url,message,api_url,diff
https://github.com/junit-team/junit4/commit/3171c4b29cb207e71fc2f752f0fbcb235bc8e784,"Relicense JUnit from CPL to EPL  <enter> EPL is the successor version of the CPL this makes re-licensing possible without seeking the approval of all contributors. <enter> CPL is actively hurting JUnit adaptation, it the following cases the deciding factor against JUnit was CPL. In both cases EPL would have been fine. * Netbeans can't ship JUnit [4] * OpenJDK uses TestNG instead of JUnit [5] <enter> Mike Milinkovich from the Eclipse Foundation wrote [1] <enter> > Back in 2009, the CPL was superseded by the EPL. This means that the > EPL is the successor version of the CPL. It also means that using the > CPL is the licensing equivalent of using deprecated code. > > Because the EPL is the successor version to the CPL, the 'new version > re-licensing' clause in Section 7 of the CPL applies. In other words, > you can re-license your project without seeking the approval of all > of your contributors. > The CPL and EPL basically differ by about one sentence, which you can > see here. The difference relates to the scope of patent licenses > terminated should someone sue another party for patent infringement. > This is the kind of stuff that lawyers love, but most developers > don't really care about. <enter> On the migration from CPL to EPL Mike Milinkovich wrote [2] <enter> > There was a two step process that was followed to make this happen. > First, following the terms of the CPL, IBM assigned the > responsibility to serve as the Agreement Steward of the CPL to the > Eclipse Foundation. Second, the Eclipse Foundation officially > recognized the EPL 1.0 as the new version of the CPL 1.0. In OSI > license terminology, the EPL now supersedes the CPL. > > A quick read of the two licenses will quickly show that they are very > very close. Other than their names and (previously) their Agreement > Stewards, the only substantive difference is the breadth of the > patent license termination in the event of a patent law suit. (See > the second paragraph of Section 7.) For more information on the > relationship between the CPL and the EPL see the EPL FAQ. <enter> You can find more information about the difference at [3]. <enter> The new `LICENSE.txt` is based on a plain text version of the EPL with formatted so that the diff is a clean as possible. <enter> I'll submit another pull request for the gh-pages branch. <enter>  [1]  http://mmilinkov.wordpress.com/2013/02/13/jruby-moves-to-the-epl/   [2]  http://mmilinkov.wordpress.com/2009/04/16/one-small-step-towards-reducing-license-proliferation/   [3]  http://www.eclipse.org/legal/eplfaq.php#EPLDIFFER   [4]  https://netbeans.org/community/releases/70/relnotes.html#deprecated   [5]  http://openjdk.java.net/jtreg/build.html ",https://api.github.com/repos/junit-team/junit4/commits/3171c4b29cb207e71fc2f752f0fbcb235bc8e784,"@@ -1,8 +1,8 @@
 JUnit
 
-Common Public License - v 1.0
+Eclipse Public License - v 1.0
 
-THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS COMMON PUBLIC
+THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC
 LICENSE (""AGREEMENT""). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM
 CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 
@@ -173,11 +173,7 @@ terms of this Agreement, and without further action by the parties hereto, such
 provision shall be reformed to the minimum extent necessary to make such
 provision valid and enforceable.
 
-If Recipient institutes patent litigation against a Contributor with respect to
-a patent applicable to software (including a cross-claim or counterclaim in a
-lawsuit), then any patent licenses granted by that Contributor to such
-Recipient under this Agreement shall terminate as of the date such litigation
-is filed. In addition, if Recipient institutes patent litigation against any
+If Recipient institutes patent litigation against any
 entity (including a cross-claim or counterclaim in a lawsuit) alleging that the
 Program itself (excluding combinations of the Program with other software or
 hardware) infringes such Recipient's patent(s), then such Recipient's rights
@@ -198,7 +194,7 @@ order to avoid inconsistency the Agreement is copyrighted and may only be
 modified in the following manner. The Agreement Steward reserves the right to
 publish new versions (including revisions) of this Agreement from time to time.
 No one other than the Agreement Steward has the right to modify this Agreement.
-IBM is the initial Agreement Steward. IBM may assign the responsibility to
+The Eclipse Foundation is the initial Agreement Steward. The Eclipse Foundation may assign the responsibility to
 serve as the Agreement Steward to a suitable separate entity. Each new version
 of the Agreement will be given a distinguishing version number. The Program
 (including Contributions) may always be distributed subject to the version of
@@ -16,7 +16,7 @@
   <property name=""testsrc"" location=""src/test/java"" />
   <property name=""testbin"" location=""${target}/test/java"" />
   <property name=""unjarred"" 
-            value=""**/*.jar, ${testfiles}, doc/**, README.md, .classpath, .project, cpl-v10.html"" />
+            value=""**/*.jar, ${testfiles}, doc/**, README.md, .classpath, .project, epl-v10.html"" />
 
   <property name=""binjar"" value=""junit-${version}.jar"" />
   <property name=""srcjar"" value=""junit-${version}-src.jar"" />
@@ -170,7 +170,7 @@
     </copy>
     <copy file=""README.md"" tofile=""${dist}/README.md"" />
     <copy file=""BUILDING"" tofile=""${dist}/BUILDING"" />
-    <copy file=""cpl-v10.html"" tofile=""${dist}/cpl-v10.html"" />
+    <copy file=""epl-v10.html"" tofile=""${dist}/epl-v10.html"" />
     <copy file=""build.xml"" tofile=""${dist}/build.xml"" />
   </target>
 
@@ -34,8 +34,8 @@
     </mailingLists>
     <licenses>
         <license>
-            <name>Common Public License Version 1.0</name>
-            <url>http://www.opensource.org/licenses/cpl1.0.txt</url>
+            <name>Eclipse Public License Version 1.0</name>
+            <url>http://opensource.org/licenses/eclipse-1.0.txt</url>
         </license>
     </licenses>
     <scm>
@@ -26,8 +26,8 @@
     </mailingLists>
     <licenses>
         <license>
-            <name>Common Public License Version 1.0</name>
-            <url>http://www.opensource.org/licenses/cpl1.0.txt</url>
+            <name>Eclipse Public License Version 1.0</name>
+            <url>http://opensource.org/licenses/eclipse-1.0.txt</url>
         </license>
     </licenses>
     <scm>
@@ -1,125 +0,0 @@
-<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0//EN"">
-<HTML>
-<HEAD>
-<TITLE>Common Public License - v 1.0</TITLE>
-<meta http-equiv=""Content-Type"" content=""text/html; charset=iso-8859-1"">
-</HEAD>
-
-<BODY BGCOLOR=""#FFFFFF"" VLINK=""#800000"">
-
-
-<P ALIGN=""CENTER""><B>Common Public License - v 1.0</B>
-<P><B></B><FONT SIZE=""3""></FONT>
-<P><FONT SIZE=""3""></FONT><FONT SIZE=""2"">THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS COMMON PUBLIC LICENSE (""AGREEMENT"").  ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""><B>1.  DEFINITIONS</B></FONT>
-<P><FONT SIZE=""2"">""Contribution"" means:</FONT>
-
-<UL><FONT SIZE=""2"">a) in the case of the initial Contributor, the initial code and documentation distributed under this Agreement, and<BR CLEAR=""LEFT"">
-b) in the case of each subsequent Contributor:</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">i)	 	changes to the Program, and</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">ii)		additions to the Program;</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">where such changes and/or additions to the Program originate from and are distributed by that particular Contributor.  </FONT><FONT SIZE=""2"">A Contribution 'originates' from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf.  </FONT><FONT SIZE=""2"">Contributions do not include additions to the Program which:  (i) are separate modules of software distributed in conjunction with the Program under their own license agreement, and (ii) are not derivative works of the Program.  </FONT></UL>
-
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">""Contributor"" means any person or entity that distributes the Program.</FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">""Licensed Patents "" mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone or when combined with the Program.  </FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"">""Program"" means the Contributions distributed in accordance with this Agreement.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">""Recipient"" means anyone who receives the Program under this Agreement, including all Contributors.</FONT>
-<P><FONT SIZE=""2""><B></B></FONT>
-<P><FONT SIZE=""2""><B>2.  GRANT OF RIGHTS</B></FONT>
-
-<UL><FONT SIZE=""2""></FONT><FONT SIZE=""2"">a)	</FONT><FONT SIZE=""2"">Subject to the terms of this Agreement, each Contributor hereby grants</FONT><FONT SIZE=""2""> Recipient a non-exclusive, worldwide, royalty-free copyright license to</FONT><FONT SIZE=""2"" COLOR=""#FF0000""> </FONT><FONT SIZE=""2"">reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense the Contribution of such Contributor, if any, and such derivative works, in source code and object code form.</FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT><FONT SIZE=""2"">b) 	Subject to the terms of this Agreement, each Contributor hereby grants </FONT><FONT SIZE=""2"">Recipient a non-exclusive, worldwide,</FONT><FONT SIZE=""2"" COLOR=""#008000""> </FONT><FONT SIZE=""2"">royalty-free patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in source code and object code form.  This patent license shall apply to the combination of the Contribution and the Program if, at the time the Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents.  The patent license shall not apply to any other combinations which include the Contribution.  No hardware per se is licensed hereunder.   </FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT></UL>
-
-
-<UL><FONT SIZE=""2"">c)	Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity.  Each Contributor disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise.  As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other intellectual property rights needed, if any.  For example, if a third party patent license is required to allow Recipient to distribute the Program, it is Recipient's responsibility to acquire that license before distributing the Program.</FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT></UL>
-
-
-<UL><FONT SIZE=""2"">d)	Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright license set forth in this Agreement. </FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT></UL>
-
-<P><FONT SIZE=""2""><B>3.  REQUIREMENTS</B></FONT>
-<P><FONT SIZE=""2""><B></B>A Contributor may choose to distribute the Program in object code form under its own license agreement, provided that:</FONT>
-
-<UL><FONT SIZE=""2"">a)	it complies with the terms and conditions of this Agreement; and</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">b)	its license agreement:</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">i)	effectively disclaims</FONT><FONT SIZE=""2""> on behalf of all Contributors all warranties and conditions, express and implied, including warranties or conditions of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose; </FONT></UL>
-
-
-<UL><FONT SIZE=""2"">ii) 	effectively excludes on behalf of all Contributors all liability for damages, including direct, indirect, special, incidental and consequential damages, such as lost profits; </FONT></UL>
-
-
-<UL><FONT SIZE=""2"">iii)</FONT><FONT SIZE=""2"">	states that any provisions which differ from this Agreement are offered by that Contributor alone and not by any other party; and</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">iv)	states that source code for the Program is available from such Contributor, and informs licensees how to obtain it in a reasonable manner on or through a medium customarily used for software exchange.</FONT><FONT SIZE=""2"" COLOR=""#0000FF""> </FONT><FONT SIZE=""2"" COLOR=""#FF0000""></FONT></UL>
-
-
-<UL><FONT SIZE=""2"" COLOR=""#FF0000""></FONT><FONT SIZE=""2""></FONT></UL>
-
-<P><FONT SIZE=""2"">When the Program is made available in source code form:</FONT>
-
-<UL><FONT SIZE=""2"">a)	it must be made available under this Agreement; and </FONT></UL>
-
-
-<UL><FONT SIZE=""2"">b)	a copy of this Agreement must be included with each copy of the Program.  </FONT></UL>
-
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"" COLOR=""#0000FF""><STRIKE></STRIKE></FONT>
-<P><FONT SIZE=""2"" COLOR=""#0000FF""><STRIKE></STRIKE></FONT><FONT SIZE=""2"">Contributors may not remove or alter any copyright notices contained within the Program.  </FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">Each Contributor must identify itself as the originator of its Contribution, if any, in a manner that reasonably allows subsequent Recipients to identify the originator of the Contribution.  </FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""><B>4.  COMMERCIAL DISTRIBUTION</B></FONT>
-<P><FONT SIZE=""2"">Commercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like.  While this license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering should do so in a manner which does not create potential liability for other Contributors.   Therefore, if a Contributor includes the Program in a commercial product offering, such Contributor (""Commercial Contributor"") hereby agrees to defend and indemnify every other Contributor (""Indemnified Contributor"") against any losses, damages and costs (collectively ""Losses"") arising from claims, lawsuits and other legal actions brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in connection with its distribution of the Program in a commercial product offering.  The obligations in this section do not apply to any claims or Losses relating to any actual or alleged intellectual property infringement.  In order to qualify, an Indemnified Contributor must: a) promptly notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the Commercial Contributor in, the defense and any related settlement negotiations.  The Indemnified Contributor may participate in any such claim at its own expense.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">For example, a Contributor might include the Program in a commercial product offering, Product X.  That Contributor is then a Commercial Contributor.  If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims and warranties are such Commercial Contributor's responsibility alone.  Under this section, the Commercial Contributor would have to defend claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay any damages as a result, the Commercial Contributor must pay those damages.</FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"" COLOR=""#0000FF""></FONT>
-<P><FONT SIZE=""2"" COLOR=""#0000FF""></FONT><FONT SIZE=""2""><B>5.  NO WARRANTY</B></FONT>
-<P><FONT SIZE=""2"">EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is</FONT><FONT SIZE=""2""> solely responsible for determining the appropriateness of using and distributing </FONT><FONT SIZE=""2"">the Program</FONT><FONT SIZE=""2""> and assumes all risks associated with its exercise of rights under this Agreement</FONT><FONT SIZE=""2"">, including but not limited to the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, </FONT><FONT SIZE=""2"">programs or equipment, and unavailability or interruption of operations</FONT><FONT SIZE=""2"">.  </FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""><B>6.  DISCLAIMER OF LIABILITY</B></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"">EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES </FONT><FONT SIZE=""2"">(INCLUDING WITHOUT LIMITATION LOST PROFITS),</FONT><FONT SIZE=""2""> HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""><B>7.  GENERAL</B></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"">If any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">If Recipient institutes patent litigation against a Contributor with respect to a patent applicable to software (including a cross-claim or counterclaim in a lawsuit), then any patent licenses granted by that Contributor to such Recipient under this Agreement shall terminate as of the date such litigation is filed.  In addition, if Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's rights granted under Section 2(b) shall terminate as of the date such litigation is filed. </FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">All Recipient's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance.  If all Recipient's rights under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable.  However, Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.  </FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"">Everyone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted  and may only be modified in the following manner. The Agreement Steward reserves the right to </FONT><FONT SIZE=""2"">publish new versions (including revisions) of this Agreement from time to </FONT><FONT SIZE=""2"">time. No one other than the Agreement Steward has the right to modify this Agreement. IBM is the initial Agreement Steward.   IBM may assign the responsibility to serve as the Agreement Steward to a suitable separate entity.  </FONT><FONT SIZE=""2"">Each new version of the Agreement will be given a distinguishing version number.  The Program (including Contributions) may always be distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is published, Contributor may elect to distribute the Program (including its Contributions) under the new </FONT><FONT SIZE=""2"">version.  </FONT><FONT SIZE=""2"">Except as expressly stated in Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to the intellectual property of any Contributor under this Agreement, whether expressly, </FONT><FONT SIZE=""2"">by implication, estoppel or otherwise</FONT><FONT SIZE=""2"">.</FONT><FONT SIZE=""2"">  All rights in the Program not expressly granted under this Agreement are reserved.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">This Agreement is governed by the laws of the State of New York and the intellectual property laws of the United States of America. No party to this Agreement will bring a legal action under this Agreement more than one year after the cause of action arose.  Each party waives its rights to a jury trial in any resulting litigation.</FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT>
-
-</BODY>
-
-</HTML>
\ No newline at end of file
@@ -422,9 +422,9 @@ <h1>
     <p>
       JUnit is <a href=""http://www.opensource.org/"">Open Source
       Software</a>, released
-      under <a
-      href=""http://oss.software.ibm.com/developerworks/oss/license-cpl.html"">IBM's
-      Common Public License Version 0.5</a> and hosted
+      under the <a
+      href=""http://opensource.org/licenses/eclipse-1.0.html"">
+      Eclipse Public License Version 1.0</a> and hosted
       on <a
       href=""http://sourceforge.net/projects/junit/"">SourceForge</a>.
     </p>
@@ -56,7 +56,7 @@ <h2>
 
 <br><a href=""README.html"">Release notes</a>
 <br>&nbsp;&nbsp;&nbsp; Latest JUnit release notes
-<br><a href=""cpl-v10.html"">License</a>
+<br><a href=""epl-v10.html"">License</a>
 <br>&nbsp;&nbsp;&nbsp; The terms of the common public license used for JUnit.<br>
 </blockquote>
 The following documents still describe JUnit 3.8.
@@ -0,0 +1,261 @@
+<?xml version=""1.0"" encoding=""ISO-8859-1"" ?>
+<!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">
+<html xmlns=""http://www.w3.org/1999/xhtml"">
+
+<head>
+<meta http-equiv=""Content-Type"" content=""text/html; charset=ISO-8859-1"" />
+<title>Eclipse Public License - Version 1.0</title>
+<style type=""text/css"">
+  body {
+    size: 8.5in 11.0in;
+    margin: 0.25in 0.5in 0.25in 0.5in;
+    tab-interval: 0.5in;
+    }
+  p {  	
+    margin-left: auto;
+    margin-top:  0.5em;
+    margin-bottom: 0.5em;
+    }
+  p.list {
+  	margin-left: 0.5in;
+    margin-top:  0.05em;
+    margin-bottom: 0.05em;
+    }
+  </style>
+
+</head>
+
+<body lang=""EN-US"">
+
+<h2>Eclipse Public License - v 1.0</h2>
+
+<p>THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE
+PUBLIC LICENSE (&quot;AGREEMENT&quot;). ANY USE, REPRODUCTION OR
+DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS
+AGREEMENT.</p>
+
+<p><b>1. DEFINITIONS</b></p>
+
+<p>&quot;Contribution&quot; means:</p>
+
+<p class=""list"">a) in the case of the initial Contributor, the initial
+code and documentation distributed under this Agreement, and</p>
+<p class=""list"">b) in the case of each subsequent Contributor:</p>
+<p class=""list"">i) changes to the Program, and</p>
+<p class=""list"">ii) additions to the Program;</p>
+<p class=""list"">where such changes and/or additions to the Program
+originate from and are distributed by that particular Contributor. A
+Contribution 'originates' from a Contributor if it was added to the
+Program by such Contributor itself or anyone acting on such
+Contributor's behalf. Contributions do not include additions to the
+Program which: (i) are separate modules of software distributed in
+conjunction with the Program under their own license agreement, and (ii)
+are not derivative works of the Program.</p>
+
+<p>&quot;Contributor&quot; means any person or entity that distributes
+the Program.</p>
+
+<p>&quot;Licensed Patents&quot; mean patent claims licensable by a
+Contributor which are necessarily infringed by the use or sale of its
+Contribution alone or when combined with the Program.</p>
+
+<p>&quot;Program&quot; means the Contributions distributed in accordance
+with this Agreement.</p>
+
+<p>&quot;Recipient&quot; means anyone who receives the Program under
+this Agreement, including all Contributors.</p>
+
+<p><b>2. GRANT OF RIGHTS</b></p>
+
+<p class=""list"">a) Subject to the terms of this Agreement, each
+Contributor hereby grants Recipient a non-exclusive, worldwide,
+royalty-free copyright license to reproduce, prepare derivative works
+of, publicly display, publicly perform, distribute and sublicense the
+Contribution of such Contributor, if any, and such derivative works, in
+source code and object code form.</p>
+
+<p class=""list"">b) Subject to the terms of this Agreement, each
+Contributor hereby grants Recipient a non-exclusive, worldwide,
+royalty-free patent license under Licensed Patents to make, use, sell,
+offer to sell, import and otherwise transfer the Contribution of such
+Contributor, if any, in source code and object code form. This patent
+license shall apply to the combination of the Contribution and the
+Program if, at the time the Contribution is added by the Contributor,
+such addition of the Contribution causes such combination to be covered
+by the Licensed Patents. The patent license shall not apply to any other
+combinations which include the Contribution. No hardware per se is
+licensed hereunder.</p>
+
+<p class=""list"">c) Recipient understands that although each Contributor
+grants the licenses to its Contributions set forth herein, no assurances
+are provided by any Contributor that the Program does not infringe the
+patent or other intellectual property rights of any other entity. Each
+Contributor disclaims any liability to Recipient for claims brought by
+any other entity based on infringement of intellectual property rights
+or otherwise. As a condition to exercising the rights and licenses
+granted hereunder, each Recipient hereby assumes sole responsibility to
+secure any other intellectual property rights needed, if any. For
+example, if a third party patent license is required to allow Recipient
+to distribute the Program, it is Recipient's responsibility to acquire
+that license before distributing the Program.</p>
+
+<p class=""list"">d) Each Contributor represents that to its knowledge it
+has sufficient copyright rights in its Contribution, if any, to grant
+the copyright license set forth in this Agreement.</p>
+
+<p><b>3. REQUIREMENTS</b></p>
+
+<p>A Contributor may choose to distribute the Program in object code
+form under its own license agreement, provided that:</p>
+
+<p class=""list"">a) it complies with the terms and conditions of this
+Agreement; and</p>
+
+<p class=""list"">b) its license agreement:</p>
+
+<p class=""list"">i) effectively disclaims on behalf of all Contributors
+all warranties and conditions, express and implied, including warranties
+or conditions of title and non-infringement, and implied warranties or
+conditions of merchantability and fitness for a particular purpose;</p>
+
+<p class=""list"">ii) effectively excludes on behalf of all Contributors
+all liability for damages, including direct, indirect, special,
+incidental and consequential damages, such as lost profits;</p>
+
+<p class=""list"">iii) states that any provisions which differ from this
+Agreement are offered by that Contributor alone and not by any other
+party; and</p>
+
+<p class=""list"">iv) states that source code for the Program is available
+from such Contributor, and informs licensees how to obtain it in a
+reasonable manner on or through a medium customarily used for software
+exchange.</p>
+
+<p>When the Program is made available in source code form:</p>
+
+<p class=""list"">a) it must be made available under this Agreement; and</p>
+
+<p class=""list"">b) a copy of this Agreement must be included with each
+copy of the Program.</p>
+
+<p>Contributors may not remove or alter any copyright notices contained
+within the Program.</p>
+
+<p>Each Contributor must identify itself as the originator of its
+Contribution, if any, in a manner that reasonably allows subsequent
+Recipients to identify the originator of the Contribution.</p>
+
+<p><b>4. COMMERCIAL DISTRIBUTION</b></p>
+
+<p>Commercial distributors of software may accept certain
+responsibilities with respect to end users, business partners and the
+like. While this license is intended to facilitate the commercial use of
+the Program, the Contributor who includes the Program in a commercial
+product offering should do so in a manner which does not create
+potential liability for other Contributors. Therefore, if a Contributor
+includes the Program in a commercial product offering, such Contributor
+(&quot;Commercial Contributor&quot;) hereby agrees to defend and
+indemnify every other Contributor (&quot;Indemnified Contributor&quot;)
+against any losses, damages and costs (collectively &quot;Losses&quot;)
+arising from claims, lawsuits and other legal actions brought by a third
+party against the Indemnified Contributor to the extent caused by the
+acts or omissions of such Commercial Contributor in connection with its
+distribution of the Program in a commercial product offering. The
+obligations in this section do not apply to any claims or Losses
+relating to any actual or alleged intellectual property infringement. In
+order to qualify, an Indemnified Contributor must: a) promptly notify
+the Commercial Contributor in writing of such claim, and b) allow the
+Commercial Contributor to control, and cooperate with the Commercial
+Contributor in, the defense and any related settlement negotiations. The
+Indemnified Contributor may participate in any such claim at its own
+expense.</p>
+
+<p>For example, a Contributor might include the Program in a commercial
+product offering, Product X. That Contributor is then a Commercial
+Contributor. If that Commercial Contributor then makes performance
+claims, or offers warranties related to Product X, those performance
+claims and warranties are such Commercial Contributor's responsibility
+alone. Under this section, the Commercial Contributor would have to
+defend claims against the other Contributors related to those
+performance claims and warranties, and if a court requires any other
+Contributor to pay any damages as a result, the Commercial Contributor
+must pay those damages.</p>
+
+<p><b>5. NO WARRANTY</b></p>
+
+<p>EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS
+PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS
+OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION,
+ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY
+OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely
+responsible for determining the appropriateness of using and
+distributing the Program and assumes all risks associated with its
+exercise of rights under this Agreement , including but not limited to
+the risks and costs of program errors, compliance with applicable laws,
+damage to or loss of data, programs or equipment, and unavailability or
+interruption of operations.</p>
+
+<p><b>6. DISCLAIMER OF LIABILITY</b></p>
+
+<p>EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT
+NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING
+WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR
+DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>
+
+<p><b>7. GENERAL</b></p>
+
+<p>If any provision of this Agreement is invalid or unenforceable under
+applicable law, it shall not affect the validity or enforceability of
+the remainder of the terms of this Agreement, and without further action
+by the parties hereto, such provision shall be reformed to the minimum
+extent necessary to make such provision valid and enforceable.</p>
+
+<p>If Recipient institutes patent litigation against any entity
+(including a cross-claim or counterclaim in a lawsuit) alleging that the
+Program itself (excluding combinations of the Program with other
+software or hardware) infringes such Recipient's patent(s), then such
+Recipient's rights granted under Section 2(b) shall terminate as of the
+date such litigation is filed.</p>
+
+<p>All Recipient's rights under this Agreement shall terminate if it
+fails to comply with any of the material terms or conditions of this
+Agreement and does not cure such failure in a reasonable period of time
+after becoming aware of such noncompliance. If all Recipient's rights
+under this Agreement terminate, Recipient agrees to cease use and
+distribution of the Program as soon as reasonably practicable. However,
+Recipient's obligations under this Agreement and any licenses granted by
+Recipient relating to the Program shall continue and survive.</p>
+
+<p>Everyone is permitted to copy and distribute copies of this
+Agreement, but in order to avoid inconsistency the Agreement is
+copyrighted and may only be modified in the following manner. The
+Agreement Steward reserves the right to publish new versions (including
+revisions) of this Agreement from time to time. No one other than the
+Agreement Steward has the right to modify this Agreement. The Eclipse
+Foundation is the initial Agreement Steward. The Eclipse Foundation may
+assign the responsibility to serve as the Agreement Steward to a
+suitable separate entity. Each new version of the Agreement will be
+given a distinguishing version number. The Program (including
+Contributions) may always be distributed subject to the version of the
+Agreement under which it was received. In addition, after a new version
+of the Agreement is published, Contributor may elect to distribute the
+Program (including its Contributions) under the new version. Except as
+expressly stated in Sections 2(a) and 2(b) above, Recipient receives no
+rights or licenses to the intellectual property of any Contributor under
+this Agreement, whether expressly, by implication, estoppel or
+otherwise. All rights in the Program not expressly granted under this
+Agreement are reserved.</p>
+
+<p>This Agreement is governed by the laws of the State of New York and
+the intellectual property laws of the United States of America. No party
+to this Agreement will bring a legal action under this Agreement more
+than one year after the cause of action arose. Each party waives its
+rights to a jury trial in any resulting litigation.</p>
+
+</body>
+
+</html>
\ No newline at end of file
@@ -16,8 +16,8 @@
     </organization>
     <licenses>
         <license>
-            <name>Common Public License Version 1.0</name>
-            <url>http://www.opensource.org/licenses/cpl1.0.txt</url>
+            <name>Eclipse Public License 1.0</name>
+            <url>http://opensource.org/licenses/eclipse-1.0.txt</url>
             <distribution>repo</distribution>
         </license>
     </licenses>
"
https://github.com/spring-projects/spring-boot/commit/6c8f8c9d827a5340f9e6493c14d8c252d1f0d52a,"Better diagnotics when ESCF subclass breaks with custom management port  <enter> When a custom management.port is used, the child context is configured with an EmbeddedServletContainerFactory bean that has the same class as the parent context’s EmbeddedServletContainerFactory bean. This ensures that the child context uses the same type of embedded container as its parent when there are multiple embedded containers on the classpath. It also causes a failure when the custom EmbeddedServletContainerFactory subclass cannot be instantiated, for example because it’s an anonymous inner-class. <enter> This commit improves the diagnostics so that we fail fast with an information exception message when we detect that the embedded servlet container factory bean’s class cannot be instantiated. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/6c8f8c9d827a5340f9e6493c14d8c252d1f0d52a,"@@ -17,6 +17,7 @@
 package org.springframework.boot.actuate.autoconfigure;
 
 import java.io.IOException;
+import java.lang.reflect.Modifier;
 
 import javax.servlet.FilterChain;
 import javax.servlet.Servlet;
@@ -28,6 +29,7 @@
 import org.apache.commons.logging.LogFactory;
 
 import org.springframework.beans.BeansException;
+import org.springframework.beans.FatalBeanException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
@@ -188,20 +190,38 @@ private void createChildManagementContext() {
 	private void registerEmbeddedServletContainerFactory(
 			AnnotationConfigEmbeddedWebApplicationContext childContext) {
 		try {
-			EmbeddedServletContainerFactory servletContainerFactory = this.applicationContext
-					.getBean(EmbeddedServletContainerFactory.class);
 			ConfigurableListableBeanFactory beanFactory = childContext.getBeanFactory();
 			if (beanFactory instanceof BeanDefinitionRegistry) {
 				BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
 				registry.registerBeanDefinition(""embeddedServletContainerFactory"",
-						new RootBeanDefinition(servletContainerFactory.getClass()));
+						new RootBeanDefinition(
+								determineEmbeddedServletContainerFactoryClass()));
 			}
 		}
 		catch (NoSuchBeanDefinitionException ex) {
 			// Ignore and assume auto-configuration
 		}
 	}
 
+	private Class<?> determineEmbeddedServletContainerFactoryClass()
+			throws NoSuchBeanDefinitionException {
+		Class<?> servletContainerFactoryClass = this.applicationContext
+				.getBean(EmbeddedServletContainerFactory.class).getClass();
+		if (cannotBeInstantiated(servletContainerFactoryClass)) {
+			throw new FatalBeanException(""EmbeddedServletContainerFactory implementation ""
+					+ servletContainerFactoryClass.getName() + "" cannot be instantiated. ""
+					+ ""To allow a separate management port to be used, a top-level class ""
+					+ ""or static inner class should be used instead"");
+		}
+		return servletContainerFactoryClass;
+	}
+
+	private boolean cannotBeInstantiated(Class<?> clazz) {
+		return clazz.isLocalClass()
+				|| (clazz.isMemberClass() && !Modifier.isStatic(clazz.getModifiers()))
+				|| clazz.isAnonymousClass();
+	}
+
 	/**
 	 * Add an alias for 'local.management.port' that actually resolves using
 	 * 'local.server.port'.
"
https://github.com/spring-projects/spring-boot/commit/6dc14af92dbfa7b5281072d9fdde241ce0da3679,"Update view of bean types when an override is detected  <enter> Previously, when a bean was overridden and its type changes, BeanTypeRegistry could be left with a stale view of the bean's type. This would lead to incorrect bean condition evaluation as conditions would match or not match based on the bean's old type. <enter> This commit updates the type registry to refresh its view of a bean's type when its definition changes. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/6dc14af92dbfa7b5281072d9fdde241ce0da3679,"@@ -76,7 +76,7 @@ final class BeanTypeRegistry implements SmartInitializingSingleton {
 
 	private final Map<String, Class<?>> beanTypes = new HashMap<String, Class<?>>();
 
-	private int lastBeanDefinitionCount = 0;
+	private final Map<String, RootBeanDefinition> beanDefinitions = new HashMap<String, RootBeanDefinition>();
 
 	private BeanTypeRegistry(DefaultListableBeanFactory beanFactory) {
 		this.beanFactory = beanFactory;
@@ -146,7 +146,7 @@ Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {
 	public void afterSingletonsInstantiated() {
 		// We're done at this point, free up some memory
 		this.beanTypes.clear();
-		this.lastBeanDefinitionCount = 0;
+		this.beanDefinitions.clear();
 	}
 
 	private void addBeanType(String name) {
@@ -159,10 +159,23 @@ else if (!this.beanFactory.isAlias(name)) {
 	}
 
 	private void addBeanTypeForNonAliasDefinition(String name) {
+		addBeanTypeForNonAliasDefinition(name, getBeanDefinition(name));
+	}
+
+	private RootBeanDefinition getBeanDefinition(String name) {
+		try {
+			return (RootBeanDefinition) this.beanFactory.getMergedBeanDefinition(name);
+		}
+		catch (BeanDefinitionStoreException ex) {
+			logIgnoredError(""unresolvable metadata in bean definition"", name, ex);
+			return null;
+		}
+	}
+
+	private void addBeanTypeForNonAliasDefinition(String name,
+			RootBeanDefinition beanDefinition) {
 		try {
 			String factoryName = BeanFactory.FACTORY_BEAN_PREFIX + name;
-			RootBeanDefinition beanDefinition = (RootBeanDefinition) this.beanFactory
-					.getMergedBeanDefinition(name);
 			if (!beanDefinition.isAbstract()
 					&& !requiresEagerInit(beanDefinition.getFactoryBeanName())) {
 				if (this.beanFactory.isFactoryBean(factoryName)) {
@@ -176,15 +189,12 @@ private void addBeanTypeForNonAliasDefinition(String name) {
 					this.beanTypes.put(name, this.beanFactory.getType(name));
 				}
 			}
+			this.beanDefinitions.put(name, beanDefinition);
 		}
 		catch (CannotLoadBeanClassException ex) {
 			// Probably contains a placeholder
 			logIgnoredError(""bean class loading failure for bean"", name, ex);
 		}
-		catch (BeanDefinitionStoreException ex) {
-			// Probably contains a placeholder
-			logIgnoredError(""unresolvable metadata in bean definition"", name, ex);
-		}
 	}
 
 	private void logIgnoredError(String message, String name, Exception ex) {
@@ -199,15 +209,24 @@ private boolean requiresEagerInit(String factoryBeanName) {
 	}
 
 	private void updateTypesIfNecessary() {
-		if (this.lastBeanDefinitionCount != this.beanFactory.getBeanDefinitionCount()) {
-			Iterator<String> names = this.beanFactory.getBeanNamesIterator();
-			while (names.hasNext()) {
-				String name = names.next();
-				if (!this.beanTypes.containsKey(name)) {
-					addBeanType(name);
+		Iterator<String> names = this.beanFactory.getBeanNamesIterator();
+		while (names.hasNext()) {
+			String name = names.next();
+			if (!this.beanTypes.containsKey(name)) {
+				addBeanType(name);
+			}
+			else {
+				if (!this.beanFactory.isAlias(name)
+						&& !this.beanFactory.containsSingleton(name)) {
+					RootBeanDefinition beanDefinition = getBeanDefinition(name);
+					RootBeanDefinition existingDefinition = this.beanDefinitions.put(name,
+							beanDefinition);
+					if (existingDefinition != null
+							&& !beanDefinition.equals(existingDefinition)) {
+						addBeanTypeForNonAliasDefinition(name, beanDefinition);
+					}
 				}
 			}
-			this.lastBeanDefinitionCount = this.beanFactory.getBeanDefinitionCount();
 		}
 	}
 
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -139,6 +139,16 @@ public void beanProducedByFactoryBeanIsConsideredWhenMatchingOnAnnotation() {
 		assertThat(this.context.getBeansOfType(ExampleBean.class)).hasSize(1);
 	}
 
+	@Test
+	public void conditionEvaluationConsidersChangeInTypeWhenBeanIsOverridden() {
+		this.context.register(OriginalDefinition.class, OverridingDefinition.class,
+				ConsumingConfiguration.class);
+		this.context.refresh();
+		assertThat(this.context.containsBean(""testBean"")).isTrue();
+		assertThat(this.context.getBean(Integer.class)).isEqualTo(1);
+		assertThat(this.context.getBeansOfType(ConsumingConfiguration.class)).isEmpty();
+	}
+
 	@Configuration
 	@ConditionalOnBean(name = ""foo"")
 	protected static class OnBeanNameConfiguration {
@@ -311,4 +321,35 @@ public String toString() {
 
 	}
 
+	@Configuration
+	public static class OriginalDefinition {
+
+		@Bean
+		public String testBean() {
+			return ""test"";
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnBean(String.class)
+	public static class OverridingDefinition {
+
+		@Bean
+		public Integer testBean() {
+			return 1;
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnBean(String.class)
+	public static class ConsumingConfiguration {
+
+		ConsumingConfiguration(String testBean) {
+
+		}
+
+	}
+
 }
"
https://github.com/square/okhttp/commit/868ee844458eda9ee7b1b6f9a5238b7c3f84c0e4,"Drop our one remaining DSS cipher suite.  <enter> Tracking Chrome and Firefox, which have also dropped this cipher suite. <enter> This is the only cipher suite change since the last update. See our cipher suites spreadsheet for a comparison:  https://goo.gl/dWXbi0  <enter>  Closes   <issue_link> ",https://api.github.com/repos/square/okhttp/commits/868ee844458eda9ee7b1b6f9a5238b7c3f84c0e4,"@@ -37,7 +37,7 @@
  */
 public final class ConnectionSpec {
 
-  // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+  // This is a subset of the cipher suites supported in Chrome 46, current as of 2015-11-05.
   // All of these suites are available on Android 5.0; earlier releases support a subset of
   // these suites. https://github.com/square/okhttp/issues/330
   private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
@@ -53,7 +53,6 @@ public final class ConnectionSpec {
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
"
https://github.com/spring-projects/spring-boot/commit/e233ea7f546fcbc5fccf972bc70c26373103444c,Fix undertow access_log file name  <enter> Undertow 1.3.2 changed the default access log file suffix from '.log' to just 'log'. Thus we need to adapt the file name pattern to include the missing dot. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/e233ea7f546fcbc5fccf972bc70c26373103444c,"@@ -384,7 +384,7 @@ private AccessLogHandler createAccessLogHandler(HttpHandler handler) {
 		try {
 			createAccessLogDirectoryIfNecessary();
 			AccessLogReceiver accessLogReceiver = new DefaultAccessLogReceiver(
-					createWorker(), this.accessLogDirectory, ""access_log"");
+					createWorker(), this.accessLogDirectory, ""access_log."");
 			String formatString = (this.accessLogPattern != null) ? this.accessLogPattern
 					: ""common"";
 			return new AccessLogHandler(handler, accessLogReceiver, formatString,
"
https://github.com/spring-projects/spring-boot/commit/247c596f8ceb657800e86d0ca59d4816aa67026b,Remove duplicate console appender from Actuator sample's logback config  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/247c596f8ceb657800e86d0ca59d4816aa67026b,"@@ -1,7 +1,6 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 <configuration>
 	<include resource=""org/springframework/boot/logging/logback/base.xml"" />
-	<include resource=""org/springframework/boot/logging/logback/console-appender.xml"" />
 	<root level=""INFO"">
 		<appender-ref ref=""CONSOLE"" />
 	</root>
"
https://github.com/junit-team/junit4/commit/591fcae09c6470a03ade7d608773f8f633409bc2,Added more Javadoc to Assert for messages and when they are displayed.  <enter> Put versiontag back into Version. ,https://api.github.com/repos/junit-team/junit4/commits/591fcae09c6470a03ade7d608773f8f633409bc2,"@@ -1,7 +1,7 @@
 package junit.framework;
 
 /**
- * A set of assert methods.
+ * A set of assert methods.  Messages are only displayed when an assert fails.
  */
 
 public class Assert {
@@ -59,20 +59,20 @@ static public void assertFalse(boolean condition) {
 		assertFalse(null, condition);
 	}
 	/**
-	 * Fails a test with the given message. 
+	 * Fails a test with the given message.
 	 */
 	static public void fail(String message) {
 		throw new AssertionFailedError(message);
 	}
 	/**
-	 * Fails a test with no message. 
+	 * Fails a test with no message.
 	 */
 	static public void fail() {
 		fail(null);
 	}
 	/**
 	 * Asserts that two objects are equal. If they are not
-	 * an AssertionFailedError is thrown.
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, Object expected, Object actual) {
 		if (expected == null && actual == null)
@@ -89,7 +89,8 @@ static public void assertEquals(Object expected, Object actual) {
 	    assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two doubles are equal concerning a delta. If the expected
+	 * Asserts that two doubles are equal concerning a delta.  If they are not
+	 * an AssertionFailedError is thrown with the given message.  If the expected
 	 * value is infinity then the delta value is ignored.
 	 */
 	static public void assertEquals(String message, double expected, double actual, double delta) {
@@ -109,7 +110,8 @@ static public void assertEquals(double expected, double actual, double delta) {
 	    assertEquals(null, expected, actual, delta);
 	}
 	/**
-	 * Asserts that two floats are equal concerning a delta. If the expected
+	 * Asserts that two floats are equal concerning a delta. If they are not
+	 * an AssertionFailedError is thrown with the given message.  If the expected
 	 * value is infinity then the delta value is ignored.
 	 */
 	static public void assertEquals(String message, float expected, float actual, float delta) {
@@ -129,7 +131,8 @@ static public void assertEquals(float expected, float actual, float delta) {
 		assertEquals(null, expected, actual, delta);
 	}
 	/**
-	 * Asserts that two longs are equal.
+	 * Asserts that two longs are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, long expected, long actual) {
 	    assertEquals(message, new Long(expected), new Long(actual));
@@ -141,7 +144,8 @@ static public void assertEquals(long expected, long actual) {
 	    assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two booleans are equal.
+	 * Asserts that two booleans are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, boolean expected, boolean actual) {
     		assertEquals(message, new Boolean(expected), new Boolean(actual));
@@ -153,7 +157,8 @@ static public void assertEquals(boolean expected, boolean actual) {
 		assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two bytes are equal.
+	 * Asserts that two bytes are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
   	static public void assertEquals(String message, byte expected, byte actual) {
 		assertEquals(message, new Byte(expected), new Byte(actual));
@@ -165,7 +170,8 @@ static public void assertEquals(byte expected, byte actual) {
 		assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two chars are equal.
+	 * Asserts that two chars are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
   	static public void assertEquals(String message, char expected, char actual) {
     		assertEquals(message, new Character(expected), new Character(actual));
@@ -177,7 +183,8 @@ static public void assertEquals(char expected, char actual) {
 		assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two shorts are equal.
+	 * Asserts that two shorts are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, short expected, short actual) {
     		assertEquals(message, new Short(expected), new Short(actual));
@@ -189,7 +196,8 @@ static public void assertEquals(short expected, short actual) {
 		assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two ints are equal.
+	 * Asserts that two ints are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
   	static public void assertEquals(String message, int expected, int actual) {
 		assertEquals(message, new Integer(expected), new Integer(actual));
@@ -207,10 +215,11 @@ static public void assertNotNull(Object object) {
 		assertNotNull(null, object);
 	}
 	/**
-	 * Asserts that an object isn't null.
+	 * Asserts that an object isn't null. If it is
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertNotNull(String message, Object object) {
-		assertTrue(message, object != null); 
+		assertTrue(message, object != null);
 	}
 	/**
 	 * Asserts that an object is null.
@@ -219,14 +228,15 @@ static public void assertNull(Object object) {
 		assertNull(null, object);
 	}
 	/**
-	 * Asserts that an object is null.
+	 * Asserts that an object is null.  If it is not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertNull(String message, Object object) {
-		assertTrue(message, object == null); 
+		assertTrue(message, object == null);
 	}
 	/**
 	 * Asserts that two objects refer to the same object. If they are not
-	 * an AssertionFailedError is thrown.
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertSame(String message, Object expected, Object actual) {
 		if (expected == actual)
@@ -242,7 +252,7 @@ static public void assertSame(Object expected, Object actual) {
 	}
  	/**
  	 * Asserts that two objects refer to the same object. If they are not
- 	 * an AssertionFailedError is thrown.
+ 	 * an AssertionFailedError is thrown with the given message.
  	 */
 	static public void assertNotSame(String message, Object expected, Object actual) {
 		if (expected == actual)
@@ -255,7 +265,7 @@ static public void assertNotSame(String message, Object expected, Object actual)
 	static public void assertNotSame(Object expected, Object actual) {
 		assertNotSame(null, expected, actual);
 	}
- 	
+
 	static private void failSame(String message, Object expected, Object actual) {
 		String formatted= """";
  		if (message != null)
@@ -1,14 +1,14 @@
-package junit.runner;   
-    
-/**   
- * This class defines the current version of JUnit   
- */   
-public class Version {   
-	private Version() {   
-		// don't instantiate   
-	}   
+package junit.runner;
 
-	public static String id() {   
-		return ""3.7"";   
-	}   
-} 
+/**
+ * This class defines the current version of JUnit
+ */
+public class Version {
+	private Version() {
+		// don't instantiate
+	}
+
+	public static String id() {
+		return ""@version@"";
+	}
+}
"
https://github.com/junit-team/junit4/commit/870289f3272917f312de6902b8b6bdc43552d4b7,Simplify Filter implementation for backward compatibility ,https://api.github.com/repos/junit-team/junit4/commits/870289f3272917f312de6902b8b6bdc43552d4b7,"@@ -28,7 +28,7 @@ public JUnit4TestAdapter(final Class<?> newTestClass,
 			JUnit4TestAdapterCache cache) {
 		fCache = cache;
 		fNewTestClass = newTestClass;
-		fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();
+		fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();
 	}
 
 	public int countTestCases() {
@@ -50,20 +50,21 @@ public Class<?> getTestClass() {
 	}
 	
 	public Description getDescription() {
-		Description description= fRunner.getDescription();		
-		return removeIgnored(description);
+		return fRunner.getDescription();
 	}
 
-	private Description removeIgnored(Description description) {
-		if (isIgnored(description))
-			return Description.EMPTY;
-		Description result = description.childlessCopy();
-		for (Description each : description.getChildren()) {
-			Description child= removeIgnored(each);
-			if (! child.isEmpty())
-				result.addChild(child);
-		}
-		return result;
+	private Filter removeIgnored() {
+		return new Filter() {			
+			@Override
+			public boolean shouldRun(Description description) {
+				return !isIgnored(description);
+			}
+			
+			@Override
+			public String describe() {
+				return ""not ignored"";
+			}
+		};
 	}
 
 	private boolean isIgnored(Description description) {
@@ -13,6 +13,7 @@
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Request;
 import org.junit.runner.Result;
+import org.junit.runner.Runner;
 
 public class SuiteMethodTest {
 	public static boolean wasRun;
@@ -21,94 +22,108 @@ static public class OldTest extends TestCase {
 		public OldTest(String name) {
 			super(name);
 		}
-		
+
 		public static junit.framework.Test suite() {
 			TestSuite result= new TestSuite();
 			result.addTest(new OldTest(""notObviouslyATest""));
 			return result;
 		}
-		
+
 		public void notObviouslyATest() {
 			wasRun= true;
 		}
 	}
-	
-	@Test public void makeSureSuiteIsCalled() {
+
+	@Test
+	public void makeSureSuiteIsCalled() {
 		wasRun= false;
 		JUnitCore.runClasses(OldTest.class);
 		assertTrue(wasRun);
 	}
-	
+
 	static public class NewTest {
-		@Test public void sample() {
+		@Test
+		public void sample() {
 			wasRun= true;
 		}
 
 		public static junit.framework.Test suite() {
 			return new JUnit4TestAdapter(NewTest.class);
 		}
 	}
-	
-	@Test public void makeSureSuiteWorksWithJUnit4Classes() {
+
+	@Test
+	public void makeSureSuiteWorksWithJUnit4Classes() {
 		wasRun= false;
 		JUnitCore.runClasses(NewTest.class);
 		assertTrue(wasRun);
 	}
-	
 
 	public static class CompatibilityTest {
-		@Ignore	@Test
+		@Ignore
+		@Test
 		public void ignored() {
 		}
-		
+
 		public static junit.framework.Test suite() {
 			return new JUnit4TestAdapter(CompatibilityTest.class);
 		}
 	}
-	
-	@Test public void descriptionAndRunNotificationsAreConsistent() {
+
+	// when executing as JUnit 3, ignored tests are stripped out before execution
+	@Test
+	public void descriptionAndRunNotificationsAreConsistent() {
 		Result result= JUnitCore.runClasses(CompatibilityTest.class);
 		assertEquals(0, result.getIgnoreCount());
-		
-		Description description= Request.aClass(CompatibilityTest.class).getRunner().getDescription();
-		assertEquals(0, description.getChildren().size());
+
+		Runner runner= Request.aClass(CompatibilityTest.class).getRunner();
+		Description description= runner.getDescription();
+		assertEquals(1, description.getChildren().size());
+		assertEquals(""initializationError"", description.getChildren().get(0)
+				.getMethodName());
 	}
-	
+
 	static public class NewTestSuiteFails {
-		@Test public void sample() {
+		@Test
+		public void sample() {
 			wasRun= true;
 		}
-		
+
 		public static junit.framework.Test suite() {
 			fail(""called with JUnit 4 runner"");
 			return null;
 		}
 	}
-	
-	@Test public void suiteIsUsedWithJUnit4Classes() {
+
+	@Test
+	public void suiteIsUsedWithJUnit4Classes() {
 		wasRun= false;
 		Result result= JUnitCore.runClasses(NewTestSuiteFails.class);
 		assertEquals(1, result.getFailureCount());
 		assertFalse(wasRun);
 	}
-	
+
 	static public class NewTestSuiteNotUsed {
 		private static boolean wasIgnoredRun;
-		
-		@Test public void sample() {
+
+		@Test
+		public void sample() {
 			wasRun= true;
 		}
-		
-		@Ignore @Test public void ignore() {
+
+		@Ignore
+		@Test
+		public void ignore() {
 			wasIgnoredRun= true;
 		}
-		
+
 		public static junit.framework.Test suite() {
 			return new JUnit4TestAdapter(NewTestSuiteNotUsed.class);
 		}
 	}
-	
-	@Test public void makeSureSuiteNotUsedWithJUnit4Classes2() {
+
+	@Test
+	public void makeSureSuiteNotUsedWithJUnit4Classes2() {
 		wasRun= false;
 		NewTestSuiteNotUsed.wasIgnoredRun= false;
 		Result res= JUnitCore.runClasses(NewTestSuiteNotUsed.class);
"
https://github.com/square/retrofit/commit/c0cc4cb5bbf688a11dda5531f009300b20005e61,RxJava 1.0.14 with an important Android fix.  <enter> Just in case someone is relying on the transitive dependency. ,https://api.github.com/repos/square/retrofit/commits/c0cc4cb5bbf688a11dda5531f009300b20005e61,"@@ -54,7 +54,7 @@
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.13</rxjava.version>
+    <rxjava.version>1.0.14</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.3.1</gson.version>
"
https://github.com/apache/dubbo/commit/e8d85386bc7869d3a6e5b27c12ec7784c74bc2d6,Format code ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/e8d85386bc7869d3a6e5b27c12ec7784c74bc2d6,"@@ -36,7 +36,7 @@
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
     public static final String NAME = ""roundrobin"";
     
-    private static int RECYCLE_PERIOD = 60000;
+    private static final int RECYCLE_PERIOD = 60000;
     
     protected static class WeightedRoundRobin {
         private int weight;
@@ -47,7 +47,7 @@ public class ConditionRouter extends AbstractRouter {
     public static final String NAME = ""condition"";
 
     private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class);
-    protected static Pattern ROUTE_PATTERN = Pattern.compile(""([&!=,]*)\\s*([^&!=,\\s]+)"");
+    protected static final Pattern ROUTE_PATTERN = Pattern.compile(""([&!=,]*)\\s*([^&!=,\\s]+)"");
     protected Map<String, MatchPair> whenCondition;
     protected Map<String, MatchPair> thenCondition;
 
@@ -156,9 +156,9 @@ private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,
         if ((selected != null && selected.contains(invoker))
                 || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
             try {
-                Invoker<T> rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
-                if (rinvoker != null) {
-                    invoker = rinvoker;
+                Invoker<T> rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
+                if (rInvoker != null) {
+                    invoker = rInvoker;
                 } else {
                     //Check the index of current selected invoker, if it's not the last one, choose the one at index+1.
                     int index = invokers.indexOf(invoker);
@@ -43,7 +43,7 @@ public class QosProcessHandler extends ByteToMessageDecoder {
     // true means to accept foreign IP
     private boolean acceptForeignIp;
 
-    public static String prompt = ""dubbo>"";
+    public static final String prompt = ""dubbo>"";
 
     public QosProcessHandler(String welcome, boolean acceptForeignIp) {
         this.welcome = welcome;
@@ -44,9 +44,9 @@ public class HeaderExchangeHandler implements ChannelHandlerDelegate {
 
     protected static final Logger logger = LoggerFactory.getLogger(HeaderExchangeHandler.class);
 
-    public static String KEY_READ_TIMESTAMP = HeartbeatHandler.KEY_READ_TIMESTAMP;
+    public static final String KEY_READ_TIMESTAMP = HeartbeatHandler.KEY_READ_TIMESTAMP;
 
-    public static String KEY_WRITE_TIMESTAMP = HeartbeatHandler.KEY_WRITE_TIMESTAMP;
+    public static final String KEY_WRITE_TIMESTAMP = HeartbeatHandler.KEY_WRITE_TIMESTAMP;
 
     private final ExchangeHandler handler;
 
@@ -31,9 +31,9 @@ public class HeartbeatHandler extends AbstractChannelHandlerDelegate {
 
     private static final Logger logger = LoggerFactory.getLogger(HeartbeatHandler.class);
 
-    public static String KEY_READ_TIMESTAMP = ""READ_TIMESTAMP"";
+    public static final String KEY_READ_TIMESTAMP = ""READ_TIMESTAMP"";
 
-    public static String KEY_WRITE_TIMESTAMP = ""WRITE_TIMESTAMP"";
+    public static final String KEY_WRITE_TIMESTAMP = ""WRITE_TIMESTAMP"";
 
     public HeartbeatHandler(ChannelHandler handler) {
         super(handler);
"
https://github.com/square/okhttp/commit/6cf56de5d0701ff26aa6043c552e17c4665c1287,"Return HttpResponseCache to previous (e.g. KitKat) behavior  <enter> This change required to handle this Android scenario: <enter> When this version of OkHttp is packaged into Android in a future release (in com.android.okhttp...) there is a possibility that an older version of OkHttp bundled with application (in com.squareup.okhttp...) will pick up the newer HttpResponseCache via ResponseCache.getDefault(). It will attempt to use the get() / put() methods. Commit  <otherCommit_link>  was intended to restore HttpResponseCache get() and put() and avoid the UnsupportedOperationException that would be thrown. <enter> Unfortunately, it didn't quite do it: <enter> In KitKat and older versions OkHttp, in HttpResponseCache the behavior was to ignore any calls to put(URI, URLConnection) including any HttpURLConnection/HttpsURLConnection that wasn't its own (i.e. only ones from com.android.okhttp would be cached). The previous fix to HttpResponseCache re-introduced get()/put() but didn't implement the necessary instanceof checks. <enter> Jesse also informs me that coexistance with other implementations of HttpURLConnection is not required (since OkHttp replaces the HTTP implementation on the desktop). I have also since discovered that HttpResponseCache didn't implement the cache-control logic required to follow the letter of the Java API anyway, which means that HttpResponseCache is not suitable for use in cases where the Http(s)URLConnection implementation expects a fully compliant implementation. <enter> Also addressed nits from  <otherCommit_link> . ",https://api.github.com/repos/square/okhttp/commits/6cf56de5d0701ff26aa6043c552e17c4665c1287,"@@ -53,6 +53,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
@@ -1861,28 +1862,60 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals(""foo"", connection.getHeaderField(""etag""));
   }
 
-  // For compatibility with Java HttpURLConnections, and when Android-bundled and and older
-  // app-bundled OkHttp library are in use at the same time in an Android app, the HttpResponseCache
-  // must behave as a working, Java compliant, ResponseCache.
-  @Test public void testHttpResponseCacheIsValidResponseCache() throws Exception {
+  // Older versions of OkHttp use ResponseCache.get() and ResponseCache.put(). For compatibility
+  // with Android apps when the Android-bundled and and an older app-bundled OkHttp library are in
+  // use at the same time the HttpResponseCache must behave as it always used to. That's not the
+  // same as a fully API-compliant {@link ResponseCache}: That means that the cache
+  // doesn't throw an exception from get() or put() and also does not cache requests/responses from
+  // anything other than the variant of OkHttp that it comes with. It does still return values from
+  // get() and it is not expected to implement any cache-control logic.
+  @Test public void testHttpResponseCacheBackwardsCompatible() throws Exception {
     assertSame(cache, ResponseCache.getDefault());
+    assertEquals(0, cache.getRequestCount());
 
     String body = ""Body"";
-    server.enqueue(new MockResponse().setBody(body));
+    server.enqueue(new MockResponse()
+        .addHeader(""Last-Modified: "" + formatDate(-1, TimeUnit.HOURS))
+        .addHeader(""Expires: "" + formatDate(1, TimeUnit.HOURS))
+        .setBody(body));
     server.play();
 
-    // Use a standard Java HttpURLConnection, which will pick up the default ResponseCache.
     URL url = server.getUrl(""/"");
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    assertEquals(body, readAscii(connection));
-    connection.disconnect();
 
-    // Next request should be cached.
-    HttpURLConnection connection2 = (HttpURLConnection) url.openConnection();
-    assertEquals(body, readAscii(connection2));
-    connection2.disconnect();
+    // Here we use a HttpURLConnection from URL to represent a non-OkHttp HttpURLConnection. In
+    // Android this would be com.android.okhttp.internal.http.HttpURLConnectionImpl. In tests this
+    // is some other implementation.
+    HttpURLConnection javaConnection = (HttpURLConnection) url.openConnection();
+    assertFalse(""This test relies on url.openConnection() not returning an OkHttp connection"",
+        javaConnection instanceof HttpURLConnectionImpl);
+    javaConnection.disconnect();
+
+    // This should simply be discarded. It doesn't matter the connection is not useful.
+    cache.put(url.toURI(), javaConnection);
+
+    // Confirm the initial cache state.
+    assertNull(cache.get(url.toURI(), ""GET"", new HashMap<String, List<String>>()));
+
+    // Now cache a response
+    HttpURLConnection okHttpConnection = openConnection(url);
+    assertEquals(body, readAscii(okHttpConnection));
+    okHttpConnection.disconnect();
 
     assertEquals(1, server.getRequestCount());
+    assertEquals(0, cache.getHitCount());
+
+    // OkHttp should now find the result cached.
+    HttpURLConnection okHttpConnection2 = openConnection(url);
+    assertEquals(body, readAscii(okHttpConnection2));
+    okHttpConnection2.disconnect();
+
+    assertEquals(1, server.getRequestCount());
+    assertEquals(1, cache.getHitCount());
+
+    // Confirm the unfortunate get() behavior.
+    assertNotNull(cache.get(url.toURI(), ""GET"", new HashMap<String, List<String>>()));
+    // Only OkHttp makes the necessary callbacks to increment the cache stats.
+    assertEquals(1, cache.getHitCount());
   }
 
   private void writeFile(File directory, String file, String content) throws IOException {
@@ -49,7 +49,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -432,9 +432,9 @@ public Principal getLocalPrincipal() {
     // Check retrieval using a Map.
     Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
     assertEquals(Arrays.asList(statusLine), responseHeaders.get(null));
-    assertEquals(newSet(""c"", ""e""), new HashSet<String>(responseHeaders.get(""A"")));
+    assertEquals(newSet(""c"", ""e""), newSet(responseHeaders.get(""A"")));
     // OkHttp supports case-insensitive matching here. The RI does not.
-    assertEquals(newSet(""c"", ""e""), new HashSet<String>(responseHeaders.get(""a"")));
+    assertEquals(newSet(""c"", ""e""), newSet(responseHeaders.get(""a"")));
 
     // Check the Map iterator contains the expected mappings.
     assertHeadersContainsMapping(responseHeaders, null, statusLine);
@@ -485,7 +485,7 @@ private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnect
   private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
       String... expectedValues) {
     assertTrue(headers.containsKey(expectedKey));
-    assertEquals(newSet(expectedValues), new HashSet<String>(headers.get(expectedKey)));
+    assertEquals(newSet(expectedValues), newSet(headers.get(expectedKey)));
   }
 
   @Test public void createJavaUrlConnection_accessibleRequestInfo_GET() throws Exception {
@@ -717,8 +717,12 @@ private static X509Certificate certificate(String certificate) {
     }
   }
 
-  private static Set<String> newSet(String... elements) {
-    return new HashSet<String>(Arrays.asList(elements));
+  private static <T> Set<T> newSet(T... elements) {
+    return newSet(Arrays.asList(elements));
+  }
+
+  private static <T> Set<T> newSet(List<T> elements) {
+    return new LinkedHashSet<T>(elements);
   }
 
   private static Request createArbitraryOkRequest() {
@@ -55,8 +55,8 @@
  * <ul>
  *   <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
  *   classes are called correctly by OkHttp.</li>
- *   <li>{@link JavaApiConverterTest} for tests that check Java API classes <-> OkHttp conversion logic.
- *   </li>
+ *   <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
+ *   logic. </li>
  * </ul>
  */
 public class ResponseCacheAdapterTest {
@@ -19,6 +19,8 @@
 import com.squareup.okhttp.internal.DiskLruCache;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpMethod;
+import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
 import com.squareup.okhttp.internal.http.JavaApiConverter;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
@@ -53,6 +55,18 @@
  * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
  * saving time and bandwidth.
  *
+ * <p>This cache extends {@link ResponseCache} but is only intended for use
+ * with OkHttp and is not a general-purpose implementation: The
+ * {@link ResponseCache} API requires that the subclass handles cache-control
+ * logic as well as storage. In OkHttp the {@link HttpResponseCache} only
+ * handles cursory cache-control logic.
+ *
+ * <p>To maintain support for previous releases the {@link HttpResponseCache}
+ * will disregard any {@link #put(java.net.URI, java.net.URLConnection)}
+ * calls with a URLConnection that is not from OkHttp. It will, however,
+ * return cached data for any calls to {@link #get(java.net.URI, String,
+ * java.util.Map)}.
+ *
  * <h3>Cache Optimization</h3>
  * To measure cache effectiveness, this class tracks three statistics:
  * <ul>
@@ -168,9 +182,17 @@ private static String urlToKey(Request requst) {
   }
 
   @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    if (!isCacheableConnection(urlConnection)) {
+      return null;
+    }
     return put(JavaApiConverter.createOkResponse(uri, urlConnection));
   }
 
+  private static boolean isCacheableConnection(URLConnection httpConnection) {
+    return (httpConnection instanceof HttpURLConnectionImpl)
+        || (httpConnection instanceof HttpsURLConnectionImpl);
+  }
+
   @Override public CacheRequest put(Response response) throws IOException {
     String requestMethod = response.request().method();
 
@@ -52,10 +52,6 @@ private JavaApiConverter() {
   /**
    * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection}
    * to supply the data. The URLConnection is assumed to already be connected.
-   *
-   * <p>Note: Because this method is used by HttpResponseCache, this class is intended for use with
-   * any Java-API compliant HttpURLConnection / HttpsURLConnection and not just ones implemented by
-   * OkHttp.
    */
   public static Response createOkResponse(URI uri, URLConnection urlConnection) throws IOException {
     HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
"
https://github.com/square/okhttp/commit/137e7de0454f10160370f105ac7d9d2fc5403c84,"New API, HandshakeCertificates.addPlatformTrustedCertificates()  <enter> Also rename HeldCertificate.Builder.issuedBy() to signedBy(). 'Issued' is the word used by certificates; 'signed' is the word used by cryptographers. I prefer 'signed'. ",https://api.github.com/repos/square/okhttp/commits/137e7de0454f10160370f105ac7d9d2fc5403c84,"@@ -530,7 +530,7 @@ private List<String> headersToList(MockResponse response) {
         .certificateAuthority(0)
         .build();
     HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .issuedBy(serverCa)
+        .signedBy(serverCa)
         .addSubjectAlternativeName(server.getHostName())
         .build();
     HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
@@ -543,7 +543,7 @@ private List<String> headersToList(MockResponse response) {
     server.requestClientAuth();
 
     HeldCertificate clientCertificate = new HeldCertificate.Builder()
-        .issuedBy(clientCa)
+        .signedBy(clientCa)
         .build();
     HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()
         .addTrustedCertificate(serverCa.certificate())
@@ -77,11 +77,11 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
@@ -94,11 +94,11 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
@@ -112,15 +112,15 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
         .serialNumber(4L)
-        .issuedBy(certB)
+        .signedBy(certB)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
@@ -134,15 +134,15 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
         .serialNumber(4L)
-        .issuedBy(certB)
+        .signedBy(certB)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
@@ -156,11 +156,11 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
     HeldCertificate certUnnecessary = new HeldCertificate.Builder()
         .serialNumber(4L)
@@ -177,15 +177,15 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(selfSigned)
+        .signedBy(selfSigned)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(trusted)
+        .signedBy(trusted)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(4L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(
@@ -203,15 +203,15 @@ public final class CertificateChainCleanerTest {
         .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .issuedBy(unknownSigner)
+        .signedBy(unknownSigner)
         .serialNumber(2L)
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(trusted)
+        .signedBy(trusted)
         .serialNumber(3L)
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
+        .signedBy(intermediateCa)
         .serialNumber(4L)
         .build();
 
@@ -256,7 +256,7 @@ private List<HeldCertificate> chainOfLength(int length) {
     List<HeldCertificate> result = new ArrayList<>();
     for (int i = 1; i <= length; i++) {
       result.add(0, new HeldCertificate.Builder()
-          .issuedBy(!result.isEmpty() ? result.get(0) : null)
+          .signedBy(!result.isEmpty() ? result.get(0) : null)
           .serialNumber(i)
           .build());
     }
@@ -56,7 +56,7 @@ public final class ConnectionCoalescingTest {
         .commonName(""root"")
         .build();
     certificate = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .serialNumber(2L)
         .commonName(server.getHostName())
         .addSubjectAlternativeName(server.getHostName())
@@ -61,13 +61,13 @@ public final class CertificatePinnerChainValidationTest {
         .commonName(""root"")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""intermediate_ca"")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
+        .signedBy(intermediateCa)
         .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
@@ -118,13 +118,13 @@ public final class CertificatePinnerChainValidationTest {
         .commonName(""root"")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""intermediate_ca"")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
+        .signedBy(intermediateCa)
         .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
@@ -184,13 +184,13 @@ public final class CertificatePinnerChainValidationTest {
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""good_intermediate_ca"")
         .build();
     HeldCertificate goodCertificate = new HeldCertificate.Builder()
-        .issuedBy(goodIntermediateCa)
+        .signedBy(goodIntermediateCa)
         .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
@@ -212,14 +212,14 @@ public final class CertificatePinnerChainValidationTest {
     // trusted good certificate above. The attack is that by including the good certificate in the
     // chain, we may trick the certificate pinner into accepting the rouge certificate.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(4L)
         .commonName(""bad_intermediate_ca"")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
         .serialNumber(5L)
-        .issuedBy(compromisedIntermediateCa)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
@@ -264,7 +264,7 @@ public final class CertificatePinnerChainValidationTest {
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(3L)
         .commonName(""intermediate_ca"")
@@ -288,14 +288,14 @@ public final class CertificatePinnerChainValidationTest {
     // serves the good CAs certificate in the chain, which means the certificate pinner sees a
     // different set of certificates than the SSL verifier.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(compromisedRootCa)
+        .signedBy(compromisedRootCa)
         .certificateAuthority(0)
         .serialNumber(4L)
         .commonName(""intermediate_ca"")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
         .serialNumber(5L)
-        .issuedBy(compromisedIntermediateCa)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
@@ -67,15 +67,15 @@ public void setUp() {
         .addSubjectAlternativeName(""root_ca.com"")
         .build();
     serverIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
+        .signedBy(serverRootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""intermediate_ca"")
         .addSubjectAlternativeName(""intermediate_ca.com"")
         .build();
 
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
+        .signedBy(serverIntermediateCa)
         .serialNumber(3L)
         .commonName(""Local Host"")
         .addSubjectAlternativeName(server.getHostName())
@@ -88,15 +88,15 @@ public void setUp() {
         .addSubjectAlternativeName(""root_ca.com"")
         .build();
     clientIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
+        .signedBy(serverRootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""intermediate_ca"")
         .addSubjectAlternativeName(""intermediate_ca.com"")
         .build();
 
     clientCert = new HeldCertificate.Builder()
-        .issuedBy(clientIntermediateCa)
+        .signedBy(clientIntermediateCa)
         .serialNumber(4L)
         .commonName(""Jethro Willis"")
         .addSubjectAlternativeName(""jethrowillis.com"")
@@ -188,7 +188,7 @@ public void setUp() {
 
   @Test public void commonNameIsNotTrusted() throws Exception {
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
+        .signedBy(serverIntermediateCa)
         .serialNumber(3L)
         .commonName(server.getHostName())
         .addSubjectAlternativeName(""different-host.com"")
@@ -20,13 +20,16 @@
 import java.security.SecureRandom;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509KeyManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
 
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
@@ -137,6 +140,24 @@ public Builder addTrustedCertificate(X509Certificate certificate) {
       return this;
     }
 
+    /**
+     * Add all of the host platform's trusted root certificates. This set varies by platform
+     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
+     * customizations.
+     *
+     * <p>Most TLS clients that connect to hosts on the public Internet should call this method.
+     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
+     *
+     * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root
+     * certificates. Applications that connect to a known set of servers may be able to mitigate
+     * this problem with {@linkplain CertificatePinner certificate pinning}.
+     */
+    public Builder addPlatformTrustedCertificates() {
+      X509TrustManager platformTrustManager = Util.platformTrustManager();
+      Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers());
+      return this;
+    }
+
     public HandshakeCertificates build() {
       try {
         X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates);
@@ -208,7 +208,7 @@ public static final class Builder {
     private final List<String> altNames = new ArrayList<>();
     private BigInteger serialNumber;
     private KeyPair keyPair;
-    private HeldCertificate issuedBy;
+    private HeldCertificate signedBy;
     private int maxIntermediateCas = -1;
     private String keyAlgorithm;
     private int keySize;
@@ -298,11 +298,11 @@ public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {
     }
 
     /**
-     * Set the certificate that will sign this certificate. If unset the certificate will be
+     * Set the certificate that will issue this certificate. If unset the certificate will be
      * self-signed.
      */
-    public Builder issuedBy(HeldCertificate issuedBy) {
-      this.issuedBy = issuedBy;
+    public Builder signedBy(HeldCertificate signedBy) {
+      this.signedBy = signedBy;
       return this;
     }
 
@@ -357,9 +357,9 @@ public HeldCertificate build() {
       // Subject, public & private keys for this certificate's signer. It may be self signed!
       KeyPair signedByKeyPair;
       X500Principal signedByPrincipal;
-      if (issuedBy != null) {
-        signedByKeyPair = issuedBy.keyPair;
-        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
+      if (signedBy != null) {
+        signedByKeyPair = signedBy.keyPair;
+        signedByPrincipal = signedBy.certificate.getSubjectX500Principal();
       } else {
         signedByKeyPair = heldKeyPair;
         signedByPrincipal = subject;
@@ -21,7 +21,10 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.security.PrivateKey;
+import java.security.cert.X509Certificate;
 import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -37,6 +40,7 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public final class HandshakeCertificatesTest {
   private ExecutorService executorService;
@@ -57,21 +61,21 @@ public final class HandshakeCertificatesTest {
         .build();
     HeldCertificate clientIntermediate = new HeldCertificate.Builder()
         .certificateAuthority(0)
-        .issuedBy(clientRoot)
+        .signedBy(clientRoot)
         .build();
     HeldCertificate clientCertificate = new HeldCertificate.Builder()
-        .issuedBy(clientIntermediate)
+        .signedBy(clientIntermediate)
         .build();
 
     HeldCertificate serverRoot = new HeldCertificate.Builder()
         .certificateAuthority(1)
         .build();
     HeldCertificate serverIntermediate = new HeldCertificate.Builder()
         .certificateAuthority(0)
-        .issuedBy(serverRoot)
+        .signedBy(serverRoot)
         .build();
     HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediate)
+        .signedBy(serverIntermediate)
         .build();
 
     HandshakeCertificates server = new HandshakeCertificates.Builder()
@@ -108,10 +112,10 @@ public final class HandshakeCertificatesTest {
         .build();
     HeldCertificate intermediate = new HeldCertificate.Builder()
         .certificateAuthority(0)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediate)
+        .signedBy(intermediate)
         .build();
 
     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
@@ -123,6 +127,20 @@ public final class HandshakeCertificatesTest {
         Arrays.asList(handshakeCertificates.keyManager().getCertificateChain(""private"")));
   }
 
+  @Test public void platformTrustedCertificates() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addPlatformTrustedCertificates()
+        .build();
+    Set<String> names = new LinkedHashSet<>();
+    for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {
+      // Abbreviate a long name like ""CN=Entrust Root Certification Authority - G2, OU=...""
+      String name = certificate.getSubjectDN().getName();
+      names.add(name.substring(0, name.indexOf("" "")));
+    }
+    // It's safe to assume all platforms will have a major Internet certificate issuer.
+    assertTrue(names.toString(), names.contains(""CN=Entrust""));
+  }
+
   private InetSocketAddress startTlsServer() throws IOException {
     ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
     serverSocket = serverSocketFactory.createServerSocket();
@@ -202,7 +202,7 @@ public final class HeldCertificateTest {
     HeldCertificate leaf = new HeldCertificate.Builder()
         .certificateAuthority(0)
         .ecdsa256()
-        .issuedBy(root)
+        .signedBy(root)
         .build();
 
     assertEquals(""SHA256WITHRSA"", root.certificate().getSigAlgName());
@@ -217,7 +217,7 @@ public final class HeldCertificateTest {
     HeldCertificate leaf = new HeldCertificate.Builder()
         .certificateAuthority(0)
         .rsa2048()
-        .issuedBy(root)
+        .signedBy(root)
         .build();
 
     assertEquals(""SHA256WITHECDSA"", root.certificate().getSigAlgName());
@@ -19,9 +19,7 @@
 import java.net.ProxySelector;
 import java.net.Socket;
 import java.security.GeneralSecurityException;
-import java.security.KeyStore;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
@@ -34,7 +32,6 @@
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
@@ -248,8 +245,8 @@ public OkHttpClient() {
       this.sslSocketFactory = builder.sslSocketFactory;
       this.certificateChainCleaner = builder.certificateChainCleaner;
     } else {
-      X509TrustManager trustManager = systemDefaultTrustManager();
-      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      X509TrustManager trustManager = Util.platformTrustManager();
+      this.sslSocketFactory = newSslSocketFactory(trustManager);
       this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
     }
 
@@ -280,23 +277,7 @@ public OkHttpClient() {
     }
   }
 
-  private X509TrustManager systemDefaultTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException(""Unexpected default trust managers:""
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw assertionError(""No System TLS"", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
     try {
       SSLContext sslContext = Platform.get().getSSLContext();
       sslContext.init(null, new TrustManager[] { trustManager }, null);
@@ -26,6 +26,8 @@
 import java.net.Socket;
 import java.net.UnknownHostException;
 import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -37,6 +39,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.HttpUrl;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -642,4 +647,20 @@ private static String inet6AddressToAscii(byte[] address) {
     }
     return result.readUtf8();
   }
+
+  public static X509TrustManager platformTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException(""Unexpected default trust managers:""
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw assertionError(""No System TLS"", e); // The system has no TLS. Just give up.
+    }
+  }
 }
"
https://github.com/spring-projects/spring-boot/commit/4d172ca7429bfc15692ce7f1247beeb355faa924,"Remove duplicate resources from classpath  <enter> We had been making a special case for logback.xml anyway, so extending that to simply deleting recursively all of src/main/resources (or equivalent) from target/classes (or equivalent) seems like it's perfectly justifiable. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/4d172ca7429bfc15692ce7f1247beeb355faa924,"@@ -52,8 +52,7 @@ public void runApp() {
 			SourceDirectorySet resources = main.getResources();
 			allResources.addAll(resources.getSrcDirs());
 			outputs = main.getOutput().getResourcesDir();
-		}
-		else {
+		} else {
 			outputs = null;
 		}
 
@@ -80,11 +79,16 @@ public String call() throws Exception {
 					getLogger().info(""Found main: "" + mainClass);
 				}
 				if (outputs != null) {
-					// Special case: this file causes logback to worry that it has been
-					// configured twice, so remove it from the target directory...
-					File logback = new File(outputs, ""logback.xml"");
-					if (logback.exists()) {
-						logback.delete();
+					// remove duplicates from resources and build
+					for (File directory : allResources) {
+						if (directory.isDirectory()) {
+							for (String name : directory.list()) {
+								File file = new File(outputs, name);
+								if (file.exists() && file.canWrite()) {
+									getProject().delete(file);
+								}
+							}
+						}
 					}
 				}
 				exec.exec();
@@ -100,8 +104,7 @@ private String findMainClass(SourceSet main) {
 		getLogger().info(""Looking for main in: "" + main.getOutput().getClassesDir());
 		try {
 			return MainClassFinder.findMainClass(main.getOutput().getClassesDir());
-		}
-		catch (IOException ex) {
+		} catch (IOException ex) {
 			throw new IllegalStateException(""Cannot find main class"", ex);
 		}
 	}
@@ -37,6 +37,7 @@
 import org.apache.maven.plugins.annotations.Parameter;
 import org.apache.maven.plugins.annotations.ResolutionScope;
 import org.apache.maven.project.MavenProject;
+import org.codehaus.plexus.util.FileUtils;
 import org.springframework.boot.loader.tools.AgentAttacher;
 import org.springframework.boot.loader.tools.MainClassFinder;
 
@@ -62,10 +63,7 @@ public class RunMojo extends AbstractMojo {
 
 	/**
 	 * Add maven resources to the classpath directly, this allows live in-place editing or
-	 * resources. Since resources will be added directly, and via the target/classes
-	 * folder they will appear twice if ClassLoader.getResources() is called. In practice
-	 * however most applications call ClassLoader.getResource() which will always return
-	 * the first resource.
+	 * resources.
 	 */
 	@Parameter(property = ""run.addResources"", defaultValue = ""true"")
 	private boolean addResources;
@@ -185,6 +183,9 @@ private URL[] getClassPathUrls() throws MojoExecutionException {
 		catch (MalformedURLException ex) {
 			throw new MojoExecutionException(""Unable to build classpath"", ex);
 		}
+		catch (IOException ex) {
+			throw new MojoExecutionException(""Unable to build classpath"", ex);
+		}
 	}
 
 	private void addUserDefinedFolders(List<URL> urls) throws MalformedURLException {
@@ -195,16 +196,25 @@ private void addUserDefinedFolders(List<URL> urls) throws MalformedURLException
 		}
 	}
 
-	private void addResources(List<URL> urls) throws MalformedURLException {
+	private void addResources(List<URL> urls) throws MalformedURLException, IOException {
 		if (this.addResources) {
 			for (Resource resource : this.project.getResources()) {
-				urls.add(new File(resource.getDirectory()).toURI().toURL());
-			}
-			// Special case: this file causes logback to worry that it has been configured
-			// twice, so remove it from the target directory...
-			File logback = new File(this.classesDirectory, ""logback.xml"");
-			if (logback.exists() && logback.canWrite()) {
-				logback.delete();
+				File directory = new File(resource.getDirectory());
+				urls.add(directory.toURI().toURL());
+				if (directory.isDirectory()) {
+					// Remove duplicates from the target directory...
+					for (String name : directory.list()) {
+						File file = new File(this.classesDirectory, name);
+						if (file.exists() && file.canWrite()) {
+							if (file.isDirectory()) {
+								FileUtils.deleteDirectory(file);
+							}
+							else {
+								file.delete();
+							}
+						}
+					}
+				}
 			}
 		}
 	}
"
https://github.com/spring-projects/spring-boot/commit/b39ecdf0060189367e396f0dcc455760006f2659,Rename preferred-mapper property so its clear it only applies to JSON  <enter> preferred-mapper has been renamed to preferred-json-mapper to make it clear that it only affects the JSON mapper and that the XML mapper that will be used (if any) is unaffected <enter> See  <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/b39ecdf0060189367e396f0dcc455760006f2659,"@@ -52,7 +52,7 @@
 		GsonHttpMessageConvertersConfiguration.class })
 public class HttpMessageConvertersAutoConfiguration {
 
-	static final String PREFERRED_MAPPER_PROPERTY = ""spring.http.converters.preferred-mapper"";
+	static final String PREFERRED_MAPPER_PROPERTY = ""spring.http.converters.preferred-json-mapper"";
 
 	@Autowired(required = false)
 	private final List<HttpMessageConverter<?>> converters = Collections.emptyList();
@@ -148,7 +148,7 @@ public void gsonCanBePreferredWhenBothGsonAndJacksonAreAvailable() {
 				JacksonAutoConfiguration.class,
 				HttpMessageConvertersAutoConfiguration.class);
 		EnvironmentTestUtils.addEnvironment(this.context,
-				""spring.http.converters.preferred-mapper:gson"");
+				""spring.http.converters.preferred-json-mapper:gson"");
 		this.context.refresh();
 		assertConverterBeanExists(GsonHttpMessageConverter.class,
 				""gsonHttpMessageConverter"");
"
https://github.com/square/retrofit/commit/ebc0128add0d416a846ff661888910d16751dd34,Clean out Java 8 READMEs to further discourage use ,https://api.github.com/repos/square/retrofit/commits/ebc0128add0d416a846ff661888910d16751dd34,"@@ -1,54 +1,10 @@
-Java8 Adapter
-==============
+Java 8 Adapter (Deprecated)
+===========================
 
-An `Adapter` for adapting [Java8][1] `CompletableFuture`.
-
-
-Deprecated – Included by default in Retrofit
----------------------------------------
-
-
-Usage
------
-
-Add `Java8CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
-```java
-Retrofit retrofit = new Retrofit.Builder()
-    .baseUrl(""https://example.com/"")
-    .addCallAdapterFactory(Java8CallAdapterFactory.create())
-    .build();
-```
-
-Your service methods can now use `CompletableFuture` as their return type.
-```java
-interface MyService {
-  @GET(""/user"")
-  CompletableFuture<User> getUser();
-}
-```
-
-
-Download
---------
-
-Download [the latest JAR][2] or grab via [Maven][3]:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>adapter-java8</artifactId>
-  <version>latest.version</version>
-</dependency>
-```
-or [Gradle][3]:
-```groovy
-implementation 'com.squareup.retrofit2:adapter-java8:latest.version'
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+A call adapter [Java 8's `CompletableFuture`][1].
 
+This adapter is no longer needed. Support for `CompletableFuture` is built-in to Retrofit and now
+works without configuration.
 
 
  [1]: http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html
- [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-java8&v=LATEST
- [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-java8%22
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
@@ -1,34 +1,8 @@
-Java 8 Converter
-================
+Java 8 Converter (Deprecated)
+=============================
 
 A `Converter` which supports Java 8's `Optional<T>` by delegating to other converters for `T`
 and then wrapping it into `Optional`.
 
-
-Deprecated – Included by default in Retrofit
----------------------------------------
-
-
-Download
---------
-
-Download [the latest JAR][1] or grab via [Maven][2]:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>converter-java8</artifactId>
-  <version>latest.version</version>
-</dependency>
-```
-or [Gradle][2]:
-```groovy
-implementation 'com.squareup.retrofit2:converter-java8:latest.version'
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
-
-
-
- [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-java8&v=LATEST
- [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-java8%22
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+This converter is no longer needed. Support for `Optional` is built-in to Retrofit and now works
+without configuration.
"
https://github.com/spring-projects/spring-boot/commit/f8a53cf775b03c9258b42be194e05e0ee1779f35,Update actuator security documentation  <enter> Update documentation to align with the new role based method. <enter> See  <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/f8a53cf775b03c9258b42be194e05e0ee1779f35,"@@ -536,11 +536,32 @@ all enabled endpoints to be exposed over HTTP. The default convention is to use
 
 
 [[production-ready-sensitive-endpoints]]
-=== Securing sensitive endpoints
-If you add '`Spring Security`' to your project, all sensitive endpoints exposed over HTTP
-will be protected. By default '`basic`' authentication will be used with the username
-`user` and a generated password (which is printed on the console when the application
-starts).
+=== Accessing sensitive endpoints
+By default all sensitive HTTP endpoints are secured such that only users that have an
+`ACTUATOR` role may access them. Security is enforced using the standard
+`HttpServletRequest.isUserInRole` method.
+
+TIP: Use the `management.security.roles` property if you want something different to
+`ACTUATOR`.
+
+If you are deploying applications behind a firewall, you may prefer that all your actuator
+endpoints can be accessed without requiring authentication. You can do this by changing
+the `management.security.enabled` property:
+
+.application.properties
+[source,properties,indent=0]
+----
+	management.security.enabled=false
+----
+
+NOTE: By default, actuator endpoints are exposed on the same port that serves regular
+HTTP traffic. Take care not to accidentally expose sensitive information if you change
+the `management.security.enabled` property.
+
+If you're deploying applications publicly, you may want to add '`Spring Security`' to
+handle user authentication. When '`Spring Security`' is added, by default '`basic`'
+authentication will be used with the username `user` and a generated password (which is
+printed on the console when the application starts).
 
 TIP: Generated passwords are logged as the application starts. Search for '`Using default
 security password`'.
@@ -556,10 +577,6 @@ in your `application.properties`:
 	management.security.roles=SUPERUSER
 ----
 
-TIP: If you don't use Spring Security and your HTTP endpoints are exposed publicly,
-you should carefully consider which endpoints you enable. See
-<<production-ready-customizing-endpoints>> for details of how you can set
-`endpoints.enabled` to `false` then ""`opt-in`"" only specific endpoints.
 
 
 [[production-ready-customizing-management-server-context-path]]
"
https://github.com/junit-team/junit4/commit/fa35d6d84a0b2c59254cb479633d0e20bc6e12e9,"Delete .cvsignore files, because we're using Git now. ",https://api.github.com/repos/junit-team/junit4/commits/fa35d6d84a0b2c59254cb479633d0e20bc6e12e9,"@@ -1,10 +0,0 @@
-bin
-junit4.1
-junit*-SNAPSHOT-*
-target
-reports
-buildfile
-java.hprof.txt
-junit4.5-RC1
-junit4.*
-*.ser
@@ -1,4 +0,0 @@
-Changes
-java.hprof.txt
-historical_javadoc
-compare_with_44.sh
"
https://github.com/spring-projects/spring-boot/commit/ee4205a0498440f3003ace8c5ccf36cbe74eab00,Remove unnecessary logging by start-docker script ,https://api.github.com/repos/spring-projects/spring-boot/commits/ee4205a0498440f3003ace8c5ccf36cbe74eab00,"@@ -10,7 +10,7 @@ caches:
 run:
   path: bash
   args:
-    - -exc
+    - -ec
     - |
       source /docker-lib.sh
       start_docker
"
https://github.com/apache/dubbo/commit/9897aa3d7273e3eb96910cfdc09709a77cae50b0,"remove appConfigs cache to support one service/reference registered more than one time (if users don't explicitly add id, cache can not work properly) ",https://api.github.com/repos/apache/dubbo/commits/9897aa3d7273e3eb96910cfdc09709a77cae50b0,"@@ -35,7 +35,6 @@ public class Environment {
     private Map<String, EnvironmentConfiguration> environmentConfigs = new ConcurrentHashMap<>();
     private Map<String, InmemoryConfiguration> externalConfigs = new ConcurrentHashMap<>();
     private Map<String, InmemoryConfiguration> appExternalConfigs = new ConcurrentHashMap<>();
-    private Map<String, InmemoryConfiguration> appConfigs = new ConcurrentHashMap<>();
 
     private Map<String, String> externalConfigurationMap = new HashMap<>();
     private Map<String, String> appExternalConfigurationMap = new HashMap<>();
@@ -79,10 +78,6 @@ public EnvironmentConfiguration getEnvironmentConfig(String prefix, String id) {
         return environmentConfigs.computeIfAbsent(toKey(prefix, id), k -> new EnvironmentConfiguration(prefix, id));
     }
 
-    public InmemoryConfiguration getAppConfig(String prefix, String id) {
-        return appConfigs.get(toKey(prefix, id));
-    }
-
     public void setExternalConfigMap(Map<String, String> externalConfiguration) {
         this.externalConfigurationMap = externalConfiguration;
     }
@@ -99,14 +94,6 @@ public Map<String, String> getAppExternalConfigurationMap() {
         return appExternalConfigurationMap;
     }
 
-    public void addAppConfig(String prefix, String id, Map<String, String> properties) {
-        appConfigs.computeIfAbsent(toKey(prefix, id), k -> {
-            InmemoryConfiguration configuration = new InmemoryConfiguration(prefix, id);
-            configuration.addProperties(properties);
-            return configuration;
-        });
-    }
-
     public void updateExternalConfigurationMap(Map<String, String> externalMap) {
         this.externalConfigurationMap.putAll(externalMap);
     }
@@ -124,27 +111,13 @@ public void updateAppExternalConfigurationMap(Map<String, String> externalMap) {
      * @param id
      * @return
      */
-    public Configuration getConfiguration(String prefix, String id) {
+    public CompositeConfiguration getConfiguration(String prefix, String id) {
         CompositeConfiguration compositeConfiguration = new CompositeConfiguration();
-        InmemoryConfiguration appConfig = this.getAppConfig(prefix, id);
         // Config center has the highest priority
-        if (!configCenterFirst) {
-            compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));
-            if (appConfig != null) {
-                compositeConfiguration.addConfiguration(appConfig);
-            }
-            compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));
-            compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));
-            compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));
-        } else {
-            compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));
-            compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));
-            compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));
-            if (appConfig != null) {
-                compositeConfiguration.addConfiguration(appConfig);
-            }
-            compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));
-        }
+        compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));
+        compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));
+        compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));
+        compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));
         return compositeConfiguration;
     }
 
@@ -18,8 +18,9 @@
 
 import org.apache.dubbo.common.Constants;
 import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.config.Configuration;
+import org.apache.dubbo.common.config.CompositeConfiguration;
 import org.apache.dubbo.common.config.Environment;
+import org.apache.dubbo.common.config.InmemoryConfiguration;
 import org.apache.dubbo.common.extension.ExtensionLoader;
 import org.apache.dubbo.common.logger.Logger;
 import org.apache.dubbo.common.logger.LoggerFactory;
@@ -536,9 +537,16 @@ public void setPrefix(String prefix) {
      */
     public void refresh() {
         try {
-            Environment env = Environment.getInstance();
-            env.addAppConfig(getPrefix(), getId(), getMetaData());
-            Configuration configuration = env.getConfiguration(getPrefix(), getId());
+            CompositeConfiguration compositeConfiguration = Environment.getInstance().getConfiguration(getPrefix(), getId());
+            InmemoryConfiguration configuration = new InmemoryConfiguration(getPrefix(), getId());
+            configuration.addProperties(getMetaData());
+            if (Environment.getInstance().isConfigCenterFirst()) {
+                // The sequence would be: SystemConfiguration -> ExternalConfiguration -> AppExternalConfiguration -> AbstractConfig -> PropertiesConfiguration
+                compositeConfiguration.addConfiguration(3,configuration);
+            } else {
+                // The sequence would be: SystemConfiguration -> AbstractConfig -> ExternalConfiguration -> AppExternalConfiguration -> PropertiesConfiguration
+                compositeConfiguration.addConfiguration(1, configuration);
+            }
 
             // loop methods, get override value and set the new value back to method
             Method[] methods = getClass().getMethods();
"
https://github.com/junit-team/junit4/commit/2b6fa701e84625c511b03079296774cc0904ef1a,"Bug: ParentRunner lost test Class from a separate class loader ( <pr_link> )  <enter> * Bug: ParentRunner lost test Class from a separate class loader <enter> When junit.jar located in one ClassLoader but runing tests in another ParentRunner can lost information about run class. For example if use @ClassRule and request test class(org.junit.runner.Description#getTestClass) we can get null, because ParentRunner instead of set Class as is to Description tranform it to class name string, as result org.junit.runner.Description#getTestClass execute Class.forName and can't find test class. <enter> Spring-test fail with exception if we try use SpringClassRule <enter> ``` java.lang.NullPointerException  at org.springframework.test.context.junit4.rules.SpringClassRule.validateSpringMethodRuleConfiguration(SpringClassRule.java:186)  at org.springframework.test.context.junit4.rules.SpringClassRule.apply(SpringClassRule.java:134)  at org.junit.rules.RunRules.applyAll(RunRules.java:26)  at org.junit.rules.RunRules.<init>(RunRules.java:15)  at org.junit.runners.ParentRunner.withClassRules(ParentRunner.java:245)  at org.junit.runners.ParentRunner.classBlock(ParentRunner.java:194)  at org.junit.runners.ParentRunner.run(ParentRunner.java:362)  at org.junit.runner.JUnitCore.run(JUnitCore.java:137) ``` <enter> As solution, now ParentRunner create Descriptor with explicit specify Class, name and uses annotations. <enter> * Restore backward compatibility with sub class of ParentRunner that override getName method * Add ParentRunnerClassLoaderTest to AllClassesTests suite ",https://api.github.com/repos/junit-team/junit4/commits/2b6fa701e84625c511b03079296774cc0904ef1a,"@@ -124,6 +124,17 @@ public static Description createSuiteDescription(Class<?> testClass) {
         return new Description(testClass, testClass.getName(), testClass.getAnnotations());
     }
 
+    /**
+     * Create a <code>Description</code> named after <code>testClass</code>
+     *
+     * @param testClass A not null {@link Class} containing tests
+     * @param annotations meta-data about the test, for downstream interpreters
+     * @return a <code>Description</code> of <code>testClass</code>
+     */
+    public static Description createSuiteDescription(Class<?> testClass, Annotation... annotations) {
+        return new Description(testClass, testClass.getName(), annotations);
+    }
+
     /**
      * Describes a Runner which runs no tests
      */
@@ -347,8 +347,16 @@ protected Annotation[] getRunnerAnnotations() {
 
     @Override
     public Description getDescription() {
-        Description description = Description.createSuiteDescription(getName(),
-                getRunnerAnnotations());
+        Class<?> clazz = getTestClass().getJavaClass();
+        Description description;
+        // if subclass overrides `getName()` then we should use it
+        // to maintain backwards compatibility with JUnit 4.12
+        if (clazz == null || !clazz.getName().equals(getName())) {
+            description = Description.createSuiteDescription(getName(), getRunnerAnnotations());
+        } else {
+            description = Description.createSuiteDescription(clazz, getRunnerAnnotations());
+        }
+
         for (T child : getFilteredChildren()) {
             description.addChild(describeChild(child));
         }
@@ -3,6 +3,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Suite;
 import org.junit.runners.Suite.SuiteClasses;
+import org.junit.tests.running.classes.parent.ParentRunnerClassLoaderTest;
 
 @RunWith(Suite.class)
 @SuiteClasses({
@@ -13,6 +14,7 @@
         ParameterizedTestTest.class,
         ParentRunnerFilteringTest.class,
         ParentRunnerTest.class,
+        ParentRunnerClassLoaderTest.class,
         RunWithTest.class,
         SuiteTest.class,
         UseSuiteAsASuperclassTest.class
@@ -0,0 +1,96 @@
+package org.junit.tests.running.classes.parent;
+
+
+import org.junit.Test;
+import org.junit.runner.Description;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.BlockJUnit4ClassRunner;
+import org.junit.runners.ParentRunner;
+import org.junit.runners.model.FrameworkMethod;
+import org.junit.runners.model.InitializationError;
+
+import java.lang.reflect.Field;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public class ParentRunnerClassLoaderTest {
+    @Test
+    public void testClassRuleAccessToClassInAnotherClassLoader() throws Exception {
+        Class<?> testClassWithOwnClassLoader = wrapToClassLoader(TestWithClassRule.class);
+
+        runTestWithParentRunner(testClassWithOwnClassLoader);
+
+        Field fieldWithReference = testClassWithOwnClassLoader.getDeclaredField(""applyTestClass"");
+        Class<?> usedClass = (Class<?>) fieldWithReference.get(null);
+
+        assertEquals(""JUnitRunner can be located in own classLoader, so, "" +
+                        ""Class.forName org.junit.runner.Description.getTestClass can not see "" +
+                        ""in current classloader by execute Class.forName"",
+                testClassWithOwnClassLoader, usedClass
+        );
+    }
+
+    @Test
+    public void testDescriptionContainCorrectTestClass() throws Exception {
+        Class<?> testClassWithOwnClassLoader = wrapToClassLoader(TestWithClassRule.class);
+        ParentRunner<?> runner = new BlockJUnit4ClassRunner(testClassWithOwnClassLoader);
+
+        Description description = runner.getDescription();
+        assertEquals(""ParentRunner accept already instantiate Class<?> with tests, if we lost it instance, and will "" +
+                ""use Class.forName we can not find test class again, because tests can be "" +
+                ""located in different ClassLoader"",
+                description.getTestClass(), testClassWithOwnClassLoader
+        );
+    }
+
+    @Test
+    public void testBackwardCompatibilityWithOverrideGetName() throws Exception {
+        final Class<TestWithClassRule> originalTestClass = TestWithClassRule.class;
+        final Class<?> waitClass = ParentRunnerClassLoaderTest.class;
+
+        ParentRunner<FrameworkMethod> subParentRunner = new BlockJUnit4ClassRunner(originalTestClass) {
+            @Override
+            protected String getName() {
+                return waitClass.getName();
+            }
+        };
+
+        Description description = subParentRunner.getDescription();
+        Class<?> result = description.getTestClass();
+
+        assertEquals(""Subclass of ParentRunner can override getName method and specify another test class for run, "" +
+                ""we should  maintain backwards compatibility with JUnit 4.12"",
+                waitClass, result
+        );
+    }
+
+    private void runTestWithParentRunner(Class<?> testClass) throws InitializationError {
+        ParentRunner<?> runner = new BlockJUnit4ClassRunner(testClass);
+        runner.run(new RunNotifier());
+    }
+
+    private Class<?> wrapToClassLoader(Class<?> sourceClass) throws ClassNotFoundException {
+        URL classpath = sourceClass.getProtectionDomain().getCodeSource().getLocation();
+        VisibleClassLoader loader = new VisibleClassLoader(new URL[]{classpath}, this.getClass().getClassLoader());
+        Class<?> testClassWithOwnClassLoader = loader.findClass(sourceClass.getName());
+
+        assert testClassWithOwnClassLoader != sourceClass;
+
+        return testClassWithOwnClassLoader;
+    }
+
+
+    private static class VisibleClassLoader extends URLClassLoader {
+        public VisibleClassLoader(URL[] urls, ClassLoader parent) {
+            super(urls, parent);
+        }
+
+        @Override // just making public
+        public Class<?> findClass(String name) throws ClassNotFoundException {
+            return super.findClass(name);
+        }
+    }
+}
@@ -0,0 +1,42 @@
+package org.junit.tests.running.classes.parent;
+
+import org.junit.Assert;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.lang.reflect.Field;
+
+/**
+ * Test class for validate run tests that was load in own ClassLoader
+ */
+public class TestWithClassRule {
+    public static Class<?> applyTestClass;
+
+    @ClassRule
+    public static TestRule rule = new CustomRule();
+
+    @Test
+    public void testClassRuleExecuted() throws Exception {
+        Assert.assertNotNull(""Description should contain reference to TestClass"", applyTestClass);
+    }
+
+    public static final class CustomRule implements TestRule {
+
+        public Statement apply(final Statement base, final Description description) {
+            return new Statement() {
+                @Override
+                public void evaluate() throws Throwable {
+                    Class<?> testClass = description.getTestClass();
+                    if(testClass != null) {
+                        Field field = testClass.getDeclaredField(""applyTestClass"");
+                        field.set(null, description.getTestClass());
+                    }
+                    base.evaluate();
+                }
+            };
+        }
+    }
+}
"
https://github.com/square/okhttp/commit/0685dfaa7ff71a8f16b1b71f417b08eff13ec55f,Move TLSv1 and TLSv1.1 to COMPATIBLE_TLS.  <enter> We no longer connect to TLSv1.0 or TLSv1.1 servers out-of-the-box; instead it is necessary to enable COMPATIBLE_TLS in the OkHttpClient configuration. <enter> This is in the path to later removing these TLS versions completely; that is scheduled for March 2020 by some browsers. <enter>  <issue_link> ,https://api.github.com/repos/square/okhttp/commits/0685dfaa7ff71a8f16b1b71f417b08eff13ec55f,"@@ -75,7 +75,8 @@ public void nonRetryableSSLHandshakeException() throws Exception {
   public void retryableSSLHandshakeException() throws Exception {
     ConnectionSpecSelector connectionSpecSelector =
         createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    SSLSocket socket = createSocketWithEnabledProtocols(
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
     connectionSpecSelector.configureSecureSocket(socket);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
@@ -85,20 +86,21 @@ public void retryableSSLHandshakeException() throws Exception {
 
   @Test
   public void someFallbacksSupported() throws Exception {
-    ConnectionSpec sslV3 =
-        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-            .tlsVersions(TlsVersion.SSL_3_0)
-            .build();
+    ConnectionSpec sslV3 = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .tlsVersions(TlsVersion.SSL_3_0)
+        .build();
 
     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
 
-    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
+    TlsVersion[] enabledSocketTlsVersions = {
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0
+    };
     SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
 
     // MODERN_TLS is used here.
     connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
     assertTrue(retry);
@@ -107,7 +109,7 @@ public void someFallbacksSupported() throws Exception {
     // COMPATIBLE_TLS is used here.
     socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
     connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
 
     retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
     assertFalse(retry);
@@ -37,6 +37,12 @@
  *
  * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
  * defer all feature selection to the underlying SSL socket.
+ *
+ * <p>The configuration of each spec changes with each OkHttp release. This is annoying: upgrading
+ * your OkHttp library can break connectivity to certain web servers! But it’s a necessary annoyance
+ * because the TLS ecosystem is dynamic and staying up to date is necessary to stay secure. See
+ * <a href=""https://github.com/square/okhttp/wiki/TLS-Configuration-History"">OkHttp's TLS
+ * Configuration History</a> to track these changes.
  */
 public final class ConnectionSpec {
 
@@ -87,24 +93,31 @@ public final class ConnectionSpec {
       CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
   };
 
-  /** A secure TLS connection assuming a modern client platform and server. */
+  /** A secure TLS connection that requires a recent client platform and a recent server. */
   public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
       .cipherSuites(RESTRICTED_CIPHER_SUITES)
       .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
       .supportsTlsExtensions(true)
       .build();
 
-  /** A modern TLS connection with extensions like SNI and ALPN available. */
+  /**
+   * A modern TLS configuration that works on most client platforms and can connect to most servers.
+   * This is OkHttp's default configuration.
+   */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
       .supportsTlsExtensions(true)
       .build();
 
-  /** A backwards-compatible fallback connection for interop with obsolete servers. */
+  /**
+   * A backwards-compatible fallback configuration that works on obsolete client platforms and can
+   * connect to obsolete servers. When possible, prefer to upgrade your client platform or server
+   * rather than using this configuration.
+   */
   public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
 
@@ -328,6 +341,11 @@ public Builder tlsVersions(String... tlsVersions) {
       return this;
     }
 
+    /**
+     * @deprecated since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.
+     *     In a future release setting this to true will be unnecessary and setting it to false will
+     *     have no effect.
+     */
     public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
       if (!tls) throw new IllegalStateException(""no TLS extensions for cleartext connections"");
       this.supportsTlsExtensions = supportsTlsExtensions;
"
https://github.com/square/retrofit/commit/2d6b02f7cf59235358ef4d574930ce7545ce8619,RxJava 1.0.  <enter> (cherry picked from commit  <otherCommit_link> ) <enter> Conflicts:  <tab> pom.xml ,https://api.github.com/repos/square/retrofit/commits/2d6b02f7cf59235358ef4d574930ce7545ce8619,"@@ -51,7 +51,7 @@
     <android.platform>16</android.platform>
     <gson.version>2.3</gson.version>
     <okhttp.version>2.0.0</okhttp.version>
-    <rxjava.version>1.0.0-rc.4</rxjava.version>
+    <rxjava.version>1.0.0</rxjava.version>
     <appengine.version>1.9.12</appengine.version>
 
     <!-- Converter Dependencies -->
"
https://github.com/square/okhttp/commit/6651a9c15e06e8d1829aa00f970998be2f33b225,Change MediaType's failure mode to not crash on charset problems.  <enter> As-is it throws unchecked exceptions on unexpected charsets. This is a problem because it can cause a misbehaving webserver to crash the client. <enter> I don't expect this to break existing clients; returning 'null' has always been a possibility; it's just returned in more cases. ,https://api.github.com/repos/square/okhttp/commits/6651a9c15e06e8d1829aa00f970998be2f33b225,"@@ -18,7 +18,6 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
@@ -241,15 +240,7 @@ public Level getLevel() {
         Charset charset = UTF8;
         MediaType contentType = responseBody.contentType();
         if (contentType != null) {
-          try {
-            charset = contentType.charset(UTF8);
-          } catch (UnsupportedCharsetException e) {
-            logger.log("""");
-            logger.log(""Couldn't decode the response body; charset is likely malformed."");
-            logger.log(""<-- END HTTP"");
-
-            return response;
-          }
+          charset = contentType.charset(UTF8);
         }
 
         if (!isPlaintext(buffer)) {
@@ -563,7 +563,7 @@ private void bodyGetNoBody(int code) throws IOException {
 
     server.enqueue(new MockResponse()
         .setHeader(""Content-Type"", ""text/html; charset=0"")
-        .setBody(""Ignore This""));
+        .setBody(""Body with unknown charset""));
     Response response = client.newCall(request().build()).execute();
     response.body().close();
 
@@ -578,8 +578,8 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual(""Content-Type: text/html; charset=0"")
         .assertLogMatch(""Content-Length: \\d+"")
         .assertLogMatch("""")
-        .assertLogEqual(""Couldn't decode the response body; charset is likely malformed."")
-        .assertLogEqual(""<-- END HTTP"")
+        .assertLogEqual(""Body with unknown charset"")
+        .assertLogEqual(""<-- END HTTP (25-byte body)"")
         .assertNoMoreLogs();
 
     applicationLogs
@@ -589,8 +589,8 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual(""Content-Type: text/html; charset=0"")
         .assertLogMatch(""Content-Length: \\d+"")
         .assertLogEqual("""")
-        .assertLogEqual(""Couldn't decode the response body; charset is likely malformed."")
-        .assertLogEqual(""<-- END HTTP"")
+        .assertLogEqual(""Body with unknown charset"")
+        .assertLogEqual(""<-- END HTTP (25-byte body)"")
         .assertNoMoreLogs();
   }
 
@@ -17,15 +17,12 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
-import java.nio.charset.IllegalCharsetNameException;
-import java.nio.charset.UnsupportedCharsetException;
 import okhttp3.internal.Util;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 /**
  * Test MediaType API and parsing.
@@ -123,29 +120,17 @@ public class MediaTypeTest {
   }
 
   @Test public void testMultipleCharsets() {
-    try {
-      MediaType.parse(""text/plain; charset=utf-8; charset=utf-16"");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
+    assertNull(MediaType.parse(""text/plain; charset=utf-8; charset=utf-16""));
   }
 
   @Test public void testIllegalCharsetName() {
     MediaType mediaType = MediaType.parse(""text/plain; charset=\""!@#$%^&*()\"""");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testUnsupportedCharset() {
     MediaType mediaType = MediaType.parse(""text/plain; charset=utf-wtf"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (UnsupportedCharsetException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   /**
@@ -159,20 +144,12 @@ public class MediaTypeTest {
 
   @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
     MediaType mediaType = MediaType.parse(""text/plain;charset=\""'utf-8'\"""");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
     MediaType mediaType = MediaType.parse(""text/plain;charset=\""'\"""");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testDefaultCharset() throws Exception {
@@ -189,7 +166,7 @@ public class MediaTypeTest {
     MediaType mediaType = MediaType.parse(""text/plain;"");
     assertEquals(""text"", mediaType.type());
     assertEquals(""plain"", mediaType.subtype());
-    assertEquals(null, mediaType.charset());
+    assertNull(mediaType.charset());
     assertEquals(""text/plain;"", mediaType.toString());
   }
 
@@ -73,7 +73,7 @@ public static MediaType parse(String string) {
         charsetParameter = parameter.group(3);
       }
       if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        throw new IllegalArgumentException(""Multiple different charsets: "" + string);
+        return null; // Multiple different charsets!
       }
       charset = charsetParameter;
     }
@@ -100,15 +100,19 @@ public String subtype() {
    * Returns the charset of this media type, or null if this media type doesn't specify a charset.
    */
   public Charset charset() {
-    return charset != null ? Charset.forName(charset) : null;
+    return charset(null);
   }
 
   /**
-   * Returns the charset of this media type, or {@code defaultValue} if this media type doesn't
-   * specify a charset.
+   * Returns the charset of this media type, or {@code defaultValue} if either this media type
+   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
    */
   public Charset charset(Charset defaultValue) {
-    return charset != null ? Charset.forName(charset) : defaultValue;
+    try {
+      return charset != null ? Charset.forName(charset) : defaultValue;
+    } catch (IllegalArgumentException e) {
+      return defaultValue; // This charset is invalid or unsupported. Give up.
+    }
   }
 
   /**
"
https://github.com/spring-projects/spring-boot/commit/3d27391d47910f73c1e889b76030a53038a38f25,Allow StringSequence.isEmpty() to be compatible with JDK 15  <enter> JDK 15 introduces isEmpty() on CharSequence which clashes with the one declared in StringSequence because it is not public. <enter> See  <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/3d27391d47910f73c1e889b76030a53038a38f25,"@@ -72,7 +72,11 @@ public StringSequence subSequence(int start, int end) {
 		return new StringSequence(this.source, subSequenceStart, subSequenceEnd);
 	}
 
-	boolean isEmpty() {
+	/**
+	 * Returns {@code true} if the sequence is empty. Public to be compatible with JDK 15.
+	 * @return {@code true} if {@link #length()} is {@code 0}, otherwise {@code false}
+	 */
+	public boolean isEmpty() {
 		return length() == 0;
 	}
 
@@ -46,4 +46,5 @@
 	<suppress files=""[\\/]src[\\/]intTest[\\/]java[\\/]"" checks=""SpringJavadoc"" message=""\@since"" />
 	<suppress files=""LinuxDomainSocket"" checks=""FinalClass"" message=""SockaddrUn"" />
 	<suppress files=""BsdDomainSocket"" checks=""FinalClass"" message=""SockaddrUn"" />
+	<suppress files=""StringSequence"" checks=""SpringMethodVisibility"" />
 </suppressions>
"
https://github.com/square/okhttp/commit/c6c7ce7dadf2ccaa04122f57a278a4a96d1f5c50,"DiskLruCache snapshot() method removing entries that are being cached (<pr_link> ) <enter> Fixed a bug I found. When using DiskLruCache, hasNext() method of Iterator<Snapshot> returned by snapshot() method iterates through lruEntries, however if entry is not completed yet, it is removed (together with dirtyFiles) as cleanFiles don't exist yet - during saving response to disk. This caused sometimes file not being cached at all. ",https://api.github.com/repos/square/okhttp/commits/c6c7ce7dadf2ccaa04122f57a278a4a96d1f5c50,"@@ -706,6 +706,8 @@ class DiskLruCache internal constructor(
 
           while (delegate.hasNext()) {
             val entry = delegate.next()
+            if (entry == null || !entry.readable) continue // Entry during edit
+
             val snapshot = entry.snapshot() ?: continue
             // Evicted since we copied the entries.
             nextSnapshot = snapshot
@@ -1643,6 +1643,25 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertAbsent(""k1"");
   }
 
+  @Test public void dontRemoveUnfinishedEntryWhenCreatingSnapshot() throws Exception {
+    DiskLruCache.Editor creator = cache.edit(""k1"");
+    setString(creator, 0, ""ABC"");
+    setString(creator, 1, ""DE"");
+
+    assertThat(creator.newSource(0)).isNull();
+    assertThat(creator.newSource(1)).isNull();
+
+    Iterator<DiskLruCache.Snapshot> snapshotWhileEditing = cache.snapshots();
+    assertThat(snapshotWhileEditing.hasNext()).isFalse(); // entry still is being created/edited
+    creator.commit();
+
+    Iterator<DiskLruCache.Snapshot> snapshotAfterCommit = cache.snapshots();
+
+    assertThat(snapshotAfterCommit.hasNext())
+        .withFailMessage(""Entry has been removed during creation."")
+        .isTrue();
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
"
https://github.com/spring-projects/spring-boot/commit/3a8a1272855a82c1d454920b423c49ced826428a,Implement simpler exclusion logic for Gradle  <enter> Simplify the exclusion logic used in Gradle by implementing implicit exclusions rather than trying to detect transitive excludes. <enter> This commit reverts much of the code originally included to  fix   <issue_link>  which adds far too much complexity to the build and still doesn't solve the underlying issue. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/3a8a1272855a82c1d454920b423c49ced826428a,"@@ -105,12 +105,8 @@
 				<skipTests>true</skipTests>
 			</properties>
 			<modules>
-				<module>spring-boot-dependencies</module>
 				<module>spring-boot-versions</module>
 				<module>spring-boot-parent</module>
-				<module>spring-boot</module>
-				<module>spring-boot-autoconfigure</module>
-				<module>spring-boot-actuator</module>
 				<module>spring-boot-starters</module>
 				<module>spring-boot-tools</module>
 			</modules>
@@ -1,4 +1,5 @@
-<?xml version=""1.0"" encoding=""UTF-8""?><project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
 	<groupId>org.springframework.boot</groupId>
 	<artifactId>spring-boot-dependencies</artifactId>
@@ -1283,4 +1284,4 @@
 			</plugins>
 		</pluginManagement>
 	</build>
-</project>
\ No newline at end of file
+</project>
@@ -296,8 +296,7 @@ which does not have an `exclusion` element.
 
 To ensure that correct exclusions are actually applied, the Spring Boot Gradle plugin will
 automatically add exclusion rules. All exclusions defined in the
-`spring-boot-dependencies` POM and the ``starter'' POMs will be added (both direct and
-transitive exclusions).
+`spring-boot-dependencies` POM and implicit rules for the ``starter'' POMs will be added.
 
 If you don't want exclusion rules automatically applied you can use the following
 configuration:
@@ -37,7 +37,7 @@
 /**
  * Tests for war packaging with Gradle to ensure that only the Servlet container and its
  * dependencies are packaged in WEB-INF/lib-provided
- *
+ * 
  * @author Andy Wilkinson
  */
 public class WarPackagingTests {
@@ -54,6 +54,7 @@ public class WarPackagingTests {
 			Arrays.asList(WEB_INF_LIB_PROVIDED_PREFIX + ""spring-boot-starter-jetty-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-util-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-xml-"",
+					WEB_INF_LIB_PROVIDED_PREFIX + ""javax.servlet-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-continuation-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-io-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-http-"",
@@ -20,7 +20,6 @@
 		<main.basedir>${basedir}/..</main.basedir>
 	</properties>
 	<modules>
-		<!-- If you add a starter remember to also add a dependency in spring-boot-versions -->
 		<module>spring-boot-starter</module>
 		<module>spring-boot-starter-amqp</module>
 		<module>spring-boot-starter-aop</module>
@@ -30,7 +30,7 @@
 				<artifactId>maven-dependency-plugin</artifactId>
 				<executions>
 					<execution>
-						<id>copy-resources</id>
+						<id>copy-effective-pom</id>
 						<phase>generate-resources</phase>
 						<goals>
 							<goal>copy</goal>
@@ -46,15 +46,6 @@
 									<outputDirectory>${generated.pom.dir}</outputDirectory>
 									<destFileName>effective-pom.xml</destFileName>
 								</artifactItem>
-								<artifactItem>
-									<groupId>org.springframework.boot</groupId>
-									<artifactId>spring-boot-versions</artifactId>
-									<version>${project.version}</version>
-									<type>dependency-tree</type>
-									<overWrite>true</overWrite>
-									<outputDirectory>${generated.pom.dir}</outputDirectory>
-									<destFileName>dependency-tree.txt</destFileName>
-								</artifactItem>
 							</artifactItems>
 						</configuration>
 					</execution>
@@ -1,131 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import org.springframework.boot.dependency.tools.Dependency.Exclusion;
-import org.springframework.boot.dependency.tools.Dependency.ExclusionType;
-
-/**
- * {@link Dependencies} to extend an existing {@link Dependencies} instance with
- * transitive {@link Exclusion}s located from a {@link DependencyTree}.
- * 
- * @author Phillip Webb
- * @since 1.1.0
- */
-class DependenciesWithTransitiveExclusions extends AbstractDependencies {
-
-	public DependenciesWithTransitiveExclusions(Dependencies dependencies,
-			DependencyTree tree) {
-		DependencyBuilder builder = new DependencyBuilder(dependencies);
-		builder.addTransitiveExcludes(tree);
-		builder.finish();
-	}
-
-	/**
-	 * Builder used to collect the transitive exclusions.
-	 */
-	private class DependencyBuilder {
-
-		private Map<ArtifactAndGroupId, DependencyAndTransitiveExclusions> dependencies;
-
-		public DependencyBuilder(Dependencies dependencies) {
-			this.dependencies = new LinkedHashMap<ArtifactAndGroupId, DependencyAndTransitiveExclusions>();
-			for (Dependency dependency : dependencies) {
-				this.dependencies.put(new ArtifactAndGroupId(dependency),
-						new DependencyAndTransitiveExclusions(dependency));
-			}
-		}
-
-		public void addTransitiveExcludes(DependencyTree tree) {
-			for (DependencyNode node : tree) {
-				DependencyAndTransitiveExclusions dependency = this.dependencies
-						.get(asArtifactAndGroupId(node));
-				if (dependency != null) {
-					for (DependencyNode child : node) {
-						addTransitiveExcludes(dependency, child);
-					}
-				}
-			}
-		}
-
-		private void addTransitiveExcludes(DependencyAndTransitiveExclusions dependency,
-				DependencyNode node) {
-			DependencyAndTransitiveExclusions exclusions = this.dependencies
-					.get(asArtifactAndGroupId(node));
-			if (exclusions != null) {
-				dependency.addTransitiveExclusions(exclusions.getSourceDependency());
-			}
-			for (DependencyNode child : node) {
-				addTransitiveExcludes(dependency, child);
-			}
-		}
-
-		private ArtifactAndGroupId asArtifactAndGroupId(DependencyNode node) {
-			return new ArtifactAndGroupId(node.getGroupId(), node.getArtifactId());
-		}
-
-		public void finish() {
-			for (Map.Entry<ArtifactAndGroupId, DependencyAndTransitiveExclusions> entry : this.dependencies
-					.entrySet()) {
-				add(entry.getKey(), entry.getValue().createNewDependency());
-			}
-		}
-
-	}
-
-	/**
-	 * Holds a {@link Dependency} with additional transitive {@link Exclusion}s.
-	 */
-	private static class DependencyAndTransitiveExclusions {
-
-		private Dependency dependency;
-
-		private Set<Exclusion> transitiveExclusions = new LinkedHashSet<Exclusion>();
-
-		public DependencyAndTransitiveExclusions(Dependency dependency) {
-			this.dependency = dependency;
-		}
-
-		public Dependency getSourceDependency() {
-			return this.dependency;
-		}
-
-		public void addTransitiveExclusions(Dependency dependency) {
-			for (Exclusion exclusion : dependency.getExclusions()) {
-				this.transitiveExclusions.add(new Exclusion(exclusion.getGroupId(),
-						exclusion.getArtifactId(), ExclusionType.TRANSITIVE));
-			}
-		}
-
-		public Dependency createNewDependency() {
-			Set<Exclusion> exclusions = new LinkedHashSet<Dependency.Exclusion>();
-			exclusions.addAll(this.dependency.getExclusions());
-			exclusions.addAll(this.transitiveExclusions);
-			return new Dependency(this.dependency.getGroupId(),
-					this.dependency.getArtifactId(), this.dependency.getVersion(),
-					new ArrayList<Exclusion>(exclusions));
-		}
-
-	}
-
-}
@@ -137,15 +137,11 @@ public static final class Exclusion {
 
 		private final String artifactId;
 
-		private final ExclusionType type;
-
-		Exclusion(String groupId, String artifactId, ExclusionType type) {
+		Exclusion(String groupId, String artifactId) {
 			Assert.notNull(groupId, ""GroupId must not be null"");
 			Assert.notNull(groupId, ""ArtifactId must not be null"");
-			Assert.notNull(type, ""Type must not be null"");
 			this.groupId = groupId;
 			this.artifactId = artifactId;
-			this.type = type;
 		}
 
 		/**
@@ -162,10 +158,6 @@ public String getGroupId() {
 			return this.groupId;
 		}
 
-		public ExclusionType getType() {
-			return this.type;
-		}
-
 		@Override
 		public String toString() {
 			return this.groupId + "":"" + this.artifactId;
@@ -196,22 +188,4 @@ public boolean equals(Object obj) {
 
 	}
 
-	public static enum ExclusionType {
-
-		/**
-		 * An exclusion that was specified directly on the dependency.
-		 */
-		DIRECT,
-
-		/**
-		 * An exclusion that is was specified on a dependency of this dependency. For
-		 * example if {@literal commons-logging} is directly excluded from
-		 * {@literal spring-core} then it is also transitive exclude on
-		 * {@literal spring-context} (since {@literal spring-context} depends on
-		 * {@literal spring-core}).
-		 */
-		TRANSITIVE
-
-	}
-
 }
@@ -1,82 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * A single node in a {@link DependencyTree}.
- * 
- * @author Phillip Webb
- * @see DependencyTree
- * @since 1.1.0
- */
-class DependencyNode implements Iterable<DependencyNode> {
-
-	private final String groupId;
-
-	private final String artifactId;
-
-	private final String version;
-
-	private List<DependencyNode> dependencies;
-
-	DependencyNode(String groupId, String artifactId, String version) {
-		this.groupId = groupId;
-		this.artifactId = artifactId;
-		this.version = version;
-		this.dependencies = new ArrayList<DependencyNode>();
-	}
-
-	@Override
-	public Iterator<DependencyNode> iterator() {
-		return getDependencies().iterator();
-	}
-
-	public String getGroupId() {
-		return this.groupId;
-	}
-
-	public String getArtifactId() {
-		return this.artifactId;
-	}
-
-	public String getVersion() {
-		return this.version;
-	}
-
-	public List<DependencyNode> getDependencies() {
-		return Collections.unmodifiableList(this.dependencies);
-	}
-
-	@Override
-	public String toString() {
-		return this.groupId + "":"" + this.artifactId + "":"" + this.version;
-	}
-
-	void addDependency(DependencyNode node) {
-		this.dependencies.add(node);
-	}
-
-	DependencyNode getLastDependency() {
-		return this.dependencies.get(this.dependencies.size() - 1);
-	}
-
-}
@@ -1,159 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.ArrayDeque;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Dependency tree information that can be loaded from the output of
- * {@literal mvn dependency:tree}.
- * 
- * @author Phillip Webb
- * @since 1.1.0
- * @see DependencyNode
- */
-class DependencyTree implements Iterable<DependencyNode> {
-
-	private final DependencyNode root;
-
-	/**
-	 * Create a new {@link DependencyTree} instance for the given input stream.
-	 * @param inputStream input stream containing content from
-	 * {@literal mvn dependency:tree} (the stream will be closed).
-	 */
-	public DependencyTree(InputStream inputStream) {
-		try {
-			this.root = parse(inputStream);
-		}
-		catch (IOException ex) {
-			throw new IllegalStateException(ex);
-		}
-	}
-
-	private DependencyNode parse(InputStream inputStream) throws IOException {
-		try {
-			BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-			Parser parser = new Parser();
-			String line;
-			while ((line = reader.readLine()) != null) {
-				parser.append(line);
-			}
-			return parser.getRoot();
-		}
-		finally {
-			inputStream.close();
-		}
-	}
-
-	@Override
-	public Iterator<DependencyNode> iterator() {
-		return getDependencies().iterator();
-	}
-
-	/**
-	 * @return the root node for the tree.
-	 */
-	public DependencyNode getRoot() {
-		return this.root;
-	}
-
-	/**
-	 * @return the dependencies of the root node.
-	 */
-	public List<DependencyNode> getDependencies() {
-		return this.root.getDependencies();
-	}
-
-	/**
-	 * Return the node at the specified index.
-	 * @param index the index (multiple indexes can be used to traverse the tree)
-	 * @return the node at the specified index
-	 */
-	public DependencyNode get(int... index) {
-		DependencyNode rtn = this.root;
-		for (int i : index) {
-			rtn = rtn.getDependencies().get(i);
-		}
-		return rtn;
-	}
-
-	private static class Parser {
-
-		private static final int INDENT = 3;
-
-		private static final Set<Character> PREFIX_CHARS = new HashSet<Character>(
-				Arrays.asList(' ', '+', '-', '\\', '|'));
-
-		private static final Pattern LINE_PATTERN = Pattern
-				.compile(""[(]?([^:]*):([^:]*):([^:]*):([^:\\s]*)"");
-
-		private Deque<DependencyNode> stack = new ArrayDeque<DependencyNode>();
-
-		public void append(String line) {
-			int depth = getDepth(line);
-			String data = line.substring(depth * INDENT);
-			if (depth == 0) {
-				this.stack.push(createNode(data));
-			}
-			else {
-				while (depth < this.stack.size()) {
-					this.stack.pop();
-				}
-				if (depth > this.stack.size()) {
-					this.stack.push(this.stack.peek().getLastDependency());
-				}
-				this.stack.peek().addDependency(createNode(data));
-			}
-		}
-
-		private int getDepth(String line) {
-			for (int i = 0; i < line.length(); i++) {
-				if (!Parser.PREFIX_CHARS.contains(line.charAt(i))) {
-					return i / INDENT;
-				}
-			}
-			return 0;
-		}
-
-		private DependencyNode createNode(String line) {
-			Matcher matcher = LINE_PATTERN.matcher(line);
-			if (!matcher.find()) {
-				throw new IllegalStateException(""Unable to parese line "" + line);
-			}
-			return new DependencyNode(matcher.group(1), matcher.group(2),
-					matcher.group(4));
-		}
-
-		public DependencyNode getRoot() {
-			return this.stack.getLast();
-		}
-
-	}
-
-}
@@ -57,11 +57,7 @@ private void addAll(Dependencies dependencies) {
 
 	private static Dependencies getSpringBootDependencies() {
 		if (springBootDependencies == null) {
-			Dependencies dependencies = new PomDependencies(
-					getResource(""effective-pom.xml""));
-			DependencyTree tree = new DependencyTree(getResource(""dependency-tree.txt""));
-			dependencies = new DependenciesWithTransitiveExclusions(dependencies, tree);
-			springBootDependencies = dependencies;
+			springBootDependencies = new PomDependencies(getResource(""effective-pom.xml""));
 		}
 		return springBootDependencies;
 	}
@@ -25,7 +25,6 @@
 import javax.xml.parsers.DocumentBuilderFactory;
 
 import org.springframework.boot.dependency.tools.Dependency.Exclusion;
-import org.springframework.boot.dependency.tools.Dependency.ExclusionType;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
@@ -119,7 +118,7 @@ private List<Exclusion> createExclusions(Node item) {
 	private Exclusion createExclusion(Element element) {
 		String groupId = getTextContent(element, ""groupId"");
 		String artifactId = getTextContent(element, ""artifactId"");
-		return new Exclusion(groupId, artifactId, ExclusionType.DIRECT);
+		return new Exclusion(groupId, artifactId);
 	}
 
 	private String getTextContent(Element element, String tagName) {
@@ -1,50 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import org.junit.Test;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.assertThat;
-
-/**
- * Tests for {@link DependenciesWithTransitiveExclusions}.
- * 
- * @author Phillip Webb
- */
-public class DependenciesWithTransitiveExclusionsTests {
-
-	@Test
-	public void findsTransitiveExclusions() throws Exception {
-		Dependencies source = new PomDependencies(getClass().getResourceAsStream(
-				""test-effective-pom.xml""));
-		DependencyTree tree = new DependencyTree(getClass().getResourceAsStream(
-				""test-effective-pom-dependency-tree.txt""));
-		DependenciesWithTransitiveExclusions dependencies = new DependenciesWithTransitiveExclusions(
-				source, tree);
-		assertExcludes(dependencies, ""sample01"", ""[org.exclude:exclude01]"");
-		assertExcludes(source, ""sample02"", ""[]"");
-		assertExcludes(dependencies, ""sample02"", ""[org.exclude:exclude01]"");
-	}
-
-	private void assertExcludes(Dependencies dependencies, String artifactId,
-			String expected) {
-		Dependency dependency = dependencies.find(""org.sample"", artifactId);
-		assertThat(dependency.getExclusions().toString(), equalTo(expected));
-	}
-
-}
@@ -1,44 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import org.junit.Test;
-import org.springframework.boot.dependency.tools.DependencyTree;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.assertThat;
-
-/**
- * Tests for {@link DependencyTree}.
- * 
- * @author Phillip Webb
- */
-public class DependencyTreeTests {
-
-	@Test
-	public void parse() throws Exception {
-		DependencyTree tree = new DependencyTree(getClass().getResourceAsStream(
-				""sample-dependency-tree.txt""));
-		assertThat(tree.getRoot().toString(), equalTo(""org.springframework.boot:""
-				+ ""spring-boot-versions-dependency-tree:1.1.0.BUILD-SNAPSHOT""));
-		assertThat(tree.getDependencies().size(), equalTo(204));
-		assertThat(tree.get(0, 1).toString(), equalTo(""org.slf4j:slf4j-api:1.7.6""));
-		assertThat(tree.get(203).toString(), equalTo(""org.springframework.security:""
-				+ ""spring-security-web:3.2.4.RELEASE""));
-	}
-
-}
@@ -1,1087 +0,0 @@
-org.springframework.boot:spring-boot-versions-dependency-tree:pom:1.1.0.BUILD-SNAPSHOT
-+- ch.qos.logback:logback-classic:jar:1.1.2:compile
-|  +- ch.qos.logback:logback-core:jar:1.1.2:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.6:compile - omitted for conflict with 1.7.7)
-+- com.codahale.metrics:metrics-graphite:jar:3.0.2:compile
-|  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-+- com.codahale.metrics:metrics-ganglia:jar:3.0.2:compile
-|  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  +- info.ganglia.gmetric4j:gmetric4j:jar:1.0.3:compile
-|  |  \- org.acplt:oncrpc:jar:1.0.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-+- com.codahale.metrics:metrics-core:jar:3.0.2:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-+- com.codahale.metrics:metrics-servlets:jar:3.0.2:compile
-|  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  +- com.codahale.metrics:metrics-healthchecks:jar:3.0.2:compile
-|  |  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- com.codahale.metrics:metrics-json:jar:3.0.2:compile
-|  |  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  |  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.2.2:compile - omitted for duplicate)
-|  |  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- com.codahale.metrics:metrics-jvm:jar:3.0.2:compile
-|  |  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  |  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.2.2:compile - omitted for conflict with 2.3.3)
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-+- org.codehaus.janino:janino:jar:2.6.1:compile
-|  \- org.codehaus.janino:commons-compiler:jar:2.6.1:compile
-+- com.fasterxml.jackson.core:jackson-annotations:jar:2.3.3:compile
-+- com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile
-+- com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.0:compile - omitted for conflict with 2.3.3)
-|  \- (com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile - omitted for duplicate)
-+- com.fasterxml.jackson.datatype:jackson-datatype-joda:jar:2.3.3:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.0:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile - omitted for duplicate)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile - omitted for duplicate)
-|  \- (joda-time:joda-time:jar:2.1:compile - omitted for conflict with 2.3)
-+- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.3.3:compile
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile - omitted for duplicate)
-|  \- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile - omitted for duplicate)
-+- com.gemstone.gemfire:gemfire:jar:7.0.2:compile
-|  \- (antlr:antlr:jar:2.7.7:compile - scope updated from runtime; omitted for duplicate)
-+- com.h2database:h2:jar:1.3.175:compile
-+- com.zaxxer:HikariCP:jar:1.3.8:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  \- (org.javassist:javassist:jar:3.18.1-GA:compile - omitted for duplicate)
-+- commons-beanutils:commons-beanutils:jar:1.9.2:compile
-|  \- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-+- commons-collections:commons-collections:jar:3.2.1:compile
-+- commons-dbcp:commons-dbcp:jar:1.4:compile
-|  \- (commons-pool:commons-pool:jar:1.5.4:compile - omitted for conflict with 1.6)
-+- commons-digester:commons-digester:jar:2.1:compile
-|  \- (commons-beanutils:commons-beanutils:jar:1.8.3:compile - omitted for conflict with 1.9.2)
-+- commons-pool:commons-pool:jar:1.6:compile
-+- javax.jms:jms-api:jar:1.1-rev-1:compile
-+- javax.servlet:javax.servlet-api:jar:3.0.1:compile
-+- javax.servlet:jstl:jar:1.2:compile
-+- joda-time:joda-time:jar:2.3:compile
-+- junit:junit:jar:4.11:compile
-|  \- (org.hamcrest:hamcrest-core:jar:1.3:compile - omitted for duplicate)
-+- log4j:log4j:jar:1.2.17:compile
-+- mysql:mysql-connector-java:jar:5.1.30:compile
-+- nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect:jar:1.2.4:compile
-|  \- (org.thymeleaf:thymeleaf:jar:2.1.2.RELEASE:compile - omitted for conflict with 2.1.3.RELEASE)
-+- org.apache.activemq:activemq-client:jar:5.9.1:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- org.apache.geronimo.specs:geronimo-jms_1.1_spec:jar:1.1.1:compile
-|  +- org.fusesource.hawtbuf:hawtbuf:jar:1.9:compile
-|  \- org.apache.geronimo.specs:geronimo-j2ee-management_1.1_spec:jar:1.0.1:compile
-+- org.apache.activemq:activemq-broker:jar:5.9.1:compile
-|  +- (org.apache.activemq:activemq-client:jar:5.9.1:compile - omitted for duplicate)
-|  \- org.apache.activemq:activemq-openwire-legacy:jar:5.9.1:compile
-|     \- (org.apache.activemq:activemq-client:jar:5.9.1:compile - omitted for duplicate)
-+- org.apache.activemq:activemq-pool:jar:5.9.1:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- org.apache.activemq:activemq-jms-pool:jar:5.9.1:compile
-|  |  +- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  |  +- (org.apache.geronimo.specs:geronimo-jms_1.1_spec:jar:1.1.1:compile - omitted for duplicate)
-|  |  +- (org.apache.geronimo.specs:geronimo-jta_1.0.1B_spec:jar:1.0.1:compile - omitted for duplicate)
-|  |  \- (commons-pool:commons-pool:jar:1.6:compile - omitted for duplicate)
-|  +- (org.apache.activemq:activemq-client:jar:5.9.1:compile - omitted for duplicate)
-|  +- org.apache.geronimo.specs:geronimo-jta_1.0.1B_spec:jar:1.0.1:compile
-|  \- (commons-pool:commons-pool:jar:1.6:compile - omitted for duplicate)
-+- org.apache.commons:commons-pool2:jar:2.2:compile
-+- org.apache.httpcomponents:httpclient:jar:4.3.3:compile
-|  +- org.apache.httpcomponents:httpcore:jar:4.3.2:compile
-|  +- commons-logging:commons-logging:jar:1.1.3:compile
-|  \- commons-codec:commons-codec:jar:1.6:compile
-+- org.apache.httpcomponents:httpmime:jar:4.3.3:compile
-|  \- (org.apache.httpcomponents:httpclient:jar:4.3.3:compile - omitted for duplicate)
-+- org.apache.httpcomponents:httpasyncclient:jar:4.0.1:compile
-|  +- (org.apache.httpcomponents:httpcore:jar:4.3.2:compile - omitted for duplicate)
-|  +- org.apache.httpcomponents:httpcore-nio:jar:4.3.2:compile
-|  |  \- (org.apache.httpcomponents:httpcore:jar:4.3.2:compile - omitted for duplicate)
-|  +- (org.apache.httpcomponents:httpclient:jar:4.3.2:compile - omitted for conflict with 4.3.3)
-|  \- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)
-+- org.apache.tomcat.embed:tomcat-embed-core:jar:7.0.54:compile
-+- org.apache.tomcat.embed:tomcat-embed-el:jar:7.0.54:compile
-+- org.apache.tomcat.embed:tomcat-embed-logging-juli:jar:7.0.54:compile
-+- org.apache.tomcat.embed:tomcat-embed-jasper:jar:7.0.54:compile
-|  +- (org.apache.tomcat.embed:tomcat-embed-core:jar:7.0.54:compile - omitted for duplicate)
-|  +- (org.apache.tomcat.embed:tomcat-embed-el:jar:7.0.54:compile - omitted for duplicate)
-|  \- org.eclipse.jdt.core.compiler:ecj:jar:P20140317-1600:compile
-+- org.apache.tomcat.embed:tomcat-embed-websocket:jar:7.0.54:compile
-|  \- (org.apache.tomcat.embed:tomcat-embed-core:jar:7.0.54:compile - omitted for duplicate)
-+- org.apache.tomcat:tomcat-jdbc:jar:7.0.54:compile
-|  \- org.apache.tomcat:tomcat-juli:jar:7.0.54:compile
-+- org.apache.tomcat:tomcat-jsp-api:jar:7.0.54:compile
-|  +- org.apache.tomcat:tomcat-el-api:jar:7.0.54:compile
-|  \- org.apache.tomcat:tomcat-servlet-api:jar:7.0.54:compile
-+- org.apache.velocity:velocity:jar:1.7:compile
-|  +- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-|  \- commons-lang:commons-lang:jar:2.4:compile
-+- org.apache.velocity:velocity-tools:jar:2.0:compile
-|  +- (commons-beanutils:commons-beanutils:jar:1.7.0:compile - omitted for conflict with 1.9.2)
-|  +- (commons-digester:commons-digester:jar:1.8:compile - omitted for conflict with 2.1)
-|  +- commons-chain:commons-chain:jar:1.1:compile
-|  |  +- (commons-beanutils:commons-beanutils:jar:1.7.0:compile - omitted for conflict with 1.9.2)
-|  |  +- (commons-digester:commons-digester:jar:1.6:compile - omitted for conflict with 2.1)
-|  |  \- (commons-logging:commons-logging:jar:1.0.3:compile - omitted for conflict with 1.1.3)
-|  +- (commons-collections:commons-collections:jar:3.2:compile - omitted for conflict with 3.2.1)
-|  +- (commons-logging:commons-logging:jar:1.1:compile - omitted for conflict with 1.1.3)
-|  +- commons-validator:commons-validator:jar:1.3.1:compile
-|  |  +- (commons-beanutils:commons-beanutils:jar:1.7.0:compile - omitted for conflict with 1.9.2)
-|  |  +- (commons-digester:commons-digester:jar:1.6:compile - omitted for conflict with 2.1)
-|  |  \- (commons-logging:commons-logging:jar:1.0.4:compile - omitted for conflict with 1.1.3)
-|  +- dom4j:dom4j:jar:1.1:compile
-|  +- oro:oro:jar:2.0.8:compile
-|  +- sslext:sslext:jar:1.2-0:compile
-|  +- org.apache.struts:struts-core:jar:1.3.8:compile
-|  |  +- antlr:antlr:jar:2.7.7:compile
-|  |  +- (commons-beanutils:commons-beanutils:jar:1.7.0:compile - omitted for conflict with 1.9.2)
-|  |  +- (commons-chain:commons-chain:jar:1.1:compile - omitted for duplicate)
-|  |  +- (commons-digester:commons-digester:jar:1.8:compile - omitted for conflict with 2.1)
-|  |  +- (commons-logging:commons-logging:jar:1.0.4:compile - omitted for conflict with 1.1.3)
-|  |  +- (commons-validator:commons-validator:jar:1.3.1:compile - omitted for duplicate)
-|  |  \- (oro:oro:jar:2.0.8:compile - omitted for duplicate)
-|  +- org.apache.struts:struts-taglib:jar:1.3.8:compile
-|  |  \- (org.apache.struts:struts-core:jar:1.3.8:compile - omitted for duplicate)
-|  +- org.apache.struts:struts-tiles:jar:1.3.8:compile
-|  |  \- (org.apache.struts:struts-core:jar:1.3.8:compile - omitted for duplicate)
-|  \- (org.apache.velocity:velocity:jar:1.6.2:compile - omitted for conflict with 1.7)
-+- org.aspectj:aspectjrt:jar:1.8.0:compile
-+- org.aspectj:aspectjtools:jar:1.8.0:compile
-+- org.aspectj:aspectjweaver:jar:1.8.0:compile
-+- org.codehaus.groovy:groovy:jar:2.3.2:compile
-+- org.codehaus.groovy:groovy-all:jar:2.3.2:compile
-+- org.codehaus.groovy:groovy-ant:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-groovydoc:jar:2.3.2:compile - omitted for duplicate)
-|  +- org.apache.ant:ant-antlr:jar:1.9.3:runtime
-|  +- org.apache.ant:ant:jar:1.9.3:compile
-|  |  \- org.apache.ant:ant-launcher:jar:1.9.3:compile
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.apache.ant:ant-launcher:jar:1.9.3:compile - scope updated from runtime; omitted for duplicate)
-|  \- org.apache.ant:ant-junit:jar:1.9.3:runtime
-|     \- (org.apache.ant:ant:jar:1.9.3:runtime - omitted for duplicate)
-+- org.codehaus.groovy:groovy-bsf:jar:2.3.2:compile
-|  +- (commons-logging:commons-logging:jar:1.1.1:compile - omitted for conflict with 1.1.3)
-|  +- bsf:bsf:jar:2.4.0:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-console:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-swing:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.codehaus.groovy:groovy-templates:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-docgenerator:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-templates:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  \- com.thoughtworks.qdox:qdox:jar:1.12.1:compile
-+- org.codehaus.groovy:groovy-groovydoc:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-templates:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-groovysh:jar:2.3.2:compile
-|  +- jline:jline:jar:2.11:compile
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy-console:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-jmx:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-json:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-jsr223:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-nio:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-servlet:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-xml:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.codehaus.groovy:groovy-templates:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-sql:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-swing:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-templates:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-xml:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-test:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  \- (junit:junit:jar:4.11:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-testng:jar:2.3.2:compile
-|  +- com.beust:jcommander:jar:1.35:compile
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  \- org.testng:testng:jar:6.8.8:runtime
-+- org.codehaus.groovy:groovy-xml:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.crashub:crash.cli:jar:1.3.0-cr4:compile
-+- org.crashub:crash.connectors.ssh:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  +- org.apache.sshd:sshd-core:jar:0.11.0:compile
-|  |  \- (org.apache.mina:mina-core:jar:2.0.7:compile - omitted for duplicate)
-|  +- org.apache.sshd:sshd-pam:jar:0.11.0:compile
-|  |  +- (org.apache.sshd:sshd-core:jar:0.11.0:compile - omitted for duplicate)
-|  |  \- net.sf.jpam:jpam:jar:1.1:compile
-|  |     \- (commons-logging:commons-logging:jar:1.0.4:compile - omitted for conflict with 1.1.3)
-|  +- org.bouncycastle:bcprov-jdk15on:jar:1.49:compile
-|  +- org.bouncycastle:bcpkix-jdk15on:jar:1.49:compile
-|  |  \- (org.bouncycastle:bcprov-jdk15on:jar:1.49:compile - omitted for duplicate)
-|  \- org.apache.mina:mina-core:jar:2.0.7:compile
-|     \- (org.slf4j:slf4j-api:jar:1.6.6:compile - omitted for conflict with 1.7.6)
-+- org.crashub:crash.connectors.telnet:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  \- net.wimpi:telnetd-x:jar:2.1.1:compile
-|     +- (log4j:log4j:jar:1.2.9:compile - omitted for conflict with 1.2.17)
-|     \- (commons-logging:commons-logging:jar:1.1:compile - omitted for conflict with 1.1.3)
-+- org.crashub:crash.embed.spring:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:3.1.1.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-web:jar:3.1.1.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.1.1.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-beans:jar:3.1.1.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.crashub:crash.plugins.cron:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  \- it.sauronsoftware.cron4j:cron4j:jar:2.2.5:compile
-+- org.crashub:crash.plugins.mail:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  \- javax.mail:mail:jar:1.4:compile
-|     \- javax.activation:activation:jar:1.1:compile
-+- org.crashub:crash.shell:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.cli:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy-all:jar:1.8.9:compile - omitted for conflict with 2.3.2)
-+- org.eclipse.jetty:jetty-annotations:jar:8.1.15.v20140411:compile
-|  +- org.eclipse.jetty:jetty-plus:jar:8.1.15.v20140411:compile
-|  |  +- org.eclipse.jetty.orbit:javax.transaction:jar:1.1.1.v201105210645:compile
-|  |  +- (org.eclipse.jetty:jetty-webapp:jar:8.1.15.v20140411:compile - omitted for duplicate)
-|  |  \- org.eclipse.jetty:jetty-jndi:jar:8.1.15.v20140411:compile
-|  |     +- org.eclipse.jetty:jetty-server:jar:8.1.15.v20140411:compile
-|  |     |  +- (org.eclipse.jetty.orbit:javax.servlet:jar:3.0.0.v201112011016:compile - omitted for duplicate)
-|  |     |  +- org.eclipse.jetty:jetty-continuation:jar:8.1.15.v20140411:compile
-|  |     |  \- org.eclipse.jetty:jetty-http:jar:8.1.15.v20140411:compile
-|  |     |     \- org.eclipse.jetty:jetty-io:jar:8.1.15.v20140411:compile
-|  |     |        \- (org.eclipse.jetty:jetty-util:jar:8.1.15.v20140411:compile - omitted for duplicate)
-|  |     \- org.eclipse.jetty.orbit:javax.mail.glassfish:jar:1.4.1.v201005082020:compile
-|  |        \- org.eclipse.jetty.orbit:javax.activation:jar:1.1.0.v201105071233:compile
-|  +- (org.eclipse.jetty:jetty-webapp:jar:8.1.15.v20140411:compile - omitted for duplicate)
-|  +- org.eclipse.jetty.orbit:javax.annotation:jar:1.1.0.v201108011116:compile
-|  \- org.eclipse.jetty.orbit:org.objectweb.asm:jar:3.1.0.v200803061910:compile
-+- org.eclipse.jetty:jetty-jsp:jar:8.1.15.v20140411:compile
-|  +- (org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.2.0.v201112011158:compile - omitted for duplicate)
-|  +- org.eclipse.jetty.orbit:org.apache.jasper.glassfish:jar:2.2.2.v201112011158:compile
-|  |  \- (org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.2.0.v201112011158:compile - omitted for duplicate)
-|  +- org.eclipse.jetty.orbit:javax.servlet.jsp.jstl:jar:1.2.0.v201105211821:compile
-|  |  \- (org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.1.0.v201105211820:compile - omitted for conflict with 2.2.0.v201112011158)
-|  +- org.eclipse.jetty.orbit:org.apache.taglibs.standard.glassfish:jar:1.2.0.v201112081803:compile
-|  |  \- (org.eclipse.jetty.orbit:javax.servlet.jsp.jstl:jar:1.2.0.v201105211821:compile - omitted for duplicate)
-|  +- org.eclipse.jetty.orbit:javax.el:jar:2.2.0.v201108011116:compile
-|  +- org.eclipse.jetty.orbit:com.sun.el:jar:2.2.0.v201108011116:compile
-|  \- org.eclipse.jetty.orbit:org.eclipse.jdt.core:jar:3.7.1:compile
-+- org.eclipse.jetty:jetty-webapp:jar:8.1.15.v20140411:compile
-|  +- org.eclipse.jetty:jetty-xml:jar:8.1.15.v20140411:compile
-|  |  \- (org.eclipse.jetty:jetty-util:jar:8.1.15.v20140411:compile - omitted for duplicate)
-|  \- org.eclipse.jetty:jetty-servlet:jar:8.1.15.v20140411:compile
-|     \- org.eclipse.jetty:jetty-security:jar:8.1.15.v20140411:compile
-|        \- (org.eclipse.jetty:jetty-server:jar:8.1.15.v20140411:compile - omitted for duplicate)
-+- org.eclipse.jetty:jetty-util:jar:8.1.15.v20140411:compile
-+- org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.2.0.v201112011158:compile
-|  \- org.eclipse.jetty.orbit:javax.servlet:jar:3.0.0.v201112011016:compile
-+- org.freemarker:freemarker:jar:2.3.20:compile
-+- org.flywaydb:flyway-core:jar:3.0:compile
-+- org.hamcrest:hamcrest-core:jar:1.3:compile
-+- org.hamcrest:hamcrest-library:jar:1.3:compile
-|  \- (org.hamcrest:hamcrest-core:jar:1.3:compile - omitted for duplicate)
-+- org.hibernate:hibernate-entitymanager:jar:4.3.1.Final:compile
-|  +- org.jboss.logging:jboss-logging:jar:3.1.3.GA:compile
-|  +- org.jboss.logging:jboss-logging-annotations:jar:1.2.0.Beta1:compile
-|  +- org.hibernate:hibernate-core:jar:4.3.1.Final:compile
-|  |  +- (org.jboss.logging:jboss-logging:jar:3.1.3.GA:compile - omitted for duplicate)
-|  |  +- (org.jboss.logging:jboss-logging-annotations:jar:1.2.0.Beta1:compile - omitted for duplicate)
-|  |  +- (org.jboss.spec.javax.transaction:jboss-transaction-api_1.2_spec:jar:1.0.0.Final:compile - omitted for duplicate)
-|  |  +- (dom4j:dom4j:jar:1.6.1:compile - omitted for conflict with 1.1)
-|  |  +- (org.hibernate.common:hibernate-commons-annotations:jar:4.0.4.Final:compile - omitted for duplicate)
-|  |  +- (org.hibernate.javax.persistence:hibernate-jpa-2.1-api:jar:1.0.0.Final:compile - omitted for duplicate)
-|  |  +- (org.javassist:javassist:jar:3.18.1-GA:compile - omitted for duplicate)
-|  |  +- (antlr:antlr:jar:2.7.7:compile - omitted for duplicate)
-|  |  \- org.jboss:jandex:jar:1.1.0.Final:compile
-|  +- (dom4j:dom4j:jar:1.6.1:compile - omitted for conflict with 1.1)
-|  +- org.hibernate.common:hibernate-commons-annotations:jar:4.0.4.Final:compile
-|  |  +- (org.jboss.logging:jboss-logging:jar:3.1.3.GA:compile - omitted for duplicate)
-|  |  \- (org.jboss.logging:jboss-logging-annotations:jar:1.2.0.Beta1:compile - omitted for duplicate)
-|  +- org.hibernate.javax.persistence:hibernate-jpa-2.1-api:jar:1.0.0.Final:compile
-|  +- org.jboss.spec.javax.transaction:jboss-transaction-api_1.2_spec:jar:1.0.0.Final:compile
-|  \- (org.javassist:javassist:jar:3.18.1-GA:compile - omitted for duplicate)
-+- org.hibernate:hibernate-validator:jar:5.0.3.Final:compile
-|  +- javax.validation:validation-api:jar:1.1.0.Final:compile
-|  +- (org.jboss.logging:jboss-logging:jar:3.1.1.GA:compile - omitted for conflict with 3.1.3.GA)
-|  \- com.fasterxml:classmate:jar:1.0.0:compile
-+- org.hibernate.javax.persistence:hibernate-jpa-2.0-api:jar:1.0.1.Final:compile
-+- org.hornetq:hornetq-jms-server:jar:2.4.1.Final:compile
-|  +- org.hornetq:hornetq-core-client:jar:2.4.1.Final:compile
-|  |  +- org.jgroups:jgroups:jar:3.3.4.Final:compile
-|  |  +- org.hornetq:hornetq-commons:jar:2.4.1.Final:compile
-|  |  |  +- (org.jboss.logging:jboss-logging:jar:3.1.0.GA:compile - omitted for conflict with 3.1.3.GA)
-|  |  |  \- (io.netty:netty-all:jar:4.0.13.Final:compile - omitted for duplicate)
-|  |  +- org.hornetq:hornetq-journal:jar:2.4.1.Final:compile
-|  |  |  +- (org.jboss.logging:jboss-logging:jar:3.1.0.GA:compile - omitted for conflict with 3.1.3.GA)
-|  |  |  +- (org.hornetq:hornetq-commons:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  |  \- org.hornetq:hornetq-native:jar:2.4.1.Final:compile
-|  |  |     \- (org.hornetq:hornetq-commons:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  \- (io.netty:netty-all:jar:4.0.13.Final:compile - omitted for conflict with 4.0.19.Final)
-|  +- (org.hornetq:hornetq-jms-client:jar:2.4.1.Final:compile - omitted for duplicate)
-|  +- org.hornetq:hornetq-server:jar:2.4.1.Final:compile
-|  |  +- (org.jboss.logging:jboss-logging:jar:3.1.0.GA:compile - omitted for conflict with 3.1.3.GA)
-|  |  +- (org.hornetq:hornetq-commons:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  +- (org.hornetq:hornetq-journal:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  +- (org.hornetq:hornetq-core-client:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  \- (io.netty:netty-all:jar:4.0.13.Final:compile - omitted for duplicate)
-|  +- org.jboss.spec.javax.jms:jboss-jms-api_2.0_spec:jar:1.0.0.Final:compile
-|  +- org.jboss.spec.javax.transaction:jboss-transaction-api_1.1_spec:jar:1.0.0.Final:compile
-|  +- org.jboss:jboss-transaction-spi:jar:7.0.0.Final:compile
-|  |  +- org.jboss.spec.javax.resource:jboss-connector-api_1.5_spec:jar:1.0.0.Final:compile
-|  |  |  \- (org.jboss.spec.javax.transaction:jboss-transaction-api_1.1_spec:jar:1.0.0.Final:compile - omitted for duplicate)
-|  |  \- (org.jboss.spec.javax.transaction:jboss-transaction-api_1.1_spec:jar:1.0.1.Beta1:compile - omitted for conflict with 1.0.0.Final)
-|  \- org.jboss.naming:jnpserver:jar:5.0.3.GA:compile
-|     \- org.jboss:jboss-common-core:jar:2.2.10.GA:compile
-+- org.hornetq:hornetq-jms-client:jar:2.4.1.Final:compile
-|  +- (org.hornetq:hornetq-core-client:jar:2.4.1.Final:compile - omitted for duplicate)
-|  +- (org.jboss.spec.javax.jms:jboss-jms-api_2.0_spec:jar:1.0.0.Final:compile - omitted for duplicate)
-|  \- javax.inject:javax.inject:jar:1:compile
-+- org.hsqldb:hsqldb:jar:2.3.2:compile
-+- org.javassist:javassist:jar:3.18.1-GA:compile
-+- org.jolokia:jolokia-core:jar:1.2.1:compile
-|  \- com.googlecode.json-simple:json-simple:jar:1.1:compile
-+- org.liquibase:liquibase-core:jar:3.0.8:compile
-|  \- (org.yaml:snakeyaml:jar:1.13:compile - omitted for duplicate)
-+- org.mongodb:mongo-java-driver:jar:2.12.1:compile
-+- org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile
-|  +- com.goldmansachs:gs-collections:jar:5.0.0:compile
-|  |  \- com.goldmansachs:gs-collections-api:jar:5.0.0:compile
-|  +- com.lmax:disruptor:jar:3.2.1:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor:reactor-groovy:jar:1.1.2.RELEASE:compile
-|  +- (org.codehaus.groovy:groovy-all:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.projectreactor:reactor-groovy-extensions:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor:reactor-groovy-extensions:jar:1.1.2.RELEASE:compile
-|  +- (org.codehaus.groovy:groovy-all:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor:reactor-logback:jar:1.1.2.RELEASE:compile
-|  +- (ch.qos.logback:logback-classic:jar:1.1.2:compile - omitted for duplicate)
-|  +- commons-cli:commons-cli:jar:1.2:compile
-|  +- net.openhft:chronicle:jar:2.0.3:compile
-|  |  +- net.openhft:lang:jar:6.1.4:compile
-|  |  |  \- (org.kohsuke.jetbrains:annotations:jar:9.0:compile - omitted for duplicate)
-|  |  \- org.kohsuke.jetbrains:annotations:jar:9.0:compile
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor:reactor-net:jar:1.1.2.RELEASE:compile
-|  +- io.netty:netty-all:jar:4.0.19.Final:compile
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor.spring:reactor-spring-core:jar:1.1.2.RELEASE:compile
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-|  +- (org.springframework:spring-beans:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-context:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-core:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (org.springframework:spring-expression:jar:4.0.3.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.projectreactor.spring:reactor-spring-context:jar:1.1.2.RELEASE:compile
-|  +- com.jayway.jsonpath:json-path:jar:0.9.0:compile
-|  |  +- net.minidev:json-smart:jar:1.2:compile
-|  |  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- (org.projectreactor.spring:reactor-spring-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-|  \- (org.springframework:spring-context-support:jar:4.0.3.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.projectreactor.spring:reactor-spring-messaging:jar:1.1.2.RELEASE:compile
-|  +- (org.projectreactor.spring:reactor-spring-context:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.projectreactor:reactor-net:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-|  \- (org.springframework:spring-messaging:jar:4.0.3.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.projectreactor.spring:reactor-spring-webmvc:jar:1.1.2.RELEASE:compile
-|  +- (org.projectreactor.spring:reactor-spring-context:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-|  \- (org.springframework:spring-webmvc:jar:4.0.3.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.mockito:mockito-core:jar:1.9.5:compile
-|  +- (org.hamcrest:hamcrest-core:jar:1.1:compile - omitted for conflict with 1.3)
-|  \- org.objenesis:objenesis:jar:1.0:compile
-+- org.slf4j:jcl-over-slf4j:jar:1.7.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.slf4j:log4j-over-slf4j:jar:1.7.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.slf4j:slf4j-api:jar:1.7.7:compile
-+- org.slf4j:jul-to-slf4j:jar:1.7.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-+- org.slf4j:slf4j-jdk14:jar:1.7.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-+- org.slf4j:slf4j-log4j12:jar:1.7.7:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (log4j:log4j:jar:1.2.17:compile - omitted for duplicate)
-+- org.apache.solr:solr-solrj:jar:4.7.2:compile
-|  +- commons-io:commons-io:jar:2.1:compile
-|  +- (log4j:log4j:jar:1.2.16:compile - omitted for conflict with 1.2.17)
-|  +- (org.apache.httpcomponents:httpclient:jar:4.3.1:compile - omitted for conflict with 4.3.3)
-|  +- (org.apache.httpcomponents:httpcore:jar:4.3:compile - omitted for conflict with 4.3.2)
-|  +- (org.apache.httpcomponents:httpmime:jar:4.3.1:compile - omitted for conflict with 4.3.3)
-|  +- org.apache.zookeeper:zookeeper:jar:3.4.5:compile
-|  +- org.codehaus.woodstox:wstx-asl:jar:3.2.7:compile
-|  +- org.noggit:noggit:jar:0.5:compile
-|  \- (org.slf4j:slf4j-api:jar:1.6.6:compile - omitted for conflict with 1.7.7)
-+- org.spockframework:spock-core:jar:0.7-groovy-2.0:compile
-|  +- junit:junit-dep:jar:4.10:compile
-|  |  \- (org.hamcrest:hamcrest-core:jar:1.1:compile - omitted for conflict with 1.3)
-|  \- (org.hamcrest:hamcrest-core:jar:1.3:compile - omitted for duplicate)
-+- org.springframework:spring-core:jar:4.0.5.RELEASE:compile
-|  \- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)
-+- org.springframework:springloaded:jar:1.2.0.RELEASE:compile
-+- org.springframework.amqp:spring-amqp:jar:1.3.4.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.amqp:spring-erlang:jar:1.3.4.RELEASE:compile
-|  +- org.erlang.otp:jinterface:jar:1.5.6:compile
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (commons-io:commons-io:jar:2.4:compile - omitted for conflict with 2.1)
-+- org.springframework.amqp:spring-rabbit:jar:1.3.4.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- org.springframework.retry:spring-retry:jar:1.1.0.RELEASE:compile
-|  |  \- (org.springframework:spring-context:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework.amqp:spring-amqp:jar:1.3.4.RELEASE:compile - omitted for duplicate)
-|  \- com.rabbitmq:amqp-client:jar:3.3.1:compile
-+- org.springframework.batch:spring-batch-core:jar:3.0.0.RELEASE:compile
-|  +- com.ibm.jbatch:com.ibm.jbatch-tck-spi:jar:1.0:compile
-|  |  \- javax.batch:javax.batch-api:jar:1.0:compile
-|  +- com.thoughtworks.xstream:xstream:jar:1.4.7:compile
-|  |  +- xmlpull:xmlpull:jar:1.1.3.1:compile
-|  |  \- xpp3:xpp3_min:jar:1.1.4c:compile
-|  +- org.codehaus.jettison:jettison:jar:1.2:compile
-|  +- (org.springframework.batch:spring-batch-infrastructure:jar:3.0.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework.batch:spring-batch-infrastructure:jar:3.0.0.RELEASE:compile
-|  +- (org.springframework.retry:spring-retry:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework.batch:spring-batch-integration:jar:3.0.0.RELEASE:compile
-|  +- (org.springframework.batch:spring-batch-core:jar:3.0.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.1.RELEASE:compile - omitted for conflict with 4.0.2.RELEASE)
-|  +- (org.springframework.retry:spring-retry:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-messaging:jar:4.0.5.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework.batch:spring-batch-test:jar:3.0.0.RELEASE:compile
-|  +- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-|  +- (commons-io:commons-io:jar:2.4:compile - omitted for conflict with 2.1)
-|  +- (junit:junit:jar:4.10:compile - omitted for conflict with 4.11)
-|  +- org.hamcrest:hamcrest-all:jar:1.3:compile
-|  +- (org.springframework.batch:spring-batch-core:jar:3.0.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-jdbc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-test:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework.hateoas:spring-hateoas:jar:0.12.0.RELEASE:compile
-|  +- (org.springframework:spring-aop:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-web:jar:3.2.9.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-webmvc:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-|  +- (org.objenesis:objenesis:jar:2.1:compile - omitted for conflict with 1.0)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-http:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-webmvc:jar:4.0.5.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-|  +- net.java.dev.rome:rome-fetcher:jar:1.0.0:compile
-|  |  +- jdom:jdom:jar:1.0:compile
-|  |  +- xerces:xercesImpl:jar:2.4.0:compile
-|  |  +- (net.java.dev.rome:rome:jar:1.0.0:compile - omitted for duplicate)
-|  |  +- commons-httpclient:commons-httpclient:jar:3.0.1:compile
-|  |  |  +- (commons-logging:commons-logging:jar:1.0.3:compile - omitted for conflict with 1.1.3)
-|  |  |  \- (commons-codec:commons-codec:jar:1.2:compile - omitted for conflict with 1.6)
-|  |  +- (commons-logging:commons-logging:jar:1.0.4:compile - omitted for conflict with 1.1.3)
-|  |  \- commons-logging:commons-logging-api:jar:1.0.4:compile
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for conflict with 4.0.1.RELEASE)
-+- org.springframework.mobile:spring-mobile-device:jar:1.1.2.RELEASE:compile
-|  +- (org.springframework:spring-webmvc:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-|  \- (org.springframework:spring-web:jar:3.2.9.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-+- org.springframework.security:spring-security-jwt:jar:1.0.2.RELEASE:compile
-|  +- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile
-|  |  \- (org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile - omitted for conflict with 1.9.12)
-|  \- (org.bouncycastle:bcpkix-jdk15on:jar:1.47:compile - omitted for conflict with 1.49)
-+- org.springframework.social:spring-social-config:jar:1.1.0.RELEASE:compile
-|  +- (org.springframework.social:spring-social-web:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile
-|  \- (org.springframework:spring-web:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-+- org.springframework.social:spring-social-security:jar:1.1.0.RELEASE:compile
-|  +- (org.springframework.social:spring-social-web:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-web:jar:3.2.3.RELEASE:compile - omitted for conflict with 3.2.4.RELEASE)
-|  +- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-web:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (org.springframework:spring-webmvc:jar:4.0.3.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-web:jar:1.1.0.RELEASE:compile
-|  +- (javax.inject:javax.inject:jar:1:compile - omitted for duplicate)
-|  +- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-web:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (org.springframework:spring-webmvc:jar:4.0.3.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-facebook:jar:1.1.1.RELEASE:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (org.springframework.social:spring-social-config:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  \- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-facebook-web:jar:1.1.1.RELEASE:compile
-|  +- (org.springframework:spring-web:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework.social:spring-social-facebook:jar:1.1.1.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-webmvc:jar:4.0.3.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-twitter:jar:1.1.0.RELEASE:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (org.springframework.security:spring-security-crypto:jar:3.2.3.RELEASE:compile - omitted for conflict with 3.2.4.RELEASE)
-|  +- (org.springframework.social:spring-social-config:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  \- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-linkedin:jar:1.0.1.RELEASE:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.social:spring-social-config:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-+- org.thymeleaf:thymeleaf:jar:2.1.3.RELEASE:compile
-|  +- ognl:ognl:jar:3.0.6:compile
-|  +- (org.javassist:javassist:jar:3.16.1-GA:compile - omitted for conflict with 3.18.1-GA)
-|  +- org.unbescape:unbescape:jar:1.0:compile
-|  \- (org.slf4j:slf4j-api:jar:1.6.1:compile - omitted for conflict with 1.7.7)
-+- org.thymeleaf.extras:thymeleaf-extras-springsecurity3:jar:2.1.1.RELEASE:compile
-|  +- (org.thymeleaf:thymeleaf:jar:2.1.2.RELEASE:compile - omitted for conflict with 2.1.3.RELEASE)
-|  \- (org.slf4j:slf4j-api:jar:1.6.1:compile - omitted for conflict with 1.7.7)
-+- org.thymeleaf:thymeleaf-spring4:jar:2.1.3.RELEASE:compile
-|  +- (org.thymeleaf:thymeleaf:jar:2.1.3.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.6.1:compile - omitted for conflict with 1.7.7)
-+- org.yaml:snakeyaml:jar:1.13:compile
-+- redis.clients:jedis:jar:2.4.1:compile
-|  \- (org.apache.commons:commons-pool2:jar:2.0:compile - omitted for conflict with 2.2)
-+- org.springframework:spring-aop:jar:4.0.5.RELEASE:compile
-|  +- aopalliance:aopalliance:jar:1.0:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-aspects:jar:4.0.5.RELEASE:compile
-|  \- (org.aspectj:aspectjweaver:jar:1.7.4:compile - omitted for conflict with 1.8.0)
-+- org.springframework:spring-beans:jar:4.0.5.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-context:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-expression:jar:4.0.5.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-+- org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-expression:jar:4.0.5.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-instrument:jar:4.0.5.RELEASE:compile
-+- org.springframework:spring-instrument-tomcat:jar:4.0.5.RELEASE:compile
-+- org.springframework:spring-jdbc:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework:spring-jms:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework:spring-messaging:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-orm:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-jdbc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework:spring-oxm:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-test:jar:4.0.5.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-tx:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-web:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-webmvc:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-expression:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-web:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-webmvc-portlet:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-web:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-webmvc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-websocket:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-web:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework.data:spring-data-cassandra:jar:1.0.0.RELEASE:compile
-|  +- org.springframework.data:spring-cql:jar:1.0.0.RELEASE:compile
-|  |  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework:spring-expression:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  |  +- (com.datastax.cassandra:cassandra-driver-dse:jar:2.0.2:compile - omitted for duplicate)
-|  |  +- org.apache.cassandra:cassandra-all:jar:2.0.6:compile
-|  |  |  +- org.xerial.snappy:snappy-java:jar:1.0.5:compile
-|  |  |  +- net.jpountz.lz4:lz4:jar:1.2.0:compile
-|  |  |  +- com.ning:compress-lzf:jar:0.8.4:compile
-|  |  |  +- (commons-cli:commons-cli:jar:1.1:compile - omitted for conflict with 1.2)
-|  |  |  +- (commons-codec:commons-codec:jar:1.2:compile - omitted for conflict with 1.6)
-|  |  |  +- (org.apache.commons:commons-lang3:jar:3.1:compile - omitted for duplicate)
-|  |  |  +- (com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:jar:1.3:compile - omitted for conflict with 1.3.1)
-|  |  |  +- org.antlr:antlr:jar:3.2:compile
-|  |  |  |  \- org.antlr:antlr-runtime:jar:3.2:compile
-|  |  |  |     \- org.antlr:stringtemplate:jar:3.2:compile
-|  |  |  |        \- (antlr:antlr:jar:2.7.7:compile - omitted for duplicate)
-|  |  |  +- (org.slf4j:slf4j-api:jar:1.7.2:compile - omitted for conflict with 1.7.7)
-|  |  |  +- (org.codehaus.jackson:jackson-core-asl:jar:1.9.2:compile - omitted for conflict with 1.9.13)
-|  |  |  +- (org.codehaus.jackson:jackson-mapper-asl:jar:1.9.2:compile - omitted for conflict with 1.9.13)
-|  |  |  +- (jline:jline:jar:1.0:compile - omitted for conflict with 2.11)
-|  |  |  +- (com.googlecode.json-simple:json-simple:jar:1.1:compile - omitted for duplicate)
-|  |  |  +- com.github.stephenc.high-scale-lib:high-scale-lib:jar:1.1.2:compile
-|  |  |  +- (org.yaml:snakeyaml:jar:1.11:compile - omitted for conflict with 1.13)
-|  |  |  +- edu.stanford.ppl:snaptree:jar:0.1:compile
-|  |  |  +- org.mindrot:jbcrypt:jar:0.3m:compile
-|  |  |  +- com.yammer.metrics:metrics-core:jar:2.2.0:compile
-|  |  |  |  \- (org.slf4j:slf4j-api:jar:1.7.2:compile - omitted for conflict with 1.7.7)
-|  |  |  +- com.addthis.metrics:reporter-config:jar:2.1.0:compile
-|  |  |  |  +- (org.slf4j:slf4j-api:jar:1.7.2:compile - omitted for conflict with 1.7.7)
-|  |  |  |  +- (org.yaml:snakeyaml:jar:1.12:compile - omitted for conflict with 1.13)
-|  |  |  |  +- (org.hibernate:hibernate-validator:jar:4.3.0.Final:compile - omitted for conflict with 5.0.3.Final)
-|  |  |  |  \- (com.yammer.metrics:metrics-core:jar:2.2.0:compile - omitted for duplicate)
-|  |  |  +- com.thinkaurelius.thrift:thrift-server:jar:0.3.3:compile
-|  |  |  |  +- (com.lmax:disruptor:jar:3.0.1:compile - omitted for conflict with 3.2.1)
-|  |  |  |  +- (org.apache.thrift:libthrift:jar:0.9.1:compile - omitted for duplicate)
-|  |  |  |  +- (org.slf4j:slf4j-api:jar:1.6.1:compile - omitted for conflict with 1.7.7)
-|  |  |  |  \- (junit:junit:jar:4.8.1:compile - omitted for conflict with 4.11)
-|  |  |  +- net.sf.supercsv:super-csv:jar:2.1.0:compile
-|  |  |  +- (log4j:log4j:jar:1.2.16:compile - omitted for conflict with 1.2.17)
-|  |  |  +- org.apache.thrift:libthrift:jar:0.9.1:compile
-|  |  |  |  +- (org.slf4j:slf4j-api:jar:1.5.8:compile - omitted for conflict with 1.7.7)
-|  |  |  |  +- (org.apache.commons:commons-lang3:jar:3.1:compile - omitted for duplicate)
-|  |  |  |  +- (org.apache.httpcomponents:httpclient:jar:4.2.5:compile - omitted for conflict with 4.3.3)
-|  |  |  |  \- (org.apache.httpcomponents:httpcore:jar:4.2.4:compile - omitted for conflict with 4.3.2)
-|  |  |  +- org.apache.cassandra:cassandra-thrift:jar:2.0.6:compile
-|  |  |  |  +- (org.apache.commons:commons-lang3:jar:3.1:compile - omitted for duplicate)
-|  |  |  |  +- (org.slf4j:slf4j-api:jar:1.7.2:compile - omitted for conflict with 1.7.7)
-|  |  |  |  \- (org.apache.thrift:libthrift:jar:0.9.1:compile - omitted for duplicate)
-|  |  |  +- com.github.stephenc:jamm:jar:0.2.5:compile
-|  |  |  \- (io.netty:netty:jar:3.6.6.Final:compile - omitted for conflict with 3.5.5.Final)
-|  |  +- (com.google.guava:guava:jar:15.0:compile - omitted for conflict with 16.0.1)
-|  |  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  |  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-|  +- (org.springframework:spring-expression:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- com.datastax.cassandra:cassandra-driver-dse:jar:2.0.2:compile
-|  |  \- com.datastax.cassandra:cassandra-driver-core:jar:2.0.2:compile
-|  |     +- (io.netty:netty:jar:3.9.0.Final:compile - omitted for conflict with 3.6.6.Final)
-|  |     \- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-couchbase:jar:1.1.0.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-web:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- com.couchbase.client:couchbase-client:jar:1.4.1:compile
-|  |  +- io.netty:netty:jar:3.5.5.Final:compile
-|  |  +- (org.codehaus.jettison:jettison:jar:1.1:compile - omitted for conflict with 1.2)
-|  |  +- (commons-codec:commons-codec:jar:1.5:compile - omitted for conflict with 1.6)
-|  |  +- net.spy:spymemcached:jar:2.11.2:compile
-|  |  +- (org.apache.httpcomponents:httpcore:jar:4.3:compile - omitted for conflict with 4.3.2)
-|  |  \- (org.apache.httpcomponents:httpcore-nio:jar:4.3:compile - omitted for conflict with 4.3.2)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-elasticsearch:jar:1.0.0.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- (commons-lang:commons-lang:jar:2.6:compile - omitted for conflict with 2.4)
-|  +- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-|  +- (joda-time:joda-time:jar:2.3:compile - omitted for duplicate)
-|  +- org.elasticsearch:elasticsearch:jar:1.1.1:compile
-|  |  +- org.apache.lucene:lucene-core:jar:4.7.2:compile
-|  |  +- org.apache.lucene:lucene-analyzers-common:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-codecs:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-queries:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-memory:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-highlighter:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  +- (org.apache.lucene:lucene-memory:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-queryparser:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  +- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-sandbox:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-sandbox:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-suggest:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-analyzers-common:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  +- (org.apache.lucene:lucene-misc:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-misc:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-join:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-grouping:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-grouping:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |  \- org.apache.lucene:lucene-spatial:jar:4.7.2:compile
-|  |     +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |     +- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |     \- com.spatial4j:spatial4j:jar:0.4.1:compile
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile - omitted for duplicate)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-gemfire:jar:1.4.0.RELEASE:compile
-|  +- (antlr:antlr:jar:2.7.7:compile - scope updated from runtime; omitted for duplicate)
-|  +- (org.slf4j:jcl-over-slf4j:jar:1.7.6:compile - omitted for conflict with 1.7.7)
-|  +- (org.aspectj:aspectjweaver:jar:1.7.4:compile - omitted for conflict with 1.8.0)
-|  +- (org.slf4j:slf4j-api:jar:1.7.6:compile - omitted for conflict with 1.7.7)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- (com.gemstone.gemfire:gemfire:jar:7.0.2:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.codehaus.jackson:jackson-mapper-asl:jar:1.9.12:compile - omitted for conflict with 1.9.13)
-|  +- (org.springframework:spring-aop:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context-support:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- org.codehaus.jackson:jackson-core-asl:jar:1.9.12:compile
-+- org.springframework.data:spring-data-jpa:jar:1.6.0.RELEASE:compile
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-orm:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-aop:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.aspectj:aspectjrt:jar:1.8.0:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-mongodb:jar:1.5.0.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-expression:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.mongodb:mongo-java-driver:jar:2.12.1:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-neo4j:jar:3.1.0.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-aspects:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-expression:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.aspectj:aspectjrt:jar:1.8.0:compile - omitted for duplicate)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- org.neo4j:neo4j-cypher-dsl:jar:2.0.1:compile
-|  +- org.neo4j:neo4j:jar:2.0.3:compile
-|  |  +- org.neo4j:neo4j-kernel:jar:2.0.3:compile
-|  |  |  \- org.apache.geronimo.specs:geronimo-jta_1.1_spec:jar:1.1.1:compile
-|  |  +- org.neo4j:neo4j-lucene-index:jar:2.0.3:compile
-|  |  |  +- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-core:jar:3.6.2:compile - omitted for conflict with 4.7.2)
-|  |  +- org.neo4j:neo4j-graph-algo:jar:2.0.3:compile
-|  |  |  \- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-udc:jar:2.0.3:compile
-|  |  |  \- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-graph-matching:jar:2.0.3:compile
-|  |  |  \- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- (org.neo4j:neo4j-cypher:jar:2.0.3:compile - omitted for duplicate)
-|  |  \- org.neo4j:neo4j-jmx:jar:2.0.3:compile
-|  +- org.neo4j:neo4j-cypher:jar:2.0.3:compile
-|  |  +- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- (org.neo4j:neo4j-lucene-index:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- (org.neo4j:neo4j-graph-matching:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- (org.neo4j:neo4j-graph-algo:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-cypher-commons:jar:2.0.3:compile
-|  |  |  +- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  +- (com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:jar:1.3.1:compile - omitted for conflict with 1.3)
-|  |  |  \- (org.scala-lang:scala-library:jar:2.10.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-cypher-compiler-1.9:jar:2.0.3:compile
-|  |  |  +- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  +- (org.neo4j:neo4j-lucene-index:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  +- (org.neo4j:neo4j-graph-matching:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  +- (org.neo4j:neo4j-graph-algo:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  \- (org.scala-lang:scala-library:jar:2.10.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-cypher-compiler-2.0:jar:2.0.3:compile
-|  |  |  +- org.parboiled:parboiled-scala_2.10:jar:1.1.6:compile
-|  |  |  |  \- org.parboiled:parboiled-core:jar:1.1.6:compile
-|  |  |  +- net.sf.opencsv:opencsv:jar:2.0:compile
-|  |  |  \- (org.scala-lang:scala-library:jar:2.10.3:compile - omitted for duplicate)
-|  |  +- com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:jar:1.3.1:compile
-|  |  \- org.scala-lang:scala-library:jar:2.10.3:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-redis:jar:1.3.0.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-aop:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context-support:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.7)
-+- org.springframework.data:spring-data-rest-webmvc:jar:2.1.0.RELEASE:compile
-|  +- org.springframework.data:spring-data-rest-core:jar:2.1.0.RELEASE:compile
-|  |  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework.hateoas:spring-hateoas:jar:0.12.0.RELEASE:compile - omitted for duplicate)
-|  |  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  |  +- org.springframework.plugin:spring-plugin-core:jar:1.1.0.RELEASE:compile
-|  |  |  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  |  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  |  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  |  \- (org.slf4j:slf4j-api:jar:1.7.6:compile - omitted for conflict with 1.7.7)
-|  |  +- org.atteo:evo-inflector:jar:1.1:compile
-|  |  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.3:compile - omitted for duplicate)
-|  |  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  |  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-|  +- (org.springframework:spring-webmvc:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-solr:jar:1.2.0.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- org.apache.commons:commons-lang3:jar:3.1:compile
-|  +- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-|  +- (org.apache.httpcomponents:httpclient:jar:4.2.2:compile - omitted for conflict with 4.3.3)
-|  +- (org.apache.httpcomponents:httpmime:jar:4.2.2:compile - omitted for conflict with 4.3.3)
-|  +- org.apache.httpcomponents:httpclient-cache:jar:4.2.2:compile
-|  |  \- (org.apache.httpcomponents:httpclient:jar:4.2.2:compile - omitted for conflict with 4.3.3)
-|  +- (org.apache.solr:solr-solrj:jar:4.7.2:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.integration:spring-integration-amqp:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.amqp:spring-rabbit:jar:1.3.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for conflict with 4.0.1.RELEASE)
-+- org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.retry:spring-retry:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-messaging:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-event:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-feed:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (net.java.dev.rome:rome-fetcher:jar:1.0.0:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- net.java.dev.rome:rome:jar:1.0.0:compile
-|     \- (jdom:jdom:jar:1.0:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-file:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (commons-io:commons-io:jar:2.4:compile - omitted for conflict with 2.1)
-+- org.springframework.integration:spring-integration-ftp:jar:4.0.2.RELEASE:compile
-|  +- commons-net:commons-net:jar:3.3:compile
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-file:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-gemfire:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.data:spring-data-gemfire:jar:1.4.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-groovy:jar:4.0.2.RELEASE:compile
-|  +- (org.codehaus.groovy:groovy-all:jar:2.3.1:compile - omitted for conflict with 2.3.2)
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-scripting:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-ip:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-jdbc:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-jdbc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- com.google.guava:guava:jar:16.0.1:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-jms:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-jms:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-jmx:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-jpa:jar:4.0.2.RELEASE:compile
-|  +- org.eclipse.persistence:javax.persistence:jar:2.0.0:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-orm:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-mail:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-mongodb:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.data:spring-data-mongodb:jar:1.5.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-mqtt:jar:4.0.2.RELEASE:compile
-|  +- org.eclipse.paho:mqtt-client:jar:0.4.0:compile
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-redis:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.data:spring-data-redis:jar:1.3.0.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-rmi:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-scripting:jar:4.0.2.RELEASE:compile
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-security:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.security:spring-security-config:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-sftp:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.integration:spring-integration-stream:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-file:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- com.jcraft:jsch:jar:0.1.51:compile
-+- org.springframework.integration:spring-integration-stream:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-syslog:jar:4.0.2.RELEASE:compile
-|  \- (org.springframework.integration:spring-integration-ip:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-test:jar:4.0.2.RELEASE:compile
-|  +- (org.mockito:mockito-core:jar:1.9.5:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-test:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (junit:junit:jar:4.11:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.hamcrest:hamcrest-all:jar:1.3:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-twitter:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.social:spring-social-twitter:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-web:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-ws:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-webmvc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-oxm:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- org.springframework.ws:spring-ws-core:jar:2.2.0.RELEASE:compile
-|  |  +- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)
-|  |  \- (org.springframework.ws:spring-xml:jar:2.2.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-expression:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-xml:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-oxm:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- org.springframework.ws:spring-xml:jar:2.2.0.RELEASE:compile
-|     \- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-xmpp:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  +- org.igniterealtime.smack:smack:jar:3.2.1:compile
-|  \- org.igniterealtime.smack:smackx:jar:3.2.1:compile
-+- org.springframework.security:spring-security-acl:jar:3.2.4.RELEASE:compile
-|  +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-jdbc:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-tx:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-aspects:jar:3.2.4.RELEASE:compile
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-cas:jar:3.2.4.RELEASE:compile
-|  +- org.jasig.cas.client:cas-client-core:jar:3.2.1:compile
-|  |  \- (commons-logging:commons-logging:jar:1.1:compile - omitted for conflict with 1.1.3)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-web:jar:3.2.4.RELEASE:compile - omitted for conflict with 3.2.3.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-config:jar:3.2.4.RELEASE:compile
-|  +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile
-|  +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-expression:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-crypto:jar:3.2.4.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-ldap:jar:3.2.4.RELEASE:compile
-|  +- org.springframework.ldap:spring-ldap-core:jar:1.3.2.RELEASE:compile
-|  |  \- (commons-lang:commons-lang:jar:2.4:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-tx:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-openid:jar:3.2.4.RELEASE:compile
-|  +- com.google.inject:guice:jar:2.0:compile
-|  |  \- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- org.openid4java:openid4java-nodeps:jar:0.9.6:compile
-|  |  +- (commons-logging:commons-logging:jar:1.1.1:compile - omitted for conflict with 1.1.3)
-|  |  \- net.jcip:jcip-annotations:jar:1.0:compile
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-web:jar:3.2.4.RELEASE:compile - omitted for conflict with 3.2.3.RELEASE)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- net.sourceforge.nekohtml:nekohtml:jar:1.9.20:runtime
-|  |  \- (xerces:xercesImpl:jar:2.10.0:runtime - omitted for conflict with 2.4.0)
-|  \- (org.apache.httpcomponents:httpclient:jar:4.2.3:runtime - omitted for conflict with 4.3.3)
-+- org.springframework.security:spring-security-remoting:jar:3.2.4.RELEASE:compile
-|  +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-taglibs:jar:3.2.4.RELEASE:compile
-|  +- (org.springframework.security:spring-security-acl:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-web:jar:3.2.4.RELEASE:compile - omitted for conflict with 3.2.3.RELEASE)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-expression:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-\- org.springframework.security:spring-security-web:jar:3.2.4.RELEASE:compile
-   +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-   +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-   +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-   +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-   +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-   +- (org.springframework:spring-expression:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-   \- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
@@ -1,5 +0,0 @@
-org.sample:sample:pom:1.0.0.BUILD-SNAPSHOT
-+- org.sample:sample01:jar:1.0.0:compile
-+- org.sample:sample02:jar:1.0.0:compile
-|  +- (org.sample:sample01:jar:1.0.0:compile - omitted for duplicate)
-\- org.springframework.boot:spring-boot:jar:1.0.0.BUILD-SNAPSHOT:compile
@@ -2,8 +2,6 @@
 <project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
 	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
-	<groupId>org.sample</groupId>
-	<artifactId>sample</artifactId>
 	<version>1.0.0.BUILD-SNAPSHOT</version>
 	<properties>
 		<sample.version>1.0.0</sample.version>
@@ -47,17 +47,19 @@ public ApplyExcludeRules(Project project) {
 	@Override
 	public void execute(Configuration configuration) {
 		if (!VersionManagedDependencies.CONFIGURATION.equals(configuration.getName())) {
-			configuration.getIncoming().beforeResolve(new Action<ResolvableDependencies>() {
-				@Override
-				public void execute(ResolvableDependencies resolvableDependencies) {
-					resolvableDependencies.getDependencies().all(new Action<Dependency>() {
+			configuration.getIncoming().beforeResolve(
+					new Action<ResolvableDependencies>() {
 						@Override
-						public void execute(Dependency dependency) {
-							applyExcludeRules(dependency);
+						public void execute(ResolvableDependencies resolvableDependencies) {
+							resolvableDependencies.getDependencies().all(
+									new Action<Dependency>() {
+										@Override
+										public void execute(Dependency dependency) {
+											applyExcludeRules(dependency);
+										}
+									});
 						}
 					});
-				}
-			});
 		}
 	}
 
@@ -73,13 +75,10 @@ private void applyExcludeRules(ModuleDependency dependency) {
 		org.springframework.boot.dependency.tools.Dependency managedDependency = managedDependencies
 				.find(dependency.getGroup(), dependency.getName());
 		if (managedDependency != null) {
-			if (managedDependency.getExclusions().isEmpty()) {
-				logger.debug(""No exclusions rules applied for managed dependency ""
-						+ dependency);
-			}
 			for (Exclusion exclusion : managedDependency.getExclusions()) {
 				addExcludeRule(dependency, exclusion);
 			}
+			addImplicitExcludeRules(dependency);
 		}
 		else {
 			logger.debug(""No exclusions rules applied for non-managed dependency ""
@@ -94,4 +93,21 @@ private void addExcludeRule(ModuleDependency dependency, Exclusion exclusion) {
 		dependency.getExcludeRules().add(rule);
 	}
 
+	private void addImplicitExcludeRules(ModuleDependency dependency) {
+		if (isStarter(dependency)) {
+			logger.info(""Adding implicit managed exclusion rules to starter ""
+					+ dependency);
+			dependency.getExcludeRules().add(
+					new DefaultExcludeRule(""commons-logging"", ""commons-logging""));
+			dependency.getExcludeRules().add(
+					new DefaultExcludeRule(""commons-logging"", ""commons-logging-api""));
+		}
+	}
+
+	private boolean isStarter(ModuleDependency dependency) {
+		return (dependency.getGroup() != null
+				&& dependency.getGroup().equals(""org.springframework.boot"") && dependency
+				.getName().startsWith(""spring-boot-starter""));
+	}
+
 }
@@ -27,7 +27,6 @@
 		</resources>
 		<plugins>
 			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
 				<artifactId>maven-help-plugin</artifactId>
 				<executions>
 					<execution>
@@ -42,49 +41,6 @@
 					</execution>
 				</executions>
 			</plugin>
-			<plugin>
-				<groupId>org.codehaus.gmavenplus</groupId>
-				<artifactId>gmavenplus-plugin</artifactId>
-				<executions>
-					<execution>
-						<goals>
-							<goal>execute</goal>
-						</goals>
-						<phase>generate-resources</phase>
-					</execution>
-				</executions>
-				<configuration>
-					<scripts>
-						<script>file:///${project.basedir}/src/main/groovy/generateDependencyTreePom.groovy</script>
-					</scripts>
-				</configuration>
-				<dependencies>
-					<dependency>
-						<groupId>org.codehaus.groovy</groupId>
-						<artifactId>groovy-all</artifactId>
-						<version>${groovy.version}</version>
-					</dependency>
-				</dependencies>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-invoker-plugin</artifactId>
-				<executions>
-					<execution>
-						<id>generate-dependency-tree</id>
-						<phase>generate-resources</phase>
-						<goals>
-							<goal>run</goal>
-						</goals>
-						<configuration>
-							<cloneProjectsTo>${project.build.directory}/invoker</cloneProjectsTo>
-							<settingsFile>src/dependency-tree/settings.xml</settingsFile>
-							<streamLogs>true</streamLogs>
-							<pom>${basedir}/src/dependency-tree/pom.xml</pom>
-						</configuration>
-					</execution>
-				</executions>
-			</plugin>
 			<plugin>
 				<groupId>org.codehaus.mojo</groupId>
 				<artifactId>xml-maven-plugin</artifactId>
@@ -131,149 +87,11 @@
 									<file>${project.build.directory}/effective-pom/spring-boot-versions.xml</file>
 									<type>effective-pom</type>
 								</artifact>
-								<artifact>
-									<file>${project.build.directory}/dependency-tree/dependency-tree.txt </file>
-									<type>dependency-tree</type>
-								</artifact>
 							</artifacts>
 						</configuration>
 					</execution>
 				</executions>
 			</plugin>
 		</plugins>
 	</build>
-	<dependencies>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-actuator</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-amqp</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-aop</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-batch</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-elasticsearch</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-gemfire</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-jpa</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-mongodb</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-rest</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-solr</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-freemarker</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-groovy-templates</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-hornetq</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-integration</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-jdbc</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-jetty</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-log4j</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-logging</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-mobile</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-redis</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-remote-shell</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-security</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-social-facebook</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-social-linkedin</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-social-twitter</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-test</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-thymeleaf</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-tomcat</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-velocity</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-web</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-websocket</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-ws</artifactId>
-		</dependency>
-	</dependencies>
 </project>
@@ -1,40 +0,0 @@
-<?xml version=""1.0"" encoding=""UTF-8""?>
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
-	<modelVersion>4.0.0</modelVersion>
-	<parent>
-		<groupId>org.springframework.boot</groupId>
-		<artifactId>spring-boot-versions</artifactId>
-		<version>@project.version@</version>
-		<relativePath>../../target/dependency-tree</relativePath>
-	</parent>
-	<artifactId>spring-boot-versions-dependency-tree</artifactId>
-	<packaging>pom</packaging>
-	<build>
-		<plugins>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-dependency-plugin</artifactId>
-				<executions>
-					<execution>
-						<id>write-dependencies-tree</id>
-						<phase>generate-resources</phase>
-						<goals>
-							<goal>tree</goal>
-						</goals>
-						<configuration>
-							<outputFile>@project.build.directory@/dependency-tree/dependency-tree.txt</outputFile>
-							<verbose>true</verbose>
-						</configuration>
-					</execution>
-				</executions>
-			</plugin>
-		</plugins>
-	</build>
-	<repositories>
-		<repository>
-			<id>spring-ext</id>
-			<url>http://repo.spring.io/ext-release-local/</url>
-		</repository>
-	</repositories>
-</project>
@@ -1,34 +0,0 @@
-// Generate a POM from the effective-pom that can be used to build a complete dependency tree
-
-import groovy.util.*
-import groovy.xml.*
-
-def effectivePom = new XmlSlurper().parse(
-	new File(project.build.directory, 'effective-pom/spring-boot-versions.xml'))
-
-effectivePom.dependencyManagement.dependencies.dependency.findAll{ it.groupId != ""org.springframework.boot"" }.each {
-	effectivePom.dependencies.appendNode( it )
-}
-
-// effectivePom.appendNode(effectivePom.dependencyManagement.dependencies)
-effectivePom.parent.replaceNode {}
-effectivePom.dependencyManagement.replaceNode {}
-effectivePom.build.replaceNode {}
-effectivePom.properties.replaceNode {}
-effectivePom.repositories.replaceNode {}
-effectivePom.pluginRepositories.replaceNode {}
-effectivePom.reporting.replaceNode {}
-
-out = new StreamingMarkupBuilder()
-String xmlResult = out.bind {
-	mkp.declareNamespace("""": ""http://maven.apache.org/POM/4.0.0"")
-	mkp.yield effectivePom
-}
-
-
-def outputDir = new File(project.build.directory, 'dependency-tree');
-outputDir.mkdirs();
-XmlUtil.serialize(xmlResult, new FileWriter(new File(outputDir, 'pom.xml')))
-
-
-
"
https://github.com/spring-projects/spring-boot/commit/c4f756daee43f89e0ba832ceac17bac216fc899b,"Fix MavenSettings’ handling of profiles activated by a file  <enter> Previously, MavenSettings used a FileProfileActivator with no PathTransformer. If a settings.xml file contains a file-activated profile this would result in an NPE within Maven. This was made worse by the NPE not being included in the resulting failure message which hampered diagnosis of the problem. <enter> This commit updates MavenSettings to configure its FileProfileActivator with a PathTransformer. It also improves the failure message that’s created from any problems that are reported by Maven while determining the active profiles to include a problem’s exception if it has one. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/c4f756daee43f89e0ba832ceac17bac216fc899b,"@@ -16,8 +16,11 @@
 
 package org.springframework.boot.cli.compiler.maven;
 
+import java.io.BufferedReader;
 import java.io.File;
+import java.io.IOException;
 import java.io.PrintWriter;
+import java.io.StringReader;
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -29,6 +32,7 @@
 import org.apache.maven.model.ActivationProperty;
 import org.apache.maven.model.building.ModelProblemCollector;
 import org.apache.maven.model.building.ModelProblemCollectorRequest;
+import org.apache.maven.model.path.DefaultPathTranslator;
 import org.apache.maven.model.profile.DefaultProfileSelector;
 import org.apache.maven.model.profile.ProfileActivationContext;
 import org.apache.maven.model.profile.activation.FileProfileActivator;
@@ -147,15 +151,47 @@ private String createFailureMessage(
 		PrintWriter printer = new PrintWriter(message);
 		printer.println(""Failed to determine active profiles:"");
 		for (ModelProblemCollectorRequest problem : problemCollector.getProblems()) {
-			printer.println(
-					""    "" + problem.getMessage() + "" at "" + problem.getLocation());
+			printer.println(""    "" + problem.getMessage() + (problem.getLocation() != null
+					? "" at "" + problem.getLocation() : """"));
+			if (problem.getException() != null) {
+				printer.println(indentStackTrace(problem.getException(), ""        ""));
+			}
 		}
 		return message.toString();
 	}
 
+	private String indentStackTrace(Exception ex, String indent) {
+		return indentLines(printStackTrace(ex), indent);
+	}
+
+	private String printStackTrace(Exception ex) {
+		StringWriter stackTrace = new StringWriter();
+		PrintWriter printer = new PrintWriter(stackTrace);
+		ex.printStackTrace(printer);
+		return stackTrace.toString();
+	}
+
+	private String indentLines(String input, String indent) {
+		StringWriter indented = new StringWriter();
+		PrintWriter writer = new PrintWriter(indented);
+		String line;
+		BufferedReader reader = new BufferedReader(new StringReader(input));
+		try {
+			while ((line = reader.readLine()) != null) {
+				writer.println(indent + line);
+			}
+		}
+		catch (IOException ex) {
+			return input;
+		}
+		return indented.toString();
+	}
+
 	private DefaultProfileSelector createProfileSelector() {
 		DefaultProfileSelector selector = new DefaultProfileSelector();
-		selector.addProfileActivator(new FileProfileActivator());
+
+		selector.addProfileActivator(new FileProfileActivator()
+				.setPathTranslator(new DefaultPathTranslator()));
 		selector.addProfileActivator(new JdkVersionProfileActivator());
 		selector.addProfileActivator(new PropertyProfileActivator());
 		selector.addProfileActivator(new OperatingSystemProfileActivator());
@@ -28,4 +28,21 @@
 		</proxy>
 	</proxies>
 
-</settings>
\ No newline at end of file
+	<profiles>
+		<profile>
+    		<id>test-profile</id>
+    		<activation>
+	        	<file>
+	            	<exists>${user.home}/.m2/some_file</exists>
+	        	</file>
+    		</activation>
+	    	<repositories>
+	        	<repository>
+	            	<id>example-repository</id>
+	            	<url>http://repo.example.com</url>
+	        	</repository>
+	    	</repositories>
+		</profile>
+	</profiles>
+
+</settings>
"
https://github.com/spring-projects/spring-boot/commit/32b32b714275d0efaa1f5afba10e88e09101f224,Notify the use of logback specific system property  <enter> Logback documentation explains how to initialize the logging system and namely how the `logback.configurationFile` system property can be used to specify the configuration file to use. <enter> Spring Boot has an abstraction on top of that. A user can define the `logging.path` property regardless of the logging infrastructure it is using. <enter> Users following the logback documentation can be confused at first so we're not logging a warning when we found out that the logback specific property has been specified. <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/32b32b714275d0efaa1f5afba10e88e09101f224,"@@ -1019,6 +1019,9 @@ NOTE: The logging system is initialized early in the application lifecycle and a
 logging properties will not be found in property files loaded via `@PropertySource`
 annotations.
 
+TIP: Logging properties are independent of the actual logging infrastructure. As a
+result, specific configuration keys (such as `logback.configurationFile` for Logback)
+are not managed by spring Boot.
 
 
 [[boot-features-custom-log-levels]]
@@ -56,6 +56,8 @@
  */
 public class LogbackLoggingSystem extends Slf4JLoggingSystem {
 
+	private static final String CONFIGURATION_FILE_PROPERTY = ""logback.configurationFile"";
+
 	private static final Map<LogLevel, Level> LEVELS;
 
 	static {
@@ -102,6 +104,11 @@ public void initialize(LoggingInitializationContext initializationContext,
 			String configLocation, LogFile logFile) {
 		getLogger(null).getLoggerContext().getTurboFilterList().remove(FILTER);
 		super.initialize(initializationContext, configLocation, logFile);
+		if (StringUtils.hasText(System.getProperty(CONFIGURATION_FILE_PROPERTY))) {
+			getLogger(LogbackLoggingSystem.class.getName()).warn(
+					""Ignoring '""+CONFIGURATION_FILE_PROPERTY+""' system property. "" +
+							""Please use 'logging.path' instead."");
+		}
 	}
 
 	@Override
@@ -141,6 +141,21 @@ public void testNonDefaultConfigLocation() throws Exception {
 		assertFalse(new File(tmpDir() + ""/tmp.log"").exists());
 	}
 
+	@Test
+	public void testLogbackSpecificSystemProperty() throws Exception {
+		System.setProperty(""logback.configurationFile"", ""/foo/my-file.xml"");
+		try {
+			this.loggingSystem.beforeInitialize();
+			this.loggingSystem.initialize(this.initializationContext, null, null);
+			String output = this.output.toString().trim();
+			assertTrue(""Wrong output:\n"" + output, output.contains(""Ignoring "" +
+					""'logback.configurationFile' system property. Please use 'logging.path' instead.""));
+		}
+		finally {
+			System.clearProperty(""logback.configurationFile"");
+		}
+	}
+
 	@Test(expected = IllegalStateException.class)
 	public void testNonexistentConfigLocation() throws Exception {
 		this.loggingSystem.beforeInitialize();
"
https://github.com/spring-projects/spring-boot/commit/e5a253e68951dcf975b9844b3b39afac2222b503,"Improve diagnostics when OnBeanCondition type deduction fails  <enter> When @ConditionalOnBean or @ConditionalOnMissingBean are used on a  @bean  method, they will, in the absence of any other configuration, attempt to deduce the bean's type by examining the method's return type. This deduction can fail. See  <issue_link> ,  <issue_link> , and  <issue_link>  for some examples of possible failure causes. Previously, this failure was only logged as a debug message leaving the user with a misleading message suggesting that the @ConditionalOnBean or @ConditionalOnMissingBean annotation was not configured correctly. <enter> This commit improves the diagnostics by mention the possibility of type deduction in the exception message and including the exception that caused deduction to fail as the cause. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/e5a253e68951dcf975b9844b3b39afac2222b503,"@@ -267,18 +267,32 @@ private static class BeanSearchSpec {
 			collect(attributes, ""annotation"", this.annotations);
 			collect(attributes, ""ignored"", this.ignoredTypes);
 			collect(attributes, ""ignoredType"", this.ignoredTypes);
-			if (this.types.isEmpty() && this.names.isEmpty()) {
-				addDeducedBeanType(context, metadata, this.types);
-			}
 			this.strategy = (SearchStrategy) metadata
 					.getAnnotationAttributes(annotationType.getName()).get(""search"");
-			validate();
+			BeanTypeDeductionException deductionException = null;
+			try {
+				if (this.types.isEmpty() && this.names.isEmpty()) {
+					addDeducedBeanType(context, metadata, this.types);
+				}
+			}
+			catch (BeanTypeDeductionException ex) {
+				deductionException = ex;
+			}
+			validate(deductionException);
 		}
 
-		protected void validate() {
-			Assert.isTrue(hasAtLeastOne(this.types, this.names, this.annotations),
-					annotationName() + "" annotations must ""
-							+ ""specify at least one bean (type, name or annotation)"");
+		protected void validate(BeanTypeDeductionException ex) {
+			if (!hasAtLeastOne(this.types, this.names, this.annotations)) {
+				String message = annotationName()
+						+ "" did not specify a bean using type, name or annotation"";
+				if (ex == null) {
+					throw new IllegalStateException(message);
+				}
+				else {
+					throw new IllegalStateException(message + "" and the attempt to deduce""
+							+ "" the bean's type failed"", ex);
+				}
+			}
 		}
 
 		private boolean hasAtLeastOne(List<?>... lists) {
@@ -337,12 +351,9 @@ public void doWith(Method method)
 				});
 			}
 			catch (Throwable ex) {
-				// swallow exception and continue
-				if (logger.isDebugEnabled()) {
-					logger.debug(""Unable to deduce bean type for ""
-							+ methodMetadata.getDeclaringClassName() + "".""
-							+ methodMetadata.getMethodName(), ex);
-				}
+				throw new BeanTypeDeductionException(
+						methodMetadata.getDeclaringClassName(),
+						methodMetadata.getMethodName(), ex);
 			}
 		}
 
@@ -404,11 +415,20 @@ protected void collect(MultiValueMap<String, Object> attributes, String key,
 		}
 
 		@Override
-		protected void validate() {
+		protected void validate(BeanTypeDeductionException ex) {
 			Assert.isTrue(getTypes().size() == 1, annotationName() + "" annotations must ""
 					+ ""specify only one type (got "" + getTypes() + "")"");
+		}
+	}
+
+	static final class BeanTypeDeductionException extends RuntimeException {
 
+		private BeanTypeDeductionException(String className, String beanMethodName,
+				Throwable cause) {
+			super(""Failed to deduce bean type for "" + className + ""."" + beanMethodName,
+					cause);
 		}
+
 	}
 
 }
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2012-2016 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.condition;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.springframework.boot.autoconfigure.condition.OnBeanCondition.BeanTypeDeductionException;
+import org.springframework.boot.testutil.ClassPathExclusions;
+import org.springframework.boot.testutil.FilteredClassPathRunner;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Import;
+import org.springframework.context.annotation.ImportSelector;
+import org.springframework.core.type.AnnotationMetadata;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for {@link OnBeanCondition} when deduction of the bean's type fails
+ *
+ * @author Andy Wilkinson
+ */
+@RunWith(FilteredClassPathRunner.class)
+@ClassPathExclusions(""jackson-core-*.jar"")
+public class OnBeanConditionTypeDeductionFailureTests {
+
+	@Test
+	public void conditionalOnMissingBeanWithDeducedTypeThatIsPartiallyMissingFromClassPath() {
+		try {
+			new AnnotationConfigApplicationContext(ImportingConfiguration.class).close();
+			fail(""Context refresh was successful"");
+		}
+		catch (Exception ex) {
+			ex.printStackTrace();
+			Throwable beanTypeDeductionException = findBeanTypeDeductionException(ex);
+			assertThat(beanTypeDeductionException)
+					.hasMessage(""Failed to deduce bean type for ""
+							+ OnMissingBeanConfiguration.class.getName()
+							+ "".objectMapper"");
+			assertThat(beanTypeDeductionException)
+					.hasCauseInstanceOf(NoClassDefFoundError.class);
+		}
+	}
+
+	private Throwable findBeanTypeDeductionException(Throwable ex) {
+		Throwable candidate = ex;
+		while (candidate != null) {
+			if (candidate instanceof BeanTypeDeductionException) {
+				return candidate;
+			}
+			candidate = candidate.getCause();
+		}
+		return null;
+	}
+
+	@Configuration
+	@Import(OnMissingBeanImportSelector.class)
+	static class ImportingConfiguration {
+
+	}
+
+	@Configuration
+	static class OnMissingBeanConfiguration {
+
+		@Bean
+		@ConditionalOnMissingBean
+		public ObjectMapper objectMapper() {
+			return new ObjectMapper();
+		}
+
+	}
+
+	static class OnMissingBeanImportSelector implements ImportSelector {
+
+		@Override
+		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
+			return new String[] { OnMissingBeanConfiguration.class.getName() };
+		}
+
+	}
+
+}
"
https://github.com/junit-team/junit4/commit/3189af007b26d74ca459f823d57ef77b9c1697b8,Remove redundant field fCause ,https://api.github.com/repos/junit-team/junit4/commits/3189af007b26d74ca459f823d57ef77b9c1697b8,"@@ -16,7 +16,6 @@ public class ArrayComparisonFailure extends AssertionError {
 
     private List<Integer> fIndices = new ArrayList<Integer>();
     private final String fMessage;
-    private final AssertionError fCause;
 
     /**
      * Construct a new <code>ArrayComparisonFailure</code> with an error text and the array's
@@ -28,7 +27,7 @@ public class ArrayComparisonFailure extends AssertionError {
      */
     public ArrayComparisonFailure(String message, AssertionError cause, int index) {
         fMessage = message;
-        fCause = cause;
+        initCause(cause);
         addDimension(index);
     }
 
@@ -49,7 +48,7 @@ public String getMessage() {
             sb.append(""]"");
         }
         sb.append(""; "");
-        sb.append(fCause.getMessage());
+        sb.append(getCause().getMessage());
         return sb.toString();
     }
 
"
https://github.com/square/okhttp/commit/30ecba897fb624df201f0a014b54a604418a0e73,Use Request and Response types in OkResponseCache.  <enter> This breaks support for java.net.ResponseCache implementations. That's good. That API is akward and can't support important features like conditional GETs and hit tracking. ,https://api.github.com/repos/square/okhttp/commits/30ecba897fb624df201f0a014b54a604418a0e73,"@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal;
 
+import java.io.ByteArrayInputStream;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
@@ -44,9 +45,7 @@
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
-
-  /** A cheap and type-safe constant for the ISO-8859-1 Charset. */
-  public static final Charset ISO_8859_1 = Charset.forName(""ISO-8859-1"");
+  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
 
   /** A cheap and type-safe constant for the US-ASCII Charset. */
   public static final Charset US_ASCII = Charset.forName(""US-ASCII"");
@@ -79,7 +79,7 @@ static class RealResponseBody extends Response.Body {
       return responseHeaders.getContentLength();
     }
 
-    @Override public InputStream byteStream() throws IOException {
+    @Override public InputStream byteStream() {
       return in;
     }
   }
@@ -21,7 +21,7 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ class Failure {
+public final class Failure {
   private final Request request;
   private final Throwable exception;
 
@@ -20,9 +20,6 @@
 import com.squareup.okhttp.internal.DiskLruCache;
 import com.squareup.okhttp.internal.StrictLineReader;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
 import com.squareup.okhttp.internal.http.RawHeaders;
 import com.squareup.okhttp.internal.http.ResponseHeaders;
 import java.io.BufferedWriter;
@@ -37,12 +34,9 @@
 import java.io.Writer;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
-import java.net.HttpURLConnection;
 import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
 import java.net.URI;
 import java.net.URLConnection;
-import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
 import java.security.cert.CertificateException;
@@ -51,7 +45,6 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import javax.net.ssl.SSLPeerUnverifiedException;
 
 import static com.squareup.okhttp.internal.Util.US_ASCII;
 import static com.squareup.okhttp.internal.Util.UTF_8;
@@ -113,7 +106,7 @@
  *         connection.addRequestProperty(""Cache-Control"", ""max-stale="" + maxStale);
  * }</pre>
  */
-public final class HttpResponseCache extends ResponseCache {
+public final class HttpResponseCache extends ResponseCache implements OkResponseCache {
   // TODO: add APIs to iterate the cache?
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
@@ -129,51 +122,25 @@ public final class HttpResponseCache extends ResponseCache {
   private int hitCount;
   private int requestCount;
 
-  /**
-   * Although this class only exposes the limited ResponseCache API, it
-   * implements the full OkResponseCache interface. This field is used as a
-   * package private handle to the complete implementation. It delegates to
-   * public and private members of this type.
-   */
-  final OkResponseCache okResponseCache = new OkResponseCache() {
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      return HttpResponseCache.this.get(uri, requestMethod, requestHeaders);
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return HttpResponseCache.this.put(uri, connection);
-    }
-
-    @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-      HttpResponseCache.this.maybeRemove(requestMethod, uri);
-    }
-
-    @Override public void update(
-        CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException {
-      HttpResponseCache.this.update(conditionalCacheHit, connection);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      HttpResponseCache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(ResponseSource source) {
-      HttpResponseCache.this.trackResponse(source);
-    }
-  };
-
   public HttpResponseCache(File directory, long maxSize) throws IOException {
     cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
-  private String uriToKey(URI uri) {
-    return Util.hash(uri.toString());
+  @Override public CacheResponse get(URI uri, String s, Map<String, List<String>> stringListMap)
+      throws IOException {
+    throw new UnsupportedOperationException(""This is not a general purpose response cache."");
   }
 
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) {
-    String key = uriToKey(uri);
+  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    throw new UnsupportedOperationException(""This is not a general purpose response cache."");
+  }
+
+  private static String urlToKey(Request requst) {
+    return Util.hash(requst.urlString());
+  }
+
+  @Override public Response get(Request request) {
+    String key = urlToKey(request);
     DiskLruCache.Snapshot snapshot;
     Entry entry;
     try {
@@ -187,25 +154,18 @@ private String uriToKey(URI uri) {
       return null;
     }
 
-    if (!entry.matches(uri, requestMethod, requestHeaders)) {
+    if (!entry.matches(request)) {
       snapshot.close();
       return null;
     }
 
-    return entry.isHttps()
-        ? new EntrySecureCacheResponse(entry, snapshot)
-        : new EntryCacheResponse(entry, snapshot);
+    return entry.response(request, snapshot);
   }
 
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    if (!(urlConnection instanceof HttpURLConnection)) {
-      return null;
-    }
-
-    HttpURLConnection httpConnection = (HttpURLConnection) urlConnection;
-    String requestMethod = httpConnection.getRequestMethod();
+  @Override public CacheRequest put(Response response) throws IOException {
+    String requestMethod = response.request().method();
 
-    if (maybeRemove(requestMethod, uri)) {
+    if (maybeRemove(response.request())) {
       return null;
     }
     if (!requestMethod.equals(""GET"")) {
@@ -215,23 +175,15 @@ private String uriToKey(URI uri) {
       return null;
     }
 
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    if (httpEngine == null) {
-      // Don't cache unless the HTTP implementation is ours.
+    ResponseHeaders responseHeaders = new ResponseHeaders(null, response.rawHeaders());
+    if (responseHeaders.hasVaryAll()) {
       return null;
     }
 
-    ResponseHeaders response = httpEngine.getResponseHeaders();
-    if (response.hasVaryAll()) {
-      return null;
-    }
-
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
+    Entry entry = new Entry(response);
     DiskLruCache.Editor editor = null;
     try {
-      editor = cache.edit(uriToKey(uri));
+      editor = cache.edit(urlToKey(response.request()));
       if (editor == null) {
         return null;
       }
@@ -243,15 +195,11 @@ private String uriToKey(URI uri) {
     }
   }
 
-  /**
-   * Returns true if the supplied {@code requestMethod} potentially invalidates an entry in the
-   * cache.
-   */
-  private boolean maybeRemove(String requestMethod, URI uri) {
-    if (requestMethod.equals(""POST"") || requestMethod.equals(""PUT"") || requestMethod.equals(
-        ""DELETE"")) {
+  @Override public boolean maybeRemove(Request request) {
+    String method = request.method();
+    if (method.equals(""POST"") || method.equals(""PUT"") || method.equals(""DELETE"")) {
       try {
-        cache.remove(uriToKey(uri));
+        cache.remove(urlToKey(request));
       } catch (IOException ignored) {
         // The cache cannot be written.
       }
@@ -260,20 +208,12 @@ private boolean maybeRemove(String requestMethod, URI uri) {
     return false;
   }
 
-  private void update(CacheResponse conditionalCacheHit, HttpURLConnection httpConnection)
-      throws IOException {
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    URI uri = httpEngine.getUri();
-    ResponseHeaders response = httpEngine.getResponseHeaders();
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
-    DiskLruCache.Snapshot snapshot = (conditionalCacheHit instanceof EntryCacheResponse)
-        ? ((EntryCacheResponse) conditionalCacheHit).snapshot
-        : ((EntrySecureCacheResponse) conditionalCacheHit).snapshot;
+  @Override public void update(Response cached, Response network) {
+    Entry entry = new Entry(network);
+    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
     DiskLruCache.Editor editor = null;
     try {
-      editor = snapshot.edit(); // returns null if snapshot is not current
+      editor = snapshot.edit(); // Returns null if snapshot is not current.
       if (editor != null) {
         entry.writeTo(editor);
         editor.commit();
@@ -293,16 +233,6 @@ private void abortQuietly(DiskLruCache.Editor editor) {
     }
   }
 
-  private HttpEngine getHttpEngine(URLConnection httpConnection) {
-    if (httpConnection instanceof HttpURLConnectionImpl) {
-      return ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
-    } else if (httpConnection instanceof HttpsURLConnectionImpl) {
-      return ((HttpsURLConnectionImpl) httpConnection).getHttpEngine();
-    } else {
-      return null;
-    }
-  }
-
   /**
    * Closes the cache and deletes all of its stored values. This will delete
    * all files in the cache directory including files that weren't created by
@@ -344,7 +274,7 @@ public boolean isClosed() {
     return cache.isClosed();
   }
 
-  private synchronized void trackResponse(ResponseSource source) {
+  @Override public synchronized void trackResponse(ResponseSource source) {
     requestCount++;
 
     switch (source) {
@@ -358,7 +288,7 @@ private synchronized void trackResponse(ResponseSource source) {
     }
   }
 
-  private synchronized void trackConditionalCacheHit() {
+  @Override public synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
@@ -425,7 +355,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
   }
 
   private static final class Entry {
-    private final String uri;
+    private final String url;
     private final RawHeaders varyHeaders;
     private final String requestMethod;
     private final RawHeaders responseHeaders;
@@ -483,7 +413,7 @@ private static final class Entry {
     public Entry(InputStream in) throws IOException {
       try {
         StrictLineReader reader = new StrictLineReader(in, US_ASCII);
-        uri = reader.readLine();
+        url = reader.readLine();
         requestMethod = reader.readLine();
         varyHeaders = new RawHeaders();
         int varyRequestHeaderLineCount = reader.readInt();
@@ -515,26 +445,20 @@ public Entry(InputStream in) throws IOException {
       }
     }
 
-    public Entry(URI uri, RawHeaders varyHeaders, HttpURLConnection httpConnection)
-        throws IOException {
-      this.uri = uri.toString();
-      this.varyHeaders = varyHeaders;
-      this.requestMethod = httpConnection.getRequestMethod();
-      this.responseHeaders = RawHeaders.fromMultimap(httpConnection.getHeaderFields(), true);
-      this.handshake = getHttpEngine(httpConnection).getHandshake();
-    }
-
-    private HttpEngine getHttpEngine(HttpURLConnection httpConnection) {
-      return httpConnection instanceof HttpsURLConnectionImpl
-          ? ((HttpsURLConnectionImpl) httpConnection).getHttpEngine()
-          : ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
+    public Entry(Response response) {
+      this.url = response.request().urlString();
+      this.varyHeaders = response.request().rawHeaders().getAll(
+          new ResponseHeaders(null, response.rawHeaders()).getVaryFields());
+      this.requestMethod = response.request().method();
+      this.responseHeaders = response.rawHeaders();
+      this.handshake = response.handshake();
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
       OutputStream out = editor.newOutputStream(ENTRY_METADATA);
       Writer writer = new BufferedWriter(new OutputStreamWriter(out, UTF_8));
 
-      writer.write(uri + '\n');
+      writer.write(url + '\n');
       writer.write(requestMethod + '\n');
       writer.write(Integer.toString(varyHeaders.length()) + '\n');
       for (int i = 0; i < varyHeaders.length(); i++) {
@@ -557,7 +481,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
     }
 
     private boolean isHttps() {
-      return uri.startsWith(""https://"");
+      return url.startsWith(""https://"");
     }
 
     private List<Certificate> readCertificateList(StrictLineReader reader) throws IOException {
@@ -591,90 +515,62 @@ private void writeCertArray(Writer writer, List<Certificate> certificates) throw
       }
     }
 
-    public boolean matches(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) {
-      return this.uri.equals(uri.toString())
-          && this.requestMethod.equals(requestMethod)
-          && new ResponseHeaders(uri, responseHeaders).varyMatches(varyHeaders.toMultimap(false),
-          requestHeaders);
-    }
-  }
-
-  /**
-   * Returns an input stream that reads the body of a snapshot, closing the
-   * snapshot when the stream is closed.
-   */
-  private static InputStream newBodyInputStream(final DiskLruCache.Snapshot snapshot) {
-    return new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
-      @Override public void close() throws IOException {
-        snapshot.close();
-        super.close();
-      }
-    };
-  }
-
-  static class EntryCacheResponse extends CacheResponse {
-    private final Entry entry;
-    private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
-
-    public EntryCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
-      this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
-    }
-
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
+    public boolean matches(Request request) {
+      return url.equals(request.urlString())
+          && requestMethod.equals(request.method())
+          && new ResponseHeaders(null, responseHeaders).varyMatches(varyHeaders, request);
     }
 
-    @Override public InputStream getBody() {
-      return in;
+    public Response response(Request request, DiskLruCache.Snapshot snapshot) {
+      String contentType = responseHeaders.get(""Content-Type"");
+      String contentLength = responseHeaders.get(""Content-Length"");
+      return new Response.Builder(request, responseHeaders.getResponseCode())
+          .rawHeaders(responseHeaders)
+          .body(new CacheResponseBody(snapshot, contentType, contentLength))
+          .handshake(handshake)
+          .build();
     }
   }
 
-  static class EntrySecureCacheResponse extends SecureCacheResponse {
-    private final Entry entry;
+  private static class CacheResponseBody extends Response.Body {
     private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
+    private final InputStream bodyIn;
+    private final String contentType;
+    private final String contentLength;
 
-    public EntrySecureCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
+    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+        String contentType, String contentLength) {
       this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
-    }
-
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
-    }
-
-    @Override public InputStream getBody() {
-      return in;
-    }
+      this.contentType = contentType;
+      this.contentLength = contentLength;
 
-    @Override public String getCipherSuite() {
-      return entry.handshake.cipherSuite();
+      // This input stream closes the snapshot when the stream is closed.
+      this.bodyIn = new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
+        @Override public void close() throws IOException {
+          snapshot.close();
+          super.close();
+        }
+      };
     }
 
-    @Override public List<Certificate> getServerCertificateChain()
-        throws SSLPeerUnverifiedException {
-      if (entry.handshake.peerCertificates().isEmpty()) throw new SSLPeerUnverifiedException(null);
-      return entry.handshake.peerCertificates();
+    @Override public boolean ready() throws IOException {
+      return true;
     }
 
-    @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-      if (entry.handshake.peerCertificates().isEmpty()) throw new SSLPeerUnverifiedException(null);
-      return entry.handshake.peerPrincipal();
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
     }
 
-    @Override public List<Certificate> getLocalCertificateChain() {
-      return !entry.handshake.localCertificates().isEmpty()
-          ? entry.handshake.localCertificates()
-          : null;
+    @Override public long contentLength() {
+      try {
+        return contentLength != null ? Long.parseLong(contentLength) : -1;
+      } catch (NumberFormatException e) {
+        return -1;
+      }
     }
 
-    @Override public Principal getLocalPrincipal() {
-      return entry.handshake.localPrincipal();
+    @Override public InputStream byteStream() {
+      return bodyIn;
     }
   }
 }
@@ -22,7 +22,6 @@
 import com.squareup.okhttp.internal.http.Policy;
 import com.squareup.okhttp.internal.http.RawHeaders;
 import java.io.IOException;
-import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.URL;
@@ -61,11 +60,7 @@ public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
   }
 
   @Override public boolean getUseCaches() {
-    return false; // TODO.
-  }
-
-  @Override public HttpURLConnection getHttpConnectionToCache() {
-    return null;
+    return true;
   }
 
   @Override public URL getURL() {
@@ -19,7 +19,6 @@
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.OkResponseCacheAdapter;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.net.CookieHandler;
 import java.net.HttpURLConnection;
@@ -48,7 +47,7 @@ public final class OkHttpClient implements URLStreamHandlerFactory {
   private List<String> transports;
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
-  private ResponseCache responseCache;
+  private OkResponseCache responseCache;
   private SSLSocketFactory sslSocketFactory;
   private HostnameVerifier hostnameVerifier;
   private OkAuthenticator authenticator;
@@ -169,24 +168,40 @@ public CookieHandler getCookieHandler() {
    *
    * <p>If unset, the {@link ResponseCache#getDefault() system-wide default}
    * response cache will be used.
+   *
+   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
+   *     is broken for many reasons: URI instead of URL, no conditional updates,
+   *     no invalidation, and no mechanism for tracking hit rates. Use
+   *     {@link #setOkResponseCache} instead.
    */
+  @Deprecated
   public OkHttpClient setResponseCache(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-    return this;
+    if (responseCache instanceof OkResponseCache) {
+      return setOkResponseCache((OkResponseCache) responseCache);
+    }
+    throw new UnsupportedOperationException(""OkHttp 2 dropped support for java.net.ResponseCache. ""
+        + ""Use setOkResponseCache() instead."");
   }
 
+  /**
+   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
+   *     is broken for many reasons: URI instead of URL, no conditional updates,
+   *     no invalidation, and no mechanism for tracking hit rates. Use
+   *     {@link #setOkResponseCache} instead.
+   */
+  @Deprecated
   public ResponseCache getResponseCache() {
-    return responseCache;
+    throw new UnsupportedOperationException(""OkHttp 2 dropped support for java.net.ResponseCache. ""
+        + ""Use setOkResponseCache() instead."");
+  }
+
+  public OkHttpClient setOkResponseCache(OkResponseCache responseCache) {
+    this.responseCache = responseCache;
+    return this;
   }
 
   public OkResponseCache getOkResponseCache() {
-    if (responseCache instanceof HttpResponseCache) {
-      return ((HttpResponseCache) responseCache).okResponseCache;
-    } else if (responseCache != null) {
-      return new OkResponseCacheAdapter(responseCache);
-    } else {
-      return null;
-    }
+    return responseCache;
   }
 
   /**
@@ -319,19 +334,24 @@ public List<String> getTransports() {
 
   /**
    * Schedules {@code request} to be executed.
+   *
+   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
+   * This method is in beta. APIs are subject to change!
    */
-  /* OkHttp 2.0: public */ void enqueue(Request request, Response.Receiver responseReceiver) {
-    // Create the HttpURLConnection immediately so the enqueued job gets the current settings of
-    // this client. Otherwise changes to this client (socket factory, redirect policy, etc.) may
-    // incorrectly be reflected in the request when it is dispatched later.
+  public void enqueue(Request request, Response.Receiver responseReceiver) {
+    // Copy this client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is dispatched.
     dispatcher.enqueue(copyWithDefaults(), request, responseReceiver);
   }
 
   /**
    * Cancels all scheduled tasks tagged with {@code tag}. Requests that are already
    * in flight might not be canceled.
+   *
+   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
+   * This method is in beta. APIs are subject to change!
    */
-  /* OkHttp 2.0: public */ void cancel(Object tag) {
+  public void cancel(Object tag) {
     dispatcher.cancel(tag);
   }
 
@@ -358,7 +378,9 @@ private OkHttpClient copyWithDefaults() {
     result.proxy = proxy;
     result.proxySelector = proxySelector != null ? proxySelector : ProxySelector.getDefault();
     result.cookieHandler = cookieHandler != null ? cookieHandler : CookieHandler.getDefault();
-    result.responseCache = responseCache != null ? responseCache : ResponseCache.getDefault();
+    result.responseCache = responseCache != null
+        ? responseCache
+        : toOkResponseCacheOrNull(ResponseCache.getDefault());
     result.sslSocketFactory = sslSocketFactory != null
         ? sslSocketFactory
         : HttpsURLConnection.getDefaultSSLSocketFactory();
@@ -376,6 +398,10 @@ private OkHttpClient copyWithDefaults() {
     return result;
   }
 
+  private OkResponseCache toOkResponseCacheOrNull(ResponseCache cache) {
+    return cache instanceof OkResponseCache ? ((OkResponseCache) cache) : null;
+  }
+
   /**
    * Creates a URLStreamHandler as a {@link URL#setURLStreamHandlerFactory}.
    *
@@ -17,12 +17,6 @@
 
 import java.io.IOException;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
 
 /**
  * An extended response cache API. Unlike {@link java.net.ResponseCache}, this
@@ -32,21 +26,25 @@
  * This class is in beta. APIs are subject to change!
  */
 public interface OkResponseCache {
-  CacheResponse get(URI uri, String requestMethod, Map<String, List<String>> requestHeaders)
-      throws IOException;
+  Response get(Request request) throws IOException;
 
-  CacheRequest put(URI uri, URLConnection urlConnection) throws IOException;
+  CacheRequest put(Response response) throws IOException;
 
-  /** Remove any cache entries for the supplied {@code uri} if the request method invalidates. */
-  void maybeRemove(String requestMethod, URI uri) throws IOException;
+  /**
+   * Remove any cache entries for the supplied {@code uri}. Returns true if the
+   * supplied {@code requestMethod} potentially invalidates an entry in the
+   * cache.
+   */
+  // TODO: this shouldn't return a boolean.
+  boolean maybeRemove(Request request) throws IOException;
 
   /**
    * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code httpConnection}. The cached response body is
-   * not updated. If the stored response has changed since {@code
-   * conditionalCacheHit} was returned, this does nothing.
+   * with the headers from {@code network}. The cached response body is not
+   * updated. If the stored response has changed since {@code cached} was
+   * returned, this does nothing.
    */
-  void update(CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException;
+  void update(Response cached, Response network) throws IOException;
 
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
@@ -35,7 +35,7 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Request {
+public final class Request {
   private final URL url;
   private final String method;
   private final RawHeaders headers;
@@ -237,7 +237,8 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
-    Builder rawHeaders(RawHeaders rawHeaders) {
+    // TODO: this shouldn't be public.
+    public Builder rawHeaders(RawHeaders rawHeaders) {
       headers = new RawHeaders(rawHeaders);
       return this;
     }
@@ -18,6 +18,7 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.RawHeaders;
 import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -36,7 +37,7 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Response {
+public final class Response {
   private final Request request;
   private final int code;
   private final Handshake handshake;
@@ -106,7 +107,8 @@ public String headerName(int index) {
     return headers.getFieldName(index);
   }
 
-  RawHeaders rawHeaders() {
+  // TODO: this shouldn't be public.
+  public RawHeaders rawHeaders() {
     return new RawHeaders(headers);
   }
 
@@ -128,7 +130,7 @@ public Response redirectedBy() {
     return redirectedBy;
   }
 
-  public abstract static class Body {
+  public abstract static class Body implements Closeable {
     /** Multiple calls to {@link #charStream()} must return the same instance. */
     private Reader reader;
 
@@ -154,7 +156,7 @@ public abstract static class Body {
      */
     public abstract long contentLength();
 
-    public abstract InputStream byteStream() throws IOException;
+    public abstract InputStream byteStream();
 
     public final byte[] bytes() throws IOException {
       long contentLength = contentLength();
@@ -181,7 +183,7 @@ public final byte[] bytes() throws IOException {
      * of the Content-Type header. If that header is either absent or lacks a
      * charset, this will attempt to decode the response body as UTF-8.
      */
-    public final Reader charStream() throws IOException {
+    public final Reader charStream() {
       if (reader == null) {
         reader = new InputStreamReader(byteStream(), charset());
       }
@@ -201,6 +203,10 @@ private Charset charset() {
       MediaType contentType = contentType();
       return contentType != null ? contentType.charset(UTF_8) : UTF_8;
     }
+
+    @Override public void close() throws IOException {
+      byteStream().close();
+    }
   }
 
   public interface Receiver {
@@ -282,7 +288,8 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
-    Builder rawHeaders(RawHeaders rawHeaders) {
+    // TODO: this shouldn't be public.
+    public Builder rawHeaders(RawHeaders rawHeaders) {
       headers = new RawHeaders(rawHeaders);
       return this;
     }
@@ -46,7 +46,7 @@ abstract class AbstractHttpInputStream extends InputStream {
 
     OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
 
-    // some apps return a null body; for compatibility we treat that like a null cache request
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
     if (cacheBody == null) {
       cacheRequest = null;
     }
@@ -20,37 +20,33 @@
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.TunnelRequest;
 import com.squareup.okhttp.internal.Dns;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.CookieHandler;
-import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.UnknownHostException;
-import java.util.Collections;
 import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
-import static com.squareup.okhttp.internal.Util.EMPTY_BYTE_ARRAY;
+import static com.squareup.okhttp.internal.Util.EMPTY_INPUT_STREAM;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -82,16 +78,21 @@
  * implementation type of its HttpEngine.
  */
 public class HttpEngine {
-  private static final CacheResponse GATEWAY_TIMEOUT_RESPONSE = new CacheResponse() {
-    @Override public Map<String, List<String>> getHeaders() throws IOException {
-      Map<String, List<String>> result = new HashMap<String, List<String>>();
-      result.put(null, Collections.singletonList(""HTTP/1.1 504 Gateway Timeout""));
-      return result;
+  private static final Response.Body EMPTY_BODY = new Response.Body() {
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
+    @Override public MediaType contentType() {
+      return null;
+    }
+    @Override public long contentLength() {
+      return 0;
     }
-    @Override public InputStream getBody() throws IOException {
-      return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
+    @Override public InputStream byteStream() {
+      return EMPTY_INPUT_STREAM;
     }
   };
+
   public static final int HTTP_CONTINUE = 100;
 
   protected final Policy policy;
@@ -111,15 +112,9 @@ public class HttpEngine {
   private InputStream responseTransferIn;
   private InputStream responseBodyIn;
 
-  private CacheResponse cacheResponse;
-  private CacheRequest cacheRequest;
-
   /** The time when the request headers were written, or -1 if they haven't been written yet. */
   long sentRequestMillis = -1;
 
-  /** Whether the connection has been established. */
-  boolean connected;
-
   /**
    * True if this client added an ""Accept-Encoding: gzip"" header field and is
    * therefore responsible for also decompressing the transfer stream.
@@ -133,12 +128,16 @@ public class HttpEngine {
   /** Null until a response is received from the network or the cache. */
   ResponseHeaders responseHeaders;
 
-  // The cache response currently being validated on a conditional get. Null
-  // if the cached response doesn't exist or doesn't need validation. If the
-  // conditional get succeeds, these will be used for the response headers and
-  // body. If it fails, these be closed and set to null.
-  private ResponseHeaders cachedResponseHeaders;
-  private InputStream cachedResponseBody;
+  /**
+   * The cache response currently being validated on a conditional get. Null
+   * if the cached response doesn't exist or doesn't need validation. If the
+   * conditional get succeeds, these will be used for the response. If it fails,
+   * it will be set to null.
+   */
+  private Response validatingResponse;
+
+  /** The cache request currently being populated from a network response. */
+  private CacheRequest cacheRequest;
 
   /**
    * True if the socket connection should be released to the connection pool
@@ -173,11 +172,8 @@ public HttpEngine(OkHttpClient client, Policy policy, String method, RawHeaders
 
     this.requestHeaders = new RequestHeaders(uri, new RawHeaders(requestHeaders));
 
-    if (connection != null) {
-      connected = true;
-      if (connection.getSocket() instanceof SSLSocket) {
-        handshake = Handshake.get(((SSLSocket) connection.getSocket()).getSession());
-      }
+    if (connection != null && connection.getSocket() instanceof SSLSocket) {
+      handshake = Handshake.get(((SSLSocket) connection.getSocket()).getSession());
     }
   }
 
@@ -204,16 +200,21 @@ public final void sendRequest() throws IOException {
 
     // The raw response source may require the network, but the request
     // headers may forbid network use. In that case, dispose of the network
-    // response and use a GATEWAY_TIMEOUT response instead, as specified
+    // response and use a gateway timeout response instead, as specified
     // by http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
     if (requestHeaders.isOnlyIfCached() && responseSource.requiresConnection()) {
       if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-        Util.closeQuietly(cachedResponseBody);
+        Util.closeQuietly(validatingResponse.body());
       }
       this.responseSource = ResponseSource.CACHE;
-      this.cacheResponse = GATEWAY_TIMEOUT_RESPONSE;
-      RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(cacheResponse.getHeaders(), true);
-      setResponse(new ResponseHeaders(uri, rawResponseHeaders), cacheResponse.getBody());
+
+      RawHeaders gatewayTimeoutHeaders = new RawHeaders();
+      gatewayTimeoutHeaders.setStatusLine(""HTTP/1.1 504 Gateway Timeout"");
+      this.validatingResponse = new Response.Builder(request(), 504)
+          .rawHeaders(gatewayTimeoutHeaders)
+          .body(EMPTY_BODY)
+          .build();
+      promoteValidatingResponse(new ResponseHeaders(uri, gatewayTimeoutHeaders));
     }
 
     if (responseSource.requiresConnection()) {
@@ -235,35 +236,52 @@ private void initResponseSource() throws IOException {
     OkResponseCache responseCache = client.getOkResponseCache();
     if (responseCache == null) return;
 
-    CacheResponse candidate = responseCache.get(
-        uri, method, requestHeaders.getHeaders().toMultimap(false));
+    Response candidate = responseCache.get(request());
     if (candidate == null) return;
 
-    Map<String, List<String>> responseHeadersMap = candidate.getHeaders();
-    cachedResponseBody = candidate.getBody();
-    if (!acceptCacheResponseType(candidate)
-        || responseHeadersMap == null
-        || cachedResponseBody == null) {
-      Util.closeQuietly(cachedResponseBody);
+    if (!acceptCacheResponseType(candidate)) {
+      Util.closeQuietly(candidate.body());
       return;
     }
 
-    RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(responseHeadersMap, true);
-    cachedResponseHeaders = new ResponseHeaders(uri, rawResponseHeaders);
+    ResponseHeaders cachedResponseHeaders = new ResponseHeaders(uri, candidate.rawHeaders());
     long now = System.currentTimeMillis();
     this.responseSource = cachedResponseHeaders.chooseResponseSource(now, requestHeaders);
     if (responseSource == ResponseSource.CACHE) {
-      this.cacheResponse = candidate;
-      setResponse(cachedResponseHeaders, cachedResponseBody);
+      this.validatingResponse = candidate;
+      promoteValidatingResponse(cachedResponseHeaders);
     } else if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      this.cacheResponse = candidate;
+      this.validatingResponse = candidate;
     } else if (responseSource == ResponseSource.NETWORK) {
-      Util.closeQuietly(cachedResponseBody);
+      Util.closeQuietly(candidate.body());
     } else {
       throw new AssertionError();
     }
   }
 
+  private Request request() {
+    // This doesn't have a body. When we're sending requests to the cache, we don't need it.
+    return new Request.Builder(policy.getURL())
+        .method(method, null)
+        .rawHeaders(requestHeaders.getHeaders())
+        .build();
+  }
+
+  private Response response() {
+    RawHeaders rawHeaders = responseHeaders.getHeaders();
+
+    // Use an unreadable response body when offering the response to the cache. The cache isn't
+    // allowed to consume the response body bytes!
+    Response.Body body = new UnreadableResponseBody(responseHeaders.getContentType(),
+        responseHeaders.getContentLength());
+
+    return new Response.Builder(request(), rawHeaders.getResponseCode())
+        .body(body)
+        .rawHeaders(rawHeaders)
+        .handshake(handshake)
+        .build();
+  }
+
   private void sendSocketRequest() throws IOException {
     if (connection == null) {
       connect();
@@ -322,12 +340,11 @@ protected final void connect() throws IOException {
    * Called after a socket connection has been created or retrieved from the
    * pool. Subclasses use this hook to get a reference to the TLS data.
    */
-  protected void connected(Connection connection) {
+  private void connected(Connection connection) {
     if (handshake == null && connection.getSocket() instanceof SSLSocket) {
       handshake = Handshake.get(((SSLSocket) connection.getSocket()).getSession());
     }
     policy.setSelectedProxy(connection.getRoute().getProxy());
-    connected = true;
   }
 
   /**
@@ -341,17 +358,13 @@ public void writingRequestHeaders() {
     sentRequestMillis = System.currentTimeMillis();
   }
 
-  /**
-   * @param body the response body, or null if it doesn't exist or isn't
-   * available.
-   */
-  private void setResponse(ResponseHeaders headers, InputStream body) throws IOException {
-    if (this.responseBodyIn != null) {
-      throw new IllegalStateException();
-    }
-    this.responseHeaders = headers;
-    if (body != null) {
-      initContentStream(body);
+  private void promoteValidatingResponse(ResponseHeaders responseHeaders) throws IOException {
+    if (this.responseBodyIn != null) throw new IllegalStateException();
+
+    this.responseHeaders = responseHeaders;
+    this.handshake = validatingResponse.handshake();
+    if (validatingResponse.body() != null) {
+      initContentStream(validatingResponse.body().byteStream());
     }
   }
 
@@ -396,20 +409,15 @@ public final InputStream getResponseBody() {
     return responseBodyIn;
   }
 
-  public final CacheResponse getCacheResponse() {
-    return cacheResponse;
-  }
-
   public final Connection getConnection() {
     return connection;
   }
 
   /**
-   * Returns true if {@code cacheResponse} is of the right type. This
-   * condition is necessary but not sufficient for the cached response to
-   * be used.
+   * Returns true if {@code response} is of the right type. This condition is
+   * necessary but not sufficient for the cached response to be used.
    */
-  protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
+  protected boolean acceptCacheResponseType(Response response) {
     return true;
   }
 
@@ -419,16 +427,14 @@ private void maybeCache() throws IOException {
     OkResponseCache responseCache = client.getOkResponseCache();
     if (responseCache == null) return;
 
-    HttpURLConnection connectionToCache = policy.getHttpConnectionToCache();
-
     // Should we cache this response for this request?
     if (!responseHeaders.isCacheable(requestHeaders)) {
-      responseCache.maybeRemove(connectionToCache.getRequestMethod(), uri);
+      responseCache.maybeRemove(request());
       return;
     }
 
     // Offer this request to the cache.
-    cacheRequest = responseCache.put(uri, connectionToCache);
+    cacheRequest = responseCache.put(response());
   }
 
   /**
@@ -452,7 +458,9 @@ public final void automaticallyReleaseConnectionToPool() {
    */
   public final void release(boolean streamCanceled) {
     // If the response body comes from the cache, close it.
-    if (responseBodyIn == cachedResponseBody) {
+    if (validatingResponse != null
+        && validatingResponse.body() != null
+        && responseBodyIn == validatingResponse.body().byteStream()) {
       Util.closeQuietly(responseBodyIn);
     }
 
@@ -477,9 +485,9 @@ private void initContentStream(InputStream transferStream) throws IOException {
       // so clients don't double decompress. http://b/3009828
       //
       // Also remove the Content-Length in this case because it contains the
-      // length 528 of the gzipped response. This isn't terribly useful and is
-      // dangerous because 529 clients can query the content length, but not
-      // the content encoding.
+      // length of the gzipped response. This isn't terribly useful and is
+      // dangerous because clients can query the content length, but not the
+      // content encoding.
       responseHeaders.stripContentEncoding();
       responseHeaders.stripContentLength();
       responseBodyIn = new GZIPInputStream(transferStream);
@@ -614,7 +622,6 @@ protected boolean includeAuthorityInRequestLine() {
    * no TLS connection was made.
    */
   public Handshake getHandshake() {
-    // TODO: initialize handshake when populating a response from the cache.
     return handshake;
   }
 
@@ -672,23 +679,26 @@ public final void readResponse() throws IOException {
     responseHeaders.setResponseSource(responseSource);
 
     if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      if (cachedResponseHeaders.validate(responseHeaders)) {
+      ResponseHeaders validatingResponseHeaders = new ResponseHeaders(
+          uri, validatingResponse.rawHeaders());
+
+      if (validatingResponseHeaders.validate(responseHeaders)) {
         release(false);
-        ResponseHeaders combinedHeaders = cachedResponseHeaders.combine(responseHeaders);
-        this.responseHeaders = combinedHeaders;
+        responseHeaders = validatingResponseHeaders.combine(responseHeaders);
+        handshake = validatingResponse.handshake();
 
-        // Update the cache after applying the combined headers but before initializing the content
-        // stream, otherwise the Content-Encoding header (if present) will be stripped from the
-        // combined headers and not end up in the cache file if transparent gzip compression is
-        // turned on.
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
         OkResponseCache responseCache = client.getOkResponseCache();
         responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, policy.getHttpConnectionToCache());
+        responseCache.update(validatingResponse, response());
 
-        initContentStream(cachedResponseBody);
+        if (validatingResponse.body() != null) {
+          initContentStream(validatingResponse.body().byteStream());
+        }
         return;
       } else {
-        Util.closeQuietly(cachedResponseBody);
+        Util.closeQuietly(validatingResponse.body());
       }
     }
 
@@ -709,4 +719,30 @@ public void receiveHeaders(RawHeaders headers) throws IOException {
       cookieHandler.put(uri, headers.toMultimap(true));
     }
   }
+
+  static class UnreadableResponseBody extends Response.Body {
+    private final String contentType;
+    private final long contentLength;
+
+    public UnreadableResponseBody(String contentType, long contentLength) {
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+    }
+
+    @Override public boolean ready() throws IOException {
+      throw new IllegalStateException(""It is an error to read this response body at this time."");
+    }
+
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
+    }
+
+    @Override public long contentLength() {
+      return contentLength;
+    }
+
+    @Override public InputStream byteStream() {
+      throw new IllegalStateException(""It is an error to read this response body at this time."");
+    }
+  }
 }
@@ -266,10 +266,6 @@ private void initHttpEngine() throws IOException {
     }
   }
 
-  @Override public HttpURLConnection getHttpConnectionToCache() {
-    return this;
-  }
-
   private HttpEngine newHttpEngine(String method, RawHeaders requestHeaders,
       Connection connection, RetryableOutputStream requestBody) throws IOException {
     if (url.getProtocol().equals(""http"")) {
@@ -18,10 +18,9 @@
 
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.TunnelRequest;
 import java.io.IOException;
-import java.net.CacheResponse;
-import java.net.SecureCacheResponse;
 import java.net.URL;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
@@ -32,12 +31,8 @@ public HttpsEngine(OkHttpClient client, Policy policy, String method, RawHeaders
     super(client, policy, method, requestHeaders, connection, requestBody);
   }
 
-  @Override protected void connected(Connection connection) {
-    super.connected(connection);
-  }
-
-  @Override protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
-    return cacheResponse instanceof SecureCacheResponse;
+  @Override protected boolean acceptCacheResponseType(Response response) {
+    return response.handshake() != null;
   }
 
   @Override protected boolean includeAuthorityInRequestLine() {
@@ -21,9 +21,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.HttpURLConnection;
 import java.net.ProtocolException;
-import java.net.SecureCacheResponse;
 import java.net.URL;
 import java.security.Permission;
 import java.security.Principal;
@@ -37,67 +35,45 @@
 
 public final class HttpsURLConnectionImpl extends HttpsURLConnection {
 
-  /** HttpUrlConnectionDelegate allows reuse of HttpURLConnectionImpl. */
-  private final HttpUrlConnectionDelegate delegate;
+  /** Reuse HttpURLConnectionImpl. */
+  private final HttpURLConnectionImpl delegate;
 
   public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
-    delegate = new HttpUrlConnectionDelegate(url, client);
+    delegate = new HttpURLConnectionImpl(url, client);
   }
 
   @Override public String getCipherSuite() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getCipherSuite();
-    }
     Handshake handshake = handshake();
     return handshake != null ? handshake.cipherSuite() : null;
   }
 
   @Override public Certificate[] getLocalCertificates() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getLocalCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
     Handshake handshake = handshake();
     if (handshake == null) return null;
     List<Certificate> result = handshake.localCertificates();
     return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getServerCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
     Handshake handshake = handshake();
     if (handshake == null) return null;
     List<Certificate> result = handshake.peerCertificates();
     return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) return cacheResponse.getPeerPrincipal();
     Handshake handshake = handshake();
     return handshake != null ? handshake.peerPrincipal() : null;
   }
 
   @Override public Principal getLocalPrincipal() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) return cacheResponse.getLocalPrincipal();
     Handshake handshake = handshake();
     return handshake != null ? handshake.localPrincipal() : null;
   }
 
-  public HttpEngine getHttpEngine() {
-    return delegate.getHttpEngine();
-  }
-
   private Handshake handshake() {
-    if (delegate.httpEngine == null || !delegate.httpEngine.connected) {
+    if (delegate.httpEngine == null) {
       throw new IllegalStateException(""Connection has not yet been established"");
     }
     return delegate.httpEngine.getHandshake();
@@ -324,20 +300,4 @@ private Handshake handshake() {
   @Override public SSLSocketFactory getSSLSocketFactory() {
     return delegate.client.getSslSocketFactory();
   }
-
-  private final class HttpUrlConnectionDelegate extends HttpURLConnectionImpl {
-    private HttpUrlConnectionDelegate(URL url, OkHttpClient client) {
-      super(url, client);
-    }
-
-    @Override public HttpURLConnection getHttpConnectionToCache() {
-      return HttpsURLConnectionImpl.this;
-    }
-
-    public SecureCacheResponse getSecureCacheResponse() {
-      return httpEngine instanceof HttpsEngine
-          ? (SecureCacheResponse) httpEngine.getCacheResponse()
-          : null;
-    }
-  }
 }
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkResponseCache;
-import com.squareup.okhttp.ResponseSource;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-
-public final class OkResponseCacheAdapter implements OkResponseCache {
-  private final ResponseCache responseCache;
-  public OkResponseCacheAdapter(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return responseCache.get(uri, requestMethod, requestHeaders);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    return responseCache.put(uri, urlConnection);
-  }
-
-  @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-  }
-
-  @Override public void update(CacheResponse conditionalCacheHit, HttpURLConnection connection)
-      throws IOException {
-  }
-
-  @Override public void trackConditionalCacheHit() {
-  }
-
-  @Override public void trackResponse(ResponseSource source) {
-  }
-}
@@ -15,17 +15,13 @@
  */
 package com.squareup.okhttp.internal.http;
 
-import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URL;
 
 public interface Policy {
   /** Returns true if HTTP response caches should be used. */
   boolean getUseCaches();
 
-  /** Returns the HttpURLConnection instance to store in the cache. */
-  HttpURLConnection getHttpConnectionToCache();
-
   /** Returns the current destination URL, possibly a redirect. */
   URL getURL();
 
@@ -16,15 +16,14 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Request;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.Platform;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URI;
 import java.util.Collections;
 import java.util.Date;
-import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
@@ -381,12 +380,9 @@ public boolean hasVaryAll() {
    * Returns true if none of the Vary headers on this response have changed
    * between {@code cachedRequest} and {@code newRequest}.
    */
-  public boolean varyMatches(Map<String, List<String>> cachedRequest,
-      Map<String, List<String>> newRequest) {
+  public boolean varyMatches(RawHeaders varyHeaders, Request newRequest) {
     for (String field : varyFields) {
-      if (!equal(cachedRequest.get(field), newRequest.get(field))) {
-        return false;
-      }
+      if (!equal(varyHeaders.values(field), newRequest.headers(field))) return false;
     }
     return true;
   }
@@ -20,11 +20,16 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.File;
+import java.net.HttpURLConnection;
+import java.util.UUID;
 import javax.net.ssl.SSLContext;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 public final class AsyncApiTest {
@@ -33,9 +38,17 @@ public final class AsyncApiTest {
   private RecordingReceiver receiver = new RecordingReceiver();
 
   private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private HttpResponseCache cache;
+
+  @Before public void setUp() throws Exception {
+    String tmp = System.getProperty(""java.io.tmpdir"");
+    File cacheDir = new File(tmp, ""HttpCache-"" + UUID.randomUUID());
+    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
+  }
 
   @After public void tearDown() throws Exception {
     server.shutdown();
+    cache.delete();
   }
 
   @Test public void get() throws Exception {
@@ -91,4 +104,22 @@ public final class AsyncApiTest {
     assertEquals(""3"", recordedRequest.getHeader(""Content-Length""));
     assertEquals(""text/plain; charset=utf-8"", recordedRequest.getHeader(""Content-Type""));
   }
+
+  @Test public void cache() throws Exception {
+    server.enqueue(new MockResponse().setBody(""A"").addHeader(""ETag: v1""));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    Request request1 = new Request.Builder(server.getUrl(""/"")).build();
+    client.enqueue(request1, receiver);
+    receiver.await(request1).assertCode(200).assertBody(""A"");
+    assertNull(server.takeRequest().getHeader(""If-None-Match""));
+
+    Request request2 = new Request.Builder(server.getUrl(""/"")).build();
+    client.enqueue(request2, receiver);
+    receiver.await(request2).assertCode(200).assertBody(""A"");
+    assertEquals(""v1"", server.takeRequest().getHeader(""If-None-Match""));
+  }
 }
@@ -18,6 +18,9 @@
 
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
@@ -51,7 +54,6 @@
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -60,6 +62,7 @@
 import java.util.TimeZone;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.GZIPOutputStream;
@@ -201,11 +204,10 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     // exhaust the content stream
     readAscii(conn);
 
-    CacheResponse cached =
-        cache.get(url.toURI(), ""GET"", Collections.<String, List<String>>emptyMap());
+    Response cached = cache.get(new Request.Builder(url).build());
     if (shouldPut) {
       assertNotNull(Integer.toString(responseCode), cached);
-      cached.getBody().close();
+      cached.body().close();
     } else {
       assertNull(Integer.toString(responseCode), cached);
     }
@@ -220,40 +222,25 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     final String body = ""ABCDE"";
     final AtomicInteger cacheCount = new AtomicInteger();
 
-    server.enqueue(
-        new MockResponse().setStatus(""HTTP/1.1 200 Fantastic"").addHeader(""fgh: ijk"").setBody(body));
-    server.play();
-
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        HttpURLConnection httpConnection = (HttpURLConnection) conn;
-        try {
-          httpConnection.getRequestProperties();
-          fail();
-        } catch (IllegalStateException expected) {
-        }
+    server.enqueue(new MockResponse()
+        .setStatus(""HTTP/1.1 200 Fantastic"")
+        .addHeader(""Content-Type: text/plain"")
+        .addHeader(""fgh: ijk"")
+        .setBody(body));
+    server.play();
+
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public CacheRequest put(Response response) throws IOException {
+        assertEquals(server.getUrl(""/""), response.request().url());
+        assertEquals(200, response.code());
+        assertEquals(body.length(), response.body().contentLength());
+        assertEquals(""text/plain"", response.body().contentType().toString());
+        assertEquals(""ijk"", response.header(""fgh""));
         try {
-          httpConnection.addRequestProperty(""K"", ""V"");
+          response.body().byteStream(); // the RI doesn't forbid this, but it should
           fail();
         } catch (IllegalStateException expected) {
         }
-        assertEquals(""HTTP/1.1 200 Fantastic"", httpConnection.getHeaderField(null));
-        assertEquals(Arrays.asList(""HTTP/1.1 200 Fantastic""),
-            httpConnection.getHeaderFields().get(null));
-        assertEquals(200, httpConnection.getResponseCode());
-        assertEquals(""Fantastic"", httpConnection.getResponseMessage());
-        assertEquals(body.length(), httpConnection.getContentLength());
-        assertEquals(""ijk"", httpConnection.getHeaderField(""fgh""));
-        try {
-          httpConnection.getInputStream(); // the RI doesn't forbid this, but it should
-          fail();
-        } catch (IOException expected) {
-        }
         cacheCount.incrementAndGet();
         return null;
       }
@@ -265,6 +252,32 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     assertEquals(1, cacheCount.get());
   }
 
+  /** Don't explode if the cache returns a null body. http://b/3373699 */
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public CacheRequest put(Response response) throws IOException {
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
+      }
+    });
+
+    server.enqueue(new MockResponse().setBody(""abcdef""));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl(""/""));
+    assertEquals(""abc"", readAscii(connection, 3));
+    connection.getInputStream().close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+  }
+
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
   }
@@ -323,32 +336,32 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody(""ABC""));
     server.play();
 
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl(""/""));
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals(""ABC"", readAscii(connection));
+    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl(""/""));
+    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals(""ABC"", readAscii(c1));
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = connection.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(connection.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(connection.getServerCertificates());
-    Principal peerPrincipal = connection.getPeerPrincipal();
-    Principal localPrincipal = connection.getLocalPrincipal();
-
-    connection = (HttpsURLConnection) client.open(server.getUrl(""/"")); // cached!
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals(""ABC"", readAscii(connection));
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.getUrl(""/"")); // cached!
+    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals(""ABC"", readAscii(c2));
 
     assertEquals(2, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(1, cache.getHitCount());
 
-    assertEquals(suite, connection.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(connection.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(connection.getServerCertificates()));
-    assertEquals(peerPrincipal, connection.getPeerPrincipal());
-    assertEquals(localPrincipal, connection.getLocalPrincipal());
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
   }
 
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
@@ -486,15 +499,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody(""ABC""));
     server.play();
 
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
-        new AtomicReference<Map<String, List<String>>>();
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
+    final AtomicReference<Request> requestRef = new AtomicReference<Request>();
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public Response get(Request request) throws IOException {
+        requestRef.set(request);
         return null;
       }
     });
@@ -503,7 +511,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     URLConnection urlConnection = openConnection(url);
     urlConnection.addRequestProperty(""A"", ""android"");
     readAscii(urlConnection);
-    assertEquals(Arrays.asList(""android""), requestHeadersRef.get().get(""A""));
+    assertEquals(Arrays.asList(""android""), requestRef.get().headers(""A""));
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -1903,7 +1911,8 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
     InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
+        ? connection.getInputStream()
+        : httpConnection.getErrorStream();
     StringBuilder result = new StringBuilder();
     for (int i = 0; i < count; i++) {
       int value = in.read();
@@ -2002,4 +2011,27 @@ private class InsecureResponseCache extends ResponseCache {
       return response;
     }
   }
+
+  static abstract class AbstractOkResponseCache implements OkResponseCache {
+    @Override public Response get(Request request) throws IOException {
+      return null;
+    }
+
+    @Override public CacheRequest put(Response response) throws IOException {
+      return null;
+    }
+
+    @Override public boolean maybeRemove(Request request) throws IOException {
+      return false;
+    }
+
+    @Override public void update(Response cached, Response network) throws IOException {
+    }
+
+    @Override public void trackConditionalCacheHit() {
+    }
+
+    @Override public void trackResponse(ResponseSource source) {
+    }
+  }
 }
@@ -60,7 +60,6 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HttpsURLConnection;
@@ -2113,35 +2112,22 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    client.setResponseCache(new ResponseCache() {
+  @Test public void installDeprecatedJavaNetResponseCache() throws Exception {
+    ResponseCache cache = new ResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         return null;
       }
-
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
+        return null;
       }
-    });
-
-    server.enqueue(new MockResponse().setBody(""abcdef""));
-    server.play();
+    };
 
-    HttpURLConnection connection = client.open(server.getUrl(""/""));
-    InputStream in = connection.getInputStream();
-    assertEquals(""abc"", readAscii(in, 3));
-    in.close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+    try {
+      client.setResponseCache(cache);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
   }
 
   /** http://code.google.com/p/android/issues/detail?id=14562 */
"
https://github.com/junit-team/junit4/commit/435d41f0d45cfdbc1a38e1ad4eb1d5300da533f9,"Use Google's Maven Central mirror <enter>  <enter> We are using Maven 3.1.1 which by default uses HTTP instead of HTTPS for <enter> resolving artifacts from Maven Central. Maven Central recently <enter> discontinued HTTP support. Therefore the build on Travis started <enter> failing. By using an HTTPS mirror of Maven Central the build on Travis <enter> will work again. <enter>  <enter> I chose Google's mirror because Travis uses this mirror by default, too. <enter> I did not upgrade to a new version of Maven because there is no newer <enter> version with Java 5 support and it should be possible to build JUnit 4 <enter> with Java 5 so that we can easily ensure that it works with Java 5.",https://api.github.com/repos/junit-team/junit4/commits/435d41f0d45cfdbc1a38e1ad4eb1d5300da533f9,"@@ -1,4 +1,12 @@
 <settings>
+    <mirrors xmlns=""http://maven.apache.org/SETTINGS/1.1.0"">
+        <mirror>
+            <mirrorOf>central</mirrorOf>
+            <name>GCS Maven Central mirror</name>
+            <url>https://maven-central.storage-download.googleapis.com/maven2/</url>
+            <id>google-maven-central</id>
+        </mirror>
+    </mirrors>
     <servers>
         <server>
             <id>junit-snapshot-repo</id>
"
https://github.com/apache/dubbo/commit/6764744115bffdcd7cde85112611dade6002fe5c,update version to 2.1.6  <enter> git-svn-id:  http://code.alibabatech.com/svn/dubbo/trunk@1550  1a56cb94-b969-4eaa-88fa-be21384802f2 ,https://api.github.com/repos/apache/dubbo/commits/6764744115bffdcd7cde85112611dade6002fe5c,"@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-cluster-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-cluster-faulttolerant</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-cluster-loadbalance</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-cluster-router</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-common</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-config-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-config-guice</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-config-sca</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-config-spring</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-container-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-container-jetty</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-container-log4j</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-container-spring</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-demo</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-demo-consumer</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-demo-provider</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-filter-cache</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-filter-default</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-filter-validation</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-monitor-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-monitor-default</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-monitor-simple</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-default</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-multicast</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-redis</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-simple</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-zookeeper</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-grizzly</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-http</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-mina</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-netty</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-p2p</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-default</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-hessian</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-injvm</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-rmi</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-test-benchmark</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-test-showcase</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-test-integration</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo</artifactId>
 	<packaging>jar</packaging>
@@ -22,7 +22,7 @@
 		<version>1.0</version>
 	</parent>
 	<artifactId>dubbo-parent</artifactId>
-	<version>2.2.0-SNAPSHOT</version>
+	<version>2.1.6</version>
 	<packaging>pom</packaging>
 	<name>${project.artifactId}</name>
 	<description>The parent project of dubbo</description>
"
https://github.com/square/okhttp/commit/15940665526348d815b26d509ce44c79926c612b,Merge: Fix HttpURLConnection CloseGuard warning due to lack of close on GZIPInputStream <enter> Original AOSP/libcore commit by Brian Carlstrom: java.lang.Throwable: Explicit termination method 'end' not called   at dalvik.system.CloseGuard.open(CloseGuard.java:184)   at java.util.zip.Inflater.<init>(Inflater.java:82)   at java.util.zip.GZIPInputStream.<init>(GZIPInputStream.java:96)   at java.util.zip.GZIPInputStream.<init>(GZIPInputStream.java:81)   at libcore.net.http.HttpEngine.initContentStream(HttpEngine.java:523)   at libcore.net.http.HttpEngine.readResponse(HttpEngine.java:831)   at libcore.net.http.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:274)   at libcore.net.http.HttpURLConnectionImpl.getResponseCode(HttpURLConnectionImpl.java:486)   at ... <enter> Bug: 6602529 Change-Id: I9b49cbca561f8780d08844e566820087fdffc4d7 ,https://api.github.com/repos/square/okhttp/commits/15940665526348d815b26d509ce44c79926c612b,"@@ -35,6 +35,7 @@
 import java.util.List;
 import java.util.Map;
 import libcore.io.Base64;
+import libcore.io.IoUtils;
 import libcore.util.Libcore;
 
 /**
@@ -92,6 +93,14 @@ public HttpURLConnectionImpl(URL url, int port, Proxy proxy) {
     @Override public final void disconnect() {
         // Calling disconnect() before a connection exists should have no effect.
         if (httpEngine != null) {
+            // We close the response body here instead of in
+            // HttpEngine.release because that is called when input
+            // has been completely read from the underlying socket.
+            // However the response body can be a GZIPInputStream that
+            // still has unread data.
+            if (httpEngine.hasResponse()) {
+                IoUtils.closeQuietly(httpEngine.getResponseBody());
+            }
             httpEngine.release(false);
         }
     }
@@ -773,6 +773,50 @@ public void testDisconnectBeforeConnect() throws IOException {
         assertEquals(200, connection.getResponseCode());
     }
 
+//    public void testDisconnectAfterOnlyResponseCodeCausesNoCloseGuardWarning() throws IOException {
+//        CloseGuardGuard guard = new CloseGuardGuard();
+//        try {
+//            server.enqueue(new MockResponse()
+//                    .setBody(gzip(""ABCABCABC"".getBytes(""UTF-8"")))
+//                    .addHeader(""Content-Encoding: gzip""));
+//            server.play();
+//
+//            HttpURLConnection connection = (HttpURLConnection) server.getUrl(""/"").openConnection();
+//            assertEquals(200, connection.getResponseCode());
+//            connection.disconnect();
+//            connection = null;
+//            assertFalse(guard.wasCloseGuardCalled());
+//        } finally {
+//            guard.close();
+//        }
+//    }
+//
+//    public static class CloseGuardGuard implements Closeable, CloseGuard.Reporter  {
+//        private final CloseGuard.Reporter oldReporter = CloseGuard.getReporter();
+//
+//        private AtomicBoolean closeGuardCalled = new AtomicBoolean();
+//
+//        public CloseGuardGuard() {
+//            CloseGuard.setReporter(this);
+//        }
+//
+//        @Override public void report(String message, Throwable allocationSite) {
+//            oldReporter.report(message, allocationSite);
+//            closeGuardCalled.set(true);
+//        }
+//
+//        public boolean wasCloseGuardCalled() {
+//            // FinalizationTester.induceFinalization();
+//            close();
+//            return closeGuardCalled.get();
+//        }
+//
+//        @Override public void close() {
+//            CloseGuard.setReporter(oldReporter);
+//        }
+//
+//    }
+
     public void testDefaultRequestProperty() throws Exception {
         URLConnection.setDefaultRequestProperty(""X-testSetDefaultRequestProperty"", ""A"");
         assertNull(URLConnection.getDefaultRequestProperty(""X-setDefaultRequestProperty""));
"
https://github.com/junit-team/junit4/commit/18b23a7ed22080e7412e24060c66cef7fc3b1b93,Fix <issue_link> - correct link to 4.12 release notes ,https://api.github.com/repos/junit-team/junit4/commits/18b23a7ed22080e7412e24060c66cef7fc3b1b93,"@@ -78,8 +78,7 @@
             <li><a href=""https://github.com/junit-team/junit/wiki/Getting-started"">Getting started</a></li>
             <li>Release Notes
               <ul>
-<li>
-<a href=""https://github.com/junit-team/junit/wiki/4.12-release-notes"">4.12</a> - (unreleased)</li>
+<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.12.md"">4.12</a></li>
 <li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.11.md"">4.11</a></li>
 <li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.10.md"">4.10</a></li>
 <li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.9.1.md"">4.9.1</a></li>
"
https://github.com/spring-projects/spring-boot/commit/c3e447c84c8a3d46ef300184787d3c6be8b792fc,"Order char encoding filter so it sets encoding before request is read  <enter> For the character encoding filter to work, it's vital that it sets the request's encoding before any other filters attempt to read the request. This commit updates the order of OrderedCharacterEncodingFilter to be HIGHEST_PRECEDENCE and improves the existing test to check that the ordering is as required. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/c3e447c84c8a3d46ef300184787d3c6be8b792fc,"@@ -27,6 +27,8 @@
 import org.junit.rules.ExpectedException;
 import org.springframework.beans.DirectFieldAccessor;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
+import org.springframework.boot.context.web.OrderedHiddenHttpMethodFilter;
+import org.springframework.boot.context.web.OrderedHttpPutFormContentFilter;
 import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Bean;
@@ -145,8 +147,13 @@ public CharacterEncodingFilter myCharacterEncodingFilter() {
 	static class OrderedConfiguration {
 
 		@Bean
-		public HiddenHttpMethodFilter hiddenHttpMethodFilter() {
-			return new HiddenHttpMethodFilter();
+		public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
+			return new OrderedHiddenHttpMethodFilter();
+		}
+
+		@Bean
+		public OrderedHttpPutFormContentFilter httpPutFormContentFilter() {
+			return new OrderedHttpPutFormContentFilter();
 		}
 
 	}
@@ -16,7 +16,6 @@
 
 package org.springframework.boot.context.web;
 
-import org.springframework.boot.context.embedded.FilterRegistrationBean;
 import org.springframework.core.Ordered;
 import org.springframework.web.filter.CharacterEncodingFilter;
 
@@ -29,7 +28,7 @@
 public class OrderedCharacterEncodingFilter extends CharacterEncodingFilter implements
 		Ordered {
 
-	private int order = FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER - 9800;
+	private int order = Ordered.HIGHEST_PRECEDENCE;
 
 	@Override
 	public int getOrder() {
"
https://github.com/square/okhttp/commit/18f2b5e6e69de28f420298862378abfd243096ce,"Fix source compatibility for some Kotlin callsites. ( <pr_link> )  <enter> We had a problem where boolean vals needed to be reverted back to boolean funs. I'd like to go back to vals later, but supporting existing source patterns is more important. <enter> We also had a problem where single abstract method types (SAM types) could be supplied as lambas when calling into Java but not when calling into Kotlin. <enter> I found these by pointing KotlinSourceCompatibilityTest at the OkHttp <enter> Get there like this:   git co  <otherCommit_link> ^   git co  <otherCommit_link>  okhttp/build.gradle   git co  <otherCommit_link>  build.gradle ",https://api.github.com/repos/square/okhttp/commits/18f2b5e6e69de28f420298862378abfd243096ce,"@@ -183,7 +183,7 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
         logger.log(""--> END ${request.method()}"")
       } else if (bodyHasUnknownEncoding(request.headers())) {
         logger.log(""--> END ${request.method()} (encoded body omitted)"")
-      } else if (requestBody.isDuplex) {
+      } else if (requestBody.isDuplex()) {
         logger.log(""--> END ${request.method()} (duplex request body omitted)"")
       } else {
         val buffer = Buffer()
@@ -115,5 +115,13 @@ interface Authenticator {
         return null
       }
     }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_Authenticator"")
+    inline operator fun invoke(
+      crossinline block: (route: Route?, response: Response) -> Request?
+    ): Authenticator = object: Authenticator {
+      override fun authenticate(route: Route?, response: Response) = block(route, response)
+    }
   }
 }
@@ -74,9 +74,9 @@ interface Call : Cloneable {
    * Returns true if this call has been either [executed][execute] or [enqueued][enqueue]. It is an
    * error to execute a call more than once.
    */
-  val isExecuted: Boolean
+  fun isExecuted(): Boolean
 
-  val isCanceled: Boolean
+  fun isCanceled(): Boolean
 
   /**
    * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
@@ -112,6 +112,11 @@ class Dispatcher constructor() {
     this.idleCallback = idleCallback
   }
 
+  // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+  @JvmName(""-deprecated_setIdleCallback"")
+  inline fun setIdleCallback(crossinline idleCallback: () -> Unit) =
+      setIdleCallback(Runnable { idleCallback() })
+
   internal fun enqueue(call: AsyncCall) {
     synchronized(this) {
       readyAsyncCalls.add(call)
@@ -54,5 +54,13 @@ interface Dns {
         }
       }
     }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_Dns"")
+    inline operator fun invoke(
+      crossinline block: (String) -> List<InetAddress>
+    ): Dns = object : Dns {
+      override fun lookup(hostname: String): List<InetAddress> = block(hostname)
+    }
   }
 }
@@ -346,6 +346,16 @@ abstract class EventListener {
      * from this method.**
      */
     fun create(call: Call): EventListener
+
+    companion object {
+      // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+      @JvmName(""-deprecated_Factory"")
+      inline operator fun invoke(
+        crossinline block: (call: Call) -> EventListener
+      ): Factory = object : Factory {
+        override fun create(call: Call) = block(call)
+      }
+    }
   }
 
   companion object {
@@ -27,6 +27,16 @@ interface Interceptor {
   @Throws(IOException::class)
   fun intercept(chain: Chain): Response
 
+  companion object {
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_Interceptor"")
+    inline operator fun invoke(
+      crossinline block: (chain: Chain) -> Response
+    ): Interceptor = object: Interceptor {
+      override fun intercept(chain: Chain) = block(chain)
+    }
+  }
+
   interface Chain {
     fun request(): Request
 
@@ -755,6 +755,16 @@ open class OkHttpClient internal constructor(
       interceptors += interceptor
     }
 
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_addInterceptor"")
+    inline fun addInterceptor(
+      crossinline interceptor: (chain: Interceptor.Chain) -> Response
+    ) = apply {
+      addInterceptor(object : Interceptor {
+        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
+      })
+    }
+
     /**
      * Returns a modifiable list of interceptors that observe a single network request and response.
      * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for a
@@ -766,6 +776,16 @@ open class OkHttpClient internal constructor(
       networkInterceptors += interceptor
     }
 
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_addNetworkInterceptor"")
+    inline fun addNetworkInterceptor(
+      crossinline interceptor: (chain: Interceptor.Chain) -> Response
+    ) = apply {
+      addInterceptor(object : Interceptor {
+        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
+      })
+    }
+
     /**
      * Configure a single client scoped listener that will receive all analytic events for this
      * client.
@@ -786,6 +806,14 @@ open class OkHttpClient internal constructor(
       this.eventListenerFactory = eventListenerFactory
     }
 
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_eventListenerFactory"")
+    inline fun eventListenerFactory(crossinline block: (call: Call) -> EventListener) = apply {
+      eventListenerFactory(object : EventListener.Factory {
+        override fun create(call: Call) = block(call)
+      })
+    }
+
     fun build(): OkHttpClient = OkHttpClient(this)
   }
 
@@ -47,17 +47,18 @@ internal class RealCall private constructor(
   private lateinit var transmitter: Transmitter
 
   // Guarded by this.
-  @get:Synchronized override var isExecuted: Boolean = false
+  var executed: Boolean = false
 
-  override val isCanceled: Boolean
-    get() = transmitter.isCanceled
+  @Synchronized override fun isExecuted(): Boolean = executed
+
+  override fun isCanceled(): Boolean = transmitter.isCanceled
 
   override fun request(): Request = originalRequest
 
   override fun execute(): Response {
     synchronized(this) {
-      check(!isExecuted) { ""Already Executed"" }
-      isExecuted = true
+      check(!executed) { ""Already Executed"" }
+      executed = true
     }
     transmitter.timeoutEnter()
     transmitter.callStart()
@@ -71,8 +72,8 @@ internal class RealCall private constructor(
 
   override fun enqueue(responseCallback: Callback) {
     synchronized(this) {
-      check(!isExecuted) { ""Already Executed"" }
-      isExecuted = true
+      check(!executed) { ""Already Executed"" }
+      executed = true
     }
     transmitter.callStart()
     client.dispatcher().enqueue(AsyncCall(responseCallback))
@@ -153,7 +154,7 @@ internal class RealCall private constructor(
    * sensitive information.
    */
   fun toLoggableString(): String {
-    return ((if (isCanceled) ""canceled "" else """")
+    return ((if (isCanceled()) ""canceled "" else """")
         + (if (forWebSocket) ""web socket"" else ""call"")
         + "" to "" + redactedUrl())
   }
@@ -72,7 +72,7 @@ abstract class RequestBody {
    *
    * [grpc]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
    */
-  open val isDuplex: Boolean = false
+  open fun isDuplex(): Boolean = false
 
   /**
    * Returns true if this body expects at most one call to [writeTo] and can be transmitted
@@ -86,7 +86,7 @@ abstract class RequestBody {
    * (HTTP 401 and 407), or a retryable server failure (HTTP 503 with a `Retry-After: 0`
    * header).
    */
-  open val isOneShot: Boolean = false
+  open fun isOneShot(): Boolean = false
 
   companion object {
 
@@ -62,6 +62,8 @@ import javax.net.ssl.SSLSocketFactory
     ""ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE"",
     ""DEPRECATION"",
     ""RedundantExplicitType"",
+    ""RedundantLambdaArrow"",
+    ""UNUSED_ANONYMOUS_PARAMETER"",
     ""UNUSED_VALUE"",
     ""UNUSED_VARIABLE"",
     ""VARIABLE_WITH_REDUNDANT_INITIALIZER""
@@ -97,9 +99,10 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun authenticator() {
-    val authenticator = object : Authenticator {
+    var authenticator: Authenticator = object : Authenticator {
       override fun authenticate(route: Route?, response: Response): Request? = TODO()
     }
+    authenticator = Authenticator { route: Route?, response: Response -> TODO() }
   }
 
   @Test @Ignore
@@ -160,8 +163,8 @@ class KotlinSourceCompatibilityTest {
       override fun execute(): Response = TODO()
       override fun enqueue(responseCallback: Callback) = TODO()
       override fun cancel() = TODO()
-      override val isExecuted: Boolean get() = TODO()
-      override val isCanceled: Boolean get() = TODO()
+      override fun isExecuted(): Boolean = TODO()
+      override fun isCanceled(): Boolean = TODO()
       override fun timeout(): Timeout = TODO()
       override fun clone(): Call = TODO()
     }
@@ -312,6 +315,7 @@ class KotlinSourceCompatibilityTest {
     dispatcher.setIdleCallback(object : Runnable {
       override fun run() = TODO()
     })
+    dispatcher.setIdleCallback { TODO() }
     val queuedCalls: List<Call> = dispatcher.queuedCalls()
     val runningCalls: List<Call> = dispatcher.runningCalls()
     val queuedCallsCount: Int = dispatcher.queuedCallsCount()
@@ -321,9 +325,11 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun dns() {
-    val dns = object : Dns {
+    var dns: Dns = object : Dns {
       override fun lookup(hostname: String): List<InetAddress> = TODO()
     }
+    dns = Dns { it: String -> TODO() }
+
     val system: Dns = Dns.SYSTEM
   }
 
@@ -381,9 +387,10 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun eventListenerBuilder() {
-    val builder = object : EventListener.Factory {
+    var builder: EventListener.Factory = object : EventListener.Factory {
       override fun create(call: Call): EventListener = TODO()
     }
+    builder = EventListener.Factory { it: Call -> TODO() }
   }
 
   @Test @Ignore
@@ -394,7 +401,7 @@ class KotlinSourceCompatibilityTest {
     val name: String = formBody.name(0)
     val encodedValue: String = formBody.encodedValue(0)
     val value: String = formBody.value(0)
-    val contentType: MediaType = formBody.contentType()
+    val contentType: MediaType? = formBody.contentType()
     val contentLength: Long = formBody.contentLength()
     formBody.writeTo(Buffer())
     val requestBody: RequestBody = formBody
@@ -570,9 +577,10 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun interceptor() {
-    val interceptor = object : Interceptor {
+    var interceptor: Interceptor = object : Interceptor {
       override fun intercept(chain: Interceptor.Chain): Response = TODO()
     }
+    interceptor = Interceptor { it: Interceptor.Chain -> TODO() }
   }
 
   @Test @Ignore
@@ -683,14 +691,17 @@ class KotlinSourceCompatibilityTest {
     builder = builder.addInterceptor(object : Interceptor {
       override fun intercept(chain: Interceptor.Chain): Response = TODO()
     })
+    builder = builder.addInterceptor { it: Interceptor.Chain -> TODO() }
     val networkInterceptors: List<Interceptor> = builder.networkInterceptors()
     builder = builder.addNetworkInterceptor(object : Interceptor {
       override fun intercept(chain: Interceptor.Chain): Response = TODO()
     })
+    builder = builder.addNetworkInterceptor { it: Interceptor.Chain -> TODO() }
     builder = builder.eventListener(EventListener.NONE)
     builder = builder.eventListenerFactory(object : EventListener.Factory {
       override fun create(call: Call): EventListener = TODO()
     })
+    builder = builder.eventListenerFactory { it: Call -> TODO() }
     val client: OkHttpClient = builder.build()
   }
 
@@ -749,8 +760,8 @@ class KotlinSourceCompatibilityTest {
     var requestBody: RequestBody = object : RequestBody() {
       override fun contentType(): MediaType? = TODO()
       override fun contentLength(): Long = TODO()
-      override val isDuplex: Boolean get() = TODO()
-      override val isOneShot: Boolean get() = TODO()
+      override fun isDuplex(): Boolean = TODO()
+      override fun isOneShot(): Boolean = TODO()
       override fun writeTo(sink: BufferedSink) = TODO()
     }
     requestBody = RequestBody.create(null, """")
"
https://github.com/square/okhttp/commit/7a3bb19ea44f6771a20d3f5c323cc8bd15d73a56,"Prevent MockSpdyPeer interfering with Android tests  <enter> On Android we run the OkHttp tests as an instrumented test case. The default UncaughtExceptionHandler on Android will quit the app, causing the current test to fail. <enter> MockSpdyPeer creates a thread that fails for various reasons that are not related to / required for the actual test. Often the exception is thrown during a subsequent test. <enter> This change logs the exception but prevent it from propagating out of the top of the call stack. This decreases overall flakiness. ",https://api.github.com/repos/square/okhttp/commits/7a3bb19ea44f6771a20d3f5c323cc8bd15d73a56,"@@ -122,7 +122,7 @@ public void play() throws IOException {
           readAndWriteFrames();
         } catch (IOException e) {
           Util.closeQuietly(MockSpdyPeer.this);
-          throw new RuntimeException(e);
+          e.printStackTrace();
         }
       }
     });
"
https://github.com/apache/dubbo/commit/203078981bb23517703e7bbb60925b8542bc8983,Ignore testStatusChecker since it is unstable and consider removing it later. ,https://api.github.com/repos/apache/dubbo/commits/203078981bb23517703e7bbb60925b8542bc8983,"@@ -27,6 +27,7 @@
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.util.List;
@@ -123,8 +124,12 @@ public void testLookup() {
         assertThat(lookup.size(), is(1));
     }
 
-
+    @Ignore
     @Test
+    /*
+      This UT is unstable, consider remove it later.
+      @see https://github.com/apache/incubator-dubbo/issues/1787
+     */
     public void testStatusChecker() {
         RegistryStatusChecker registryStatusChecker = new RegistryStatusChecker();
         Status status = registryStatusChecker.check();
"
https://github.com/square/okhttp/commit/29ab48bf0dfbac1b249f2233de08fa948bad11d8,"Fix a race condition in Connection.isExpired().  <enter> This was causing some SPDY connections to be evicted early, and preventing connection reuse. <enter> The spdyConnectionReuse test becomes flaky with the fix that makes MockWebServer use different sequenceNumbers for different requests on the same socket. With the fix the test is no longer flaky. The old test wasn't good enough to detect what it wanted to detect! <enter> This race has existed in the code since we added more aggressive time-based expiration in January 2013. In my basic tests the race impacted ~20% of connections on a desktop VM. It may have been more on mobile. ",https://api.github.com/repos/square/okhttp/commits/29ab48bf0dfbac1b249f2233de08fa948bad11d8,"@@ -633,6 +633,7 @@ public void run() {
   private class SpdySocketHandler implements IncomingStreamHandler {
     private final Socket socket;
     private final Transport transport;
+    private final AtomicInteger sequenceNumber = new AtomicInteger();
 
     private SpdySocketHandler(Socket socket, Transport transport) {
       this.socket = socket;
@@ -684,7 +685,7 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
       String requestLine = method + ' ' + path + ' ' + version;
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
       return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.size(),
-          bodyOut.toByteArray(), 0, socket);
+          bodyOut.toByteArray(), sequenceNumber.getAndIncrement(), socket);
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
@@ -122,15 +122,18 @@ synchronized SpdyStream removeStream(int streamId) {
   }
 
   private synchronized void setIdle(boolean value) {
-    idleStartTimeNs = value ? System.nanoTime() : 0L;
+    idleStartTimeNs = value ? System.nanoTime() : Long.MAX_VALUE;
   }
 
   /** Returns true if this connection is idle. */
   public synchronized boolean isIdle() {
-    return idleStartTimeNs != 0L;
+    return idleStartTimeNs != Long.MAX_VALUE;
   }
 
-  /** Returns the time in ns when this connection became idle or 0L if connection is not idle. */
+  /**
+   * Returns the time in ns when this connection became idle or Long.MAX_VALUE
+   * if connection is not idle.
+   */
   public synchronized long getIdleStartTimeNs() {
     return idleStartTimeNs;
   }
@@ -244,7 +244,7 @@ public boolean isIdle() {
    * {@code keepAliveDurationNs}.
    */
   public boolean isExpired(long keepAliveDurationNs) {
-    return isIdle() && System.nanoTime() - getIdleStartTimeNs() > keepAliveDurationNs;
+    return getIdleStartTimeNs() < System.nanoTime() - keepAliveDurationNs;
   }
 
   /**
@@ -142,7 +142,7 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(""DEF"", readAscii(connection1.getInputStream(), 3));
     assertEquals(""JKL"", readAscii(connection2.getInputStream(), 3));
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   @Test public void gzippedResponseBody() throws Exception {
"
https://github.com/junit-team/junit4/commit/1254795902e56eb545e1fe696827924bc5e82b66,"Mark ThreadGroups created by FailOnTimeout as daemon groups ( <pr_link> )  <enter> Mark ThreadGroup created by FailOnTimeout as a daemon group. <enter> Previously, FailOnTimeout destroyed the ThreadGroup, which could cause race conditions if the ThreadGroup was referenced by other threads. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/junit-team/junit4/commits/1254795902e56eb545e1fe696827924bc5e82b66,"@@ -121,28 +121,21 @@ public void evaluate() throws Throwable {
         CallableStatement callable = new CallableStatement();
         FutureTask<Throwable> task = new FutureTask<Throwable>(callable);
         ThreadGroup threadGroup = new ThreadGroup(""FailOnTimeoutGroup"");
-        Thread thread = new Thread(threadGroup, task, ""Time-limited test"");
-        try {
-            thread.setDaemon(true);
-            thread.start();
-            callable.awaitStarted();
-            Throwable throwable = getResult(task, thread);
-            if (throwable != null) {
-                throw throwable;
-            }
-        } finally {
+        if (!threadGroup.isDaemon()) {
             try {
-                thread.join(1);
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-            }
-            try {
-                threadGroup.destroy();
-            } catch (IllegalThreadStateException e) {
-                // If a thread from the group is still alive, the ThreadGroup cannot be destroyed.
-                // Swallow the exception to keep the same behavior prior to this change.
+                threadGroup.setDaemon(true);
+            } catch (SecurityException e) {
+                // Swallow the exception to keep the same behavior as in JUnit 4.12.
             }
         }
+        Thread thread = new Thread(threadGroup, task, ""Time-limited test"");
+        thread.setDaemon(true);
+        thread.start();
+        callable.awaitStarted();
+        Throwable throwable = getResult(task, thread);
+        if (throwable != null) {
+            throw throwable;
+        }
     }
 
     /**
@@ -14,17 +14,16 @@
 import static org.junit.Assert.fail;
 import static org.junit.internal.runners.statements.FailOnTimeout.builder;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Test;
 import org.junit.function.ThrowingRunnable;
+import org.junit.internal.runners.statements.Fail;
 import org.junit.runners.model.Statement;
 import org.junit.runners.model.TestTimedOutException;
 
+
 /**
  * @author Asaf Ary, Stefan Birkner
  */
@@ -91,20 +90,24 @@ public void throwsExceptionWithTimeoutValueAndTimeUnitSet() {
         assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());
     }
 
-    private ThrowingRunnable evaluateWithException(final Exception exception) {
+    private ThrowingRunnable evaluateWithDelegate(final Statement delegate) {
         return new ThrowingRunnable() {
             public void run() throws Throwable {
-                statement.nextException = exception;
+                statement.nextStatement = delegate;
                 statement.waitDuration = 0;
                 failOnTimeout.evaluate();
             }
         };
     }
 
+    private ThrowingRunnable evaluateWithException(Exception exception) {
+        return evaluateWithDelegate(new Fail(exception));
+    }
+
     private ThrowingRunnable evaluateWithWaitDuration(final long waitDuration) {
         return new ThrowingRunnable() {
             public void run() throws Throwable {
-                statement.nextException = null;
+                statement.nextStatement = null;
                 statement.waitDuration = waitDuration;
                 failOnTimeout.evaluate();
             }
@@ -114,13 +117,13 @@ public void run() throws Throwable {
     private static final class TestStatement extends Statement {
         long waitDuration;
 
-        Exception nextException;
+        Statement nextStatement;
 
         @Override
         public void evaluate() throws Throwable {
             sleep(waitDuration);
-            if (nextException != null) {
-                throw nextException;
+            if (nextStatement != null) {
+                nextStatement.evaluate();
             }
         }
     }
@@ -210,20 +213,22 @@ private void notTheRealCauseOfTheTimeout() {
 
     @Test
     public void threadGroupNotLeaked() throws Throwable {
-        Collection<ThreadGroup> groupsBeforeSet = subGroupsOfCurrentThread();
-        
-        evaluateWithWaitDuration(0);
-        
-        for (ThreadGroup group: subGroupsOfCurrentThread()) {
-            if (!groupsBeforeSet.contains(group) && ""FailOnTimeoutGroup"".equals(group.getName())) {
-                fail(""A 'FailOnTimeoutGroup' thread group remains referenced after the test execution."");
+        final AtomicReference<ThreadGroup> innerThreadGroup = new AtomicReference<ThreadGroup>();
+        final AtomicReference<Thread> innerThread = new AtomicReference<Thread>();
+        ThrowingRunnable runnable = evaluateWithDelegate(new Statement() {
+            @Override
+            public void evaluate() {
+                innerThread.set(currentThread());
+                ThreadGroup group = currentThread().getThreadGroup();
+                innerThreadGroup.set(group);
+                assertTrue(""the 'FailOnTimeoutGroup' thread group should be a daemon thread group"", group.isDaemon());
             }
-        }
-    }
-    
-    private Collection<ThreadGroup> subGroupsOfCurrentThread() {
-        ThreadGroup[] subGroups = new ThreadGroup[256];
-        int numGroups = currentThread().getThreadGroup().enumerate(subGroups);
-        return Arrays.asList(subGroups).subList(0, numGroups);
+        });
+
+        runnable.run();
+
+        assertTrue(""the Statement was never run"", innerThread.get() != null);
+        innerThread.get().join();
+        assertTrue(""the 'FailOnTimeoutGroup' thread group should be destroyed after running the test"", innerThreadGroup.get().isDestroyed());
     }
 }
"
https://github.com/junit-team/junit4/commit/1ef449139923a22333f262dc8c75fa057903040c,Increase running time of statement. Fixes <issue_link> .  <enter> The time between starting the statement and calling the future is arbitrary. Now the execution time of the statement is very very long. This ensures that the statement is not already finished when the future is called. ,https://api.github.com/repos/junit-team/junit4/commits/1ef449139923a22333f262dc8c75fa057903040c,"@@ -23,10 +23,9 @@
 /**
  * @author Asaf Ary, Stefan Birkner
  */
-// TODO Fix this. See https://github.com/junit-team/junit/issues/963
-@Ignore
 public class FailOnTimeoutTest {
     private static final int TIMEOUT = 100;
+    private static final int DURATION_THAT_EXCEEDS_TIMEOUT = Integer.MAX_VALUE;
 
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
@@ -39,13 +38,13 @@ public class FailOnTimeoutTest {
     @Test
     public void throwsTestTimedOutException() throws Throwable {
         thrown.expect(TestTimedOutException.class);
-        evaluateWithWaitDuration(TIMEOUT + 50);
+        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
     }
 
     @Test
     public void throwExceptionWithNiceMessageOnTimeout() throws Throwable {
         thrown.expectMessage(""test timed out after 100 milliseconds"");
-        evaluateWithWaitDuration(TIMEOUT + 50);
+        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
     }
 
     @Test
@@ -60,7 +59,7 @@ public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime()
             throws Throwable {
         thrown.expect(TestTimedOutException.class);
         evaluateWithWaitDuration(0);
-        evaluateWithWaitDuration(TIMEOUT + 50);
+        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
     }
 
     @Test
@@ -71,14 +70,14 @@ public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException()
             evaluateWithException(new RuntimeException());
         } catch (Throwable expected) {
         }
-        evaluateWithWaitDuration(TIMEOUT + 50);
+        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
     }
 
     @Test
     public void throwsExceptionWithTimeoutValueAndTimeUnitSet()
             throws Throwable {
         try {
-            evaluateWithWaitDuration(TIMEOUT + 50);
+            evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
             fail(""No exception was thrown when test timed out"");
         } catch (TestTimedOutException e) {
             assertEquals(TIMEOUT, e.getTimeout());
"
https://github.com/square/okhttp/commit/2594c6c695f2898bba947ea86a7aaac8dcfd4dc4,Don't call callEnd() twice when application interceptors proceed twice.  <enter> I'm working towards reducing the role StreamAllocation plays. <enter>  <issue_link> ,https://api.github.com/repos/square/okhttp/commits/2594c6c695f2898bba947ea86a7aaac8dcfd4dc4,"@@ -88,8 +88,8 @@ public final class ConnectionPoolTest {
           .build();
       Call call = client.newCall(newRequest(addressA));
       Transmitter transmitter = new Transmitter(client, call);
-      transmitter.newStreamAllocation(addressA);
-      transmitter.acquire(c1, true);
+      transmitter.prepareToConnect(call.request());
+      transmitter.acquireConnection(c1, true);
     }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
@@ -186,8 +186,8 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
           .build();
       Call call = client.newCall(newRequest(connection.route().address()));
       Transmitter transmitter = new Transmitter(client, call);
-      transmitter.newStreamAllocation(call.request());
-      transmitter.acquire(connection, true);
+      transmitter.prepareToConnect(call.request());
+      transmitter.acquireConnection(connection, true);
     }
   }
 
@@ -1139,4 +1139,33 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
         ""CallEnd"");
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
+
+  @Test public void applicationInterceptorProceedsMultipleTimes() throws Exception {
+    server.enqueue(new MockResponse().setBody(""a""));
+    server.enqueue(new MockResponse().setBody(""b""));
+
+    client = client.newBuilder()
+        .addInterceptor(chain -> {
+          try (Response a = chain.proceed(chain.request())) {
+            assertEquals(""a"", a.body().string());
+          }
+          return chain.proceed(chain.request());
+        })
+        .build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
+    Response response = call.execute();
+    assertEquals(""b"", response.body().string());
+
+    List<String> expectedEvents = Arrays.asList(""CallStart"", ""DnsStart"", ""DnsEnd"",
+        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
+        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
+        ""ResponseBodyEnd"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"",
+        ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"",
+        ""CallEnd"");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
 }
@@ -110,17 +110,20 @@ public synchronized int connectionCount() {
   }
 
   /**
-   * Acquires a recycled connection to {@code address} for {@code streamAllocation}. If non-null
-   * {@code route} is the resolved route for a connection.
+   * Attempts to acquire a recycled connection to {@code address} for {@code transmitter}. If
+   * non-null {@code route} is the resolved route for a connection. Returns true if a connection was
+   * acquired.
    */
-  void acquire(Address address, Transmitter transmitter, @Nullable Route route) {
+  boolean transmitterAcquirePooledConnection(
+      Address address, Transmitter transmitter, @Nullable Route route) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
       if (connection.isEligible(address, route)) {
-        transmitter.acquire(connection, true);
-        return;
+        transmitter.acquireConnection(connection, true);
+        return true;
       }
     }
+    return false;
   }
 
   /**
@@ -149,9 +149,9 @@ public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory
         return pool.connectionBecameIdle(connection);
       }
 
-      @Override public void acquire(ConnectionPool pool, Address address,
-          Transmitter transmitter, @Nullable Route route) {
-        pool.acquire(address, transmitter, route);
+      @Override public boolean transmitterAcquirePooledConnection(
+          ConnectionPool pool, Address address, Transmitter transmitter, @Nullable Route route) {
+        return pool.transmitterAcquirePooledConnection(address, transmitter, route);
       }
 
       @Override public boolean equalsNonHost(Address a, Address b) {
@@ -259,6 +259,10 @@ Response getResponseWithInterceptorChain() throws IOException {
         originalRequest, this, client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis());
 
-    return chain.proceed(originalRequest);
+    try {
+      return chain.proceed(originalRequest);
+    } finally {
+      transmitter.noMoreStreamsOnCall();
+    }
   }
 }
@@ -51,8 +51,8 @@ public static void initializeInstanceForTests() {
 
   public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
 
-  public abstract void acquire(ConnectionPool pool, Address address,
-      Transmitter transmitter, @Nullable Route route);
+  public abstract boolean transmitterAcquirePooledConnection(
+      ConnectionPool pool, Address address, Transmitter transmitter, @Nullable Route route);
 
   public abstract boolean equalsNonHost(Address a, Address b);
 
@@ -44,6 +44,8 @@
 import okio.ForwardingSink;
 import okio.Sink;
 
+import static okhttp3.internal.Util.sameConnection;
+
 /**
  * Bridge between OkHttp's application and network layers. This class exposes high-level application
  * layer primitives: connections, requests, responses, and streams.
@@ -55,6 +57,7 @@ public final class Transmitter {
 
   private @Nullable Object callStackTrace;
 
+  private Request request;
   private volatile boolean canceled;
   private volatile StreamAllocation streamAllocation;
 
@@ -68,13 +71,24 @@ public void setCallStackTrace(@Nullable Object callStackTrace) {
     this.callStackTrace = callStackTrace;
   }
 
-  public void newStreamAllocation(Request request) {
-    newStreamAllocation(createAddress(request.url()));
-  }
+  /**
+   * Prepare to create a stream to carry {@code request}. This prefers to use the existing
+   * connection if it exists.
+   */
+  public void prepareToConnect(Request request) {
+    if (this.request != null) {
+      if (sameConnection(this.request.url(), request.url())) {
+        return; // Already ready.
+      }
+      if (streamAllocation != null) {
+        streamAllocation.transmitterReleaseConnection(false);
+        streamAllocation = null;
+      }
+    }
 
-  public void newStreamAllocation(Address address) {
+    this.request = request;
     this.streamAllocation = new StreamAllocation(this, client.connectionPool(),
-        address, call, eventListener, callStackTrace);
+        createAddress(request.url()), call, eventListener, callStackTrace);
   }
 
   private Address createAddress(HttpUrl url) {
@@ -116,7 +130,7 @@ public void streamFailed(@Nullable IOException e) {
   }
 
   public void noNewStreams() {
-    streamAllocation.noNewStreams();
+    streamAllocation.noNewStreamsOnConnection();
   }
 
   public RealWebSocket.Streams newWebSocketStreams() {
@@ -141,8 +155,10 @@ public boolean isConnectionMultiplexed() {
     return streamAllocation.connection().isMultiplexed();
   }
 
-  public void releaseStreamAllocation(boolean callEnd) {
-    streamAllocation.release(callEnd);
+  public void noMoreStreamsOnCall() {
+    if (streamAllocation != null) {
+      streamAllocation.transmitterReleaseConnection(true);
+    }
   }
 
   public boolean hasMoreRoutes() {
@@ -214,8 +230,8 @@ public boolean supportsUrl(HttpUrl url) {
     return streamAllocation.connection().supportsUrl(url);
   }
 
-  public void acquire(RealConnection connection, boolean reportedAcquired) {
-    streamAllocation.acquire(connection, reportedAcquired);
+  public void acquireConnection(RealConnection connection, boolean reportedAcquired) {
+    streamAllocation.transmitterAcquireConnection(connection, reportedAcquired);
   }
 
   public RealConnection connection() {
@@ -678,4 +678,11 @@ public static String getSystemProperty(String key, @Nullable String defaultValue
     }
     return value != null ? value : defaultValue;
   }
+
+  /** Returns true if an HTTP request for {@code a} and {@code b} can reuse a connection. */
+  public static boolean sameConnection(HttpUrl a, HttpUrl b) {
+    return a.host().equals(b.host())
+        && a.port() == b.port()
+        && a.scheme().equals(b.scheme());
+  }
 }
@@ -50,25 +50,26 @@
  *         connections. Each connection has its own allocation limit, which defines how many
  *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
  *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *         its follow up requests. We prefer to keep all streams of a single call on the same
- *         connection for better behavior and locality.
+ *     <li><strong>Transmitters:</strong> a logical sequence of streams, typically an initial
+ *         request and its follow up requests. We prefer to keep all streams of a single {@link
+ *         Call} on the same connection for better behavior and locality.
  * </ul>
  *
- * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
- * connections. This class has APIs to release each of the above resources:
+ * <p>Instances of this class act on behalf of a single transmitter, using one or more streams over
+ * one or more connections. This class has APIs to release each of the above resources:
  *
  * <ul>
- *     <li>{@link #noNewStreams} prevents the connection from being used for new streams in the
- *         future. Use this after a {@code Connection: close} header, or when the connection may be
- *         inconsistent.
+ *     <li>{@link #noNewStreamsOnConnection} prevents the connection from being used for new streams
+ *         in the future. Use this after a {@code Connection: close} header, or when the connection
+ *         may be inconsistent.
  *     <li>{@link #streamFinished streamFinished} releases the active stream from this allocation.
  *         Note that only one stream may be active at a given time, so it is necessary to call
  *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
  *         #newStream newStream()}.
- *     <li>{@link #release} removes the call's hold on the connection. Note that this won't
- *         immediately free the connection if there is a stream still lingering. That happens when a
- *         call is complete but its response body has yet to be fully consumed.
+ *     <li>{@link #transmitterReleaseConnection} removes the transmitter's hold on the connection.
+ *         Note that this won't immediately free the connection if there is a stream still
+ *         lingering. That happens when a call is complete but its response body has yet to be fully
+ *         consumed.
  * </ul>
  *
  * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
@@ -149,7 +150,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
       // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
       // isn't, take it out of the pool and start again.
       if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        noNewStreams();
+        noNewStreamsOnConnection();
         continue;
       }
 
@@ -189,8 +190,8 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
 
       if (result == null) {
         // Attempt to get a connection from the pool.
-        Internal.instance.acquire(connectionPool, address, transmitter, null);
-        if (connection != null) {
+        if (Internal.instance.transmitterAcquirePooledConnection(
+            connectionPool, address, transmitter, null)) {
           foundPooledConnection = true;
           result = connection;
         } else {
@@ -227,8 +228,8 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         List<Route> routes = routeSelection.getAll();
         for (int i = 0, size = routes.size(); i < size; i++) {
           Route route = routes.get(i);
-          Internal.instance.acquire(connectionPool, address, transmitter, route);
-          if (connection != null) {
+          if (Internal.instance.transmitterAcquirePooledConnection(
+              connectionPool, address, transmitter, route)) {
             foundPooledConnection = true;
             result = connection;
             this.route = route;
@@ -247,7 +248,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         route = selectedRoute;
         refusedStreamCount = 0;
         result = new RealConnection(connectionPool, selectedRoute);
-        acquire(result, false);
+        transmitterAcquireConnection(result, false);
       }
     }
 
@@ -347,7 +348,7 @@ public synchronized RealConnection connection() {
     return connection;
   }
 
-  public void release(boolean callEnd) {
+  public void transmitterReleaseConnection(boolean callEnd) {
     Socket socket;
     Connection releasedConnection;
     synchronized (connectionPool) {
@@ -368,7 +369,7 @@ public void release(boolean callEnd) {
   }
 
   /** Forbid new streams from being created on the connection that hosts this allocation. */
-  public void noNewStreams() {
+  public void noNewStreamsOnConnection() {
     Socket socket;
     Connection releasedConnection;
     synchronized (connectionPool) {
@@ -398,23 +399,15 @@ private Socket deallocate(boolean noNewStreams, boolean released, boolean stream
     if (released) {
       this.released = true;
     }
-    Socket socket = null;
     if (connection != null) {
       if (noNewStreams) {
         connection.noNewStreams = true;
       }
       if (this.codec == null && (this.released || connection.noNewStreams)) {
-        release(connection);
-        if (connection.transmitters.isEmpty()) {
-          connection.idleAtNanos = System.nanoTime();
-          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            socket = connection.socket();
-          }
-        }
-        connection = null;
+        return transmitterReleaseConnection();
       }
     }
-    return socket;
+    return null;
   }
 
   public void cancel() {
@@ -476,10 +469,10 @@ public void streamFailed(@Nullable IOException e) {
   }
 
   /**
-   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
-   * {@link #release} on the same connection.
+   * Use this allocation to hold {@code connection}. Each use of this must be paired with a call to
+   * {@link #transmitterReleaseConnection} on the same connection.
    */
-  public void acquire(RealConnection connection, boolean reportedAcquired) {
+  public void transmitterAcquireConnection(RealConnection connection, boolean reportedAcquired) {
     assert (Thread.holdsLock(connectionPool));
     if (this.connection != null) throw new IllegalStateException();
 
@@ -488,16 +481,34 @@ public void acquire(RealConnection connection, boolean reportedAcquired) {
     connection.transmitters.add(new TransmitterReference(transmitter, callStackTrace));
   }
 
-  /** Remove this allocation from the connection's list of allocations. */
-  private void release(RealConnection connection) {
+  /**
+   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
+   * caller should close.
+   */
+  private @Nullable Socket transmitterReleaseConnection() {
+    int index = -1;
     for (int i = 0, size = connection.transmitters.size(); i < size; i++) {
       Reference<Transmitter> reference = connection.transmitters.get(i);
       if (reference.get() == transmitter) {
-        connection.transmitters.remove(i);
-        return;
+        index = i;
+        break;
       }
     }
-    throw new IllegalStateException();
+
+    if (index == -1) throw new IllegalStateException();
+
+    RealConnection released = this.connection;
+    released.transmitters.remove(index);
+    this.connection = null;
+
+    if (released.transmitters.isEmpty()) {
+      released.idleAtNanos = System.nanoTime();
+      if (Internal.instance.connectionBecameIdle(connectionPool, released)) {
+        return released.socket();
+      }
+    }
+
+    return null;
   }
 
   /**
@@ -45,6 +45,7 @@
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
 import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.sameConnection;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
@@ -70,13 +71,12 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
     Transmitter transmitter = realChain.transmitter();
 
-    transmitter.newStreamAllocation(request);
-
     int followUpCount = 0;
     Response priorResponse = null;
     while (true) {
+      transmitter.prepareToConnect(request);
+
       if (transmitter.isCanceled()) {
-        transmitter.releaseStreamAllocation(true);
         throw new IOException(""Canceled"");
       }
 
@@ -102,7 +102,6 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
         // We're throwing an unchecked exception. Release any resources.
         if (releaseConnection) {
           transmitter.streamFailed(null);
-          transmitter.releaseStreamAllocation(true);
         }
       }
 
@@ -119,35 +118,28 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
       try {
         followUp = followUpRequest(response, transmitter.route());
       } catch (IOException e) {
-        transmitter.releaseStreamAllocation(true);
         throw e;
       }
 
       if (followUp == null) {
-        transmitter.releaseStreamAllocation(true);
         return response;
       }
 
       closeQuietly(response.body());
 
+      if (transmitter.hasCodec()) {
+        throw new IllegalStateException(""Closing the body of "" + response
+            + "" didn't close its backing stream. Bad interceptor?"");
+      }
+
       if (++followUpCount > MAX_FOLLOW_UPS) {
-        transmitter.releaseStreamAllocation(true);
         throw new ProtocolException(""Too many follow-up requests: "" + followUpCount);
       }
 
       if (followUp.body() instanceof UnrepeatableRequestBody) {
-        transmitter.releaseStreamAllocation(true);
         throw new HttpRetryException(""Cannot retry streamed HTTP body"", response.code());
       }
 
-      if (!sameConnection(response, followUp.url())) {
-        transmitter.releaseStreamAllocation(false);
-        transmitter.newStreamAllocation(followUp);
-      } else if (transmitter.hasCodec()) {
-        throw new IllegalStateException(""Closing the body of "" + response
-            + "" didn't close its backing stream. Bad interceptor?"");
-      }
-
       request = followUp;
       priorResponse = response;
     }
@@ -285,7 +277,7 @@ private Request followUpRequest(Response userResponse, Route route) throws IOExc
         // When redirecting across hosts, drop all authentication headers. This
         // is potentially annoying to the application layer since they have no
         // way to retain them.
-        if (!sameConnection(userResponse, url)) {
+        if (!sameConnection(userResponse.request().url(), url)) {
           requestBuilder.removeHeader(""Authorization"");
         }
 
@@ -350,15 +342,4 @@ private int retryAfter(Response userResponse, int defaultDelay) {
 
     return Integer.MAX_VALUE;
   }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  private boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
 }
"
https://github.com/square/okhttp/commit/1ab086360755fcb13356617fe6d738171889d810,"Add a test for interceptors throwing unchecked exceptions.  <enter> Our behavior here is not good. Right now it looks like we're leaking resources; nothing is releasing the socket in a 'finally' clause when interceptors crash. We're also not notifying the callback that the call has failed; that's left hanging. <enter> That said, we don't expect applications to recover from these exceptions. <enter>  Closes   <issue_link> ",https://api.github.com/repos/square/okhttp/commits/1ab086360755fcb13356617fe6d738171889d810,"@@ -23,6 +23,11 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -430,6 +435,73 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     callbackB.await(requestB.url()).assertBody(""b"");
   }
 
+  @Test public void applicationkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(client.interceptors());
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(client.networkInterceptors());
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
+   * with it.
+   *
+   * TODO(jwilson): test that resources are not leaked when this happens.
+   */
+  private void interceptorThrowsRuntimeExceptionSynchronous(
+      List<Interceptor> interceptors) throws Exception {
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException(""boom!"");
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl(""/""))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals(""boom!"", expected.getMessage());
+    }
+  }
+
+  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(client.interceptors());
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(client.networkInterceptors());
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
+   * exception goes to the uncaught exception handler.
+   *
+   * TODO(jwilson): test that resources are not leaked when this happens.
+   */
+  private void interceptorThrowsRuntimeExceptionAsynchronous(
+        List<Interceptor> interceptors) throws Exception {
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException(""boom!"");
+      }
+    });
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client.setDispatcher(new Dispatcher(executor));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl(""/""))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    assertEquals(""boom!"", executor.takeException().getMessage());
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -480,4 +552,29 @@ private Buffer gzip(String data) throws IOException {
     sink.close();
     return result;
   }
+
+  /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
+  private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
+    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
+
+    public ExceptionCatchingExecutor() {
+      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
+    }
+
+    @Override public void execute(final Runnable runnable) {
+      super.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            runnable.run();
+          } catch (Exception e) {
+            exceptions.add(e);
+          }
+        }
+      });
+    }
+
+    public Exception takeException() throws InterruptedException {
+      return exceptions.take();
+    }
+  }
 }
"
https://github.com/square/retrofit/commit/863030b551bc2e3447c5dde55d6bcc312218de6f,Add docs about null responses. ,https://api.github.com/repos/square/retrofit/commits/863030b551bc2e3447c5dde55d6bcc312218de6f,"@@ -74,7 +74,8 @@ public boolean isNetworkError() {
 
   /**
    * HTTP response body converted to the type declared by either the interface method return type or
-   * the generic type of the supplied {@link Callback} parameter.
+   * the generic type of the supplied {@link Callback} parameter. {@code null} if there is no
+   * response.
    */
   public Object getBody() {
     if (response == null) {
@@ -91,7 +92,9 @@ public Object getBody() {
     }
   }
 
-  /** HTTP response body converted to specified {@code type}. */
+  /**
+   * HTTP response body converted to specified {@code type}. {@code null} if there is no response.
+   */
   public Object getBodyAs(Type type) {
     if (response == null) {
       return null;
"
https://github.com/spring-projects/spring-boot/commit/296dc7132b8e444df0e6173740fa6bba5a5f1bd1,Allow JSON Testers to be `@Autowired`  <enter> Switch `@AutoConfigureJsonTesters` to use regular `@Autowired` injection for JSON testers. Prior to this commit JSON Tester fields were initialized directly which caused IDE issues and was also a little confusing. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/296dc7132b8e444df0e6173740fa6bba5a5f1bd1,"@@ -5011,12 +5011,13 @@ annotation.
 Spring Boot includes AssertJ based helpers that work with the JSONassert and JsonPath
 libraries to check that JSON is as expected. The `JacksonHelper`, `GsonHelper` and
 `BasicJsonTester` classes can be used for Jackson, Gson and Strings respectively. Any
-helper fields on the test class will be automatically initialized when using `@JsonTest`.
+helper fields on the test class can be `@Autowired` when using `@JsonTest`.
 
 [source,java,indent=0]
 ----
 	import org.junit.*;
 	import org.junit.runner.*;
+	import org.springframework.beans.factory.annotation.*;
 	import org.springframework.boot.test.autoconfigure.json.*;
 	import org.springframework.boot.test.context.*;
 	import org.springframework.boot.test.json.*;
@@ -5028,6 +5029,7 @@ helper fields on the test class will be automatically initialized when using `@J
 	@JsonTest
 	public class MyJsonTests {
 
+		@Autowired
 		private JacksonTester<VehicleDetails> json;
 
 		@Test
@@ -19,6 +19,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.autoconfigure.json.JsonTest;
 import org.springframework.boot.test.json.JacksonTester;
 import org.springframework.test.context.junit4.SpringRunner;
@@ -34,6 +35,7 @@
 @JsonTest
 public class VehicleDetailsJsonTests {
 
+	@Autowired
 	private JacksonTester<VehicleDetails> json;
 
 	@Test
@@ -18,42 +18,34 @@
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
-import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
+import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
+import org.springframework.boot.test.autoconfigure.properties.PropertyMapping;
 import org.springframework.boot.test.json.BasicJsonTester;
 import org.springframework.boot.test.json.GsonTester;
 import org.springframework.boot.test.json.JacksonTester;
-import org.springframework.context.ApplicationContext;
-import org.springframework.test.context.TestExecutionListeners;
-import org.springframework.test.context.TestExecutionListeners.MergeMode;
 
 /**
  * Annotation that can be applied to a test class to enable and configure
  * auto-configuration of JSON testers.
- * <p>
- * NOTE: {@code @AutoConfigureJsonTesters} works in conjunction with
- * {@link JsonTesterInitializationTestExecutionListener}. If you declare your own
- * {@link TestExecutionListeners @TestExecutionListeners} and don't
- * {@link MergeMode#MERGE_WITH_DEFAULTS merge with defaults} you must include
- * {@link JsonTesterInitializationTestExecutionListener} to use this annotation.
  *
  * @author Phillip Webb
- * @see JsonTesterInitializationTestExecutionListener
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
-@Inherited
+@ImportAutoConfiguration
+@PropertyMapping(""spring.test.jsontesters"")
 public @interface AutoConfigureJsonTesters {
 
 	/**
-	 * If {@link BasicJsonTester}, {@link JacksonTester} and {@link GsonTester} fields
-	 * should be initialized using marshallers from the {@link ApplicationContext}.
-	 * @return if JSON tester fields should be initialized
+	 * If {@link BasicJsonTester}, {@link JacksonTester} and {@link GsonTester} beans
+	 * should be registered. Defaults to {@code true}
+	 * @return if tester support is enabled
 	 */
-	boolean initFields() default true;
+	boolean enabled() default true;
 
 }
@@ -1,174 +0,0 @@
-/*
- * Copyright 2012-2016 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.test.autoconfigure.json;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.google.gson.Gson;
-
-import org.springframework.beans.BeansException;
-import org.springframework.beans.factory.ObjectFactory;
-import org.springframework.boot.test.json.BasicJsonTester;
-import org.springframework.boot.test.json.GsonTester;
-import org.springframework.boot.test.json.JacksonTester;
-import org.springframework.core.annotation.AnnotatedElementUtils;
-import org.springframework.test.context.TestContext;
-import org.springframework.test.context.TestExecutionListener;
-import org.springframework.test.context.support.AbstractTestExecutionListener;
-import org.springframework.util.ClassUtils;
-import org.springframework.util.ReflectionUtils;
-import org.springframework.util.ReflectionUtils.FieldCallback;
-
-/**
- * {@link TestExecutionListener} to initialize JSON tester fields.
- *
- * @author Phillip Webb
- * @since 1.4.0
- */
-public class JsonTesterInitializationTestExecutionListener
-		extends AbstractTestExecutionListener {
-
-	private static final String ASSERTJ_CLASS = ""org.assertj.core.api.Assert"";
-
-	private static final Map<String, Class<?>> INITIALIZERS;
-
-	static {
-		Map<String, Class<?>> initializers = new LinkedHashMap<String, Class<?>>();
-		initializers.put(""com.fasterxml.jackson.databind.ObjectMapper"",
-				JacksonInitializer.class);
-		initializers.put(""com.google.gson.Gson"", GsonInitializer.class);
-		INITIALIZERS = Collections.unmodifiableMap(initializers);
-	}
-
-	@Override
-	public void prepareTestInstance(TestContext testContext) throws Exception {
-		ClassLoader classLoader = getClass().getClassLoader();
-		if (ClassUtils.isPresent(ASSERTJ_CLASS, classLoader)
-				&& shouldInitializeFields(testContext)) {
-			initializeBasicJsonTesterFields(testContext);
-			initializeJsonMarshalTesterFields(classLoader, testContext);
-		}
-	}
-
-	private boolean shouldInitializeFields(TestContext testContext) {
-		AutoConfigureJsonTesters annotation = AnnotatedElementUtils.getMergedAnnotation(
-				testContext.getTestClass(), AutoConfigureJsonTesters.class);
-		return (annotation != null && annotation.initFields());
-	}
-
-	private void initializeBasicJsonTesterFields(final TestContext testContext) {
-		ReflectionUtils.doWithFields(testContext.getTestClass(), new FieldCallback() {
-
-			@Override
-			public void doWith(Field field)
-					throws IllegalArgumentException, IllegalAccessException {
-				if (BasicJsonTester.class.isAssignableFrom(field.getType())) {
-					setupField(field);
-				}
-			}
-
-			private void setupField(Field field) {
-				ReflectionUtils.makeAccessible(field);
-				Object existingInstance = ReflectionUtils.getField(field,
-						testContext.getTestInstance());
-				if (existingInstance == null) {
-					ReflectionUtils.setField(field, testContext.getTestInstance(),
-							new BasicJsonTester(testContext.getTestClass()));
-				}
-			}
-
-		});
-	}
-
-	private void initializeJsonMarshalTesterFields(ClassLoader classLoader,
-			TestContext testContext) {
-		for (Map.Entry<String, Class<?>> entry : INITIALIZERS.entrySet()) {
-			if (ClassUtils.isPresent(entry.getKey(), classLoader)) {
-				initializeJsonMarshalTesterFields(classLoader, testContext,
-						entry.getKey(), entry.getValue());
-			}
-		}
-	}
-
-	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
-	private void initializeJsonMarshalTesterFields(ClassLoader classLoader,
-			TestContext testContext, String marshallerClassName, Class<?> initializer) {
-		try {
-			Constructor<?> constructor = initializer.getDeclaredConstructor();
-			ReflectionUtils.makeAccessible(constructor);
-			initializeJsonMarshalTesterFields(testContext,
-					ClassUtils.resolveClassName(marshallerClassName, classLoader),
-					(Initializer) constructor.newInstance());
-		}
-		catch (Throwable ex) {
-			throw new IllegalStateException(ex);
-		}
-	}
-
-	private <T> void initializeJsonMarshalTesterFields(final TestContext testContext,
-			final Class<T> marshallerClass, Initializer<T> initializer) {
-		initializer.initialize(testContext, new ObjectFactory<T>() {
-
-			@Override
-			public T getObject() throws BeansException {
-				return testContext.getApplicationContext().getBean(marshallerClass);
-			}
-
-		});
-	}
-
-	/**
-	 * Strategy used to initialize JSON testers without cause class not found exceptions.
-	 * @param <M> the marshaller type
-	 */
-	interface Initializer<M> {
-
-		void initialize(TestContext testContext, ObjectFactory<M> marshaller);
-
-	}
-
-	/**
-	 * {@link Initializer} for {@link JacksonTester}.
-	 */
-	static class JacksonInitializer implements Initializer<ObjectMapper> {
-
-		@Override
-		public void initialize(TestContext testContext,
-				ObjectFactory<ObjectMapper> marshaller) {
-			JacksonTester.initFields(testContext.getTestInstance(), marshaller);
-		}
-
-	}
-
-	/**
-	 * {@link Initializer} for {@link GsonTester}.
-	 */
-	static class GsonInitializer implements Initializer<Gson> {
-
-		@Override
-		public void initialize(TestContext testContext, ObjectFactory<Gson> marshaller) {
-			GsonTester.initFields(testContext.getTestInstance(), marshaller);
-		}
-
-	}
-
-}
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2012-2016 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.test.autoconfigure.json;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+
+import org.springframework.beans.BeanUtils;
+import org.springframework.beans.BeansException;
+import org.springframework.beans.factory.FactoryBean;
+import org.springframework.beans.factory.config.BeanPostProcessor;
+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.test.json.AbstractJsonMarshalTester;
+import org.springframework.boot.test.json.BasicJsonTester;
+import org.springframework.boot.test.json.GsonTester;
+import org.springframework.boot.test.json.JacksonTester;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Scope;
+import org.springframework.core.ResolvableType;
+import org.springframework.test.util.ReflectionTestUtils;
+import org.springframework.util.ReflectionUtils;
+import org.springframework.util.ReflectionUtils.FieldCallback;
+
+/**
+ * Auto-configuration for Json testers.
+ *
+ * @author Phillip Webb
+ * @see AutoConfigureJsonTesters
+ * @since 1.4.0
+ */
+@Configuration
+@ConditionalOnClass(name = ""org.assertj.core.api.Assert"")
+@ConditionalOnProperty(""spring.test.jsontesters.enabled"")
+public class JsonTestersAutoConfiguration {
+
+	@Bean
+	public static JsonMarshalTestersBeanPostProcessor jsonMarshalTestersBeanPostProcessor() {
+		return new JsonMarshalTestersBeanPostProcessor();
+	}
+
+	@Bean
+	@Scope(""prototype"")
+	public FactoryBean<BasicJsonTester> BasicJsonTesterFactoryBean() {
+		return new JsonTesterFactoryBean<BasicJsonTester, Void>(BasicJsonTester.class,
+				null);
+	}
+
+	@Bean
+	@Scope(""prototype"")
+	@ConditionalOnClass(ObjectMapper.class)
+	@ConditionalOnBean(ObjectMapper.class)
+	public FactoryBean<JacksonTester<?>> jacksonTesterFactoryBean(ObjectMapper mapper) {
+		return new JsonTesterFactoryBean<JacksonTester<?>, ObjectMapper>(
+				JacksonTester.class, mapper);
+	}
+
+	@Bean
+	@Scope(""prototype"")
+	@ConditionalOnClass(ObjectMapper.class)
+	@ConditionalOnBean(Gson.class)
+	public FactoryBean<GsonTester<?>> gsonTesterFactoryBean(Gson gson) {
+		return new JsonTesterFactoryBean<GsonTester<?>, Gson>(GsonTester.class, gson);
+	}
+
+	/**
+	 * {@link FactoryBean} used to create JSON Tester instances.
+	 */
+	private class JsonTesterFactoryBean<T, M> implements FactoryBean<T> {
+
+		private final Class<?> objectType;
+
+		private final M marshaller;
+
+		JsonTesterFactoryBean(Class<?> objectType, M marshaller) {
+			this.objectType = objectType;
+			this.marshaller = marshaller;
+
+		}
+
+		@Override
+		public boolean isSingleton() {
+			return false;
+		}
+
+		@Override
+		@SuppressWarnings(""unchecked"")
+		public T getObject() throws Exception {
+			if (this.marshaller == null) {
+				Constructor<?> constructor = this.objectType.getDeclaredConstructor();
+				ReflectionUtils.makeAccessible(constructor);
+				return (T) BeanUtils.instantiateClass(constructor);
+			}
+			Constructor<?>[] constructors = this.objectType.getDeclaredConstructors();
+			for (Constructor<?> constructor : constructors) {
+				if (constructor.getParameterTypes().length == 1
+						&& constructor.getParameterTypes()[0]
+								.isInstance(this.marshaller)) {
+					ReflectionUtils.makeAccessible(constructor);
+					return (T) BeanUtils.instantiateClass(constructor, this.marshaller);
+				}
+			}
+			throw new IllegalStateException(
+					this.objectType + "" does not have a usable constructor"");
+		}
+
+		@Override
+		public Class<?> getObjectType() {
+			return this.objectType;
+		}
+
+	}
+
+	/**
+	 * {@link BeanPostProcessor} used to initialize JSON testers.
+	 */
+	private static class JsonMarshalTestersBeanPostProcessor
+			extends InstantiationAwareBeanPostProcessorAdapter {
+
+		@Override
+		public Object postProcessAfterInitialization(final Object bean, String beanName)
+				throws BeansException {
+
+			ReflectionUtils.doWithFields(bean.getClass(), new FieldCallback() {
+
+				@Override
+				public void doWith(Field field)
+						throws IllegalArgumentException, IllegalAccessException {
+					processFiled(bean, field);
+				}
+
+			});
+			return bean;
+		}
+
+		private void processFiled(Object bean, Field field) {
+			if (AbstractJsonMarshalTester.class.isAssignableFrom(field.getType())
+					|| BasicJsonTester.class.isAssignableFrom(field.getType())) {
+				ResolvableType type = ResolvableType.forField(field).getGeneric();
+				ReflectionUtils.makeAccessible(field);
+				Object tester = ReflectionUtils.getField(field, bean);
+				if (tester != null) {
+					ReflectionTestUtils.invokeMethod(tester, ""initialize"",
+							bean.getClass(), type);
+				}
+			}
+		}
+
+	}
+
+}
@@ -17,6 +17,10 @@ org.springframework.boot.test.autoconfigure.json.AutoConfigureJson=\
 org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
 org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration
 
+# AutoConfigureJsonTesters auto-configuration imports
+org.springframework.boot.test.autoconfigure.json.AutoConfigureJsonTesters=\
+org.springframework.boot.test.autoconfigure.json.JsonTestersAutoConfiguration
+
 # AutoConfigureMockMvc auto-configuration imports
 org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc=\
 org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration,\
@@ -69,6 +73,5 @@ org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCus
 # Test Execution Listeners
 org.springframework.test.context.TestExecutionListener=\
 org.springframework.boot.test.autoconfigure.AutoConfigureReportTestExecutionListener,\
-org.springframework.boot.test.autoconfigure.json.JsonTesterInitializationTestExecutionListener,\
 org.springframework.boot.test.autoconfigure.restdocs.RestDocsTestExecutionListener,\
 org.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerResetTestExecutionListener
@@ -19,6 +19,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.json.BasicJsonTester;
 import org.springframework.boot.test.json.GsonTester;
 import org.springframework.boot.test.json.JacksonTester;
@@ -35,12 +36,16 @@
 @JsonTest
 public class JsonTestIntegrationTests {
 
+	@Autowired
 	private BasicJsonTester basicJson;
 
+	@Autowired
 	private JacksonTester<ExampleBasicObject> jacksonBasicJson;
 
+	@Autowired
 	private JacksonTester<ExampleCustomObject> jacksonCustomJson;
 
+	@Autowired
 	private GsonTester<ExampleBasicObject> gsonJson;
 
 	@Test
@@ -19,6 +19,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.json.BasicJsonTester;
 import org.springframework.boot.test.json.GsonTester;
 import org.springframework.boot.test.json.JacksonTester;
@@ -33,13 +34,16 @@
  */
 @RunWith(SpringRunner.class)
 @JsonTest
-@AutoConfigureJsonTesters(initFields = false)
+@AutoConfigureJsonTesters(enabled = false)
 public class JsonTestWithAutoConfigureJsonTestersTests {
 
+	@Autowired(required = false)
 	private BasicJsonTester basicJson;
 
+	@Autowired(required = false)
 	private JacksonTester<ExampleBasicObject> jacksonTester;
 
+	@Autowired(required = false)
 	private GsonTester<ExampleBasicObject> gsonTester;
 
 	@Test
@@ -1,179 +0,0 @@
-/*
- * Copyright 2012-2016 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.test.autoconfigure.json;
-
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.google.gson.GsonBuilder;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.ExpectedException;
-
-import org.springframework.boot.test.json.BasicJsonTester;
-import org.springframework.boot.test.json.GsonTester;
-import org.springframework.boot.test.json.JacksonTester;
-import org.springframework.context.support.StaticApplicationContext;
-import org.springframework.test.context.TestContext;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
-/**
- * Tests for {@link JsonTesterInitializationTestExecutionListener}.
- *
- * @author Phillip Webb
- */
-public class JsonTesterInitializationTestExecutionListenerTests {
-
-	@Rule
-	public ExpectedException thrown = ExpectedException.none();
-
-	private JsonTesterInitializationTestExecutionListener listener = new JsonTesterInitializationTestExecutionListener();
-
-	@Test
-	public void prepareTestContextShouldInitializeBasicJsonTester() throws Exception {
-		WithBasicJsonTester instance = new WithBasicJsonTester();
-		this.listener.prepareTestInstance(mockTestContext(instance));
-		assertThat(instance.tester).isNotNull();
-	}
-
-	@Test
-	public void prepareTestContextShouldInitializeJacksonTester() throws Exception {
-		WithJacksonTester instance = new WithJacksonTester();
-		this.listener.prepareTestInstance(mockTestContext(instance, new ObjectMapper()));
-		assertThat(instance.tester).isNotNull();
-	}
-
-	@Test
-	public void prepareTestContextShouldInitializeGsonTester() throws Exception {
-		WithGsonTester instance = new WithGsonTester();
-		this.listener.prepareTestInstance(
-				mockTestContext(instance, new GsonBuilder().create()));
-		assertThat(instance.tester).isNotNull();
-	}
-
-	@Test
-	public void prepareTestContextWhenInitFieldsFalseShouldNotInitializeTesters()
-			throws Exception {
-		WithInitFieldsFalse instance = new WithInitFieldsFalse();
-		this.listener.prepareTestInstance(mockTestContext(instance, new ObjectMapper()));
-		assertThat(instance.basicTester).isNull();
-		assertThat(instance.jacksonTester).isNull();
-		assertThat(instance.gsonTester).isNull();
-	}
-
-	@Test
-	public void prepareTestContextWhenInitFieldsTrueShouldInitializeTesters()
-			throws Exception {
-		WithInitFieldsTrue instance = new WithInitFieldsTrue();
-		this.listener.prepareTestInstance(mockTestContext(instance));
-		assertThat(instance.tester).isNotNull();
-	}
-
-	@Test
-	public void prepareTestContextWhenMissingAnnotationShouldNotInitializeTesters()
-			throws Exception {
-		WithoutAnnotation instance = new WithoutAnnotation();
-		this.listener.prepareTestInstance(mockTestContext(instance));
-		assertThat(instance.basicTester).isNull();
-		assertThat(instance.jacksonTester).isNull();
-		assertThat(instance.gsonTester).isNull();
-	}
-
-	@Test
-	public void prepareTestContextWhenHasJacksonTesterButNoObjectMapperBeanShouldThrowException()
-			throws Exception {
-		WithJacksonTester instance = new WithJacksonTester();
-		this.thrown.expect(IllegalStateException.class);
-		this.thrown.expectMessage(""ObjectMapper"");
-		this.listener.prepareTestInstance(mockTestContext(instance));
-	}
-
-	@Test
-	public void prepareTestContextWhenHasJacksonTesterButNoGsonBeanShouldThrowException()
-			throws Exception {
-		WithGsonTester instance = new WithGsonTester();
-		this.thrown.expect(IllegalStateException.class);
-		this.thrown.expectMessage(""Gson"");
-		this.listener.prepareTestInstance(mockTestContext(instance));
-	}
-
-	private TestContext mockTestContext(Object testInstance) {
-		return mockTestContext(testInstance, null);
-	}
-
-	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
-	private TestContext mockTestContext(Object testInstance, Object bean) {
-		TestContext testContext = mock(TestContext.class);
-		StaticApplicationContext applicationContext = new StaticApplicationContext();
-		if (bean != null) {
-			applicationContext.getBeanFactory().registerSingleton(""bean"", bean);
-		}
-		given(testContext.getApplicationContext()).willReturn(applicationContext);
-		given(testContext.getTestClass()).willReturn((Class) testInstance.getClass());
-		given(testContext.getTestInstance()).willReturn(testInstance);
-		return testContext;
-	}
-
-	@AutoConfigureJsonTesters
-	static class WithBasicJsonTester {
-
-		private BasicJsonTester tester;
-
-	}
-
-	@AutoConfigureJsonTesters
-	static class WithJacksonTester {
-
-		private JacksonTester<Object> tester;
-	}
-
-	@AutoConfigureJsonTesters
-	static class WithGsonTester {
-
-		private GsonTester<Object> tester;
-	}
-
-	@AutoConfigureJsonTesters(initFields = false)
-	static class WithInitFieldsFalse {
-
-		private BasicJsonTester basicTester;
-
-		private JacksonTester<Object> jacksonTester;
-
-		private GsonTester<Object> gsonTester;
-
-	}
-
-	@AutoConfigureJsonTesters(initFields = true)
-	static class WithInitFieldsTrue {
-
-		private BasicJsonTester tester;
-
-	}
-
-	static class WithoutAnnotation {
-
-		private BasicJsonTester basicTester;
-
-		private JacksonTester<Object> jacksonTester;
-
-		private GsonTester<Object> gsonTester;
-
-	}
-
-}
@@ -70,9 +70,15 @@
  */
 public abstract class AbstractJsonMarshalTester<T> {
 
-	private final Class<?> resourceLoadClass;
+	private Class<?> resourceLoadClass;
 
-	private final ResolvableType type;
+	private ResolvableType type;
+
+	/**
+	 * Create a new uninitialized {@link AbstractJsonMarshalTester} instance.
+	 */
+	protected AbstractJsonMarshalTester() {
+	}
 
 	/**
 	 * Create a new {@link AbstractJsonMarshalTester} instance.
@@ -83,8 +89,20 @@ public abstract class AbstractJsonMarshalTester<T> {
 	public AbstractJsonMarshalTester(Class<?> resourceLoadClass, ResolvableType type) {
 		Assert.notNull(resourceLoadClass, ""ResourceLoadClass must not be null"");
 		Assert.notNull(type, ""Type must not be null"");
-		this.resourceLoadClass = resourceLoadClass;
-		this.type = type;
+		initialize(resourceLoadClass, type);
+	}
+
+	/**
+	 * Initialize the marshal tester for use.
+	 * @param resourceLoadClass the source class used when loading relative classpath
+	 * resources
+	 * @param type the type under test
+	 */
+	protected final void initialize(Class<?> resourceLoadClass, ResolvableType type) {
+		if (this.resourceLoadClass == null && this.type == null) {
+			this.resourceLoadClass = resourceLoadClass;
+			this.type = type;
+		}
 	}
 
 	/**
@@ -102,6 +120,7 @@ protected final ResolvableType getType() {
 	 * @throws IOException on write error
 	 */
 	public JsonContent<T> write(T value) throws IOException {
+		verify();
 		Assert.notNull(value, ""Value must not be null"");
 		String json = writeObject(value, this.type);
 		return new JsonContent<T>(this.resourceLoadClass, this.type, json);
@@ -114,6 +133,7 @@ public JsonContent<T> write(T value) throws IOException {
 	 * @throws IOException on parse error
 	 */
 	public T parseObject(byte[] jsonBytes) throws IOException {
+		verify();
 		return parse(jsonBytes).getObject();
 	}
 
@@ -124,6 +144,7 @@ public T parseObject(byte[] jsonBytes) throws IOException {
 	 * @throws IOException on parse error
 	 */
 	public ObjectContent<T> parse(byte[] jsonBytes) throws IOException {
+		verify();
 		Assert.notNull(jsonBytes, ""JsonBytes must not be null"");
 		return read(new ByteArrayResource(jsonBytes));
 	}
@@ -135,6 +156,7 @@ public ObjectContent<T> parse(byte[] jsonBytes) throws IOException {
 	 * @throws IOException on parse error
 	 */
 	public T parseObject(String jsonString) throws IOException {
+		verify();
 		return parse(jsonString).getObject();
 	}
 
@@ -145,6 +167,7 @@ public T parseObject(String jsonString) throws IOException {
 	 * @throws IOException on parse error
 	 */
 	public ObjectContent<T> parse(String jsonString) throws IOException {
+		verify();
 		Assert.notNull(jsonString, ""JsonString must not be null"");
 		return read(new StringReader(jsonString));
 	}
@@ -157,6 +180,7 @@ public ObjectContent<T> parse(String jsonString) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(String resourcePath) throws IOException {
+		verify();
 		return read(resourcePath).getObject();
 	}
 
@@ -168,6 +192,7 @@ public T readObject(String resourcePath) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(String resourcePath) throws IOException {
+		verify();
 		Assert.notNull(resourcePath, ""ResourcePath must not be null"");
 		return read(new ClassPathResource(resourcePath, this.resourceLoadClass));
 	}
@@ -179,6 +204,7 @@ public ObjectContent<T> read(String resourcePath) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(File file) throws IOException {
+		verify();
 		return read(file).getObject();
 	}
 
@@ -189,6 +215,7 @@ public T readObject(File file) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(File file) throws IOException {
+		verify();
 		Assert.notNull(file, ""File must not be null"");
 		return read(new FileSystemResource(file));
 	}
@@ -200,6 +227,7 @@ public ObjectContent<T> read(File file) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(InputStream inputStream) throws IOException {
+		verify();
 		return read(inputStream).getObject();
 	}
 
@@ -210,6 +238,7 @@ public T readObject(InputStream inputStream) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(InputStream inputStream) throws IOException {
+		verify();
 		Assert.notNull(inputStream, ""InputStream must not be null"");
 		return read(new InputStreamResource(inputStream));
 	}
@@ -221,6 +250,7 @@ public ObjectContent<T> read(InputStream inputStream) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(Resource resource) throws IOException {
+		verify();
 		return read(resource).getObject();
 	}
 
@@ -231,6 +261,7 @@ public T readObject(Resource resource) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(Resource resource) throws IOException {
+		verify();
 		Assert.notNull(resource, ""Resource must not be null"");
 		InputStream inputStream = resource.getInputStream();
 		T object = readObject(inputStream, this.type);
@@ -245,6 +276,7 @@ public ObjectContent<T> read(Resource resource) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(Reader reader) throws IOException {
+		verify();
 		return read(reader).getObject();
 	}
 
@@ -255,6 +287,7 @@ public T readObject(Reader reader) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(Reader reader) throws IOException {
+		verify();
 		Assert.notNull(reader, ""Reader must not be null"");
 		T object = readObject(reader, this.type);
 		closeQuietly(reader);
@@ -269,6 +302,12 @@ private void closeQuietly(Closeable closeable) {
 		}
 	}
 
+	private void verify() {
+		Assert.state(this.resourceLoadClass != null,
+				""Unitialized JsonMarshalTester (ResourceLoadClass is null)"");
+		Assert.state(this.type != null, ""Unitialized JsonMarshalTester (Type is null)"");
+	}
+
 	/**
 	 * Write the specified object to a JSON string.
 	 * @param value the source value (never {@code null})
@@ -19,6 +19,7 @@
 import java.io.File;
 import java.io.InputStream;
 
+import org.springframework.core.ResolvableType;
 import org.springframework.core.io.Resource;
 import org.springframework.util.Assert;
 
@@ -45,7 +46,13 @@
  */
 public class BasicJsonTester {
 
-	private final JsonLoader loader;
+	private JsonLoader loader;
+
+	/**
+	 * Create a new uninialized {@link BasicJsonTester} instance.
+	 */
+	protected BasicJsonTester() {
+	}
 
 	/**
 	 * Create a new {@link BasicJsonTester} instance.
@@ -56,6 +63,18 @@ public BasicJsonTester(Class<?> resourceLoadClass) {
 		this.loader = new JsonLoader(resourceLoadClass);
 	}
 
+	/**
+	 * Initialize the marshal tester for use.
+	 * @param resourceLoadClass the source class used when loading relative classpath
+	 * resources
+	 * @param type the type under test
+	 */
+	protected final void initialize(Class<?> resourceLoadClass, ResolvableType type) {
+		if (this.loader == null) {
+			this.loader = new JsonLoader(resourceLoadClass);
+		}
+	}
+
 	/**
 	 * Create JSON content from the specified String source. The source can contain the
 	 * JSON itself or, if it ends with {@code .json}, the name of a resource to be loaded
@@ -64,6 +83,7 @@ public BasicJsonTester(Class<?> resourceLoadClass) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(CharSequence source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
@@ -74,6 +94,7 @@ public JsonContent<Object> from(CharSequence source) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(String path, Class<?> resourceLoadClass) {
+		verify();
 		return getJsonContent(this.loader.getJson(path, resourceLoadClass));
 	}
 
@@ -83,6 +104,7 @@ public JsonContent<Object> from(String path, Class<?> resourceLoadClass) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(byte[] source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
@@ -92,6 +114,7 @@ public JsonContent<Object> from(byte[] source) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(File source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
@@ -101,6 +124,7 @@ public JsonContent<Object> from(File source) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(InputStream source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
@@ -110,9 +134,14 @@ public JsonContent<Object> from(InputStream source) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(Resource source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
+	private void verify() {
+		Assert.state(this.loader != null, ""Unitialized BasicJsonTester"");
+	}
+
 	private JsonContent<Object> getJsonContent(String json) {
 		return new JsonContent<Object>(this.loader.getResourceLoadClass(), null, json);
 	}
@@ -57,6 +57,15 @@ public class GsonTester<T> extends AbstractJsonMarshalTester<T> {
 
 	private final Gson gson;
 
+	/**
+	 * Create a new uninitialized {@link GsonTester} instance.
+	 * @param gson the Gson instance
+	 */
+	protected GsonTester(Gson gson) {
+		Assert.notNull(gson, ""Gson must not be null"");
+		this.gson = gson;
+	}
+
 	/**
 	 * Create a new {@link GsonTester} instance.
 	 * @param resourceLoadClass the source class used to load resources
@@ -59,6 +59,15 @@ public class JacksonTester<T> extends AbstractJsonMarshalTester<T> {
 
 	private final ObjectMapper objectMapper;
 
+	/**
+	 * Create a new {@link JacksonTester} instance.
+	 * @param objectMapper the Jackson object mapper
+	 */
+	protected JacksonTester(ObjectMapper objectMapper) {
+		Assert.notNull(objectMapper, ""ObjectMapper must not be null"");
+		this.objectMapper = objectMapper;
+	}
+
 	/**
 	 * Create a new {@link JacksonTester} instance.
 	 * @param resourceLoadClass the source class used to load resources
"
https://github.com/spring-projects/spring-boot/commit/12724bf33211d68899d710fda376bd5636731e4c,"Fix ordering of keys in PropertySourcesPropertyValues  <enter> Since  @ConfigurationProperties  binding uses a single instance of PropertySourcesPropertyValues per bean, there doesn't seem to be any issue with using a normal LinkedHashMap. Then the order passed in as PropertySources will be preserved. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/12724bf33211d68899d710fda376bd5636731e4c,"@@ -19,8 +19,8 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 
 import org.springframework.beans.MutablePropertyValues;
 import org.springframework.beans.PropertyValue;
@@ -42,7 +42,7 @@
  */
 public class PropertySourcesPropertyValues implements PropertyValues {
 
-	private final Map<String, PropertyValue> propertyValues = new ConcurrentHashMap<String, PropertyValue>();
+	private final Map<String, PropertyValue> propertyValues = new LinkedHashMap<String, PropertyValue>();
 
 	private final PropertySources propertySources;
 
@@ -16,11 +16,14 @@
 
 package org.springframework.boot.bind;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 
 import org.junit.Before;
 import org.junit.Test;
+import org.springframework.beans.PropertyValue;
 import org.springframework.core.env.CompositePropertySource;
 import org.springframework.core.env.MapPropertySource;
 import org.springframework.core.env.MutablePropertySources;
@@ -61,6 +64,26 @@ public void testSize() {
 		assertEquals(1, propertyValues.getPropertyValues().length);
 	}
 
+	@Test
+	public void testOrderPreserved() {
+		LinkedHashMap<String, Object> map = new LinkedHashMap<String, Object>();
+		map.put(""one"", 1);
+		map.put(""two"", 2);
+		map.put(""three"", 3);
+		map.put(""four"", 4);
+		map.put(""five"", 5);
+		this.propertySources.addFirst(new MapPropertySource(""ordered"", map));
+		PropertySourcesPropertyValues propertyValues = new PropertySourcesPropertyValues(
+				this.propertySources);
+		PropertyValue[] values = propertyValues.getPropertyValues();
+		assertEquals(6, values.length);
+		Collection<String> names = new ArrayList<String>();
+		for (PropertyValue value : values) {
+			names.add(value.getName());
+		}
+		assertEquals(""[one, two, three, four, five, name]"", names.toString());
+	}
+
 	@Test
 	public void testNonEnumeratedValue() {
 		PropertySourcesPropertyValues propertyValues = new PropertySourcesPropertyValues(
"
https://github.com/spring-projects/spring-boot/commit/1de2316a0b4c2d5896c34b954208a4c550466f22,"Refine validator and MVC validator configuration  <enter> This commit ensures that a primary JSR 303 and Spring Validator will be exposed if the auto-configuration kicks in. As `LocalValidatorFactoryBean` exposes 3 contracts (JSR-303 `Validator` and `ValidatorFactory` as well as the `Spring` validator one), this makes sure that those types can be injected by type. <enter> `LocalValidatorFactoryBean` exposes 3 contracts and we're only checking for the absence of a `javax.validation.Validator` to auto-configure a `LocalValidatorFactoryBean`. If no standard JSR validator exists but a Spring's `Validator` exists and is primary, we shouldn't flag the auto-configured one as `@Primary`. Previous iterations on this feature have made sure that we'll auto-configure at most one `javax.validation.Validator` so not flagging it `@Primary` is no problem. <enter> This commit also restores and adds tests that validates `ValidationAutoConfiguration` will configure a JSR validator even if a Spring Validator is present. <enter> This effectively  fixes   <issue_link>  in a different way. <enter>  Closes   <issue_link>   Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/1de2316a0b4c2d5896c34b954208a4c550466f22,"@@ -0,0 +1,88 @@
+/*
+ * Copyright 2012-2017 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.validation;
+
+import org.springframework.beans.BeansException;
+import org.springframework.beans.factory.BeanFactory;
+import org.springframework.beans.factory.BeanFactoryAware;
+import org.springframework.beans.factory.BeanFactoryUtils;
+import org.springframework.beans.factory.config.BeanDefinition;
+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
+import org.springframework.beans.factory.support.BeanDefinitionRegistry;
+import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
+import org.springframework.core.type.AnnotationMetadata;
+import org.springframework.validation.Validator;
+import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
+
+/**
+ * Enable the {@code Primary} flag on the auto-configured validator if necessary.
+ * <p>
+ * As {@link LocalValidatorFactoryBean} exposes 3 validator related contracts and we're
+ * only checking for the absence {@link javax.validation.Validator}, we should flag the
+ * auto-configured validator as primary only if no Spring's {@link Validator} is flagged
+ * as primary.
+ *
+ * @author Stephane Nicoll
+ */
+class PrimaryDefaultValidatorPostProcessor
+		implements ImportBeanDefinitionRegistrar, BeanFactoryAware {
+
+	/**
+	 * The bean name of the auto-configured Validator.
+	 */
+	private static final String VALIDATOR_BEAN_NAME = ""defaultValidator"";
+
+	private ConfigurableListableBeanFactory beanFactory;
+
+	@Override
+	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
+		if (beanFactory instanceof ConfigurableListableBeanFactory) {
+			this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
+		}
+	}
+
+	@Override
+	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
+			BeanDefinitionRegistry registry) {
+		if (this.beanFactory == null) {
+			return;
+		}
+		if (!registry.containsBeanDefinition(VALIDATOR_BEAN_NAME)) {
+			return;
+		}
+		BeanDefinition def = registry.getBeanDefinition(VALIDATOR_BEAN_NAME);
+		if (def != null
+				&& this.beanFactory.isTypeMatch(VALIDATOR_BEAN_NAME, LocalValidatorFactoryBean.class)
+				&& def.getRole() == BeanDefinition.ROLE_INFRASTRUCTURE) {
+			def.setPrimary(!hasPrimarySpringValidator(registry));
+		}
+	}
+
+	private boolean hasPrimarySpringValidator(BeanDefinitionRegistry registry) {
+		String[] validatorBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
+				this.beanFactory, Validator.class, false, false);
+		for (String validatorBean : validatorBeans) {
+			BeanDefinition def = registry.getBeanDefinition(validatorBean);
+			if (def != null && def.isPrimary()) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+}
+
@@ -28,6 +28,7 @@
 import org.springframework.boot.validation.MessageInterpolatorFactory;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Import;
 import org.springframework.context.annotation.Role;
 import org.springframework.core.env.Environment;
 import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
@@ -43,12 +44,13 @@
 @Configuration
 @ConditionalOnClass(ExecutableValidator.class)
 @ConditionalOnResource(resources = ""classpath:META-INF/services/javax.validation.spi.ValidationProvider"")
+@Import(PrimaryDefaultValidatorPostProcessor.class)
 public class ValidationAutoConfiguration {
 
 	@Bean
 	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
-	@ConditionalOnMissingBean
-	public static Validator jsr303Validator() {
+	@ConditionalOnMissingBean(Validator.class)
+	public static LocalValidatorFactoryBean defaultValidator() {
 		LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean();
 		MessageInterpolatorFactory interpolatorFactory = new MessageInterpolatorFactory();
 		factoryBean.setMessageInterpolator(interpolatorFactory.getObject());
@@ -31,15 +31,20 @@
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Primary;
 import org.springframework.validation.annotation.Validated;
+import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
 import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;
+import org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
 
 /**
  * Tests for {@link ValidationAutoConfiguration}.
  *
  * @author Stephane Nicoll
+ * @author Phillip Webb
  */
 public class ValidationAutoConfigurationTests {
 
@@ -55,6 +60,95 @@ public void close() {
 		}
 	}
 
+	@Test
+	public void validationAutoConfigurationShouldConfigureDefaultValidator() {
+		load(Config.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(springValidatorNames).containsExactly(""defaultValidator"");
+		Validator jsrValidator = this.context.getBean(Validator.class);
+		org.springframework.validation.Validator springValidator = this.context
+				.getBean(org.springframework.validation.Validator.class);
+		assertThat(jsrValidator).isInstanceOf(LocalValidatorFactoryBean.class);
+		assertThat(jsrValidator).isEqualTo(springValidator);
+		assertThat(isPrimaryBean(""defaultValidator"")).isTrue();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesValidatorShouldBackOff() {
+		load(UserDefinedValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""customValidator"");
+		assertThat(springValidatorNames).containsExactly(""customValidator"");
+		org.springframework.validation.Validator springValidator = this.context
+				.getBean(org.springframework.validation.Validator.class);
+		Validator jsrValidator = this.context.getBean(Validator.class);
+		assertThat(jsrValidator).isInstanceOf(OptionalValidatorFactoryBean.class);
+		assertThat(jsrValidator).isEqualTo(springValidator);
+		assertThat(isPrimaryBean(""customValidator"")).isFalse();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesDefaultValidatorShouldNotEnablePrimary() {
+		load(UserDefinedDefaultValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(springValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(isPrimaryBean(""defaultValidator"")).isFalse();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesJsrValidatorShouldBackOff() {
+		load(UserDefinedJsrValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""customValidator"");
+		assertThat(springValidatorNames).isEmpty();
+		assertThat(isPrimaryBean(""customValidator"")).isFalse();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesSpringValidatorShouldCreateJsrValidator() {
+		load(UserDefinedSpringValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(springValidatorNames).containsExactly(
+				""customValidator"", ""anotherCustomValidator"", ""defaultValidator"");
+		Validator jsrValidator = this.context.getBean(Validator.class);
+		org.springframework.validation.Validator springValidator = this.context
+				.getBean(org.springframework.validation.Validator.class);
+		assertThat(jsrValidator).isInstanceOf(LocalValidatorFactoryBean.class);
+		assertThat(jsrValidator).isEqualTo(springValidator);
+		assertThat(isPrimaryBean(""defaultValidator"")).isTrue();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesPrimarySpringValidatorShouldRemovePrimaryFlag() {
+		load(UserDefinedPrimarySpringValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(springValidatorNames).containsExactly(
+				""customValidator"", ""anotherCustomValidator"", ""defaultValidator"");
+		Validator jsrValidator = this.context.getBean(Validator.class);
+		org.springframework.validation.Validator springValidator = this.context
+				.getBean(org.springframework.validation.Validator.class);
+		assertThat(jsrValidator).isInstanceOf(LocalValidatorFactoryBean.class);
+		assertThat(springValidator).isEqualTo(
+				this.context.getBean(""anotherCustomValidator""));
+		assertThat(isPrimaryBean(""defaultValidator"")).isFalse();
+	}
+
 	@Test
 	public void validationIsEnabled() {
 		load(SampleService.class);
@@ -104,7 +198,11 @@ public void userDefinedMethodValidationPostProcessorTakesPrecedence() {
 						.getPropertyValue(""validator""));
 	}
 
-	public void load(Class<?> config, String... environment) {
+	private boolean isPrimaryBean(String beanName) {
+		return this.context.getBeanDefinition(beanName).isPrimary();
+	}
+
+	private void load(Class<?> config, String... environment) {
 		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
 		EnvironmentTestUtils.addEnvironment(ctx, environment);
 		if (config != null) {
@@ -115,6 +213,72 @@ public void load(Class<?> config, String... environment) {
 		this.context = ctx;
 	}
 
+	@Configuration
+	static class Config {
+
+	}
+
+	@Configuration
+	static class UserDefinedValidatorConfig {
+
+		@Bean
+		public OptionalValidatorFactoryBean customValidator() {
+			return new OptionalValidatorFactoryBean();
+		}
+
+	}
+
+	@Configuration
+	static class UserDefinedDefaultValidatorConfig {
+
+		@Bean
+		public OptionalValidatorFactoryBean defaultValidator() {
+			return new OptionalValidatorFactoryBean();
+		}
+
+	}
+
+	@Configuration
+	static class UserDefinedJsrValidatorConfig {
+
+		@Bean
+		public Validator customValidator() {
+			return mock(Validator.class);
+		}
+
+	}
+
+	@Configuration
+	static class UserDefinedSpringValidatorConfig {
+
+		@Bean
+		public org.springframework.validation.Validator customValidator() {
+			return mock(org.springframework.validation.Validator.class);
+		}
+
+		@Bean
+		public org.springframework.validation.Validator anotherCustomValidator() {
+			return mock(org.springframework.validation.Validator.class);
+		}
+
+	}
+
+	@Configuration
+	static class UserDefinedPrimarySpringValidatorConfig {
+
+		@Bean
+		public org.springframework.validation.Validator customValidator() {
+			return mock(org.springframework.validation.Validator.class);
+		}
+
+		@Bean
+		@Primary
+		public org.springframework.validation.Validator anotherCustomValidator() {
+			return mock(org.springframework.validation.Validator.class);
+		}
+
+	}
+
 	@Validated
 	static class SampleService {
 
@@ -39,6 +39,7 @@
 import org.springframework.beans.DirectFieldAccessor;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
 import org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration;
+import org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration;
 import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter;
 import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration.WelcomePageHandlerMapping;
 import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
@@ -59,6 +60,7 @@
 import org.springframework.test.util.ReflectionTestUtils;
 import org.springframework.test.web.servlet.MockMvc;
 import org.springframework.test.web.servlet.setup.MockMvcBuilders;
+import org.springframework.util.ObjectUtils;
 import org.springframework.util.ReflectionUtils;
 import org.springframework.util.StringUtils;
 import org.springframework.validation.Validator;
@@ -655,77 +657,126 @@ public boolean matches(Object value) {
 	}
 
 	@Test
-	public void validationNoJsr303ValidatorExposedByDefault() {
-		load();
+	public void validatorWhenNoValidatorShouldUseDefault() {
+		load(null, new Class<?>[] { ValidationAutoConfiguration.class });
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).isEmpty();
 		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
 				.isEmpty();
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(1);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(springValidatorBeans).containsExactly(""mvcValidator"");
 	}
 
 	@Test
-	public void validationCustomConfigurerTakesPrecedence() {
-		load(MvcValidator.class);
+	public void validatorWhenNoCustomizationShouldUseAutoConfigured() {
+		load();
+		String[] jsrValidatorBeans = this.context
+				.getBeanNamesForType(javax.validation.Validator.class);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(jsrValidatorBeans).containsExactly(""defaultValidator"");
+		assertThat(springValidatorBeans).containsExactly(""defaultValidator"", ""mvcValidator"");
+		Validator validator = this.context.getBean(""mvcValidator"", Validator.class);
+		assertThat(validator).isInstanceOf(WebMvcValidator.class);
+		Object defaultValidator = this.context.getBean(""defaultValidator"");
+		assertThat(((WebMvcValidator) validator).getTarget()).isSameAs(defaultValidator);
+		// Primary Spring validator is the one use by MVC behind the scenes
+		assertThat(this.context.getBean(Validator.class)).isEqualTo(defaultValidator);
+	}
+
+	@Test
+	public void validatorWithConfigurerShouldUseSpringValidator() {
+		load(MvcValidator.class, new Class<?>[] { ValidationAutoConfiguration.class });
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).isEmpty();
 		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
 				.isEmpty();
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(1);
-		Validator validator = this.context.getBean(Validator.class);
-		assertThat(validator)
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(springValidatorBeans).containsExactly(""mvcValidator"");
+		assertThat(this.context.getBean(""mvcValidator""))
 				.isSameAs(this.context.getBean(MvcValidator.class).validator);
 	}
 
 	@Test
-	public void validationCustomConfigurerTakesPrecedenceAndDoNotExposeJsr303() {
-		load(MvcJsr303Validator.class);
+	public void validatorWithConfigurerDoesNotExposeJsr303() {
+		load(MvcJsr303Validator.class, new Class<?>[] { ValidationAutoConfiguration.class });
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).isEmpty();
 		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
 				.isEmpty();
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(1);
-		Validator validator = this.context.getBean(Validator.class);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(springValidatorBeans).containsExactly(""mvcValidator"");
+		Validator validator = this.context.getBean(""mvcValidator"", Validator.class);
 		assertThat(validator).isInstanceOf(WebMvcValidator.class);
 		assertThat(((WebMvcValidator) validator).getTarget())
 				.isSameAs(this.context.getBean(MvcJsr303Validator.class).validator);
 	}
 
 	@Test
-	public void validationJsr303CustomValidatorReusedAsSpringValidator() {
-		load(CustomValidator.class);
+	public void validatorWithConfigurerTakesPrecedence() {
+		load(MvcValidator.class);
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).hasSize(1);
 		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
 				.hasSize(1);
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(2);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(springValidatorBeans).containsExactly(""defaultValidator"", ""mvcValidator"");
+		assertThat(this.context.getBean(""mvcValidator""))
+				.isSameAs(this.context.getBean(MvcValidator.class).validator);
+		// Primary Spring validator is the auto-configured one as the MVC one has been
+		// customized via a WebMvcConfigurer
+		assertThat(this.context.getBean(Validator.class))
+				.isEqualTo(this.context.getBean(""defaultValidator""));
+	}
+
+	@Test
+	public void validatorWithCustomSpringValidatorIgnored() {
+		load(CustomSpringValidator.class);
+		String[] jsrValidatorBeans = this.context
+				.getBeanNamesForType(javax.validation.Validator.class);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(jsrValidatorBeans).containsExactly(""defaultValidator"");
+		assertThat(springValidatorBeans).containsExactly(
+				""customSpringValidator"", ""defaultValidator"", ""mvcValidator"");
 		Validator validator = this.context.getBean(""mvcValidator"", Validator.class);
 		assertThat(validator).isInstanceOf(WebMvcValidator.class);
+		Object defaultValidator = this.context.getBean(""defaultValidator"");
 		assertThat(((WebMvcValidator) validator).getTarget())
-				.isSameAs(this.context.getBean(javax.validation.Validator.class));
+				.isSameAs(defaultValidator);
+		// Primary Spring validator is the one use by MVC behind the scenes
+		assertThat(this.context.getBean(Validator.class)).isEqualTo(defaultValidator);
 	}
 
 	@Test
-	public void validationJsr303ValidatorExposedAsSpringValidator() {
-		load(Jsr303Validator.class);
+	public void validatorWithCustomJsr303ValidatorExposedAsSpringValidator() {
+		load(CustomJsr303Validator.class);
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).isEmpty();
-		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
-				.hasSize(1);
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(1);
+		String[] jsrValidatorBeans = this.context
+				.getBeanNamesForType(javax.validation.Validator.class);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(jsrValidatorBeans).containsExactly(""customJsr303Validator"");
+		assertThat(springValidatorBeans).containsExactly(""mvcValidator"");
 		Validator validator = this.context.getBean(Validator.class);
 		assertThat(validator).isInstanceOf(WebMvcValidator.class);
 		SpringValidatorAdapter target = ((WebMvcValidator) validator)
 				.getTarget();
 		assertThat(new DirectFieldAccessor(target).getPropertyValue(""targetValidator""))
-				.isSameAs(this.context.getBean(javax.validation.Validator.class));
+				.isSameAs(this.context.getBean(""customJsr303Validator""));
 	}
 
 	private void load(Class<?> config, String... environment) {
+		load(config, null, environment);
+	}
+
+	private void load(Class<?> config, Class<?>[] exclude, String... environment) {
 		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
 		EnvironmentTestUtils.addEnvironment(this.context, environment);
 		List<Class<?>> configClasses = new ArrayList<Class<?>>();
 		if (config != null) {
 			configClasses.add(config);
 		}
-		configClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,
+		configClasses.addAll(Arrays.asList(Config.class,
+				ValidationAutoConfiguration.class, WebMvcAutoConfiguration.class,
 				HttpMessageConvertersAutoConfiguration.class,
 				PropertyPlaceholderAutoConfiguration.class));
+		if (!ObjectUtils.isEmpty(exclude)) {
+			configClasses.removeAll(Arrays.asList(exclude));
+		}
 		this.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));
 		this.context.refresh();
 	}
@@ -919,21 +970,21 @@ public Validator getValidator() {
 	}
 
 	@Configuration
-	static class Jsr303Validator {
+	static class CustomJsr303Validator {
 
 		@Bean
-		public javax.validation.Validator jsr303Validator() {
+		public javax.validation.Validator customJsr303Validator() {
 			return mock(javax.validation.Validator.class);
 		}
 
 	}
 
 	@Configuration
-	static class CustomValidator {
+	static class CustomSpringValidator {
 
 		@Bean
-		public Validator customValidator() {
-			return new LocalValidatorFactoryBean();
+		public Validator customSpringValidator() {
+			return mock(Validator.class);
 		}
 
 	}
"
https://github.com/spring-projects/spring-boot/commit/05e6af23cf2e60d5c61388fbb954bd56f00b9f94,Prepend without replacing in HttpMessageConverters  <enter> It was incorrect to simply replace existing instances because you can't tell from the instance which media types and java types it supports. This fix just prepends the custom converters so they get higher priority. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/05e6af23cf2e60d5c61388fbb954bd56f00b9f94,"@@ -75,15 +75,7 @@ public HttpMessageConverters(HttpMessageConverter<?>... additionalConverters) {
 	public HttpMessageConverters(Collection<HttpMessageConverter<?>> additionalConverters) {
 		List<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>();
 		List<HttpMessageConverter<?>> defaultConverters = getDefaultConverters();
-		for (HttpMessageConverter<?> converter : additionalConverters) {
-			int defaultConverterIndex = indexOfItemClass(defaultConverters, converter);
-			if (defaultConverterIndex == -1) {
-				converters.add(converter);
-			}
-			else {
-				defaultConverters.set(defaultConverterIndex, converter);
-			}
-		}
+		converters.addAll(additionalConverters);
 		converters.addAll(defaultConverters);
 		this.converters = Collections.unmodifiableList(converters);
 	}
@@ -120,16 +112,6 @@ private void reorderXmlConvertersToEnd(List<HttpMessageConverter<?>> converters)
 		converters.addAll(xml);
 	}
 
-	private <E> int indexOfItemClass(List<E> list, E item) {
-		Class<? extends Object> itemClass = item.getClass();
-		for (int i = 0; i < list.size(); i++) {
-			if (list.get(i).getClass().isAssignableFrom(itemClass)) {
-				return i;
-			}
-		}
-		return -1;
-	}
-
 	@Override
 	public Iterator<HttpMessageConverter<?>> iterator() {
 		return getConverters().iterator();
@@ -69,6 +69,15 @@ public void overrideExistingConverter() {
 		MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
 		HttpMessageConverters converters = new HttpMessageConverters(converter);
 		assertTrue(converters.getConverters().contains(converter));
+		int count = 0;
+		for (HttpMessageConverter<?> httpMessageConverter : converters) {
+			if (httpMessageConverter instanceof MappingJackson2HttpMessageConverter) {
+				count++;
+			}
+		}
+		// The existing converter is still there, but with a lower priority
+		assertEquals(2, count);
+		assertEquals(0, converters.getConverters().indexOf(converter));
 	}
 
 	@Test
"
https://github.com/square/retrofit/commit/238a9e59e69d61479a4505dba5f5659a599c699f,"Doc error. `@QueryMap` with `encoded=true` will stop default url encoding. So, calling with `foo.list(ImmutableMap.of('foo', 'foo+bar'))` yields '/search?foo=foo+bar' instead of '/search?foo=foo%2Bbar'. ",https://api.github.com/repos/square/retrofit/commits/238a9e59e69d61479a4505dba5f5659a599c699f,"@@ -43,8 +43,8 @@
  * &#64;GET(""/search"")
  * Call&lt;ResponseBody> list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
  * }</pre>
- * Calling with {@code foo.list(ImmutableMap.of(""foo"", ""foo+foo""))} yields
- * {@code /search?foo=foo%2Bbar}.
+ * Calling with {@code foo.list(ImmutableMap.of(""foo"", ""foo+bar""))} yields
+ * {@code /search?foo=foo+bar}.
  *
  * @see Query
  */
"
https://github.com/square/retrofit/commit/f4ee9e28a6380662ea0ab8a9a02adbd021ef55e8,Added more tests for RxJava Single type support  <enter> Single.toBlocking() is present since RxJava 1.0.16 version. ,https://api.github.com/repos/square/retrofit/commits/f4ee9e28a6380662ea0ab8a9a02adbd021ef55e8,"@@ -54,7 +54,7 @@
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.14</rxjava.version>
+    <rxjava.version>1.1.0</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.4</gson.version>
@@ -32,10 +32,10 @@
 import rx.Observable;
 import rx.Single;
 import rx.observables.BlockingObservable;
+import rx.singles.BlockingSingle;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
 public final class RxJavaCallAdapterFactoryTest {
@@ -236,11 +236,97 @@ interface Service {
     }
   }
 
-  @Test public void single() {
-    // TODO Better tests here. Why is there no toBlocking() on Single?
-    assertNotNull(service.singleBody());
-    assertNotNull(service.singleResponse());
-    assertNotNull(service.singleResult());
+  @Test public void singleBodySuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingSingle<String> o = service.singleBody().toBlocking();
+    assertThat(o.value()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleBodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingSingle<String> o = service.singleBody().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 OK"");
+    }
+  }
+
+  @Test public void singleBodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<String> o = service.singleBody().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void singleResponseSuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
+    Response<String> response = o.value();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleResponseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+
+    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
+    Response<String> response = o.value();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleResponseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException t) {
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void singleResultSuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleResultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+
+    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleResultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
   }
 
   static class StringConverterFactory extends Converter.Factory {
"
https://github.com/spring-projects/spring-boot/commit/09200361defde95ec48bd9169ab5db7590c9440b,"Align expectations of various JMX configurations  <enter> They all want to create an MBeanServer and when that happens user sees no MBeans, or sometimes just one set (Spring Core, Spring Integration or Spring Boot). To harmonise them we create a  @bean  of type MBeanServer and link to it in the other autoconfigs <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/09200361defde95ec48bd9169ab5db7590c9440b,"@@ -16,12 +16,15 @@
 
 package org.springframework.boot.actuate.autoconfigure;
 
+import javax.management.MBeanServer;
+
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.actuate.endpoint.Endpoint;
 import org.springframework.boot.actuate.endpoint.jmx.EndpointMBeanExporter;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
+import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -35,21 +38,22 @@
  */
 @Configuration
 @ConditionalOnExpression(""${endpoints.jmx.enabled:true} && ${spring.jmx.enabled:true}"")
-@AutoConfigureAfter({ EndpointAutoConfiguration.class })
+@AutoConfigureAfter({ EndpointAutoConfiguration.class, JmxAutoConfiguration.class })
 @EnableConfigurationProperties(EndpointMBeanExportProperties.class)
 public class EndpointMBeanExportAutoConfiguration {
 
 	@Autowired
 	EndpointMBeanExportProperties properties = new EndpointMBeanExportProperties();
 
 	@Bean
-	public EndpointMBeanExporter endpointMBeanExporter() {
+	public EndpointMBeanExporter endpointMBeanExporter(MBeanServer server) {
 		EndpointMBeanExporter mbeanExporter = new EndpointMBeanExporter();
 
 		String domain = this.properties.getDomain();
 		if (StringUtils.hasText(domain)) {
 			mbeanExporter.setDomain(domain);
 		}
+		mbeanExporter.setServer(server);
 
 		mbeanExporter.setEnsureUniqueRuntimeObjectNames(this.properties.isUniqueNames());
 		mbeanExporter.setObjectNameStaticProperties(this.properties.getStaticNames());
@@ -26,6 +26,7 @@
 import org.junit.Test;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
 import org.springframework.boot.actuate.endpoint.jmx.EndpointMBeanExporter;
+import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Configuration;
@@ -56,7 +57,8 @@ public void close() {
 	@Test
 	public void testEndpointMBeanExporterIsInstalled() {
 		this.context = new AnnotationConfigApplicationContext();
-		this.context.register(TestConfiguration.class, EndpointAutoConfiguration.class,
+		this.context.register(TestConfiguration.class, JmxAutoConfiguration.class,
+				EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 		this.context.refresh();
 		assertNotNull(this.context.getBean(EndpointMBeanExporter.class));
@@ -68,7 +70,8 @@ public void testEndpointMBeanExporterIsNotInstalled() {
 		environment.setProperty(""endpoints.jmx.enabled"", ""false"");
 		this.context = new AnnotationConfigApplicationContext();
 		this.context.setEnvironment(environment);
-		this.context.register(EndpointAutoConfiguration.class,
+		this.context.register(JmxAutoConfiguration.class,
+				EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 		this.context.refresh();
 		this.context.getBean(EndpointMBeanExporter.class);
@@ -84,7 +87,8 @@ public void testEndpointMBeanExporterWithProperties() throws IntrospectionExcept
 		environment.setProperty(""endpoints.jmx.static_names"", ""key1=value1, key2=value2"");
 		this.context = new AnnotationConfigApplicationContext();
 		this.context.setEnvironment(environment);
-		this.context.register(EndpointAutoConfiguration.class,
+		this.context.register(JmxAutoConfiguration.class,
+				EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 		this.context.refresh();
 		this.context.getBean(EndpointMBeanExporter.class);
@@ -101,11 +105,12 @@ public void testEndpointMBeanExporterWithProperties() throws IntrospectionExcept
 	public void testEndpointMBeanExporterInParentChild() throws IntrospectionException,
 			InstanceNotFoundException, MalformedObjectNameException, ReflectionException {
 		this.context = new AnnotationConfigApplicationContext();
-		this.context.register(EndpointAutoConfiguration.class,
+		this.context.register(JmxAutoConfiguration.class,
+				EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 
 		AnnotationConfigApplicationContext parent = new AnnotationConfigApplicationContext();
-		parent.register(EndpointAutoConfiguration.class,
+		parent.register(JmxAutoConfiguration.class, EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 		this.context.setParent(parent);
 
@@ -136,6 +136,11 @@
 			<artifactId>spring-integration-core</artifactId>
 			<optional>true</optional>
 		</dependency>
+		<dependency>
+			<groupId>org.springframework.integration</groupId>
+			<artifactId>spring-integration-jmx</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>org.springframework</groupId>
 			<artifactId>spring-jms</artifactId>
@@ -16,24 +16,40 @@
 
 package org.springframework.boot.autoconfigure.integration;
 
+import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.integration.config.EnableIntegration;
+import org.springframework.integration.jmx.config.EnableIntegrationMBeanExport;
+import org.springframework.integration.jmx.config.IntegrationMBeanExportConfiguration;
 
 /**
  * {@link org.springframework.boot.autoconfigure.EnableAutoConfiguration
  * Auto-configuration} for Spring Integration.
  * 
  * @author Artem Bilan
+ * @author Dave Syer
  * @since 1.1
  */
 @Configuration
 @ConditionalOnClass(EnableIntegration.class)
+@AutoConfigureAfter(JmxAutoConfiguration.class)
 public class IntegrationAutoConfiguration {
 
 	@Configuration
 	@EnableIntegration
 	protected static class IntegrationConfiguration {
 	}
 
+	@Configuration
+	@ConditionalOnClass(EnableIntegrationMBeanExport.class)
+	@ConditionalOnMissingBean(IntegrationMBeanExportConfiguration.class)
+	@ConditionalOnExpression(""${spring.jmx.enabled:true}"")
+	@EnableIntegrationMBeanExport(defaultDomain = ""${spring.jmx.default_domain:}"", server = ""${spring.jmx.server:mbeanServer}"")
+	protected static class IntegrationJmxConfiguration {
+	}
+
 }
@@ -16,13 +16,17 @@
 
 package org.springframework.boot.autoconfigure.jmx;
 
+import javax.management.MBeanServer;
+
 import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.EnableMBeanExport;
 import org.springframework.jmx.export.MBeanExporter;
+import org.springframework.jmx.support.MBeanServerFactoryBean;
 
 /**
  * {@link EnableAutoConfiguration Auto-configuration} to enable/disable Spring's
@@ -34,14 +38,21 @@
  */
 @Configuration
 @ConditionalOnClass({ MBeanExporter.class })
-@ConditionalOnMissingBean({ MBeanExporter.class })
 @ConditionalOnExpression(""${spring.jmx.enabled:true}"")
 public class JmxAutoConfiguration {
 
 	@Configuration
-	@EnableMBeanExport(defaultDomain = ""${spring.jmx.default_domain:}"", server = ""${spring.jmx.server:}"")
+	@ConditionalOnMissingBean({ MBeanExporter.class })
+	@EnableMBeanExport(defaultDomain = ""${spring.jmx.default_domain:}"", server = ""${spring.jmx.server:mbeanServer}"")
 	public static class MBeanExport {
+	}
 
+	@Bean
+	@ConditionalOnMissingBean(MBeanServer.class)
+	public MBeanServerFactoryBean mbeanServer() {
+		MBeanServerFactoryBean factory = new MBeanServerFactoryBean();
+		factory.setLocateExistingServerIfPossible(true);
+		return factory;
 	}
 
 }
@@ -17,6 +17,7 @@
 package org.springframework.boot.autoconfigure.integration;
 
 import org.junit.Test;
+import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.integration.support.channel.HeaderChannelRegistry;
 
@@ -32,7 +33,8 @@ public class IntegrationAutoConfigurationTests {
 
 	@Test
 	public void integrationIsAvailable() {
-		this.context.register(IntegrationAutoConfiguration.class);
+		this.context.register(JmxAutoConfiguration.class,
+				IntegrationAutoConfiguration.class);
 		this.context.refresh();
 		assertNotNull(this.context.getBean(HeaderChannelRegistry.class));
 		this.context.close();
@@ -1688,6 +1688,17 @@ infrastructure to receive messages asynchronously. Spring AMQP provides a simila
 feature set for the ``Advanced Message Queuing Protocol'' and Boot also provides
 auto-configuration options for `RabbitTemplate` and RabbitMQ.
 
+[[boot-features-messaging]]
+== Spring Integration
+
+Spring Integration provides abstractions over messaging and also other 
+transports such as HTTP, TCP etc. If Spring Integration is available
+on your classpath it will be initialized through the `@EnableIntegration`
+annotation. Message processing statistics will be published over JMX if
+``spring-integration-jmx'' is also on the classpath. 
+See the {sc-spring-boot-autoconfigure}/integration/IntegrationAutoConfiguration.{sc-ext}[`IntegrationAutoConfiguration`]
+class for more details.
+
 [[boot-features-jms]]
 == JMS
 
@@ -1792,6 +1803,17 @@ into your own beans:
 	}
 ----
 
+[[boot-features-jmx]]
+== Monitoring and management over JMX
+
+Java Management Extensions (JMX) provide a standard mechanism to
+monitor and manage applications. By default Spring Boot will create an
+`MBeanServer` with bean id ""mbeanServer"" and expose any of your beans
+that are annotated with Spring JMX annotations (`@ManagedResource`,
+`@ManagedAttribute`, `@ManagedOperation`).
+
+See the {sc-spring-boot-autoconfigure}/jmx/JmxAutoConfiguration.{sc-ext}[`JmxAutoConfiguration`]
+class for more details.
 
 [[boot-features-testing]]
 == Testing
@@ -23,6 +23,10 @@
 			<groupId>org.springframework.boot</groupId>
 			<artifactId>spring-boot-starter-integration</artifactId>
 		</dependency>
+		<dependency>
+			<groupId>org.springframework.integration</groupId>
+			<artifactId>spring-integration-jmx</artifactId>
+		</dependency>
 		<dependency>
 			<groupId>org.springframework.boot</groupId>
 			<artifactId>spring-boot-starter-test</artifactId>
@@ -1,2 +1,3 @@
 logging.file: /tmp/logs/app.log
-service.greeting: Hello
\ No newline at end of file
+service.greeting: Hello
+debug: true
\ No newline at end of file
"
https://github.com/spring-projects/spring-boot/commit/2516dc033f909281702dfd2f99e8d0f05d59af8b,"Fix documentation example  <enter> Previously, the nested private static class would cause an error at startup stating that it was not accessible when trying to bind the property from the environment. The nested class should be public. <enter>  Closes   <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/2516dc033f909281702dfd2f99e8d0f05d59af8b,"@@ -813,7 +813,7 @@ as `@Valid` to trigger its validation. For example, building upon the above
 
 		// ... getters and setters
 
-		private static class RemoteAddress {
+		public static class RemoteAddress {
 
 			@NotEmpty
 			public String hostname;
"
https://github.com/apache/dubbo/commit/fa157deadf65d00c9884d611430ec78e585840ff,Refactor: remove NetUtils.getHostAddress() and relace it with NetUtils.getLocalHost() ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/fa157deadf65d00c9884d611430ec78e585840ff,"@@ -31,7 +31,7 @@ public class ConsumerContextClusterInterceptor implements ClusterInterceptor, Cl
     public void before(AbstractClusterInvoker<?> invoker, Invocation invocation) {
         RpcContext.getContext()
                 .setInvocation(invocation)
-                .setLocalAddress(NetUtils.getHostAddress(), 0);
+                .setLocalAddress(NetUtils.getLocalHost(), 0);
         if (invocation instanceof RpcInvocation) {
             ((RpcInvocation) invocation).setInvoker(invoker);
         }
@@ -139,12 +139,12 @@ static boolean isValidV4Address(InetAddress address) {
         if (address == null || address.isLoopbackAddress()) {
             return false;
         }
+
         String name = address.getHostAddress();
-        boolean result = (name != null
+        return (name != null
                 && IP_PATTERN.matcher(name).matches()
                 && !ANYHOST_VALUE.equals(name)
                 && !LOCALHOST_VALUE.equals(name));
-        return result;
     }
 
     /**
@@ -186,18 +186,16 @@ static InetAddress normalizeV6Address(Inet6Address address) {
 
     private static volatile String HOST_ADDRESS;
 
-    public static String getHostAddress () {
+    public static String getLocalHost() {
         if (HOST_ADDRESS != null) {
             return HOST_ADDRESS;
         }
 
-        HOST_ADDRESS = getLocalHost();
-        return HOST_ADDRESS;
-    }
-
-    public static String getLocalHost() {
         InetAddress address = getLocalAddress();
-        return address == null ? LOCALHOST_VALUE : address.getHostAddress();
+        if (address != null) {
+            return HOST_ADDRESS = address.getHostAddress();
+        }
+        return LOCALHOST_VALUE;
     }
 
     public static String filterLocalHost(String host) {
@@ -287,7 +285,7 @@ private static InetAddress getLocalAddress0() {
                             Optional<InetAddress> addressOp = toValidAddress(addresses.nextElement());
                             if (addressOp.isPresent()) {
                                 try {
-                                    if(addressOp.get().isReachable(100)){
+                                    if (addressOp.get().isReachable(100)) {
                                         return addressOp.get();
                                     }
                                 } catch (IOException e) {
@@ -387,7 +385,7 @@ public static void setInterface(MulticastSocket multicastSocket, boolean preferI
                 InetAddress address = (InetAddress) addresses.nextElement();
                 if (preferIpv6 && address instanceof Inet6Address) {
                     try {
-                        if(address.isReachable(100)){
+                        if (address.isReachable(100)) {
                             multicastSocket.setInterface(address);
                             interfaceSet = true;
                             break;
@@ -397,7 +395,7 @@ public static void setInterface(MulticastSocket multicastSocket, boolean preferI
                     }
                 } else if (!preferIpv6 && address instanceof Inet4Address) {
                     try {
-                        if(address.isReachable(100)){
+                        if (address.isReachable(100)) {
                             multicastSocket.setInterface(address);
                             interfaceSet = true;
                             break;
@@ -300,4 +300,11 @@ public void testMatchIpv4WithIpPort() throws UnknownHostException {
         assertFalse(NetUtils.matchIpRange(""192.168.1.1-61:90"", ""192.168.1.62"", 90));
         assertFalse(NetUtils.matchIpRange(""192.168.1.62:90"", ""192.168.1.63"", 90));
     }
+
+    @Test
+    public void testLocalHost() {
+        assertEquals(NetUtils.getLocalHost(), NetUtils.getLocalAddress().getHostAddress());
+        assertTrue(NetUtils.isValidLocalHost(NetUtils.getLocalHost()));
+        assertFalse(NetUtils.isInvalidLocalHost(NetUtils.getLocalHost()));
+    }
 }
"
https://github.com/apache/dubbo/commit/f9f10ba5225e80c34953f56123ac1702c13e45c7,"In order to facilitate the consumer to better locate the failure of provider token check, the token value called by consumer will be printed out in the exception information ( <pr_link> ) ",https://api.github.com/repos/apache/dubbo/commits/f9f10ba5225e80c34953f56123ac1702c13e45c7,"@@ -48,7 +48,9 @@ public Result invoke(Invoker<?> invoker, Invocation inv)
             Map<String, Object> attachments = inv.getObjectAttachments();
             String remoteToken = (attachments == null ? null : (String) attachments.get(TOKEN_KEY));
             if (!token.equals(remoteToken)) {
-                throw new RpcException(""Invalid token! Forbid invoke remote service "" + serviceType + "" method "" + inv.getMethodName() + ""() from consumer "" + RpcContext.getContext().getRemoteHost() + "" to provider "" + RpcContext.getContext().getLocalHost());
+                throw new RpcException(""Invalid token! Forbid invoke remote service "" + serviceType + "" method "" + inv.getMethodName()
+                        + ""() from consumer "" + RpcContext.getContext().getRemoteHost() + "" to provider "" + RpcContext.getContext().getLocalHost()
+                        + "", consumer incorrect token is "" + remoteToken);
             }
         }
         return invoker.invoke(inv);
"
https://github.com/square/okhttp/commit/bffee2336725dde0f74933d5a7d12536c9bcbd06,"Introduce intermediate storage for frame contents.  <enter> This eliminates the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. Now, we only emit bytes once Okio reports complete segments. ",https://api.github.com/repos/square/okhttp/commits/bffee2336725dde0f74933d5a7d12536c9bcbd06,"@@ -246,13 +246,6 @@ public final class RealWebSocketTest {
         client.readMessage();
         clientListener.assertClose(1000, ""Hello!"");
 
-        try {
-          sink.writeUtf8(""lo!"").emit(); // No writing to the underlying sink.
-          fail();
-        } catch (IOException e) {
-          assertEquals(""closed"", e.getMessage());
-          sink.buffer().clear();
-        }
         try {
           sink.flush(); // No flushing.
           fail();
@@ -320,7 +313,7 @@ public final class RealWebSocketTest {
     clientListener.assertClose(1000, ""Bye!"");
   }
 
-  @Test public void protocolErrorBeforeCloseSendsClose() {
+  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
     server2client.write(ByteString.decodeHex(""0a00"")); // Invalid non-final ping frame.
 
     client.readMessage(); // Detects error, send close.
@@ -31,6 +31,8 @@
 
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -71,15 +73,30 @@ public final class WebSocketWriterTest {
     assertData(""8000"");
   }
 
-  @Test public void serverCloseFlushes() throws IOException {
+  @Test public void closeFlushes() throws IOException {
     BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT));
 
     sink.writeUtf8(""Hel"").flush();
     assertData(""010348656c"");
 
     sink.writeUtf8(""lo"").close();
-    assertData(""00026c6f"");
-    assertData(""8000"");
+    assertData(""80026c6f"");
+  }
+
+  @Test public void noWritesAfterClose() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT);
+
+    sink.close();
+    assertData(""8100"");
+
+    Buffer payload = new Buffer().writeUtf8(""Hello"");
+    try {
+      // Write to the unbuffered sink as BufferedSink keeps its own closed state.
+      sink.write(payload, payload.size());
+      fail();
+    } catch (IOException e) {
+      assertEquals(""closed"", e.getMessage());
+    }
   }
 
   @Test public void clientTextMessage() throws IOException {
@@ -96,39 +113,55 @@ public final class WebSocketWriterTest {
   }
 
   @Test public void serverBinaryMessage() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY));
 
-    sink.write(binaryData(50), 50);
+    sink.write(binaryData(50)).flush();
     assertData(""0232"");
-    assertData(binaryData(50).readByteArray());
+    assertData(binaryData(50));
 
-    sink.write(binaryData(50), 50);
+    sink.write(binaryData(50)).flush();
     assertData(""0032"");
-    assertData(binaryData(50).readByteArray());
+    assertData(binaryData(50));
 
     sink.close();
     assertData(""8000"");
   }
 
-  @Test public void serverBinaryMessageLengthShort() throws IOException {
+  @Test public void serverMessageLengthShort() throws IOException {
     Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
 
-    int length = 0xffff;
-    sink.write(binaryData(length), length);
-    assertData(""027effff"");
-    assertData(binaryData(length).readByteArray());
+    // Create a payload which will overflow the normal payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData(""027e""); // 'e' == 4-byte follow-up length.
+    assertData(String.format(""%04X"", payload.completeSegmentByteCount()));
+    assertData(payload.readByteArray());
 
     sink.close();
     assertData(""8000"");
   }
 
-  @Test public void serverBinaryMessageLengthLong() throws IOException {
+  @Test public void serverMessageLengthLong() throws IOException {
     Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
 
-    int length = 65537;
-    sink.write(binaryData(length), length);
-    assertData(""027f0000000000010001"");
-    assertData(binaryData(length).readByteArray());
+    // Create a payload which will overflow the normal and short payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData(""027f""); // 'f' == 16-byte follow-up length.
+    assertData(String.format(""%016X"", byteCount));
+    assertData(payload.readByteArray(byteCount));
 
     sink.close();
     assertData(""8000"");
@@ -139,30 +172,24 @@ public final class WebSocketWriterTest {
     random.nextBytes(maskKey1);
     byte[] maskKey2 = new byte[4];
     random.nextBytes(maskKey2);
-    byte[] maskKey3 = new byte[4];
-    random.nextBytes(maskKey3);
 
     random.setSeed(0); // Reset the seed so real data matches.
 
-    Sink sink = clientWriter.newMessageSink(OPCODE_BINARY);
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY));
 
-    sink.write(binaryData(50), 50);
-    byte[] part1 = binaryData(50).readByteArray();
+    byte[] part1 = binaryData(50);
+    sink.write(part1).flush();
     toggleMask(part1, 50, maskKey1, 0);
     assertData(""02b2"");
     assertData(maskKey1);
     assertData(part1);
 
-    sink.write(binaryData(50), 50);
-    byte[] part2 = binaryData(50).readByteArray();
+    byte[] part2 = binaryData(50);
+    sink.write(part2).close();
     toggleMask(part2, 50, maskKey2, 0);
-    assertData(""00b2"");
+    assertData(""80b2"");
     assertData(maskKey2);
     assertData(part2);
-
-    sink.close();
-    assertData(""8080"");
-    assertData(maskKey3);
   }
 
   @Test public void serverEmptyClose() throws IOException {
@@ -251,7 +278,7 @@ public final class WebSocketWriterTest {
 
   @Test public void pingTooLongThrows() throws IOException {
     try {
-      serverWriter.writePing(binaryData(1000));
+      serverWriter.writePing(new Buffer().write(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals(""Payload size must be less than or equal to 125"", e.getMessage());
@@ -260,7 +287,7 @@ public final class WebSocketWriterTest {
 
   @Test public void pongTooLongThrows() throws IOException {
     try {
-      serverWriter.writePong(binaryData(1000));
+      serverWriter.writePong(new Buffer().write(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals(""Payload size must be less than or equal to 125"", e.getMessage());
@@ -269,7 +296,7 @@ public final class WebSocketWriterTest {
 
   @Test public void closeTooLongThrows() throws IOException {
     try {
-      String longString = binaryData(75).readByteString().hex();
+      String longString = ByteString.of(binaryData(75)).hex();
       serverWriter.writeClose(1000, longString);
       fail();
     } catch (IllegalArgumentException e) {
@@ -303,9 +330,9 @@ private void assertData(byte[] data) throws IOException {
     }
   }
 
-  private static Buffer binaryData(int length) {
+  private static byte[] binaryData(int length) {
     byte[] junk = new byte[length];
     new Random(0).nextBytes(junk);
-    return new Buffer().write(junk);
+    return junk;
   }
 }
@@ -87,28 +87,48 @@ private Object nextEvent() {
     }
   }
 
-  public void assertTextMessage(String payload) {
+  public void assertTextMessage(String payload) throws IOException {
     Message message = new Message(TEXT);
     message.buffer.writeUtf8(payload);
-    assertEquals(message, nextEvent());
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(message, actual);
   }
 
-  public void assertBinaryMessage(byte[] payload) {
+  public void assertBinaryMessage(byte[] payload) throws IOException {
     Message message = new Message(BINARY);
     message.buffer.write(payload);
-    assertEquals(message, nextEvent());
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(message, actual);
   }
 
-  public void assertPing(Buffer payload) {
-    assertEquals(new Ping(payload), nextEvent());
+  public void assertPing(Buffer payload) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Ping(payload), actual);
   }
 
-  public void assertPong(Buffer payload) {
-    assertEquals(new Pong(payload), nextEvent());
+  public void assertPong(Buffer payload) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Pong(payload), actual);
   }
 
-  public void assertClose(int code, String reason) {
-    assertEquals(new Close(code, reason), nextEvent());
+  public void assertClose(int code, String reason) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Close(code, reason), actual);
   }
 
   public void assertFailure(Class<? extends IOException> cls, String message) {
@@ -68,14 +68,16 @@ public final class WebSocketProtocol {
   static final int OPCODE_CONTROL_PONG = 0xa;
 
   /**
-   * Maximum length of frame payload. Larger payloads, if supported, can use the special values
-   * {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
+   * Maximum length of frame payload. Larger payloads, if supported by the frame type, can use the
+   * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
-  static final int PAYLOAD_MAX = 125;
+  static final long PAYLOAD_BYTE_MAX = 125L;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
    */
   static final int PAYLOAD_SHORT = 126;
+  /** Maximum length of a frame payload to be denoted as {@link #PAYLOAD_SHORT}. */
+  static final long PAYLOAD_SHORT_MAX = 0xffffL;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
    * length.
@@ -42,7 +42,7 @@
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static java.lang.Integer.toHexString;
@@ -147,8 +147,8 @@ private void readHeader() throws IOException {
     }
     frameBytesRead = 0;
 
-    if (isControlFrame && frameLength > PAYLOAD_MAX) {
-      throw new ProtocolException(""Control frame must be less than "" + PAYLOAD_MAX + ""B."");
+    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
+      throw new ProtocolException(""Control frame must be less than "" + PAYLOAD_BYTE_MAX + ""B."");
     }
 
     if (isMasked) {
@@ -30,8 +30,9 @@
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 
 /**
@@ -44,13 +45,16 @@
  */
 public final class WebSocketWriter {
   private final boolean isClient;
-  /** Writes must be guarded by synchronizing on this instance! */
-  private final BufferedSink sink;
   private final Random random;
 
+  /** Writes must be guarded by synchronizing on 'this'. */
+  private final BufferedSink sink;
+  /** Access must be guarded by synchronizing on 'this'. */
+  private boolean writerClosed;
+
+  private final Buffer buffer = new Buffer();
   private final FrameSink frameSink = new FrameSink();
 
-  private boolean closed;
   private boolean activeWriter;
 
   private final byte[] maskKey;
@@ -70,15 +74,15 @@ public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
 
   /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
   public void writePing(Buffer payload) throws IOException {
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_PING, payload);
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
     }
   }
 
   /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
   public void writePong(Buffer payload) throws IOException {
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_PONG, payload);
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
     }
   }
 
@@ -103,21 +107,23 @@ public void writeClose(int code, String reason) throws IOException {
       }
     }
 
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
-      closed = true;
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
+      writerClosed = true;
     }
   }
 
-  private void writeControlFrame(int opcode, Buffer payload) throws IOException {
-    if (closed) throw new IOException(""closed"");
+  private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IOException {
+    assert Thread.holdsLock(this);
+
+    if (writerClosed) throw new IOException(""closed"");
 
     int length = 0;
     if (payload != null) {
       length = (int) payload.size();
-      if (length > PAYLOAD_MAX) {
+      if (length > PAYLOAD_BYTE_MAX) {
         throw new IllegalArgumentException(
-            ""Payload size must be less than or equal to "" + PAYLOAD_MAX);
+            ""Payload size must be less than or equal to "" + PAYLOAD_BYTE_MAX);
       }
     }
 
@@ -133,7 +139,7 @@ private void writeControlFrame(int opcode, Buffer payload) throws IOException {
       sink.write(maskKey);
 
       if (payload != null) {
-        writeAllMasked(payload, length);
+        writeMaskedSynchronized(payload, length);
       }
     } else {
       sink.writeByte(b1);
@@ -143,7 +149,7 @@ private void writeControlFrame(int opcode, Buffer payload) throws IOException {
       }
     }
 
-    sink.flush();
+    sink.emit();
   }
 
   /**
@@ -156,54 +162,57 @@ public Sink newMessageSink(int formatOpcode) {
     }
     activeWriter = true;
 
+    // Reset FrameSink state for a new writer.
     frameSink.formatOpcode = formatOpcode;
     frameSink.isFirstFrame = true;
+    frameSink.closed = false;
+
     return frameSink;
   }
 
-  private void writeFrame(int formatOpcode, Buffer source, long byteCount,
-      boolean isFirstFrame, boolean isFinal) throws IOException {
-    if (closed) throw new IOException(""closed"");
-
-    int opcode = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
+  private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+      boolean isFinal) throws IOException {
+    assert Thread.holdsLock(this);
 
-    synchronized (sink) {
-      int b0 = opcode;
-      if (isFinal) {
-        b0 |= B0_FLAG_FIN;
-      }
-      sink.writeByte(b0);
+    if (writerClosed) throw new IOException(""closed"");
 
-      int b1 = 0;
-      if (isClient) {
-        b1 |= B1_FLAG_MASK;
-        random.nextBytes(maskKey);
-      }
-      if (byteCount <= PAYLOAD_MAX) {
-        b1 |= (int) byteCount;
-        sink.writeByte(b1);
-      } else if (byteCount <= 0xffffL) { // Unsigned short.
-        b1 |= PAYLOAD_SHORT;
-        sink.writeByte(b1);
-        sink.writeShort((int) byteCount);
-      } else {
-        b1 |= PAYLOAD_LONG;
-        sink.writeByte(b1);
-        sink.writeLong(byteCount);
-      }
+    int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
+    if (isFinal) {
+      b0 |= B0_FLAG_FIN;
+    }
+    sink.writeByte(b0);
 
-      if (isClient) {
-        sink.write(maskKey);
-        writeAllMasked(source, byteCount);
-      } else {
-        sink.write(source, byteCount);
-      }
+    int b1 = 0;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      random.nextBytes(maskKey);
+    }
+    if (byteCount <= PAYLOAD_BYTE_MAX) {
+      b1 |= (int) byteCount;
+      sink.writeByte(b1);
+    } else if (byteCount <= PAYLOAD_SHORT_MAX) {
+      b1 |= PAYLOAD_SHORT;
+      sink.writeByte(b1);
+      sink.writeShort((int) byteCount);
+    } else {
+      b1 |= PAYLOAD_LONG;
+      sink.writeByte(b1);
+      sink.writeLong(byteCount);
+    }
 
-      sink.flush();
+    if (isClient) {
+      sink.write(maskKey);
+      writeMaskedSynchronized(buffer, byteCount);
+    } else {
+      sink.write(buffer, byteCount);
     }
+
+    sink.emit();
   }
 
-  private void writeAllMasked(BufferedSource source, long byteCount) throws IOException {
+  private void writeMaskedSynchronized(BufferedSource source, long byteCount) throws IOException {
+    assert Thread.holdsLock(this);
+
     long written = 0;
     while (written < byteCount) {
       int toRead = (int) Math.min(byteCount, maskBuffer.length);
@@ -218,18 +227,29 @@ private void writeAllMasked(BufferedSource source, long byteCount) throws IOExce
   private final class FrameSink implements Sink {
     private int formatOpcode;
     private boolean isFirstFrame;
+    private boolean closed;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
-      writeFrame(formatOpcode, source, byteCount, isFirstFrame, false /* final */);
-      isFirstFrame = false;
+      if (closed) throw new IOException(""closed"");
+
+      buffer.write(source, byteCount);
+
+      long emitCount = buffer.completeSegmentByteCount();
+      if (emitCount > 0) {
+        synchronized (WebSocketWriter.this) {
+          writeMessageFrameSynchronized(formatOpcode, emitCount, isFirstFrame, false /* final */);
+        }
+        isFirstFrame = false;
+      }
     }
 
     @Override public void flush() throws IOException {
       if (closed) throw new IOException(""closed"");
 
-      synchronized (sink) {
-        sink.flush();
+      synchronized (WebSocketWriter.this) {
+        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
       }
+      isFirstFrame = false;
     }
 
     @Override public Timeout timeout() {
@@ -240,21 +260,10 @@ private final class FrameSink implements Sink {
     @Override public void close() throws IOException {
       if (closed) throw new IOException(""closed"");
 
-      int length = 0;
-
-      synchronized (sink) {
-        sink.writeByte(B0_FLAG_FIN | OPCODE_CONTINUATION);
-
-        if (isClient) {
-          sink.writeByte(B1_FLAG_MASK | length);
-          random.nextBytes(maskKey);
-          sink.write(maskKey);
-        } else {
-          sink.writeByte(length);
-        }
-        sink.flush();
+      synchronized (WebSocketWriter.this) {
+        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
       }
-
+      closed = true;
       activeWriter = false;
     }
   }
@@ -17,10 +17,6 @@
 import static com.squareup.okhttp.ws.WebSocket.BINARY;
 import static com.squareup.okhttp.ws.WebSocket.TEXT;
 
-/**
- * NOTE: This is currently broken because the Echo server does not correctly echo empty frames
- * which OkHttp uses for final frames on streamed messages.
- */
 public final class WebSocketEcho implements WebSocketListener {
   private final Executor writeExecutor = Executors.newSingleThreadExecutor();
 
"
https://github.com/square/okhttp/commit/ba5d3e278b027ee7a2cb741a1bec3646f9d11e16,Migrate from Travis to GitHub Action for publishing ,https://api.github.com/repos/square/okhttp/commits/ba5d3e278b027ee7a2cb741a1bec3646f9d11e16,"@@ -1,26 +0,0 @@
-#!/bin/bash
-#
-# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
-#
-# Adapted from https://coderwall.com/p/9b_lfq and
-# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
-
-SLUG=""square/okhttp""
-JDK=""openjdk11""
-BRANCH=""master""
-
-set -e
-
-if [ ""$TRAVIS_REPO_SLUG"" != ""$SLUG"" ]; then
-  echo ""Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'.""
-elif [ ""$TRAVIS_JDK_VERSION"" != ""$JDK"" ]; then
-  echo ""Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'.""
-elif [ ""$TRAVIS_PULL_REQUEST"" != ""false"" ]; then
-  echo ""Skipping snapshot deployment: was pull request.""
-elif [ ""$TRAVIS_BRANCH"" != ""$BRANCH"" ]; then
-  echo ""Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.""
-else
-  echo ""Deploying snapshot...""
-  ./gradlew clean uploadArchives
-  echo ""Snapshot deployed!""
-fi
@@ -0,0 +1,29 @@
+name: build
+
+on: [push, pull_request]
+
+env:
+  GRADLE_OPTS: ""-Dorg.gradle.jvmargs=-Xmx4g -Dorg.gradle.daemon=false -Dkotlin.incremental=false""
+
+jobs:
+  publish:
+    runs-on: ubuntu-latest
+    if: github.ref == 'refs/heads/master'
+
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v2
+
+      - name: Validate Gradle Wrapper
+        uses: gradle/wrapper-validation-action@v1
+
+      - name: Configure JDK
+        uses: actions/setup-java@v1
+        with:
+          java-version: 11
+
+      - name: Upload Artifacts
+        run: ./gradlew uploadArchives
+        env:
+          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_USERNAME: ${{ secrets.SONATYPE_NEXUS_USERNAME }}
+          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_PASSWORD: ${{ secrets.SONATYPE_NEXUS_PASSWORD }}
@@ -1,35 +0,0 @@
-language: java
-
-dist: trusty
-
-jdk:
-  - openjdk11
-
-script:
-  - ./gradlew jar --parallel
-
-after_success:
-  - .buildscript/deploy_snapshot.sh
-
-env:
-  global:
-    - secure: ""fELrorBJHDz+Xk9iSVMnamu0qC0+pYnFvjnEIcGnmKMMxLI/CIMACghIfSkqZhKAcU3hvxgWzyY8JBMnf5tykUjjOwmubAjZ9qIvwujtrUoUitUkpvVaPtqF0d1Yx0Xq4qt3NB9cOugPR/cPGnoEvSKfND3g+o5ta7KzdjwMBCY=""
-    - secure: ""WMkcWrsvzJNf48w7DJwipUNbhAoggCkC+NM31esq9/GDceGtVWj4hssQETynG4+ckxr0wGqUxsTRTz0uGhX6Fi58haG8yKp+g/HVClqI5EYjI44ptPcwlqlbYjuGbk65k1OGGZLctA6fQA3uT0zee05/yBjJx/jOqrN+PD1tW38=""
-
-branches:
-  only:
-    - master
-
-notifications:
-  email: false
-
-sudo: false
-
-before_cache:
-  - rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
-  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
-
-cache:
-  directories:
-    - $HOME/.gradle/caches/
-    - $HOME/.gradle/wrapper/
"
https://github.com/square/okhttp/commit/fd509b937c4a5438fe02ddf06ade5ad56736af5d,Inject a leading . for better matching under JavaNetCookieJar  <enter> Closes :  <issue_link> ,https://api.github.com/repos/square/okhttp/commits/fd509b937c4a5438fe02ddf06ade5ad56736af5d,"@@ -23,6 +23,7 @@
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.URI;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -271,6 +272,58 @@ public void testNetscapeResponse() throws Exception {
     assertNull(request.getHeader(""Quux""));
   }
 
+  @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse(""https://www.squareup.com/"");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, ""a=android; Domain=squareup.com"")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals(""a"", actualCookies.get(0).name());
+    assertEquals(""android"", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse(""https://www.squareup.com/"");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, ""a=android; Domain=.squareup.com"")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals(""a"", actualCookies.get(0).name());
+    assertEquals(""android"", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesExactly() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse(""https://squareup.com/"");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, ""a=android; Domain=squareup.com"")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals(""a"", actualCookies.get(0).name());
+    assertEquals(""android"", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url1 = HttpUrl.parse(""https://api.squareup.com/"");
+    cookieJar.saveFromResponse(url1, Arrays.asList(
+        Cookie.parse(url1, ""a=android; Domain=api.squareup.com"")));
+
+    HttpUrl url2 = HttpUrl.parse(""https://www.squareup.com/"");
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
+    assertEquals(Collections.<Cookie>emptyList(), actualCookies);
+  }
+
   private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
     return server.url(path)
         .newBuilder()
@@ -40,7 +40,7 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
     if (cookieHandler != null) {
       List<String> cookieStrings = new ArrayList<>();
       for (Cookie cookie : cookies) {
-        cookieStrings.add(cookie.toString());
+        cookieStrings.add(cookie.toString(true));
       }
       Map<String, List<String>> multimap = Collections.singletonMap(""Set-Cookie"", cookieStrings);
       try {
@@ -530,6 +530,15 @@ public Cookie build() {
   }
 
   @Override public String toString() {
+    return toString(false);
+  }
+
+  /**
+   * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is
+   *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This
+   *     extra dot is ignored by more recent specifications.
+   */
+  String toString(boolean forObsoleteRfc2965) {
     StringBuilder result = new StringBuilder();
     result.append(name);
     result.append('=');
@@ -544,7 +553,11 @@ public Cookie build() {
     }
 
     if (!hostOnly) {
-      result.append(""; domain="").append(domain);
+      result.append(""; domain="");
+      if (forObsoleteRfc2965) {
+        result.append(""."");
+      }
+      result.append(domain);
     }
 
     result.append(""; path="").append(path);
"
https://github.com/junit-team/junit4/commit/078e45bd31a9920e00633ad6ce658e22529304f2,Brought in old JUnit4ClassRunner for compatibility. Renamed new JUnit4ClassRunner to BlockJUnit4ClassRunner. ,https://api.github.com/repos/junit-team/junit4/commits/078e45bd31a9920e00633ad6ce658e22529304f2,"@@ -16,11 +16,11 @@
 import org.junit.experimental.theories.internal.ParameterizedAssertionError;
 import org.junit.internal.AssumptionViolatedException;
 import org.junit.internal.runners.InitializationError;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.internal.runners.links.Statement;
 import org.junit.internal.runners.model.FrameworkMethod;
 
-public class Theories extends JUnit4ClassRunner {
+public class Theories extends BlockJUnit4ClassRunner {
 	public Theories(Class<?> klass) throws InitializationError {
 		super(klass);
 	}
@@ -91,7 +91,7 @@ protected void runWithIncompleteAssignment(Assignments incomplete)
 		protected void runWithCompleteAssignment(final Assignments complete)
 				throws InstantiationException, IllegalAccessException,
 				InvocationTargetException, NoSuchMethodException, Throwable {
-			new JUnit4ClassRunner(getTestClass()) {
+			new BlockJUnit4ClassRunner(getTestClass()) {
 				@Override
 				protected void collectInitializationErrors(
 						List<Throwable> errors) {
@@ -3,13 +3,13 @@
  */
 package org.junit.internal.builders;
 
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.runner.Runner;
 import org.junit.runners.RunnerBuilder;
 
 public class JUnit4Builder extends RunnerBuilder {
 	@Override
 	public Runner runnerForClass(Class<?> testClass) throws Throwable {
-		return new JUnit4ClassRunner(testClass);
+		return new BlockJUnit4ClassRunner(testClass);
 	}
 }
\ No newline at end of file
@@ -0,0 +1,80 @@
+package org.junit.internal.deprecated;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.runner.Description;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunNotifier;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public
+class ClassRoadie {
+	private RunNotifier fNotifier;
+	private TestClass fTestClass;
+	private Description fDescription;
+	private final Runnable fRunnable;
+	
+	public ClassRoadie(RunNotifier notifier, TestClass testClass,
+			Description description, Runnable runnable) {
+		fNotifier= notifier;
+		fTestClass= testClass;
+		fDescription= description;
+		fRunnable= runnable;
+	}
+
+	protected void runUnprotected() {
+		fRunnable.run();
+	};
+
+	protected void addFailure(Throwable targetException) {
+		fNotifier.fireTestFailure(new Failure(fDescription, targetException));
+	}
+
+	public void runProtected() {
+		try {
+			runBefores();
+			runUnprotected();
+		} catch (FailedBefore e) {
+		} finally {
+			runAfters();
+		}
+	}
+
+	private void runBefores() throws FailedBefore {
+		try {
+			try {
+				List<Method> befores= fTestClass.getBefores();
+				for (Method before : befores)
+					before.invoke(null);
+			} catch (InvocationTargetException e) {
+				throw e.getTargetException();
+			}
+		} catch (org.junit.internal.AssumptionViolatedException e) {
+			throw new FailedBefore();
+		} catch (Throwable e) {
+			addFailure(e);
+			throw new FailedBefore();
+		}
+	}
+
+	private void runAfters() {
+		List<Method> afters= fTestClass.getAfters();
+		for (Method after : afters)
+			try {
+				after.invoke(null);
+			} catch (InvocationTargetException e) {
+				addFailure(e.getTargetException());
+			} catch (Throwable e) {
+				addFailure(e); // Untested, but seems impossible
+			}
+	}
+}
\ No newline at end of file
@@ -0,0 +1,14 @@
+package org.junit.internal.deprecated;
+
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+class FailedBefore extends Exception {
+	private static final long serialVersionUID= 1L;
+}
\ No newline at end of file
@@ -0,0 +1,158 @@
+package org.junit.internal.deprecated;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import org.junit.internal.AssumptionViolatedException;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.runner.Description;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunNotifier;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class MethodRoadie {
+	private final Object fTest;
+	private final RunNotifier fNotifier;
+	private final Description fDescription;
+	private TestMethod fTestMethod;
+
+	public MethodRoadie(Object test, TestMethod method, RunNotifier notifier, Description description) {
+		fTest= test;
+		fNotifier= notifier;
+		fDescription= description;
+		fTestMethod= method;
+	}
+
+	public void run() {
+		if (fTestMethod.isIgnored()) {
+			fNotifier.fireTestIgnored(fDescription);
+			return;
+		}
+		fNotifier.fireTestStarted(fDescription);
+		try {
+			long timeout= fTestMethod.getTimeout();
+			if (timeout > 0)
+				runWithTimeout(timeout);
+			else
+				runTest();
+		} finally {
+			fNotifier.fireTestFinished(fDescription);
+		}
+	}
+
+	private void runWithTimeout(final long timeout) {
+		runBeforesThenTestThenAfters(new Runnable() {
+		
+			public void run() {
+				ExecutorService service= Executors.newSingleThreadExecutor();
+				Callable<Object> callable= new Callable<Object>() {
+					public Object call() throws Exception {
+						runTestMethod();
+						return null;
+					}
+				};
+				Future<Object> result= service.submit(callable);
+				service.shutdown();
+				try {
+					boolean terminated= service.awaitTermination(timeout,
+							TimeUnit.MILLISECONDS);
+					if (!terminated)
+						service.shutdownNow();
+					result.get(0, TimeUnit.MILLISECONDS); // throws the exception if one occurred during the invocation
+				} catch (TimeoutException e) {
+					addFailure(new Exception(String.format(""test timed out after %d milliseconds"", timeout)));
+				} catch (Exception e) {
+					addFailure(e);
+				}				
+			}
+		});
+	}
+	
+	public void runTest() {
+		runBeforesThenTestThenAfters(new Runnable() {
+			public void run() {
+				runTestMethod();
+			}
+		});
+	}
+
+	public void runBeforesThenTestThenAfters(Runnable test) {
+		try {
+			runBefores();
+			test.run();
+		} catch (FailedBefore e) {
+		} catch (Exception e) {
+			throw new RuntimeException(""test should never throw an exception to this level"");
+		} finally {
+			runAfters();
+		}		
+	}
+	
+	protected void runTestMethod() {
+		try {
+			fTestMethod.invoke(fTest);
+			if (fTestMethod.expectsException())
+				addFailure(new AssertionError(""Expected exception: "" + fTestMethod.getExpectedException().getName()));
+		} catch (InvocationTargetException e) {
+			Throwable actual= e.getTargetException();
+			if (actual instanceof AssumptionViolatedException)
+				return;
+			else if (!fTestMethod.expectsException())
+				addFailure(actual);
+			else if (fTestMethod.isUnexpected(actual)) {
+				String message= ""Unexpected exception, expected<"" + fTestMethod.getExpectedException().getName() + ""> but was<""
+					+ actual.getClass().getName() + "">"";
+				addFailure(new Exception(message, actual));
+			}
+		} catch (Throwable e) {
+			addFailure(e);
+		}
+	}
+	
+	private void runBefores() throws FailedBefore {
+		try {
+			try {
+				List<Method> befores= fTestMethod.getBefores();
+				for (Method before : befores)
+					before.invoke(fTest);
+			} catch (InvocationTargetException e) {
+				throw e.getTargetException();
+			}
+		} catch (AssumptionViolatedException e) {
+			throw new FailedBefore();
+		} catch (Throwable e) {
+			addFailure(e);
+			throw new FailedBefore();
+		}
+	}
+
+	private void runAfters() {
+		List<Method> afters= fTestMethod.getAfters();
+		for (Method after : afters)
+			try {
+				after.invoke(fTest);
+			} catch (InvocationTargetException e) {
+				addFailure(e.getTargetException());
+			} catch (Throwable e) {
+				addFailure(e); // Untested, but seems impossible
+			}
+	}
+
+	protected void addFailure(Throwable e) {
+		fNotifier.fireTestFailure(new Failure(fDescription, e));
+	}
+}
+
@@ -0,0 +1,93 @@
+package org.junit.internal.deprecated;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.InitializationError;
+import org.junit.internal.runners.JUnit4ClassRunner;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class MethodValidator {
+
+	private final List<Throwable> fErrors= new ArrayList<Throwable>();
+
+	private TestClass fTestClass;
+
+	public MethodValidator(TestClass testClass) {
+		fTestClass = testClass;
+	}
+
+	public void validateInstanceMethods() {
+		validateTestMethods(After.class, false);
+		validateTestMethods(Before.class, false);
+		validateTestMethods(Test.class, false);
+		
+		List<Method> methods= fTestClass.getAnnotatedMethods(Test.class);
+		if (methods.size() == 0)
+			fErrors.add(new Exception(""No runnable methods""));
+	}
+
+	public void validateStaticMethods() {
+		validateTestMethods(BeforeClass.class, true);
+		validateTestMethods(AfterClass.class, true);
+	}
+	
+	public List<Throwable> validateMethodsForDefaultRunner() {
+		validateNoArgConstructor();
+		validateStaticMethods();
+		validateInstanceMethods();
+		return fErrors;
+	}
+	
+	public void assertValid() throws InitializationError {
+		if (!fErrors.isEmpty())
+			throw new InitializationError(fErrors);
+	}
+
+	public void validateNoArgConstructor() {
+		try {
+			fTestClass.getConstructor();
+		} catch (Exception e) {
+			fErrors.add(new Exception(""Test class should have public zero-argument constructor"", e));
+		}
+	}
+
+	private void validateTestMethods(Class<? extends Annotation> annotation,
+			boolean isStatic) {
+		List<Method> methods= fTestClass.getAnnotatedMethods(annotation);
+		
+		for (Method each : methods) {
+			if (Modifier.isStatic(each.getModifiers()) != isStatic) {
+				String state= isStatic ? ""should"" : ""should not"";
+				fErrors.add(new Exception(""Method "" + each.getName() + ""() ""
+						+ state + "" be static""));
+			}
+			if (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))
+				fErrors.add(new Exception(""Class "" + each.getDeclaringClass().getName()
+						+ "" should be public""));
+			if (!Modifier.isPublic(each.getModifiers()))
+				fErrors.add(new Exception(""Method "" + each.getName()
+						+ "" should be public""));
+			if (each.getReturnType() != Void.TYPE)
+				fErrors.add(new Exception(""Method "" + each.getName()
+						+ "" should be void""));
+			if (each.getParameterTypes().length != 0)
+				fErrors.add(new Exception(""Method "" + each.getName()
+						+ "" should have no parameters""));
+		}
+	}
+}
@@ -0,0 +1,103 @@
+package org.junit.internal.deprecated;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class TestClass {
+	private final Class<?> fClass;
+	
+	public TestClass(Class<?> klass) {
+		fClass= klass;
+	}
+
+	public List<Method> getTestMethods() {
+		return getAnnotatedMethods(Test.class);
+	}
+
+	List<Method> getBefores() {
+		return getAnnotatedMethods(BeforeClass.class);
+	}
+
+	List<Method> getAfters() {
+		return getAnnotatedMethods(AfterClass.class);
+	}
+	
+	public List<Method> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {
+		List<Method> results= new ArrayList<Method>();
+		for (Class<?> eachClass : getSuperClasses(fClass)) {
+			Method[] methods= eachClass.getDeclaredMethods();
+			for (Method eachMethod : methods) {
+				Annotation annotation= eachMethod.getAnnotation(annotationClass);
+				if (annotation != null && ! isShadowed(eachMethod, results)) 
+					results.add(eachMethod);
+			}
+		}
+		if (runsTopToBottom(annotationClass))
+			Collections.reverse(results);
+		return results;
+	}
+
+	private boolean runsTopToBottom(Class< ? extends Annotation> annotation) {
+		return annotation.equals(Before.class) || annotation.equals(BeforeClass.class);
+	}
+	
+	private boolean isShadowed(Method method, List<Method> results) {
+		for (Method each : results) {
+			if (isShadowed(method, each))
+				return true;
+		}
+		return false;
+	}
+
+	private boolean isShadowed(Method current, Method previous) {
+		if (! previous.getName().equals(current.getName()))
+			return false;
+		if (previous.getParameterTypes().length != current.getParameterTypes().length)
+			return false;
+		for (int i= 0; i < previous.getParameterTypes().length; i++) {
+			if (! previous.getParameterTypes()[i].equals(current.getParameterTypes()[i]))
+				return false;
+		}
+		return true;
+	}
+
+	private List<Class<?>> getSuperClasses(Class< ?> testClass) {
+		ArrayList<Class<?>> results= new ArrayList<Class<?>>();
+		Class<?> current= testClass;
+		while (current != null) {
+			results.add(current);
+			current= current.getSuperclass();
+		}
+		return results;
+	}
+
+	public Constructor<?> getConstructor() throws SecurityException, NoSuchMethodException {
+		return fClass.getConstructor();
+	}
+
+	public Class<?> getJavaClass() {
+		return fClass;
+	}
+
+	public String getName() {
+		return fClass.getName();
+	}
+
+}
@@ -0,0 +1,70 @@
+package org.junit.internal.deprecated;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.Test.None;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class TestMethod {
+	private final Method fMethod;
+	private TestClass fTestClass;
+
+	public TestMethod(Method method, TestClass testClass) {
+		fMethod= method;
+		fTestClass= testClass;
+	}
+
+	public boolean isIgnored() {
+		return fMethod.getAnnotation(Ignore.class) != null;
+	}
+
+	public long getTimeout() {
+		Test annotation= fMethod.getAnnotation(Test.class);
+		if (annotation == null)
+			return 0;
+		long timeout= annotation.timeout();
+		return timeout;
+	}
+
+	protected Class<? extends Throwable> getExpectedException() {
+		Test annotation= fMethod.getAnnotation(Test.class);
+		if (annotation == null || annotation.expected() == None.class)
+			return null;
+		else
+			return annotation.expected();
+	}
+
+	boolean isUnexpected(Throwable exception) {
+		return ! getExpectedException().isAssignableFrom(exception.getClass());
+	}
+
+	boolean expectsException() {
+		return getExpectedException() != null;
+	}
+
+	List<Method> getBefores() {
+		return fTestClass.getAnnotatedMethods(Before.class);
+	}
+
+	List<Method> getAfters() {
+		return fTestClass.getAnnotatedMethods(After.class);
+	}
+
+	public void invoke(Object test) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
+		fMethod.invoke(test);
+	}
+
+}
@@ -0,0 +1,140 @@
+package org.junit.internal.runners;
+
+import java.util.List;
+
+import org.junit.internal.runners.links.ExpectException;
+import org.junit.internal.runners.links.Fail;
+import org.junit.internal.runners.links.FailOnTimeout;
+import org.junit.internal.runners.links.IgnoreTestNotifier;
+import org.junit.internal.runners.links.InvokeMethod;
+import org.junit.internal.runners.links.Notifier;
+import org.junit.internal.runners.links.RunAfters;
+import org.junit.internal.runners.links.RunBefores;
+import org.junit.internal.runners.links.RunTestNotifier;
+import org.junit.internal.runners.links.Statement;
+import org.junit.internal.runners.model.EachTestNotifier;
+import org.junit.internal.runners.model.FrameworkMethod;
+import org.junit.internal.runners.model.ReflectiveCallable;
+import org.junit.internal.runners.model.TestAnnotation;
+import org.junit.internal.runners.model.TestClass;
+import org.junit.internal.runners.model.TestMethod;
+import org.junit.runner.Description;
+import org.junit.runner.manipulation.Filterable;
+import org.junit.runner.manipulation.Sortable;
+import org.junit.runner.notification.RunNotifier;
+
+public class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> implements Filterable, Sortable {
+	protected final List<FrameworkMethod> fTestMethods;
+
+	public BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {
+		this(new TestClass(klass));
+	}
+	
+	public BlockJUnit4ClassRunner(TestClass testClass) throws InitializationError {
+		super(testClass);
+		fTestMethods= computeTestMethods();
+		validate();
+	}
+	
+	//
+	// Override in subclasses
+	//
+
+	protected List<FrameworkMethod> computeTestMethods() {
+		return getTestClass().getTestMethods();
+	}
+
+	@Override
+	protected void collectInitializationErrors(List<Throwable> errors) {
+		getTestClass().validateMethodsForDefaultRunner(errors);
+	}
+
+	protected Object createTest() throws Exception {
+		return getTestClass().getConstructor().newInstance();
+	}
+
+	protected String testName(FrameworkMethod method) {
+		return method.getName();
+	}
+	
+	protected Statement childBlock(FrameworkMethod method) {
+		Object test;
+		try {
+			test= new ReflectiveCallable() {
+				@Override
+				protected Object runReflectiveCall() throws Throwable {
+					return createTest();
+				}
+			}.run();
+		} catch (Throwable e) {
+			return new Fail(e);
+		}
+
+		TestAnnotation annotation= new TestAnnotation(method);
+		
+		Statement link= invoke(method, test);
+		link= possiblyExpectingExceptions(annotation, link);
+		link= withPotentialTimeout(annotation, link);
+		link= withBefores(method, test, link);
+		link= withAfters(method, test, link);
+		return link;
+	}
+	
+	//
+	// Implementation of ParentRunner
+	// 
+	
+	@Override
+	protected void runChild(FrameworkMethod method, RunNotifier notifier) {
+		Description description= describeChild(method);
+		EachTestNotifier eachNotifier= new EachTestNotifier(notifier,
+				description);
+		notifying(method, childBlock(method)).run(eachNotifier);
+	}
+
+	@Override
+	protected Description describeChild(FrameworkMethod method) {
+		return Description.createTestDescription(getTestClass().getJavaClass(),
+				testName(method), method.getMethod().getAnnotations());
+	}
+
+	@Override
+	protected List<FrameworkMethod> getChildren() {
+		return fTestMethods;
+	}
+
+	//
+	// Statement builders
+	//
+	
+	protected Statement invoke(FrameworkMethod method, Object test) {
+		return new InvokeMethod(method, test);
+	}
+
+	protected Statement possiblyExpectingExceptions(TestAnnotation annotation,
+			Statement next) {
+		return annotation.expectsException() ? new ExpectException(next, annotation
+				.getExpectedException()) : next;
+	}
+
+	protected Statement withPotentialTimeout(TestAnnotation annotation,
+			Statement next) {
+		long timeout= annotation.getTimeout();
+		return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
+	}
+
+	protected Statement withAfters(FrameworkMethod method, Object target,
+			Statement link) {
+		return new RunAfters(link, new TestMethod(getTestClass()), target);
+	}
+
+	protected Statement withBefores(FrameworkMethod method, Object target,
+			Statement link) {
+		return new RunBefores(link, new TestMethod(getTestClass()), target);
+	}
+
+	protected Notifier notifying(FrameworkMethod method, Statement link) {
+		return method.isIgnored() ? new IgnoreTestNotifier()
+				: new RunTestNotifier(link);
+	}
+}
@@ -1,140 +1,147 @@
 package org.junit.internal.runners;
 
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
 import java.util.List;
 
-import org.junit.internal.runners.links.ExpectException;
-import org.junit.internal.runners.links.Fail;
-import org.junit.internal.runners.links.FailOnTimeout;
-import org.junit.internal.runners.links.IgnoreTestNotifier;
-import org.junit.internal.runners.links.InvokeMethod;
-import org.junit.internal.runners.links.Notifier;
-import org.junit.internal.runners.links.RunAfters;
-import org.junit.internal.runners.links.RunBefores;
-import org.junit.internal.runners.links.RunTestNotifier;
-import org.junit.internal.runners.links.Statement;
-import org.junit.internal.runners.model.EachTestNotifier;
-import org.junit.internal.runners.model.FrameworkMethod;
-import org.junit.internal.runners.model.ReflectiveCallable;
-import org.junit.internal.runners.model.TestAnnotation;
-import org.junit.internal.runners.model.TestClass;
-import org.junit.internal.runners.model.TestMethod;
+import org.junit.internal.deprecated.ClassRoadie;
+import org.junit.internal.deprecated.MethodRoadie;
+import org.junit.internal.deprecated.MethodValidator;
+import org.junit.internal.deprecated.TestClass;
+import org.junit.internal.deprecated.TestMethod;
 import org.junit.runner.Description;
+import org.junit.runner.Runner;
+import org.junit.runner.manipulation.Filter;
 import org.junit.runner.manipulation.Filterable;
+import org.junit.runner.manipulation.NoTestsRemainException;
 import org.junit.runner.manipulation.Sortable;
+import org.junit.runner.manipulation.Sorter;
+import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunNotifier;
 
-public class JUnit4ClassRunner extends ParentRunner<FrameworkMethod> implements Filterable, Sortable {
-	protected final List<FrameworkMethod> fTestMethods;
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class JUnit4ClassRunner extends Runner implements Filterable, Sortable {
+	private final List<Method> fTestMethods;
+	private TestClass fTestClass;
 
 	public JUnit4ClassRunner(Class<?> klass) throws InitializationError {
-		this(new TestClass(klass));
+		fTestClass= new TestClass(klass);
+		fTestMethods= getTestMethods();
+		validate();
 	}
 	
-	public JUnit4ClassRunner(TestClass testClass) throws InitializationError {
-		super(testClass);
-		fTestMethods= computeTestMethods();
-		validate();
+	protected List<Method> getTestMethods() {
+		return fTestClass.getTestMethods();
 	}
 	
-	//
-	// Override in subclasses
-	//
+	protected void validate() throws InitializationError {
+		MethodValidator methodValidator= new MethodValidator(fTestClass);
+		methodValidator.validateMethodsForDefaultRunner();
+		methodValidator.assertValid();
+	}
+
+	@Override
+	public void run(final RunNotifier notifier) {
+		new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {
+			public void run() {
+				runMethods(notifier);
+			}
+		}).runProtected();
+	}
 
-	protected List<FrameworkMethod> computeTestMethods() {
-		return getTestClass().getTestMethods();
+	protected void runMethods(final RunNotifier notifier) {
+		for (Method method : fTestMethods)
+			invokeTestMethod(method, notifier);
 	}
 
 	@Override
-	protected void collectInitializationErrors(List<Throwable> errors) {
-		getTestClass().validateMethodsForDefaultRunner(errors);
+	public Description getDescription() {
+		Description spec= Description.createSuiteDescription(getName(), classAnnotations());
+		List<Method> testMethods= fTestMethods;
+		for (Method method : testMethods)
+			spec.addChild(methodDescription(method));
+		return spec;
 	}
 
-	protected Object createTest() throws Exception {
-		return getTestClass().getConstructor().newInstance();
+	protected Annotation[] classAnnotations() {
+		return fTestClass.getJavaClass().getAnnotations();
 	}
 
-	protected String testName(FrameworkMethod method) {
-		return method.getName();
+	protected String getName() {
+		return getTestClass().getName();
 	}
 	
-	protected Statement childBlock(FrameworkMethod method) {
+	protected Object createTest() throws Exception {
+		return getTestClass().getConstructor().newInstance();
+	}
+
+	protected void invokeTestMethod(Method method, RunNotifier notifier) {
+		Description description= methodDescription(method);
 		Object test;
 		try {
-			test= new ReflectiveCallable() {
-				@Override
-				protected Object runReflectiveCall() throws Throwable {
-					return createTest();
-				}
-			}.run();
-		} catch (Throwable e) {
-			return new Fail(e);
+			test= createTest();
+		} catch (InvocationTargetException e) {
+			testAborted(notifier, description, e.getCause());
+			return;			
+		} catch (Exception e) {
+			testAborted(notifier, description, e);
+			return;
 		}
-
-		TestAnnotation annotation= new TestAnnotation(method);
-		
-		Statement link= invoke(method, test);
-		link= possiblyExpectingExceptions(annotation, link);
-		link= withPotentialTimeout(annotation, link);
-		link= withBefores(method, test, link);
-		link= withAfters(method, test, link);
-		return link;
-	}
-	
-	//
-	// Implementation of ParentRunner
-	// 
-	
-	@Override
-	protected void runChild(FrameworkMethod method, RunNotifier notifier) {
-		Description description= describeChild(method);
-		EachTestNotifier eachNotifier= new EachTestNotifier(notifier,
-				description);
-		notifying(method, childBlock(method)).run(eachNotifier);
+		TestMethod testMethod= wrapMethod(method);
+		new MethodRoadie(test, testMethod, notifier, description).run();
 	}
 
-	@Override
-	protected Description describeChild(FrameworkMethod method) {
-		return Description.createTestDescription(getTestClass().getJavaClass(),
-				testName(method), method.getMethod().getAnnotations());
+	private void testAborted(RunNotifier notifier, Description description,
+			Throwable e) {
+		notifier.fireTestStarted(description);
+		notifier.fireTestFailure(new Failure(description, e));
+		notifier.fireTestFinished(description);
 	}
 
-	@Override
-	protected List<FrameworkMethod> getChildren() {
-		return fTestMethods;
+	protected TestMethod wrapMethod(Method method) {
+		return new TestMethod(method, fTestClass);
 	}
 
-	//
-	// Statement builders
-	//
-	
-	protected Statement invoke(FrameworkMethod method, Object test) {
-		return new InvokeMethod(method, test);
+	protected String testName(Method method) {
+		return method.getName();
 	}
 
-	protected Statement possiblyExpectingExceptions(TestAnnotation annotation,
-			Statement next) {
-		return annotation.expectsException() ? new ExpectException(next, annotation
-				.getExpectedException()) : next;
+	protected Description methodDescription(Method method) {
+		return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), testAnnotations(method));
 	}
 
-	protected Statement withPotentialTimeout(TestAnnotation annotation,
-			Statement next) {
-		long timeout= annotation.getTimeout();
-		return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
+	protected Annotation[] testAnnotations(Method method) {
+		return method.getAnnotations();
 	}
 
-	protected Statement withAfters(FrameworkMethod method, Object target,
-			Statement link) {
-		return new RunAfters(link, new TestMethod(getTestClass()), target);
+	public void filter(Filter filter) throws NoTestsRemainException {
+		for (Iterator<Method> iter= fTestMethods.iterator(); iter.hasNext();) {
+			Method method= iter.next();
+			if (!filter.shouldRun(methodDescription(method)))
+				iter.remove();
+		}
+		if (fTestMethods.isEmpty())
+			throw new NoTestsRemainException();
 	}
 
-	protected Statement withBefores(FrameworkMethod method, Object target,
-			Statement link) {
-		return new RunBefores(link, new TestMethod(getTestClass()), target);
+	public void sort(final Sorter sorter) {
+		Collections.sort(fTestMethods, new Comparator<Method>() {
+			public int compare(Method o1, Method o2) {
+				return sorter.compare(methodDescription(o1), methodDescription(o2));
+			}
+		});
 	}
 
-	protected Notifier notifying(FrameworkMethod method, Statement link) {
-		return method.isIgnored() ? new IgnoreTestNotifier()
-				: new RunTestNotifier(link);
+	protected TestClass getTestClass() {
+		return fTestClass;
 	}
-}
+}
\ No newline at end of file
@@ -9,7 +9,7 @@
 import java.util.List;
 
 import org.junit.internal.runners.InitializationError;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.internal.runners.links.Statement;
 import org.junit.internal.runners.model.FrameworkMethod;
 import org.junit.internal.runners.model.TestClass;
@@ -74,7 +74,7 @@ public Parameterized(Class<?> klass) throws Throwable {
 		validate();
 	}
 	
-	private static class TestClassRunnerForParameters extends JUnit4ClassRunner {
+	private static class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {
 		private final int fParameterSetNumber;
 
 		private final List<Object[]> fParameterList;
@@ -3,6 +3,6 @@
  *
  * @since 4.0
  * @see org.junit.runner.Runner
- * @see org.junit.internal.runners.JUnit4ClassRunner
+ * @see org.junit.internal.runners.BlockJUnit4ClassRunner
  */
 package org.junit.runners;
\ No newline at end of file
@@ -8,6 +8,7 @@
 import org.junit.tests.assertion.AssertionTest;
 import org.junit.tests.assertion.BothTest;
 import org.junit.tests.assertion.EachTest;
+import org.junit.tests.deprecated.JUnit4ClassRunnerTest;
 import org.junit.tests.description.AnnotatedDescriptionTest;
 import org.junit.tests.description.SuiteDescriptionTest;
 import org.junit.tests.description.TestDescriptionTest;
@@ -105,7 +106,8 @@
 	AllMembersSupplierTest.class,
 	MatcherTest.class,
 	ObjectContractTest.class,
-	TheoriesPerformanceTest.class
+	TheoriesPerformanceTest.class,
+	JUnit4ClassRunnerTest.class
 })
 public class AllTests {
 	public static Test suite() {
@@ -0,0 +1,51 @@
+package org.junit.tests.deprecated;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+import org.junit.Test;
+import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.runner.JUnitCore;
+import org.junit.runner.Result;
+import org.junit.runner.RunWith;
+
+/*
+ * This is a simple smoke test to make sure the old JUnit4ClassRunner basically works.
+ * Delete this test when JUnit4ClassRunner goes to the Great Heap In The Sky.
+ */
+public class JUnit4ClassRunnerTest {
+
+	@RunWith(JUnit4ClassRunner.class)
+	public static class Example {
+		@Test public void success() {}
+		@Test public void failure() {
+			fail();
+		}
+	}
+	
+	@Test
+	public void runWithOldJUnit4ClassRunner() {
+		Result result= JUnitCore.runClasses(Example.class);
+		assertThat(result.getRunCount(), is(2));
+		assertThat(result.getFailureCount(), is(1));
+	}
+
+	@RunWith(JUnit4ClassRunner.class)
+	public static class UnconstructableExample {
+		public UnconstructableExample() {
+			throw new UnsupportedOperationException();
+		}
+		@Test public void success() {}
+		@Test public void failure() {
+			fail();
+		}
+	}
+
+	
+	@Test
+	public void runWithOldJUnit4ClassRunnerAndBadConstructor() {
+		Result result= JUnitCore.runClasses(UnconstructableExample.class);
+		assertThat(result.getRunCount(), is(2));
+		assertThat(result.getFailureCount(), is(2));
+	}
+}
@@ -9,7 +9,7 @@
 import junit.framework.TestResult;
 import org.junit.Before;
 import org.junit.Test;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.runner.Description;
 import org.junit.runner.RunWith;
 import org.junit.runner.Runner;
@@ -91,7 +91,7 @@ public void generatedErrorTestsMatchUp() {
 		assertTrue(shouldFail == listener.getError());
 	}
 	
-	public static class InitializesWithError extends JUnit4ClassRunner {
+	public static class InitializesWithError extends BlockJUnit4ClassRunner {
 		public InitializesWithError(Class<?> klass) throws Exception {
 			super(klass);
 			throw new Exception();
@@ -14,7 +14,7 @@
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.internal.runners.InitializationError;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
@@ -85,7 +85,7 @@ public static Collection<Object[]> params() {
 	
 	private List<Throwable> validateAllMethods(Class<?> clazz) {
 		try {
-			new JUnit4ClassRunner(clazz);
+			new BlockJUnit4ClassRunner(clazz);
 		} catch (InitializationError e) {
 			return e.getCauses();
 		}
@@ -17,7 +17,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.internal.runners.InitializationError;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.internal.runners.model.TestClass;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
@@ -88,7 +88,7 @@ static public class SubShadows extends SuperWrong {
 
 	private List<Throwable> validateAllMethods(Class<?> clazz) {
 		try {
-			new JUnit4ClassRunner(clazz);
+			new BlockJUnit4ClassRunner(clazz);
 		} catch (InitializationError e) {
 			return e.getCauses();
 		}
"
https://github.com/square/retrofit/commit/00d3f9070e15e514430e5dbb2aec602547c3c92d,AndroidLog: Added getTag() and logChunk() methods  for easier subclassing. ,https://api.github.com/repos/square/retrofit/commits/00d3f9070e15e514430e5dbb2aec602547c3c92d,"@@ -16,7 +16,15 @@ public AndroidLog(String tag) {
   @Override public void log(String message) {
     for (int i = 0, len = message.length(); i < len; i += LOG_CHUNK_SIZE) {
       int end = Math.min(len, i + LOG_CHUNK_SIZE);
-      Log.d(tag, message.substring(i, end));
+      logChunk(message.substring(i, end));
     }
   }
+
+  public void logChunk(String chunk) {
+    Log.d(getTag(), chunk);
+  }
+
+  public String getTag() {
+    return tag;
+  }
 }
"
https://github.com/square/okhttp/commit/18f3564a4f2b17c3067e7f02337e3909ba5cb3ba,Update deploy_snapshot.sh to temporarily ignore javadoc errors and compile tests but not run ( <pr_link> ) ,https://api.github.com/repos/square/okhttp/commits/18f3564a4f2b17c3067e7f02337e3909ba5cb3ba,"@@ -21,6 +21,6 @@ elif [ ""$TRAVIS_BRANCH"" != ""$BRANCH"" ]; then
   echo ""Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.""
 else
   echo ""Deploying snapshot...""
-  mvn clean source:jar javadoc:jar deploy --settings="".buildscript/settings.xml"" -Dmaven.test.skip=true
+  mvn clean package source:jar javadoc:jar deploy --settings="".buildscript/settings.xml"" -Dmaven.javadoc.failOnError=false -DskipTests
   echo ""Snapshot deployed!""
 fi
"
https://github.com/apache/dubbo/commit/793bf8244411c33b675e08f1499122bc82654d44,Defensive check to solve issue <issue_link> ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/793bf8244411c33b675e08f1499122bc82654d44,"@@ -37,6 +37,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutorService;
@@ -200,7 +201,11 @@ private boolean isProviderSide(URL url) {
 
     private List<URL> convert(List<HealthService> services) {
         return services.stream()
-                .map(s -> s.getService().getMeta().get(URL_META_KEY))
+                .map(HealthService::getService)
+                .filter(Objects::nonNull)
+                .map(HealthService.Service::getMeta)
+                .filter(m -> m != null && m.containsKey(URL_META_KEY))
+                .map(m -> m.get(URL_META_KEY))
                 .map(URL::valueOf)
                 .collect(Collectors.toList());
     }
"
https://github.com/square/okhttp/commit/c8638813ff5f90715417e489b342aae5e410c5b2,Build setup tweak to work around release plugin bug.  <enter> http://jira.codehaus.org/browse/MRELEASE-812 ,https://api.github.com/repos/square/okhttp/commits/c8638813ff5f90715417e489b342aae5e410c5b2,"@@ -138,19 +138,26 @@
           <artifactId>maven-javadoc-plugin</artifactId>
           <version>2.9</version>
         </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-release-plugin</artifactId>
-          <version>2.3.2</version>
-          <configuration>
-            <autoVersionSubmodules>true</autoVersionSubmodules>
-          </configuration>
-        </plugin>
       </plugins>
     </pluginManagement>
 
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
"
https://github.com/junit-team/junit4/commit/610b38e6c9753ab01b8aef093d2fcaeabe3a7a32,Updated release notes  <enter> Signed-off-by: Kent Beck <kent@threeriversinstitute.org> ,https://api.github.com/repos/junit-team/junit4/commits/610b38e6c9753ab01b8aef093d2fcaeabe3a7a32,"@@ -6,7 +6,6 @@
   of each test method in a test class.  For example, this class will
   keep a log of each passing and failing test:
   
-	@RunWith(Interceptors.class)
 	public static class WatchmanTest {
 		private static String watchedLog;
 
@@ -38,7 +37,6 @@
 
 - The TestName Interceptor makes the current test name available inside test methods:
 
-	@RunWith(Interceptors.class)
 	public class NameInterceptorTest {
 		@Interceptor public TestName name = new TestName();
 		
@@ -53,7 +51,6 @@
 
 - The Timeout Interceptor applies the same timeout to all test methods in a class:
 
-	@RunWith(Interceptors.class)
 	public static class HasGlobalTimeout {
 		public static String log;
 		
@@ -71,7 +68,7 @@
 	}
 
 ### Timeouts ###
-- Tests that timeout now show the stack trace of the test thread.
+- Tests that time out now show the stack trace of the test thread.
 
 ### Docs ###
 - Javadocs now link to online JDK javadocs (bug 2090230)
"
https://github.com/square/okhttp/commit/0665b628fafec38271d7a66421ae04c7fd35dd29,Add support for following HTTP 307 temporary redirects.  <enter> Fixes Android bug 41739. ,https://api.github.com/repos/square/okhttp/commits/0665b628fafec38271d7a66421ae04c7fd35dd29,"@@ -60,6 +60,10 @@
  * is currently connected to a server.
  */
 public class HttpURLConnectionImpl extends HttpURLConnection {
+
+  /** Numeric status code, 307: Temporary Redirect. */
+  static final int HTTP_TEMP_REDIRECT = 307;
+
   /**
    * How many redirects should we follow? Chrome follows 21; Firefox, curl,
    * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
@@ -400,7 +404,8 @@ private Retry processResponseHeaders() throws IOException {
     Proxy selectedProxy = httpEngine.connection != null
         ? httpEngine.connection.getProxy()
         : requestedProxy;
-    switch (getResponseCode()) {
+    final int responseCode = getResponseCode();
+    switch (responseCode) {
       case HTTP_PROXY_AUTH:
         if (selectedProxy.type() != Proxy.Type.HTTP) {
           throw new ProtocolException(""Received HTTP_PROXY_AUTH (407) code while not using proxy"");
@@ -415,12 +420,18 @@ private Retry processResponseHeaders() throws IOException {
       case HTTP_MOVED_PERM:
       case HTTP_MOVED_TEMP:
       case HTTP_SEE_OTHER:
+      case HTTP_TEMP_REDIRECT:
         if (!getInstanceFollowRedirects()) {
           return Retry.NONE;
         }
         if (++redirectionCount > MAX_REDIRECTS) {
           throw new ProtocolException(""Too many redirects: "" + redirectionCount);
         }
+        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals(""GET"") && !method.equals(""HEAD"")) {
+          // ""If the 307 status code is received in response to a request other than GET or HEAD,
+          // the user agent MUST NOT automatically redirect the request""
+          return Retry.NONE;
+        }
         String location = getHeaderField(""Location"");
         if (location == null) {
           return Retry.NONE;
@@ -1731,6 +1731,70 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
     assertEquals(1, server.getRequestCount());
   }
 
+  @Test public void response307WithGet() throws Exception {
+    test307Redirect(""GET"");
+  }
+
+  @Test public void response307WithHead() throws Exception {
+    test307Redirect(""HEAD"");
+  }
+
+  @Test public void response307WithOptions() throws Exception {
+    test307Redirect(""OPTIONS"");
+  }
+
+  @Test public void response307WithPost() throws Exception {
+    test307Redirect(""POST"");
+  }
+
+  private void test307Redirect(String method) throws Exception {
+    MockResponse response1 = new MockResponse()
+        .setResponseCode(HttpURLConnectionImpl.HTTP_TEMP_REDIRECT)
+        .addHeader(""Location: /page2"");
+    if (!method.equals(""HEAD"")) {
+      response1.setBody(""This page has moved!"");
+    }
+    server.enqueue(response1);
+    server.enqueue(new MockResponse().setBody(""Page 2""));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl(""/page1""));
+    connection.setRequestMethod(method);
+    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    if (method.equals(""POST"")) {
+      connection.setDoOutput(true);
+      OutputStream outputStream = connection.getOutputStream();
+      outputStream.write(requestBody);
+      outputStream.close();
+    }
+
+    String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals(method + "" /page1 HTTP/1.1"", page1.getRequestLine());
+
+    if (method.equals(""GET"")) {
+        assertEquals(""Page 2"", response);
+    } else if (method.equals(""HEAD""))  {
+        assertTrue(response.isEmpty());
+    } else {
+      // Methods other than GET/HEAD shouldn't follow the redirect
+      if (method.equals(""POST"")) {
+        assertTrue(connection.getDoOutput());
+        assertEquals(Arrays.toString(requestBody), Arrays.toString(page1.getBody()));
+      }
+      assertEquals(1, server.getRequestCount());
+      assertEquals(""This page has moved!"", response);
+      return;
+    }
+
+    // GET/HEAD requests should have followed the redirect with the same method
+    assertFalse(connection.getDoOutput());
+    assertEquals(2, server.getRequestCount());
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals(method + "" /page2 HTTP/1.1"", page2.getRequestLine());
+  }
+
   @Test public void follow20Redirects() throws Exception {
     for (int i = 0; i < 20; i++) {
       server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
"
https://github.com/square/okhttp/commit/59e68cd2bcba789e7faca70f8910afd2edeed2be,"Introduce Exchange.  <enter> This is the payoff that preceding changes have been working towards. This splits StreamAllocation into three parts: <enter>  - ExchangeFinder: strategy to allocate connections for exchanges  - Exchange: a single request/response pair  - Transmitter: a sequence of exchanges for a Call <enter> The refactoring isn't totally complete, but this should be the last big one. <enter>  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/59e68cd2bcba789e7faca70f8910afd2edeed2be,"@@ -96,7 +96,7 @@ public final class ConnectionPoolTest {
       Call call = client.newCall(newRequest(addressA));
       Transmitter transmitter = new Transmitter(client, call);
       transmitter.prepareToConnect(call.request());
-      transmitter.acquireConnection(c1);
+      transmitter.acquireConnectionNoEvents(c1);
     }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
@@ -183,7 +183,7 @@ public final class ConnectionPoolTest {
     assertEquals(0L, pool.cleanup(100L));
     assertEquals(Collections.emptyList(), c1.transmitters);
 
-    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected.
+    assertTrue(c1.noNewExchanges); // Can't allocate once a leak has been detected.
   }
 
   /** Use a helper method so there's no hidden reference remaining on the stack. */
@@ -195,7 +195,7 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
       Call call = client.newCall(newRequest(connection.route().address()));
       Transmitter transmitter = new Transmitter(client, call);
       transmitter.prepareToConnect(call.request());
-      transmitter.acquireConnection(connection);
+      transmitter.acquireConnectionNoEvents(connection);
     }
   }
 
@@ -35,11 +35,10 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.DeferredTrailers;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Transmitter;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.connection.RealConnectionPool;
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.proxy.NullProxySelector;
@@ -164,10 +163,6 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
       }
 
-      @Override public Transmitter transmitter(Call call) {
-        return ((RealCall) call).transmitter();
-      }
-
       @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
         return ((RealCall) call).timeoutExit(e);
       }
@@ -176,9 +171,13 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         return RealCall.newRealCall(client, originalRequest, true);
       }
 
-      @Override public void initDeferredTrailers(
-          Response.Builder responseBuilder, DeferredTrailers deferredTrailers) {
-        responseBuilder.initDeferredTrailers(deferredTrailers);
+      @Override public void initExchange(
+          Response.Builder responseBuilder, Exchange exchange) {
+        responseBuilder.initExchange(exchange);
+      }
+
+      @Override public @Nullable Exchange exchange(Response response) {
+        return response.exchange;
       }
     };
   }
@@ -83,18 +83,11 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       if (executed) throw new IllegalStateException(""Already Executed"");
       executed = true;
     }
-    captureCallStackTrace();
     timeout.enter();
     transmitter.callStart();
     try {
       client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain();
-      if (result == null) throw new IOException(""Canceled"");
-      return result;
-    } catch (IOException e) {
-      e = timeoutExit(e);
-      transmitter.callFailed(e);
-      throw e;
+      return getResponseWithInterceptorChain();
     } finally {
       client.dispatcher().finished(this);
     }
@@ -110,17 +103,11 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     return e;
   }
 
-  private void captureCallStackTrace() {
-    transmitter.initCallStackTrace(
-        Platform.get().getStackTraceForCloseable(""response.body().close()""));
-  }
-
   @Override public void enqueue(Callback responseCallback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException(""Already Executed"");
       executed = true;
     }
-    captureCallStackTrace();
     transmitter.callStart();
     client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
@@ -146,10 +133,6 @@ private void captureCallStackTrace() {
     return RealCall.newRealCall(client, originalRequest, forWebSocket);
   }
 
-  Transmitter transmitter() {
-    return transmitter;
-  }
-
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
     private volatile AtomicInteger callsPerHost = new AtomicInteger(0);
@@ -192,7 +175,7 @@ void executeOn(ExecutorService executorService) {
       } catch (RejectedExecutionException e) {
         InterruptedIOException ioException = new InterruptedIOException(""executor rejected"");
         ioException.initCause(e);
-        transmitter.callFailed(ioException);
+        transmitter.noMoreExchanges(ioException);
         responseCallback.onFailure(RealCall.this, ioException);
       } finally {
         if (!success) {
@@ -206,20 +189,14 @@ void executeOn(ExecutorService executorService) {
       timeout.enter();
       try {
         Response response = getResponseWithInterceptorChain();
-        if (transmitter.isCanceled()) {
-          signalledCallback = true;
-          responseCallback.onFailure(RealCall.this, new IOException(""Canceled""));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(RealCall.this, response);
-        }
+        if (transmitter.isCanceled()) throw new IOException(""Canceled"");
+        signalledCallback = true;
+        responseCallback.onResponse(RealCall.this, response);
       } catch (IOException e) {
-        e = timeoutExit(e);
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, ""Callback failure for "" + toLoggableString(), e);
         } else {
-          transmitter.callFailed(e);
           responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
@@ -259,10 +236,14 @@ Response getResponseWithInterceptorChain() throws IOException {
         originalRequest, this, client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis());
 
+    IOException ioException = null;
     try {
       return chain.proceed(originalRequest);
+    } catch (IOException e) {
+      ioException = e;
+      throw e;
     } finally {
-      transmitter.noMoreStreamsOnCall();
+      transmitter.noMoreExchanges(ioException);
     }
   }
 }
@@ -20,7 +20,7 @@
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
-import okhttp3.internal.DeferredTrailers;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.http.HttpHeaders;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -54,7 +54,7 @@ public final class Response implements Closeable {
   final @Nullable Response priorResponse;
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
-  final @Nullable DeferredTrailers deferredTrailers;
+  final @Nullable Exchange exchange;
 
   private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
@@ -71,7 +71,7 @@ public final class Response implements Closeable {
     this.priorResponse = builder.priorResponse;
     this.sentRequestAtMillis = builder.sentRequestAtMillis;
     this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
-    this.deferredTrailers = builder.deferredTrailers;
+    this.exchange = builder.exchange;
   }
 
   /**
@@ -144,7 +144,8 @@ public Headers headers() {
    * before the entire HTTP response body has been consumed.
    */
   public Headers trailers() throws IOException {
-    return deferredTrailers.trailers();
+    if (exchange == null) throw new IllegalStateException(""trailers not available"");
+    return exchange.trailers();
   }
 
   /**
@@ -314,7 +315,7 @@ public static class Builder {
     @Nullable Response priorResponse;
     long sentRequestAtMillis;
     long receivedResponseAtMillis;
-    @Nullable DeferredTrailers deferredTrailers;
+    @Nullable Exchange exchange;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -333,7 +334,7 @@ public Builder() {
       this.priorResponse = response.priorResponse;
       this.sentRequestAtMillis = response.sentRequestAtMillis;
       this.receivedResponseAtMillis = response.receivedResponseAtMillis;
-      this.deferredTrailers = response.deferredTrailers;
+      this.exchange = response.exchange;
     }
 
     public Builder request(Request request) {
@@ -441,8 +442,8 @@ public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
       return this;
     }
 
-    void initDeferredTrailers(DeferredTrailers deferredTrailers) {
-      this.deferredTrailers = deferredTrailers;
+    void initExchange(Exchange deferredTrailers) {
+      this.exchange = deferredTrailers;
     }
 
     public Response build() {
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.IOException;
-import okhttp3.Headers;
-
-public interface DeferredTrailers {
-  /** Call this only after the HTTP response body has been exhausted. */
-  Headers trailers() throws IOException;
-}
@@ -27,6 +27,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.connection.RealConnectionPool;
 
 /**
@@ -59,12 +60,12 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
 
   public abstract boolean isInvalidHttpUrlHost(IllegalArgumentException e);
 
-  public abstract Transmitter transmitter(Call call);
-
   public abstract @Nullable IOException timeoutExit(Call call, @Nullable IOException e);
 
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 
-  public abstract void initDeferredTrailers(
-      Response.Builder responseBuilder, DeferredTrailers deferredTrailers);
+  public abstract void initExchange(
+      Response.Builder responseBuilder, Exchange exchange);
+
+  public abstract @Nullable Exchange exchange(Response response);
 }
@@ -16,55 +16,56 @@
 package okhttp3.internal;
 
 import java.io.IOException;
+import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
-import java.net.ProtocolException;
-import java.net.SocketException;
+import java.net.Socket;
 import javax.annotation.Nullable;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
+import okhttp3.Connection;
 import okhttp3.EventListener;
-import okhttp3.Handshake;
-import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.Route;
+import okhttp3.internal.connection.Exchange;
+import okhttp3.internal.connection.ExchangeFinder;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RealConnectionPool;
-import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.RealResponseBody;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
+import okhttp3.internal.platform.Platform;
 
+import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.sameConnection;
 
 /**
  * Bridge between OkHttp's application and network layers. This class exposes high-level application
  * layer primitives: connections, requests, responses, and streams.
+ *
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
  */
 public final class Transmitter {
-  public final OkHttpClient client;
-  public final RealConnectionPool connectionPool;
-  public final Call call;
-  public final EventListener eventListener;
+  private final OkHttpClient client;
+  private final RealConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
 
   private @Nullable Object callStackTrace;
 
   private Request request;
-  private volatile boolean canceled;
-  private volatile StreamAllocation streamAllocation;
+  private ExchangeFinder exchangeFinder;
+
+  // Guarded by connectionPool.
+  public RealConnection connection;
+  private Exchange exchange;
+  private boolean canceled;
+  private boolean noMoreExchanges;
 
   public Transmitter(OkHttpClient client, Call call) {
     this.client = client;
@@ -73,8 +74,9 @@ public Transmitter(OkHttpClient client, Call call) {
     this.eventListener = client.eventListenerFactory().create(call);
   }
 
-  public void initCallStackTrace(@Nullable Object callStackTrace) {
-    this.callStackTrace = callStackTrace;
+  public void callStart() {
+    this.callStackTrace = Platform.get().getStackTraceForCloseable(""response.body().close()"");
+    eventListener.callStart(call);
   }
 
   /**
@@ -83,19 +85,18 @@ public void initCallStackTrace(@Nullable Object callStackTrace) {
    */
   public void prepareToConnect(Request request) {
     if (this.request != null) {
-      if (sameConnection(this.request.url(), request.url())) {
-        return; // Already ready.
-      }
-      if (streamAllocation != null) {
-        streamAllocation.transmitterReleaseConnection(false);
-        streamAllocation = null;
+      if (sameConnection(this.request.url(), request.url())) return; // Already ready.
+      if (exchange != null) throw new IllegalStateException();
+
+      if (exchangeFinder != null) {
+        maybeReleaseConnection(null, true);
+        exchangeFinder = null;
       }
     }
 
     this.request = request;
-    this.streamAllocation = new StreamAllocation(this,
-        Internal.instance.realConnectionPool(client.connectionPool()), createAddress(request.url()),
-        call, eventListener, callStackTrace);
+    this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()),
+        call, eventListener);
   }
 
   private Address createAddress(HttpUrl url) {
@@ -113,283 +114,161 @@ private Address createAddress(HttpUrl url) {
         client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
   }
 
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    canceled = true;
-    StreamAllocation streamAllocation = this.streamAllocation;
-    if (streamAllocation != null) streamAllocation.cancel();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  public void releaseStreamForException() {
-    streamAllocation.releaseStreamForException();
-  }
-
-  public void noNewStreamsOnConnection() {
-    connection().noNewStreams();
-  }
-
-  public RealWebSocket.Streams newWebSocketStreams() {
-    return streamAllocation.connection().newWebSocketStreams(this);
-  }
-
-  public void socketTimeout(int timeout) throws SocketException {
-    streamAllocation.connection().socket().setSoTimeout(timeout);
-  }
-
-  /** Returns the connection that carries the allocated stream. */
-  public RealConnection newStream(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
-    return streamAllocation.connection();
-  }
-
-  public Handshake handshake() {
-    return streamAllocation.connection().handshake();
-  }
-
-  public boolean isConnectionMultiplexed() {
-    return streamAllocation.connection().isMultiplexed();
-  }
-
-  public void noMoreStreamsOnCall() {
-    if (streamAllocation != null) {
-      streamAllocation.transmitterReleaseConnection(true);
+  /** Returns a new exchange to carry a new request and response. */
+  public Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    synchronized (connectionPool) {
+      if (noMoreExchanges) throw new IllegalStateException(""released"");
+      if (exchange != null) throw new IllegalStateException(""exchange != null"");
     }
-  }
-
-  public boolean canRetry() {
-    return streamAllocation.canRetry();
-  }
-
-  public Route route() {
-    return streamAllocation.route();
-  }
-
-  public boolean hasCodec() {
-    return streamAllocation != null && streamAllocation.codec() != null;
-  }
-
-  public void callStart() {
-    eventListener.callStart(call);
-  }
 
-  public void callFailed(IOException e) {
-    eventListener.callFailed(call, e);
-  }
+    HttpCodec httpCodec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);
+    Exchange result = new Exchange(this, call, eventListener, exchangeFinder, httpCodec);
 
-  public void writeRequestHeaders(Request request) throws IOException {
-    try {
-      eventListener.requestHeadersStart(call);
-      streamAllocation.codec().writeRequestHeaders(request);
-      eventListener.requestHeadersEnd(call, request);
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
+    synchronized (connectionPool) {
+      this.exchange = result;
+      return result;
     }
   }
 
-  public Sink createRequestBody(Request request) throws IOException {
-    long contentLength = request.body().contentLength();
-    eventListener.requestBodyStart(call);
-    Sink rawRequestBody = streamAllocation.codec().createRequestBody(request, contentLength);
-    return new RequestBodySink(rawRequestBody, contentLength);
-  }
-
-  public void flushRequest() throws IOException {
-    try {
-      streamAllocation.codec().flushRequest();
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
-    }
-  }
+  public void acquireConnectionNoEvents(RealConnection connection) {
+    assert (Thread.holdsLock(connectionPool));
 
-  public void finishRequest() throws IOException {
-    try {
-      streamAllocation.codec().finishRequest();
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
-    }
+    if (this.connection != null) throw new IllegalStateException();
+    this.connection = connection;
+    connection.transmitters.add(new TransmitterReference(this, callStackTrace));
   }
 
-  public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    try {
-      eventListener.responseHeadersStart(call);
-      return streamAllocation.codec().readResponseHeaders(expectContinue);
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
+  /**
+   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
+   * caller should close.
+   */
+  public @Nullable Socket releaseConnectionNoEvents() {
+    assert (Thread.holdsLock(connectionPool));
+
+    int index = -1;
+    for (int i = 0, size = this.connection.transmitters.size(); i < size; i++) {
+      Reference<Transmitter> reference = this.connection.transmitters.get(i);
+      if (reference.get() == this) {
+        index = i;
+        break;
+      }
     }
-  }
-
-  public void responseHeadersEnd(Response response) {
-    eventListener.responseHeadersEnd(call, response);
-  }
 
-  public ResponseBody openResponseBody(Response response) throws IOException {
-    try {
-      streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
-      String contentType = response.header(""Content-Type"");
-      HttpCodec codec = streamAllocation.codec();
-      long contentLength = codec.reportedContentLength(response);
-      Source rawSource = codec.openResponseBodySource(response);
-      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
-      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
-    }
-  }
+    if (index == -1) throw new IllegalStateException();
 
-  public DeferredTrailers deferredTrailers() {
-    return new DeferredTrailers() {
-      HttpCodec codec = streamAllocation.codec();
+    RealConnection released = this.connection;
+    released.transmitters.remove(index);
+    this.connection = null;
 
-      @Override public Headers trailers() throws IOException {
-        return codec.trailers();
+    if (released.transmitters.isEmpty()) {
+      released.idleAtNanos = System.nanoTime();
+      if (connectionPool.connectionBecameIdle(released)) {
+        return released.socket();
       }
-    };
-  }
-
-  public boolean supportsUrl(HttpUrl url) {
-    return streamAllocation.connection().supportsUrl(url);
-  }
+    }
 
-  public void acquireConnection(RealConnection connection) {
-    streamAllocation.transmitterAcquireConnection(connection);
+    return null;
   }
 
-  public RealConnection connection() {
-    return streamAllocation.connection();
+  public void exchangeDoneDueToException() {
+    synchronized (connectionPool) {
+      if (noMoreExchanges) throw new IllegalStateException();
+      exchange = null;
+    }
   }
 
-  public void responseBodyComplete(long bytesRead, IOException e) {
-    if (e != null) {
-      streamAllocation.streamFailed(e);
-    }
-    if (streamAllocation != null) {
-      streamAllocation.responseBodyComplete(bytesRead, e);
+  public void exchangeDone(@Nullable IOException e) {
+    synchronized (connectionPool) {
+      if (exchange == null) throw new IllegalStateException(""exchange == null"");
+      exchange.connection().successCount++;
+      exchange = null;
     }
+    maybeReleaseConnection(e, false);
   }
 
-  /** A request body that fires events when it completes. */
-  private final class RequestBodySink extends ForwardingSink {
-    /** The exact number of bytes to be written, or -1L if that is unknown. */
-    private long contentLength;
-    private long bytesReceived;
-    private boolean closed;
-
-    RequestBodySink(Sink delegate, long contentLength) {
-      super(delegate);
-      this.contentLength = contentLength;
+  public void noMoreExchanges(IOException e) {
+    synchronized (connectionPool) {
+      noMoreExchanges = true;
     }
+    maybeReleaseConnection(e, false);
+  }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException(""closed"");
-      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
-        throw new ProtocolException(""expected "" + contentLength
-            + "" bytes but received "" + (bytesReceived + byteCount));
-      }
-      try {
-        super.write(source, byteCount);
-        this.bytesReceived += byteCount;
-      } catch (IOException e) {
-        streamAllocation.streamFailed(e);
-        throw e;
+  /**
+   * Release the connection if it is no longer needed. This is called after each exchange completes
+   * and after the call signals that no more exchanges are expected.
+   *
+   * @param force true to release the connection even if more exchanges are expected for the call.
+   */
+  private void maybeReleaseConnection(@Nullable IOException e, boolean force) {
+    Socket socket;
+    Connection releasedConnection;
+    boolean callEnd;
+    synchronized (connectionPool) {
+      if (force && exchange != null) {
+        throw new IllegalStateException(""cannot release connection while it is in use"");
       }
+      releasedConnection = this.connection;
+      socket = this.connection != null && exchange == null && (force || noMoreExchanges)
+          ? releaseConnectionNoEvents()
+          : null;
+      if (this.connection != null) releasedConnection = null;
+      callEnd = noMoreExchanges && exchange == null;
     }
+    closeQuietly(socket);
 
-    @Override public void flush() throws IOException {
-      try {
-        super.flush();
-      } catch (IOException e) {
-        streamAllocation.streamFailed(e);
-        throw e;
-      }
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      if (contentLength != -1L && bytesReceived != contentLength) {
-        throw new ProtocolException(""unexpected end of stream"");
-      }
-      eventListener.requestBodyEnd(call, bytesReceived);
-      try {
-        super.close();
-      } catch (IOException e) {
-        streamAllocation.streamFailed(e);
-        throw e;
+    if (callEnd) {
+      e = Internal.instance.timeoutExit(call, e);
+      if (e != null) {
+        eventListener.callFailed(call, e);
+      } else {
+        eventListener.callEnd(call);
       }
     }
   }
 
-  /** A response body that fires events when it completes. */
-  final class ResponseBodySource extends ForwardingSource {
-    private long contentLength;
-    private long bytesReceived;
-    private boolean completed;
-    private boolean closed;
-
-    ResponseBodySource(Source delegate, long contentLength) {
-      super(delegate);
-      this.contentLength = contentLength;
+  public boolean canRetry() {
+    return exchangeFinder.canRetry();
+  }
 
-      if (contentLength == 0L) {
-        complete(null);
-      }
+  public boolean hasExchange() {
+    synchronized (connectionPool) {
+      return exchange != null;
     }
+  }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException(""closed"");
-      try {
-        long read = delegate().read(sink, byteCount);
-        if (read == -1L) {
-          complete(null);
-          return -1L;
-        }
-
-        long newBytesReceived = bytesReceived + read;
-        if (contentLength != -1L && newBytesReceived > contentLength) {
-          throw new ProtocolException(""expected "" + contentLength
-              + "" bytes but received "" + newBytesReceived);
-        }
-
-        bytesReceived = newBytesReceived;
-        if (newBytesReceived == contentLength) {
-          complete(null);
-        }
-
-        return read;
-      } catch (IOException e) {
-        complete(e);
-        throw e;
-      }
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    Exchange exchangeToCancel;
+    RealConnection connectionToCancel;
+    synchronized (connectionPool) {
+      canceled = true;
+      exchangeToCancel = exchange;
+      connectionToCancel = exchangeFinder != null && exchangeFinder.connectingConnection() != null
+          ? exchangeFinder.connectingConnection()
+          : connection;
     }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      super.close();
-      complete(null);
+    if (exchangeToCancel != null) {
+      exchangeToCancel.cancel();
+    } else if (connectionToCancel != null) {
+      connectionToCancel.cancel();
     }
+  }
 
-    void complete(IOException e) {
-      if (completed) return;
-      completed = true;
-      responseBodyComplete(bytesReceived, e);
+  public boolean isCanceled() {
+    synchronized (connectionPool) {
+      return canceled;
     }
   }
 
@@ -39,8 +39,8 @@ public ConnectInterceptor(OkHttpClient client) {
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
     boolean doExtensiveHealthChecks = !request.method().equals(""GET"");
-    RealConnection connection = transmitter.newStream(chain, doExtensiveHealthChecks);
+    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);
 
-    return realChain.proceed(request, transmitter, connection);
+    return realChain.proceed(request, transmitter, exchange);
   }
 }
@@ -0,0 +1,270 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.SocketException;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Transmitter;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.ws.RealWebSocket;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Transmits a single HTTP request and a response pair. This layers connection management and events
+ * on {@link HttpCodec}, which handles the actual I/O.
+ */
+public final class Exchange {
+  final Transmitter transmitter;
+  final Call call;
+  final EventListener eventListener;
+  final ExchangeFinder finder;
+  final HttpCodec codec;
+
+  public Exchange(Transmitter transmitter, Call call, EventListener eventListener,
+      ExchangeFinder finder, HttpCodec codec) {
+    this.transmitter = transmitter;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.finder = finder;
+    this.codec = codec;
+  }
+
+  public RealConnection connection() {
+    return codec.connection();
+  }
+
+  public void writeRequestHeaders(Request request) throws IOException {
+    try {
+      eventListener.requestHeadersStart(call);
+      codec.writeRequestHeaders(request);
+      eventListener.requestHeadersEnd(call, request);
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public Sink createRequestBody(Request request) throws IOException {
+    long contentLength = request.body().contentLength();
+    eventListener.requestBodyStart(call);
+    Sink rawRequestBody = codec.createRequestBody(request, contentLength);
+    return new RequestBodySink(rawRequestBody, contentLength);
+  }
+
+  public void flushRequest() throws IOException {
+    try {
+      codec.flushRequest();
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void finishRequest() throws IOException {
+    try {
+      codec.finishRequest();
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public @Nullable Response.Builder readResponseHeaders(
+      boolean expectContinue) throws IOException {
+    try {
+      eventListener.responseHeadersStart(call);
+      Response.Builder result = codec.readResponseHeaders(expectContinue);
+      if (result != null) {
+        Internal.instance.initExchange(result, this);
+      }
+      return result;
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void responseHeadersEnd(Response response) {
+    eventListener.responseHeadersEnd(call, response);
+  }
+
+  public ResponseBody openResponseBody(Response response) throws IOException {
+    try {
+      eventListener.responseBodyStart(call);
+      String contentType = response.header(""Content-Type"");
+      long contentLength = codec.reportedContentLength(response);
+      Source rawSource = codec.openResponseBodySource(response);
+      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
+      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public Headers trailers() throws IOException {
+    return codec.trailers();
+  }
+
+  public RealWebSocket.Streams newWebSocketStreams() throws SocketException {
+    return codec.connection().newWebSocketStreams(this);
+  }
+
+  public void noNewExchangesOnConnection() {
+    codec.connection().noNewExchanges();
+  }
+
+  public void cancel() {
+    codec.cancel();
+  }
+
+  void trackFailure(IOException e) {
+    finder.trackFailure();
+    codec.connection().trackFailure(e);
+  }
+
+  void responseBodyComplete(long bytesRead, @Nullable IOException e) {
+    if (e != null) {
+      trackFailure(e);
+    }
+    eventListener.responseBodyEnd(call, bytesRead);
+    transmitter.exchangeDone(e);
+  }
+
+  /** A request body that fires events when it completes. */
+  private final class RequestBodySink extends ForwardingSink {
+    /** The exact number of bytes to be written, or -1L if that is unknown. */
+    private long contentLength;
+    private long bytesReceived;
+    private boolean closed;
+
+    RequestBodySink(Sink delegate, long contentLength) {
+      super(delegate);
+      this.contentLength = contentLength;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException(""closed"");
+      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
+        throw new ProtocolException(""expected "" + contentLength
+            + "" bytes but received "" + (bytesReceived + byteCount));
+      }
+      try {
+        super.write(source, byteCount);
+        this.bytesReceived += byteCount;
+      } catch (IOException e) {
+        trackFailure(e);
+        throw e;
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      try {
+        super.flush();
+      } catch (IOException e) {
+        trackFailure(e);
+        throw e;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      if (contentLength != -1L && bytesReceived != contentLength) {
+        throw new ProtocolException(""unexpected end of stream"");
+      }
+      eventListener.requestBodyEnd(call, bytesReceived);
+      try {
+        super.close();
+      } catch (IOException e) {
+        trackFailure(e);
+        throw e;
+      }
+    }
+  }
+
+  /** A response body that fires events when it completes. */
+  final class ResponseBodySource extends ForwardingSource {
+    private long contentLength;
+    private long bytesReceived;
+    private boolean completed;
+    private boolean closed;
+
+    ResponseBodySource(Source delegate, long contentLength) {
+      super(delegate);
+      this.contentLength = contentLength;
+
+      if (contentLength == 0L) {
+        complete(null);
+      }
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException(""closed"");
+      try {
+        long read = delegate().read(sink, byteCount);
+        if (read == -1L) {
+          complete(null);
+          return -1L;
+        }
+
+        long newBytesReceived = bytesReceived + read;
+        if (contentLength != -1L && newBytesReceived > contentLength) {
+          throw new ProtocolException(""expected "" + contentLength
+              + "" bytes but received "" + newBytesReceived);
+        }
+
+        bytesReceived = newBytesReceived;
+        if (newBytesReceived == contentLength) {
+          complete(null);
+        }
+
+        return read;
+      } catch (IOException e) {
+        complete(e);
+        throw e;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      super.close();
+      complete(null);
+    }
+
+    void complete(IOException e) {
+      if (completed) return;
+      completed = true;
+      responseBodyComplete(bytesReceived, e);
+    }
+  }
+}
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.util.List;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Route;
+import okhttp3.internal.Transmitter;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpCodec;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
+ *
+ * <ol>
+ *   <li>If the current call already has a connection that can satisfy the request it is used.
+ *       Using the same connection for an initial exchange and its follow-ups may improve locality.
+ *
+ *   <li>If there is a connection in the pool that can satisfy the request it is used. Note that
+ *       it is possible for shared exchanges to make requests to different host names! See {@link
+ *       RealConnection#isEligible} for details.
+ *
+ *   <li>If there's no existing connection, make a list of routes (which may require blocking DNS
+ *       lookups) and attempt a new connection them. When failures occur, retries iterate the list
+ *       of available routes.
+ * </ol>
+ *
+ * <p>If the pool gains an eligible connection while DNS, TCP, or TLS work is in flight, this finder
+ * will prefer pooled connections. Only pooled HTTP/2 connections are used for such de-duplication.
+ *
+ * <p>It is possible to cancel the finding process.
+ */
+public final class ExchangeFinder {
+  private final Transmitter transmitter;
+  private final Address address;
+  private final RealConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
+
+  private RouteSelector.Selection routeSelection;
+
+  // State guarded by connectionPool.
+  private final RouteSelector routeSelector;
+  private RealConnection connectingConnection;
+  private boolean hasStreamFailure;
+
+  public ExchangeFinder(Transmitter transmitter, RealConnectionPool connectionPool,
+      Address address, Call call, EventListener eventListener) {
+    this.transmitter = transmitter;
+    this.connectionPool = connectionPool;
+    this.address = address;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.routeSelector = new RouteSelector(
+        address, connectionPool.routeDatabase, call, eventListener);
+  }
+
+  public HttpCodec find(
+      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    int connectTimeout = chain.connectTimeoutMillis();
+    int readTimeout = chain.readTimeoutMillis();
+    int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
+    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+    try {
+      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
+      return resultConnection.newCodec(client, chain);
+    } catch (RouteException e) {
+      trackFailure();
+      throw e;
+    } catch (IOException e) {
+      trackFailure();
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
+    while (true) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          pingIntervalMillis, connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        candidate.noNewExchanges();
+        continue;
+      }
+
+      return candidate;
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
+    boolean foundPooledConnection = false;
+    RealConnection result = null;
+    Route selectedRoute = null;
+    RealConnection releasedConnection;
+    Socket toClose;
+    synchronized (connectionPool) {
+      if (transmitter.isCanceled()) throw new IOException(""Canceled"");
+      hasStreamFailure = false; // This is a fresh attempt.
+
+      Route previousRoute = retryCurrentRoute()
+          ? transmitter.connection.route()
+          : null;
+
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new exchanges.
+      releasedConnection = transmitter.connection;
+      toClose = transmitter.connection != null && transmitter.connection.noNewExchanges
+          ? transmitter.releaseConnectionNoEvents()
+          : null;
+
+      if (transmitter.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = transmitter.connection;
+        releasedConnection = null;
+      }
+
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
+          foundPooledConnection = true;
+          result = transmitter.connection;
+        } else {
+          selectedRoute = previousRoute;
+        }
+      }
+    }
+    closeQuietly(toClose);
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result;
+    }
+
+    // If we need a route selection, make one. This is a blocking operation.
+    boolean newRouteSelection = false;
+    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+      newRouteSelection = true;
+      routeSelection = routeSelector.next();
+    }
+
+    List<Route> routes = null;
+    synchronized (connectionPool) {
+      if (transmitter.isCanceled()) throw new IOException(""Canceled"");
+
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        routes = routeSelection.getAll();
+        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, false)) {
+          foundPooledConnection = true;
+          result = transmitter.connection;
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
+        result = new RealConnection(connectionPool, selectedRoute);
+        connectingConnection = result;
+      }
+    }
+
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+      return result;
+    }
+
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
+    connectionPool.routeDatabase.connected(result.route());
+
+    Socket socket = null;
+    synchronized (connectionPool) {
+      connectingConnection = null;
+      // Last attempt at connection coalescing, which only occurs if we attempted multiple
+      // concurrent connections to the same host.
+      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
+        // We lost the race! Close the connection we created and return the pooled connection.
+        result.noNewExchanges = true;
+        socket = result.socket();
+        result = transmitter.connection;
+      } else {
+        connectionPool.put(result);
+        transmitter.acquireConnectionNoEvents(result);
+      }
+    }
+    closeQuietly(socket);
+
+    eventListener.connectionAcquired(call, result);
+    return result;
+  }
+
+  public RealConnection connectingConnection() {
+    assert (Thread.holdsLock(connectionPool));
+    return connectingConnection;
+  }
+
+  public void trackFailure() {
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      hasStreamFailure = true; // Permit retries.
+    }
+  }
+
+  public boolean canRetry() {
+    synchronized (connectionPool) {
+      // Don't try if the failure wasn't our fault!
+      if (!hasStreamFailure) return false;
+
+      return retryCurrentRoute()
+          || (routeSelection != null && routeSelection.hasNext())
+          || routeSelector.hasNext();
+    }
+  }
+
+  /**
+   * Return true if the route used for the current connection should be retried, even if the
+   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
+   * coalesced connections.
+   */
+  private boolean retryCurrentRoute() {
+    return transmitter.connection != null
+        && transmitter.connection.routeFailureCount == 0
+        && Util.sameConnection(transmitter.connection.route().address().url(), address.url());
+  }
+}
@@ -99,10 +99,10 @@ public final class RealConnection extends Http2Connection.Listener implements Co
   // The fields below track connection state and are guarded by connectionPool.
 
   /**
-   * If true, no new streams can be created on this connection. Once true this is always true.
+   * If true, no new exchanges can be created on this connection. Once true this is always true.
    * Guarded by {@link #connectionPool}.
    */
-  public boolean noNewStreams;
+  public boolean noNewExchanges;
 
   /**
    * The number of times there was a problem establishing a stream that could be due to route
@@ -130,11 +130,11 @@ public RealConnection(RealConnectionPool connectionPool, Route route) {
     this.route = route;
   }
 
-  /** Prevent further streams from being created on this connection. */
-  public void noNewStreams() {
+  /** Prevent further exchanges from being created on this connection. */
+  public void noNewExchanges() {
     assert (!Thread.holdsLock(connectionPool));
     synchronized (connectionPool) {
-      noNewStreams = true;
+      noNewExchanges = true;
     }
   }
 
@@ -472,8 +472,8 @@ private Request createTunnelRequest() throws IOException {
    * {@code route} is the resolved route for a connection.
    */
   public boolean isEligible(Address address, @Nullable List<Route> routes) {
-    // If this connection is not accepting new streams, we're done.
-    if (transmitters.size() >= allocationLimit || noNewStreams) return false;
+    // If this connection is not accepting new exchanges, we're done.
+    if (transmitters.size() >= allocationLimit || noNewExchanges) return false;
 
     // If the non-host fields of the address don't overlap, we're done.
     if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
@@ -548,11 +548,12 @@ public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain) throws S
     }
   }
 
-  public RealWebSocket.Streams newWebSocketStreams(Transmitter transmitter) {
-    noNewStreams();
+  public RealWebSocket.Streams newWebSocketStreams(Exchange exchange) throws SocketException {
+    socket.setSoTimeout(0);
+    noNewExchanges();
     return new RealWebSocket.Streams(true, source, sink) {
       @Override public void close() throws IOException {
-        transmitter.responseBodyComplete(-1L, null);
+        exchange.responseBodyComplete(-1L, null);
       }
     };
   }
@@ -628,34 +629,35 @@ public boolean isMultiplexed() {
 
   /**
    * Track a failure using this connection. This may prevent both the connection and its route from
-   * being used for future streams.
+   * being used for future exchanges.
    */
   void trackFailure(@Nullable IOException e) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (e instanceof StreamResetException) {
-      ErrorCode errorCode = ((StreamResetException) e).errorCode;
-      if (errorCode == ErrorCode.REFUSED_STREAM) {
-        // Retry REFUSED_STREAM errors once on the same connection.
-        refusedStreamCount++;
-        if (refusedStreamCount > 1) {
-          noNewStreams = true;
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      if (e instanceof StreamResetException) {
+        ErrorCode errorCode = ((StreamResetException) e).errorCode;
+        if (errorCode == ErrorCode.REFUSED_STREAM) {
+          // Retry REFUSED_STREAM errors once on the same connection.
+          refusedStreamCount++;
+          if (refusedStreamCount > 1) {
+            noNewExchanges = true;
+            routeFailureCount++;
+          }
+        } else if (errorCode != ErrorCode.CANCEL) {
+          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
+          noNewExchanges = true;
           routeFailureCount++;
         }
-      } else if (errorCode != ErrorCode.CANCEL) {
-        // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
-        noNewStreams = true;
-        routeFailureCount++;
-      }
-    } else if (!isMultiplexed() || e instanceof ConnectionShutdownException) {
-      noNewStreams = true;
+      } else if (!isMultiplexed() || e instanceof ConnectionShutdownException) {
+        noNewExchanges = true;
 
-      // If this route hasn't completed a call, avoid it for new connections.
-      if (successCount == 0) {
-        if (e != null) {
-          connectionPool.connectFailed(route, e);
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (successCount == 0) {
+          if (e != null) {
+            connectionPool.connectFailed(route, e);
+          }
+          routeFailureCount++;
         }
-        routeFailureCount++;
       }
     }
   }
@@ -108,7 +108,7 @@ boolean transmitterAcquirePooledConnection(Address address, Transmitter transmit
     for (RealConnection connection : connections) {
       if (requireMultiplexed && !connection.isMultiplexed()) continue;
       if (!connection.isEligible(address, routes)) continue;
-      transmitter.acquireConnection(connection);
+      transmitter.acquireConnectionNoEvents(connection);
       return true;
     }
     return false;
@@ -127,9 +127,9 @@ void put(RealConnection connection) {
    * Notify this pool that {@code connection} has become idle. Returns true if the connection has
    * been removed from the pool and should be closed.
    */
-  boolean connectionBecameIdle(RealConnection connection) {
+  public boolean connectionBecameIdle(RealConnection connection) {
     assert (Thread.holdsLock(this));
-    if (connection.noNewStreams || maxIdleConnections == 0) {
+    if (connection.noNewExchanges || maxIdleConnections == 0) {
       connections.remove(connection);
       return true;
     } else {
@@ -144,7 +144,7 @@ public void evictAll() {
       for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
         RealConnection connection = i.next();
         if (connection.transmitters.isEmpty()) {
-          connection.noNewStreams = true;
+          connection.noNewExchanges = true;
           evictedConnections.add(connection);
           i.remove();
         }
@@ -237,7 +237,7 @@ private int pruneAndGetAllocationCount(RealConnection connection, long now) {
       Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);
 
       references.remove(i);
-      connection.noNewStreams = true;
+      connection.noNewExchanges = true;
 
       // If this was the last allocation, the connection is eligible for immediate eviction.
       if (references.isEmpty()) {
@@ -1,455 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.lang.ref.Reference;
-import java.net.Socket;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Transmitter;
-import okhttp3.internal.Transmitter.TransmitterReference;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpCodec;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * This class coordinates the relationship between three entities:
- *
- * <ul>
- *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *         potentially slow to establish so it is necessary to be able to cancel a connection
- *         currently being connected.
- *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *         connections. Each connection has its own allocation limit, which defines how many
- *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Transmitters:</strong> a logical sequence of streams, typically an initial
- *         request and its follow up requests. We prefer to keep all streams of a single {@link
- *         Call} on the same connection for better behavior and locality.
- * </ul>
- *
- * <p>Instances of this class act on behalf of a single transmitter, using one or more streams over
- * one or more connections. This class has APIs to release each of the above resources:
- *
- * <ul>
- *     <li>{@link RealConnection#noNewStreams} prevents the connection from being used for new
- *         streams in the future. Use this after a {@code Connection: close} header, or when the
- *         connection may be inconsistent.
- *     <li>{@link #responseBodyComplete} releases the active stream from this allocation.
- *         Note that only one stream may be active at a given time, so it is necessary to call
- *         it before creating a subsequent stream with {@link #newStream}.
- *     <li>{@link #transmitterReleaseConnection} removes the transmitter's hold on the connection.
- *         Note that this won't immediately free the connection if there is a stream still
- *         lingering. That happens when a call is complete but its response body has yet to be fully
- *         consumed.
- * </ul>
- *
- * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
- * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
- * but not the other streams sharing its connection. But if the TLS handshake is still in progress
- * then canceling may break the entire connection.
- */
-public final class StreamAllocation {
-  public final Transmitter transmitter;
-  public final Address address;
-  private final RealConnectionPool connectionPool;
-  public final Call call;
-  public final EventListener eventListener;
-  private final Object callStackTrace;
-
-  private RouteSelector.Selection routeSelection;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private RealConnection connectingConnection;
-  private RealConnection connection;
-  private boolean released;
-  private boolean canceled;
-  private boolean hasStreamFailure;
-  private HttpCodec codec;
-
-  public StreamAllocation(Transmitter transmitter, RealConnectionPool connectionPool,
-      Address address, Call call, EventListener eventListener, Object callStackTrace) {
-    this.transmitter = transmitter;
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.routeSelector = new RouteSelector(
-        address, connectionPool.routeDatabase, call, eventListener);
-    this.callStackTrace = callStackTrace;
-  }
-
-  public HttpCodec newStream(
-      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    int connectTimeout = chain.connectTimeoutMillis();
-    int readTimeout = chain.readTimeoutMillis();
-    int writeTimeout = chain.writeTimeoutMillis();
-    int pingIntervalMillis = client.pingIntervalMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, chain);
-
-      synchronized (connectionPool) {
-        codec = resultCodec;
-        return resultCodec;
-      }
-    } catch (RouteException e) {
-      streamFailed(e.getLastConnectException());
-      throw e;
-    } catch (IOException e) {
-      streamFailed(e);
-      throw new RouteException(e);
-    }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
-      boolean doExtensiveHealthChecks) throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          pingIntervalMillis, connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        candidate.noNewStreams();
-        continue;
-      }
-
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
-    boolean foundPooledConnection = false;
-    RealConnection result = null;
-    Route selectedRoute = null;
-    RealConnection releasedConnection;
-    Socket toClose;
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException(""released"");
-      if (codec != null) throw new IllegalStateException(""codec != null"");
-      if (canceled) throw new IOException(""Canceled"");
-
-      Route previousRoute = retryCurrentRoute()
-          ? connection.route()
-          : null;
-
-      // Attempt to use an already-allocated connection. We need to be careful here because our
-      // already-allocated connection may have been restricted from creating new streams.
-      releasedConnection = connection;
-      toClose = connection != null && connection.noNewStreams
-          ? transmitterReleaseConnection()
-          : null;
-
-      if (connection != null) {
-        // We had an already-allocated connection and it's good.
-        result = connection;
-        releasedConnection = null;
-      }
-
-      if (result == null) {
-        // Attempt to get a connection from the pool.
-        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
-          foundPooledConnection = true;
-          result = connection;
-        } else {
-          selectedRoute = previousRoute;
-        }
-      }
-    }
-    closeQuietly(toClose);
-
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-    }
-    if (result != null) {
-      // If we found an already-allocated or pooled connection, we're done.
-      return result;
-    }
-
-    // If we need a route selection, make one. This is a blocking operation.
-    boolean newRouteSelection = false;
-    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
-      newRouteSelection = true;
-      routeSelection = routeSelector.next();
-    }
-
-    List<Route> routes = null;
-    synchronized (connectionPool) {
-      if (canceled) throw new IOException(""Canceled"");
-
-      if (newRouteSelection) {
-        // Now that we have a set of IP addresses, make another attempt at getting a connection from
-        // the pool. This could match due to connection coalescing.
-        routes = routeSelection.getAll();
-        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, false)) {
-          foundPooledConnection = true;
-          result = connection;
-        }
-      }
-
-      if (!foundPooledConnection) {
-        if (selectedRoute == null) {
-          selectedRoute = routeSelection.next();
-        }
-
-        // Create a connection and assign it to this allocation immediately. This makes it possible
-        // for an asynchronous cancel() to interrupt the handshake we're about to do.
-        hasStreamFailure = false;
-        result = new RealConnection(connectionPool, selectedRoute);
-        connectingConnection = result;
-      }
-    }
-
-    // If we found a pooled connection on the 2nd time around, we're done.
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-      return result;
-    }
-
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
-        connectionRetryEnabled, call, eventListener);
-    connectionPool.routeDatabase.connected(result.route());
-
-    Socket socket = null;
-    synchronized (connectionPool) {
-      connectingConnection = null;
-      // Last attempt at connection coalescing, which only occurs if we attempted multiple
-      // concurrent connections to the same host.
-      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
-        // We lost the race! Close the connection we created and return the pooled connection.
-        result.noNewStreams = true;
-        socket = result.socket();
-        result = connection;
-      } else {
-        connectionPool.put(result);
-        transmitterAcquireConnection(result);
-      }
-    }
-    closeQuietly(socket);
-
-    eventListener.connectionAcquired(call, result);
-    return result;
-  }
-
-  public void responseBodyComplete(long bytesRead, IOException e) {
-    eventListener.responseBodyEnd(call, bytesRead);
-
-    Socket socket;
-    Connection releasedConnection;
-    boolean callEnd;
-    synchronized (connectionPool) {
-      if (codec == null) throw new IllegalStateException(""codec == null"");
-      connection.successCount++;
-      this.codec = null;
-      releasedConnection = connection;
-      socket = this.released
-          ? transmitterReleaseConnection()
-          : null;
-      if (connection != null) releasedConnection = null;
-      callEnd = this.released;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-
-    if (callEnd) {
-      e = Internal.instance.timeoutExit(call, e);
-    }
-    if (e != null) {
-      eventListener.callFailed(call, e);
-    } else if (callEnd) {
-      eventListener.callEnd(call);
-    }
-  }
-
-  public HttpCodec codec() {
-    synchronized (connectionPool) {
-      return codec;
-    }
-  }
-
-  public Route route() {
-    synchronized (connectionPool) {
-      return connection != null ? connection.route() : null;
-    }
-  }
-
-  public RealConnection connection() {
-    synchronized (connectionPool) {
-      return connection;
-    }
-  }
-
-  public void transmitterReleaseConnection(boolean callEnd) {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      this.released = true;
-      socket = connection != null && this.codec == null
-          ? transmitterReleaseConnection()
-          : null;
-      if (connection != null) releasedConnection = null;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      if (callEnd) {
-        Internal.instance.timeoutExit(call, null);
-      }
-      eventListener.connectionReleased(call, releasedConnection);
-      if (callEnd) {
-        eventListener.callEnd(call);
-      }
-    }
-  }
-
-  public void cancel() {
-    HttpCodec codecToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      codecToCancel = codec;
-      connectionToCancel = connectingConnection != null ? connectingConnection : connection;
-    }
-    if (codecToCancel != null) {
-      codecToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
-    }
-  }
-
-  public void releaseStreamForException() {
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException();
-      this.codec = null;
-    }
-  }
-
-  public void streamFailed(IOException e) {
-    synchronized (connectionPool) {
-      hasStreamFailure = true;
-      if (connection != null) {
-        connection.trackFailure(e);
-      }
-    }
-  }
-
-  /**
-   * Use this allocation to hold {@code connection}. Each use of this must be paired with a call to
-   * {@link #transmitterReleaseConnection} on the same connection.
-   */
-  public void transmitterAcquireConnection(RealConnection connection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (this.connection != null) throw new IllegalStateException();
-
-    this.connection = connection;
-    connection.transmitters.add(new TransmitterReference(transmitter, callStackTrace));
-  }
-
-  /**
-   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
-   * caller should close.
-   */
-  private @Nullable Socket transmitterReleaseConnection() {
-    int index = -1;
-    for (int i = 0, size = connection.transmitters.size(); i < size; i++) {
-      Reference<Transmitter> reference = connection.transmitters.get(i);
-      if (reference.get() == transmitter) {
-        index = i;
-        break;
-      }
-    }
-
-    if (index == -1) throw new IllegalStateException();
-
-    RealConnection released = this.connection;
-    released.transmitters.remove(index);
-    this.connection = null;
-
-    if (released.transmitters.isEmpty()) {
-      released.idleAtNanos = System.nanoTime();
-      if (connectionPool.connectionBecameIdle(released)) {
-        return released.socket();
-      }
-    }
-
-    return null;
-  }
-
-  public boolean canRetry() {
-    synchronized (connectionPool) {
-      // Don't try if the failure wasn't our fault!
-      if (!hasStreamFailure) return false;
-
-      return retryCurrentRoute()
-          || (routeSelection != null && routeSelection.hasNext())
-          || routeSelector.hasNext();
-    }
-  }
-
-  /**
-   * Return true if the route used for the current connection should be retried, even if the
-   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
-   * coalesced connections.
-   */
-  private boolean retryCurrentRoute() {
-    return connection != null
-        && connection.routeFailureCount == 0
-        && Util.sameConnection(connection.route().address().url(), address.url());
-  }
-
-  @Override public String toString() {
-    RealConnection connection = connection();
-    return connection != null ? connection.toString() : address.toString();
-  }
-}
@@ -20,9 +20,8 @@
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Transmitter;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.duplex.DuplexRequestBody;
 import okio.BufferedSink;
 import okio.Okio;
@@ -37,77 +36,73 @@ public CallServerInterceptor(boolean forWebSocket) {
 
   @Override public Response intercept(Chain chain) throws IOException {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Transmitter transmitter = realChain.transmitter();
+    Exchange exchange = realChain.exchange();
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
 
-    transmitter.writeRequestHeaders(request);
+    exchange.writeRequestHeaders(request);
 
     Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
       // If there's a ""Expect: 100-continue"" header on the request, wait for a ""HTTP/1.1 100
       // Continue"" response before transmitting the request body. If we don't get that, return
       // what we did get (such as a 4xx response) without ever transmitting the request body.
       if (""100-continue"".equalsIgnoreCase(request.header(""Expect""))) {
-        transmitter.flushRequest();
-        responseBuilder = transmitter.readResponseHeaders(true);
+        exchange.flushRequest();
+        responseBuilder = exchange.readResponseHeaders(true);
       }
 
       if (responseBuilder == null) {
         if (request.body() instanceof DuplexRequestBody) {
           // Prepare a duplex body so that the application can send a request body later.
-          transmitter.flushRequest();
-          BufferedSink bufferedRequestBody = Okio.buffer(transmitter.createRequestBody(request));
+          exchange.flushRequest();
+          BufferedSink bufferedRequestBody = Okio.buffer(exchange.createRequestBody(request));
           request.body().writeTo(bufferedRequestBody);
         } else {
           // Write the request body if the ""Expect: 100-continue"" expectation was met.
-          BufferedSink bufferedRequestBody = Okio.buffer(transmitter.createRequestBody(request));
+          BufferedSink bufferedRequestBody = Okio.buffer(exchange.createRequestBody(request));
           request.body().writeTo(bufferedRequestBody);
           bufferedRequestBody.close();
         }
-      } else if (!transmitter.isConnectionMultiplexed()) {
+      } else if (!exchange.connection().isMultiplexed()) {
         // If the ""Expect: 100-continue"" expectation wasn't met, prevent the HTTP/1 connection
         // from being reused. Otherwise we're still obligated to transmit the request body to
         // leave the connection in a consistent state.
-        transmitter.noNewStreamsOnConnection();
+        exchange.noNewExchangesOnConnection();
       }
     }
 
     if (!(request.body() instanceof DuplexRequestBody)) {
-      transmitter.finishRequest();
+      exchange.finishRequest();
     }
 
     if (responseBuilder == null) {
-      responseBuilder = transmitter.readResponseHeaders(false);
+      responseBuilder = exchange.readResponseHeaders(false);
     }
 
-    responseBuilder
+    Response response = responseBuilder
         .request(request)
-        .handshake(transmitter.handshake())
+        .handshake(exchange.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis());
-    Internal.instance.initDeferredTrailers(responseBuilder, transmitter.deferredTrailers());
-    Response response = responseBuilder.build();
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build();
 
     int code = response.code();
     if (code == 100) {
       // server sent a 100-continue even though we did not request one.
       // try again to read the actual response
-      responseBuilder = transmitter.readResponseHeaders(false);
-
-      responseBuilder
+      response = exchange.readResponseHeaders(false)
           .request(request)
-          .handshake(transmitter.handshake())
+          .handshake(exchange.connection().handshake())
           .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(System.currentTimeMillis());
-      Internal.instance.initDeferredTrailers(responseBuilder, transmitter.deferredTrailers());
-      response = responseBuilder.build();
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
 
       code = response.code();
     }
 
-    transmitter.responseHeadersEnd(response);
+    exchange.responseHeadersEnd(response);
 
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
@@ -116,13 +111,13 @@ public CallServerInterceptor(boolean forWebSocket) {
           .build();
     } else {
       response = response.newBuilder()
-          .body(transmitter.openResponseBody(response))
+          .body(exchange.openResponseBody(response))
           .build();
     }
 
     if (""close"".equalsIgnoreCase(response.request().header(""Connection""))
         || ""close"".equalsIgnoreCase(response.header(""Connection""))) {
-      transmitter.noNewStreamsOnConnection();
+      exchange.noNewExchangesOnConnection();
     }
 
     if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
@@ -16,6 +16,7 @@
 package okhttp3.internal.http;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -53,7 +54,7 @@ public interface HttpCodec {
    * @param expectContinue true to return null if this is an intermediate response with a ""100""
    *     response code. Otherwise this method never returns null.
    */
-  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
+  @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
 
   long reportedContentLength(Response response) throws IOException;
 
@@ -25,7 +25,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Transmitter;
-import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.Exchange;
 
 import static okhttp3.internal.Util.checkDuration;
 
@@ -39,7 +39,7 @@
 public final class RealInterceptorChain implements Interceptor.Chain {
   private final List<Interceptor> interceptors;
   private final Transmitter transmitter;
-  private final @Nullable RealConnection connection;
+  private final @Nullable Exchange exchange;
   private final int index;
   private final Request request;
   private final Call call;
@@ -49,11 +49,11 @@ public final class RealInterceptorChain implements Interceptor.Chain {
   private int calls;
 
   public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmitter,
-      @Nullable RealConnection connection, int index, Request request, Call call,
+      @Nullable Exchange exchange, int index, Request request, Call call,
       int connectTimeout, int readTimeout, int writeTimeout) {
     this.interceptors = interceptors;
     this.transmitter = transmitter;
-    this.connection = connection;
+    this.exchange = exchange;
     this.index = index;
     this.request = request;
     this.call = call;
@@ -62,8 +62,8 @@ public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmit
     this.writeTimeout = writeTimeout;
   }
 
-  @Override public Connection connection() {
-    return connection;
+  @Override public @Nullable Connection connection() {
+    return exchange != null ? exchange.connection() : null;
   }
 
   @Override public int connectTimeoutMillis() {
@@ -72,7 +72,7 @@ public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmit
 
   @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
     int millis = checkDuration(""timeout"", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, connection, index, request, call,
+    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
         millis, readTimeout, writeTimeout);
   }
 
@@ -82,7 +82,7 @@ public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmit
 
   @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
     int millis = checkDuration(""timeout"", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, connection, index, request, call,
+    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
         connectTimeout, millis, writeTimeout);
   }
 
@@ -92,14 +92,19 @@ public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmit
 
   @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
     int millis = checkDuration(""timeout"", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, connection, index, request, call,
+    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
         connectTimeout, readTimeout, millis);
   }
 
   public Transmitter transmitter() {
     return transmitter;
   }
 
+  public Exchange exchange() {
+    if (exchange == null) throw new IllegalStateException();
+    return exchange;
+  }
+
   @Override public Call call() {
     return call;
   }
@@ -109,35 +114,35 @@ public Transmitter transmitter() {
   }
 
   @Override public Response proceed(Request request) throws IOException {
-    return proceed(request, transmitter, connection);
+    return proceed(request, transmitter, exchange);
   }
 
-  public Response proceed(Request request, Transmitter transmitter, RealConnection connection)
+  public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange)
       throws IOException {
     if (index >= interceptors.size()) throw new AssertionError();
 
     calls++;
 
     // If we already have a stream, confirm that the incoming request will use it.
-    if (this.connection != null && !this.transmitter.supportsUrl(request.url())) {
+    if (this.exchange != null && !this.exchange.connection().supportsUrl(request.url())) {
       throw new IllegalStateException(""network interceptor "" + interceptors.get(index - 1)
           + "" must retain the same host and port"");
     }
 
     // If we already have a stream, confirm that this is the only call to chain.proceed().
-    if (this.connection != null && calls > 1) {
+    if (this.exchange != null && calls > 1) {
       throw new IllegalStateException(""network interceptor "" + interceptors.get(index - 1)
           + "" must call proceed() exactly once"");
     }
 
     // Call the next interceptor in the chain.
-    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, connection,
+    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange,
         index + 1, request, call, connectTimeout, readTimeout, writeTimeout);
     Interceptor interceptor = interceptors.get(index);
     Response response = interceptor.intercept(next);
 
     // Confirm that the next interceptor made its required call to chain.proceed().
-    if (connection != null && index + 1 < interceptors.size() && next.calls != 1) {
+    if (exchange != null && index + 1 < interceptors.size() && next.calls != 1) {
       throw new IllegalStateException(""network interceptor "" + interceptor
           + "" must call proceed() exactly once"");
     }
@@ -23,6 +23,7 @@
 import java.net.Proxy;
 import java.net.SocketTimeoutException;
 import java.security.cert.CertificateException;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.HttpUrl;
@@ -32,7 +33,9 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.Route;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Transmitter;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.connection.RouteException;
 import okhttp3.internal.http2.ConnectionShutdownException;
 
@@ -99,7 +102,7 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
       } finally {
         // The network call threw an exception. Release any resources.
         if (!success) {
-          transmitter.releaseStreamForException();
+          transmitter.exchangeDoneDueToException();
         }
       }
 
@@ -114,7 +117,9 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
 
       Request followUp;
       try {
-        followUp = followUpRequest(response, transmitter.route());
+        Exchange exchange = Internal.instance.exchange(response);
+        Route route = exchange != null ? exchange.connection().route() : null;
+        followUp = followUpRequest(response, route);
       } catch (IOException e) {
         throw e;
       }
@@ -125,7 +130,7 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
 
       closeQuietly(response.body());
 
-      if (transmitter.hasCodec()) {
+      if (transmitter.hasExchange()) {
         throw new IllegalStateException(""Closing the body of "" + response
             + "" didn't close its backing stream. Bad interceptor?"");
       }
@@ -209,7 +214,7 @@ private boolean isRecoverable(IOException e, boolean requestSendStarted) {
    * either add authentication headers, follow redirects or handle a client request timeout. If a
    * follow-up is either unnecessary or not applicable, this returns null.
    */
-  private Request followUpRequest(Response userResponse, Route route) throws IOException {
+  private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException {
     if (userResponse == null) throw new IllegalStateException();
     int responseCode = userResponse.code();
 
@@ -273,7 +273,7 @@ private Source newChunkedSource(HttpUrl url) {
   private Source newUnknownLengthSource() {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    realConnection.noNewStreams();
+    realConnection.noNewExchanges();
     return new UnknownLengthSource();
   }
 
@@ -380,7 +380,7 @@ private abstract class AbstractSource implements Source {
       try {
         return source.read(sink, byteCount);
       } catch (IOException e) {
-        realConnection.noNewStreams();
+        realConnection.noNewExchanges();
         responseBodyComplete();
         throw e;
       }
@@ -418,7 +418,7 @@ private class FixedLengthSource extends AbstractSource {
 
       long read = super.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        realConnection.noNewStreams(); // The server didn't supply the promised content length.
+        realConnection.noNewExchanges(); // The server didn't supply the promised content length.
         ProtocolException e = new ProtocolException(""unexpected end of stream"");
         responseBodyComplete();
         throw e;
@@ -435,7 +435,7 @@ private class FixedLengthSource extends AbstractSource {
       if (closed) return;
 
       if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        realConnection.noNewStreams(); // Unread bytes remain on the stream.
+        realConnection.noNewExchanges(); // Unread bytes remain on the stream.
         responseBodyComplete();
       }
 
@@ -466,7 +466,7 @@ private class ChunkedSource extends AbstractSource {
 
       long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        realConnection.noNewStreams(); // The server didn't supply the promised chunk length.
+        realConnection.noNewExchanges(); // The server didn't supply the promised chunk length.
         ProtocolException e = new ProtocolException(""unexpected end of stream"");
         responseBodyComplete();
         throw e;
@@ -501,7 +501,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        realConnection.noNewStreams(); // Unread bytes remain on the stream.
+        realConnection.noNewExchanges(); // Unread bytes remain on the stream.
         responseBodyComplete();
       }
       closed = true;
@@ -38,8 +38,8 @@
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Transmitter;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.Exchange;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -190,25 +190,20 @@ public void connect(OkHttpClient client) {
     call.timeout().clearTimeout();
     call.enqueue(new Callback() {
       @Override public void onResponse(Call call, Response response) {
-        Transmitter transmitter = Internal.instance.transmitter(call);
-
+        Streams streams;
         try {
-          checkResponse(response);
-        } catch (ProtocolException e) {
+          streams = extractStreamsFromResponse(response);
+        } catch (IOException e) {
           failWebSocket(e, response);
           closeQuietly(response);
           return;
         }
 
-        // Promote the HTTP streams into web socket streams.
-        Streams streams = transmitter.newWebSocketStreams();
-
         // Process all web socket messages.
         try {
           String name = ""OkHttp WebSocket "" + request.url().redact();
           initReaderAndWriter(name, streams);
           listener.onOpen(RealWebSocket.this, response);
-          transmitter.socketTimeout(0);
           loopReader();
         } catch (Exception e) {
           failWebSocket(e, null);
@@ -221,7 +216,7 @@ public void connect(OkHttpClient client) {
     });
   }
 
-  void checkResponse(Response response) throws ProtocolException {
+  Streams extractStreamsFromResponse(Response response) throws IOException {
     if (response.code() != 101) {
       throw new ProtocolException(""Expected HTTP 101 response but was '""
           + response.code() + "" "" + response.message() + ""'"");
@@ -246,6 +241,12 @@ void checkResponse(Response response) throws ProtocolException {
       throw new ProtocolException(""Expected 'Sec-WebSocket-Accept' header value '""
           + acceptExpected + ""' but was '"" + headerAccept + ""'"");
     }
+
+    Exchange exchange = Internal.instance.exchange(response);
+    if (exchange == null) {
+      throw new ProtocolException(""Web Socket exchange missing: bad interceptor?"");
+    }
+    return exchange.newWebSocketStreams();
   }
 
   public void initReaderAndWriter(String name, Streams streams) throws IOException {
"
https://github.com/square/okhttp/commit/e36d7ecc26be18021da3555fc8b14381df7af34d,"Fix flakiness in CallTest.cancelTagImmediatelyAfterEnqueue()  <enter> There's a race where the HTTP engine has been created, but not yet connected and the cancel isn't as immediate as it could be. Fix the test by making sure there's a response to be retrieved. <enter> With the upcoming connection pool changes we might make the implementation more robust. <enter>  Closes :  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/e36d7ecc26be18021da3555fc8b14381df7af34d,"@@ -1525,13 +1525,13 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
     Call call = client.newCall(new Request.Builder()
         .url(server.url(""/a""))
         .tag(""request"")
         .build());
     call.enqueue(callback);
     client.cancel(""request"");
-    assertEquals(0, server.getRequestCount());
     callback.await(server.url(""/a"")).assertFailure(""Canceled"");
   }
 
"
https://github.com/spring-projects/spring-boot/commit/8a0f0354dfed2fc6d4cb1b046ec03fe5b7ff1146,"Disable Log4J2's shutdown hook by default  <enter> Log4J2 enables its shutdown hook by default. When the JVM is exiting, this creates a race between logging that happens during the application context being closed and Log4J2 being shut down such that the logging is lost. <enter> This commit updates SpringBootConfigurationFactory so that it produces a custom sub-class of DefaultConfiguration that disables the shutdown hook by default. In addition to solving the problem described above, this also aligns the Log4J2 logging system with the logging.register-shutdown-hook property which defaults to false. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/8a0f0354dfed2fc6d4cb1b046ec03fe5b7ff1146,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -27,12 +27,18 @@
 import org.springframework.boot.logging.LoggingSystem;
 
 /**
- * Spring Boot {@link ConfigurationFactory} that prevents logger warnings from being
- * printed when the application first starts. This factory is ordered last and is
- * triggered by a {@code log4j2.springboot} classpath resource (which is bundled in this
- * jar). If the {@link Log4J2LoggingSystem} is active, a {@link DefaultConfiguration} is
- * returned with the expectation that the system will later re-initialize Log4J2 with the
- * correct configuration file.
+ * Spring Boot {@link ConfigurationFactory} that customizes Log4J2's default configuration
+ * to:
+ *
+ * <ol>
+ * <li>Prevent logger warnings from being printed when the application first starts.
+ * <li>Disable its shutdown hook
+ * </ol>
+ *
+ * This factory is ordered last and is triggered by a {@code log4j2.springboot} classpath
+ * resource (which is bundled in this jar). If the {@link Log4J2LoggingSystem} is active,
+ * a custom {@link DefaultConfiguration} is returned with the expectation that the system
+ * will later re-initialize Log4J2 with the correct configuration file.
  *
  * @author Phillip Webb
  * @since 1.5.0
@@ -53,10 +59,18 @@ public Configuration getConfiguration(LoggerContext loggerContext,
 			ConfigurationSource source) {
 		if (source != null && source != ConfigurationSource.NULL_SOURCE) {
 			if (LoggingSystem.get(loggerContext.getClass().getClassLoader()) != null) {
-				return new DefaultConfiguration();
+				return new SpringBootConfiguration();
 			}
 		}
 		return null;
 	}
 
+	private static final class SpringBootConfiguration extends DefaultConfiguration {
+
+		private SpringBootConfiguration() {
+			this.isShutdownHookEnabled = false;
+		}
+
+	}
+
 }
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.logging.log4j2;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.config.ConfigurationSource;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link SpringBootConfigurationFactory}.
+ *
+ * @author Andy Wilkinson
+ */
+public class SpringBootConfigurationFactoryTests {
+
+	@Test
+	public void producesConfigurationWithShutdownHookDisabled() throws IOException {
+		ConfigurationSource source = new ConfigurationSource(
+				new ByteArrayInputStream(new byte[0]));
+		assertThat(new SpringBootConfigurationFactory()
+				.getConfiguration(new LoggerContext(""""), source).isShutdownHookEnabled())
+						.isFalse();
+	}
+
+}
"
https://github.com/square/retrofit/commit/54c8e17ad51bd35e75009233c3be6cdc3afe310e,Update documentation for handling of @field and @part values. ,https://api.github.com/repos/square/retrofit/commits/54c8e17ad51bd35e75009233c3be6cdc3afe310e,"@@ -25,7 +25,9 @@
 /**
  * Named pair for a form-encoded request.
  * <p>
- * Values may be {@code null} which will omit them from the request body.
+ * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
+ * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
+ * field pair for each non-{@code null} item.
  * <p>
  * Simple Example:
  * <pre>
@@ -36,6 +38,15 @@
  * </pre>
  * Calling with {@code foo.example(""Bob Smith"", ""President"")} yields a request body of
  * {@code name=Bob+Smith&occupation=President}.
+ * <p>
+ * Array Example:
+ * <pre>
+ * &#64;FormUrlEncoded
+ * &#64;POST(""/list"")
+ * void example(@Field(""name"") String... names);
+ * </pre>
+ * Calling with {@code foo.example(""Bob Smith"", ""Jane Doe"")} yields a request body of
+ * {@code name=Bob+Smith&name=Jane+Doe}.
  *
  * @see FormUrlEncoded
  * @see FieldMap
@@ -35,6 +35,8 @@
  * retrofit.converter.Converter#toBody(Object)}.</li>
  * </ul>
  * <p>
+ * Values may be {@code null} which will omit them from the request body.
+ * <p>
  * <pre>
  * &#64;Multipart
  * &#64;POST(""/"")
@@ -26,9 +26,8 @@
  * Query parameter appended to the URL.
  * <p>
  * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
- * A {@link java.util.List List} or array will result in a query parameter for each value.
- * {@code null} as a value to the parameter or as a value in a list will not be included in the
- * URL.
+ * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
+ * query parameter for each non-{@code null} item.
  * <p>
  * Simple Example:
  * <pre>
"
https://github.com/junit-team/junit4/commit/16a2b51b9d9425cd7dacad85e2df97985996ca8d,"Disable parts of doclint for the site's javadoc.  <enter> This is a follow-up to  <otherCommit_link> . That commit is missing to apply the doclint rules to site generation. Hence the site goal fails because of doclint issues. Now doclint is disabled for all groups but accessibility and reference for the site generation, too. ",https://api.github.com/repos/junit-team/junit4/commits/16a2b51b9d9425cd7dacad85e2df97985996ca8d,"@@ -514,6 +514,16 @@
                     </plugin>
                 </plugins>
             </build>
+            <reporting>
+                <plugins>
+                    <plugin>
+                        <artifactId>maven-javadoc-plugin</artifactId>
+                        <configuration>
+                            <additionalparam>-Xdoclint:accessibility -Xdoclint:reference</additionalparam>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </reporting>
         </profile>
         <profile>
             <id>fast-tests</id>
"
https://github.com/square/okhttp/commit/5569a0d20f4669ddde8227d8777de54ddf373181,Remove obsolete @JvmField ,https://api.github.com/repos/square/okhttp/commits/5569a0d20f4669ddde8227d8777de54ddf373181,"@@ -38,8 +38,7 @@ internal class RealCall private constructor(
   val client: OkHttpClient,
   /** The application's original request unadulterated by redirects or auth headers.  */
   val originalRequest: Request,
-  // TODO(egorand): Remove @JvmField once Dispatcher.java is converted to Kotlin
-  @JvmField val forWebSocket: Boolean
+  val forWebSocket: Boolean
 ) : Call {
   /**
    * There is a cycle between the [Call] and [Transmitter] that makes this awkward.
"
https://github.com/square/retrofit/commit/26d19ea8877696a253be8c00b2baed6b359baaa2,Java 7 is required since <otherCommit_link> ,https://api.github.com/repos/square/retrofit/commits/26d19ea8877696a253be8c00b2baed6b359baaa2,"@@ -24,7 +24,7 @@ compile 'com.squareup.retrofit:retrofit:1.9.0'
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
-Retrofit requires at minimum Java 6 or Android 2.3.
+Retrofit requires at minimum Java 7 or Android 2.3.
 
 
 
"
https://github.com/square/okhttp/commit/4ab6a8258b0df3a3528029f810e1f48952dba2d7,Remove old SSL protocol method. ,https://api.github.com/repos/square/okhttp/commits/4ab6a8258b0df3a3528029f810e1f48952dba2d7,"@@ -16,9 +16,8 @@
 
 package com.squareup.okhttp.mockwebserver;
 
-import com.squareup.okhttp.TlsVersion;
-import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.TlsVersion;
 import java.net.Socket;
 import java.util.ArrayList;
 import java.util.List;
@@ -135,11 +134,6 @@ public int getSequenceNumber() {
     return sequenceNumber;
   }
 
-  /** @deprecated Use {@link #getTlsVersion()}. */
-  public String getSslProtocol() {
-    return tlsVersion != null ? Internal.instance.tlsVersionJavaName(tlsVersion) : null;
-  }
-
   /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
   public TlsVersion getTlsVersion() {
     return tlsVersion;
@@ -120,10 +120,6 @@ public class OkHttpClient implements Cloneable {
         connection.connectAndSetOwner(client, owner, request);
       }
 
-      @Override public String tlsVersionJavaName(TlsVersion tlsVersion) {
-        return tlsVersion.javaName;
-      }
-
       @Override
       public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
         call.enqueue(responseCallback, forWebSocket);
@@ -23,7 +23,6 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
-import com.squareup.okhttp.TlsVersion;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
@@ -70,8 +69,6 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
   public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
       HttpEngine owner, Request request) throws IOException;
 
-  public abstract String tlsVersionJavaName(TlsVersion tlsVersion);
-
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
   public abstract void callEngineReleaseConnection(Call call) throws IOException;
"
https://github.com/square/okhttp/commit/18b2660873ed8f028ee72981c882ed676aa08030,"New CertificateAuthorityCouncil class to normalize certificate chains.  <enter> The goal of this is to get the root CA certificate into the certificate chain, so that it can be considered by the certificate pinner. The work to integrate CertificateAuthorityCouncil with CertificatePinner will come in a follow-up PR. <enter> See:  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/18b2660873ed8f028ee72981c882ed676aa08030,"@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+import java.util.UUID;
+import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+/**
+ * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
+ * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
+ * held certificates, as done in practice by certificate authorities.
+ */
+public final class HeldCertificate {
+  public final X509Certificate certificate;
+  public final KeyPair keyPair;
+
+  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public static final class Builder {
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private final long duration = 1000L * 60 * 60 * 24; // One day.
+    private String hostname;
+    private String serialNumber = ""1"";
+    private KeyPair keyPair;
+    private HeldCertificate issuedBy;
+
+    public Builder serialNumber(String serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /**
+     * Set this certificate's hostname. This is the CN (common name) in the certificate. Will be a
+     * random string if no value is provided.
+     */
+    public Builder hostname(String hostname) {
+      this.hostname = hostname;
+      return this;
+    }
+
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
+     * generated.
+     */
+    public Builder issuedBy(HeldCertificate signedBy) {
+      this.issuedBy = signedBy;
+      return this;
+    }
+
+    public HeldCertificate build() throws GeneralSecurityException {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+      X500Principal subject = hostname != null
+          ? new X500Principal(""CN="" + hostname)
+          : new X500Principal(""CN="" + UUID.randomUUID());
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (issuedBy != null) {
+        signedByKeyPair = issuedBy.keyPair;
+        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long now = System.currentTimeMillis();
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(new BigInteger(serialNumber));
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(now));
+      generator.setNotAfter(new Date(now + duration));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm(""SHA256WithRSAEncryption"");
+      X509Certificate certificate = generator.generateX509Certificate(
+          signedByKeyPair.getPrivate(), ""BC"");
+      return new HeldCertificate(certificate, heldKeyPair);
+    }
+
+    public KeyPair generateKeyPair() throws GeneralSecurityException {
+      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
+      keyPairGenerator.initialize(1024, new SecureRandom());
+      return keyPairGenerator.generateKeyPair();
+    }
+  }
+}
@@ -13,29 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package okhttp3.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.math.BigInteger;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
 import java.security.KeyStore;
 import java.security.SecureRandom;
-import java.security.Security;
 import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.Date;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
-import javax.security.auth.x500.X500Principal;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
 
 /**
  * Constructs an SSL context for testing. This uses Bouncy Castle to generate a self-signed
@@ -45,16 +35,8 @@
  * instances where possible.
  */
 public final class SslContextBuilder {
-  static {
-    Security.addProvider(new BouncyCastleProvider());
-  }
-
-  private static final long ONE_DAY_MILLIS = 1000L * 60 * 60 * 24;
   private static SSLContext localhost; // Lazily initialized.
-
   private final String hostName;
-  private long notBefore = System.currentTimeMillis();
-  private long notAfter = System.currentTimeMillis() + ONE_DAY_MILLIS;
 
   /**
    * @param hostName the subject of the host. For TLS this should be the domain name that the client
@@ -79,17 +61,19 @@ public static synchronized SSLContext localhost() {
   }
 
   public SSLContext build() throws GeneralSecurityException {
-    char[] password = ""password"".toCharArray();
-
-    // Generate public and private keys and use them to make a self-signed certificate.
-    KeyPair keyPair = generateKeyPair();
-    X509Certificate certificate = selfSignedCertificate(keyPair, ""1"");
+    // Generate a self-signed cert for the server to serve and the client to trust.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .hostname(hostName)
+        .build();
 
-    // Put 'em in a key store.
+    // Put the certificate in a key store.
+    char[] password = ""password"".toCharArray();
     KeyStore keyStore = newEmptyKeyStore(password);
-    Certificate[] certificateChain = {certificate};
-    keyStore.setKeyEntry(""private"", keyPair.getPrivate(), password, certificateChain);
-    keyStore.setCertificateEntry(""cert"", certificate);
+    Certificate[] certificateChain = {heldCertificate.certificate};
+    keyStore.setKeyEntry(""private"",
+        heldCertificate.keyPair.getPrivate(), password, certificateChain);
+    keyStore.setCertificateEntry(""cert"", heldCertificate.certificate);
 
     // Wrap it up in an SSL context.
     KeyManagerFactory keyManagerFactory =
@@ -104,32 +88,6 @@ public SSLContext build() throws GeneralSecurityException {
     return sslContext;
   }
 
-  public KeyPair generateKeyPair() throws GeneralSecurityException {
-    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
-    keyPairGenerator.initialize(1024, new SecureRandom());
-    return keyPairGenerator.generateKeyPair();
-  }
-
-  /**
-   * Generates a certificate for {@code hostName} containing {@code keyPair}'s public key, signed by
-   * {@code keyPair}'s private key.
-   */
-  @SuppressWarnings(""deprecation"") // use the old Bouncy Castle APIs to reduce dependencies.
-  public X509Certificate selfSignedCertificate(KeyPair keyPair, String serialNumber)
-      throws GeneralSecurityException {
-    X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-    X500Principal issuer = new X500Principal(""CN="" + hostName);
-    X500Principal subject = new X500Principal(""CN="" + hostName);
-    generator.setSerialNumber(new BigInteger(serialNumber));
-    generator.setIssuerDN(issuer);
-    generator.setNotBefore(new Date(notBefore));
-    generator.setNotAfter(new Date(notAfter));
-    generator.setSubjectDN(subject);
-    generator.setPublicKey(keyPair.getPublic());
-    generator.setSignatureAlgorithm(""SHA256WithRSAEncryption"");
-    return generator.generateX509Certificate(keyPair.getPrivate(), ""BC"");
-  }
-
   private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
     try {
       KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.cert.Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.tls.CertificateAuthorityCouncil;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class CertificateAuthorityCouncilTest {
+  @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(root), council.normalizeCertificateChain(list(root)));
+  }
+
+  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil();
+
+    try {
+      council.normalizeCertificateChain(list(root));
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certB, certA, root),
+        council.normalizeCertificateChain(list(certB, certA, root)));
+  }
+
+  @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certB, certA, root),
+        council.normalizeCertificateChain(list(certB, certA))); // Root is added!
+  }
+
+  @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber(""4"")
+        .issuedBy(certB)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        council.normalizeCertificateChain(list(certC, certA, root, certB)));
+  }
+
+  @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber(""4"")
+        .issuedBy(certB)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        council.normalizeCertificateChain(list(certC, certA, certB)));
+  }
+
+  @Test public void unrelatedCertificatesAreOmitted() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certUnnecessary = new HeldCertificate.Builder()
+        .serialNumber(""4"")
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certB, certA, root),
+        council.normalizeCertificateChain(list(certB, certUnnecessary, certA, root)));
+  }
+
+  @Test public void unnecessaryTrustedCertificatesAreOmitted() throws Exception {
+    HeldCertificate superRoot = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(superRoot)
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""4"")
+        .issuedBy(certA)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(
+        superRoot.certificate, root.certificate);
+    assertEquals(list(certB, certA, root),
+        council.normalizeCertificateChain(list(certB, certA, root, superRoot)));
+  }
+
+  private List<Certificate> list(HeldCertificate... heldCertificates) {
+    List<Certificate> result = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      result.add(heldCertificate.certificate);
+    }
+    return result;
+  }
+}
@@ -16,11 +16,9 @@
 package okhttp3;
 
 import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.cert.X509Certificate;
 import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.HeldCertificate;
 import okio.ByteString;
 import org.junit.Test;
 
@@ -32,39 +30,35 @@
 import static org.junit.Assert.fail;
 
 public final class CertificatePinnerTest {
-  static SslContextBuilder sslContextBuilder;
+  static HeldCertificate certA1;
+  static String certA1Pin;
+  static ByteString certA1PinBase64;
 
-  static KeyPair keyPairA;
-  static X509Certificate keypairACertificate1;
-  static String keypairACertificate1Pin;
-  static ByteString keypairACertificate1PinBase64;
+  static HeldCertificate certB1;
+  static String certB1Pin;
+  static ByteString certB1PinBase64;
 
-  static KeyPair keyPairB;
-  static X509Certificate keypairBCertificate1;
-  static String keypairBCertificate1Pin;
-  static ByteString keypairBCertificate1PinBase64;
-
-  static KeyPair keyPairC;
-  static X509Certificate keypairCCertificate1;
-  static String keypairCCertificate1Pin;
+  static HeldCertificate certC1;
+  static String certC1Pin;
 
   static {
     try {
-      sslContextBuilder = new SslContextBuilder(""example.com"");
-
-      keyPairA = sslContextBuilder.generateKeyPair();
-      keypairACertificate1 = sslContextBuilder.selfSignedCertificate(keyPairA, ""1"");
-      keypairACertificate1Pin = CertificatePinner.pin(keypairACertificate1);
-      keypairACertificate1PinBase64 = pinToBase64(keypairACertificate1Pin);
-
-      keyPairB = sslContextBuilder.generateKeyPair();
-      keypairBCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairB, ""1"");
-      keypairBCertificate1Pin = CertificatePinner.pin(keypairBCertificate1);
-      keypairBCertificate1PinBase64 = pinToBase64(keypairBCertificate1Pin);
-
-      keyPairC = sslContextBuilder.generateKeyPair();
-      keypairCCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairC, ""1"");
-      keypairCCertificate1Pin = CertificatePinner.pin(keypairCCertificate1);
+      certA1 = new HeldCertificate.Builder()
+          .serialNumber(""100"")
+          .build();
+      certA1Pin = CertificatePinner.pin(certA1.certificate);
+      certA1PinBase64 = pinToBase64(certA1Pin);
+
+      certB1 = new HeldCertificate.Builder()
+          .serialNumber(""200"")
+          .build();
+      certB1Pin = CertificatePinner.pin(certB1.certificate);
+      certB1PinBase64 = pinToBase64(certB1Pin);
+
+      certC1 = new HeldCertificate.Builder()
+          .serialNumber(""300"")
+          .build();
+      certC1Pin = CertificatePinner.pin(certC1.certificate);
     } catch (GeneralSecurityException e) {
       throw new AssertionError(e);
     }
@@ -94,162 +88,166 @@ static ByteString pinToBase64(String pin) {
 
   /** Multiple certificates generated from the same keypair have the same pin. */
   @Test public void sameKeypairSamePin() throws Exception {
-    X509Certificate keypairACertificate2 = sslContextBuilder.selfSignedCertificate(keyPairA, ""2"");
-    String keypairACertificate2Pin = CertificatePinner.pin(keypairACertificate2);
+    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
+        .keyPair(certA1.keyPair)
+        .serialNumber(""101"")
+        .build();
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
 
-    X509Certificate keypairBCertificate2 = sslContextBuilder.selfSignedCertificate(keyPairB, ""2"");
-    String keypairBCertificate2Pin = CertificatePinner.pin(keypairBCertificate2);
+    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
+        .keyPair(certB1.keyPair)
+        .serialNumber(""201"")
+        .build();
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
 
-    assertTrue(keypairACertificate1Pin.equals(keypairACertificate2Pin));
-    assertTrue(keypairBCertificate1Pin.equals(keypairBCertificate2Pin));
-    assertFalse(keypairACertificate1Pin.equals(keypairBCertificate1Pin));
+    assertTrue(certA1Pin.equals(keypairACertificate2Pin));
+    assertTrue(certB1Pin.equals(keypairBCertificate2Pin));
+    assertFalse(certA1Pin.equals(certB1Pin));
   }
 
   @Test public void successfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairACertificate1Pin)
+        .add(""example.com"", certA1Pin)
         .build();
 
-    certificatePinner.check(""example.com"", keypairACertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate);
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairBCertificate1Pin)
+        .add(""example.com"", certB1Pin)
         .build();
 
-    certificatePinner.check(""example.com"", keypairACertificate1, keypairBCertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate, certB1.certificate);
   }
 
   @Test public void unsuccessfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairACertificate1Pin)
+        .add(""example.com"", certA1Pin)
         .build();
 
     try {
-      certificatePinner.check(""example.com"", keypairBCertificate1);
+      certificatePinner.check(""example.com"", certB1.certificate);
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
   }
 
   @Test public void multipleCertificatesForOneHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairACertificate1Pin, keypairBCertificate1Pin)
+        .add(""example.com"", certA1Pin, certB1Pin)
         .build();
 
-    certificatePinner.check(""example.com"", keypairACertificate1);
-    certificatePinner.check(""example.com"", keypairBCertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate);
+    certificatePinner.check(""example.com"", certB1.certificate);
   }
 
   @Test public void multipleHostnamesForOneCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairACertificate1Pin)
-        .add(""www.example.com"", keypairACertificate1Pin)
+        .add(""example.com"", certA1Pin)
+        .add(""www.example.com"", certA1Pin)
         .build();
 
-    certificatePinner.check(""example.com"", keypairACertificate1);
-    certificatePinner.check(""www.example.com"", keypairACertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate);
+    certificatePinner.check(""www.example.com"", certA1.certificate);
   }
 
   @Test public void absentHostnameMatches() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check(""example.com"", keypairACertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate);
   }
 
   @Test public void successfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
         .build();
 
-    certificatePinner.check(""a.example.com"", keypairACertificate1);
+    certificatePinner.check(""a.example.com"", certA1.certificate);
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairBCertificate1Pin)
+        .add(""*.example.com"", certB1Pin)
         .build();
 
-    certificatePinner.check(""a.example.com"", keypairACertificate1, keypairBCertificate1);
+    certificatePinner.check(""a.example.com"", certA1.certificate, certB1.certificate);
   }
 
   @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
         .build();
 
     try {
-      certificatePinner.check(""a.example.com"", keypairBCertificate1);
+      certificatePinner.check(""a.example.com"", certB1.certificate);
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
   }
 
   @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin, keypairBCertificate1Pin)
+        .add(""*.example.com"", certA1Pin, certB1Pin)
         .build();
 
-    certificatePinner.check(""a.example.com"", keypairACertificate1);
-    certificatePinner.check(""a.example.com"", keypairBCertificate1);
+    certificatePinner.check(""a.example.com"", certA1.certificate);
+    certificatePinner.check(""a.example.com"", certB1.certificate);
   }
 
   @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
-        .add(""a.example.com"", keypairBCertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
+        .add(""a.example.com"", certB1Pin)
         .build();
 
-    certificatePinner.check(""a.example.com"", keypairACertificate1);
-    certificatePinner.check(""a.example.com"", keypairBCertificate1);
+    certificatePinner.check(""a.example.com"", certA1.certificate);
+    certificatePinner.check(""a.example.com"", certB1.certificate);
   }
 
   @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
-        .add(""a.example.com"", keypairBCertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
+        .add(""a.example.com"", certB1Pin)
         .build();
 
     try {
-      certificatePinner.check(""a.example.com"", keypairCCertificate1);
+      certificatePinner.check(""a.example.com"", certC1.certificate);
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
   }
 
   @Test public void successfulFindMatchingPins() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""first.com"", keypairACertificate1Pin, keypairBCertificate1Pin)
-        .add(""second.com"", keypairCCertificate1Pin)
+        .add(""first.com"", certA1Pin, certB1Pin)
+        .add(""second.com"", certC1Pin)
         .build();
 
-    Set<ByteString> expectedPins =
-        setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
+    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
     Set<ByteString> matchedPins = certificatePinner.findMatchingPins(""first.com"");
 
     assertEquals(expectedPins, matchedPins);
   }
 
   @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
-        .add(""a.example.com"", keypairBCertificate1Pin)
-        .add(""b.example.com"", keypairCCertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
+        .add(""a.example.com"", certB1Pin)
+        .add(""b.example.com"", certC1Pin)
         .build();
 
-    Set<ByteString> expectedPins =
-        setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
+    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
     Set<ByteString> matchedPins = certificatePinner.findMatchingPins(""a.example.com"");
 
     assertEquals(expectedPins, matchedPins);
   }
 
   @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
         .build();
 
     assertNull(certificatePinner.findMatchingPins(""example.com""));
@@ -34,6 +34,7 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
+import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -58,6 +59,7 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.Internal;
+import okhttp3.internal.Platform;
 import okhttp3.internal.RecordingAuthenticator;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
@@ -2303,9 +2305,9 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
   @Test public void httpsWithCustomTrustManager() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager();
+    RecordingTrustManager trustManager = new RecordingTrustManager(sslContext);
     SSLContext sc = SSLContext.getInstance(""TLS"");
-    sc.init(null, new TrustManager[] {trustManager}, new java.security.SecureRandom());
+    sc.init(null, new TrustManager[] {trustManager}, new SecureRandom());
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(hostnameVerifier)
@@ -2321,8 +2323,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     assertContent(""DEF"", urlFactory.open(url));
     assertContent(""GHI"", urlFactory.open(url));
 
-    assertEquals(Arrays.asList(""verify "" + server.getHostName()),
-        hostnameVerifier.calls);
+    assertEquals(Arrays.asList(""verify "" + server.getHostName()), hostnameVerifier.calls);
     assertEquals(Arrays.asList(""checkServerTrusted [CN="" + server.getHostName() + "" 1]""),
         trustManager.calls);
   }
@@ -3535,9 +3536,14 @@ public abstract HttpURLConnection connect(
 
   private static class RecordingTrustManager implements X509TrustManager {
     private final List<String> calls = new ArrayList<String>();
+    private final X509TrustManager delegate;
+
+    public RecordingTrustManager(SSLContext sslContext) {
+      this.delegate = Platform.get().trustManager(sslContext.getSocketFactory());
+    }
 
     public X509Certificate[] getAcceptedIssuers() {
-      return new X509Certificate[] {};
+      return delegate.getAcceptedIssuers();
     }
 
     public void checkClientTrusted(X509Certificate[] chain, String authType)
@@ -0,0 +1,120 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the ""License""); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.PublicKey;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.security.auth.x500.X500Principal;
+
+/**
+ * A set of trusted Certificate Authority (CA) certificates that are trusted to verify the TLS
+ * certificates offered by remote web servers.
+ *
+ * <p>This class includes code from <a href=""https://conscrypt.org/"">Conscrypt's</a> {@code
+ * TrustManagerImpl} and {@code TrustedCertificateIndex}.
+ */
+public final class CertificateAuthorityCouncil {
+  private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts = new LinkedHashMap<>();
+
+  public CertificateAuthorityCouncil(X509Certificate... caCerts) {
+    for (X509Certificate caCert : caCerts) {
+      X500Principal subject = caCert.getSubjectX500Principal();
+      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+      if (subjectCaCerts == null) {
+        subjectCaCerts = new ArrayList<>(1);
+        subjectToCaCerts.put(subject, subjectCaCerts);
+      }
+      subjectCaCerts.add(caCert);
+    }
+  }
+
+  /**
+   * Computes the effective certificate chain from the raw array returned by Java's built in TLS
+   * APIs. This method returns a list of certificates where the first element is {@code chain[0]},
+   * each certificate is signed by the certificate that follows, and the last certificate is a
+   * trusted CA certificate.
+   *
+   * <p>Use of this method is necessary to omit unexpected certificates that aren't relevant to the
+   * TLS handshake and to extract the trusted CA certificate for the benefit of certificate pinning.
+   *
+   * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
+   * This is unexpected unless the X509 trust manager in this class is different from the trust
+   * manager that was used to establish {@code chain}.
+   */
+  public List<Certificate> normalizeCertificateChain(List<Certificate> chain)
+      throws SSLPeerUnverifiedException {
+    Deque<Certificate> queue = new ArrayDeque<>(chain);
+    List<Certificate> result = new ArrayList<>();
+    result.add(queue.removeFirst());
+
+    followIssuerChain:
+    while (true) {
+      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
+
+      // If this cert has been signed by a trusted CA cert, we're done. Add the trusted CA
+      // certificate to the end of the chain, unless it's already present. (That would happen if the
+      // first certificate in the chain is itself a self-signed and trusted CA certificate.)
+      X509Certificate caCert = findByIssuerAndSignature(toVerify);
+      if (caCert != null) {
+        if (result.size() > 1 || !toVerify.equals(caCert)) {
+          result.add(caCert);
+        }
+        return result;
+      }
+
+      // Search for the certificate in the chain that signed this certificate. This is typically the
+      // next element in the chain, but it could be any element.
+      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
+        Certificate signingCert = i.next();
+        if (toVerify.getIssuerDN().equals(((X509Certificate) signingCert).getSubjectDN())) {
+          i.remove();
+          result.add(signingCert);
+          continue followIssuerChain;
+        }
+      }
+
+      throw new SSLPeerUnverifiedException(""Failed to find a cert that signed "" + toVerify);
+    }
+  }
+
+  /** Returns the trusted CA certificate that signed {@code cert}. */
+  private X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    X500Principal issuer = cert.getIssuerX500Principal();
+    List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+    if (subjectCaCerts == null) return null;
+
+    for (X509Certificate caCert : subjectCaCerts) {
+      PublicKey publicKey = caCert.getPublicKey();
+      try {
+        cert.verify(publicKey);
+        return caCert;
+      } catch (Exception ignored) {
+      }
+    }
+
+    return null;
+  }
+}
"
https://github.com/spring-projects/spring-boot/commit/205fa2507b019f5e1348f6bc554fdd18691152ba,Remove maven-eclipse-plugin as it has been retired  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/205fa2507b019f5e1348f6bc554fdd18691152ba,"@@ -193,7 +193,6 @@
 		<maven-compiler-plugin.version>3.7.0</maven-compiler-plugin.version>
 		<maven-dependency-plugin.version>3.0.2</maven-dependency-plugin.version>
 		<maven-deploy-plugin.version>2.8.2</maven-deploy-plugin.version>
-		<maven-eclipse-plugin.version>2.10</maven-eclipse-plugin.version>
 		<maven-enforcer-plugin.version>3.0.0-M1</maven-enforcer-plugin.version>
 		<maven-failsafe-plugin.version>2.22.0</maven-failsafe-plugin.version>
 		<maven-install-plugin.version>2.5.2</maven-install-plugin.version>
@@ -2912,11 +2911,6 @@
 					<artifactId>maven-dependency-plugin</artifactId>
 					<version>${maven-dependency-plugin.version}</version>
 				</plugin>
-				<plugin>
-					<groupId>org.apache.maven.plugins</groupId>
-					<artifactId>maven-eclipse-plugin</artifactId>
-					<version>${maven-eclipse-plugin.version}</version>
-				</plugin>
 				<plugin>
 					<groupId>org.apache.maven.plugins</groupId>
 					<artifactId>maven-enforcer-plugin</artifactId>
"
https://github.com/square/okhttp/commit/cf63fcc48ae3e1dc3fb32120ca2fb04877fa041e,Remove creation of 'fat' jar.  <enter> Since the 'okhttp-protocols' module no longer exists we do not need to create this. ,https://api.github.com/repos/square/okhttp/commits/cf63fcc48ae3e1dc3fb32120ca2fb04877fa041e,"@@ -34,24 +34,6 @@
           <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
         </configuration>
       </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
     </plugins>
   </build>
 </project>
"
https://github.com/junit-team/junit4/commit/5eee07b3e21f196b8cb937fb88eb8cf4be694f76,"Optimize ParentRunner.filter for nested suites  <enter> Prior to this change, applying a filter to a nested suite would create redundant nested filters ",https://api.github.com/repos/junit-team/junit4/commits/5eee07b3e21f196b8cb937fb88eb8cf4be694f76,"@@ -50,8 +50,6 @@ public abstract class ParentRunner<T> extends Runner implements Filterable,
 		Sortable {
 	private final TestClass fTestClass;
 
-	private Filter fFilter= Filter.ALL;
-
 	private Sorter fSorter= Sorter.NULL;
 
 	private List<T> fFilteredChildren= null;
@@ -319,13 +317,11 @@ public void run(final RunNotifier notifier) {
 	//
 
 	public void filter(Filter filter) throws NoTestsRemainException {
-		fFilter= fFilter.intersect(filter);
-
 		for (Iterator<T> iter = getFilteredChildren().iterator(); iter.hasNext(); ) {
 			T each = iter.next();
-			if (shouldRun(each))
+			if (shouldRun(filter, each))
 				try {
-					filterChild(each);
+					filter.apply(each);
 				} catch (NoTestsRemainException e) {
 					iter.remove();
 				}
@@ -365,12 +361,8 @@ private void sortChild(T child) {
 		fSorter.apply(child);
 	}
 
-	private void filterChild(T child) throws NoTestsRemainException {
-		fFilter.apply(child);
-	}
-
-	private boolean shouldRun(T each) {
-		return fFilter.shouldRun(describeChild(each));
+	private boolean shouldRun(Filter filter, T each) {
+		return filter.shouldRun(describeChild(each));
 	}
 
 	private Comparator<? super T> comparator() {
"
https://github.com/square/retrofit/commit/b6748ac88759a4768c1003930bb5c921ac49d8d1,Mark GSON as provided since we jarjar it in. ,https://api.github.com/repos/square/retrofit/commits/b6748ac88759a4768c1003930bb5c921ac49d8d1,"@@ -29,6 +29,7 @@
         <dependency>
             <groupId>com.google.code.gson</groupId>
             <artifactId>gson</artifactId>
+            <scope>provided</scope>
         </dependency>
         <dependency>
             <groupId>org.apache.httpcomponents</groupId>
"
https://github.com/junit-team/junit4/commit/24dfdd762e753c83babca3768d4b508cf5c6a86c,Fix dead link to the ant task in FAQ ( <pr_link> )  <enter> Documentation to the ant junit task has been moved to another location. ,https://api.github.com/repos/junit-team/junit4/commits/24dfdd762e753c83babca3768d4b508cf5c6a86c,"@@ -1461,7 +1461,7 @@ a test failure, rather than the source file's line number?</question>
           Idiomatic naming patterns for unit tests
           are <code>Test*.java</code> and <code>*Test.java</code>.
           Documentation and examples are at <a
-                                               href=""http://ant.apache.org/manual/OptionalTasks/junit.html"">http://ant.apache.org/manual/OptionalTasks/junit.html</a>.
+                                               href=""https://ant.apache.org/manual/Tasks/junit.html"">https://ant.apache.org/manual/Tasks/junit.html</a>.
         </p>
       </li>
       <li>
"
https://github.com/square/okhttp/commit/50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d,"Move out of the libcore package.  <enter> To promote the code into AOSP, we'll keep this package as-is and do the jarjar in Android instead. ",https://api.github.com/repos/square/okhttp/commits/50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d,"@@ -101,31 +101,6 @@
                     <target>${java.version}</target>
                 </configuration>
             </plugin>
-            <plugin>
-                <groupId>org.sonatype.plugins</groupId>
-                <artifactId>jarjar-maven-plugin</artifactId>
-                <version>1.5</version>
-                <executions>
-                    <execution>
-                        <phase>package</phase>
-                        <goals>
-                            <goal>jarjar</goal>
-                        </goals>
-                        <configuration>
-                            <includes>
-                                <include>asm:asm</include>
-                                <include>org.sonatype.sisu.inject:cglib</include>
-                            </includes>
-                            <rules>
-                                <rule>
-                                    <pattern>libcore.**</pattern>
-                                    <result>com.squareup.okhttp.libcore.@1</result>
-                                </rule>
-                            </rules>
-                        </configuration>
-                    </execution>
-                </executions>
-            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-checkstyle-plugin</artifactId>
@@ -15,6 +15,8 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.net.http.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.net.http.HttpsURLConnectionImpl;
 import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URL;
@@ -33,9 +35,9 @@ public OkHttpClient setProxy(Proxy proxy) {
     public HttpURLConnection open(URL url) {
         String protocol = url.getProtocol();
         if (protocol.equals(""http"")) {
-            return new libcore.net.http.HttpURLConnectionImpl(url, 80, proxy);
+            return new HttpURLConnectionImpl(url, 80, proxy);
         } else if (protocol.equals(""https"")) {
-            return new libcore.net.http.HttpsURLConnectionImpl(url, 443, proxy);
+            return new HttpsURLConnectionImpl(url, 443, proxy);
         } else {
             throw new IllegalArgumentException();
         }
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore;
+package com.squareup.okhttp.internal;
 
 import com.squareup.okhttp.OkHttpClient;
 import java.io.OutputStream;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 import java.io.FileDescriptor;
 
@@ -19,10 +19,10 @@
 * @author Alexander Y. Kleymenov
 */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.EmptyArray;
 import java.io.UnsupportedEncodingException;
-import libcore.util.EmptyArray;
 
 /**
  * <a href=""http://www.ietf.org/rfc/rfc2045.txt"">Base64</a> encoder/decoder.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 /**
  * Iterates over big- or little-endian bytes. See {@link MemoryMappedFile#bigEndianIterator} and
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.Charsets;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.BufferedWriter;
 import java.io.Closeable;
 import java.io.EOFException;
@@ -41,8 +43,6 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import libcore.util.Charsets;
-import libcore.util.Libcore;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 import java.io.Closeable;
 import java.io.File;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 public final class OsConstants {
     private OsConstants() { }
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 public final class SizeOf {
     public static final int CHAR = 2;
@@ -14,8 +14,9 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
 import java.io.IOException;
@@ -24,7 +25,6 @@
 import java.io.Reader;
 import java.io.StringWriter;
 import java.util.concurrent.atomic.AtomicReference;
-import libcore.util.Libcore;
 
 public final class Streams {
     private static AtomicReference<byte[]> skipBuffer = new AtomicReference<byte[]>();
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.Charsets;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
-import libcore.util.Charsets;
 
 /**
  * Buffers input from an {@link InputStream} for reading lines.
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net;
+package com.squareup.okhttp.internal.net;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net;
+package com.squareup.okhttp.internal.net;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.io.Streams;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import libcore.io.Streams;
 
 /**
  * An input stream for the body of an HTTP response.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.io.IOException;
 import java.io.OutputStream;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 final class HeaderParser {
 
@@ -14,20 +14,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
-import static com.squareup.okhttp.OkHttpConnection.HTTP_PROXY_AUTH;
-import static com.squareup.okhttp.OkHttpConnection.HTTP_UNAUTHORIZED;
+import com.squareup.okhttp.internal.io.Base64;
 import java.io.IOException;
 import java.net.Authenticator;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.PasswordAuthentication;
 import java.net.Proxy;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
-import libcore.io.Base64;
 
 /**
  * Handles HTTP authentication headers from origin and proxy servers.
@@ -15,14 +15,19 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
-import static com.squareup.okhttp.OkHttpConnection.HTTP_PROXY_AUTH;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.io.IoUtils;
+import com.squareup.okhttp.internal.net.spdy.SpdyConnection;
+import com.squareup.okhttp.internal.util.Libcore;
+import com.squareup.okhttp.internal.util.Objects;
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.Socket;
@@ -33,11 +38,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
-import libcore.Platform;
-import libcore.io.IoUtils;
-import libcore.net.spdy.SpdyConnection;
-import libcore.util.Libcore;
-import libcore.util.Objects;
 
 /**
  * Holds the sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection,
@@ -15,14 +15,14 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.util.Libcore;
 import java.net.Socket;
 import java.net.SocketException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
-import libcore.util.Libcore;
 
 /**
  * A pool of HTTP and SPDY connections. This class exposes its tuning parameters
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.text.DateFormat;
 import java.text.ParseException;
@@ -15,8 +15,14 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
-
+package com.squareup.okhttp.internal.net.http;
+
+import com.squareup.okhttp.internal.io.IoUtils;
+import com.squareup.okhttp.internal.net.Dns;
+import com.squareup.okhttp.internal.util.EmptyArray;
+import com.squareup.okhttp.internal.util.ExtendedResponseCache;
+import com.squareup.okhttp.internal.util.Libcore;
+import com.squareup.okhttp.internal.util.ResponseSource;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -39,12 +45,6 @@
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
-import libcore.io.IoUtils;
-import libcore.net.Dns;
-import libcore.util.EmptyArray;
-import libcore.util.ExtendedResponseCache;
-import libcore.util.Libcore;
-import libcore.util.ResponseSource;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -14,8 +14,16 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
-
+package com.squareup.okhttp.internal.net.http;
+
+import com.squareup.okhttp.internal.io.Base64;
+import com.squareup.okhttp.internal.io.DiskLruCache;
+import com.squareup.okhttp.internal.io.IoUtils;
+import com.squareup.okhttp.internal.io.StrictLineReader;
+import com.squareup.okhttp.internal.util.Charsets;
+import com.squareup.okhttp.internal.util.ExtendedResponseCache;
+import com.squareup.okhttp.internal.util.IntegralToString;
+import com.squareup.okhttp.internal.util.ResponseSource;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -47,14 +55,6 @@
 import java.util.Map;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import libcore.io.Base64;
-import libcore.io.DiskLruCache;
-import libcore.io.IoUtils;
-import libcore.io.StrictLineReader;
-import libcore.util.Charsets;
-import libcore.util.ExtendedResponseCache;
-import libcore.util.IntegralToString;
-import libcore.util.ResponseSource;
 
 /**
  * Cache responses in a directory on the file system. Most clients should use
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.io.Streams;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -25,8 +27,6 @@
 import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Socket;
-import libcore.io.Streams;
-import libcore.util.Libcore;
 
 final class HttpTransport implements Transport {
     /**
@@ -15,8 +15,10 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.io.IoUtils;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -33,8 +35,6 @@
 import java.util.List;
 import java.util.Map;
 import javax.net.ssl.SSLHandshakeException;
-import libcore.io.IoUtils;
-import libcore.util.Libcore;
 
 /**
  * This implementation uses HttpEngine to send requests and receive responses.
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.io.IOException;
 import java.net.Proxy;
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -15,8 +15,10 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.io.Streams;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
@@ -31,8 +33,6 @@
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.TreeMap;
-import libcore.io.Streams;
-import libcore.util.Libcore;
 
 /**
  * The HTTP status and unparsed header fields of a single HTTP message. Values
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.net.URI;
 import java.util.Date;
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.util.Objects;
+import com.squareup.okhttp.internal.util.ResponseSource;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URI;
@@ -26,8 +28,6 @@
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
-import libcore.util.Objects;
-import libcore.util.ResponseSource;
 
 /**
  * Parsed HTTP response headers.
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.ProtocolException;
-import libcore.util.Libcore;
 
 /**
  * An HTTP request body that's completely buffered in memory. This allows
@@ -13,8 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.net.Dns;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_AGGRESSIVE;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_COMPATIBLE;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_NULL;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -26,11 +31,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
-import libcore.net.Dns;
-import static libcore.net.http.HttpConnection.TLS_MODE_AGGRESSIVE;
-import static libcore.net.http.HttpConnection.TLS_MODE_COMPATIBLE;
-import static libcore.net.http.HttpConnection.TLS_MODE_NULL;
-import libcore.util.Libcore;
 
 /**
  * Selects routes to connect to an origin server. Each connection requires a
@@ -14,16 +14,16 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.net.spdy.SpdyConnection;
+import com.squareup.okhttp.internal.net.spdy.SpdyStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.util.List;
-import libcore.net.spdy.SpdyConnection;
-import libcore.net.spdy.SpdyStream;
 
 final class SpdyTransport implements Transport {
     private final HttpEngine httpEngine;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 import java.io.IOException;
 
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 final class Settings {
     /** Peer request to clear durable settings. */
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.io.Streams;
+import static com.squareup.okhttp.internal.net.spdy.Threads.newThreadFactory;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -29,9 +31,6 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import libcore.io.Streams;
-
-import static libcore.net.spdy.Threads.newThreadFactory;
 
 /**
  * A socket connection to a remote peer. A connection hosts streams which can
@@ -14,8 +14,9 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.io.Streams;
 import java.io.DataInputStream;
 import java.io.EOFException;
 import java.io.IOException;
@@ -27,7 +28,6 @@
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
 import java.util.zip.InflaterInputStream;
-import libcore.io.Streams;
 
 /**
  * Read version 2 SPDY frames.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -14,17 +14,16 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.io.Streams;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
-import java.util.List;
-import libcore.io.Streams;
-import libcore.util.Libcore;
-
 import static java.nio.ByteOrder.BIG_ENDIAN;
+import java.util.List;
 
 /**
  * A logical bidirectional stream.
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.Platform;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.List;
 import java.util.zip.Deflater;
-import libcore.Platform;
 
 /**
  * Write version 2 SPDY frames.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 import java.util.concurrent.ThreadFactory;
 
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.nio.charset.Charset;
 
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.lang.ref.Reference;
 import java.util.Collections;
@@ -14,14 +14,15 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
+import com.squareup.okhttp.internal.net.MimeUtils;
 import java.net.FileNameMap;
 import java.util.Locale;
-import libcore.net.MimeUtils;
 
 /**
- * Implements {@link java.net.FileNameMap} in terms of {@link libcore.net.MimeUtils}.
+ * Implements {@link java.net.FileNameMap} in terms of
+ * {@link com.squareup.okhttp.internal.net.MimeUtils}.
  */
 class DefaultFileNameMap implements FileNameMap {
     public String getContentTypeFor(String filename) {
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class EmptyArray {
     private EmptyArray() {
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.io.IOException;
 import java.net.CacheResponse;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 /**
  * Converts integral types to strings. This class is public but hidden so that it can also be
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.io.File;
 import java.io.IOException;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableBoolean {
     public boolean value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableByte {
     public byte value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableChar {
     public char value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableDouble {
     public double value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableFloat {
     public float value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableInt {
     public int value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableLong {
     public long value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableShort {
     public short value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class Objects {
     private Objects() {
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 /**
  * Where the HTTP client should look for a response.
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 /**
  * Exploits a weakness in the runtime to throw an arbitrary throwable without
@@ -14,8 +14,11 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import static com.squareup.okhttp.internal.io.DiskLruCache.JOURNAL_FILE;
+import static com.squareup.okhttp.internal.io.DiskLruCache.MAGIC;
+import static com.squareup.okhttp.internal.io.DiskLruCache.VERSION_1;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
@@ -29,10 +32,6 @@
 import java.util.List;
 import junit.framework.TestCase;
 
-import static libcore.io.DiskLruCache.JOURNAL_FILE;
-import static libcore.io.DiskLruCache.MAGIC;
-import static libcore.io.DiskLruCache.VERSION_1;
-
 public final class DiskLruCacheTest extends TestCase {
     private final int appVersion = 100;
     private String javaTmpDir;
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.Charsets;
 import java.io.ByteArrayInputStream;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import junit.framework.TestCase;
-import libcore.util.Charsets;
 
 public class StrictLineReaderTest extends TestCase {
 
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import com.squareup.okhttp.OkHttpClient;
 import java.io.BufferedReader;
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import com.google.mockwebserver.MockResponse;
 import com.google.mockwebserver.MockWebServer;
 import com.google.mockwebserver.RecordedRequest;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import com.squareup.okhttp.OkHttpClient;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
@@ -58,8 +59,6 @@
 import java.util.zip.GZIPOutputStream;
 import junit.framework.TestCase;
 
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-
 /**
  * Android's HttpResponseCacheTest.
  */
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import junit.framework.TestCase;
 
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.util.Arrays;
 import java.util.List;
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.net.Dns;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_AGGRESSIVE;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_COMPATIBLE;
+import com.squareup.okhttp.internal.net.ssl.SslContextBuilder;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -32,10 +36,6 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
 import junit.framework.TestCase;
-import libcore.net.Dns;
-import static libcore.net.http.HttpConnection.TLS_MODE_AGGRESSIVE;
-import static libcore.net.http.HttpConnection.TLS_MODE_COMPATIBLE;
-import libcore.net.ssl.SslContextBuilder;
 
 public final class RouteSelectorTest extends TestCase {
     private static final int proxyAPort = 1001;
@@ -14,13 +14,18 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import com.google.mockwebserver.MockResponse;
 import com.google.mockwebserver.MockWebServer;
 import com.google.mockwebserver.RecordedRequest;
 import com.google.mockwebserver.SocketPolicy;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.internal.net.ssl.SslContextBuilder;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
@@ -69,12 +74,6 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
 import junit.framework.TestCase;
-import libcore.net.ssl.SslContextBuilder;
-
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 
 /**
  * Android's URLConnectionTest.
@@ -14,8 +14,9 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.io.Streams;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -29,7 +30,6 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
-import libcore.io.Streams;
 
 /**
  * Replays prerecorded outgoing frames and records incoming frames.
@@ -13,17 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.spdy;
-
+package com.squareup.okhttp.internal.net.spdy;
+
+import static com.squareup.okhttp.internal.net.spdy.Settings.DOWNLOAD_BANDWIDTH;
+import static com.squareup.okhttp.internal.net.spdy.Settings.DOWNLOAD_RETRANS_RATE;
+import static com.squareup.okhttp.internal.net.spdy.Settings.MAX_CONCURRENT_STREAMS;
+import static com.squareup.okhttp.internal.net.spdy.Settings.PERSISTED;
+import static com.squareup.okhttp.internal.net.spdy.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.net.spdy.Settings.UPLOAD_BANDWIDTH;
 import junit.framework.TestCase;
 
-import static libcore.net.spdy.Settings.DOWNLOAD_BANDWIDTH;
-import static libcore.net.spdy.Settings.DOWNLOAD_RETRANS_RATE;
-import static libcore.net.spdy.Settings.MAX_CONCURRENT_STREAMS;
-import static libcore.net.spdy.Settings.PERSISTED;
-import static libcore.net.spdy.Settings.PERSIST_VALUE;
-import static libcore.net.spdy.Settings.UPLOAD_BANDWIDTH;
-
 public final class SettingsTest extends TestCase {
     public void testUnsetField() {
         Settings settings = new Settings();
@@ -14,8 +14,18 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
-
+package com.squareup.okhttp.internal.net.spdy;
+
+import static com.squareup.okhttp.internal.net.spdy.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.FLAG_FIN;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_DATA;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_NOOP;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_PING;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_SYN_REPLY;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_SYN_STREAM;
+import static com.squareup.okhttp.internal.net.spdy.SpdyStream.RST_INVALID_STREAM;
+import static com.squareup.okhttp.internal.util.Charsets.UTF_8;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -25,17 +35,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import junit.framework.TestCase;
 
-import static libcore.net.spdy.Settings.PERSIST_VALUE;
-import static libcore.net.spdy.SpdyConnection.FLAG_FIN;
-import static libcore.net.spdy.SpdyConnection.TYPE_DATA;
-import static libcore.net.spdy.SpdyConnection.TYPE_NOOP;
-import static libcore.net.spdy.SpdyConnection.TYPE_PING;
-import static libcore.net.spdy.SpdyConnection.TYPE_RST_STREAM;
-import static libcore.net.spdy.SpdyConnection.TYPE_SYN_REPLY;
-import static libcore.net.spdy.SpdyConnection.TYPE_SYN_STREAM;
-import static libcore.net.spdy.SpdyStream.RST_INVALID_STREAM;
-import static libcore.util.Charsets.UTF_8;
-
 public final class SpdyConnectionTest extends TestCase {
     private static final IncomingStreamHandler REJECT_INCOMING_STREAMS
             = new IncomingStreamHandler() {
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.ssl;
+package com.squareup.okhttp.internal.net.ssl;
 
 import java.io.IOException;
 import java.io.InputStream;
"
https://github.com/square/okhttp/commit/5ba145aa6c737878281c3fc655657002320b71c0,"Limit recovery attempts for REFUSED_STREAM errors  <enter> We limit per-connection retries but not per-call retries, so this was creating large numbers of connections each of which called the server and accepted yet another REFUSED_STREAM. <enter> Instead we fail sooner with a StreamResetException. <enter> This shows that the ExchangeFinder interface is still somewhat inadequate to support all of the use cases we have. ",https://api.github.com/repos/square/okhttp/commits/5ba145aa6c737878281c3fc655657002320b71c0,"@@ -163,7 +163,7 @@ class Exchange(
   }
 
   private fun trackFailure(e: IOException) {
-    finder.trackFailure()
+    finder.trackFailure(e)
     codec.connection.trackFailure(call.client, e)
   }
 
@@ -19,7 +19,6 @@ import java.io.IOException
 import java.net.Socket
 import okhttp3.Address
 import okhttp3.EventListener
-import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
 import okhttp3.Route
 import okhttp3.internal.assertThreadDoesntHoldLock
@@ -28,9 +27,13 @@ import okhttp3.internal.canReuseConnectionFor
 import okhttp3.internal.closeQuietly
 import okhttp3.internal.http.ExchangeCodec
 import okhttp3.internal.http.RealInterceptorChain
+import okhttp3.internal.http2.ConnectionShutdownException
+import okhttp3.internal.http2.ErrorCode
+import okhttp3.internal.http2.StreamResetException
 
 /**
- * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
+ * Attempts to find the connections for an exchange and any retries that follow. This uses the
+ * following strategies:
  *
  *  1. If the current call already has a connection that can satisfy the request it is used. Using
  *     the same connection for an initial exchange and its follow-ups may improve locality.
@@ -59,7 +62,9 @@ class ExchangeFinder(
   // State guarded by connectionPool.
   private var routeSelector: RouteSelector? = null
   private var connectingConnection: RealConnection? = null
-  private var hasStreamFailure = false
+  private var refusedStreamCount = 0
+  private var connectionShutdownCount = 0
+  private var otherFailureCount = 0
   private var nextRouteToTry: Route? = null
 
   fun find(
@@ -77,10 +82,10 @@ class ExchangeFinder(
       )
       return resultConnection.newCodec(client, chain)
     } catch (e: RouteException) {
-      trackFailure()
+      trackFailure(e.lastConnectException)
       throw e
     } catch (e: IOException) {
-      trackFailure()
+      trackFailure(e)
       throw RouteException(e)
     }
   }
@@ -144,7 +149,6 @@ class ExchangeFinder(
     val toClose: Socket?
     synchronized(connectionPool) {
       if (call.isCanceled()) throw IOException(""Canceled"")
-      hasStreamFailure = false // This is a fresh attempt.
 
       releasedConnection = call.connection
       toClose = if (call.connection != null &&
@@ -158,9 +162,15 @@ class ExchangeFinder(
         // We had an already-allocated connection and it's good.
         result = call.connection
         releasedConnection = null
+        nextRouteToTry = null
       }
 
       if (result == null) {
+        // The connection hasn't had any problems for this call.
+        refusedStreamCount = 0
+        connectionShutdownCount = 0
+        otherFailureCount = 0
+
         // Attempt to get a connection from the pool.
         if (connectionPool.callAcquirePooledConnection(address, call, null, false)) {
           foundPooledConnection = true
@@ -270,24 +280,30 @@ class ExchangeFinder(
     return connectingConnection
   }
 
-  fun trackFailure() {
+  fun trackFailure(e: IOException) {
     connectionPool.assertThreadDoesntHoldLock()
 
     synchronized(connectionPool) {
-      hasStreamFailure = true // Permit retries.
+      if (e is StreamResetException && e.errorCode == ErrorCode.REFUSED_STREAM) {
+        refusedStreamCount++
+      } else if (e is ConnectionShutdownException) {
+        connectionShutdownCount++
+      } else {
+        otherFailureCount++
+      }
     }
   }
 
-  /** Returns true if there is a failure that retrying might fix. */
-  fun hasStreamFailure(): Boolean {
+  /**
+   * Returns true if the current route has a failure that retrying could fix, and that there's
+   * a route to retry on.
+   */
+  fun retryAfterFailure(): Boolean {
     synchronized(connectionPool) {
-      return hasStreamFailure
-    }
-  }
+      if (refusedStreamCount == 0 && connectionShutdownCount == 0 && otherFailureCount == 0) {
+        return false // Nothing to recover from.
+      }
 
-  /** Returns true if a current route is still good or if there are routes we haven't tried yet. */
-  fun hasRouteToTry(): Boolean {
-    synchronized(connectionPool) {
       if (nextRouteToTry != null) {
         return true
       }
@@ -315,11 +331,13 @@ class ExchangeFinder(
    * coalesced connections.
    */
   private fun retryCurrentRoute(): Boolean {
+    if (refusedStreamCount > 1 || connectionShutdownCount > 1 || otherFailureCount > 0) {
+      return false // This route has too many problems to retry.
+    }
+
     val connection = call.connection
     return connection != null &&
         connection.routeFailureCount == 0 &&
         connection.route().address.url.canReuseConnectionFor(address.url)
   }
-
-  fun canReuseFinderFor(httpUrl: HttpUrl) = httpUrl.canReuseConnectionFor(address.url)
 }
@@ -213,29 +213,24 @@ class RealCall(
    * find an exchange to carry the request.
    *
    * Note that an exchange will not be needed if the request is satisfied by the cache.
+   *
+   * @param newExchangeFinder true if this is not a retry and new routing can be performed.
    */
-  fun enterNetworkInterceptorExchange(request: Request) {
+  fun enterNetworkInterceptorExchange(request: Request, newExchangeFinder: Boolean) {
     check(interceptorScopedExchange == null)
     check(exchange == null) {
       ""cannot make a new request because the previous response is still open: "" +
           ""please call response.close()""
     }
 
-    val exchangeFinder = this.exchangeFinder
-    if (exchangeFinder != null) {
-      if (exchangeFinder.canReuseFinderFor(request.url) && exchangeFinder.hasRouteToTry()) {
-        return // Already ready.
-      }
-
-      maybeReleaseConnection(null, true)
+    if (newExchangeFinder) {
+      this.exchangeFinder = ExchangeFinder(
+          connectionPool,
+          createAddress(request.url),
+          this,
+          eventListener
+      )
     }
-
-    this.exchangeFinder = ExchangeFinder(
-        connectionPool,
-        createAddress(request.url),
-        this,
-        eventListener
-    )
   }
 
   /** Finds a new or pooled connection to carry a forthcoming request and response. */
@@ -441,7 +436,7 @@ class RealCall(
     )
   }
 
-  fun canRetry() = exchangeFinder!!.hasStreamFailure() && exchangeFinder!!.hasRouteToTry()
+  fun retryAfterFailure() = exchangeFinder!!.retryAfterFailure()
 
   /**
    * Returns a string that describes this call. Doesn't include a full URL as that might contain
@@ -59,8 +59,9 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
     val call = realChain.call
     var followUpCount = 0
     var priorResponse: Response? = null
+    var newExchangeFinder = true
     while (true) {
-      call.enterNetworkInterceptorExchange(request)
+      call.enterNetworkInterceptorExchange(request, newExchangeFinder)
 
       var response: Response
       var closeActiveExchange = true
@@ -71,17 +72,20 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
 
         try {
           response = realChain.proceed(request)
+          newExchangeFinder = true
         } catch (e: RouteException) {
           // The attempt to connect via a route failed. The request will not have been sent.
           if (!recover(e.lastConnectException, call, request, requestSendStarted = false)) {
             throw e.firstConnectException
           }
+          newExchangeFinder = false
           continue
         } catch (e: IOException) {
           // An attempt to communicate with a server failed. The request may have been sent.
           if (!recover(e, call, request, requestSendStarted = e !is ConnectionShutdownException)) {
             throw e
           }
+          newExchangeFinder = false
           continue
         }
 
@@ -147,7 +151,8 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
     if (!isRecoverable(e, requestSendStarted)) return false
 
     // No more routes to attempt.
-    if (!call.canRetry()) return false
+    if (!call.retryAfterFailure()) return false
+
     // For failure recovery, use the same route selector with a new connection.
     return true
   }
@@ -89,7 +89,7 @@ public final class ConnectionPoolTest {
           .connectionPool(poolApi)
           .build();
       RealCall call = (RealCall) client.newCall(newRequest(addressA));
-      call.enterNetworkInterceptorExchange(call.request());
+      call.enterNetworkInterceptorExchange(call.request(), true);
       call.acquireConnectionNoEvents(c1);
     }
 
@@ -211,7 +211,7 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
           .connectionPool(pool)
           .build();
       RealCall call = (RealCall) client.newCall(newRequest(connection.route().address()));
-      call.enterNetworkInterceptorExchange(call.request());
+      call.enterNetworkInterceptorExchange(call.request(), true);
       call.acquireConnectionNoEvents(connection);
     }
   }
@@ -853,6 +853,33 @@ private void waitForDataFrames(int dataLength) throws Exception {
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
+  /**
+   * We had a bug where we'd perform infinite retries of route that fail with connection shutdown
+   * errors. The problem was that the logic that decided whether to reuse a route didn't track
+   * certain HTTP/2 errors. https://github.com/square/okhttp/issues/5547
+   */
+  @Test
+  public void noRecoveryFromTwoRefusedStreams() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.getHttpCode()));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.getHttpCode()));
+    server.enqueue(new MockResponse()
+        .setBody(""abc""));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url(""/""))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertThat(expected.errorCode).isEqualTo(ErrorCode.REFUSED_STREAM);
+    }
+  }
+
   @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
"
https://github.com/apache/dubbo/commit/5caa422add46efa9b6de8c0e763e1ccecbcbfacd,just for modify comments and imports ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/5caa422add46efa9b6de8c0e763e1ccecbcbfacd,"@@ -52,18 +52,18 @@ public ZookeeperClient connect(URL url) {
         List<String> addressList = getURLBackupAddress(url);
         // The field define the zookeeper server , including protocol, host, port, username, password
         if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {
-            logger.info(""Get result from map for the first time when invoking zookeeperTransporter.connnect ."");
+            logger.info(""find valid zookeeper client from the cache for address: "" + url);
             return zookeeperClient;
         }
         // avoid creating too many connections， so add lock
         synchronized (zookeeperClientMap) {
             if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {
-                logger.info(""Get result from map for the second time when invoking zookeeperTransporter.connnect ."");
+                logger.info(""find valid zookeeper client from the cache for address: "" + url);
                 return zookeeperClient;
             }
 
-            zookeeperClient = createZookeeperClient(createServerURL(url));
-            logger.info(""Get result by creating new connection when invoking zookeeperTransporter.connnect ."");
+            zookeeperClient = createZookeeperClient(toClientURL(url));
+            logger.info(""No valid zookeeper client found from cache, therefore create a new client for url. "" + url);
             writeToClientMap(addressList, zookeeperClient);
         }
         return zookeeperClient;
@@ -131,7 +131,7 @@ void writeToClientMap(List<String> addressList, ZookeeperClient zookeeperClient)
      * @param url
      * @return
      */
-    URL createServerURL(URL url) {
+    URL toClientURL(URL url) {
         Map<String, String> parameterMap = new HashMap<>();
         // for CuratorZookeeperClient
         if (url.getParameter(Constants.TIMEOUT_KEY) != null) {
@@ -16,13 +16,14 @@
  */
 package org.apache.dubbo.remoting.zookeeper.support;
 
-import org.apache.curator.test.TestingServer;
 import org.apache.dubbo.common.Constants;
 import org.apache.dubbo.common.URL;
 import org.apache.dubbo.common.utils.NetUtils;
 import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
 import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
 import org.apache.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter;
+
+import org.apache.curator.test.TestingServer;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
@@ -67,7 +68,7 @@ public void testZookeeperClient() {
     @Test
     public void testCreateServerURL() {
         URL url = URL.valueOf(""zookeeper://127.0.0.1:"" + zkServerPort + ""/org.apache.dubbo.registry.RegistryService?application=metadatareport-local-xml-provider2&dubbo=2.0.2&interface=org.apache.dubbo.registry.RegistryService&pid=47418&specVersion=2.7.0-SNAPSHOT&timestamp=1547102428828&timeout=2300"");
-        URL newUrl = abstractZookeeperTransporter.createServerURL(url);
+        URL newUrl = abstractZookeeperTransporter.toClientURL(url);
         Assert.assertEquals(newUrl.getProtocol(), ""zookeeper"");
         Assert.assertEquals(newUrl.getHost(), ""127.0.0.1"");
         Assert.assertEquals(newUrl.getPort(), zkServerPort);
@@ -80,9 +81,9 @@ public void testCreateServerURL() {
 
 
     @Test
-    public void testCreateServerURLWhenHasUser() {
+    public void testToCreateURLWhenHasUser() {
         URL url = URL.valueOf(""zookeeper://us2:pw2@127.0.0.1:"" + zkServerPort + ""/org.apache.dubbo.registry.RegistryService?application=metadatareport-local-xml-provider2&dubbo=2.0.2&interface=org.apache.dubbo.registry.RegistryService&pid=47418&specVersion=2.7.0-SNAPSHOT&timestamp=1547102428828"");
-        URL newUrl = abstractZookeeperTransporter.createServerURL(url);
+        URL newUrl = abstractZookeeperTransporter.toClientURL(url);
         Assert.assertEquals(newUrl.getProtocol(), ""zookeeper"");
         Assert.assertEquals(newUrl.getHost(), ""127.0.0.1"");
         Assert.assertEquals(newUrl.getPort(), zkServerPort);
"
https://github.com/square/retrofit/commit/745e29b7832c3cc37e7b6d395aded79a908c3bbc,"Remove deprecated error identifier.  <enter> This whole class is probably going to die or morph, but killing off tech debt before major refactorings makes me feel good. ",https://api.github.com/repos/square/retrofit/commits/745e29b7832c3cc37e7b6d395aded79a908c3bbc,"@@ -86,15 +86,6 @@ public Response getResponse() {
     return response;
   }
 
-  /**
-   * Whether or not this error was the result of a network error.
-   *
-   * @deprecated Use {@link #getKind() getKind() == Kind.NETWORK}.
-   */
-  @Deprecated public boolean isNetworkError() {
-    return kind == Kind.NETWORK;
-  }
-
   /** The event kind which triggered this error. */
   public Kind getKind() {
     return kind;
@@ -577,7 +577,6 @@ private interface InvalidExample extends Example {
       fail(""RetrofitError expected on malformed response body."");
     } catch (RetrofitError e) {
       assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-      assertThat(e.isNetworkError());
       assertThat(e.getCause()).isInstanceOf(IOException.class);
       assertThat(e.getCause()).hasMessage(""I'm broken!"");
     }
"
https://github.com/spring-projects/spring-boot/commit/5afe4743cbf4ff69ffe4bbcefa4508b1a4ac6f4b,Remove deprecated configuration properties  <enter> This commit removes the following deprecated properties: <enter> * `server.connection-timeout` * `server.use-forward-headers` * `server.jetty.max-http-post-size` * `server.tomcat.max-http-post-size` <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/5afe4743cbf4ff69ffe4bbcefa4508b1a4ac6f4b,"@@ -100,13 +100,6 @@ public class ServerProperties {
 	 */
 	private DataSize maxHttpHeaderSize = DataSize.ofKilobytes(8);
 
-	/**
-	 * Time that connectors wait for another HTTP request before closing the connection.
-	 * When not set, the connector's container-specific default is used. Use a value of -1
-	 * to indicate no (that is, an infinite) timeout.
-	 */
-	private Duration connectionTimeout;
-
 	@NestedConfigurationProperty
 	private Ssl ssl;
 
@@ -145,17 +138,6 @@ public void setAddress(InetAddress address) {
 		this.address = address;
 	}
 
-	@DeprecatedConfigurationProperty(reason = ""replaced to support additional strategies"",
-			replacement = ""server.forward-headers-strategy"")
-	public Boolean isUseForwardHeaders() {
-		return ForwardHeadersStrategy.NATIVE.equals(this.forwardHeadersStrategy);
-	}
-
-	public void setUseForwardHeaders(Boolean useForwardHeaders) {
-		this.forwardHeadersStrategy = Boolean.TRUE.equals(useForwardHeaders) ? ForwardHeadersStrategy.NATIVE
-				: ForwardHeadersStrategy.NONE;
-	}
-
 	public String getServerHeader() {
 		return this.serverHeader;
 	}
@@ -172,18 +154,6 @@ public void setMaxHttpHeaderSize(DataSize maxHttpHeaderSize) {
 		this.maxHttpHeaderSize = maxHttpHeaderSize;
 	}
 
-	@Deprecated
-	@DeprecatedConfigurationProperty(
-			reason = ""Each server behaves differently. Use server specific properties instead."")
-	public Duration getConnectionTimeout() {
-		return this.connectionTimeout;
-	}
-
-	@Deprecated
-	public void setConnectionTimeout(Duration connectionTimeout) {
-		this.connectionTimeout = connectionTimeout;
-	}
-
 	public ErrorProperties getError() {
 		return this.error;
 	}
@@ -443,17 +413,6 @@ public void setMinSpareThreads(int minSpareThreads) {
 			this.getThreads().setMinSpare(minSpareThreads);
 		}
 
-		@Deprecated
-		@DeprecatedConfigurationProperty(replacement = ""server.tomcat.max-http-form-post-size"")
-		public DataSize getMaxHttpPostSize() {
-			return this.maxHttpFormPostSize;
-		}
-
-		@Deprecated
-		public void setMaxHttpPostSize(DataSize maxHttpPostSize) {
-			this.maxHttpFormPostSize = maxHttpPostSize;
-		}
-
 		public DataSize getMaxHttpFormPostSize() {
 			return this.maxHttpFormPostSize;
 		}
@@ -1084,17 +1043,6 @@ public Threads getThreads() {
 			return this.threads;
 		}
 
-		@Deprecated
-		@DeprecatedConfigurationProperty(replacement = ""server.jetty.max-http-form-post-size"")
-		public DataSize getMaxHttpPostSize() {
-			return this.maxHttpFormPostSize;
-		}
-
-		@Deprecated
-		public void setMaxHttpPostSize(DataSize maxHttpPostSize) {
-			this.maxHttpFormPostSize = maxHttpPostSize;
-		}
-
 		public DataSize getMaxHttpFormPostSize() {
 			return this.maxHttpFormPostSize;
 		}
@@ -87,8 +87,6 @@ public void customize(ConfigurableJettyWebServerFactory factory) {
 						.addServerCustomizers(new MaxHttpHeaderSizeCustomizer(maxHttpHeaderSize)));
 		propertyMapper.from(jettyProperties::getMaxHttpFormPostSize).asInt(DataSize::toBytes).when(this::isPositive)
 				.to((maxHttpFormPostSize) -> customizeMaxHttpFormPostSize(factory, maxHttpFormPostSize));
-		propertyMapper.from(properties::getConnectionTimeout).whenNonNull()
-				.to((connectionTimeout) -> customizeIdleTimeout(factory, connectionTimeout));
 		propertyMapper.from(jettyProperties::getConnectionIdleTimeout).whenNonNull()
 				.to((idleTimeout) -> customizeIdleTimeout(factory, idleTimeout));
 		propertyMapper.from(jettyProperties::getAccesslog).when(ServerProperties.Jetty.Accesslog::isEnabled)
@@ -60,8 +60,6 @@ public void customize(NettyReactiveWebServerFactory factory) {
 		PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
 		propertyMapper.from(this.serverProperties::getMaxHttpHeaderSize)
 				.to((maxHttpRequestHeaderSize) -> customizeMaxHttpHeaderSize(factory, maxHttpRequestHeaderSize));
-		propertyMapper.from(this.serverProperties::getConnectionTimeout)
-				.to((connectionTimeout) -> customizeGenericConnectionTimeout(factory, connectionTimeout));
 		ServerProperties.Netty nettyProperties = this.serverProperties.getNetty();
 		propertyMapper.from(nettyProperties::getConnectionTimeout).whenNonNull()
 				.to((connectionTimeout) -> customizeConnectionTimeout(factory, connectionTimeout));
@@ -80,14 +78,6 @@ private void customizeMaxHttpHeaderSize(NettyReactiveWebServerFactory factory, D
 				(httpRequestDecoderSpec) -> httpRequestDecoderSpec.maxHeaderSize((int) maxHttpHeaderSize.toBytes())));
 	}
 
-	private void customizeGenericConnectionTimeout(NettyReactiveWebServerFactory factory, Duration connectionTimeout) {
-		if (!connectionTimeout.isZero()) {
-			long timeoutMillis = connectionTimeout.isNegative() ? 0 : connectionTimeout.toMillis();
-			factory.addServerCustomizers((httpServer) -> httpServer.tcpConfiguration((tcpServer) -> tcpServer
-					.selectorOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, (int) timeoutMillis)));
-		}
-	}
-
 	private void customizeConnectionTimeout(NettyReactiveWebServerFactory factory, Duration connectionTimeout) {
 		factory.addServerCustomizers((httpServer) -> httpServer.tcpConfiguration((tcpServer) -> tcpServer
 				.selectorOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, (int) connectionTimeout.toMillis())));
@@ -100,8 +100,6 @@ public void customize(ConfigurableTomcatWebServerFactory factory) {
 		propertyMapper.from(tomcatProperties::getAccesslog).when(ServerProperties.Tomcat.Accesslog::isEnabled)
 				.to((enabled) -> customizeAccessLog(factory));
 		propertyMapper.from(tomcatProperties::getUriEncoding).whenNonNull().to(factory::setUriEncoding);
-		propertyMapper.from(properties::getConnectionTimeout).whenNonNull()
-				.to((connectionTimeout) -> customizeConnectionTimeout(factory, connectionTimeout));
 		propertyMapper.from(tomcatProperties::getConnectionTimeout).whenNonNull()
 				.to((connectionTimeout) -> customizeConnectionTimeout(factory, connectionTimeout));
 		propertyMapper.from(tomcatProperties::getMaxConnections).when(this::isPositive)
@@ -78,8 +78,6 @@ public void customize(ConfigurableUndertowWebServerFactory factory) {
 		ServerProperties properties = this.serverProperties;
 		map.from(properties::getMaxHttpHeaderSize).asInt(DataSize::toBytes).when(this::isPositive)
 				.to(options.server(UndertowOptions.MAX_HEADER_SIZE));
-		map.from(properties::getConnectionTimeout).asInt(Duration::toMillis)
-				.to(options.server(UndertowOptions.NO_REQUEST_TIMEOUT));
 		mapUndertowProperties(factory, options);
 		mapAccessLogProperties(factory);
 		map.from(this::getOrDeduceUseForwardHeaders).to(factory::setUseForwardHeaders);
@@ -29,6 +29,14 @@
         ""level"": ""error""
       }
     },
+    {
+      ""name"": ""server.connection-timeout"",
+      ""type"" : ""java.time.Duration"",
+      ""deprecation"": {
+        ""reason"": ""Each server behaves differently. Use server specific properties instead."",
+        ""level"": ""error""
+      }
+    },
     {
       ""name"": ""server.jetty.accesslog.date-format"",
       ""deprecation"": {
@@ -119,6 +127,14 @@
       ""description"": ""Whether to enable HTTP/2 support, if the current environment supports it."",
       ""defaultValue"": false
     },
+    {
+      ""name"": ""server.jetty.max-http-post-size"",
+      ""type"": ""org.springframework.util.unit.DataSize"",
+      ""deprecation"": {
+        ""replacement"": ""server.jetty.max-http-form-post-size"",
+        ""level"": ""error""
+      }
+    },
     {
       ""name"": ""server.port"",
       ""defaultValue"": 8080
@@ -245,6 +261,23 @@
       ""name"": ""server.ssl.trust-store-type"",
       ""description"": ""Type of the trust store.""
     },
+    {
+      ""name"": ""server.tomcat.max-http-post-size"",
+      ""type"": ""org.springframework.util.unit.DataSize"",
+      ""deprecation"": {
+        ""replacement"": ""server.tomcat.max-http-form-post-size"",
+        ""level"": ""error""
+      }
+    },
+    {
+      ""name"": ""server.use-forward-headers"",
+      ""type"": ""java.lang.Boolean"",
+      ""deprecation"": {
+        ""reason"": ""Replaced to support additional strategies."",
+        ""replacement"": ""server.forward-headers-strategy"",
+        ""level"": ""error""
+      }
+    },
     {
       ""name"": ""spring.aop.auto"",
       ""type"": ""java.lang.Boolean"",
@@ -105,12 +105,6 @@ void testServerHeader() {
 		assertThat(this.properties.getServerHeader()).isEqualTo(""Custom Server"");
 	}
 
-	@Test
-	void testConnectionTimeout() {
-		bind(""server.connection-timeout"", ""60s"");
-		assertThat(this.properties.getConnectionTimeout()).hasMillis(60000);
-	}
-
 	@Test
 	void testTomcatBinding() {
 		Map<String, String> map = new HashMap<>();
@@ -403,7 +397,7 @@ void tomcatMinSpareThreadsMatchesProtocolDefault() throws Exception {
 
 	@Test
 	void tomcatMaxHttpPostSizeMatchesConnectorDefault() throws Exception {
-		assertThat(this.properties.getTomcat().getMaxHttpPostSize().toBytes())
+		assertThat(this.properties.getTomcat().getMaxHttpFormPostSize().toBytes())
 				.isEqualTo(getDefaultConnector().getMaxPostSize());
 	}
 
@@ -41,6 +41,7 @@
 import org.junit.jupiter.api.Test;
 
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.ServerProperties.ForwardHeadersStrategy;
 import org.springframework.boot.autoconfigure.web.ServerProperties.Jetty;
 import org.springframework.boot.context.properties.bind.Bindable;
 import org.springframework.boot.context.properties.bind.Binder;
@@ -251,7 +252,7 @@ private RequestLogWriter getLogWriter(CustomRequestLog requestLog) {
 
 	@Test
 	void setUseForwardHeaders() {
-		this.serverProperties.setUseForwardHeaders(true);
+		this.serverProperties.setForwardHeadersStrategy(ForwardHeadersStrategy.NATIVE);
 		ConfigurableJettyWebServerFactory factory = mock(ConfigurableJettyWebServerFactory.class);
 		this.customizer.customize(factory);
 		verify(factory).setUseForwardHeaders(true);
@@ -30,6 +30,7 @@
 import reactor.netty.tcp.TcpServer;
 
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.ServerProperties.ForwardHeadersStrategy;
 import org.springframework.boot.context.properties.source.ConfigurationPropertySources;
 import org.springframework.boot.web.embedded.netty.NettyReactiveWebServerFactory;
 import org.springframework.boot.web.embedded.netty.NettyServerCustomizer;
@@ -84,14 +85,6 @@ void defaultUseForwardHeaders() {
 		verify(factory).setUseForwardHeaders(false);
 	}
 
-	@Test
-	void setUseForwardHeaders() {
-		this.serverProperties.setUseForwardHeaders(true);
-		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
-		this.customizer.customize(factory);
-		verify(factory).setUseForwardHeaders(true);
-	}
-
 	@Test
 	void forwardHeadersWhenStrategyIsNativeShouldConfigureValve() {
 		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NATIVE);
@@ -109,30 +102,6 @@ void forwardHeadersWhenStrategyIsNoneShouldNotConfigureValve() {
 		verify(factory).setUseForwardHeaders(false);
 	}
 
-	@Test
-	void setServerConnectionTimeoutAsZero() {
-		setupServerConnectionTimeout(Duration.ZERO);
-		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
-		this.customizer.customize(factory);
-		verifyConnectionTimeout(factory, null);
-	}
-
-	@Test
-	void setServerConnectionTimeoutAsMinusOne() {
-		setupServerConnectionTimeout(Duration.ofNanos(-1));
-		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
-		this.customizer.customize(factory);
-		verifyConnectionTimeout(factory, 0);
-	}
-
-	@Test
-	void setServerConnectionTimeout() {
-		setupServerConnectionTimeout(Duration.ofSeconds(1));
-		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
-		this.customizer.customize(factory);
-		verifyConnectionTimeout(factory, 1000);
-	}
-
 	@Test
 	void setConnectionTimeout() {
 		setupConnectionTimeout(Duration.ofSeconds(1));
@@ -156,14 +125,8 @@ private void verifyConnectionTimeout(NettyReactiveWebServerFactory factory, Inte
 		assertThat(options).containsEntry(ChannelOption.CONNECT_TIMEOUT_MILLIS, expected);
 	}
 
-	private void setupServerConnectionTimeout(Duration connectionTimeout) {
-		this.serverProperties.setUseForwardHeaders(null);
-		this.serverProperties.setMaxHttpHeaderSize(null);
-		this.serverProperties.setConnectionTimeout(connectionTimeout);
-	}
-
 	private void setupConnectionTimeout(Duration connectionTimeout) {
-		this.serverProperties.setUseForwardHeaders(null);
+		this.serverProperties.setForwardHeadersStrategy(ForwardHeadersStrategy.NONE);
 		this.serverProperties.setMaxHttpHeaderSize(null);
 		this.serverProperties.getNetty().setConnectionTimeout(connectionTimeout);
 	}
@@ -32,6 +32,7 @@
 import org.junit.jupiter.api.Test;
 
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.ServerProperties.ForwardHeadersStrategy;
 import org.springframework.boot.context.properties.bind.Bindable;
 import org.springframework.boot.context.properties.bind.Binder;
 import org.springframework.boot.context.properties.source.ConfigurationPropertySources;
@@ -111,12 +112,6 @@ void customBackgroundProcessorDelay() {
 		assertThat(server.getTomcat().getEngine().getBackgroundProcessorDelay()).isEqualTo(5);
 	}
 
-	@Test
-	void customDisableMaxHttpPostSize() {
-		bind(""server.tomcat.max-http-post-size=-1"");
-		customizeAndRunServer((server) -> assertThat(server.getTomcat().getConnector().getMaxPostSize()).isEqualTo(-1));
-	}
-
 	@Test
 	void customDisableMaxHttpFormPostSize() {
 		bind(""server.tomcat.max-http-form-post-size=-1"");
@@ -131,13 +126,6 @@ void customMaxConnections() {
 						.isEqualTo(5));
 	}
 
-	@Test
-	void customMaxHttpPostSize() {
-		bind(""server.tomcat.max-http-post-size=10000"");
-		customizeAndRunServer(
-				(server) -> assertThat(server.getTomcat().getConnector().getMaxPostSize()).isEqualTo(10000));
-	}
-
 	@Test
 	void customMaxHttpFormPostSize() {
 		bind(""server.tomcat.max-http-form-post-size=10000"");
@@ -289,9 +277,8 @@ void defaultRemoteIpValve() {
 	}
 
 	@Test
-	void setUseForwardHeaders() {
-		// Since 1.3.0 no need to explicitly set header names if use-forward-header=true
-		this.serverProperties.setUseForwardHeaders(true);
+	void setUseNativeForwardHeadersStrategy() {
+		this.serverProperties.setForwardHeadersStrategy(ForwardHeadersStrategy.NATIVE);
 		testRemoteIpValveConfigured();
 	}
 
@@ -210,14 +210,6 @@ void defaultUseForwardHeaders() {
 		verify(factory).setUseForwardHeaders(false);
 	}
 
-	@Test
-	void setUseForwardHeaders() {
-		this.serverProperties.setUseForwardHeaders(true);
-		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
-		this.customizer.customize(factory);
-		verify(factory).setUseForwardHeaders(true);
-	}
-
 	@Test
 	void forwardHeadersWhenStrategyIsNativeShouldConfigureValve() {
 		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NATIVE);
@@ -1,3 +1,3 @@
 server.compression.enabled: true
 server.compression.min-response-size: 1
-server.connection-timeout=5000
+server.tomcat.connection-timeout=5s
"
https://github.com/spring-projects/spring-boot/commit/24e873cd7c2608e642fd6e90460bc98079ba4e27,Move files from /.eclipse into /eclipse  <enter> Move the `eclipse.properties` file from `.eclipse` into `eclipse` since the IDE plugin supports both. ,https://api.github.com/repos/spring-projects/spring-boot/commits/24e873cd7c2608e642fd6e90460bc98079ba4e27,
https://github.com/square/okhttp/commit/0e0f3a2d8d95278bf362eaeb08f13516e383fafd,"Push OkHttp 3.14.x into the sea. It is no longer supported. ( <pr_link> )  <enter> OkHttp 4.x is our only branch receiving security fixes, bug fixes, and new features. <enter> OkHttp 3.12.x gets security fixes only. ",https://api.github.com/repos/square/okhttp/commits/0e0f3a2d8d95278bf362eaeb08f13516e383fafd,"@@ -6,7 +6,6 @@ Security Policy
 | Version | Supported        | Notes          |
 | ------- | ---------------- | -------------- |
 | 4.x     | ✅               |  Android 5.0+ (API level 21+) and on Java 8+. |
-| 3.14.x  | Until 2020-06-30 |                |
 | 3.12.x  | Until 2021-12-31 | Android 2.3+ (API level 9+) and Java 7+. Platforms may not support TLSv1.2. |
 
 
"
https://github.com/square/retrofit/commit/246bef5bf34c0598a91038b2e15bace7718408d4,Remove old ProGuard nonsense.  <enter> As of API 26 the android.jar contains the classes checked by Platform and used by Platform.Java8. And we don't encourage throwing checked exceptions from the service method but instead routing them through your call adapter. ,https://api.github.com/repos/square/retrofit/commits/246bef5bf34c0598a91038b2e15bace7718408d4,"@@ -30,10 +30,16 @@ Retrofit requires at minimum Java 7 or Android 2.3.
 ProGuard
 --------
 
-If you are using ProGuard you might need to add the following options:
+If you are using ProGuard you need to add the following options:
 ```
--dontwarn okio.**
--dontwarn javax.annotation.**
+# Retain generic type information for use by reflection by converters and adapters.
+-keepattributes Signature
+# Retain service method parameters.
+-keepclassmembernames,allowobfuscation interface * {
+    @retrofit2.http.* <methods>;
+}
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
 ```
 
 
@@ -176,18 +176,14 @@ <h4>Gradle</h4>
               <h4>ProGuard</h4>
               <p>If you are using ProGuard in your project add the following lines to your configuration:</p>
               <pre class=""prettyprint"">
-# Platform calls Class.forName on types which do not exist on Android to determine platform.
--dontnote retrofit2.Platform
-# Platform used when running on Java 8 VMs. Will not be used at runtime.
--dontwarn retrofit2.Platform$Java8
 # Retain generic type information for use by reflection by converters and adapters.
 -keepattributes Signature
-# Retain declared checked exceptions for use by a Proxy instance.
--keepattributes Exceptions
 # Retain service method parameters.
 -keepclassmembernames,allowobfuscation interface * {
     @retrofit2.http.* <methods>;
 }
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
 </pre>
             <p>Retrofit uses <a href=""https://github.com/square/okio"">Okio</a> under the hood, so you may want to look at its <a href=""https://github.com/square/okio#proguard"">ProGuard rules</a> as well.</p>
             </section>
"
https://github.com/square/retrofit/commit/2e15cf9e75e4204aa492ecc1cbe53053f95a2a8f,Promote Android logging to a class which knows about chunking.  <enter> Remove the concept of chunking from calling code. This is an Android-specific implementation detail which is now only performed when needed. ,https://api.github.com/repos/square/retrofit/commits/2e15cf9e75e4204aa492ecc1cbe53053f95a2a8f,"@@ -17,12 +17,12 @@
 
 import android.os.Build;
 import android.os.Process;
-import android.util.Log;
 import com.google.gson.Gson;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
 import retrofit.android.AndroidApacheClient;
+import retrofit.android.AndroidLog;
 import retrofit.android.MainThreadExecutor;
 import retrofit.client.Client;
 import retrofit.client.OkClient;
@@ -143,11 +143,7 @@ private static class Android extends Platform {
     }
 
     @Override RestAdapter.Log defaultLog() {
-      return new RestAdapter.Log() {
-        @Override public void log(String message) {
-          Log.d(""Retrofit"", message);
-        }
-      };
+      return new AndroidLog(""Retrofit"");
     }
   }
 
@@ -107,7 +107,6 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public class RestAdapter {
-  private static final int LOG_CHUNK_SIZE = 4000;
   static final String THREAD_PREFIX = ""Retrofit-"";
   static final String IDLE_THREAD_NAME = THREAD_PREFIX + ""Idle"";
 
@@ -396,11 +395,7 @@ private Request logAndReplaceRequest(Request request) throws IOException {
           byte[] bodyBytes = ((TypedByteArray) body).getBytes();
           bodySize = bodyBytes.length;
           String bodyCharset = MimeUtil.parseCharset(bodyMime);
-          String bodyString = new String(bodyBytes, bodyCharset);
-          for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
-            int end = Math.min(len, i + LOG_CHUNK_SIZE);
-            log.log(bodyString.substring(i, end));
-          }
+          log.log(new String(bodyBytes, bodyCharset));
         }
       }
 
@@ -440,11 +435,7 @@ private Response logAndReplaceResponse(String url, Response response, long elaps
           bodySize = bodyBytes.length;
           String bodyMime = body.mimeType();
           String bodyCharset = MimeUtil.parseCharset(bodyMime);
-          String bodyString = new String(bodyBytes, bodyCharset);
-          for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
-            int end = Math.min(len, i + LOG_CHUNK_SIZE);
-            log.log(bodyString.substring(i, end));
-          }
+          log.log(new String(bodyBytes, bodyCharset));
         }
       }
 
@@ -0,0 +1,22 @@
+package retrofit.android;
+
+import android.util.Log;
+import retrofit.RestAdapter;
+
+/** A {@link RestAdapter.Log logger} for Android. */
+public class AndroidLog implements RestAdapter.Log {
+  private static final int LOG_CHUNK_SIZE = 4000;
+
+  private final String tag;
+
+  public AndroidLog(String tag) {
+    this.tag = tag;
+  }
+
+  @Override public void log(String message) {
+    for (int i = 0, len = message.length(); i < len; i += LOG_CHUNK_SIZE) {
+      int end = Math.min(len, i + LOG_CHUNK_SIZE);
+      Log.d(tag, message.substring(i, end));
+    }
+  }
+}
"
https://github.com/square/retrofit/commit/9d683b75b111e60d30da8a03335d2ce71f5e8585,"Migrate forced suspension mechanism from yield to Dispatcher.Default  <enter> Since it's possible for certain dispatchers to completely avoid yielding, and currently the immediate dispatchers exhibit this behavior, we need an alternate mechanism of forcing suspension or UndeclaredThrowableExceptions will still be seen. <enter> Retrofit does not have its own thread pool onto which we can defer resuming. Instead we rely to Dispatchers.Default and forcibly suspend the caller using low-level coroutine intrinsics. ",https://api.github.com/repos/square/retrofit/commits/9d683b75b111e60d30da8a03335d2ce71f5e8585,"@@ -170,7 +170,7 @@ static final class SuspendForResponse<ResponseT> extends HttpServiceMethod<Respo
       try {
         return KotlinExtensions.awaitResponse(call, continuation);
       } catch (Exception e) {
-        return KotlinExtensions.yieldAndThrow(e, continuation);
+        return KotlinExtensions.suspendAndThrow(e, continuation);
       }
     }
   }
@@ -206,7 +206,7 @@ static final class SuspendForBody<ResponseT> extends HttpServiceMethod<ResponseT
             ? KotlinExtensions.awaitNullable(call, continuation)
             : KotlinExtensions.await(call, continuation);
       } catch (Exception e) {
-        return KotlinExtensions.yieldAndThrow(e, continuation);
+        return KotlinExtensions.suspendAndThrow(e, continuation);
       }
     }
   }
@@ -18,8 +18,11 @@
 
 package retrofit2
 
+import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.suspendCancellableCoroutine
-import kotlinx.coroutines.yield
+import kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED
+import kotlin.coroutines.intrinsics.intercepted
+import kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn
 import kotlin.coroutines.resume
 import kotlin.coroutines.resumeWithException
 
@@ -97,7 +100,20 @@ suspend fun <T : Any> Call<T>.awaitResponse(): Response<T> {
   }
 }
 
-internal suspend fun Exception.yieldAndThrow(): Nothing {
-  yield()
-  throw this
+/**
+ * Force the calling coroutine to suspend before throwing [this].
+ *
+ * This is needed when a checked exception is synchronously caught in a [java.lang.reflect.Proxy]
+ * invocation to avoid being wrapped in [java.lang.reflect.UndeclaredThrowableException].
+ *
+ * The implementation is derived from:
+ * https://github.com/Kotlin/kotlinx.coroutines/pull/1667#issuecomment-556106349
+ */
+internal suspend fun Exception.suspendAndThrow(): Nothing {
+  suspendCoroutineUninterceptedOrReturn<Nothing> { continuation ->
+    Dispatchers.Default.dispatch(continuation.context, Runnable {
+      continuation.intercepted().resumeWithException(this@suspendAndThrow)
+    })
+    COROUTINE_SUSPENDED
+  }
 }
@@ -15,9 +15,11 @@
  */
 package retrofit2
 
+import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.GlobalScope
 import kotlinx.coroutines.async
 import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.withContext
 import okhttp3.OkHttpClient
 import okhttp3.mockwebserver.MockResponse
 import okhttp3.mockwebserver.MockWebServer
@@ -35,6 +37,7 @@ import retrofit2.http.Path
 import java.io.IOException
 import java.lang.reflect.ParameterizedType
 import java.lang.reflect.Type
+import kotlin.coroutines.CoroutineContext
 
 class KotlinSuspendTest {
   @get:Rule val server = MockWebServer()
@@ -283,15 +286,19 @@ class KotlinSuspendTest {
 
     server.shutdown()
 
-    // The problematic behavior of the UnknownHostException being synchronously thrown is
-    // probabilistic based on thread preemption. Running a thousand times will almost always
-    // trigger it, so we run an order of magnitude more to be safe.
-    repeat(10000) {
-      try {
-        example.body()
-        fail()
-      } catch (_: IOException) {
-        // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+    // Run with a dispatcher that prevents yield from actually deferring work. An old workaround
+    // for this problem relied on yield, but it is not guaranteed to prevent direct execution.
+    withContext(DirectUnconfinedDispatcher) {
+      // The problematic behavior of the UnknownHostException being synchronously thrown is
+      // probabilistic based on thread preemption. Running a thousand times will almost always
+      // trigger it, so we run an order of magnitude more to be safe.
+      repeat(10000) {
+        try {
+          example.body()
+          fail()
+        } catch (_: IOException) {
+          // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+        }
       }
     }
   }
@@ -305,16 +312,25 @@ class KotlinSuspendTest {
 
     server.shutdown()
 
-    // The problematic behavior of the UnknownHostException being synchronously thrown is
-    // probabilistic based on thread preemption. Running a thousand times will almost always
-    // trigger it, so we run an order of magnitude more to be safe.
-    repeat(10000) {
-      try {
-        example.response()
-        fail()
-      } catch (_: IOException) {
-        // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+    // Run with a dispatcher that prevents yield from actually deferring work. An old workaround
+    // for this problem relied on yield, but it is not guaranteed to prevent direct execution.
+    withContext(DirectUnconfinedDispatcher) {
+      // The problematic behavior of the UnknownHostException being synchronously thrown is
+      // probabilistic based on thread preemption. Running a thousand times will almost always
+      // trigger it, so we run an order of magnitude more to be safe.
+      repeat(10000) {
+        try {
+          example.response()
+          fail()
+        } catch (_: IOException) {
+          // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+        }
       }
     }
   }
+
+  private object DirectUnconfinedDispatcher : CoroutineDispatcher() {
+    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false
+    override fun dispatch(context: CoroutineContext, block: Runnable) = block.run()
+  }
 }
"
https://github.com/spring-projects/spring-boot/commit/ae3225e76e6f5e7d7680bfd9b5cca9da13a6efbc,"Mention that Lettuce requires commons-pool2  <enter> We intend to remove this limitation in a future milestone but as the Lettuce auto-configuration requires `commons-pool2`, this commit updates the How-To to mention that. <enter> See  <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/ae3225e76e6f5e7d7680bfd9b5cca9da13a6efbc,"@@ -3081,8 +3081,9 @@ normal in a Spring Boot application (you normally only have one application cont
 === Use Lettuce instead of Jedis
 The Spring Boot starter (`spring-boot-starter-data-redis`) uses
 https://github.com/xetorthio/jedis/[Jedis] by default. You need to exclude that dependency
-and include the https://github.com/lettuce-io/lettuce-core/[Lettuce] one instead. Spring
-Boot manages that dependency to help make this process as easy as possible.
+and include the https://github.com/lettuce-io/lettuce-core/[Lettuce] one instead. You also
+need `commons-pool2`. Spring Boot manages these dependencies to help make this process as
+easy as possible.
 
 Example in Maven:
 
@@ -3102,6 +3103,10 @@ Example in Maven:
 		<groupId>io.lettuce</groupId>
 		<artifactId>lettuce-core</artifactId>
 	</dependency>
+	<dependency>
+		<groupId>org.apache.commons</groupId>
+		<artifactId>commons-pool2</artifactId>
+	</dependency>
 ----
 
 Example in Gradle:
@@ -3113,7 +3118,8 @@ Example in Gradle:
 	}
 
 	dependencies {
-		compile(""io.lettuce:lettuce-core:{lettuce.version}"")
+		compile(""io.lettuce:lettuce-core"")
+		compile(""org.apache.commons:commons-pool2"")
 		// ...
 	}
 ----
"
https://github.com/junit-team/junit4/commit/1360f9b696f2fb1bc32b16b070ffb3363a88864f,Update Maven GPG plugin from 1.4 to 1.5.  <enter> Just to keep up-to-date. Release notes:  http://jira.codehaus.org/browse/MGPG/fixforversion/17635 ,https://api.github.com/repos/junit-team/junit4/commits/1360f9b696f2fb1bc32b16b070ffb3363a88864f,"@@ -289,7 +289,7 @@
                         (&ndash;&ndash; stands for double dash)
                         -->
                         <artifactId>maven-gpg-plugin</artifactId>
-                        <version>1.4</version>
+                        <version>1.5</version>
                         <executions>
                             <execution>
                                 <id>gpg-sign</id>
"
https://github.com/square/okhttp/commit/16f1d048165d2bf0aee4833ff7d8b415f537ce64,"api has changed, fixing the example ",https://api.github.com/repos/square/okhttp/commits/16f1d048165d2bf0aee4833ff7d8b415f537ce64,"@@ -42,7 +42,7 @@ public void test() throws Exception {
   server.start();
 
   // Ask the server for its URL. You'll need this to make HTTP requests.
-  URL baseUrl = server.url(""/v1/chat/"");
+  HttpUrl baseUrl = server.url(""/v1/chat/"");
 
   // Exercise your application code, which should make those HTTP requests.
   // Responses are returned in the same order that they are enqueued.
"
https://github.com/square/okhttp/commit/32a2b1d8d000a19d4a340cc1d77a68973a9d65dc,"OkBuffer API sketch.  <enter> I'm unhappy with java.io:  * No timeouts.  * Every layer needs to copy bytes around. Always copying bytes.  * Features like mark/reset and available() are clumsy.  * Its awkard in mixed text/binary protocols like HTTP because    character decoding is separate and takes over the stream. <enter> Unfortunately java.nio isn't better, just different:  * It's complex.  * Buffers are fixed size.  * No built-in buffer pooling.  * Features like mark/reset/position are clumsy. <enter> This is an obnoxious attempt at a 3rd I/O interface, mostly inspired by InputStream and OutputStream, but using growable buffers instead of byte arrays as the core data container. ",https://api.github.com/repos/square/okhttp/commits/32a2b1d8d000a19d4a340cc1d77a68973a9d65dc,"@@ -18,7 +18,7 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.util.Arrays;
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal;
 
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.lang.reflect.Constructor;
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package com.squareup.okhttp.internal.bytes;
 
+import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -34,7 +35,7 @@
  * process.
  */
 public final class ByteString {
-  private final byte[] data;
+  final byte[] data;
   private transient int hashCode; // Lazily computed; 0 if unknown.
   private transient String utf8; // Lazily computed.
 
@@ -119,7 +120,7 @@ public static ByteString concat(ByteString... byteStrings) {
     return new ByteString(result);
   }
 
-  private ByteString(byte[] data) {
+  ByteString(byte[] data) {
     this.data = data; // Trusted internal constructor doesn't clone data.
   }
 
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+
+/**
+ * A collection of bytes in memory.
+ *
+ * <p><strong>Moving data from one OkBuffer to another is fast.</strong> Instead
+ * of copying bytes from one place in memory to another, this class just changes
+ * ownership of the underlying bytes.
+ *
+ * <p><strong>This buffer grows with your data.</strong> Just like ArrayList,
+ * each OkBuffer starts small. It consumes only the memory it needs to.
+ *
+ * <p><strong>This buffer pools its byte arrays.</strong> When you allocate a
+ * byte array in Java, the runtime must zero-fill the requested array before
+ * returning it to you. Even if you're going to write over that space anyway.
+ * This class avoids zero-fill and GC churn by pooling byte arrays.
+ */
+public final class OkBuffer implements Source, Sink {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+  private Segment segment;
+  private long byteCount;
+
+  public OkBuffer() {
+  }
+
+  /** Returns the number of bytes currently in this buffer. */
+  public long byteCount() {
+    return byteCount;
+  }
+
+  /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
+  public ByteString readByteString(int byteCount) {
+    return new ByteString(readBytes(byteCount));
+  }
+
+  /** Removes {@code byteCount} bytes from this, decodes them as UTF-8 and returns the string. */
+  public String readUtf8(int byteCount) {
+    return new String(readBytes(byteCount), Util.UTF_8);
+  }
+
+  private byte[] readBytes(int byteCount) {
+    if (byteCount > this.byteCount) {
+      throw new IllegalArgumentException(
+          String.format(""requested %s > available %s"", byteCount, this.byteCount));
+    }
+
+    int offset = 0;
+    byte[] result = new byte[byteCount];
+
+    while (offset < byteCount) {
+      int toCopy = Math.min(byteCount - offset, segment.limit - segment.pos);
+      System.arraycopy(segment.data, segment.pos, result, offset, toCopy);
+
+      offset += toCopy;
+      segment.pos += toCopy;
+
+      if (segment.pos == segment.limit) {
+        segment = segment.pop(); // Recycle this empty segment.
+      }
+    }
+
+    this.byteCount -= byteCount;
+    return result;
+  }
+
+  /** Appends {@code byteString} to this. */
+  public void write(ByteString byteString) {
+    write(byteString.data);
+  }
+
+  /** Encodes {@code string} as UTF-8 and appends the bytes to this. */
+  public void writeUtf8(String string) {
+    write(string.getBytes(Util.UTF_8));
+  }
+
+  private void write(byte[] data) {
+    int offset = 0;
+    while (offset < data.length) {
+      if (segment == null) {
+        segment = SegmentPool.INSTANCE.take(); // Acquire a first segment.
+        segment.next = segment.prev = segment;
+      }
+
+      Segment tail = segment.prev;
+      if (tail.limit == Segment.SIZE) {
+        tail = tail.push(); // Acquire a new empty segment.
+      }
+
+      int toCopy = Math.min(data.length - offset, Segment.SIZE - tail.limit);
+      System.arraycopy(data, offset, tail.data, tail.limit, toCopy);
+
+      offset += toCopy;
+      tail.limit += toCopy;
+    }
+
+    this.byteCount += data.length;
+  }
+
+  @Override public void write(OkBuffer source, long byteCount, Timeout timeout) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount, Timeout timeout) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public long indexOf(byte b, Timeout timeout) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public void flush(Timeout timeout) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public void close(Timeout timeout) {
+    throw new UnsupportedOperationException();
+  }
+
+  /**
+   * Returns the contents of this buffer in hex. For buffers larger than 1 MiB
+   * this method is undefined.
+   */
+  @Override public String toString() {
+    if (byteCount > 0x100000) return super.toString();
+    char[] result = new char[(int) (byteCount * 2)];
+    int offset = 0;
+    for (Segment s = segment; offset < byteCount; s = s.next) {
+      for (int i = s.pos; i < s.limit; i++) {
+        result[offset++] = HEX_DIGITS[(s.data[i] >> 4) & 0xf];
+        result[offset++] = HEX_DIGITS[s.data[i] & 0xf];
+      }
+      offset += s.limit - s.pos;
+    }
+    return new String(result);
+  }
+}
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+/**
+ * A segment of an OkBuffer.
+ *
+ * <p>Each segment in an OkBuffer is a circularly-linked list node referencing
+ * the following and preceding segments in the buffer.
+ *
+ * <p>Each segment in the pool is a singly-linked list node referencing the rest
+ * of segments in the pool.
+ */
+final class Segment {
+  /** The size of all segments in bytes. */
+  // TODO: Using fixed-size segments makes pooling easier. But it harms memory
+  //       efficiency and encourages copying. Try variable sized segments?
+  // TODO: Is 2 KiB a good default segment size?
+  static final int SIZE = 2048;
+
+  final byte[] data;
+  int pos;
+  int limit;
+
+  /** Next segment in a linked list. */
+  Segment next;
+
+  /** Previous segment in a linked list. */
+  Segment prev;
+
+  Segment() {
+    data = new byte[SIZE];
+  }
+
+  /**
+   * Removes this head of a circularly-linked list, recycles it, and returns the
+   * new head of the list. Returns null if the list is now empty.
+   */
+  public Segment pop() {
+    Segment result = next != this ? next : null;
+    prev.next = next;
+    next.prev = prev;
+    next = null;
+    prev = null;
+    SegmentPool.INSTANCE.recycle(this);
+    return result;
+  }
+
+  /**
+   * Acquires a segment and appends it to this tail of a circularly-linked list.
+   * Returns the new tail segment.
+   */
+  public Segment push() {
+    Segment result = SegmentPool.INSTANCE.take();
+    result.prev = this;
+    result.next = next;
+    next.prev = result;
+    next = result;
+    return result;
+  }
+}
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+/**
+ * A collection of unused segments, necessary to avoid GC churn and zero-fill.
+ * This pool is a thread-safe static singleton.
+ */
+final class SegmentPool {
+  static final SegmentPool INSTANCE = new SegmentPool();
+
+  /** The maximum number of bytes to pool. */
+  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?
+  static final long MAX_SIZE = 64 * 1024; // 64 KiB.
+
+  /** Singly-linked list of segments. */
+  private Segment next;
+
+  /** Total bytes in this pool. */
+  long byteCount;
+
+  private SegmentPool() {
+  }
+
+  Segment take() {
+    synchronized (this) {
+      if (next != null) {
+        Segment result = next;
+        next = result.next;
+        result.next = null;
+        byteCount -= Segment.SIZE;
+        return result;
+      }
+    }
+    return new Segment(); // Pool is empty. Don't zero-fill while holding a lock.
+  }
+
+  void recycle(Segment segment) {
+    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();
+    synchronized (this) {
+      if (byteCount + Segment.SIZE > MAX_SIZE) return; // Pool is full.
+      byteCount += Segment.SIZE;
+      segment.next = next;
+      segment.pos = segment.limit = 0;
+      next = segment;
+    }
+  }
+}
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+
+/**
+ * An alternative to OutputStream.
+ */
+public interface Sink {
+  /** Removes {@code byteCount} bytes from {@code source} and appends them to this. */
+  void write(OkBuffer source, long byteCount, Timeout timeout) throws IOException;
+
+  /** Pushes all buffered bytes to their final destination. */
+  void flush(Timeout timeout) throws IOException;
+
+  /**
+   * Pushes all buffered bytes to their final destination and releases the
+   * resources held by this sink. It is an error to write a closed sink. It is
+   * safe to close a sink more than once.
+   */
+  void close(Timeout timeout) throws IOException;
+}
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+
+/**
+ * An alternative to InputStream.
+ */
+public interface Source {
+  /**
+   * Removes {@code byteCount} bytes from this and appends them to {@code sink}.
+   * Returns the number of bytes actually written.
+   */
+  long read(OkBuffer sink, long byteCount, Timeout timeout) throws IOException;
+
+  /**
+   * Returns the index of {@code b} in this, or -1 if this source is exhausted
+   * first. This may cause this source to buffer a large number of bytes.
+   */
+  long indexOf(byte b, Timeout timeout) throws IOException;
+
+  /**
+   * Closes this source and releases the resources held by this source. It is an
+   * error to read a closed source. It is safe to close a source more than once.
+   */
+  void close(Timeout timeout) throws IOException;
+}
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * The deadline for a requested operation. If the timeout elapses before the
+ * operation has completed, the operation should be aborted.
+ */
+public class Timeout {
+  public static final Timeout NONE = new Timeout() {
+    @Override public Timeout start(long timeout, TimeUnit unit) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean reached() {
+      return false;
+    }
+  };
+
+  private long deadlineNanos;
+
+  public Timeout() {
+  }
+
+  public Timeout start(long timeout, TimeUnit unit) {
+    deadlineNanos = System.nanoTime() + unit.toNanos(timeout);
+    return this;
+  }
+
+  public boolean reached() {
+    return System.nanoTime() - deadlineNanos >= 0; // Subtract to avoid overflow!
+  }
+}
@@ -1,6 +1,6 @@
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
 public final class Header {
@@ -1,7 +1,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
@@ -1,6 +1,6 @@
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.DataInputStream;
@@ -16,9 +16,9 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class OkBufferTest {
+  @Test public void readAndWriteUtf8() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(""ab"");
+    assertEquals(2, buffer.byteCount());
+    buffer.writeUtf8(""cdef"");
+    assertEquals(6, buffer.byteCount());
+    assertEquals(""abcd"", buffer.readUtf8(4));
+    assertEquals(2, buffer.byteCount());
+    assertEquals(""ef"", buffer.readUtf8(2));
+    assertEquals(0, buffer.byteCount());
+    try {
+      buffer.readUtf8(1);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void bufferToString() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(""\u0000\u0001\u0002\u007f"");
+    assertEquals(""0001027f"", buffer.toString());
+  }
+
+  @Test public void multipleSegmentBuffers() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a',  1000));
+    buffer.writeUtf8(repeat('b',  2500));
+    buffer.writeUtf8(repeat('c',  5000));
+    buffer.writeUtf8(repeat('d', 10000));
+    buffer.writeUtf8(repeat('e', 25000));
+    buffer.writeUtf8(repeat('f', 50000));
+
+    assertEquals(repeat('a', 999), buffer.readUtf8(999)); // a...a
+    assertEquals(""a"" + repeat('b', 2500) + ""c"", buffer.readUtf8(2502)); // ab...bc
+    assertEquals(repeat('c', 4998), buffer.readUtf8(4998)); // c...c
+    assertEquals(""c"" + repeat('d', 10000) + ""e"", buffer.readUtf8(10002)); // cd...de
+    assertEquals(repeat('e', 24998), buffer.readUtf8(24998)); // e...e
+    assertEquals(""e"" + repeat('f', 50000), buffer.readUtf8(50001)); // ef...f
+    assertEquals(0, buffer.byteCount());
+  }
+
+  @Test public void fillAndDrainPool() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+
+    // Take 2 * MAX_SIZE segments. This will drain the pool, even if other tests filled it.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+
+    // Recycle MAX_SIZE segments. They're all in the pool.
+    buffer.readByteString((int) SegmentPool.MAX_SIZE);
+    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
+
+    // Recycle MAX_SIZE more segments. The pool is full so they get garbage collected.
+    buffer.readByteString((int) SegmentPool.MAX_SIZE);
+    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
+
+    // Take MAX_SIZE segments to drain the pool.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+
+    // Take MAX_SIZE more segments. The pool is drained so these will need to be allocated.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
@@ -16,7 +16,7 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpEngine;
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
@@ -24,7 +24,7 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.io.FileNotFoundException;
@@ -20,7 +20,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
"
https://github.com/junit-team/junit4/commit/d2b75f93d21d2584efab1129aacd1f3020c37fca,"Document limitationBuild with Maven 3.1.1 (using Maven Wrapper) <enter>
This makes the build independent from the Maven version that is
installed on the build machine. E.g. Travis has Maven 3.5.6 installed
that does not support Java 6 anymore.
Maven version 3.1.1 is used because all newer version don't support Java 1.5.",https://api.github.com/repos/junit-team/junit4/commits/d2b75f93d21d2584efab1129aacd1f3020c37fca,
https://github.com/spring-projects/spring-boot/commit/893654bdd1d71fdf42b21d8ca16c4c18faf6a3ea,Update documentation for new HealthIndicator support ,https://api.github.com/repos/spring-projects/spring-boot/commits/893654bdd1d71fdf42b21d8ca16c4c18faf6a3ea,"@@ -1,5 +1,5 @@
 = Spring Boot Reference Guide
-Phillip Webb; Dave Syer; Josh Long; Stéphane Nicoll; Rob Winch; Andy Wilkinson; Marcel Overdijk;
+Phillip Webb; Dave Syer; Josh Long; Stéphane Nicoll; Rob Winch; Andy Wilkinson; Marcel Overdijk; Christian Dupuis;
 :doctype: book
 :toc:
 :toclevels: 4
@@ -162,9 +162,13 @@ To provide custom health information you can register a Spring bean that impleme
 	}
 ----
 
-Spring Boot also provides a
-{sc-spring-boot-actuator}/health/SimpleHealthIndicator.{sc-ext}[`SimpleHealthIndicator`]
-implementation that attempts a simple database test.
+Spring Boot provides a
+{sc-spring-boot-actuator}/health/SimpleDatabaseHealthIndicator.{sc-ext}[`SimpleDatabaseHealthIndicator`]
+implementation that attempts a simple database test as well as implementations for 
+Redis and MongoDB. 
+
+Spring Boot adds the `HealthIndicator` instances automatically if beans of type `DataSource`,
+`MongoTemplate` or `RedisConnectionFactory` are present in the `ApplicationContext`.
 
 
 
"
https://github.com/junit-team/junit4/commit/8a367c1b918f02135d333f3cea8b576c20287361,"Revert 'ExternalResource: declare after() to throw Throwable ( <pr_link> )'  <enter> Revert commit  <otherCommit_link> . It breaks code that extends ExternalResource, overrides after() and calls super.after() in after(). ",https://api.github.com/repos/junit-team/junit4/commits/8a367c1b918f02135d333f3cea8b576c20287361,"@@ -77,10 +77,8 @@ protected void before() throws Throwable {
 
     /**
      * Override to tear down your specific external resource.
-     *
-     * @throws Throwable if teardown fails
      */
-    protected void after() throws Throwable {
+    protected void after() {
         // do nothing
     }
 }
"
https://github.com/junit-team/junit4/commit/a90b496a6595856066504baf4f737fb853a6e45d,"Ensure exceptions from methodBlock() don't result in unrooted tests.  <enter> The introduction of the runLeaf() method in BlockJUnit4ClassRunner in JUnit 4.9 introduced a regression with regard to exception handling. <enter> Specifically, the invocation of methodBlock() is no longer executed within a try-catch block as was the case in previous versions of JUnit. <enter> Custom modifications to methodBlock() or the methods it invokes may in fact throw exceptions. In such cases, exceptions thrown from methodBlock() cause the current test execution to abort immediately. As a result, the failing test method is unrooted in test reports, and subsequent test methods are never invoked. Furthermore, RunListeners registered with JUnit are not notified. <enter> This commit addresses this issue by wrapping the invocation of methodBlock() within a try-catch block. If an exception is not thrown, the resulting Statement is passed to runLeaf(). If an exception is thrown, it is wrapped in a Fail statement which is passed to runLeaf(). <enter>  Closes   <issue_link>   Closes   <pr_link> ",https://api.github.com/repos/junit-team/junit4/commits/a90b496a6595856066504baf4f737fb853a6e45d,"@@ -55,7 +55,9 @@
  * @since 4.5
  */
 public class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {
+
     private final ConcurrentHashMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>();
+
     /**
      * Creates a BlockJUnit4ClassRunner to run {@code testClass}
      *
@@ -75,10 +77,17 @@ protected void runChild(final FrameworkMethod method, RunNotifier notifier) {
         if (isIgnored(method)) {
             notifier.fireTestIgnored(description);
         } else {
-            runLeaf(methodBlock(method), description, notifier);
+            Statement statement;
+            try {
+                statement = methodBlock(method);
+            }
+            catch (Throwable ex) {
+                statement = new Fail(ex);
+            }
+            runLeaf(statement, description, notifier);
         }
     }
-    
+
     /**
      * Evaluates whether {@link FrameworkMethod}s are ignored based on the
      * {@link Ignore} annotation.
@@ -390,10 +399,10 @@ private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
     protected List<MethodRule> rules(Object target) {
         List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, 
                 Rule.class, MethodRule.class);
-        
+
         rules.addAll(getTestClass().getAnnotatedFieldValues(target,
                 Rule.class, MethodRule.class));
-        
+
         return rules;
     }
 
@@ -0,0 +1,90 @@
+package org.junit.runners;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.Test;
+import org.junit.runner.Description;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunListener;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.model.FrameworkMethod;
+import org.junit.runners.model.InitializationError;
+import org.junit.runners.model.Statement;
+
+/**
+ * Tests that verify proper behavior for custom runners that extend
+ * {@link BlockJUnit4ClassRunner}.
+ *
+ * @author Sam Brannen
+ * @since 4.13
+ */
+public class CustomBlockJUnit4ClassRunnerTest {
+
+	@Test
+	public void exceptionsFromMethodBlockMustNotResultInUnrootedTests() throws Exception {
+		TrackingRunListener listener = new TrackingRunListener();
+		RunNotifier notifier = new RunNotifier();
+		notifier.addListener(listener);
+
+		new CustomBlockJUnit4ClassRunner(CustomBlockJUnit4ClassRunnerTestCase.class).run(notifier);
+		assertEquals(""tests started."", 2, listener.testStartedCount.get());
+		assertEquals(""tests failed."", 1, listener.testFailureCount.get());
+		assertEquals(""tests finished."", 2, listener.testFinishedCount.get());
+	}
+
+
+	public static class CustomBlockJUnit4ClassRunnerTestCase {
+		@Test public void shouldPass() { /* no-op */ }
+		@Test public void throwException() { /* no-op */ }
+	}
+
+	/**
+	 * Custom extension of {@link BlockJUnit4ClassRunner} that always throws
+	 * an exception from the {@code methodBlock()} if a test method is named
+	 * exactly {@code ""throwException""}.
+	 */
+	private static class CustomBlockJUnit4ClassRunner extends BlockJUnit4ClassRunner {
+
+		CustomBlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError {
+			super(testClass);
+		}
+
+		@Override
+		protected Statement methodBlock(FrameworkMethod method) {
+			if (""throwException"".equals(method.getName())) {
+				throw new RuntimeException(""throwException() test method invoked"");
+			}
+			return super.methodBlock(method);
+		}
+	}
+
+	/**
+	 * Simple {@link RunListener} that tracks the number of times that
+	 * certain callbacks are invoked.
+	 */
+	private static class TrackingRunListener extends RunListener {
+
+		final AtomicInteger testStartedCount = new AtomicInteger();
+		final AtomicInteger testFailureCount = new AtomicInteger();
+		final AtomicInteger testFinishedCount = new AtomicInteger();
+
+
+		@Override
+		public void testStarted(Description description) throws Exception {
+			testStartedCount.incrementAndGet();
+		}
+
+		@Override
+		public void testFailure(Failure failure) throws Exception {
+			testFailureCount.incrementAndGet();
+		}
+
+		@Override
+		public void testFinished(Description description) throws Exception {
+			testFinishedCount.incrementAndGet();
+		}
+	}
+
+}
@@ -18,6 +18,7 @@
 import org.junit.runner.notification.ConcurrentRunNotifierTest;
 import org.junit.runner.notification.RunNotifierTest;
 import org.junit.runner.notification.SynchronizedRunListenerTest;
+import org.junit.runners.CustomBlockJUnit4ClassRunnerTest;
 import org.junit.runners.Suite;
 import org.junit.runners.Suite.SuiteClasses;
 import org.junit.runners.model.FrameworkFieldTest;
@@ -203,6 +204,7 @@
         RuleMemberValidatorTest.class,
         RuleChainTest.class,
         BlockJUnit4ClassRunnerTest.class,
+        CustomBlockJUnit4ClassRunnerTest.class,
         MethodSorterTest.class,
         TestedOnSupplierTest.class,
         StacktracePrintingMatcherTest.class,
"
https://github.com/junit-team/junit4/commit/0d6cd750d53486f01f12ddfee8657d94b5940574,Remove old todo ,https://api.github.com/repos/junit-team/junit4/commits/0d6cd750d53486f01f12ddfee8657d94b5940574,"@@ -23,8 +23,6 @@ public boolean matchesSafely(PrintableResult item) {
 		};
 	}
 	
-	// TODO: (Dec 7, 2007 10:15:15 AM) fix type
-
 	@SuppressWarnings(""unchecked"")
 	public static Matcher<Object> hasSingleFailureContaining(final String string) {
 		return new BaseMatcher<Object>() {
"
https://github.com/square/okhttp/commit/0d069f3b7bc524320fc76051408384f8ece77412,Prefer ByteString.encodeString.  <enter> This saves cloning the byte array because the byte array can't be modified by the caller. ,https://api.github.com/repos/square/okhttp/commits/0d069f3b7bc524320fc76051408384f8ece77412,"@@ -30,8 +30,7 @@ public static String basic(String userName, String password) {
 
   public static String basic(String userName, String password, Charset charset) {
     String usernameAndPassword = userName + "":"" + password;
-    byte[] bytes = usernameAndPassword.getBytes(charset);
-    String encoded = ByteString.of(bytes).base64();
+    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
     return ""Basic "" + encoded;
   }
 }
"
https://github.com/spring-projects/spring-boot/commit/85c0b44dcbbe4d201f8b7fd72a97c31c2d07a3ec,"Test that LaunchedURLClassLoader works when thread is interrupted  <enter> Previously, RandomAccessDataFile used a semaphore and acquired it interruptibly. This meant that an interrupted thread was unable to access the file. Notably, this would prevent LaunchedURLClassLoader from loading classes or resources on an interrupted thread. <enter> The previous commit ( <otherCommit_link> ) updates RandomAccessDataFile to acquire the semaphore uninterruptibly. This commit adds a test to LaunchedURLClassLoader to verify that it can now load a resource from an interrupted thread. <enter>  Closes   <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/85c0b44dcbbe4d201f8b7fd72a97c31c2d07a3ec,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2014 the original author or authors.
+ * Copyright 2012-2016 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -36,6 +36,7 @@
  *
  * @author Dave Syer
  * @author Phillip Webb
+ * @author Andy Wilkinson
  */
 @SuppressWarnings(""resource"")
 public class LaunchedURLClassLoaderTests {
@@ -101,4 +102,23 @@ public void resolveFromNested() throws Exception {
 		assertThat(resource.openConnection().getInputStream().read(), equalTo(3));
 	}
 
+	@Test
+	public void resolveFromNestedWhileThreadIsInterrupted() throws Exception {
+		File file = this.temporaryFolder.newFile();
+		TestJarCreator.createTestJar(file);
+		JarFile jarFile = new JarFile(file);
+		URL url = jarFile.getUrl();
+		LaunchedURLClassLoader loader = new LaunchedURLClassLoader(new URL[] { url },
+				null);
+		try {
+			Thread.currentThread().interrupt();
+			URL resource = loader.getResource(""nested.jar!/3.dat"");
+			assertThat(resource.toString(), equalTo(url + ""nested.jar!/3.dat""));
+			assertThat(resource.openConnection().getInputStream().read(), equalTo(3));
+		}
+		finally {
+			Thread.interrupted();
+		}
+	}
+
 }
"
https://github.com/spring-projects/spring-boot/commit/f9d94c6ed080c45bc96a76e134d9db5bb038f900,Remove duplicate word in docs ,https://api.github.com/repos/spring-projects/spring-boot/commits/f9d94c6ed080c45bc96a76e134d9db5bb038f900,"@@ -808,7 +808,7 @@ If you need to _completely_ disable restart support (for example, because it doe
 If you work with an IDE that continuously compiles changed files, you might prefer to trigger restarts only at specific times.
 To do so, you can use a ""`trigger file`"", which is a special file that must be modified when you want to actually trigger a restart check.
 
-NOTE: Any update to the file file will trigger a check, but restart only actually occurs if Devtools has detected it has something to do.
+NOTE: Any update to the file will trigger a check, but restart only actually occurs if Devtools has detected it has something to do.
 
 To use a trigger file, set the `spring.devtools.restart.trigger-file` property to the name (excluding any path) of your trigger file.
 The trigger file must appear somewhere on your classpath.
"
https://github.com/spring-projects/spring-boot/commit/2a85a2557d37e133a10a513fc71b5ccf4ee2d4ff,"Fix health indicator auto-configuration order  <enter> Previously, the health auto-configuration `AutoconfigureOrder` entry for couchbase was referring to the standard couchbase auto-configuration that is not responsible to configure the `CouchbaseOperations` bean. Yet, the health indicator implementation was relying on the presence of such a bean. <enter> This commit fixes the `AutoconfigureOrder` entry so that it refers to `CouchbaseDataAutoConfiguration` now. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/2a85a2557d37e133a10a513fc71b5ccf4ee2d4ff,"@@ -52,8 +52,8 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration;
+import org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;
@@ -91,7 +91,7 @@
 @Configuration
 @AutoConfigureBefore({ EndpointAutoConfiguration.class })
 @AutoConfigureAfter({ CassandraAutoConfiguration.class,
-		CassandraDataAutoConfiguration.class, CouchbaseAutoConfiguration.class,
+		CassandraDataAutoConfiguration.class, CouchbaseDataAutoConfiguration.class,
 		DataSourceAutoConfiguration.class, ElasticsearchAutoConfiguration.class,
 		JestAutoConfiguration.class, JmsAutoConfiguration.class,
 		MailSenderAutoConfiguration.class, MongoAutoConfiguration.class,
"
https://github.com/spring-projects/spring-boot/commit/fe3d2c39a0f4cf016c8ceb27dbeab5508c85e65f,Fix broken links in the documentation ,https://api.github.com/repos/spring-projects/spring-boot/commits/fe3d2c39a0f4cf016c8ceb27dbeab5508c85e65f,"@@ -38,7 +38,7 @@ Having trouble with Spring Boot, We'd like to help!
 * Report bugs with Spring Boot at https://github.com/spring-projects/spring-boot/issues.
 
 NOTE: All of Spring Boot is open source, including the documentation! If you find problems
-with the docs; or if you just want to improve them, please <<github-code, get involved>>.
+with the docs; or if you just want to improve them, please {github-code}[get involved].
 
 [[boot-documentation-first-steps]]
 == First steps
@@ -157,8 +157,9 @@ installed you can follow the instructions at http://www.gradle.org/.
 Spring Boot dependencies can be declared using the `org.springframework.boot` `group`.
 Typically your project will declare dependencies to one or more
 <<using-spring-boot.adoc#using-boot-starter-poms, ``Starter POMs''>>. Spring Boot
-provides a useful <<build-tool-plugins.adoc#build-tool-plugins-gradle, Gradle plugin>>
-that can be used to simplify dependency declarations and to create executable jars.
+provides a useful <<build-tool-plugins.adoc#build-tool-plugins-gradle-plugin, Gradle
+plugin>> that can be used to simplify dependency declarations and to create executable
+jars.
 
 .Gradle Wrapper
 ****
@@ -721,8 +722,8 @@ Hopefully this section has provided you with some of the Spring Boot basics, and
 on your way to writing your own applications. If you're a task-oriented type of
 developer you might want to jump over to http://spring.io and check out some of the
 http://spring.io/guides/[getting started] guides that solve specific
-'``How do I do that with Spring''' problems; we also have a Spring Boot specific
-'<<howto.adoc#how-to, How-to>>' reference documentation.
+'``How do I do that with Spring''' problems; we also have Spring Boot-specific
+'<<howto.adoc#howto, How-to>>' reference documentation.
 
 Otherwise, the next logical step is to read '<<using-spring-boot.adoc#using-boot>>'. If
 you're really impatient, you could also jump ahead and read about
"
https://github.com/spring-projects/spring-boot/commit/715cf7da7564daaa8c349d34bd826b27ad71b183,"Do not enable cglib if spring.aop.proxy-target-class is configured  <enter> This commit makes sure to honour the `spring.aop.proxy-target-class` property if set by the user. Previously, the `PersistenceExceptionTranslationPostProcessor` was always configured to use cglib, regardless of the value of that property. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/715cf7da7564daaa8c349d34bd826b27ad71b183,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2014 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -20,14 +20,17 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.bind.RelaxedPropertyResolver;
 import org.springframework.context.annotation.Bean;
+import org.springframework.core.env.Environment;
 import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
 
 /**
  * {@link EnableAutoConfiguration Auto-configuration} for Spring's persistence exception
  * translation.
  *
  * @author Andy Wilkinson
+ * @author Stephane Nicoll
  * @since 1.2.0
  */
 @ConditionalOnClass(PersistenceExceptionTranslationPostProcessor.class)
@@ -36,10 +39,18 @@ public class PersistenceExceptionTranslationAutoConfiguration {
 	@Bean
 	@ConditionalOnMissingBean(PersistenceExceptionTranslationPostProcessor.class)
 	@ConditionalOnProperty(prefix = ""spring.dao.exceptiontranslation"", name = ""enabled"", matchIfMissing = true)
-	public static PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor() {
+	public static PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor(
+			Environment environment) {
 		PersistenceExceptionTranslationPostProcessor postProcessor = new PersistenceExceptionTranslationPostProcessor();
-		postProcessor.setProxyTargetClass(true);
+		postProcessor.setProxyTargetClass(determineProxyTargetClass(environment));
 		return postProcessor;
 	}
 
+	private static boolean determineProxyTargetClass(Environment environment) {
+		RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,
+				""spring.aop."");
+		Boolean value = resolver.getProperty(""proxyTargetClass"", Boolean.class);
+		return (value != null ? value : true);
+	}
+
 }
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -37,10 +37,10 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 /**
- *
  * Tests for {@link PersistenceExceptionTranslationAutoConfiguration}
  *
  * @author Andy Wilkinson
+ * @author Stephane Nicoll
  */
 public class PersistenceExceptionTranslationAutoConfigurationTests {
 
@@ -54,7 +54,7 @@ public void close() {
 	}
 
 	@Test
-	public void exceptionTranslationPostProcessorBeanIsCreated() {
+	public void exceptionTranslationPostProcessorUsesCglibByDefault() {
 		this.context = new AnnotationConfigApplicationContext(
 				PersistenceExceptionTranslationAutoConfiguration.class);
 		Map<String, PersistenceExceptionTranslationPostProcessor> beans = this.context
@@ -64,7 +64,20 @@ public void exceptionTranslationPostProcessorBeanIsCreated() {
 	}
 
 	@Test
-	public void exceptionTranslationPostProcessorBeanIsDisabled() {
+	public void exceptionTranslationPostProcessorCanBeConfiguredToUseJdkProxy() {
+		this.context = new AnnotationConfigApplicationContext();
+		EnvironmentTestUtils.addEnvironment(this.context,
+				""spring.aop.proxyTargetClass=false"");
+		this.context.register(PersistenceExceptionTranslationAutoConfiguration.class);
+		this.context.refresh();
+		Map<String, PersistenceExceptionTranslationPostProcessor> beans = this.context
+				.getBeansOfType(PersistenceExceptionTranslationPostProcessor.class);
+		assertThat(beans).hasSize(1);
+		assertThat(beans.values().iterator().next().isProxyTargetClass()).isFalse();
+	}
+
+	@Test
+	public void exceptionTranslationPostProcessorCanBeDisabled() {
 		this.context = new AnnotationConfigApplicationContext();
 		EnvironmentTestUtils.addEnvironment(this.context,
 				""spring.dao.exceptiontranslation.enabled=false"");
"
https://github.com/spring-projects/spring-boot/commit/e69ec6bb09e93aa5d240cfdb826e93cebb91278e,"Log classpath once environment has been prepared  <enter> Previously, the classpath would be logged in response to the ApplicationStartedEvent. At this point, logging could be disabled while the logging system is being initialized, or because the log levels configured in the environment have not yet been applied. <enter> This commit moves the logging to happen in response to an ApplicationEnvironmentPreparedEvent by which point the logging system has been initialized and its levels have been configured. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/e69ec6bb09e93aa5d240cfdb826e93cebb91278e,"@@ -22,17 +22,18 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
+import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
 import org.springframework.boot.context.event.ApplicationFailedEvent;
-import org.springframework.boot.context.event.ApplicationStartedEvent;
 import org.springframework.context.ApplicationEvent;
 import org.springframework.context.event.GenericApplicationListener;
 import org.springframework.context.event.SmartApplicationListener;
 import org.springframework.core.ResolvableType;
 
 /**
- * A {@link SmartApplicationListener} that reacts to {@link ApplicationStartedEvent start
- * events} and to {@link ApplicationFailedEvent failed events} by logging the classpath of
- * the thread context class loader (TCCL) at {@code DEBUG} level.
+ * A {@link SmartApplicationListener} that reacts to
+ * {@link ApplicationEnvironmentPreparedEvent environment prepared events} and to
+ * {@link ApplicationFailedEvent failed events} by logging the classpath of the thread
+ * context class loader (TCCL) at {@code DEBUG} level.
  *
  * @author Andy Wilkinson
  */
@@ -46,7 +47,7 @@ public final class ClasspathLoggingApplicationListener
 	@Override
 	public void onApplicationEvent(ApplicationEvent event) {
 		if (this.logger.isDebugEnabled()) {
-			if (event instanceof ApplicationStartedEvent) {
+			if (event instanceof ApplicationEnvironmentPreparedEvent) {
 				this.logger
 						.debug(""Application started with classpath: "" + getClasspath());
 			}
@@ -68,7 +69,7 @@ public boolean supportsEventType(ResolvableType resolvableType) {
 		if (type == null) {
 			return false;
 		}
-		return ApplicationStartedEvent.class.isAssignableFrom(type)
+		return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(type)
 				|| ApplicationFailedEvent.class.isAssignableFrom(type);
 	}
 
"
https://github.com/square/retrofit/commit/948a0db7ef1d46c66237ed2feb9f6f08ee159c68,"Allow service interfaces to extend other interfaces  <enter> With a higher minSdkVersion, the bug which prevented this on Android no longer exists. ",https://api.github.com/repos/square/retrofit/commits/948a0db7ef1d46c66237ed2feb9f6f08ee159c68,"@@ -22,7 +22,10 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.net.URL;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -128,10 +131,7 @@ public final class Retrofit {
    */
   @SuppressWarnings(""unchecked"") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
-    }
+    validateServiceInterface(service);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
@@ -151,11 +151,33 @@ public <T> T create(final Class<T> service) {
         });
   }
 
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
-        loadServiceMethod(method);
+  private void validateServiceInterface(Class<?> service) {
+    if (!service.isInterface()) {
+      throw new IllegalArgumentException(""API declarations must be interfaces."");
+    }
+
+    Deque<Class<?>> check = new ArrayDeque<>(1);
+    check.add(service);
+    while (!check.isEmpty()) {
+      Class<?> candidate = check.removeFirst();
+      if (candidate.getTypeParameters().length != 0) {
+        StringBuilder message = new StringBuilder(""Type parameters are unsupported on "")
+            .append(candidate.getName());
+        if (candidate != service) {
+          message.append("" which is an interface of "")
+              .append(service.getName());
+        }
+        throw new IllegalArgumentException(message.toString());
+      }
+      Collections.addAll(check, candidate.getInterfaces());
+    }
+
+    if (validateEagerly) {
+      Platform platform = Platform.get();
+      for (Method method : service.getDeclaredMethods()) {
+        if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
+          loadServiceMethod(method);
+        }
       }
     }
   }
@@ -317,18 +317,6 @@ static ResponseBody buffer(final ResponseBody body) throws IOException {
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
-  static <T> void validateServiceInterface(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException(""API declarations must be interfaces."");
-    }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException(""API interfaces must not extend other interfaces."");
-    }
-  }
-
   static Type getParameterUpperBound(int index, ParameterizedType type) {
     Type[] types = type.getActualTypeArguments();
     if (index < 0 || index >= types.length) {
@@ -85,6 +85,10 @@ interface FutureMethod {
   }
   interface Extending extends CallMethod {
   }
+  interface TypeParam<T> {
+  }
+  interface ExtendingTypeParam extends TypeParam<String> {
+  }
   interface StringService {
     @GET(""/"") String get();
   }
@@ -129,15 +133,47 @@ interface MutableParameters {
     assertThat(example.toString()).isNotEmpty();
   }
 
-  @Test public void interfaceWithExtendIsNotSupported() {
+  @Test public void interfaceWithTypeParameterThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url(""/""))
+        .build();
+
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    try {
+      retrofit.create(TypeParam.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""Type parameters are unsupported on retrofit2.RetrofitTest$TypeParam"");
+    }
+  }
+
+  @Test public void interfaceWithExtend() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url(""/""))
         .build();
+
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    Extending extending = retrofit.create(Extending.class);
+    String result = extending.getResponseBody().execute().body().string();
+    assertEquals(""Hi"", result);
+  }
+
+  @Test public void interfaceWithExtendWithTypeParameterThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url(""/""))
+        .build();
+
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
     try {
-      retrofit.create(Extending.class);
+      retrofit.create(ExtendingTypeParam.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""API interfaces must not extend other interfaces."");
+      assertThat(e).hasMessage(
+          ""Type parameters are unsupported on retrofit2.RetrofitTest$TypeParam ""
+              + ""which is an interface of retrofit2.RetrofitTest$ExtendingTypeParam"");
     }
   }
 
"
https://github.com/spring-projects/spring-boot/commit/da4f8514b293ef1c99deb0024e8147d4e553aa49,Add byte-buddy managed dependency  <enter> Add a managed dependency for byte-buddy since Mockito needs 1.6 and Hibernate pulls in 1.5. <enter> See  <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/da4f8514b293ef1c99deb0024e8147d4e553aa49,"@@ -1,4 +1,6 @@
-<?xml version=""1.0"" encoding=""UTF-8""?><project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
 	<groupId>org.springframework.boot</groupId>
 	<artifactId>spring-boot-dependencies</artifactId>
@@ -51,6 +53,7 @@
 		<assertj.version>2.6.0</assertj.version>
 		<atomikos.version>3.9.3</atomikos.version>
 		<bitronix.version>2.1.4</bitronix.version>
+		<byte-buddy.version>1.6.0</byte-buddy.version>
 		<caffeine.version>2.3.5</caffeine.version>
 		<cassandra-driver.version>3.1.3</cassandra-driver.version>
 		<classmate.version>1.3.3</classmate.version>
@@ -953,6 +956,11 @@
 				<artifactId>mysql-connector-java</artifactId>
 				<version>${mysql.version}</version>
 			</dependency>
+			<dependency>
+				<groupId>net.bytebuddy</groupId>
+				<artifactId>byte-buddy</artifactId>
+				<version>${byte-buddy.version}</version>
+			</dependency>
 			<dependency>
 				<groupId>net.java.dev.jna</groupId>
 				<artifactId>jna</artifactId>
@@ -2561,4 +2569,4 @@
 			<id>integration-test</id>
 		</profile>
 	</profiles>
-</project>
\ No newline at end of file
+</project>
"
https://github.com/square/okhttp/commit/09f424f12e48e2640915bf61c86a9ecd928e459e,fix README.md typo ( <pr_link> ) ,https://api.github.com/repos/square/okhttp/commits/09f424f12e48e2640915bf61c86a9ecd928e459e,"@@ -114,7 +114,7 @@ Also, we have a [bill of materials (BOM)][bom] available to help you keep OkHttp
        // define a BOM and its version
        implementation(platform(""com.squareup.okhttp3:okhttp-bom:4.9.0""))
        
-       // define any required OkHttp artifacts without verion
+       // define any required OkHttp artifacts without version
        implementation(""com.squareup.okhttp3:okhttp"")
        implementation(""com.squareup.okhttp3:logging-interceptor"")
     }
"
https://github.com/square/retrofit/commit/0fff59140b5791ad0f1b1c7bf7826db2e00a73f1,Pull out ServiceMethod base class  <enter> This will allow us to support multiple forms of invocation beyond HTTP calls. ,https://api.github.com/repos/square/retrofit/commits/0fff59140b5791ad0f1b1c7bf7826db2e00a73f1,"@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+
+/** Adapts an invocation of an interface method into an HTTP call. */
+final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
+  private final RequestFactory requestFactory;
+  private final okhttp3.Call.Factory callFactory;
+  private final CallAdapter<ResponseT, ReturnT> callAdapter;
+  private final Converter<ResponseBody, ResponseT> responseConverter;
+
+  HttpServiceMethod(Builder<ResponseT, ReturnT> builder) {
+    requestFactory = builder.requestFactory;
+    callFactory = builder.retrofit.callFactory();
+    callAdapter = builder.callAdapter;
+    responseConverter = builder.responseConverter;
+  }
+
+  @Override ReturnT invoke(@Nullable Object[] args) {
+    return callAdapter.adapt(
+        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
+  }
+
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method. This
+   * requires potentially-expensive reflection so it is best to build each service method only once
+   * and reuse it. Builders cannot be reused.
+   */
+  static final class Builder<ResponseT, ReturnT> {
+    final Retrofit retrofit;
+    final Method method;
+
+    RequestFactory requestFactory;
+    Type responseType;
+    Converter<ResponseBody, ResponseT> responseConverter;
+    CallAdapter<ResponseT, ReturnT> callAdapter;
+
+    Builder(Retrofit retrofit, Method method) {
+      this.retrofit = retrofit;
+      this.method = method;
+    }
+
+    HttpServiceMethod<ResponseT, ReturnT> build() {
+      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
+      callAdapter = createCallAdapter();
+      responseType = callAdapter.responseType();
+      if (responseType == Response.class || responseType == okhttp3.Response.class) {
+        throw methodError(""'""
+            + Utils.getRawType(responseType).getName()
+            + ""' is not a valid response body type. Did you mean ResponseBody?"");
+      }
+      responseConverter = createResponseConverter();
+
+      if (requestFactory.httpMethod.equals(""HEAD"") && !Void.class.equals(responseType)) {
+        throw methodError(""HEAD method must use Void as response type."");
+      }
+
+      return new HttpServiceMethod<>(this);
+    }
+
+    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
+      Type returnType = method.getGenericReturnType();
+      if (Utils.hasUnresolvableType(returnType)) {
+        throw methodError(
+            ""Method return type must not include a type variable or wildcard: %s"", returnType);
+      }
+      if (returnType == void.class) {
+        throw methodError(""Service methods cannot return void."");
+      }
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        //noinspection unchecked
+        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, ""Unable to create call adapter for %s"", returnType);
+      }
+    }
+
+    private Converter<ResponseBody, ResponseT> createResponseConverter() {
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        return retrofit.responseBodyConverter(responseType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, ""Unable to create converter for %s"", responseType);
+      }
+    }
+
+    private RuntimeException methodError(String message, Object... args) {
+      return methodError(null, message, args);
+    }
+
+    private RuntimeException methodError(Throwable cause, String message, Object... args) {
+      message = String.format(message, args);
+      return new IllegalArgumentException(message
+          + ""\n    for method ""
+          + method.getDeclaringClass().getSimpleName()
+          + "".""
+          + method.getName(), cause);
+    }
+  }
+}
@@ -58,7 +58,7 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
+  private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
 
   final okhttp3.Call.Factory callFactory;
   final HttpUrl baseUrl;
@@ -157,8 +157,8 @@ private void eagerlyValidateMethods(Class<?> service) {
     }
   }
 
-  ServiceMethod<?, ?> loadServiceMethod(Method method) {
-    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+  ServiceMethod<?> loadServiceMethod(Method method) {
+    ServiceMethod<?> result = serviceMethodCache.get(method);
     if (result != null) return result;
 
     synchronized (serviceMethodCache) {
@@ -15,112 +15,13 @@
  */
 package retrofit2;
 
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
-import java.lang.reflect.Type;
 import javax.annotation.Nullable;
-import okhttp3.ResponseBody;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
-final class ServiceMethod<ResponseT, ReturnT> {
-  static <ResponseT, ReturnT> ServiceMethod<ResponseT, ReturnT> parseAnnotations(Retrofit retrofit,
-      Method method) {
-    return new ServiceMethod.Builder<ResponseT, ReturnT>(retrofit, method).build();
+abstract class ServiceMethod<T> {
+  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    return new HttpServiceMethod.Builder<Object, T>(retrofit, method).build();
   }
 
-  private final RequestFactory requestFactory;
-  private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<ResponseT, ReturnT> callAdapter;
-  private final Converter<ResponseBody, ResponseT> responseConverter;
-
-  ServiceMethod(Builder<ResponseT, ReturnT> builder) {
-    requestFactory = builder.requestFactory;
-    callFactory = builder.retrofit.callFactory();
-    callAdapter = builder.callAdapter;
-    responseConverter = builder.responseConverter;
-  }
-
-  ReturnT invoke(@Nullable Object[] args) {
-    return callAdapter.adapt(
-        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  private static final class Builder<ResponseT, ReturnT> {
-    final Retrofit retrofit;
-    final Method method;
-
-    RequestFactory requestFactory;
-    Type responseType;
-    Converter<ResponseBody, ResponseT> responseConverter;
-    CallAdapter<ResponseT, ReturnT> callAdapter;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-    }
-
-    ServiceMethod<ResponseT, ReturnT> build() {
-      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
-
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError(""'""
-            + Utils.getRawType(responseType).getName()
-            + ""' is not a valid response body type. Did you mean ResponseBody?"");
-      }
-      responseConverter = createResponseConverter();
-
-      if (requestFactory.httpMethod.equals(""HEAD"") && !Void.class.equals(responseType)) {
-        throw methodError(""HEAD method must use Void as response type."");
-      }
-
-      return new ServiceMethod<>(this);
-    }
-
-    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(
-            ""Method return type must not include a type variable or wildcard: %s"", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError(""Service methods cannot return void."");
-      }
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, ""Unable to create call adapter for %s"", returnType);
-      }
-    }
-
-    private Converter<ResponseBody, ResponseT> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, ""Unable to create converter for %s"", responseType);
-      }
-    }
-
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
-    }
-
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + ""\n    for method ""
-          + method.getDeclaringClass().getSimpleName()
-          + "".""
-          + method.getName(), cause);
-    }
-  }
+  abstract T invoke(@Nullable Object[] args);
 }
"
https://github.com/spring-projects/spring-boot/commit/8561929164846ef4b3323a8b3f88a09ea1441785,"Improve Spring Session sample  <enter> This commit improves the Spring Session sample by providing multiple build profiles that make it possible to easily try out different session stores. By default, JDBC session store backed by an in-memory embedded H2 database is used. <enter> See  <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/8561929164846ef4b3323a8b3f88a09ea1441785,
https://github.com/spring-projects/spring-boot/commit/fa6ee8e34d5f76ee57dd9f9c84bb047c5ee3d356,Clarify h2-console requires a servlet-based web app  <enter> Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/fa6ee8e34d5f76ee57dd9f9c84bb047c5ee3d356,"@@ -3610,7 +3610,7 @@ http://www.h2database.com/html/quickstart.html#h2_console[browser-based console]
 Spring Boot can auto-configure for you. The console is auto-configured when the following
 conditions are met:
 
-* You are developing a web application.
+* You are developing a servlet-based web application.
 * `com.h2database:h2` is on the classpath.
 * You are using <<using-spring-boot.adoc#using-boot-devtools,Spring Boot's developer
 tools>>.
"
https://github.com/spring-projects/spring-boot/commit/46fbca66a69d102db55f7c454565f82ff5be6b98,Fix typo 'a' -> 'an',https://api.github.com/repos/spring-projects/spring-boot/commits/46fbca66a69d102db55f7c454565f82ff5be6b98,"@@ -158,7 +158,7 @@ Health information can be used to check the status of your running application.
 often used by monitoring software to alert someone if a production system goes down.
 The default information exposed by the `health` endpoint depends on how it is accessed.
 For an unauthenticated connection in a secure application a simple '`status`' message is 
-returned, and for a authenticated connection additional details are also displayed (see
+returned, and for an authenticated connection additional details are also displayed (see
 <<production-ready-health-access-restrictions>> for HTTP details).
 
 Health information is collected from all
"
https://github.com/junit-team/junit4/commit/cb0c4e9f7c9be8be7c11e4934f6bd71a312102ec,"For <issue_link> , remove FrameworkMethod.getParameterSignatures()  <enter> Having this method in place made a class from the 'core' of JUnit (org.junit.runners.model) depend on something from 'experimental' -- a dependency going in the wrong direction. ",https://api.github.com/repos/junit-team/junit4/commits/cb0c4e9f7c9be8be7c11e4934f6bd71a312102ec,"@@ -78,7 +78,7 @@ protected void validateTestMethods(List<Throwable> errors) {
                 each.validatePublicVoidNoArg(false, errors);
             }
             
-            for (ParameterSignature signature : each.getParameterSignatures()) {
+            for (ParameterSignature signature : ParameterSignature.signatures(each.getMethod())) {
                 ParametersSuppliedBy annotation = signature.findDeepAnnotation(ParametersSuppliedBy.class);
                 if (annotation != null) {
                     validateParameterSupplier(annotation.value(), errors);
@@ -7,7 +7,6 @@
 import java.lang.reflect.Type;
 import java.util.List;
 
-import org.junit.experimental.theories.ParameterSignature;
 import org.junit.internal.runners.model.ReflectiveCallable;
 
 /**
@@ -198,10 +197,6 @@ public <T extends Annotation> T getAnnotation(Class<T> annotationType) {
         return fMethod.getAnnotation(annotationType);
     }
 
-    public List<ParameterSignature> getParameterSignatures() {
-        return ParameterSignature.signatures(fMethod);
-    }
-
     @Override
     public String toString() {
         return fMethod.toString();
"
https://github.com/apache/dubbo/commit/80776517e923a7bb77a307b74d3b5fdfa1c2b22d,"temporarily change spring-context-support dependency back to SNAPSHOT, the formal release turns to be broken.",https://api.github.com/repos/apache/dubbo/commits/80776517e923a7bb77a307b74d3b5fdfa1c2b22d,"@@ -542,6 +542,10 @@
             <groupId>org.springframework</groupId>
             <artifactId>spring-context</artifactId>
         </dependency>
+        <dependency>
+            <groupId>com.alibaba.spring</groupId>
+            <artifactId>spring-context-support</artifactId>
+        </dependency>
         <dependency>
             <groupId>org.javassist</groupId>
             <artifactId>javassist</artifactId>
@@ -145,7 +145,7 @@
         <eureka.version>1.9.12</eureka.version>
 
         <!-- Alibaba -->
-        <alibaba_spring_context_support_version>1.0.4</alibaba_spring_context_support_version>
+        <alibaba_spring_context_support_version>1.0.4-SNAPSHOT</alibaba_spring_context_support_version>
 
         <jaxb_version>2.2.7</jaxb_version>
         <activation_version>1.2.0</activation_version>
"
https://github.com/apache/dubbo/commit/ff76661ef4ad2af0b92c208dc0740bb00e93020b,change version to 2.7.6-SNAPSHOT to prepare for next major release ,https://api.github.com/repos/apache/dubbo/commits/ff76661ef4ad2af0b92c208dc0740bb00e93020b,"@@ -162,7 +162,7 @@
         <mortbay_jetty_version>6.1.26</mortbay_jetty_version>
         <portlet_version>2.0</portlet_version>
         <maven_flatten_version>1.1.0</maven_flatten_version>
-        <revision>2.7.5-SNAPSHOT</revision>
+        <revision>2.7.6-SNAPSHOT</revision>
     </properties>
 
     <dependencyManagement>
@@ -32,7 +32,7 @@
     <packaging>pom</packaging>
 
     <properties>
-        <revision>2.7.5-SNAPSHOT</revision>
+        <revision>2.7.6-SNAPSHOT</revision>
         <maven_flatten_version>1.1.0</maven_flatten_version>
     </properties>
 
@@ -125,7 +125,7 @@
         <arguments />
         <checkstyle.skip>true</checkstyle.skip>
         <rat.skip>true</rat.skip>
-        <revision>2.7.5-SNAPSHOT</revision>
+        <revision>2.7.6-SNAPSHOT</revision>
     </properties>
 
     <modules>
"
https://github.com/square/okhttp/commit/9b4e74f8c8ce6fff4281c2d7369fb25f6772a64e,"A Pipe.  <enter> This is something we need to implement HttpURLConnection atop the native OkHttp API. The application thread wants to be active, writing to its OutputStream. But in OkHttp's API, this work wants to happen in the RequestBody.writeTo() callback. To make this work we give the HttpUrlConnection OutputStream the sink end of the pipe, and the RequestBody the source end of the pipe. It's a bit of plumbing, but the benefit is that backpressure, timeouts, and failures will propagate as expected. ",https://api.github.com/repos/square/okhttp/commits/9b4e74f8c8ce6fff4281c2d7369fb25f6772a64e,"@@ -0,0 +1,403 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.Random;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.ByteString;
+import okio.HashingSink;
+import okio.Source;
+import org.junit.After;
+import org.junit.Test;
+
+import static junit.framework.TestCase.fail;
+import static org.junit.Assert.assertEquals;
+
+public final class PipeTest {
+  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);
+
+  @After public void tearDown() throws Exception {
+    executorService.shutdown();
+  }
+
+  @Test public void test() throws Exception {
+    Pipe pipe = new Pipe(6);
+    pipe.sink.write(new Buffer().writeUtf8(""abc""), 3L);
+
+    Source source = pipe.source;
+    Buffer readBuffer = new Buffer();
+    assertEquals(3L, source.read(readBuffer, 6L));
+    assertEquals(""abc"", readBuffer.readUtf8());
+
+    pipe.sink.close();
+    assertEquals(-1L, source.read(readBuffer, 6L));
+
+    source.close();
+  }
+
+  /**
+   * A producer writes the first 16 MiB of bytes generated by {@code new Random(0)} to a sink, and a
+   * consumer consumes them. Both compute hashes of their data to confirm that they're as expected.
+   */
+  @Test public void largeDataset() throws Exception {
+    final Pipe pipe = new Pipe(1000L); // An awkward size to force producer/consumer exchange.
+    final long totalBytes = 16L * 1024L * 1024L;
+    ByteString expectedHash = ByteString.decodeHex(""7c3b224bea749086babe079360cf29f98d88262d"");
+
+    // Write data to the sink.
+    Future<ByteString> sinkHash = executorService.submit(new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        HashingSink hashingSink = HashingSink.sha1(pipe.sink);
+        Random random = new Random(0);
+        byte[] data = new byte[8192];
+
+        Buffer buffer = new Buffer();
+        for (long i = 0L; i < totalBytes; i += data.length) {
+          random.nextBytes(data);
+          buffer.write(data);
+          hashingSink.write(buffer, buffer.size());
+        }
+
+        hashingSink.close();
+        return hashingSink.hash();
+      }
+    });
+
+    // Read data from the source.
+    Future<ByteString> sourceHash = executorService.submit(new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        Buffer blackhole = new Buffer();
+        HashingSink hashingSink = HashingSink.sha1(blackhole);
+
+        Buffer buffer = new Buffer();
+        while (pipe.source.read(buffer, Long.MAX_VALUE) != -1) {
+          hashingSink.write(buffer, buffer.size());
+          blackhole.clear();
+        }
+
+        pipe.source.close();
+        return hashingSink.hash();
+      }
+    });
+
+    assertEquals(expectedHash, sinkHash.get());
+    assertEquals(expectedHash, sourceHash.get());
+  }
+
+  @Test public void sinkTimeout() throws Exception {
+    Pipe pipe = new Pipe(3);
+    pipe.sink.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    pipe.sink.write(new Buffer().writeUtf8(""abc""), 3L);
+    double start = now();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8(""def""), 3L);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+
+    Buffer readBuffer = new Buffer();
+    assertEquals(3L, pipe.source.read(readBuffer, 6L));
+    assertEquals(""abc"", readBuffer.readUtf8());
+  }
+
+  @Test public void sourceTimeout() throws Exception {
+    Pipe pipe = new Pipe(3L);
+    pipe.source.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    double start = now();
+    Buffer readBuffer = new Buffer();
+    try {
+      pipe.source.read(readBuffer, 6L);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+    assertEquals(0, readBuffer.size());
+  }
+
+  /**
+   * The writer is writing 12 bytes as fast as it can to a 3 byte buffer. The reader alternates
+   * sleeping 250 ms, then reading 3 bytes. That should make for an approximate timeline like this:
+   *
+   * 0: writer writes 'abc', blocks 0: reader sleeps until 250 250: reader reads 'abc', sleeps until
+   * 500 250: writer writes 'def', blocks 500: reader reads 'def', sleeps until 750 500: writer
+   * writes 'ghi', blocks 750: reader reads 'ghi', sleeps until 1000 750: writer writes 'jkl',
+   * returns 1000: reader reads 'jkl', returns
+   *
+   * Because the writer is writing to a buffer, it finishes before the reader does.
+   */
+  @Test public void sinkBlocksOnSlowReader() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Buffer buffer = new Buffer();
+          Thread.sleep(250L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals(""abc"", buffer.readUtf8());
+          Thread.sleep(250L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals(""def"", buffer.readUtf8());
+          Thread.sleep(250L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals(""ghi"", buffer.readUtf8());
+          Thread.sleep(250L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals(""jkl"", buffer.readUtf8());
+        } catch (IOException | InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8(""abcdefghijkl""), 12);
+    assertElapsed(750.0, start);
+  }
+
+  @Test public void sinkWriteFailsByClosedReader() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        try {
+          pipe.source.close();
+        } catch (IOException e) {
+          throw new AssertionError();
+        }
+      }
+    }, 250, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8(""abcdef""), 6);
+      fail();
+    } catch (IOException expected) {
+      assertEquals(""source is closed"", expected.getMessage());
+      assertElapsed(250.0, start);
+    }
+  }
+
+  @Test public void sinkFlushWaitsForReaderToReadEverything() throws Exception {
+    final Buffer readBuffer = new Buffer();
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(250);
+          pipe.source.read(readBuffer, 3);
+          Thread.sleep(250);
+          pipe.source.read(readBuffer, 3);
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8(""abcdef""), 6);
+    pipe.sink.flush();
+    assertElapsed(500.0, start);
+    assertEquals(""abcdef"", readBuffer.readUtf8());
+  }
+
+  @Test public void sinkFlushFailsIfReaderIsClosedBeforeAllDataIsRead() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(250);
+          pipe.source.read(new Buffer(), 3);
+          Thread.sleep(250);
+          pipe.source.close();
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8(""abcdef""), 6);
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals(""source is closed"", expected.getMessage());
+      assertElapsed(500.0, start);
+    }
+  }
+
+  @Test public void sinkCloseFailsIfReaderIsClosedBeforeAllDataIsRead() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(250);
+          pipe.source.read(new Buffer(), 3);
+          Thread.sleep(250);
+          pipe.source.close();
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8(""abcdef""), 6);
+    try {
+      pipe.sink.close();
+      fail();
+    } catch (IOException expected) {
+      assertEquals(""source is closed"", expected.getMessage());
+      assertElapsed(500.0, start);
+    }
+
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals(""closed"", expected.getMessage());
+    }
+  }
+
+  @Test public void sinkClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.sink.close();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8(""abc""), 3);
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals(""closed"", expected.getMessage());
+    }
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals(""closed"", expected.getMessage());
+    }
+  }
+
+  @Test public void sinkMultipleClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.sink.close();
+    pipe.sink.close();
+  }
+
+  @Test public void sourceClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.source.close();
+    try {
+      pipe.source.read(new Buffer(), 3);
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals(""closed"", expected.getMessage());
+    }
+  }
+
+  @Test public void sourceMultipleClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.source.close();
+    pipe.source.close();
+  }
+
+  @Test public void sourceReadUnblockedByClosedSink() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        try {
+          pipe.sink.close();
+        } catch (IOException e) {
+          throw new AssertionError();
+        }
+      }
+    }, 250, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    Buffer readBuffer = new Buffer();
+    assertEquals(-1, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(0, readBuffer.size());
+    assertElapsed(250.0, start);
+  }
+
+  /**
+   * The writer has 12 bytes to write. It alternates sleeping 250 ms, then writing 3 bytes. The
+   * reader is reading as fast as it can. That should make for an approximate timeline like this:
+   *
+   * 0: writer sleeps until 250 0: reader blocks 250: writer writes 'abc', sleeps until 500 250:
+   * reader reads 'abc' 500: writer writes 'def', sleeps until 750 500: reader reads 'def' 750:
+   * writer writes 'ghi', sleeps until 1000 750: reader reads 'ghi' 1000: writer writes 'jkl',
+   * returns 1000: reader reads 'jkl', returns
+   */
+  @Test public void sourceBlocksOnSlowWriter() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(250L);
+          pipe.sink.write(new Buffer().writeUtf8(""abc""), 3);
+          Thread.sleep(250L);
+          pipe.sink.write(new Buffer().writeUtf8(""def""), 3);
+          Thread.sleep(250L);
+          pipe.sink.write(new Buffer().writeUtf8(""ghi""), 3);
+          Thread.sleep(250L);
+          pipe.sink.write(new Buffer().writeUtf8(""jkl""), 3);
+        } catch (IOException | InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    double start = now();
+    Buffer readBuffer = new Buffer();
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(""abc"", readBuffer.readUtf8());
+    assertElapsed(250.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(""def"", readBuffer.readUtf8());
+    assertElapsed(500.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(""ghi"", readBuffer.readUtf8());
+    assertElapsed(750.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(""jkl"", readBuffer.readUtf8());
+    assertElapsed(1000.0, start);
+  }
+
+  /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
+  private double now() {
+    return System.nanoTime() / 1000000.0d;
+  }
+
+  /**
+   * Fails the test unless the time from start until now is duration, accepting differences in
+   * -50..+150 milliseconds.
+   */
+  private void assertElapsed(double duration, double start) {
+    assertEquals(duration, now() - start + 50d, 100.0);
+  }
+}
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.InterruptedIOException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import okio.Timeout;
+import org.junit.After;
+import org.junit.Test;
+
+import static junit.framework.TestCase.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public final class WaitUntilNotifiedTest {
+  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(0);
+
+  @After public void tearDown() throws Exception {
+    executorService.shutdown();
+  }
+
+  @Test public synchronized void notified() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(5000, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        synchronized (WaitUntilNotifiedTest.this) {
+          WaitUntilNotifiedTest.this.notify();
+        }
+      }
+    }, 250, TimeUnit.MILLISECONDS);
+
+    Pipe.waitUntilNotified(this, timeout);
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void timeout() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(250, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void deadline() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.deadline(250, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void deadlineBeforeTimeout() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(5000, TimeUnit.MILLISECONDS);
+    timeout.deadline(250, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void timeoutBeforeDeadline() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(250, TimeUnit.MILLISECONDS);
+    timeout.deadline(5000, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void deadlineAlreadyReached() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.deadlineNanoTime(System.nanoTime());
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(0.0, start);
+  }
+
+  @Test public synchronized void threadInterrupted() throws Exception {
+    Timeout timeout = new Timeout();
+    double start = now();
+    Thread.currentThread().interrupt();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""interrupted"", expected.getMessage());
+      assertFalse(Thread.interrupted());
+    }
+    assertElapsed(0.0, start);
+  }
+
+  /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
+  private double now() {
+    return System.nanoTime() / 1000000.0d;
+  }
+
+  /**
+   * Fails the test unless the time from start until now is duration, accepting differences in
+   * -50..+150 milliseconds.
+   */
+  private void assertElapsed(double duration, double start) {
+    assertEquals(duration, now() - start + 50d, 100.0);
+  }
+}
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import okio.Buffer;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+/**
+ * A source and a sink that are attached. The sink's output is the source's input. Typically each
+ * is accessed by its own thread: a producer thread writes data to the sink and a consumer thread
+ * reads data from the source.
+ *
+ * <p>This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum
+ * size. When a producer thread outruns its consumer the buffer fills up and eventually writes to
+ * the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its
+ * producer reads block until there is data to be read. Limits on the amount of time spent waiting
+ * for the other party can be configured with {@linkplain Timeout timeouts} on the source and the
+ * sink.
+ *
+ * <p>When the sink is closed, source reads will continue to complete normally until the buffer has
+ * been exhausted. At that point reads will return -1, indicating the end of the stream. But if the
+ * source is closed first, writes to the sink will immediately fail with an {@link IOException}.
+ */
+public final class Pipe {
+  final long maxBufferSize;
+  final Buffer buffer = new Buffer();
+  boolean sinkClosed;
+  boolean sourceClosed;
+  public final Sink sink = new PipeSink();
+  public final Source source = new PipeSource();
+
+  public Pipe(long maxBufferSize) {
+    if (maxBufferSize < 1L) {
+      throw new IllegalArgumentException(""maxBufferSize < 1: "" + maxBufferSize);
+    }
+    this.maxBufferSize = maxBufferSize;
+  }
+
+  final class PipeSink implements Sink {
+    final Timeout timeout = new Timeout();
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) throw new IllegalStateException(""closed"");
+
+        while (byteCount > 0) {
+          if (sourceClosed) throw new IOException(""source is closed"");
+
+          long bufferSpaceAvailable = maxBufferSize - buffer.size();
+          if (bufferSpaceAvailable == 0) {
+            waitUntilNotified(buffer, timeout); // Wait until the source drains the buffer.
+            continue;
+          }
+
+          long bytesToWrite = Math.min(bufferSpaceAvailable, byteCount);
+          buffer.write(source, bytesToWrite);
+          byteCount -= bytesToWrite;
+          buffer.notifyAll(); // Notify the source that it can resume reading.
+        }
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) throw new IllegalStateException(""closed"");
+
+        while (buffer.size() > 0) {
+          if (sourceClosed) throw new IOException(""source is closed"");
+          waitUntilNotified(buffer, timeout);
+        }
+      }
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) return;
+        try {
+          flush();
+        } finally {
+          sinkClosed = true;
+          buffer.notifyAll(); // Notify the source that no more bytes are coming.
+        }
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+  }
+
+  final class PipeSource implements Source {
+    final Timeout timeout = new Timeout();
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      synchronized (buffer) {
+        if (sourceClosed) throw new IllegalStateException(""closed"");
+
+        while (buffer.size() == 0) {
+          if (sinkClosed) return -1L;
+          waitUntilNotified(buffer, timeout); // Wait until the sink fills the buffer.
+        }
+
+        long result = buffer.read(sink, byteCount);
+        buffer.notifyAll(); // Notify the sink that it can resume writing.
+        return result;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (buffer) {
+        sourceClosed = true;
+        buffer.notifyAll(); // Notify the sink that no more bytes are desired.
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+  }
+
+  /**
+   * Waits on {@code monitor} until it is notified. Throws {@link InterruptedIOException} if either
+   * the thread is interrupted or if {@code timeout} elapses before {@code monitor} is notified. The
+   * caller must be synchronized on {@code monitor}.
+   */
+  static void waitUntilNotified(Object monitor, Timeout timeout) throws IOException {
+    try {
+      boolean hasDeadline = timeout.hasDeadline();
+      long timeoutNanos = timeout.timeoutNanos();
+
+      if (!hasDeadline && timeoutNanos == 0L) {
+        monitor.wait(); // There is no timeout: wait forever.
+        return;
+      }
+
+      // Compute how long we'll wait.
+      long waitNanos;
+      long start = System.nanoTime();
+      if (hasDeadline && timeoutNanos != 0) {
+        long deadlineNanos = timeout.deadlineNanoTime() - start;
+        waitNanos = Math.min(timeoutNanos, deadlineNanos);
+      } else if (hasDeadline) {
+        waitNanos = timeout.deadlineNanoTime() - start;
+      } else {
+        waitNanos = timeoutNanos;
+      }
+
+      // Attempt to wait that long. This will break out early if the monitor is notified.
+      long elapsedNanos = 0L;
+      if (waitNanos > 0L) {
+        long waitMillis = waitNanos / 1000000L;
+        monitor.wait(waitMillis, (int) (waitNanos - waitMillis * 1000000L));
+        elapsedNanos = System.nanoTime() - start;
+      }
+
+      // Throw if the timeout elapsed before the monitor was notified.
+      if (elapsedNanos >= waitNanos) {
+        throw new InterruptedIOException(""timeout"");
+      }
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException(""interrupted"");
+    }
+  }
+}
+
"
https://github.com/apache/dubbo/commit/b4afeb982b943ca8c6bbd261302a9e161c2e98a9,"follow up for pr#4339, remove the space ( <pr_link> ) ",https://api.github.com/repos/apache/dubbo/commits/b4afeb982b943ca8c6bbd261302a9e161c2e98a9,"@@ -31,56 +31,56 @@
  * Code generator for Adaptive class
  */
 public class AdaptiveClassCodeGenerator {
-    
+
     private static final Logger logger = LoggerFactory.getLogger(AdaptiveClassCodeGenerator.class);
 
     private static final String CLASSNAME_INVOCATION = ""org.apache.dubbo.rpc.Invocation"";
-    
+
     private static final String CODE_PACKAGE = ""package %s;\n"";
-    
+
     private static final String CODE_IMPORTS = ""import %s;\n"";
-    
+
     private static final String CODE_CLASS_DECLARATION = ""public class %s$Adaptive implements %s {\n"";
-    
+
     private static final String CODE_METHOD_DECLARATION = ""public %s %s(%s) %s {\n%s}\n"";
-    
+
     private static final String CODE_METHOD_ARGUMENT = ""%s arg%d"";
-    
+
     private static final String CODE_METHOD_THROWS = ""throws %s"";
-    
+
     private static final String CODE_UNSUPPORTED = ""throw new UnsupportedOperationException(\""The method %s of interface %s is not adaptive method!\"");\n"";
-    
+
     private static final String CODE_URL_NULL_CHECK = ""if (arg%d == null) throw new IllegalArgumentException(\""url == null\"");\n%s url = arg%d;\n"";
-    
+
     private static final String CODE_EXT_NAME_ASSIGNMENT = ""String extName = %s;\n"";
-    
+
     private static final String CODE_EXT_NAME_NULL_CHECK = ""if(extName == null) ""
                     + ""throw new IllegalStateException(\""Failed to get extension (%s) name from url (\"" + url.toString() + \"") use keys(%s)\"");\n"";
-    
+
     private static final String CODE_INVOCATION_ARGUMENT_NULL_CHECK = ""if (arg%d == null) throw new IllegalArgumentException(\""invocation == null\""); ""
                     + ""String methodName = arg%d.getMethodName();\n"";
-    
-    
+
+
     private static final String CODE_EXTENSION_ASSIGNMENT = ""%s extension = (%<s)%s.getExtensionLoader(%s.class).getExtension(extName);\n"";
 
-    private static final String CODE_EXTENSION_METHOD_INVOKE_ARGUMENT = ""arg%d "";
+    private static final String CODE_EXTENSION_METHOD_INVOKE_ARGUMENT = ""arg%d"";
 
     private final Class<?> type;
-    
+
     private String defaultExtName;
-    
+
     public AdaptiveClassCodeGenerator(Class<?> type, String defaultExtName) {
         this.type = type;
         this.defaultExtName = defaultExtName;
     }
-    
+
     /**
      * test if given type has at least one method annotated with <code>SPI</code>
      */
     private boolean hasAdaptiveMethod() {
         return Arrays.stream(type.getMethods()).anyMatch(m -> m.isAnnotationPresent(Adaptive.class));
     }
-    
+
     /**
      * generate and return class code
      */
@@ -94,13 +94,13 @@ public String generate() {
         code.append(generatePackageInfo());
         code.append(generateImports());
         code.append(generateClassDeclaration());
-        
+
         Method[] methods = type.getMethods();
         for (Method method : methods) {
             code.append(generateMethod(method));
         }
         code.append(""}"");
-        
+
         if (logger.isDebugEnabled()) {
             logger.debug(code.toString());
         }
@@ -127,18 +127,18 @@ private String generateImports() {
     private String generateClassDeclaration() {
         return String.format(CODE_CLASS_DECLARATION, type.getSimpleName(), type.getCanonicalName());
     }
-    
+
     /**
-     * generate method not annotated with Adaptive with throwing unsupported exception 
+     * generate method not annotated with Adaptive with throwing unsupported exception
      */
     private String generateUnsupported(Method method) {
         return String.format(CODE_UNSUPPORTED, method, type.getName());
     }
-    
+
     /**
      * get index of parameter with type URL
      */
-    private int getUrlTypeIndex(Method method) {            
+    private int getUrlTypeIndex(Method method) {
         int urlTypeIndex = -1;
         Class<?>[] pts = method.getParameterTypes();
         for (int i = 0; i < pts.length; ++i) {
@@ -149,7 +149,7 @@ private int getUrlTypeIndex(Method method) {
         }
         return urlTypeIndex;
     }
-    
+
     /**
      * generate method declaration
      */
@@ -171,9 +171,9 @@ private String generateMethodArguments(Method method) {
                         .mapToObj(i -> String.format(CODE_METHOD_ARGUMENT, pts[i].getCanonicalName(), i))
                         .collect(Collectors.joining("", ""));
     }
-    
+
     /**
-     * generate method throws 
+     * generate method throws
      */
     private String generateMethodThrows(Method method) {
         Class<?>[] ets = method.getExceptionTypes();
@@ -184,14 +184,14 @@ private String generateMethodThrows(Method method) {
             return """";
         }
     }
-    
+
     /**
-     * generate method URL argument null check 
+     * generate method URL argument null check
      */
     private String generateUrlNullCheck(int index) {
         return String.format(CODE_URL_NULL_CHECK, index, URL.class.getName(), index);
     }
-    
+
     /**
      * generate method content
      */
@@ -202,7 +202,7 @@ private String generateMethodContent(Method method) {
             return generateUnsupported(method);
         } else {
             int urlTypeIndex = getUrlTypeIndex(method);
-            
+
             // found parameter in URL type
             if (urlTypeIndex != -1) {
                 // Null Point check
@@ -215,19 +215,19 @@ private String generateMethodContent(Method method) {
             String[] value = getMethodAdaptiveValue(adaptiveAnnotation);
 
             boolean hasInvocation = hasInvocationArgument(method);
-            
+
             code.append(generateInvocationArgumentNullCheck(method));
-            
+
             code.append(generateExtNameAssignment(value, hasInvocation));
             // check extName == null?
             code.append(generateExtNameNullCheck(value));
-            
+
             code.append(generateExtensionAssignment());
 
             // return statement
             code.append(generateReturnAndInvocation(method));
         }
-        
+
         return code.toString();
     }
 
@@ -279,7 +279,7 @@ private String generateExtNameAssignment(String[] value, boolean hasInvocation)
                 }
             }
         }
-        
+
         return String.format(CODE_EXT_NAME_ASSIGNMENT, getNameCode);
     }
 
@@ -302,15 +302,15 @@ private String generateReturnAndInvocation(Method method) {
 
         return returnStatement + String.format(""extension.%s(%s);\n"", method.getName(), args);
     }
-    
+
     /**
      * test if method has argument of type <code>Invocation</code>
      */
     private boolean hasInvocationArgument(Method method) {
         Class<?>[] pts = method.getParameterTypes();
         return Arrays.stream(pts).anyMatch(p -> CLASSNAME_INVOCATION.equals(p.getName()));
     }
-    
+
     /**
      * generate code to test argument of type <code>Invocation</code> is null
      */
@@ -343,7 +343,7 @@ private String[] getMethodAdaptiveValue(Adaptive adaptiveAnnotation) {
      */
     private String generateUrlAssignmentIndirectly(Method method) {
         Class<?>[] pts = method.getParameterTypes();
-        
+
         // find URL getter method
         for (int i = 0; i < pts.length; ++i) {
             for (Method m : pts[i].getMethods()) {
@@ -357,7 +357,7 @@ private String generateUrlAssignmentIndirectly(Method method) {
                 }
             }
         }
-        
+
         // getter method not found, throw
         throw new IllegalStateException(""Failed to create adaptive class for interface "" + type.getName()
                         + "": not found url parameter or url attribute in parameters of method "" + method.getName());
@@ -380,5 +380,5 @@ private String generateGetUrlNullCheck(int index, Class<?> type, String method)
         code.append(String.format(""%s url = arg%d.%s();\n"", URL.class.getName(), index, method));
         return code.toString();
     }
-    
+
 }
"
https://github.com/square/okhttp/commit/dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3,"Move connection pooling logic.  <enter> Previously we had this ugly, awkward release() method that attempted to manage connection pooling, discarding streams for caching, and closing broken streams. <enter> Move connection reuse to HttpConnection, with policy informed by HttpEngine. It specifies what to do when the connection becomes idle: pool, close or hold. The connection does what it's told. ",https://api.github.com/repos/square/okhttp/commits/dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3,"@@ -65,7 +65,7 @@
  * should the attempt fail.
  */
 public final class Connection implements Closeable {
-
+  private final ConnectionPool pool;
   private final Route route;
 
   private Socket socket;
@@ -78,7 +78,8 @@ public final class Connection implements Closeable {
   private long idleStartTimeNs;
   private Handshake handshake;
 
-  public Connection(Route route) {
+  public Connection(ConnectionPool pool, Route route) {
+    this.pool = pool;
     this.route = route;
   }
 
@@ -96,7 +97,7 @@ public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelReq
       upgradeToTls(tunnelRequest);
     } else {
       streamWrapper();
-      httpConnection = new HttpConnection(in, out);
+      httpConnection = new HttpConnection(pool, this, in, out);
     }
     connected = true;
   }
@@ -164,7 +165,7 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
           .protocol(selectedProtocol).build();
       spdyConnection.sendConnectionHeader();
     } else {
-      httpConnection = new HttpConnection(in, out);
+      httpConnection = new HttpConnection(pool, this, in, out);
     }
   }
 
@@ -306,7 +307,7 @@ public void updateReadTimeout(int newTimeout) throws IOException {
    * retried if the proxy requires authorization.
    */
   private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(in, out);
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, in, out);
     Request request = tunnelRequest.getRequest();
     String requestLine = tunnelRequest.requestLine();
     while (true) {
@@ -244,12 +244,9 @@ public void recycle(Connection connection) {
    * Shares the SPDY connection with the pool. Callers to this method may
    * continue to use {@code connection}.
    */
-  public void maybeShare(Connection connection) {
+  public void share(Connection connection) {
+    if (!connection.isSpdy()) throw new IllegalArgumentException();
     executorService.execute(connectionsCleanupRunnable);
-    if (!connection.isSpdy()) {
-      // Only SPDY connections are sharable.
-      return;
-    }
     if (connection.isAlive()) {
       synchronized (this) {
         connections.addFirst(connection);
@@ -80,7 +80,7 @@ Object tag() {
           .exception(e)
           .build());
     } finally {
-      engine.release(true); // Release the connection if it isn't already released.
+      engine.close(); // Close the connection if it isn't already.
       dispatcher.finished(this);
     }
   }
@@ -142,19 +142,18 @@ private Response getResponse() throws IOException {
       Request redirect = processResponse(engine, response);
 
       if (redirect == null) {
-        engine.automaticallyReleaseConnectionToPool();
+        engine.releaseConnection();
         return response.newBuilder()
             .body(new RealResponseBody(response, engine.getResponseBody()))
             .redirectedBy(redirectedBy)
             .build();
       }
 
       if (!sameConnection(request, redirect)) {
-        engine.automaticallyReleaseConnectionToPool();
+        engine.releaseConnection();
       }
 
-      engine.release(false);
-      Connection connection = engine.getConnection();
+      Connection connection = engine.close();
       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
       request = redirect;
       engine = new HttpEngine(client, request, false, connection, null, null);
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Response;
@@ -61,16 +62,59 @@ public final class HttpConnection {
   private static final int STATE_READING_RESPONSE_BODY = 5;
   private static final int STATE_CLOSED = 6;
 
+  private static final int ON_IDLE_HOLD = 0;
+  private static final int ON_IDLE_POOL = 1;
+  private static final int ON_IDLE_CLOSE = 2;
+
+  private final ConnectionPool pool;
+  private final Connection connection;
   private final InputStream in;
   private final OutputStream out;
 
   private int state = STATE_IDLE;
+  private int onIdle = ON_IDLE_HOLD;
 
-  public HttpConnection(InputStream in, OutputStream out) {
+  public HttpConnection(ConnectionPool pool, Connection connection, InputStream in,
+      OutputStream out) {
+    this.pool = pool;
+    this.connection = connection;
     this.in = in;
     this.out = out;
   }
 
+  /**
+   * Configure this connection to put itself back into the connection pool when
+   * the HTTP response body is exhausted.
+   */
+  public void poolOnIdle() {
+    onIdle = ON_IDLE_POOL;
+
+    // If we're already idle, go to the pool immediately.
+    if (state == STATE_IDLE) {
+      onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+      pool.recycle(connection);
+    }
+  }
+
+  /**
+   * Configure this connection to close itself when the HTTP response body is
+   * exhausted.
+   */
+  public void closeOnIdle() throws IOException {
+    onIdle = ON_IDLE_CLOSE;
+
+    // If we're already idle, close immediately.
+    if (state == STATE_IDLE) {
+      state = STATE_CLOSED;
+      connection.close();
+    }
+  }
+
+  /** Returns true if this connection is closed. */
+  public boolean isClosed() {
+    return state == STATE_CLOSED;
+  }
+
   public void flush() throws IOException {
     out.flush();
   }
@@ -126,11 +170,8 @@ public Response.Builder readResponse() throws IOException {
    * cannot be cached unless it is consumed completely) or to enable connection
    * reuse.
    */
-  private static boolean discardStream(HttpEngine httpEngine, InputStream responseBodyIn) {
-    Connection connection = httpEngine.getConnection();
-    if (connection == null) return false;
+  public boolean discard(InputStream responseBodyIn) {
     Socket socket = connection.getSocket();
-    if (socket == null) return false;
     try {
       int socketTimeout = socket.getSoTimeout();
       socket.setSoTimeout(Transport.DISCARD_STREAM_TIMEOUT_MILLIS);
@@ -163,38 +204,33 @@ public void writeRequestBody(RetryableOutputStream requestBody) throws IOExcepti
     requestBody.writeToSocket(out);
   }
 
-  public InputStream newFixedLengthInputStream(
-      CacheRequest cacheRequest, HttpEngine httpEngine, long length) throws IOException {
+  public InputStream newFixedLengthInputStream(CacheRequest cacheRequest, long length)
+      throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthInputStream(in, cacheRequest, httpEngine, length);
+    return new FixedLengthInputStream(cacheRequest, length);
   }
 
   /**
    * Call this to advance past a response body for HTTP responses that do not
    * have a response body.
    */
-  public void emptyResponseBody() {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
-    state = STATE_IDLE;
+  public void emptyResponseBody() throws IOException {
+    newFixedLengthInputStream(null, 0L); // Transition to STATE_IDLE.
   }
 
   public InputStream newChunkedInputStream(
       CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedInputStream(in, cacheRequest, httpEngine);
+    return new ChunkedInputStream(cacheRequest, httpEngine);
   }
 
   public InputStream newUnknownLengthInputStream(CacheRequest cacheRequest, HttpEngine httpEngine)
       throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new UnknownLengthHttpInputStream(in, cacheRequest, httpEngine);
-  }
-
-  public boolean discard(HttpEngine httpEngine, InputStream responseBodyIn) {
-    return discardStream(httpEngine, responseBodyIn);
+    return new UnknownLengthHttpInputStream(cacheRequest);
   }
 
   /** An HTTP body with a fixed length known in advance. */
@@ -347,17 +383,11 @@ private void writeBufferedChunkToSocket() throws IOException {
   }
 
   private class AbstractHttpInputStream extends InputStream {
-    protected final InputStream in;
-    protected final HttpEngine httpEngine;
     private final CacheRequest cacheRequest;
     protected final OutputStream cacheBody;
     protected boolean closed;
 
-    AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest)
-        throws IOException {
-      this.in = in;
-      this.httpEngine = httpEngine;
-
+    AbstractHttpInputStream(CacheRequest cacheRequest) throws IOException {
       OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
 
       // Some apps return a null body; for compatibility we treat that like a null cache request.
@@ -378,9 +408,7 @@ private class AbstractHttpInputStream extends InputStream {
     }
 
     protected final void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException(""stream closed"");
-      }
+      if (closed) throw new IOException(""stream closed"");
     }
 
     protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOException {
@@ -395,11 +423,19 @@ protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOE
      */
     protected final void endOfInput() throws IOException {
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
+
       if (cacheRequest != null) {
         cacheBody.close();
       }
-      httpEngine.release(false);
+
       state = STATE_IDLE;
+      if (onIdle == ON_IDLE_POOL) {
+        onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+        pool.recycle(connection);
+      } else if (onIdle == ON_IDLE_CLOSE) {
+        state = STATE_CLOSED;
+        connection.close();
+      }
     }
 
     /**
@@ -418,7 +454,7 @@ protected final void unexpectedEndOfInput() {
       if (cacheRequest != null) {
         cacheRequest.abort();
       }
-      httpEngine.release(true);
+      Util.closeQuietly(connection);
       state = STATE_CLOSED;
     }
   }
@@ -427,9 +463,8 @@ protected final void unexpectedEndOfInput() {
   private class FixedLengthInputStream extends AbstractHttpInputStream {
     private long bytesRemaining;
 
-    public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine,
-        long length) throws IOException {
-      super(is, httpEngine, cacheRequest);
+    public FixedLengthInputStream(CacheRequest cacheRequest, long length) throws IOException {
+      super(cacheRequest);
       bytesRemaining = length;
       if (bytesRemaining == 0) {
         endOfInput();
@@ -464,7 +499,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
       if (closed) {
         return;
       }
-      if (bytesRemaining != 0 && !discardStream(httpEngine, this)) {
+      if (bytesRemaining != 0 && !discard(this)) {
         unexpectedEndOfInput();
       }
       closed = true;
@@ -476,10 +511,11 @@ private class ChunkedInputStream extends AbstractHttpInputStream {
     private static final int NO_CHUNK_YET = -1;
     private int bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
+    private final HttpEngine httpEngine;
 
-    ChunkedInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine)
-        throws IOException {
-      super(is, httpEngine, cacheRequest);
+    ChunkedInputStream(CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
+      super(cacheRequest);
+      this.httpEngine = httpEngine;
     }
 
     @Override public int read(byte[] buffer, int offset, int count) throws IOException {
@@ -541,7 +577,7 @@ private void readChunkSize() throws IOException {
       if (closed) {
         return;
       }
-      if (hasMoreChunks && !discardStream(httpEngine, this)) {
+      if (hasMoreChunks && !discard(this)) {
         unexpectedEndOfInput();
       }
       closed = true;
@@ -552,9 +588,8 @@ private void readChunkSize() throws IOException {
   class UnknownLengthHttpInputStream extends AbstractHttpInputStream {
     private boolean inputExhausted;
 
-    UnknownLengthHttpInputStream(InputStream in, CacheRequest cacheRequest, HttpEngine httpEngine)
-        throws IOException {
-      super(in, httpEngine, cacheRequest);
+    UnknownLengthHttpInputStream(CacheRequest cacheRequest) throws IOException {
+      super(cacheRequest);
     }
 
     @Override public int read(byte[] buffer, int offset, int count) throws IOException {
@@ -68,11 +68,6 @@
  *
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
- *
- * <p>This class may hold a socket connection that needs to be released or
- * recycled. By default, this socket connection is held when the last byte of
- * the response is consumed. To release the connection when it is no longer
- * required, use {@link #automaticallyReleaseConnectionToPool()}.
  */
 public class HttpEngine {
   final OkHttpClient client;
@@ -121,15 +116,6 @@ public class HttpEngine {
   /** The cache request currently being populated from a network response. */
   private CacheRequest cacheRequest;
 
-  /**
-   * True if the socket connection should be released to the connection pool
-   * when the response has been fully read.
-   */
-  private boolean automaticallyReleaseConnectionToPool;
-
-  /** True if the socket connection is no longer needed by this engine. */
-  private boolean connectionReleased;
-
   /**
    * @param request the HTTP request without a body. The body must be
    *     written via the engine's request body stream.
@@ -199,9 +185,10 @@ public final void sendRequest() throws IOException {
       }
 
     } else {
-      // We're using a cached response. Close the connection we may have inherited from a redirect.
+      // We're using a cached response. Recycle a connection we may have inherited from a redirect.
       if (connection != null) {
-        disconnect();
+        client.getConnectionPool().recycle(connection);
+        connection = null;
       }
 
       // No need for the network! Promote the cached response immediately.
@@ -243,7 +230,7 @@ private void connect() throws IOException {
 
     if (!connection.isConnected()) {
       connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig());
-      client.getConnectionPool().maybeShare(connection);
+      if (connection.isSpdy()) client.getConnectionPool().share(connection);
       client.getRoutesDatabase().connected(connection.getRoute());
     } else if (!connection.isSpdy()) {
       connection.updateReadTimeout(client.getReadTimeout());
@@ -252,15 +239,6 @@ private void connect() throws IOException {
     route = connection.getRoute();
   }
 
-  /**
-   * Recycle the connection to the origin server. It is an error to call this
-   * with a request in flight.
-   */
-  private void disconnect() {
-    client.getConnectionPool().recycle(connection);
-    connection = null;
-  }
-
   /**
    * Called immediately before the transport transmits HTTP request headers.
    * This is used to observe the sent time should the request be cached.
@@ -324,10 +302,10 @@ public HttpEngine recover(IOException e) {
       return null;
     }
 
-    release(true);
+    Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, request, bufferRequestBody, null, routeSelector,
+    return new HttpEngine(client, request, bufferRequestBody, connection, routeSelector,
         (RetryableOutputStream) requestBodyOut);
   }
 
@@ -363,42 +341,42 @@ private void maybeCache() throws IOException {
   }
 
   /**
-   * Cause the socket connection to be released to the connection pool when
-   * it is no longer needed. If it is already unneeded, it will be pooled
-   * immediately. Otherwise the connection is held so that redirects can be
-   * handled by the same connection.
+   * Configure the socket connection to be either pooled or closed when it is
+   * either exhausted or closed. If it is unneeded when this is called, it will
+   * be released immediately.
    */
-  public final void automaticallyReleaseConnectionToPool() {
-    automaticallyReleaseConnectionToPool = true;
-    if (connection != null && connectionReleased) {
-      disconnect();
+  public final void releaseConnection() throws IOException {
+    if (transport != null) {
+      transport.releaseConnectionOnIdle();
     }
+    connection = null;
   }
 
   /**
-   * Releases this engine so that its resources may be either reused or
-   * closed. Also call {@link #automaticallyReleaseConnectionToPool} unless
-   * the connection will be used to follow a redirect.
+   * Release any resources held by this engine. If a connection is still held by
+   * this engine, it is returned.
    */
-  public final void release(boolean streamCanceled) {
-    // If the response body comes from the cache, close it.
-    if (validatingResponse != null
-        && validatingResponse.body() != null
-        && responseBodyIn == validatingResponse.body().byteStream()) {
-      closeQuietly(responseBodyIn);
+  public final Connection close() {
+    // If this engine never achieved a response body, its connection cannot be reused.
+    if (responseBodyIn == null) {
+      closeQuietly(connection);
+      connection = null;
+      return null;
     }
 
-    if (connection != null && !connectionReleased) {
-      connectionReleased = true;
+    // Close the response body. This will recycle the connection if it is eligible.
+    closeQuietly(responseBodyIn);
 
-      if (transport == null
-          || !transport.makeReusable(streamCanceled, requestBodyOut, responseTransferIn)) {
-        closeQuietly(connection);
-        connection = null;
-      } else if (automaticallyReleaseConnectionToPool) {
-        disconnect();
-      }
+    // Close the connection if it cannot be reused.
+    if (transport != null && !transport.canReuseConnection()) {
+      closeQuietly(connection);
+      connection = null;
+      return null;
     }
+
+    Connection result = connection;
+    connection = null;
+    return result;
   }
 
   /**
@@ -553,7 +531,7 @@ public final void readResponse() throws IOException {
     if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
       if (validatingResponse.validate(response)) {
         transport.emptyTransferStream();
-        release(false);
+        releaseConnection();
         response = combine(validatingResponse, response);
 
         // Update the cache after combining headers but before stripping the
@@ -18,7 +18,6 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.AbstractOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -104,46 +103,39 @@ public void writeRequestHeaders(Request request) throws IOException {
     return httpConnection.readResponse();
   }
 
-  public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn) {
-    if (streamCanceled) {
-      return false;
-    }
-
-    // We cannot reuse sockets that have incomplete output.
-    if (requestBodyOut != null && !((AbstractOutputStream) requestBodyOut).isClosed()) {
-      return false;
+  @Override public void releaseConnectionOnIdle() throws IOException {
+    if (canReuseConnection()) {
+      httpConnection.poolOnIdle();
+    } else {
+      httpConnection.closeOnIdle();
     }
+  }
 
+  @Override public boolean canReuseConnection() {
     // If the request specified that the connection shouldn't be reused, don't reuse it.
     if (""close"".equalsIgnoreCase(httpEngine.getRequest().header(""Connection""))) {
       return false;
     }
 
     // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.getResponse() != null
-        && ""close"".equalsIgnoreCase(httpEngine.getResponse().header(""Connection""))) {
+    if (""close"".equalsIgnoreCase(httpEngine.getResponse().header(""Connection""))) {
       return false;
     }
 
-    if (responseBodyIn instanceof HttpConnection.UnknownLengthHttpInputStream) {
+    if (httpConnection.isClosed()) {
       return false;
     }
 
-    if (responseBodyIn != null) {
-      return httpConnection.discard(httpEngine, responseBodyIn);
-    }
-
     return true;
   }
 
-  @Override public void emptyTransferStream() {
+  @Override public void emptyTransferStream() throws IOException {
     httpConnection.emptyResponseBody();
   }
 
   @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
     if (!httpEngine.hasResponseBody()) {
-      return httpConnection.newFixedLengthInputStream(cacheRequest, httpEngine, 0);
+      return httpConnection.newFixedLengthInputStream(cacheRequest, 0);
     }
 
     if (""chunked"".equalsIgnoreCase(httpEngine.getResponse().header(""Transfer-Encoding""))) {
@@ -152,7 +144,7 @@ public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
 
     long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
     if (contentLength != -1) {
-      return httpConnection.newFixedLengthInputStream(cacheRequest, httpEngine, contentLength);
+      return httpConnection.newFixedLengthInputStream(cacheRequest, contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
@@ -24,9 +24,9 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -101,15 +101,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final void disconnect() {
     // Calling disconnect() before a connection exists should have no effect.
     if (httpEngine != null) {
-      // We close the response body here instead of in
-      // HttpEngine.release because that is called when input
-      // has been completely read from the underlying socket.
-      // However the response body can be a GZIPInputStream that
-      // still has unread data.
-      if (httpEngine.hasResponse()) {
-        Util.closeQuietly(httpEngine.getResponseBody());
-      }
-      httpEngine.release(true);
+      httpEngine.close();
     }
   }
 
@@ -327,7 +319,7 @@ private HttpEngine getResponse() throws IOException {
 
       Retry retry = processResponseHeaders();
       if (retry == Retry.NONE) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+        httpEngine.releaseConnection();
         return httpEngine;
       }
 
@@ -353,12 +345,11 @@ private HttpEngine getResponse() throws IOException {
       }
 
       if (retry == Retry.DIFFERENT_CONNECTION) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+        httpEngine.releaseConnection();
       }
 
-      httpEngine.release(false);
-      httpEngine = newHttpEngine(retryMethod, httpEngine.getConnection(),
-          (RetryableOutputStream) requestBody);
+      Connection connection = httpEngine.close();
+      httpEngine = newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);
     }
   }
 
@@ -117,7 +117,7 @@ public Connection next(String method) throws IOException {
           if (!hasNextPostponed()) {
             throw new NoSuchElementException();
           }
-          return new Connection(nextPostponed());
+          return new Connection(pool, nextPostponed());
         }
         lastProxy = nextProxy();
         resetNextInetSocketAddress(lastProxy);
@@ -135,7 +135,7 @@ public Connection next(String method) throws IOException {
       return next(method);
     }
 
-    return new Connection(route);
+    return new Connection(pool, route);
   }
 
   /**
@@ -195,9 +195,11 @@ public static Response.Builder readNameValueBlock(List<Header> headerBlock,
     return new SpdyInputStream(stream, cacheRequest, httpEngine);
   }
 
-  @Override public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn) {
-    return true; // SPDY sockets are always reusable.
+  @Override public void releaseConnectionOnIdle() {
+  }
+
+  @Override public boolean canReuseConnection() {
+    return true; // TODO: spdyConnection.isClosed() ?
   }
 
   /** When true, this header should not be emitted or consumed. */
@@ -242,15 +244,12 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
    */
   abstract static class AbstractHttpInputStream extends InputStream {
     protected final InputStream in;
-    protected final HttpEngine httpEngine;
     private final CacheRequest cacheRequest;
     protected final OutputStream cacheBody;
     protected boolean closed;
 
-    AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest)
-        throws IOException {
+    AbstractHttpInputStream(InputStream in, CacheRequest cacheRequest) throws IOException {
       this.in = in;
-      this.httpEngine = httpEngine;
 
       OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
 
@@ -272,9 +271,7 @@ abstract static class AbstractHttpInputStream extends InputStream {
     }
 
     protected final void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException(""stream closed"");
-      }
+      if (closed) throw new IOException(""stream closed"");
     }
 
     protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOException {
@@ -291,7 +288,6 @@ protected final void endOfInput() throws IOException {
       if (cacheRequest != null) {
         cacheBody.close();
       }
-      httpEngine.release(false);
     }
 
     /**
@@ -310,7 +306,6 @@ protected final void unexpectedEndOfInput() {
       if (cacheRequest != null) {
         cacheRequest.abort();
       }
-      httpEngine.release(true);
     }
   }
 
@@ -321,7 +316,7 @@ private static class SpdyInputStream extends AbstractHttpInputStream {
 
     SpdyInputStream(SpdyStream stream, CacheRequest cacheRequest, HttpEngine httpEngine)
         throws IOException {
-      super(stream.getInputStream(), httpEngine, cacheRequest);
+      super(stream.getInputStream(), cacheRequest);
       this.stream = stream;
     }
 
@@ -65,12 +65,20 @@ interface Transport {
   Response.Builder readResponseHeaders() throws IOException;
 
   /** Notify the transport that no response body will be read. */
-  void emptyTransferStream();
+  void emptyTransferStream() throws IOException;
 
   // TODO: make this the content stream?
   InputStream getTransferStream(CacheRequest cacheRequest) throws IOException;
 
-  /** Returns true if the underlying connection can be recycled. */
-  boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn);
+  /**
+   * Configures the response body to pool or close the socket connection when
+   * the response body is closed.
+   */
+  void releaseConnectionOnIdle() throws IOException;
+
+  /**
+   * Returns true if the socket connection held by this transport can be reused
+   * for a follow-up exchange.
+   */
+  boolean canReuseConnection();
 }
@@ -35,6 +35,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public final class ConnectionPoolTest {
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
@@ -54,7 +55,6 @@ public final class ConnectionPoolTest {
   private Connection httpD;
   private Connection httpE;
   private Connection spdyA;
-  private Connection spdyB;
 
   @Before public void setUp() throws Exception {
     spdyServer.useHttps(sslContext.getSocketFactory(), false);
@@ -74,20 +74,18 @@ public final class ConnectionPoolTest {
 
     Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true);
     Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, true);
-    httpA = new Connection(httpRoute);
+    httpA = new Connection(null, httpRoute);
     httpA.connect(200, 200, null);
-    httpB = new Connection(httpRoute);
+    httpB = new Connection(null, httpRoute);
     httpB.connect(200, 200, null);
-    httpC = new Connection(httpRoute);
+    httpC = new Connection(null, httpRoute);
     httpC.connect(200, 200, null);
-    httpD = new Connection(httpRoute);
+    httpD = new Connection(null, httpRoute);
     httpD.connect(200, 200, null);
-    httpE = new Connection(httpRoute);
+    httpE = new Connection(null, httpRoute);
     httpE.connect(200, 200, null);
-    spdyA = new Connection(spdyRoute);
-    spdyA.connect(200, 200, null);
-    spdyB = new Connection(spdyRoute);
-    spdyB.connect(200, 200, null);
+    spdyA = new Connection(null, spdyRoute);
+    spdyA.connect(20000, 20000, null);
   }
 
   @After public void tearDown() throws Exception {
@@ -100,15 +98,15 @@ public final class ConnectionPoolTest {
     Util.closeQuietly(httpD);
     Util.closeQuietly(httpE);
     Util.closeQuietly(spdyA);
-    Util.closeQuietly(spdyB);
   }
 
   @Test public void poolSingleHttpConnection() throws IOException {
     ConnectionPool pool = new ConnectionPool(1, KEEP_ALIVE_DURATION_MS);
     Connection connection = pool.get(httpAddress);
     assertNull(connection);
 
-    connection = new Connection(new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
+    connection = new Connection(
+        null, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
     connection.connect(200, 200, null);
     assertEquals(0, pool.getConnectionCount());
     pool.recycle(connection);
@@ -134,7 +132,7 @@ public final class ConnectionPoolTest {
 
   @Test public void getSpdyConnection() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     assertSame(spdyA, pool.get(spdyAddress));
     assertPooled(pool, spdyA);
   }
@@ -189,7 +187,7 @@ public final class ConnectionPoolTest {
 
   @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     pool.recycle(httpA);
     assertPooled(pool, httpA, spdyA);
     assertSame(spdyA, pool.get(spdyAddress));
@@ -210,9 +208,13 @@ public final class ConnectionPoolTest {
     assertTrue(httpA.getSocket().isClosed());
   }
 
-  @Test public void shareHttpConnectionDoesNothing() throws Exception {
+  @Test public void shareHttpConnectionFails() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(httpA);
+    try {
+      pool.share(httpA);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
     assertPooled(pool);
   }
 
@@ -224,7 +226,7 @@ public final class ConnectionPoolTest {
 
   @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
     assertNull(pool.get(httpAddress));
     assertPooled(pool, spdyA); // Connection should still be in the pool.
@@ -270,7 +272,7 @@ public final class ConnectionPoolTest {
     assertEquals(0, pool.getSpdyConnectionCount());
 
     // spdy A should be added and http B should be removed.
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     Thread.sleep(50);
     assertEquals(2, pool.getConnectionCount());
     assertEquals(1, pool.getHttpConnectionCount());
@@ -299,13 +301,6 @@ public final class ConnectionPoolTest {
     assertEquals(1, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
 
-    // Nothing should change.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
     // An http connection should be removed from the pool.
     recycledHttpConnection = pool.get(httpAddress);
     assertNotNull(recycledHttpConnection);
@@ -314,13 +309,6 @@ public final class ConnectionPoolTest {
     assertEquals(0, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
 
-    // Shouldn't change numbers because spdyConnections A and B user the same server address.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
     // spdy A will be returned and kept in the pool. Pool shouldn't change.
     sharedSpdyConnection = pool.get(spdyAddress);
     assertEquals(spdyA, sharedSpdyConnection);
@@ -350,7 +338,7 @@ public final class ConnectionPoolTest {
     // Add 3 connections to the pool.
     pool.recycle(httpA);
     pool.recycle(httpB);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     assertEquals(3, pool.getConnectionCount());
     assertEquals(2, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
@@ -383,7 +371,7 @@ public final class ConnectionPoolTest {
     pool.recycle(httpA);
     Util.closeQuietly(httpA); // Include a closed connection in the pool.
     pool.recycle(httpB);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     int connectionCount = pool.getConnectionCount();
     assertTrue(connectionCount == 2 || connectionCount == 3);
 
"
https://github.com/square/retrofit/commit/ffab8145393225741167a003577696549573e857,Fix spelling ,https://api.github.com/repos/square/retrofit/commits/ffab8145393225741167a003577696549573e857,"@@ -209,7 +209,7 @@ public void testFailedExpansion() throws IOException {
     assertEquals(values[99], queueFile.peek());
   }
 
-  public void testPeakWithElementReader() throws IOException {
+  public void testPeekWithElementReader() throws IOException {
     QueueFile queueFile = new QueueFile(file);
     final byte[] a = {1, 2};
     queueFile.add(a);
"
https://github.com/spring-projects/spring-boot/commit/f34508ff8a1d85b43a0beccfc8d7377c2c993450,Remove outdated key  <enter> The `spring.metrics.export.redis.aggregate-key-pattern` is no longer defined but was still referenced in the documentation. ,https://api.github.com/repos/spring-projects/spring-boot/commits/f34508ff8a1d85b43a0beccfc8d7377c2c993450,"@@ -726,7 +726,6 @@ content into your application; rather pick only the properties that you need.
 	spring.metrics.export.send-latest=true # flag to switch off any available optimizations based on not exporting unchanged metric values
 	spring.metrics.export.includes= # list of patterns for metric names to include
 	spring.metrics.export.excludes= # list of patterns for metric names to exclude. Applied after the includes
-	spring.metrics.export.redis.aggregate-key-pattern= # pattern that tells the aggregator what to do with the keys from the source repository
 	spring.metrics.export.redis.prefix=spring.metrics # prefix for redis repository if active
 	spring.metrics.export.redis.key=keys.spring.metrics # key for redis repository export (if active)
 	spring.metrics.export.triggers.*= # specific trigger properties per MetricWriter bean name
"
https://github.com/apache/dubbo/commit/5668d740766f6303e789f072100cd235e4b67582,"Fix export provider error, change to catch throwable, handle NoClassDefFoundError ( <pr_link> ) ",https://api.github.com/repos/apache/dubbo/commits/5668d740766f6303e789f072100cd235e4b67582,"@@ -40,7 +40,7 @@
 
 /**
  * When there're more than one registry for subscription.
- *
+ * <p>
  * This extension provides a strategy to decide how to distribute traffics among them:
  * 1. registry marked as 'preferred=true' has the highest priority.
  * 2. check the zone the current request belongs, pick the registry that has the same zone first.
@@ -143,10 +143,10 @@ public void publishServiceDefinition(URL providerUrl) {
                 serviceDefinitions.put(providerUrl.getServiceKey(), data);
                 return;
             }
-            logger.info(""publishProvider interfaceName is empty . providerUrl: "" + providerUrl.toFullString());
-        } catch (ClassNotFoundException e) {
+            logger.error(""publishProvider interfaceName is empty . providerUrl: "" + providerUrl.toFullString());
+        } catch (Throwable t) {
             //ignore error
-            logger.error(""publishProvider getServiceDescriptor error. providerUrl: "" + providerUrl.toFullString(), e);
+            logger.error(""publishProvider getServiceDescriptor error. providerUrl: "" + providerUrl.toFullString(), t.getCause());
         }
     }
 
@@ -100,9 +100,9 @@ private void publishProvider(URL providerUrl) throws RpcException {
                 return;
             }
             logger.error(""publishProvider interfaceName is empty . providerUrl: "" + providerUrl.toFullString());
-        } catch (ClassNotFoundException e) {
+        } catch (Throwable t) {
             //ignore error
-            logger.error(""publishProvider getServiceDescriptor error. providerUrl: "" + providerUrl.toFullString(), e);
+            logger.error(""publishProvider getServiceDescriptor error. providerUrl: "" + providerUrl.toFullString(), t.getCause());
         }
     }
 
"
https://github.com/apache/dubbo/commit/54b0d7e3f4bc8f348c6260f649c6e3174d5b8a03,Remove duplicate dependency from [dubbo-bom] and [dubbo-demo-xml-consumer] ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/54b0d7e3f4bc8f348c6260f649c6e3174d5b8a03,"@@ -374,11 +374,6 @@
                 <artifactId>dubbo-metadata-api</artifactId>
                 <version>${project.version}</version>
             </dependency>
-            <dependency>
-                <groupId>org.apache.dubbo</groupId>
-                <artifactId>dubbo-metadata-api</artifactId>
-                <version>${project.version}</version>
-            </dependency>
             <dependency>
                 <groupId>org.apache.dubbo</groupId>
                 <artifactId>dubbo-metadata-report-zookeeper</artifactId>
@@ -67,10 +67,6 @@
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-metadata-report-nacos</artifactId>
         </dependency>
-        <dependency>
-            <groupId>org.apache.dubbo</groupId>
-            <artifactId>dubbo-metadata-report-zookeeper</artifactId>
-        </dependency>
         <dependency>
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-config-spring</artifactId>
"
https://github.com/spring-projects/spring-boot/commit/8e2e493946357bcefb53d0b0a608becad7719413,"Remove HSQLDB dependency from Batch Starter  <enter> This commit removes HSQLDB dependency from Batch Starter as most apps that use Spring Batch will prefer to use a RDBMS of their choice to store batch metadata. <enter> Additionally, explicit spring-jdbc dependency has been replaced with JDBC Starter dependency. <enter> See  <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/8e2e493946357bcefb53d0b0a608becad7719413,"@@ -23,6 +23,10 @@
 			<groupId>org.springframework.boot</groupId>
 			<artifactId>spring-boot-starter-batch</artifactId>
 		</dependency>
+		<dependency>
+			<groupId>org.hsqldb</groupId>
+			<artifactId>hsqldb</artifactId>
+		</dependency>
 		<dependency>
 			<groupId>org.springframework.boot</groupId>
 			<artifactId>spring-boot-starter-test</artifactId>
@@ -8,7 +8,7 @@
 	</parent>
 	<artifactId>spring-boot-starter-batch</artifactId>
 	<name>Spring Boot Batch Starter</name>
-	<description>Starter for using Spring Batch, including HSQLDB in-memory database</description>
+	<description>Starter for using Spring Batch</description>
 	<url>http://projects.spring.io/spring-boot/</url>
 	<organization>
 		<name>Pivotal Software, Inc.</name>
@@ -23,12 +23,8 @@
 			<artifactId>spring-boot-starter</artifactId>
 		</dependency>
 		<dependency>
-			<groupId>org.hsqldb</groupId>
-			<artifactId>hsqldb</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework</groupId>
-			<artifactId>spring-jdbc</artifactId>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-jdbc</artifactId>
 		</dependency>
 		<dependency>
 			<groupId>org.springframework.batch</groupId>
@@ -1 +1 @@
-provides: spring-batch
\ No newline at end of file
+provides: spring-batch-core
\ No newline at end of file
"
https://github.com/square/retrofit/commit/8bd6c990a728955f91646156b78244061ea91a2a,Prepare next development version ,https://api.github.com/repos/square/retrofit/commits/8bd6c990a728955f91646156b78244061ea91a2a,"@@ -1,6 +1,40 @@
 Change Log
 ==========
 
+Version 2.5.0 *(2018-11-18)*
+============================
+
+ * New: Built-in support for Kotlin's `Unit` type. This behaves the same as Java's `Void` where the body
+   content is ignored and immediately discarded.
+ * New: Build-in support for Java 8's `Optional` and `CompletableFuture` types. Previously the 'converter-java8'
+   and 'adapter-java8' dependencies were needed and explicitly adding `Java8OptionalConverterFactory` and/or
+   `Java8CallAdapterFactory` to your `Retrofit.Builder` in order to use these types. Support is now built-in and
+   those types and their artifacts are marked as deprecated.
+ * New: `Invocation` class provides a reference to the invoked method and argument list as a tag on the
+   underlying OkHttp `Call`. This can be accessed from an OkHttp interceptor for things like logging, analytics,
+   or metrics aggregation.
+ * New: Kotlin extension for `Retrofit` which allows you call `create` passing the interface type only as
+   a generic parameter (e.g., `retrofit.create<MyService>()`).
+ * New: Added `Response.success` overload which allows specifying a custom 2xx status code.
+ * New: Added `Call.failure` overload which allows passing any `Throwable` subtype.
+ * New: Minimal R8 rules now ship inside the jar requiring no client configuration in the common case.
+ * Fix: Do not propagate fatal errors to the callback. They are sent to the thread's uncaught
+   exception handler.
+ * Fix: Do not enqueue/execute an otherwise useless call when the RxJava type is disposed by `onSubscribe`.
+ * Fix: Call `RxJavaPlugins` assembly hook when creating an RxJava 2 type.
+ * Fix: Ensure both the Guava and Java 8 `Optional` converters delegate properly. This ensures that converters
+   registered prior to the optional converter can be used for deserializing the body type.
+ * Fix: Prevent `@Path` values from participating in path-traversal. This ensures untrusted input passed as
+   a path value cannot cause you to make a request to an un-intended relative URL.
+ * Fix: Simple XML converter (which is deprecated) no longer wraps subtypes of `RuntimeException`
+   or `IOException` when it fails.
+ * Fix: Prevent JAXB converter from loading remote entities and DTDs.
+ * Fix: Correctly detect default methods in interfaces on Android (API 24+). These still do not work, but
+   now a correct exception will be thrown when detected.
+ * Fix: Report more accurate exceptions when a `@QueryName` or `@QueryMap` precedes a `@Url` parameter.
+ * Update OkHttp dependency to 3.12.
+
+
 Version 2.4.0 *(2018-03-14)*
 ----------------------------
 
@@ -9,18 +9,7 @@ For more information please see [the website][1].
 Download
 --------
 
-Download [the latest JAR][2] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>retrofit</artifactId>
-  <version>2.4.0</version>
-</dependency>
-```
-or Gradle:
-```groovy
-implementation 'com.squareup.retrofit2:retrofit:2.4.0'
-```
+Download [the latest JAR][2] or grab from Maven central at the coordinates `com.squareup.retrofit2:retrofit:2.5.0`.
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
@@ -30,10 +19,11 @@ Retrofit requires at minimum Java 7 or Android 2.3.
 R8 / ProGuard
 -------------
 
-If you are using R8 or ProGuard add the options from
-[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro).
+If you are using R8 the shrinking and obfuscation rules are included automatically.
 
-You might also need rules for OkHttp and Okio which are dependencies of this library.
+ProGuard users must manually add the options from
+[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro).
+(Note: You might also need rules for OkHttp and Okio which are dependencies of this library)
 
 
 License
"
https://github.com/square/retrofit/commit/b3fcdca9939f376d9f825bb6ccaeeaa97c0f8325,"Fix inconsistencies in javadocs.  <enter> These changes were made with consistency in mind, in relation to the rest of the project:  - Change self-closing <p/> tags to regular <p> tags.  - Add missing <p> tags. ",https://api.github.com/repos/square/retrofit/commits/b3fcdca9939f376d9f825bb6ccaeeaa97c0f8325,"@@ -5,7 +5,7 @@
 
 /**
  * Represents a named parameter and its value.
- * <p/>
+ * <p>
  * This is used in one of three places in a request:
  * <ul>
  * <li>Named replacement in the relative URL path.
@@ -11,7 +11,7 @@ public interface Profiler<T> {
   /**
    * Invoked before an HTTP method call. The object returned by this method will be
    * passed to {@link #afterCall} when the call returns.
-   *
+   * <p>
    * This method gives implementors the opportunity to include information that may
    * change during the server call in {@code afterCall} logic.
    */
@@ -58,11 +58,11 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
 
   /**
    * Adapts a Java interface to a REST API.
-   * <p/>
+   * <p>
    * The relative path for a given method is obtained from an annotation on the method describing
    * the request type. The names of URL parameters are retrieved from {@link Name}
    * annotations on the method parameters.
-   * <p/>
+   * <p>
    * HTTP requests happen in one of two ways:
    * <ul>
    * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
@@ -74,7 +74,7 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
    * response will be converted to the method's return type using the specified
    * {@link Converter}.</li>
    * </ul>
-   * <p/>
+   * <p>
    * For example:
    * <pre>
    *   public interface MyApi {
@@ -260,13 +260,14 @@ private static Profiler.RequestInformation getRequestInfo(Server server,
 
   /**
    * Build a new {@link RestAdapter}.
-   * <p/>
+   * <p>
    * Calling the following methods is required before calling {@link #build()}:
    * <ul>
    * <li>{@link #setServer(Server)}</li>
    * <li>{@link #setClient(Client.Provider)}</li>
    * <li>{@link #setConverter(Converter)}</li>
    * </ul>
+   * <p>
    * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following
    * is also required:
    * <ul>
"
https://github.com/apache/dubbo/commit/48cb8e41a76b49b184f2b97e61b42eb109a16229,refactor package  <enter> git-svn-id:  http://code.alibabatech.com/svn/dubbo/trunk@1395  1a56cb94-b969-4eaa-88fa-be21384802f2 ,https://api.github.com/repos/apache/dubbo/commits/48cb8e41a76b49b184f2b97e61b42eb109a16229,
https://github.com/apache/dubbo/commit/93b1cf014af7cce13f12816ab7114881765d4471,"Move UT in config-api to bootstrap temporarily, to solve the unreasonable dependency problem between modules. For long term run, we should refactor the config-api module to stop it from depending on other modules.",https://api.github.com/repos/apache/dubbo/commits/93b1cf014af7cce13f12816ab7114881765d4471,"@@ -43,5 +43,69 @@
             <artifactId>dubbo-registry-api</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-monitor-default</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-dubbo</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-rmi</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-remoting-netty4</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>javax.validation</groupId>
+            <artifactId>validation-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.hibernate</groupId>
+            <artifactId>hibernate-validator</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish</groupId>
+            <artifactId>javax.el</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-default</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-multicast</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-serialization-hessian2</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-serialization-jdk</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 </project>
\ No newline at end of file
@@ -1,515 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import junit.framework.TestCase;
-import org.apache.dubbo.config.api.Greeting;
-import org.apache.dubbo.config.support.Parameter;
-import org.hamcrest.Matchers;
-import org.junit.Test;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.junit.Assert.assertThat;
-
-public class AbstractConfigTest {
-
-    //FIXME
-  /*  @Test
-    public void testAppendProperties1() throws Exception {
-        try {
-            System.setProperty(""dubbo.properties.i"", ""1"");
-            System.setProperty(""dubbo.properties.c"", ""c"");
-            System.setProperty(""dubbo.properties.b"", ""2"");
-            System.setProperty(""dubbo.properties.d"", ""3"");
-            System.setProperty(""dubbo.properties.f"", ""4"");
-            System.setProperty(""dubbo.properties.l"", ""5"");
-            System.setProperty(""dubbo.properties.s"", ""6"");
-            System.setProperty(""dubbo.properties.str"", ""dubbo"");
-            System.setProperty(""dubbo.properties.bool"", ""true"");
-            PropertiesConfig config = new PropertiesConfig();
-            AbstractConfig.appendProperties(config);
-            TestCase.assertEquals(1, config.getI());
-            TestCase.assertEquals('c', config.getC());
-            TestCase.assertEquals((byte) 0x02, config.getB());
-            TestCase.assertEquals(3d, config.getD());
-            TestCase.assertEquals(4f, config.getF());
-            TestCase.assertEquals(5L, config.getL());
-            TestCase.assertEquals(6, config.getS());
-            TestCase.assertEquals(""dubbo"", config.getStr());
-            TestCase.assertTrue(config.isBool());
-        } finally {
-            System.clearProperty(""dubbo.properties.i"");
-            System.clearProperty(""dubbo.properties.c"");
-            System.clearProperty(""dubbo.properties.b"");
-            System.clearProperty(""dubbo.properties.d"");
-            System.clearProperty(""dubbo.properties.f"");
-            System.clearProperty(""dubbo.properties.l"");
-            System.clearProperty(""dubbo.properties.s"");
-            System.clearProperty(""dubbo.properties.str"");
-            System.clearProperty(""dubbo.properties.bool"");
-        }
-    }
-
-    @Test
-    public void testAppendProperties2() throws Exception {
-        try {
-            System.setProperty(""dubbo.properties.two.i"", ""2"");
-            PropertiesConfig config = new PropertiesConfig(""two"");
-            AbstractConfig.appendProperties(config);
-            TestCase.assertEquals(2, config.getI());
-        } finally {
-            System.clearProperty(""dubbo.properties.two.i"");
-        }
-    }
-
-    @Test
-    public void testAppendProperties3() throws Exception {
-        try {
-            Properties p = new Properties();
-            p.put(""dubbo.properties.str"", ""dubbo"");
-            ConfigUtils.setProperties(p);
-            PropertiesConfig config = new PropertiesConfig();
-            AbstractConfig.appendProperties(config);
-            TestCase.assertEquals(""dubbo"", config.getStr());
-        } finally {
-            System.clearProperty(Constants.DUBBO_PROPERTIES_KEY);
-            ConfigUtils.setProperties(null);
-        }
-    }*/
-
-    @Test
-    public void testAppendParameters1() throws Exception {
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(""default.num"", ""one"");
-        parameters.put(""num"", ""ONE"");
-        AbstractConfig.appendParameters(parameters, new ParameterConfig(1, ""hello/world"", 30, ""password""), ""prefix"");
-        TestCase.assertEquals(""one"", parameters.get(""prefix.key.1""));
-        TestCase.assertEquals(""two"", parameters.get(""prefix.key.2""));
-        TestCase.assertEquals(""ONE,one,1"", parameters.get(""prefix.num""));
-        TestCase.assertEquals(""hello%2Fworld"", parameters.get(""prefix.naming""));
-        TestCase.assertEquals(""30"", parameters.get(""prefix.age""));
-        TestCase.assertFalse(parameters.containsKey(""prefix.key-2""));
-        TestCase.assertFalse(parameters.containsKey(""prefix.secret""));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testAppendParameters2() throws Exception {
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractConfig.appendParameters(parameters, new ParameterConfig());
-    }
-
-    @Test
-    public void testAppendParameters3() throws Exception {
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractConfig.appendParameters(parameters, null);
-        TestCase.assertTrue(parameters.isEmpty());
-    }
-
-    @Test
-    public void testAppendParameters4() throws Exception {
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractConfig.appendParameters(parameters, new ParameterConfig(1, ""hello/world"", 30, ""password""));
-        TestCase.assertEquals(""one"", parameters.get(""key.1""));
-        TestCase.assertEquals(""two"", parameters.get(""key.2""));
-        TestCase.assertEquals(""1"", parameters.get(""num""));
-        TestCase.assertEquals(""hello%2Fworld"", parameters.get(""naming""));
-        TestCase.assertEquals(""30"", parameters.get(""age""));
-    }
-
-    @Test
-    public void testAppendAttributes1() throws Exception {
-        Map<String, Object> parameters = new HashMap<String, Object>();
-        AbstractConfig.appendAttributes(parameters, new AttributeConfig('l', true, (byte) 0x01), ""prefix"");
-        TestCase.assertEquals('l', parameters.get(""prefix.let""));
-        TestCase.assertEquals(true, parameters.get(""prefix.activate""));
-        TestCase.assertFalse(parameters.containsKey(""prefix.flag""));
-    }
-
-    @Test
-    public void testAppendAttributes2() throws Exception {
-        Map<String, Object> parameters = new HashMap<String, Object>();
-        AbstractConfig.appendAttributes(parameters, new AttributeConfig('l', true, (byte) 0x01));
-        TestCase.assertEquals('l', parameters.get(""let""));
-        TestCase.assertEquals(true, parameters.get(""activate""));
-        TestCase.assertFalse(parameters.containsKey(""flag""));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkExtension() throws Exception {
-        AbstractConfig.checkExtension(Greeting.class, ""hello"", ""world"");
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkMultiExtension1() throws Exception {
-        AbstractConfig.checkMultiExtension(Greeting.class, ""hello"", ""default,world"");
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkMultiExtension2() throws Exception {
-        AbstractConfig.checkMultiExtension(Greeting.class, ""hello"", ""default,-world"");
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkLength() throws Exception {
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0; i <= 200; i++) {
-            builder.append(""a"");
-        }
-        AbstractConfig.checkLength(""hello"", builder.toString());
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkPathLength() throws Exception {
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0; i <= 200; i++) {
-            builder.append(""a"");
-        }
-        AbstractConfig.checkPathLength(""hello"", builder.toString());
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkName() throws Exception {
-        AbstractConfig.checkName(""hello"", ""world%"");
-    }
-
-    @Test
-    public void checkNameHasSymbol() throws Exception {
-        try {
-            AbstractConfig.checkNameHasSymbol(""hello"", "":*,/-0123abcdABCD"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    public void checkKey() throws Exception {
-        try {
-            AbstractConfig.checkKey(""hello"", ""*,-0123abcdABCD"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    public void checkMultiName() throws Exception {
-        try {
-            AbstractConfig.checkMultiName(""hello"", "",-._0123abcdABCD"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    public void checkPathName() throws Exception {
-        try {
-            AbstractConfig.checkPathName(""hello"", ""/-$._0123abcdABCD"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    public void checkMethodName() throws Exception {
-        try {
-            AbstractConfig.checkMethodName(""hello"", ""abcdABCD0123abcd"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-
-        try {
-            AbstractConfig.checkMethodName(""hello"", ""0a"");
-            TestCase.fail(""the value should be illegal."");
-        } catch (Exception e) {
-            // ignore
-        }
-    }
-
-    @Test
-    public void checkParameterName() throws Exception {
-        Map<String, String> parameters = Collections.singletonMap(""hello"", "":*,/-._0123abcdABCD"");
-        try {
-            AbstractConfig.checkParameterName(parameters);
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    @Config(interfaceClass = Greeting.class, filter = {""f1, f2""}, listener = {""l1, l2""},
-            parameters = {""k1"", ""v1"", ""k2"", ""v2""})
-    public void appendAnnotation() throws Exception {
-        Config config = getClass().getMethod(""appendAnnotation"").getAnnotation(Config.class);
-        AnnotationConfig annotationConfig = new AnnotationConfig();
-        annotationConfig.appendAnnotation(Config.class, config);
-        TestCase.assertSame(Greeting.class, annotationConfig.getInterface());
-        TestCase.assertEquals(""f1, f2"", annotationConfig.getFilter());
-        TestCase.assertEquals(""l1, l2"", annotationConfig.getListener());
-        TestCase.assertEquals(2, annotationConfig.getParameters().size());
-        TestCase.assertEquals(""v1"", annotationConfig.getParameters().get(""k1""));
-        TestCase.assertEquals(""v2"", annotationConfig.getParameters().get(""k2""));
-        assertThat(annotationConfig.toString(), Matchers.containsString(""filter=\""f1, f2\"" ""));
-        assertThat(annotationConfig.toString(), Matchers.containsString(""listener=\""l1, l2\"" ""));
-    }
-
-    private static class PropertiesConfig extends AbstractConfig {
-        private char c;
-        private boolean bool;
-        private byte b;
-        private int i;
-        private long l;
-        private float f;
-        private double d;
-        private short s;
-        private String str;
-
-        PropertiesConfig() {
-        }
-
-        PropertiesConfig(String id) {
-            this.id = id;
-        }
-
-        public char getC() {
-            return c;
-        }
-
-        public void setC(char c) {
-            this.c = c;
-        }
-
-        public boolean isBool() {
-            return bool;
-        }
-
-        public void setBool(boolean bool) {
-            this.bool = bool;
-        }
-
-        public byte getB() {
-            return b;
-        }
-
-        public void setB(byte b) {
-            this.b = b;
-        }
-
-        public int getI() {
-            return i;
-        }
-
-        public void setI(int i) {
-            this.i = i;
-        }
-
-        public long getL() {
-            return l;
-        }
-
-        public void setL(long l) {
-            this.l = l;
-        }
-
-        public float getF() {
-            return f;
-        }
-
-        public void setF(float f) {
-            this.f = f;
-        }
-
-        public double getD() {
-            return d;
-        }
-
-        public void setD(double d) {
-            this.d = d;
-        }
-
-        public String getStr() {
-            return str;
-        }
-
-        public void setStr(String str) {
-            this.str = str;
-        }
-
-        public short getS() {
-            return s;
-        }
-
-        public void setS(short s) {
-            this.s = s;
-        }
-    }
-
-    private static class ParameterConfig {
-        private int number;
-        private String name;
-        private int age;
-        private String secret;
-
-        ParameterConfig() {
-        }
-
-        ParameterConfig(int number, String name, int age, String secret) {
-            this.number = number;
-            this.name = name;
-            this.age = age;
-            this.secret = secret;
-        }
-
-        @Parameter(key = ""num"", append = true)
-        public int getNumber() {
-            return number;
-        }
-
-        public void setNumber(int number) {
-            this.number = number;
-        }
-
-        @Parameter(key = ""naming"", append = true, escaped = true, required = true)
-        public String getName() {
-            return name;
-        }
-
-        public void setName(String name) {
-            this.name = name;
-        }
-
-        public int getAge() {
-            return age;
-        }
-
-        public void setAge(int age) {
-            this.age = age;
-        }
-
-        @Parameter(excluded = true)
-        public String getSecret() {
-            return secret;
-        }
-
-        public void setSecret(String secret) {
-            this.secret = secret;
-        }
-
-        public Map getParameters() {
-            Map<String, String> map = new HashMap<String, String>();
-            map.put(""key.1"", ""one"");
-            map.put(""key-2"", ""two"");
-            return map;
-        }
-    }
-
-    private static class AttributeConfig {
-        private char letter;
-        private boolean activate;
-        private byte flag;
-
-        public AttributeConfig(char letter, boolean activate, byte flag) {
-            this.letter = letter;
-            this.activate = activate;
-            this.flag = flag;
-        }
-
-        @Parameter(attribute = true, key = ""let"")
-        public char getLetter() {
-            return letter;
-        }
-
-        public void setLetter(char letter) {
-            this.letter = letter;
-        }
-
-        @Parameter(attribute = true)
-        public boolean isActivate() {
-            return activate;
-        }
-
-        public void setActivate(boolean activate) {
-            this.activate = activate;
-        }
-
-        public byte getFlag() {
-            return flag;
-        }
-
-        public void setFlag(byte flag) {
-            this.flag = flag;
-        }
-    }
-
-    @Retention(RetentionPolicy.RUNTIME)
-    @Target({ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE})
-    public @interface Config {
-        Class<?> interfaceClass() default void.class;
-
-        String interfaceName() default """";
-
-        String[] filter() default {};
-
-        String[] listener() default {};
-
-        String[] parameters() default {};
-    }
-
-    private static class AnnotationConfig extends AbstractConfig {
-        private Class interfaceClass;
-        private String filter;
-        private String listener;
-        private Map<String, String> parameters;
-
-        public Class getInterface() {
-            return interfaceClass;
-        }
-
-        public void setInterface(Class interfaceName) {
-            this.interfaceClass = interfaceName;
-        }
-
-        public String getFilter() {
-            return filter;
-        }
-
-        public void setFilter(String filter) {
-            this.filter = filter;
-        }
-
-        public String getListener() {
-            return listener;
-        }
-
-        public void setListener(String listener) {
-            this.listener = listener;
-        }
-
-        public Map<String, String> getParameters() {
-            return parameters;
-        }
-
-        public void setParameters(Map<String, String> parameters) {
-            this.parameters = parameters;
-        }
-    }
-}
@@ -1,411 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.IOUtils;
-import org.apache.dubbo.config.api.Greeting;
-import org.apache.dubbo.config.mock.GreetingLocal1;
-import org.apache.dubbo.config.mock.GreetingLocal2;
-import org.apache.dubbo.config.mock.GreetingLocal3;
-import org.apache.dubbo.config.mock.GreetingMock1;
-import org.apache.dubbo.config.mock.GreetingMock2;
-import org.apache.dubbo.monitor.MonitorService;
-import org.apache.dubbo.registry.RegistryService;
-import junit.framework.TestCase;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.ClassRule;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Properties;
-
-public class AbstractInterfaceConfigTest {
-    @ClassRule
-    public static TemporaryFolder tempDir = new TemporaryFolder();
-    private static File dubboProperties;
-
-    @BeforeClass
-    public static void setUp() throws Exception {
-        dubboProperties = tempDir.newFile(Constants.DUBBO_PROPERTIES_KEY);
-        System.setProperty(Constants.DUBBO_PROPERTIES_KEY, dubboProperties.getAbsolutePath());
-    }
-
-    @AfterClass
-    public static void tearDown() throws Exception {
-        System.clearProperty(Constants.DUBBO_PROPERTIES_KEY);
-    }
-
-    @Test
-    public void testCheckRegistry1() throws Exception {
-        System.setProperty(""dubbo.registry.address"", ""addr1|addr2"");
-        try {
-            InterfaceConfig interfaceConfig = new InterfaceConfig();
-            interfaceConfig.checkRegistry();
-            TestCase.assertEquals(2, interfaceConfig.getRegistries().size());
-        } finally {
-            System.clearProperty(""dubbo.registry.address"");
-        }
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testCheckRegistry2() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkRegistry();
-    }
-
-    @Test
-    public void checkApplication1() throws Exception {
-        try {
-            ConfigUtils.setProperties(null);
-            System.clearProperty(Constants.SHUTDOWN_WAIT_KEY);
-            System.clearProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);
-
-            writeDubboProperties(Constants.SHUTDOWN_WAIT_KEY, ""100"");
-            System.setProperty(""dubbo.application.name"", ""demo"");
-            InterfaceConfig interfaceConfig = new InterfaceConfig();
-            interfaceConfig.checkApplication();
-            ApplicationConfig appConfig = interfaceConfig.getApplication();
-            TestCase.assertEquals(""demo"", appConfig.getName());
-            TestCase.assertEquals(""100"", System.getProperty(Constants.SHUTDOWN_WAIT_KEY));
-
-            System.clearProperty(Constants.SHUTDOWN_WAIT_KEY);
-            ConfigUtils.setProperties(null);
-            writeDubboProperties(Constants.SHUTDOWN_WAIT_SECONDS_KEY, ""1000"");
-            System.setProperty(""dubbo.application.name"", ""demo"");
-            interfaceConfig = new InterfaceConfig();
-            interfaceConfig.checkApplication();
-            TestCase.assertEquals(""1000"", System.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY));
-        } finally {
-            ConfigUtils.setProperties(null);
-            System.clearProperty(""dubbo.application.name"");
-            System.clearProperty(Constants.SHUTDOWN_WAIT_KEY);
-            System.clearProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);
-        }
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkApplication2() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkApplication();
-    }
-
-    @Test
-    public void testLoadRegistries() throws Exception {
-        System.setProperty(""dubbo.registry.address"", ""addr1"");
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        List<URL> urls = interfaceConfig.loadRegistries(true);
-        TestCase.assertEquals(1, urls.size());
-        URL url = urls.get(0);
-        TestCase.assertEquals(""registry"", url.getProtocol());
-        TestCase.assertEquals(""addr1:9090"", url.getAddress());
-        TestCase.assertEquals(RegistryService.class.getName(), url.getPath());
-        TestCase.assertTrue(url.getParameters().containsKey(""timestamp""));
-        TestCase.assertTrue(url.getParameters().containsKey(""pid""));
-        TestCase.assertTrue(url.getParameters().containsKey(""registry""));
-        TestCase.assertTrue(url.getParameters().containsKey(""dubbo""));
-    }
-
-    @Test
-    public void testLoadMonitor() throws Exception {
-        System.setProperty(""dubbo.monitor.address"", ""monitor-addr:12080"");
-        System.setProperty(""dubbo.monitor.protocol"", ""monitor"");
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        URL url = interfaceConfig.loadMonitor(new URL(""dubbo"", ""addr1"", 9090));
-        TestCase.assertEquals(""monitor-addr:12080"", url.getAddress());
-        TestCase.assertEquals(MonitorService.class.getName(), url.getParameter(""interface""));
-        TestCase.assertNotNull(url.getParameter(""dubbo""));
-        TestCase.assertNotNull(url.getParameter(""pid""));
-        TestCase.assertNotNull(url.getParameter(""timestamp""));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkInterfaceAndMethods1() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(null, null);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkInterfaceAndMethods2() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(AbstractInterfaceConfigTest.class, null);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkInterfaceAndMethod3() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(Greeting.class, Collections.singletonList(methodConfig));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkInterfaceAndMethod4() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setName(""nihao"");
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(Greeting.class, Collections.singletonList(methodConfig));
-    }
-
-    @Test
-    public void checkInterfaceAndMethod5() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setName(""hello"");
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(Greeting.class, Collections.singletonList(methodConfig));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock1() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLocal(GreetingLocal1.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock2() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLocal(GreetingLocal2.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test
-    public void checkStubAndMock3() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLocal(GreetingLocal3.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock4() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setStub(GreetingLocal1.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock5() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setStub(GreetingLocal2.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test
-    public void checkStubAndMock6() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setStub(GreetingLocal3.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock7() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setMock(""return {a, b}"");
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock8() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setMock(GreetingMock1.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock9() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setMock(GreetingMock2.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test
-    public void testLocal() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLocal((Boolean) null);
-        TestCase.assertNull(interfaceConfig.getLocal());
-        interfaceConfig.setLocal(true);
-        TestCase.assertEquals(""true"", interfaceConfig.getLocal());
-        interfaceConfig.setLocal(""GreetingMock"");
-        TestCase.assertEquals(""GreetingMock"", interfaceConfig.getLocal());
-    }
-
-    @Test
-    public void testStub() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setStub((Boolean) null);
-        TestCase.assertNull(interfaceConfig.getStub());
-        interfaceConfig.setStub(true);
-        TestCase.assertEquals(""true"", interfaceConfig.getStub());
-        interfaceConfig.setStub(""GreetingMock"");
-        TestCase.assertEquals(""GreetingMock"", interfaceConfig.getStub());
-    }
-
-    @Test
-    public void testCluster() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setCluster(""mockcluster"");
-        TestCase.assertEquals(""mockcluster"", interfaceConfig.getCluster());
-    }
-
-    @Test
-    public void testProxy() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setProxy(""mockproxyfactory"");
-        TestCase.assertEquals(""mockproxyfactory"", interfaceConfig.getProxy());
-    }
-
-    @Test
-    public void testConnections() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setConnections(1);
-        TestCase.assertEquals(1, interfaceConfig.getConnections().intValue());
-    }
-
-    @Test
-    public void testFilter() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setFilter(""mockfilter"");
-        TestCase.assertEquals(""mockfilter"", interfaceConfig.getFilter());
-    }
-
-    @Test
-    public void testListener() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setListener(""mockinvokerlistener"");
-        TestCase.assertEquals(""mockinvokerlistener"", interfaceConfig.getListener());
-    }
-
-    @Test
-    public void testLayer() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLayer(""layer"");
-        TestCase.assertEquals(""layer"", interfaceConfig.getLayer());
-    }
-
-    @Test
-    public void testApplication() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        ApplicationConfig applicationConfig = new ApplicationConfig();
-        interfaceConfig.setApplication(applicationConfig);
-        TestCase.assertSame(applicationConfig, interfaceConfig.getApplication());
-    }
-
-    @Test
-    public void testModule() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        ModuleConfig moduleConfig = new ModuleConfig();
-        interfaceConfig.setModule(moduleConfig);
-        TestCase.assertSame(moduleConfig, interfaceConfig.getModule());
-    }
-
-    @Test
-    public void testRegistry() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        RegistryConfig registryConfig = new RegistryConfig();
-        interfaceConfig.setRegistry(registryConfig);
-        TestCase.assertSame(registryConfig, interfaceConfig.getRegistry());
-    }
-
-    @Test
-    public void testRegistries() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        RegistryConfig registryConfig = new RegistryConfig();
-        interfaceConfig.setRegistries(Collections.singletonList(registryConfig));
-        TestCase.assertEquals(1, interfaceConfig.getRegistries().size());
-        TestCase.assertSame(registryConfig, interfaceConfig.getRegistries().get(0));
-    }
-
-    @Test
-    public void testMonitor() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setMonitor(""monitor-addr"");
-        TestCase.assertEquals(""monitor-addr"", interfaceConfig.getMonitor().getAddress());
-        MonitorConfig monitorConfig = new MonitorConfig();
-        interfaceConfig.setMonitor(monitorConfig);
-        TestCase.assertSame(monitorConfig, interfaceConfig.getMonitor());
-    }
-
-    @Test
-    public void testOwner() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setOwner(""owner"");
-        TestCase.assertEquals(""owner"", interfaceConfig.getOwner());
-    }
-
-    @Test
-    public void testCallbacks() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setCallbacks(2);
-        TestCase.assertEquals(2, interfaceConfig.getCallbacks().intValue());
-    }
-
-    @Test
-    public void testOnconnect() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setOnconnect(""onConnect"");
-        TestCase.assertEquals(""onConnect"", interfaceConfig.getOnconnect());
-    }
-
-    @Test
-    public void testOndisconnect() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setOndisconnect(""onDisconnect"");
-        TestCase.assertEquals(""onDisconnect"", interfaceConfig.getOndisconnect());
-    }
-
-    @Test
-    public void testScope() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setScope(""scope"");
-        TestCase.assertEquals(""scope"", interfaceConfig.getScope());
-    }
-
-    private void writeDubboProperties(String key, String value) {
-        OutputStream os = null;
-        try {
-            os = new BufferedOutputStream(new FileOutputStream(dubboProperties));
-            Properties properties = new Properties();
-            properties.put(key, value);
-            properties.store(os, """");
-            os.close();
-        } catch (IOException e) {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (IOException ioe) {
-                    // ignore
-                }
-            }
-        }
-    }
-
-    private static class InterfaceConfig extends AbstractInterfaceConfig {
-
-    }
-}
@@ -1,119 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.isEmptyOrNullString;
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertThat;
-
-public class AbstractMethodConfigTest {
-    @Test
-    public void testTimeout() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setTimeout(10);
-        assertThat(methodConfig.getTimeout(), equalTo(10));
-    }
-
-    @Test
-    public void testRetries() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setRetries(3);
-        assertThat(methodConfig.getRetries(), equalTo(3));
-    }
-
-    @Test
-    public void testLoadbalance() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setLoadbalance(""mockloadbalance"");
-        assertThat(methodConfig.getLoadbalance(), equalTo(""mockloadbalance""));
-    }
-
-    @Test
-    public void testAsync() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setAsync(true);
-        assertThat(methodConfig.isAsync(), is(true));
-    }
-
-    @Test
-    public void testActives() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setActives(10);
-        assertThat(methodConfig.getActives(), equalTo(10));
-    }
-
-    @Test
-    public void testSent() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setSent(true);
-        assertThat(methodConfig.getSent(), is(true));
-    }
-
-    @Test
-    public void testMock() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setMock((Boolean) null);
-        assertThat(methodConfig.getMock(), isEmptyOrNullString());
-        methodConfig.setMock(true);
-        assertThat(methodConfig.getMock(), equalTo(""true""));
-        methodConfig.setMock(""return null"");
-        assertThat(methodConfig.getMock(), equalTo(""return null""));
-        methodConfig.setMock(""mock"");
-        assertThat(methodConfig.getMock(), equalTo(""mock""));
-    }
-
-    @Test
-    public void testMerger() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setMerger(""merger"");
-        assertThat(methodConfig.getMerger(), equalTo(""merger""));
-    }
-
-    @Test
-    public void testCache() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setCache(""cache"");
-        assertThat(methodConfig.getCache(), equalTo(""cache""));
-    }
-
-    @Test
-    public void testValidation() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setValidation(""validation"");
-        assertThat(methodConfig.getValidation(), equalTo(""validation""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(""key"", ""value"");
-        methodConfig.setParameters(parameters);
-        assertThat(methodConfig.getParameters(), sameInstance(parameters));
-    }
-
-    private static class MethodConfig extends AbstractMethodConfig {
-
-    }
-}
@@ -1,157 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.hasValue;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class AbstractReferenceConfigTest {
-
-    @Test
-    public void testCheck() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setCheck(true);
-        assertThat(referenceConfig.isCheck(), is(true));
-    }
-
-    @Test
-    public void testInit() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setInit(true);
-        assertThat(referenceConfig.isInit(), is(true));
-    }
-
-    @Test
-    public void testGeneric() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setGeneric(true);
-        assertThat(referenceConfig.isGeneric(), is(true));
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        // FIXME: not sure why AbstractReferenceConfig has both isGeneric and getGeneric
-        assertThat(parameters, hasKey(""generic""));
-    }
-
-    @Test
-    public void testInjvm() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setInit(true);
-        assertThat(referenceConfig.isInit(), is(true));
-    }
-
-    @Test
-    public void testFilter() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setFilter(""mockfilter"");
-        assertThat(referenceConfig.getFilter(), equalTo(""mockfilter""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(Constants.REFERENCE_FILTER_KEY, ""prefilter"");
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(parameters, hasValue(""prefilter,mockfilter""));
-    }
-
-    @Test
-    public void testListener() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setListener(""mockinvokerlistener"");
-        assertThat(referenceConfig.getListener(), equalTo(""mockinvokerlistener""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(Constants.INVOKER_LISTENER_KEY, ""prelistener"");
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(parameters, hasValue(""prelistener,mockinvokerlistener""));
-    }
-
-    @Test
-    public void testLazy() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setLazy(true);
-        assertThat(referenceConfig.getLazy(), is(true));
-    }
-
-    @Test
-    public void testOnconnect() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setOnconnect(""onConnect"");
-        assertThat(referenceConfig.getOnconnect(), equalTo(""onConnect""));
-        assertThat(referenceConfig.getStubevent(), is(true));
-    }
-
-    @Test
-    public void testOndisconnect() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setOndisconnect(""onDisconnect"");
-        assertThat(referenceConfig.getOndisconnect(), equalTo(""onDisconnect""));
-        assertThat(referenceConfig.getStubevent(), is(true));
-    }
-
-    @Test
-    public void testStubevent() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setOnconnect(""onConnect"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(parameters, hasKey(Constants.STUB_EVENT_KEY));
-    }
-
-    @Test
-    public void testReconnect() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setReconnect(""reconnect"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(referenceConfig.getReconnect(), equalTo(""reconnect""));
-        assertThat(parameters, hasKey(Constants.RECONNECT_KEY));
-    }
-
-    @Test
-    public void testSticky() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setSticky(true);
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(referenceConfig.getSticky(), is(true));
-        assertThat(parameters, hasKey(Constants.CLUSTER_STICKY_KEY));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setVersion(""version"");
-        assertThat(referenceConfig.getVersion(), equalTo(""version""));
-    }
-
-    @Test
-    public void testGroup() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setGroup(""group"");
-        assertThat(referenceConfig.getGroup(), equalTo(""group""));
-    }
-
-    private static class ReferenceConfig extends AbstractReferenceConfig {
-
-    }
-}
@@ -1,181 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasSize;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.notNullValue;
-import static org.hamcrest.Matchers.nullValue;
-import static org.junit.Assert.assertThat;
-
-public class AbstractServiceConfigTest {
-    @Test
-    public void testVersion() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setVersion(""version"");
-        assertThat(serviceConfig.getVersion(), equalTo(""version""));
-    }
-
-    @Test
-    public void testGroup() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setGroup(""group"");
-        assertThat(serviceConfig.getGroup(), equalTo(""group""));
-    }
-
-    @Test
-    public void testDelay() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setDelay(1000);
-        assertThat(serviceConfig.getDelay(), equalTo(1000));
-    }
-
-    @Test
-    public void testExport() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setExport(true);
-        assertThat(serviceConfig.getExport(), is(true));
-    }
-
-    @Test
-    public void testWeight() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setWeight(500);
-        assertThat(serviceConfig.getWeight(), equalTo(500));
-    }
-
-    @Test
-    public void testDocument() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setDocument(""http://dubbo.io"");
-        assertThat(serviceConfig.getDocument(), equalTo(""http://dubbo.io""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractServiceConfig.appendParameters(parameters, serviceConfig);
-        assertThat(parameters, hasEntry(""document"", ""http%3A%2F%2Fdubbo.io""));
-    }
-
-    @Test
-    public void testToken() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setToken(""token"");
-        assertThat(serviceConfig.getToken(), equalTo(""token""));
-        serviceConfig.setToken((Boolean) null);
-        assertThat(serviceConfig.getToken(), nullValue());
-        serviceConfig.setToken(true);
-        assertThat(serviceConfig.getToken(), is(""true""));
-    }
-
-    @Test
-    public void testDeprecated() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setDeprecated(true);
-        assertThat(serviceConfig.isDeprecated(), is(true));
-    }
-
-    @Test
-    public void testDynamic() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setDynamic(true);
-        assertThat(serviceConfig.isDynamic(), is(true));
-    }
-
-    @Test
-    public void testProtocol() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        assertThat(serviceConfig.getProtocol(), nullValue());
-        serviceConfig.setProtocol(new ProtocolConfig());
-        assertThat(serviceConfig.getProtocol(), notNullValue());
-        serviceConfig.setProtocols(Collections.singletonList(new ProtocolConfig()));
-        assertThat(serviceConfig.getProtocols(), hasSize(1));
-    }
-
-    @Test
-    public void testAccesslog() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setAccesslog(""access.log"");
-        assertThat(serviceConfig.getAccesslog(), equalTo(""access.log""));
-        serviceConfig.setAccesslog((Boolean) null);
-        assertThat(serviceConfig.getAccesslog(), nullValue());
-        serviceConfig.setAccesslog(true);
-        assertThat(serviceConfig.getAccesslog(), equalTo(""true""));
-    }
-
-    @Test
-    public void testExecutes() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setExecutes(10);
-        assertThat(serviceConfig.getExecutes(), equalTo(10));
-    }
-
-    @Test
-    public void testFilter() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setFilter(""mockfilter"");
-        assertThat(serviceConfig.getFilter(), equalTo(""mockfilter""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(Constants.SERVICE_FILTER_KEY, ""prefilter"");
-        AbstractServiceConfig.appendParameters(parameters, serviceConfig);
-        assertThat(parameters, hasEntry(Constants.SERVICE_FILTER_KEY, ""prefilter,mockfilter""));
-    }
-
-    @Test
-    public void testListener() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setListener(""mockexporterlistener"");
-        assertThat(serviceConfig.getListener(), equalTo(""mockexporterlistener""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(Constants.EXPORTER_LISTENER_KEY, ""prelistener"");
-        AbstractServiceConfig.appendParameters(parameters, serviceConfig);
-        assertThat(parameters, hasEntry(Constants.EXPORTER_LISTENER_KEY, ""prelistener,mockexporterlistener""));
-    }
-
-    @Test
-    public void testRegister() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setRegister(true);
-        assertThat(serviceConfig.isRegister(), is(true));
-    }
-
-    @Test
-    public void testWarmup() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setWarmup(100);
-        assertThat(serviceConfig.getWarmup(), equalTo(100));
-    }
-
-    @Test
-    public void testSerialization() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setSerialization(""serialization"");
-        assertThat(serviceConfig.getSerialization(), equalTo(""serialization""));
-    }
-
-
-    private static class ServiceConfig extends AbstractServiceConfig {
-
-    }
-}
@@ -1,177 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.sameInstance;
-import static org.hamcrest.collection.IsCollectionWithSize.hasSize;
-import static org.junit.Assert.assertThat;
-
-public class ApplicationConfigTest {
-    @Test
-    public void testName() throws Exception {
-        ApplicationConfig application = new ApplicationConfig();
-        application.setName(""app"");
-        assertThat(application.getName(), equalTo(""app""));
-        application = new ApplicationConfig(""app2"");
-        assertThat(application.getName(), equalTo(""app2""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(Constants.APPLICATION_KEY, ""app2""));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setVersion(""1.0.0"");
-        assertThat(application.getVersion(), equalTo(""1.0.0""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(""application.version"", ""1.0.0""));
-    }
-
-    @Test
-    public void testOwner() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setOwner(""owner"");
-        assertThat(application.getOwner(), equalTo(""owner""));
-    }
-
-    @Test
-    public void testOrganization() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setOrganization(""org"");
-        assertThat(application.getOrganization(), equalTo(""org""));
-    }
-
-    @Test
-    public void testArchitecture() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setArchitecture(""arch"");
-        assertThat(application.getArchitecture(), equalTo(""arch""));
-    }
-
-    @Test
-    public void testEnvironment1() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setEnvironment(""develop"");
-        assertThat(application.getEnvironment(), equalTo(""develop""));
-        application.setEnvironment(""test"");
-        assertThat(application.getEnvironment(), equalTo(""test""));
-        application.setEnvironment(""product"");
-        assertThat(application.getEnvironment(), equalTo(""product""));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testEnvironment2() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setEnvironment(""illegal-env"");
-    }
-
-    @Test
-    public void testRegistry() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        RegistryConfig registry = new RegistryConfig();
-        application.setRegistry(registry);
-        assertThat(application.getRegistry(), sameInstance(registry));
-        application.setRegistries(Collections.singletonList(registry));
-        assertThat(application.getRegistries(), contains(registry));
-        assertThat(application.getRegistries(), hasSize(1));
-    }
-
-    @Test
-    public void testMonitor() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setMonitor(new MonitorConfig(""monitor-addr""));
-        assertThat(application.getMonitor().getAddress(), equalTo(""monitor-addr""));
-        application.setMonitor(""monitor-addr"");
-        assertThat(application.getMonitor().getAddress(), equalTo(""monitor-addr""));
-    }
-
-    @Test
-    public void testLogger() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setLogger(""log4j"");
-        assertThat(application.getLogger(), equalTo(""log4j""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setDefault(true);
-        assertThat(application.isDefault(), is(true));
-    }
-
-    @Test
-    public void testDumpDirectory() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setDumpDirectory(""/dump"");
-        assertThat(application.getDumpDirectory(), equalTo(""/dump""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(Constants.DUMP_DIRECTORY, ""/dump""));
-    }
-
-    @Test
-    public void testQosEnable() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setQosEnable(true);
-        assertThat(application.getQosEnable(), is(true));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(Constants.QOS_ENABLE, ""true""));
-    }
-
-    @Test
-    public void testQosPort() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setQosPort(8080);
-        assertThat(application.getQosPort(), equalTo(8080));
-    }
-
-    @Test
-    public void testQosAcceptForeignIp() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setQosAcceptForeignIp(true);
-        assertThat(application.getQosAcceptForeignIp(), is(true));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(Constants.ACCEPT_FOREIGN_IP, ""true""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setQosAcceptForeignIp(true);
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(""k1"", ""v1"");
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(""k1"", ""v1""));
-        assertThat(parameters, hasEntry(Constants.ACCEPT_FOREIGN_IP, ""true""));
-    }
-}
@@ -1,63 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class ArgumentConfigTest {
-    @Test
-    public void testIndex() throws Exception {
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setIndex(1);
-        assertThat(argument.getIndex(), is(1));
-    }
-
-    @Test
-    public void testType() throws Exception {
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setType(""int"");
-        assertThat(argument.getType(), equalTo(""int""));
-    }
-
-    @Test
-    public void testCallback() throws Exception {
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setCallback(true);
-        assertThat(argument.isCallback(), is(true));
-    }
-
-    @Test
-    public void testArguments() throws Exception {
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setIndex(1);
-        argument.setType(""int"");
-        argument.setCallback(true);
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractServiceConfig.appendParameters(parameters, argument);
-        assertThat(parameters, hasEntry(""callback"", ""true""));
-        assertThat(parameters.size(), is(1));
-    }
-}
@@ -1,81 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class ConsumerConfigTest {
-    @Test
-    public void testTimeout() throws Exception {
-        try {
-            System.clearProperty(""sun.rmi.transport.tcp.responseTimeout"");
-            ConsumerConfig consumer = new ConsumerConfig();
-            consumer.setTimeout(10);
-            assertThat(consumer.getTimeout(), is(10));
-            assertThat(System.getProperty(""sun.rmi.transport.tcp.responseTimeout""), equalTo(""10""));
-        } finally {
-            System.clearProperty(""sun.rmi.transport.tcp.responseTimeout"");
-        }
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setDefault(true);
-        assertThat(consumer.isDefault(), is(true));
-    }
-
-    @Test
-    public void testClient() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setClient(""client"");
-        assertThat(consumer.getClient(), equalTo(""client""));
-    }
-
-    @Test
-    public void testThreadpool() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setThreadpool(""fixed"");
-        assertThat(consumer.getThreadpool(), equalTo(""fixed""));
-    }
-
-    @Test
-    public void testCorethreads() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setCorethreads(10);
-        assertThat(consumer.getCorethreads(), equalTo(10));
-    }
-
-    @Test
-    public void testThreads() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setThreads(20);
-        assertThat(consumer.getThreads(), equalTo(20));
-    }
-
-    @Test
-    public void testQueues() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setQueues(5);
-        assertThat(consumer.getQueues(), equalTo(5));
-    }
-}
@@ -1,315 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.beanutil.JavaBeanAccessor;
-import org.apache.dubbo.common.beanutil.JavaBeanDescriptor;
-import org.apache.dubbo.common.beanutil.JavaBeanSerializeUtil;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.common.serialize.Serialization;
-import org.apache.dubbo.common.utils.ReflectUtils;
-import org.apache.dubbo.config.api.DemoException;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.api.User;
-import org.apache.dubbo.config.provider.impl.DemoServiceImpl;
-import org.apache.dubbo.rpc.service.GenericException;
-import org.apache.dubbo.rpc.service.GenericService;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * GenericServiceTest
- */
-public class GenericServiceTest {
-
-    @Test
-    public void testGenericServiceException() {
-        ServiceConfig<GenericService> service = new ServiceConfig<GenericService>();
-        service.setApplication(new ApplicationConfig(""generic-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.setInterface(DemoService.class.getName());
-        service.setRef(new GenericService() {
-
-            public Object $invoke(String method, String[] parameterTypes, Object[] args)
-                    throws GenericException {
-                if (""sayName"".equals(method)) {
-                    return ""Generic "" + args[0];
-                }
-                if (""throwDemoException"".equals(method)) {
-                    throw new GenericException(DemoException.class.getName(), ""Generic"");
-                }
-                if (""getUsers"".equals(method)) {
-                    return args[0];
-                }
-                return null;
-            }
-        });
-        service.export();
-        try {
-            ReferenceConfig<DemoService> reference = new ReferenceConfig<DemoService>();
-            reference.setApplication(new ApplicationConfig(""generic-consumer""));
-            reference.setInterface(DemoService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29581?generic=true&timeout=3000"");
-            DemoService demoService = reference.get();
-            try {
-                // say name
-                Assert.assertEquals(""Generic Haha"", demoService.sayName(""Haha""));
-                // get users
-                List<User> users = new ArrayList<User>();
-                users.add(new User(""Aaa""));
-                users = demoService.getUsers(users);
-                Assert.assertEquals(""Aaa"", users.get(0).getName());
-                // throw demo exception
-                try {
-                    demoService.throwDemoException();
-                    Assert.fail();
-                } catch (DemoException e) {
-                    Assert.assertEquals(""Generic"", e.getMessage());
-                }
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @SuppressWarnings(""unchecked"")
-    @Test
-    public void testGenericReferenceException() {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setApplication(new ApplicationConfig(""generic-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.setInterface(DemoService.class.getName());
-        service.setRef(new DemoServiceImpl());
-        service.export();
-        try {
-            ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();
-            reference.setApplication(new ApplicationConfig(""generic-consumer""));
-            reference.setInterface(DemoService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29581?scope=remote&timeout=3000"");
-            reference.setGeneric(true);
-            GenericService genericService = reference.get();
-            try {
-                List<Map<String, Object>> users = new ArrayList<Map<String, Object>>();
-                Map<String, Object> user = new HashMap<String, Object>();
-                user.put(""class"", ""org.apache.dubbo.config.api.User"");
-                user.put(""name"", ""actual.provider"");
-                users.add(user);
-                users = (List<Map<String, Object>>) genericService.$invoke(""getUsers"", new String[]{List.class.getName()}, new Object[]{users});
-                Assert.assertEquals(1, users.size());
-                Assert.assertEquals(""actual.provider"", users.get(0).get(""name""));
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testGenericSerializationJava() throws Exception {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setApplication(new ApplicationConfig(""generic-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.setInterface(DemoService.class.getName());
-        DemoServiceImpl ref = new DemoServiceImpl();
-        service.setRef(ref);
-        service.export();
-        try {
-            ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();
-            reference.setApplication(new ApplicationConfig(""generic-consumer""));
-            reference.setInterface(DemoService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29581?scope=remote&timeout=3000"");
-            reference.setGeneric(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA);
-            GenericService genericService = reference.get();
-            try {
-                String name = ""kimi"";
-                ByteArrayOutputStream bos = new ByteArrayOutputStream(512);
-                ExtensionLoader.getExtensionLoader(Serialization.class)
-                        .getExtension(""nativejava"").serialize(null, bos).writeObject(name);
-                byte[] arg = bos.toByteArray();
-                Object obj = genericService.$invoke(""sayName"", new String[]{String.class.getName()}, new Object[]{arg});
-                Assert.assertTrue(obj instanceof byte[]);
-                byte[] result = (byte[]) obj;
-                Assert.assertEquals(ref.sayName(name), ExtensionLoader.getExtensionLoader(Serialization.class)
-                        .getExtension(""nativejava"").deserialize(null, new ByteArrayInputStream(result)).readObject().toString());
-
-                // getUsers
-                List<User> users = new ArrayList<User>();
-                User user = new User();
-                user.setName(name);
-                users.add(user);
-                bos = new ByteArrayOutputStream(512);
-                ExtensionLoader.getExtensionLoader(Serialization.class)
-                        .getExtension(""nativejava"").serialize(null, bos).writeObject(users);
-                obj = genericService.$invoke(""getUsers"",
-                        new String[]{List.class.getName()},
-                        new Object[]{bos.toByteArray()});
-                Assert.assertTrue(obj instanceof byte[]);
-                result = (byte[]) obj;
-                Assert.assertEquals(users,
-                        ExtensionLoader.getExtensionLoader(Serialization.class)
-                                .getExtension(""nativejava"")
-                                .deserialize(null, new ByteArrayInputStream(result))
-                                .readObject());
-
-                // echo(int)
-                bos = new ByteArrayOutputStream(512);
-                ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(""nativejava"")
-                        .serialize(null, bos).writeObject(Integer.MAX_VALUE);
-                obj = genericService.$invoke(""echo"", new String[]{int.class.getName()}, new Object[]{bos.toByteArray()});
-                Assert.assertTrue(obj instanceof byte[]);
-                Assert.assertEquals(Integer.MAX_VALUE,
-                        ExtensionLoader.getExtensionLoader(Serialization.class)
-                                .getExtension(""nativejava"")
-                                .deserialize(null, new ByteArrayInputStream((byte[]) obj))
-                                .readObject());
-
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testGenericInvokeWithBeanSerialization() throws Exception {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setApplication(new ApplicationConfig(""bean-provider""));
-        service.setInterface(DemoService.class);
-        service.setRegistry(new RegistryConfig(""N/A""));
-        DemoServiceImpl impl = new DemoServiceImpl();
-        service.setRef(impl);
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.export();
-        ReferenceConfig<GenericService> reference = null;
-        try {
-            reference = new ReferenceConfig<GenericService>();
-            reference.setApplication(new ApplicationConfig(""bean-consumer""));
-            reference.setInterface(DemoService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29581?scope=remote&timeout=3000"");
-            reference.setGeneric(Constants.GENERIC_SERIALIZATION_BEAN);
-            GenericService genericService = reference.get();
-            User user = new User();
-            user.setName(""zhangsan"");
-            List<User> users = new ArrayList<User>();
-            users.add(user);
-            Object result = genericService.$invoke(""getUsers"", new String[]{ReflectUtils.getName(List.class)}, new Object[]{JavaBeanSerializeUtil.serialize(users, JavaBeanAccessor.METHOD)});
-            Assert.assertTrue(result instanceof JavaBeanDescriptor);
-            JavaBeanDescriptor descriptor = (JavaBeanDescriptor) result;
-            Assert.assertTrue(descriptor.isCollectionType());
-            Assert.assertEquals(1, descriptor.propertySize());
-            descriptor = (JavaBeanDescriptor) descriptor.getProperty(0);
-            Assert.assertTrue(descriptor.isBeanType());
-            Assert.assertEquals(user.getName(), ((JavaBeanDescriptor) descriptor.getProperty(""name"")).getPrimitiveProperty());
-        } finally {
-            if (reference != null) {
-                reference.destroy();
-            }
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testGenericImplementationWithBeanSerialization() throws Exception {
-        final AtomicReference reference = new AtomicReference();
-        ServiceConfig<GenericService> service = new ServiceConfig<GenericService>();
-        service.setApplication(new ApplicationConfig(""bean-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.setInterface(DemoService.class.getName());
-        service.setRef(new GenericService() {
-
-            public Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException {
-                if (""getUsers"".equals(method)) {
-                    GenericParameter arg = new GenericParameter();
-                    arg.method = method;
-                    arg.parameterTypes = parameterTypes;
-                    arg.arguments = args;
-                    reference.set(arg);
-                    return args[0];
-                }
-                if (""sayName"".equals(method)) {
-                    return null;
-                }
-                return args;
-            }
-        });
-        service.export();
-        ReferenceConfig<DemoService> ref = null;
-        try {
-            ref = new ReferenceConfig<DemoService>();
-            ref.setApplication(new ApplicationConfig(""bean-consumer""));
-            ref.setInterface(DemoService.class);
-            ref.setUrl(""dubbo://127.0.0.1:29581?scope=remote&generic=bean&timeout=3000"");
-            DemoService demoService = ref.get();
-            User user = new User();
-            user.setName(""zhangsan"");
-            List<User> users = new ArrayList<User>();
-            users.add(user);
-            List<User> result = demoService.getUsers(users);
-            Assert.assertEquals(users.size(), result.size());
-            Assert.assertEquals(user.getName(), result.get(0).getName());
-
-            GenericParameter gp = (GenericParameter) reference.get();
-            Assert.assertEquals(""getUsers"", gp.method);
-            Assert.assertEquals(1, gp.parameterTypes.length);
-            Assert.assertEquals(ReflectUtils.getName(List.class), gp.parameterTypes[0]);
-            Assert.assertEquals(1, gp.arguments.length);
-            Assert.assertTrue(gp.arguments[0] instanceof JavaBeanDescriptor);
-            JavaBeanDescriptor descriptor = (JavaBeanDescriptor) gp.arguments[0];
-            Assert.assertTrue(descriptor.isCollectionType());
-            Assert.assertEquals(ArrayList.class.getName(), descriptor.getClassName());
-            Assert.assertEquals(1, descriptor.propertySize());
-            descriptor = (JavaBeanDescriptor) descriptor.getProperty(0);
-            Assert.assertTrue(descriptor.isBeanType());
-            Assert.assertEquals(User.class.getName(), descriptor.getClassName());
-            Assert.assertEquals(user.getName(), ((JavaBeanDescriptor) descriptor.getProperty(""name"")).getPrimitiveProperty());
-            Assert.assertNull(demoService.sayName(""zhangsan""));
-        } finally {
-            if (ref != null) {
-                ref.destroy();
-            }
-            service.unexport();
-        }
-    }
-
-    protected static class GenericParameter {
-
-        String method;
-
-        String[] parameterTypes;
-
-        Object[] arguments;
-    }
-
-}
@@ -1,182 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.hamcrest.Matchers;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
-
-public class MethodConfigTest {
-    @Test
-    public void testName() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setName(""hello"");
-        assertThat(method.getName(), equalTo(""hello""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters, not(hasKey(""name"")));
-    }
-
-    @Test
-    public void testStat() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setStat(10);
-        assertThat(method.getStat(), equalTo(10));
-    }
-
-    @Test
-    public void testRetry() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setRetry(true);
-        assertThat(method.isRetry(), is(true));
-    }
-
-    @Test
-    public void testReliable() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setReliable(true);
-        assertThat(method.isReliable(), is(true));
-    }
-
-    @Test
-    public void testExecutes() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setExecutes(10);
-        assertThat(method.getExecutes(), equalTo(10));
-    }
-
-    @Test
-    public void testDeprecated() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setDeprecated(true);
-        assertThat(method.getDeprecated(), is(true));
-    }
-
-    @Test
-    public void testArguments() throws Exception {
-        MethodConfig method = new MethodConfig();
-        ArgumentConfig argument = new ArgumentConfig();
-        method.setArguments(Collections.singletonList(argument));
-        assertThat(method.getArguments(), contains(argument));
-        assertThat(method.getArguments(), Matchers.<ArgumentConfig>hasSize(1));
-    }
-
-    @Test
-    public void testSticky() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setSticky(true);
-        assertThat(method.getSticky(), is(true));
-    }
-
-    @Test
-    public void testOnreturn() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOnreturn(""on-return-object"");
-        assertThat(method.getOnreturn(), equalTo((Object) ""on-return-object""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_RETURN_INSTANCE_KEY, (Object) ""on-return-object""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOnreturnMethod() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOnreturnMethod(""on-return-method"");
-        assertThat(method.getOnreturnMethod(), equalTo(""on-return-method""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_RETURN_METHOD_KEY, (Object) ""on-return-method""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOnthrow() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOnthrow(""on-throw-object"");
-        assertThat(method.getOnthrow(), equalTo((Object) ""on-throw-object""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_THROW_INSTANCE_KEY, (Object) ""on-throw-object""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOnthrowMethod() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOnthrowMethod(""on-throw-method"");
-        assertThat(method.getOnthrowMethod(), equalTo(""on-throw-method""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_THROW_METHOD_KEY, (Object) ""on-throw-method""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOninvoke() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOninvoke(""on-invoke-object"");
-        assertThat(method.getOninvoke(), equalTo((Object) ""on-invoke-object""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_INVOKE_INSTANCE_KEY, (Object) ""on-invoke-object""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOninvokeMethod() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOninvokeMethod(""on-invoke-method"");
-        assertThat(method.getOninvokeMethod(), equalTo(""on-invoke-method""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_INVOKE_METHOD_KEY, (Object) ""on-invoke-method""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testReturn() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setReturn(true);
-        assertThat(method.isReturn(), is(true));
-    }
-}
@@ -1,110 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.hamcrest.Matchers;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertThat;
-
-public class ModuleConfigTest {
-    @Test(expected = IllegalStateException.class)
-    public void testName1() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        Map<String, String> parameters = new HashMap<String, String>();
-        ModuleConfig.appendParameters(parameters, module);
-    }
-
-    @Test
-    public void testName2() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setName(""module-name"");
-        assertThat(module.getName(), equalTo(""module-name""));
-        assertThat(module.getId(), equalTo(""module-name""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ModuleConfig.appendParameters(parameters, module);
-        assertThat(parameters, hasEntry(""module"", ""module-name""));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setName(""module-name"");
-        module.setVersion(""1.0.0"");
-        assertThat(module.getVersion(), equalTo(""1.0.0""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ModuleConfig.appendParameters(parameters, module);
-        assertThat(parameters, hasEntry(""module.version"", ""1.0.0""));
-    }
-
-    @Test
-    public void testOwner() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setOwner(""owner"");
-        assertThat(module.getOwner(), equalTo(""owner""));
-    }
-
-    @Test
-    public void testOrganization() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setOrganization(""org"");
-        assertThat(module.getOrganization(), equalTo(""org""));
-    }
-
-    @Test
-    public void testRegistry() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        RegistryConfig registry = new RegistryConfig();
-        module.setRegistry(registry);
-        assertThat(module.getRegistry(), sameInstance(registry));
-    }
-
-    @Test
-    public void testRegistries() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        RegistryConfig registry = new RegistryConfig();
-        module.setRegistries(Collections.singletonList(registry));
-        assertThat(module.getRegistries(), Matchers.<RegistryConfig>hasSize(1));
-        assertThat(module.getRegistries(), contains(registry));
-    }
-
-    @Test
-    public void testMonitor() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setMonitor(""monitor-addr1"");
-        assertThat(module.getMonitor().getAddress(), equalTo(""monitor-addr1""));
-        module.setMonitor(new MonitorConfig(""monitor-addr2""));
-        assertThat(module.getMonitor().getAddress(), equalTo(""monitor-addr2""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setDefault(true);
-        assertThat(module.isDefault(), is(true));
-    }
-}
@@ -1,107 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class MonitorConfigTest {
-    @Test
-    public void testAddress() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setAddress(""monitor-addr"");
-        assertThat(monitor.getAddress(), equalTo(""monitor-addr""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MonitorConfig.appendParameters(parameters, monitor);
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testProtocol() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setProtocol(""protocol"");
-        assertThat(monitor.getProtocol(), equalTo(""protocol""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MonitorConfig.appendParameters(parameters, monitor);
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testUsername() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setUsername(""user"");
-        assertThat(monitor.getUsername(), equalTo(""user""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MonitorConfig.appendParameters(parameters, monitor);
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testPassword() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setPassword(""secret"");
-        assertThat(monitor.getPassword(), equalTo(""secret""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MonitorConfig.appendParameters(parameters, monitor);
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testGroup() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setGroup(""group"");
-        assertThat(monitor.getGroup(), equalTo(""group""));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setVersion(""1.0.0"");
-        assertThat(monitor.getVersion(), equalTo(""1.0.0""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        Map<String, String> parameters = Collections.singletonMap(""k1"", ""v1"");
-        monitor.setParameters(parameters);
-        assertThat(monitor.getParameters(), hasEntry(""k1"", ""v1""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setDefault(true);
-        assertThat(monitor.isDefault(), is(true));
-    }
-
-    @Test
-    public void testInterval() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setInterval(""100"");
-        assertThat(monitor.getInterval(), equalTo(""100""));
-    }
-}
@@ -1,217 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.config.mock.MockProtocol2;
-import org.apache.dubbo.rpc.Protocol;
-import org.junit.Test;
-import org.mockito.Mockito;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class ProtocolConfigTest {
-
-    @Test
-    public void testDestroy() throws Exception {
-        Protocol protocol = Mockito.mock(Protocol.class);
-        MockProtocol2.delegate = protocol;
-        ProtocolConfig protocolConfig = new ProtocolConfig();
-        protocolConfig.setName(""mockprotocol2"");
-        protocolConfig.destroy();
-        Mockito.verify(protocol).destroy();
-    }
-
-    @Test
-    public void testName() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(""name"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProtocolConfig.appendParameters(parameters, protocol);
-        assertThat(protocol.getName(), equalTo(""name""));
-        assertThat(protocol.getId(), equalTo(""name""));
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testHost() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setHost(""host"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProtocolConfig.appendParameters(parameters, protocol);
-        assertThat(protocol.getHost(), equalTo(""host""));
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testPort() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setPort(8080);
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProtocolConfig.appendParameters(parameters, protocol);
-        assertThat(protocol.getPort(), equalTo(8080));
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testPath() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setContextpath(""context-path"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProtocolConfig.appendParameters(parameters, protocol);
-        assertThat(protocol.getPath(), equalTo(""context-path""));
-        assertThat(protocol.getContextpath(), equalTo(""context-path""));
-        assertThat(parameters.isEmpty(), is(true));
-        protocol.setPath(""path"");
-        assertThat(protocol.getPath(), equalTo(""path""));
-        assertThat(protocol.getContextpath(), equalTo(""path""));
-    }
-
-    @Test
-    public void testCorethreads() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setCorethreads(10);
-        assertThat(protocol.getCorethreads(), is(10));
-    }
-
-    @Test
-    public void testThreads() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setThreads(10);
-        assertThat(protocol.getThreads(), is(10));
-    }
-
-    @Test
-    public void testIothreads() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setIothreads(10);
-        assertThat(protocol.getIothreads(), is(10));
-    }
-
-    @Test
-    public void testQueues() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setQueues(10);
-        assertThat(protocol.getQueues(), is(10));
-    }
-
-    @Test
-    public void testAccepts() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setAccepts(10);
-        assertThat(protocol.getAccepts(), is(10));
-    }
-
-    @Test
-    public void testCodec() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(""dubbo"");
-        protocol.setCodec(""mockcodec"");
-        assertThat(protocol.getCodec(), equalTo(""mockcodec""));
-    }
-
-    @Test
-    public void testAccesslog() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setAccesslog(""access.log"");
-        assertThat(protocol.getAccesslog(), equalTo(""access.log""));
-    }
-
-    @Test
-    public void testTelnet() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setTelnet(""mocktelnethandler"");
-        assertThat(protocol.getTelnet(), equalTo(""mocktelnethandler""));
-    }
-
-    @Test
-    public void testRegister() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setRegister(true);
-        assertThat(protocol.isRegister(), is(true));
-    }
-
-    @Test
-    public void testTransporter() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setTransporter(""mocktransporter"");
-        assertThat(protocol.getTransporter(), equalTo(""mocktransporter""));
-    }
-
-    @Test
-    public void testExchanger() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setExchanger(""mockexchanger"");
-        assertThat(protocol.getExchanger(), equalTo(""mockexchanger""));
-    }
-
-    @Test
-    public void testDispatcher() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setDispatcher(""mockdispatcher"");
-        assertThat(protocol.getDispatcher(), equalTo(""mockdispatcher""));
-    }
-
-    @Test
-    public void testNetworker() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setNetworker(""networker"");
-        assertThat(protocol.getNetworker(), equalTo(""networker""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setParameters(Collections.singletonMap(""k1"", ""v1""));
-        assertThat(protocol.getParameters(), hasEntry(""k1"", ""v1""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setDefault(true);
-        assertThat(protocol.isDefault(), is(true));
-    }
-
-    @Test
-    public void testKeepAlive() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setKeepAlive(true);
-        assertThat(protocol.getKeepAlive(), is(true));
-    }
-
-    @Test
-    public void testOptimizer() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setOptimizer(""optimizer"");
-        assertThat(protocol.getOptimizer(), equalTo(""optimizer""));
-    }
-
-    @Test
-    public void testExtension() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setExtension(""extension"");
-        assertThat(protocol.getExtension(), equalTo(""extension""));
-    }
-}
@@ -1,219 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
-
-public class ProviderConfigTest {
-    @Test
-    public void testProtocol() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setProtocol(""protocol"");
-        assertThat(provider.getProtocol().getName(), equalTo(""protocol""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setDefault(true);
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.isDefault(), is(true));
-        assertThat(parameters, not(hasKey(""default"")));
-    }
-
-    @Test
-    public void testHost() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setHost(""demo-host"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getHost(), equalTo(""demo-host""));
-        assertThat(parameters, not(hasKey(""host"")));
-    }
-
-    @Test
-    public void testPort() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setPort(8080);
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getPort(), is(8080));
-        assertThat(parameters, not(hasKey(""port"")));
-    }
-
-    @Test
-    public void testPath() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setPath(""/path"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getPath(), equalTo(""/path""));
-        assertThat(provider.getContextpath(), equalTo(""/path""));
-        assertThat(parameters, not(hasKey(""path"")));
-    }
-
-    @Test
-    public void testContextPath() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setContextpath(""/context-path"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getContextpath(), equalTo(""/context-path""));
-        assertThat(parameters, not(hasKey(""/context-path"")));
-    }
-
-    @Test
-    public void testThreadpool() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setThreadpool(""mockthreadpool"");
-        assertThat(provider.getThreadpool(), equalTo(""mockthreadpool""));
-    }
-
-    @Test
-    public void testThreads() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setThreads(10);
-        assertThat(provider.getThreads(), is(10));
-    }
-
-    @Test
-    public void testIothreads() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setIothreads(10);
-        assertThat(provider.getIothreads(), is(10));
-    }
-
-    @Test
-    public void testQueues() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setQueues(10);
-        assertThat(provider.getQueues(), is(10));
-    }
-
-    @Test
-    public void testAccepts() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setAccepts(10);
-        assertThat(provider.getAccepts(), is(10));
-    }
-
-    @Test
-    public void testCharset() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setCharset(""utf-8"");
-        assertThat(provider.getCharset(), equalTo(""utf-8""));
-    }
-
-    @Test
-    public void testPayload() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setPayload(10);
-        assertThat(provider.getPayload(), is(10));
-    }
-
-    @Test
-    public void testBuffer() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setBuffer(10);
-        assertThat(provider.getBuffer(), is(10));
-    }
-
-    @Test
-    public void testServer() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setServer(""demo-server"");
-        assertThat(provider.getServer(), equalTo(""demo-server""));
-    }
-
-    @Test
-    public void testClient() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setClient(""client"");
-        assertThat(provider.getClient(), equalTo(""client""));
-    }
-
-    @Test
-    public void testTelnet() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setTelnet(""mocktelnethandler"");
-        assertThat(provider.getTelnet(), equalTo(""mocktelnethandler""));
-    }
-
-    @Test
-    public void testPrompt() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setPrompt(""#"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getPrompt(), equalTo(""#""));
-        assertThat(parameters, hasEntry(""prompt"", ""%23""));
-    }
-
-    @Test
-    public void testStatus() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setStatus(""mockstatuschecker"");
-        assertThat(provider.getStatus(), equalTo(""mockstatuschecker""));
-    }
-
-    @Test
-    public void testTransporter() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setTransporter(""mocktransporter"");
-        assertThat(provider.getTransporter(), equalTo(""mocktransporter""));
-    }
-
-    @Test
-    public void testExchanger() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setExchanger(""mockexchanger"");
-        assertThat(provider.getExchanger(), equalTo(""mockexchanger""));
-    }
-
-    @Test
-    public void testDispatcher() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setDispatcher(""mockdispatcher"");
-        assertThat(provider.getDispatcher(), equalTo(""mockdispatcher""));
-    }
-
-    @Test
-    public void testNetworker() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setNetworker(""networker"");
-        assertThat(provider.getNetworker(), equalTo(""networker""));
-    }
-
-    @Test
-    public void testWait() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setWait(10);
-        assertThat(provider.getWait(), equalTo(10));
-    }
-}
@@ -1,108 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.provider.impl.DemoServiceImpl;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-public class ReferenceConfigTest {
-
-    @Test
-    public void testInjvm() throws Exception {
-        ApplicationConfig application = new ApplicationConfig();
-        application.setName(""test-protocol-random-port"");
-
-        RegistryConfig registry = new RegistryConfig();
-        registry.setAddress(""multicast://224.5.6.7:1234"");
-
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(""dubbo"");
-
-        ServiceConfig<DemoService> demoService;
-        demoService = new ServiceConfig<DemoService>();
-        demoService.setInterface(DemoService.class);
-        demoService.setRef(new DemoServiceImpl());
-        demoService.setApplication(application);
-        demoService.setRegistry(registry);
-        demoService.setProtocol(protocol);
-
-        ReferenceConfig<DemoService> rc = new ReferenceConfig<DemoService>();
-        rc.setApplication(application);
-        rc.setRegistry(registry);
-        rc.setInterface(DemoService.class.getName());
-        rc.setInjvm(false);
-
-        try {
-            demoService.export();
-            rc.get();
-            Assert.assertTrue(!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(
-                    rc.getInvoker().getUrl().getProtocol()));
-        } finally {
-            demoService.unexport();
-        }
-    }
-    /**
-     * unit test for dubbo-1765
-     */
-    @Test
-    public void testReferenceRetry() {
-        ApplicationConfig application = new ApplicationConfig();
-        application.setName(""test-reference-retry"");
-        RegistryConfig registry = new RegistryConfig();
-        registry.setAddress(""multicast://224.5.6.7:1234"");
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(""dubbo"");
-
-        ReferenceConfig<DemoService> rc = new ReferenceConfig<DemoService>();
-        rc.setApplication(application);
-        rc.setRegistry(registry);
-        rc.setInterface(DemoService.class.getName());
-
-        boolean success = false;
-        DemoService demoService = null;
-        try {
-            demoService = rc.get();
-            success = true;
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        Assert.assertFalse(success);
-        Assert.assertNull(demoService);
-
-        ServiceConfig<DemoService> sc = new ServiceConfig<DemoService>();
-        sc.setInterface(DemoService.class);
-        sc.setRef(new DemoServiceImpl());
-        sc.setApplication(application);
-        sc.setRegistry(registry);
-        sc.setProtocol(protocol);
-
-        try {
-            sc.export();
-            demoService = rc.get();
-            success = true;
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        Assert.assertTrue(success);
-        Assert.assertNotNull(demoService);
-
-    }
-}
\ No newline at end of file
@@ -1,178 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
-
-public class RegistryConfigTest {
-    @Test
-    public void testProtocol() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setProtocol(""protocol"");
-        assertThat(registry.getProtocol(), equalTo(registry.getProtocol()));
-    }
-
-    @Test
-    public void testAddress() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setAddress(""localhost"");
-        assertThat(registry.getAddress(), equalTo(""localhost""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        RegistryConfig.appendParameters(parameters, registry);
-        assertThat(parameters, not(hasKey(""address"")));
-    }
-
-    @Test
-    public void testUsername() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setUsername(""username"");
-        assertThat(registry.getUsername(), equalTo(""username""));
-    }
-
-    @Test
-    public void testPassword() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setPassword(""password"");
-        assertThat(registry.getPassword(), equalTo(""password""));
-    }
-
-    @Test
-    public void testWait() throws Exception {
-        try {
-            RegistryConfig registry = new RegistryConfig();
-            registry.setWait(10);
-            assertThat(registry.getWait(), is(10));
-            assertThat(System.getProperty(Constants.SHUTDOWN_WAIT_KEY), equalTo(""10""));
-        } finally {
-            System.clearProperty(Constants.SHUTDOWN_TIMEOUT_KEY);
-        }
-    }
-
-    @Test
-    public void testCheck() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setCheck(true);
-        assertThat(registry.isCheck(), is(true));
-    }
-
-    @Test
-    public void testFile() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setFile(""file"");
-        assertThat(registry.getFile(), equalTo(""file""));
-    }
-
-    @Test
-    public void testTransporter() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setTransporter(""transporter"");
-        assertThat(registry.getTransporter(), equalTo(""transporter""));
-    }
-
-    @Test
-    public void testClient() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setClient(""client"");
-        assertThat(registry.getClient(), equalTo(""client""));
-    }
-
-    @Test
-    public void testTimeout() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setTimeout(10);
-        assertThat(registry.getTimeout(), is(10));
-    }
-
-    @Test
-    public void testSession() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setSession(10);
-        assertThat(registry.getSession(), is(10));
-    }
-
-    @Test
-    public void testDynamic() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setDynamic(true);
-        assertThat(registry.isDynamic(), is(true));
-    }
-
-    @Test
-    public void testRegister() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setRegister(true);
-        assertThat(registry.isRegister(), is(true));
-    }
-
-    @Test
-    public void testSubscribe() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setSubscribe(true);
-        assertThat(registry.isSubscribe(), is(true));
-    }
-
-    @Test
-    public void testCluster() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setCluster(""cluster"");
-        assertThat(registry.getCluster(), equalTo(""cluster""));
-    }
-
-    @Test
-    public void testGroup() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setGroup(""group"");
-        assertThat(registry.getGroup(), equalTo(""group""));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setVersion(""1.0.0"");
-        assertThat(registry.getVersion(), equalTo(""1.0.0""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setParameters(Collections.singletonMap(""k1"", ""v1""));
-        assertThat(registry.getParameters(), hasEntry(""k1"", ""v1""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        RegistryConfig.appendParameters(parameters, registry);
-        assertThat(parameters, hasEntry(""k1"", ""v1""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setDefault(true);
-        assertThat(registry.isDefault(), is(true));
-    }
-}
@@ -1,205 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.api.Greeting;
-import org.apache.dubbo.config.mock.TestProxyFactory;
-import org.apache.dubbo.config.provider.impl.DemoServiceImpl;
-import org.apache.dubbo.config.mock.MockProtocol2;
-import org.apache.dubbo.config.mock.MockRegistryFactory2;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.service.GenericService;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.mockito.Mockito;
-
-import java.util.Collections;
-
-import static org.apache.dubbo.common.Constants.GENERIC_SERIALIZATION_BEAN;
-import static org.apache.dubbo.common.Constants.GENERIC_SERIALIZATION_DEFAULT;
-import static org.apache.dubbo.common.Constants.GENERIC_SERIALIZATION_NATIVE_JAVA;
-import static org.hamcrest.CoreMatchers.containsString;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.hasSize;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.withSettings;
-
-public class ServiceConfigTest {
-    private Protocol protocolDelegate = Mockito.mock(Protocol.class);
-    private Registry registryDelegate = Mockito.mock(Registry.class);
-    private Exporter exporter = Mockito.mock(Exporter.class);
-    private ServiceConfig<DemoServiceImpl> service = new ServiceConfig<DemoServiceImpl>();
-    private ServiceConfig<DemoServiceImpl> service2 = new ServiceConfig<DemoServiceImpl>();
-
-
-    @Before
-    public void setUp() throws Exception {
-        MockProtocol2.delegate = protocolDelegate;
-        MockRegistryFactory2.registry = registryDelegate;
-        Mockito.when(protocolDelegate.export(Mockito.any(Invoker.class))).thenReturn(exporter);
-
-        ApplicationConfig app = new ApplicationConfig(""app"");
-
-        ProtocolConfig protocolConfig = new ProtocolConfig();
-        protocolConfig.setName(""mockprotocol2"");
-
-        ProviderConfig provider = new ProviderConfig();
-        provider.setExport(true);
-        provider.setProtocol(protocolConfig);
-
-        RegistryConfig registry = new RegistryConfig();
-        registry.setProtocol(""mockprotocol2"");
-
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setIndex(0);
-        argument.setCallback(false);
-
-        MethodConfig method = new MethodConfig();
-        method.setName(""echo"");
-        method.setArguments(Collections.singletonList(argument));
-
-        service.setProvider(provider);
-        service.setApplication(app);
-        service.setRegistry(registry);
-        service.setInterface(DemoService.class);
-        service.setRef(new DemoServiceImpl());
-        service.setMethods(Collections.singletonList(method));
-
-        service2.setProvider(provider);
-        service2.setApplication(app);
-        service2.setRegistry(registry);
-        service2.setInterface(DemoService.class);
-        service2.setRef(new DemoServiceImpl());
-        service2.setMethods(Collections.singletonList(method));
-        service2.setProxy(""testproxyfactory"");
-    }
-
-    @Test
-    public void testExport() throws Exception {
-        service.export();
-
-        assertThat(service.getExportedUrls(), hasSize(1));
-        URL url = service.toUrl();
-        assertThat(url.getProtocol(), equalTo(""mockprotocol2""));
-        assertThat(url.getPath(), equalTo(DemoService.class.getName()));
-        assertThat(url.getParameters(), hasEntry(Constants.ANYHOST_KEY, ""true""));
-        assertThat(url.getParameters(), hasEntry(Constants.APPLICATION_KEY, ""app""));
-        assertThat(url.getParameters(), hasKey(Constants.BIND_IP_KEY));
-        assertThat(url.getParameters(), hasKey(Constants.BIND_PORT_KEY));
-        assertThat(url.getParameters(), hasEntry(Constants.DEFAULT_KEY + ""."" + Constants.EXPORT_KEY, ""true""));
-        assertThat(url.getParameters(), hasEntry(Constants.EXPORT_KEY, ""true""));
-        assertThat(url.getParameters(), hasEntry(""echo.0.callback"", ""false""));
-        assertThat(url.getParameters(), hasEntry(Constants.GENERIC_KEY, ""false""));
-        assertThat(url.getParameters(), hasEntry(Constants.INTERFACE_KEY, DemoService.class.getName()));
-        assertThat(url.getParameters(), hasKey(Constants.METHODS_KEY));
-        assertThat(url.getParameters().get(Constants.METHODS_KEY), containsString(""echo""));
-        assertThat(url.getParameters(), hasEntry(Constants.SIDE_KEY, Constants.PROVIDER));
-        Mockito.verify(protocolDelegate).export(Mockito.any(Invoker.class));
-    }
-
-    @Test
-    public void testProxy() throws Exception {
-        service2.export();
-
-        assertThat(service2.getExportedUrls(), hasSize(1));
-        assertEquals(2, TestProxyFactory.count); // local injvm and registry protocol, so expected is 2
-    }
-
-    @Test
-    @Ignore(""cannot pass in travis"")
-    public void testUnexport() throws Exception {
-        System.setProperty(Constants.SHUTDOWN_WAIT_KEY, ""0"");
-        try {
-            service.export();
-            service.unexport();
-            Thread.sleep(1000);
-            Mockito.verify(exporter, Mockito.atLeastOnce()).unexport();
-        } finally {
-            System.clearProperty(Constants.SHUTDOWN_TIMEOUT_KEY);
-        }
-    }
-
-    @Test
-    public void testInterfaceClass() throws Exception {
-        ServiceConfig<Greeting> service = new ServiceConfig<Greeting>();
-        service.setInterface(Greeting.class.getName());
-        service.setRef(Mockito.mock(Greeting.class));
-        assertThat(service.getInterfaceClass() == Greeting.class, is(true));
-        service = new ServiceConfig<Greeting>();
-        service.setRef(Mockito.mock(Greeting.class, withSettings().extraInterfaces(GenericService.class)));
-        assertThat(service.getInterfaceClass() == GenericService.class, is(true));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testInterface1() throws Exception {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setInterface(DemoServiceImpl.class);
-    }
-
-    @Test
-    public void testInterface2() throws Exception {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setInterface(DemoService.class);
-        assertThat(service.getInterface(), equalTo(DemoService.class.getName()));
-    }
-
-    @Test
-    public void testProvider() throws Exception {
-        ServiceConfig service = new ServiceConfig();
-        ProviderConfig provider = new ProviderConfig();
-        service.setProvider(provider);
-        assertThat(service.getProvider(), is(provider));
-    }
-
-    @Test
-    public void testGeneric1() throws Exception {
-        ServiceConfig service = new ServiceConfig();
-        service.setGeneric(GENERIC_SERIALIZATION_DEFAULT);
-        assertThat(service.getGeneric(), equalTo(GENERIC_SERIALIZATION_DEFAULT));
-        service.setGeneric(GENERIC_SERIALIZATION_NATIVE_JAVA);
-        assertThat(service.getGeneric(), equalTo(GENERIC_SERIALIZATION_NATIVE_JAVA));
-        service.setGeneric(GENERIC_SERIALIZATION_BEAN);
-        assertThat(service.getGeneric(), equalTo(GENERIC_SERIALIZATION_BEAN));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testGeneric2() throws Exception {
-        ServiceConfig service = new ServiceConfig();
-        service.setGeneric(""illegal"");
-    }
-
-    @Test
-    public void testUniqueServiceName() throws Exception {
-        ServiceConfig<Greeting> service = new ServiceConfig<Greeting>();
-        service.setGroup(""dubbo"");
-        service.setInterface(Greeting.class);
-        service.setVersion(""1.0.0"");
-        assertThat(service.getUniqueServiceName(), equalTo(""dubbo/"" + Greeting.class.getName() + "":1.0.0""));
-    }
-}
@@ -1,23 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-public interface Box {
-
-    String getName();
-
-}
\ No newline at end of file
@@ -1,42 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-/**
- * DemoException
- */
-public class DemoException extends Exception {
-
-    private static final long serialVersionUID = -8213943026163641747L;
-
-    public DemoException() {
-        super();
-    }
-
-    public DemoException(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-    public DemoException(String message) {
-        super(message);
-    }
-
-    public DemoException(Throwable cause) {
-        super(cause);
-    }
-
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-import java.util.List;
-
-
-/**
- * DemoService
- */
-public interface DemoService {
-
-    String sayName(String name);
-
-    Box getBox();
-
-    void throwDemoException() throws DemoException;
-
-    List<User> getUsers(List<User> users);
-
-    int echo(int i);
-
-}
\ No newline at end of file
@@ -1,24 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-import org.apache.dubbo.common.extension.SPI;
-
-@SPI
-public interface Greeting {
-    String hello();
-}
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-import java.io.Serializable;
-
-/**
- * User
- */
-public class User implements Serializable {
-
-    private static final long serialVersionUID = 1L;
-
-    private String name;
-
-    public User() {
-    }
-
-    public User(String name) {
-        this.name = name;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    @Override
-    public int hashCode() {
-        return name == null ? -1 : name.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (!(obj instanceof User)) {
-            return false;
-        }
-        User other = (User) obj;
-        if (this == other) {
-            return true;
-        }
-        if (name != null && other.name != null) {
-            return name.equals(other.name);
-        }
-        return false;
-    }
-
-}
@@ -1,26 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.cache;
-
-/**
- * ValidationService
- */
-public interface CacheService {
-
-    String findCache(String id);
-
-}
@@ -1,32 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.cache;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * ValidationServiceImpl
- */
-public class CacheServiceImpl implements CacheService {
-
-    private final AtomicInteger i = new AtomicInteger();
-
-    public String findCache(String id) {
-        return ""request: "" + id + "", response: "" + i.getAndIncrement();
-    }
-
-}
@@ -1,119 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.cache;
-
-import org.apache.dubbo.cache.Cache;
-import org.apache.dubbo.cache.CacheFactory;
-import org.apache.dubbo.cache.support.threadlocal.ThreadLocalCache;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.MethodConfig;
-import org.apache.dubbo.config.ProtocolConfig;
-import org.apache.dubbo.config.ReferenceConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.RpcInvocation;
-
-import junit.framework.TestCase;
-import org.junit.Test;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * CacheTest
- */
-public class CacheTest extends TestCase {
-
-    private void testCache(String type) throws Exception {
-        ServiceConfig<CacheService> service = new ServiceConfig<CacheService>();
-        service.setApplication(new ApplicationConfig(""cache-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""injvm""));
-        service.setInterface(CacheService.class.getName());
-        service.setRef(new CacheServiceImpl());
-        service.export();
-        try {
-            ReferenceConfig<CacheService> reference = new ReferenceConfig<CacheService>();
-            reference.setApplication(new ApplicationConfig(""cache-consumer""));
-            reference.setInterface(CacheService.class);
-            reference.setUrl(""injvm://127.0.0.1?scope=remote&cache=true"");
-
-            MethodConfig method = new MethodConfig();
-            method.setName(""findCache"");
-            method.setCache(type);
-            reference.setMethods(Arrays.asList(method));
-
-            CacheService cacheService = reference.get();
-            try {
-                // verify cache, same result is returned for multiple invocations (in fact, the return value increases
-                // on every invocation on the server side)
-                String fix = null;
-                for (int i = 0; i < 3; i++) {
-                    String result = cacheService.findCache(""0"");
-                    assertTrue(fix == null || fix.equals(result));
-                    fix = result;
-                    Thread.sleep(100);
-                }
-
-                if (""lru"".equals(type)) {
-                    // default cache.size is 1000 for LRU, should have cache expired if invoke more than 1001 times
-                    for (int n = 0; n < 1001; n++) {
-                        String pre = null;
-                        for (int i = 0; i < 10; i++) {
-                            String result = cacheService.findCache(String.valueOf(n));
-                            assertTrue(pre == null || pre.equals(result));
-                            pre = result;
-                        }
-                    }
-
-                    // verify if the first cache item is expired in LRU cache
-                    String result = cacheService.findCache(""0"");
-                    assertFalse(fix == null || fix.equals(result));
-                }
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testCache() throws Exception {
-        testCache(""lru"");
-        testCache(""threadlocal"");
-    }
-
-    @Test
-    public void testCacheProvider() throws Exception {
-        CacheFactory cacheFactory = ExtensionLoader.getExtensionLoader(CacheFactory.class).getAdaptiveExtension();
-
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(""findCache.cache"", ""threadlocal"");
-        URL url = new URL(""dubbo"", ""127.0.0.1"", 29582, ""org.apache.dubbo.config.cache.CacheService"", parameters);
-
-        Invocation invocation = new RpcInvocation(""findCache"", new Class[]{String.class}, new String[]{""0""}, null, null);
-
-        Cache cache = cacheFactory.getCache(url, invocation);
-        assertTrue(cache instanceof ThreadLocalCache);
-    }
-
-}
@@ -1,35 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.consumer;
-
-import org.apache.dubbo.config.api.DemoService;
-
-import org.springframework.beans.factory.annotation.Autowired;
-
-/**
- * DemoAction
- */
-public class DemoActionByAnnotation {
-
-    @Autowired
-    private DemoService demoService;
-
-    public DemoService getDemoService() {
-        return demoService;
-    }
-
-}
\ No newline at end of file
@@ -1,36 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.consumer;
-
-import org.apache.dubbo.config.api.DemoService;
-
-/**
- * DemoAction
- */
-public class DemoActionBySetter {
-
-    private DemoService demoService;
-
-    public DemoService getDemoService() {
-        return demoService;
-    }
-
-    public void setDemoService(DemoService demoService) {
-        this.demoService = demoService;
-    }
-
-}
\ No newline at end of file
@@ -1,31 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.consumer;
-
-import org.aopalliance.intercept.MethodInterceptor;
-import org.aopalliance.intercept.MethodInvocation;
-
-/**
- * DemoInterceptor
- */
-public class DemoInterceptor implements MethodInterceptor {
-
-    public Object invoke(MethodInvocation invocation) throws Throwable {
-        return ""aop:"" + invocation.proceed();
-    }
-
-}
\ No newline at end of file
@@ -1,59 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.invoker;
-
-import org.apache.dubbo.config.api.Greeting;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mockito;
-
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertThat;
-
-public class DelegateProviderMetaDataInvokerTest {
-    private ServiceConfig service;
-    private Invoker<Greeting> invoker;
-
-    @Before
-    public void setUp() throws Exception {
-        service = Mockito.mock(ServiceConfig.class);
-        invoker = Mockito.mock(Invoker.class);
-    }
-
-    @Test
-    public void testDelegate() throws Exception {
-        DelegateProviderMetaDataInvoker<Greeting> delegate =
-                new DelegateProviderMetaDataInvoker<Greeting>(invoker, service);
-        delegate.getInterface();
-        Mockito.verify(invoker).getInterface();
-        delegate.getUrl();
-        Mockito.verify(invoker).getUrl();
-        delegate.isAvailable();
-        Mockito.verify(invoker).isAvailable();
-        Invocation invocation = Mockito.mock(Invocation.class);
-        delegate.invoke(invocation);
-        Mockito.verify(invoker).invoke(invocation);
-        delegate.destroy();
-        Mockito.verify(invoker).destroy();
-        assertThat(delegate.getMetadata(), sameInstance(service));
-    }
-
-}
@@ -1,21 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-public class GreetingLocal1 {
-
-}
@@ -1,26 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.config.api.Greeting;
-
-public class GreetingLocal2 implements Greeting {
-    @Override
-    public String hello() {
-        return ""local"";
-    }
-}
@@ -1,32 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.config.api.Greeting;
-
-public class GreetingLocal3 implements Greeting {
-    private Greeting greeting;
-
-    public GreetingLocal3(Greeting greeting) {
-        this.greeting = greeting;
-    }
-
-    @Override
-    public String hello() {
-        return null;
-    }
-}
@@ -1,20 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-public class GreetingMock1 {
-}
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.config.api.Greeting;
-
-public class GreetingMock2 implements Greeting {
-    private GreetingMock2() {
-    }
-
-    @Override
-    public String hello() {
-        return ""mock"";
-    }
-}
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.cluster.Cluster;
-import org.apache.dubbo.rpc.cluster.Directory;
-
-public class MockCluster implements Cluster {
-    @Override
-    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
-        return null;
-    }
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.remoting.Channel;
-import org.apache.dubbo.remoting.Codec;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-public class MockCodec implements Codec {
-    @Override
-    public void encode(Channel channel, OutputStream output, Object message) throws IOException {
-
-    }
-
-    @Override
-    public Object decode(Channel channel, InputStream input) throws IOException {
-        return null;
-    }
-}
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.remoting.ChannelHandler;
-import org.apache.dubbo.remoting.Dispatcher;
-
-public class MockDispatcher implements Dispatcher {
-    @Override
-    public ChannelHandler dispatch(ChannelHandler handler, URL url) {
-        return null;
-    }
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.remoting.RemotingException;
-import org.apache.dubbo.remoting.exchange.ExchangeClient;
-import org.apache.dubbo.remoting.exchange.ExchangeHandler;
-import org.apache.dubbo.remoting.exchange.ExchangeServer;
-import org.apache.dubbo.remoting.exchange.Exchanger;
-
-public class MockExchanger implements Exchanger {
-    @Override
-    public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
-        return null;
-    }
-
-    @Override
-    public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {
-        return null;
-    }
-}
@@ -1,34 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.ExporterListener;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockExporterListener implements ExporterListener  {
-    @Override
-    public void exported(Exporter<?> exporter) throws RpcException {
-
-    }
-
-    @Override
-    public void unexported(Exporter<?> exporter) {
-
-    }
-}
@@ -1,30 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.rpc.Filter;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockFilter implements Filter {
-    @Override
-    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        return null;
-    }
-}
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.InvokerListener;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockInvokerListener implements InvokerListener {
-    @Override
-    public void referred(Invoker<?> invoker) throws RpcException {
-
-    }
-
-    @Override
-    public void destroyed(Invoker<?> invoker) {
-
-    }
-}
@@ -1,32 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.cluster.LoadBalance;
-
-import java.util.List;
-
-public class MockLoadBalance implements LoadBalance {
-    @Override
-    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
-        return null;
-    }
-}
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockProtocol implements Protocol {
-
-    /* (non-Javadoc)
-     * @see org.apache.dubbo.rpc.Protocol#getDefaultPort()
-     */
-    @Override
-    public int getDefaultPort() {
-
-        return 0;
-    }
-
-    /* (non-Javadoc)
-     * @see org.apache.dubbo.rpc.Protocol#export(org.apache.dubbo.rpc.Invoker)
-     */
-    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
-        return null;
-    }
-
-    /* (non-Javadoc)
-     * @see org.apache.dubbo.rpc.Protocol#refer(java.lang.Class, org.apache.dubbo.common.URL)
-     */
-    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
-
-        final URL u = url;
-
-        return new Invoker<T>() {
-            @Override
-            public Class<T> getInterface() {
-                return null;
-            }
-
-            public URL getUrl() {
-                return u;
-            }
-
-            @Override
-            public boolean isAvailable() {
-                return true;
-            }
-
-            public Result invoke(Invocation invocation) throws RpcException {
-                return null;
-            }
-
-            @Override
-            public void destroy() {
-
-            }
-        };
-    }
-
-    /* (non-Javadoc)
-     * @see org.apache.dubbo.rpc.Protocol#destroy()
-     */
-    @Override
-    public void destroy() {
-
-    }
-
-}
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockProtocol2 implements Protocol {
-    public static Protocol delegate;
-
-    @Override
-    public int getDefaultPort() {
-        return delegate.getDefaultPort();
-    }
-
-    @Override
-    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
-        return delegate.export(invoker);
-    }
-
-    @Override
-    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
-        return delegate.refer(type, url);
-    }
-
-    @Override
-    public void destroy() {
-        delegate.destroy();
-    }
-}
@@ -1,39 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.ProxyFactory;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockProxyFactory implements ProxyFactory {
-    @Override
-    public <T> T getProxy(Invoker<T> invoker) throws RpcException {
-        return null;
-    }
-
-    @Override
-    public <T> T getProxy(Invoker<T> invoker, boolean generic) throws RpcException {
-        return null;
-    }
-
-    @Override
-    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException {
-        return null;
-    }
-}
@@ -1,108 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.registry.NotifyListener;
-import org.apache.dubbo.registry.Registry;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * TODO Comment of MockRegistry
- */
-public class MockRegistry implements Registry {
-
-    static URL subscribedUrl = new URL(""null"", ""0.0.0.0"", 0);
-
-    public static URL getSubscribedUrl() {
-        return subscribedUrl;
-    }
-
-    /* 
-     * @see org.apache.dubbo.common.Node#getUrl()
-     */
-    public URL getUrl() {
-        return null;
-    }
-
-    /* 
-     * @see org.apache.dubbo.common.Node#isAvailable()
-     */
-    @Override
-    public boolean isAvailable() {
-        return true;
-    }
-
-    /* 
-     * @see org.apache.dubbo.common.Node#destroy()
-     */
-    @Override
-    public void destroy() {
-
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#register(org.apache.dubbo.common.URL)
-     */
-    @Override
-    public void register(URL url) {
-
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#unregister(org.apache.dubbo.common.URL)
-     */
-    @Override
-    public void unregister(URL url) {
-
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#subscribe(org.apache.dubbo.common.URL, org.apache.dubbo.registry.NotifyListener)
-     */
-    @Override
-    public void subscribe(URL url, NotifyListener listener) {
-        this.subscribedUrl = url;
-        List<URL> urls = new ArrayList<URL>();
-
-        urls.add(url.setProtocol(""mockprotocol"")
-                .removeParameter(Constants.CATEGORY_KEY)
-                .addParameter(Constants.METHODS_KEY, ""sayHello""));
-
-        listener.notify(urls);
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#unsubscribe(org.apache.dubbo.common.URL, org.apache.dubbo.registry.NotifyListener)
-     */
-    @Override
-    public void unsubscribe(URL url, NotifyListener listener) {
-
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#lookup(org.apache.dubbo.common.URL)
-     */
-    @Override
-    public List<URL> lookup(URL url) {
-        return null;
-    }
-
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.registry.RegistryFactory;
-
-/**
- * TODO Comment of MockRegistryFactory
- */
-public class MockRegistryFactory implements RegistryFactory {
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryFactory#getRegistry(org.apache.dubbo.common.URL)
-     */
-    @Override
-    public Registry getRegistry(URL url) {
-
-        return new MockRegistry();
-    }
-
-}
@@ -1,31 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.registry.RegistryFactory;
-
-public class MockRegistryFactory2 implements RegistryFactory {
-    public static Registry registry;
-
-    @Override
-    public Registry getRegistry(URL url) {
-        return registry;
-    }
-}
@@ -1,28 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.status.Status;
-import org.apache.dubbo.common.status.StatusChecker;
-
-public class MockStatusChecker implements StatusChecker {
-    @Override
-    public Status check() {
-        return null;
-    }
-}
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.remoting.Channel;
-import org.apache.dubbo.remoting.RemotingException;
-import org.apache.dubbo.remoting.telnet.TelnetHandler;
-
-public class MockTelnetHandler implements TelnetHandler {
-    @Override
-    public String telnet(Channel channel, String message) throws RemotingException {
-        return null;
-    }
-}
@@ -1,30 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.threadpool.ThreadPool;
-
-import java.util.concurrent.Executor;
-
-public class MockThreadPool implements ThreadPool  {
-    @Override
-    public Executor getExecutor(URL url) {
-        return null;
-    }
-}
@@ -1,41 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.remoting.ChannelHandler;
-import org.apache.dubbo.remoting.Client;
-import org.apache.dubbo.remoting.RemotingException;
-import org.apache.dubbo.remoting.Server;
-import org.apache.dubbo.remoting.Transporter;
-import org.mockito.Mockito;
-
-public class MockTransporter implements Transporter {
-    private Server server = Mockito.mock(Server.class);
-    private Client client = Mockito.mock(Client.class);
-
-    @Override
-    public Server bind(URL url, ChannelHandler handler) throws RemotingException {
-        return server;
-    }
-
-    @Override
-    public Client connect(URL url, ChannelHandler handler) throws RemotingException {
-        return client;
-    }
-}
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.proxy.jdk.JdkProxyFactory;
-
-public class TestProxyFactory extends JdkProxyFactory {
-    public static int count = 0;
-
-    @Override
-    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException {
-        count++;
-        return super.getInvoker(proxy, type, url);
-    }
-}
@@ -1,51 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.provider.impl;
-
-import org.apache.dubbo.config.api.Box;
-import org.apache.dubbo.config.api.DemoException;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.api.User;
-
-import java.util.List;
-
-/**
- * DemoServiceImpl
- */
-public class DemoServiceImpl implements DemoService {
-
-    public String sayName(String name) {
-        return ""say:"" + name;
-    }
-
-    public Box getBox() {
-        return null;
-    }
-
-    public void throwDemoException() throws DemoException {
-        throw new DemoException(""DemoServiceImpl"");
-    }
-
-    public List<User> getUsers(List<User> users) {
-        return users;
-    }
-
-    public int echo(int i) {
-        return i;
-    }
-
-}
\ No newline at end of file
@@ -1,99 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.url;
-
-
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
-
-public class ExporterSideConfigUrlTest extends UrlTestBase {
-
-    private static final Logger log = LoggerFactory.getLogger(ExporterSideConfigUrlTest.class);
-
-    // ======================================================
-    //   tests start
-    // ======================================================  
-    @BeforeClass
-    public static void start() {
-    }
-
-
-    @Before
-    public void setUp() {
-        initServConf();
-    }
-
-    @After()
-    public void teardown() {
-    }
-
-    @Test
-    public void exporterMethodConfigUrlTest() {
-        verifyExporterUrlGeneration(methodConfForService, methodConfForServiceTable);
-    }
-
-    @Test
-    public void exporterServiceConfigUrlTest() {
-        verifyExporterUrlGeneration(servConf, servConfTable);
-    }
-
-    @Test
-    public void exporterProviderConfigUrlTest() {
-
-        verifyExporterUrlGeneration(provConf, provConfTable);
-    }
-
-    @Test
-    public void exporterRegistryConfigUrlTest() {
-
-        //verifyExporterUrlGeneration(regConfForService, regConfForServiceTable);
-    }
-
-
-    protected <T> void verifyExporterUrlGeneration(T config, Object[][] dataTable) {
-
-        // 1. fill corresponding config with data
-        ////////////////////////////////////////////////////////////
-        fillConfigs(config, dataTable, TESTVALUE1);
-
-        // 2. export service and get url parameter string from db
-        ////////////////////////////////////////////////////////////
-        servConf.export();
-        String paramStringFromDb = getProviderParamString();
-        try {
-            paramStringFromDb = URLDecoder.decode(paramStringFromDb, ""UTF-8"");
-        } catch (UnsupportedEncodingException e) {
-            // impossible
-        }
-
-
-        assertUrlStringWithLocalTable(paramStringFromDb, dataTable, config.getClass().getName(), TESTVALUE1);
-
-
-        // 4. unexport service
-        ////////////////////////////////////////////////////////////
-        servConf.unexport();
-    }
-}
\ No newline at end of file
@@ -1,228 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.url;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.ConsumerConfig;
-import org.apache.dubbo.config.MethodConfig;
-import org.apache.dubbo.config.ReferenceConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.mock.MockRegistry;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import java.util.Arrays;
-
-
-public class InvokerSideConfigUrlTest extends UrlTestBase {
-    private static final Logger log = LoggerFactory.getLogger(InvokerSideConfigUrlTest.class);
-
-    // ======================================================
-    //   invoker related data preparing
-    // ======================================================  
-    private ApplicationConfig appConfForConsumer;
-    private ApplicationConfig appConfForReference;
-    private RegistryConfig regConfForConsumer;
-    private RegistryConfig regConfForReference;
-    private MethodConfig methodConfForReference;
-    private ConsumerConfig consumerConf;
-    private ReferenceConfig<DemoService> refConf;
-
-    private Object appConfForConsumerTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-
-    private Object appConfForReferenceTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-
-    private Object regConfForConsumerTable[][] = {
-//            {""timeout"", ""registry.timeout"", ""int"", 5000, 9000, """", """", """", """", """"}, 
-//            {""file"", ""registry.file"", ""string"", """", ""regConfForServiceTable.log"", """", """", """", """", """"}, 
-//            {""wait"", ""registry.wait"", ""int"", 0, 9000, """", """", """", """", """"}, 
-//            {""transport"", ""registry.transporter"", ""string"", ""netty"", ""mina"", """", """", """", """", """"}, 
-            {""subscribe"", ""subscribe"", ""boolean"", true, false, """", """", """", """", """"},
-            {""dynamic"", ""dynamic"", ""boolean"", true, false, """", """", """", """", """"},
-    };
-
-    private Object regConfForReferenceTable[][] = {
-            {""timeout"", ""registry.timeout"", ""int"", 5000, 9000, """", """", """", """", """"},
-            {""file"", ""registry.file"", ""string"", """", ""regConfForServiceTable.log"", """", """", """", """", """"},
-            {""wait"", ""registry.wait"", ""int"", 0, 9000, """", """", """", """", """"},
-            {""transport"", ""registry.transporter"", ""string"", ""netty"", ""mina"", """", """", """", """", """"},
-            {""subscribe"", ""subscribe"", ""boolean"", true, false, """", """", """", """", """"},
-            {""dynamic"", ""dynamic"", ""boolean"", true, false, """", """", """", """", """"},
-    };
-
-    private Object methodConfForReferenceTable[][] = {
-            {""actives"", ""eatTiger.actives"", ""int"", 0, 90, """", """", """", """", """"},
-            {""executes"", ""eatTiger.executes"", ""int"", 0, 90, """", """", """", """", """"},
-            {""deprecated"", ""eatTiger.deprecated"", ""boolean"", false, true, """", """", """", """", """"},
-            {""async"", ""eatTiger.async"", ""boolean"", false, true, """", """", """", """", """"},
-            {""timeout"", ""eatTiger.timeout"", ""int"", 0, 90, """", """", """", """", """"},
-    };
-
-    private Object refConfTable[][] = {
-//            {""version"", ""version"", ""string"", ""0.0.0"", ""1.2.3"", """", """", """", """", """"}, 
-//            {""group"", ""group"", ""string"", """", ""HaominTest"", """", """", """", """", """"}, 
-
-//            {""delay"", ""delay"", ""int"", 0, 5, """", """", """", """", """"}, // not boolean 
-            {""timeout"", ""timeout"", ""int"", 5000, 3000, """", """", """", """", """"},
-            {""retries"", ""retries"", ""int"", 2, 5, """", """", """", """", """"},
-            {""connections"", ""connections"", ""boolean"", 100, 20, """", """", """", """", """"},
-            {""loadbalance"", ""loadbalance"", ""string"", ""random"", ""roundrobin"", ""leastactive"", """", """", """"},
-            {""async"", ""async"", ""boolean"", false, true, """", """", """", """", """"},
-            //excluded = true
-//            {""generic"", ""generic"", ""boolean"", false, true, """", """", """", """", """"},  
-            {""check"", ""check"", ""boolean"", false, true, """", """", """", """", """"},
-            //{""local"", ""local"", ""string"", ""false"", ""HelloServiceLocal"", ""true"", """", """", """", """"}, 
-            //{""local"", ""local"", ""string"", ""false"", ""true"", """", """", """", """", """"}, 
-            //{""mock"", ""mock"", ""string"", ""false"", ""dubbo.test.HelloServiceMock"", ""true"", """", """", """", """"}, 
-            {""mock"", ""mock"", ""string"", ""false"", ""false"", """", """", """", """", """"},
-            {""proxy"", ""proxy"", ""boolean"", ""javassist"", ""jdk"", """", """", """", """", """"},
-            {""client"", ""client"", ""string"", ""netty"", ""mina"", """", """", """", """", """"},
-            {""client"", ""client"", ""string"", ""netty"", ""mina"", """", """", """", """", """"},
-            {""owner"", ""owner"", ""string"", """", ""haomin,ludvik"", """", """", """", """", """"},
-            {""actives"", ""actives"", ""int"", 0, 30, """", """", """", """", """"},
-            {""cluster"", ""cluster"", ""string"", ""failover"", ""failfast"", ""failsafe"", ""failback"", ""forking"", """", """"},
-            //excluded = true
-//            {""filter"", ""service.filter"", ""string"", ""default"", ""-generic"", """", """", """", """", """"}, 
-            //excluded = true
-//            {""listener"", ""exporter.listener"", ""string"", ""default"", ""-deprecated"", """", """", """", """", """"}, 
-            //{"""", """", """", """", """", """", """", """", """", """"}, 
-    };
-
-    private Object consumerConfTable[][] = {
-            {""timeout"", ""default.timeout"", ""int"", 5000, 8000, """", """", """", """", """"},
-            {""retries"", ""default.retries"", ""int"", 2, 5, """", """", """", """", """"},
-            {""loadbalance"", ""default.loadbalance"", ""string"", ""random"", ""leastactive"", """", """", """", """", """"},
-            {""async"", ""default.async"", ""boolean"", false, true, """", """", """", """", """"},
-            {""connections"", ""default.connections"", ""int"", 100, 5, """", """", """", """", """"},
-//            {""generic"", ""generic"", ""boolean"", false, false, """", """", """", """", """"}, 
-            {""check"", ""check"", ""boolean"", true, false, """", """", """", """", """"},
-            {""proxy"", ""proxy"", ""string"", ""javassist"", ""jdk"", ""javassist"", """", """", """", """"},
-            {""owner"", ""owner"", ""string"", """", ""haomin"", """", """", """", """", """"},
-            {""actives"", ""default.actives"", ""int"", 0, 5, """", """", """", """", """"},
-            {""cluster"", ""default.cluster"", ""string"", ""failover"", ""forking"", """", """", """", """", """"},
-            {""filter"", """", ""string"", """", """", """", """", """", """", """"},
-            {""listener"", """", ""string"", """", """", """", """", """", """", """"},
-//            {"""", """", """", """", """", """", """", """", """", """"}, 
-    };
-
-    // ======================================================
-    //   test Start
-    // ====================================================== 
-
-    @BeforeClass
-    public static void start() {
-        //RegistryController.startRegistryIfAbsence(1);
-    }
-
-
-    @Before
-    public void setUp() {
-        initServConf();
-        initRefConf();
-    }
-
-    @After()
-    public void teardown() {
-        //RegistryServer.reloadCache();
-    }
-
-
-    @Test
-    public void consumerConfUrlTest() {
-        verifyInvokerUrlGeneration(consumerConf, consumerConfTable);
-    }
-
-    @Test
-    public void refConfUrlTest() {
-        verifyInvokerUrlGeneration(refConf, refConfTable);
-    }
-
-    @Ignore(""parameter on register center will not be merged any longer with query parameter request from the consumer"")
-    @Test
-    public void regConfForConsumerUrlTest() {
-        verifyInvokerUrlGeneration(regConfForConsumer, regConfForConsumerTable);
-    }
-
-    // ======================================================
-    //   private helper
-    // ====================================================== 
-    private void initRefConf() {
-
-        appConfForConsumer = new ApplicationConfig();
-        appConfForReference = new ApplicationConfig();
-        regConfForConsumer = new RegistryConfig();
-        regConfForReference = new RegistryConfig();
-        methodConfForReference = new MethodConfig();
-
-        refConf = new ReferenceConfig<DemoService>();
-        consumerConf = new ConsumerConfig();
-
-        methodConfForReference.setName(""sayName"");
-        regConfForReference.setAddress(""127.0.0.1:9090"");
-        regConfForReference.setProtocol(""mockregistry"");
-        appConfForReference.setName(""ConfigTests"");
-        refConf.setInterface(""org.apache.dubbo.config.api.DemoService"");
-
-        refConf.setApplication(appConfForReference);
-        consumerConf.setApplication(appConfForConsumer);
-
-        refConf.setRegistry(regConfForReference);
-        consumerConf.setRegistry(regConfForConsumer);
-
-        refConf.setConsumer(consumerConf);
-
-        refConf.setMethods(Arrays.asList(new MethodConfig[]{methodConfForReference}));
-
-        refConf.setScope(Constants.SCOPE_REMOTE);
-    }
-
-    private <T> void verifyInvokerUrlGeneration(T config, Object[][] dataTable) {
-        servConf.export();
-
-        fillConfigs(config, dataTable, TESTVALUE1);
-        refConf.get();
-
-        String subScribedUrlStr = getSubscribedUrlString();
-
-        System.out.println(""url string=========:"" + subScribedUrlStr);
-        String configName = config.getClass().getName();
-        int column = TESTVALUE1;
-
-        assertUrlStringWithLocalTable(subScribedUrlStr, dataTable, configName, column);
-
-        try {
-            refConf.destroy();
-        } catch (Exception e) {
-        }
-    }
-
-    private String getSubscribedUrlString() {
-        return MockRegistry.getSubscribedUrl().toString();
-    }
-}
\ No newline at end of file
@@ -1,166 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.url;
-
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.config.AbstractConfig;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-
-public class RpcConfigGetSetProxy {
-
-    private static final String RPC_CONFIG_BASECLASS = AbstractConfig.class.getName();
-    private static final Logger log = LoggerFactory.getLogger(RpcConfigGetSetProxy.class);
-
-
-    private Object proxiee = null;
-    private Class<?> proxieeClass = null;
-    private Boolean isOk = false;
-
-    public RpcConfigGetSetProxy(Object p) {
-
-        if (p == null) {
-            return;
-        }
-
-        if (!isKindOf(p.getClass(), RPC_CONFIG_BASECLASS)) {
-            return;
-        }
-
-        proxiee = p;
-        //proxieeClass = c;
-        proxieeClass = p.getClass();
-        isOk = true;
-
-    }
-
-    public static boolean isKindOf(Class<?> c, String type) {
-
-        // get the class def for obj and type
-
-        Class<?> tClass;
-        try {
-            tClass = Class.forName(type);
-        } catch (ClassNotFoundException e) {
-            return false;
-        }
-
-        // check against type and superclasses
-        while (c != null) {
-            if (c == tClass) return true;
-            c = c.getSuperclass();
-        }
-
-        return false;
-    }
-
-    public boolean isOk() {
-        return isOk;
-    }
-
-    public Object setValue(String key, Object value) {
-
-        if (!isOk()) {
-            return null;
-        }
-
-        Method m = findSetMethod(key, value, proxieeClass);
-        return invoke(m, value);
-    }
-
-    public Object getValue(String key) {
-
-        if (!isOk()) {
-            return null;
-        }
-
-        Method m = findGetMethod(key, proxieeClass);
-        return invoke(m, null);
-    }
-
-    private Object invoke(Method m, Object value) {
-
-        if (m == null) {
-            return null;
-        }
-
-        try {
-            if (value == null) {
-                return m.invoke(proxiee, (Object[]) null);
-            } else {
-                return m.invoke(proxiee, value);
-            }
-        } catch (IllegalArgumentException e) {
-            log.error(""IllegalArgumentException"", e);
-            return null;
-        } catch (IllegalAccessException e) {
-            log.error(""IllegalAccessException"", e);
-            return null;
-        } catch (InvocationTargetException e) {
-            log.error(""InvocationTargetException"", e);
-            return null;
-        }
-    }
-
-    private Method findGetMethod(String key, Class<?> clazz) {
-
-        Method m = findMethod(key, null, ""get"", clazz);
-        if (m != null) {
-            return m;
-        }
-
-        return findMethod(key, null, ""is"", clazz);
-    }
-
-    private Method findSetMethod(String key, Object value, Class<?> clazz) {
-
-        return findMethod(key, value, ""set"", clazz);
-    }
-
-    private Method getMethod(String methodName, Object value, Class<?> clazz) {
-
-        try {
-            if (value == null) {
-                return clazz.getMethod(methodName, (Class<?>[]) null);
-            } else {
-                return clazz.getMethod(methodName, value.getClass());
-            }
-        } catch (SecurityException e) {
-            log.error(""SecurityException: "" + e.getMessage());
-            return null;
-        } catch (NoSuchMethodException e) {
-            log.error(""NoSuchMethodException: "" + e.getMessage());
-            return null;
-        }
-    }
-
-    private Method findMethod(String key, Object value, String prefix, Class<?> clazz) {
-
-        if (key.length() < 2) {
-            return null;
-        }
-
-        key = key.substring(0, 1).toUpperCase() + key.substring(1);
-        String methodName = prefix + key;
-
-        return getMethod(methodName, value, clazz);
-    }
-
-}
\ No newline at end of file
@@ -1,211 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.url;
-
-
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.MethodConfig;
-import org.apache.dubbo.config.ProtocolConfig;
-import org.apache.dubbo.config.ProviderConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.provider.impl.DemoServiceImpl;
-
-import java.util.Arrays;
-
-import static junit.framework.TestCase.fail;
-
-@SuppressWarnings(""unused"")
-public class UrlTestBase {
-
-    // ======================================================
-    //   data column definition
-    // ======================================================
-    protected static final int KEY = 0;
-    protected static final int URL_KEY = 1;
-    protected static final int TESTVALUE1 = 4;
-    private static final Logger log = LoggerFactory.getLogger(UrlTestBase.class);
-    private static final int TYPE = 2;
-    private static final int DEFAULT = 3;
-    private static final int TESTVALUE2 = 5;
-    private static final int TESTVALUE3 = 6;
-    private static final int TESTVALUE4 = 7;
-    private static final int TESTVALUE5 = 8;
-    private static final int TESTVALUE6 = 9;
-    private static final int TESTVALUE7 = 10;
-    protected ApplicationConfig appConfForProvider;
-    protected ApplicationConfig appConfForService;
-    protected RegistryConfig regConfForProvider;
-    protected RegistryConfig regConfForService;
-    protected ProviderConfig provConf;
-    protected ProtocolConfig protoConfForProvider;
-    protected ProtocolConfig protoConfForService;
-    protected MethodConfig methodConfForService;
-    protected ServiceConfig<DemoService> servConf;
-    protected Object servConfTable[][] = {
-            {""proxy"", ""proxy"", ""string"", ""javassist"", ""jdk"", ""javassist"", """", """", """", """"},
-            {""actives"", ""actives"", ""int"", 0, 90, """", """", """", """", """"},
-            {""executes"", ""executes"", ""int"", 0, 90, """", """", """", """", """"},
-            {""deprecated"", ""deprecated"", ""boolean"", false, true, """", """", """", """", """"},
-            {""dynamic"", ""dynamic"", ""boolean"", true, false, """", """", """", """", """"},
-            {""accesslog"", ""accesslog"", ""string"", """", ""haominTest"", """", """", """", """", """"},
-            {""document"", ""document"", ""string"", """", ""http://b2b-doc.alibaba-inc.com/display/RC/dubbo_devguide.htm?testquery=你好你好"", """", """", """", """", """"},
-            {""weight"", ""weight"", ""int"", 0, 90, """", """", """", """", """"},
-
-            //{""filter"", ""service.filter"", ""string"", """", """", """", """", """", """", """"},
-            //{""listener"", ""listener"", ""string"", """", """", """", """", """", """", """"},
-
-    };
-    protected Object regConfForServiceTable[][] = {
-            //            {""timeout"", ""registry.timeout"", ""int"", 5000, 9000, """", """", """", """", """"},
-            //            {""file"", ""registry.file"", ""string"", """", ""regConfForServiceTable.log"", """", """", """", """", """"},
-            //            {""wait"", ""registry.wait"", ""int"", 0, 9000, """", """", """", """", """"},
-            //            {""transport"", ""registry.transporter"", ""string"", ""netty"", ""mina"", """", """", """", """", """"},
-            //            {""subscribe"", ""subscribe"", ""boolean"", true, false, """", """", """", """", """"},
-            {""dynamic"", ""dynamic"", ""boolean"", true, false, """", """", """", """", """"},
-    };
-    protected Object provConfTable[][] = {
-            {""cluster"", ""default.cluster"", ""string"", ""string"", ""failover"", ""failfast"", ""failsafe"", """", """", """"},
-            {""async"", ""default.async"", ""boolean"", false, true, """", """", """", """", """"},
-            {""loadbalance"", ""default.loadbalance"", ""string"", ""random"", ""leastactive"", """", """", """", """", """"},
-            {""connections"", ""default.connections"", ""int"", 0, 60, """", """", """", """", """"},
-            {""retries"", ""default.retries"", ""int"", 2, 60, """", """", """", """", """"},
-            {""timeout"", ""default.timeout"", ""int"", 5000, 60, """", """", """", """", """"},
-            //change by fengting listener 没有缺省值
-            //{""listener"", ""exporter.listener"", ""string"", """", """", """", """", """", """", """"},
-            //{""filter"", ""service.filter"", ""string"", """", """", """", """", """", """", """"},
-
-    };
-    protected Object methodConfForServiceTable[][] = {
-            {""actives"", ""sayName.actives"", ""int"", 0, 90, """", """", """", """", """"},
-            {""executes"", ""sayName.executes"", ""int"", 0, 90, """", """", """", """", """"},
-            {""deprecated"", ""sayName.deprecated"", ""boolean"", false, true, """", """", """", """", """"},
-            {""async"", ""sayName.async"", ""boolean"", false, true, """", """", """", """", """"},
-            {""timeout"", ""sayName.timeout"", ""int"", 0, 90, """", """", """", """", """"},
-    };
-    protected DemoService demoService = new DemoServiceImpl();
-    private Object appConfForProviderTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-    private Object appConfForServiceTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-    private Object regConfForProviderTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-    private Object protoConfForProviderTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-    private Object protoConfForServiceTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-
-    // ======================================================
-    //   data table manipulation utils
-    // ====================================================== 
-    protected String genParamString(Object urlKey, Object value) {
-
-        return (String) urlKey + ""="" + value.toString();
-    }
-
-    protected <T> void fillConfigs(T conf, Object[][] table, int column) {
-
-        for (Object[] row : table) {
-            fillConfig(conf, row, column);
-        }
-    }
-
-    protected <T> void fillConfig(T conf, Object[] row, int column) {
-
-        RpcConfigGetSetProxy proxy = new RpcConfigGetSetProxy(conf);
-        proxy.setValue((String) row[KEY], row[column]);
-
-    }
-
-    @SuppressWarnings(""deprecation"")
-    protected void initServConf() {
-
-        appConfForProvider = new ApplicationConfig();
-        appConfForService = new ApplicationConfig();
-        regConfForProvider = new RegistryConfig();
-        regConfForService = new RegistryConfig();
-        provConf = new ProviderConfig();
-        protoConfForProvider = new ProtocolConfig();
-        protoConfForService = new ProtocolConfig();
-        methodConfForService = new MethodConfig();
-        servConf = new ServiceConfig<DemoService>();
-
-        provConf.setApplication(appConfForProvider);
-        servConf.setApplication(appConfForService);
-
-        provConf.setRegistry(regConfForProvider);
-        servConf.setRegistry(regConfForService);
-
-        provConf.setProtocols(Arrays.asList(new ProtocolConfig[]{protoConfForProvider}));
-        servConf.setProtocols(Arrays.asList(new ProtocolConfig[]{protoConfForService}));
-
-        servConf.setMethods(Arrays.asList(new MethodConfig[]{methodConfForService}));
-        servConf.setProvider(provConf);
-
-        servConf.setRef(demoService);
-        servConf.setInterfaceClass(DemoService.class);
-
-        methodConfForService.setName(""sayName"");
-        regConfForService.setAddress(""127.0.0.1:9090"");
-        regConfForService.setProtocol(""mockregistry"");
-        appConfForService.setName(""ConfigTests"");
-    }
-
-    protected String getProviderParamString() {
-        return servConf.getExportedUrls().get(0).toString();
-    }
-
-    /**
-     * @param paramStringFromDb
-     * @param dataTable
-     * @param configName
-     * @param column
-     */
-    protected void assertUrlStringWithLocalTable(String paramStringFromDb,
-                                                 Object[][] dataTable, String configName, int column) {
-        final String FAILLOG_HEADER = ""The following config items are not found in URLONE: "";
-
-        log.warn(""Verifying service url for "" + configName + ""... "");
-        log.warn(""Consumer url string: "" + paramStringFromDb);
-
-        String failLog = FAILLOG_HEADER;
-        for (Object[] row : dataTable) {
-
-            String targetString = genParamString(row[URL_KEY], row[column]);
-
-            log.warn(""Checking "" + (String) row[KEY] + ""for"" + targetString);
-            if (paramStringFromDb.contains(targetString)) {
-                log.warn((String) row[KEY] + "" --> "" + targetString + "" OK!"");
-            } else {
-                failLog += targetString + "", "";
-            }
-        }
-
-        if (!failLog.equals(FAILLOG_HEADER)) {
-            fail(failLog);
-        }
-    }
-
-}
\ No newline at end of file
@@ -1,53 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.utils;
-
-import org.apache.dubbo.config.ReferenceConfig;
-
-import java.util.concurrent.atomic.AtomicLong;
-
-public class MockReferenceConfig extends ReferenceConfig<String> {
-    static AtomicLong counter = new AtomicLong();
-
-    String value;
-    boolean destroyMethodRun = false;
-
-    public static void setCounter(long c) {
-        counter.set(c);
-    }
-
-    public boolean isGetMethodRun() {
-        return value != null;
-    }
-
-    public boolean isDestroyMethodRun() {
-        return destroyMethodRun;
-    }
-
-    @Override
-    public synchronized String get() {
-        if (value != null) return value;
-
-        value = """" + counter.getAndIncrement();
-        return value;
-    }
-
-    @Override
-    public synchronized void destroy() {
-        destroyMethodRun = true;
-    }
-}
@@ -1,114 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.utils;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public class ReferenceConfigCacheTest {
-    @Before
-    public void setUp() throws Exception {
-        MockReferenceConfig.setCounter(0);
-        ReferenceConfigCache.cacheHolder.clear();
-    }
-
-    @Test
-    public void testGetCacheSameReference() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        String value = cache.get(config);
-        assertTrue(config.isGetMethodRun());
-        assertEquals(""0"", value);
-
-        MockReferenceConfig configCopy = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        value = cache.get(configCopy);
-        assertFalse(configCopy.isGetMethodRun());
-        assertEquals(""0"", value);
-    }
-
-    @Test
-    public void testGetCacheDiffReference() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        String value = cache.get(config);
-        assertTrue(config.isGetMethodRun());
-        assertEquals(""0"", value);
-
-        MockReferenceConfig configCopy = buildMockReferenceConfig(""XxxService"", ""group1"", ""1.0.0"");
-        value = cache.get(configCopy);
-        assertTrue(configCopy.isGetMethodRun());
-        assertEquals(""1"", value);
-    }
-
-    @Test
-    public void testGetCacheDiffName() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        String value = cache.get(config);
-        assertTrue(config.isGetMethodRun());
-        assertEquals(""0"", value);
-
-        cache = ReferenceConfigCache.getCache(""foo"");
-        config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        value = cache.get(config);
-        // still init for the same ReferenceConfig if the cache is different
-        assertTrue(config.isGetMethodRun());
-        assertEquals(""1"", value);
-    }
-
-    @Test
-    public void testDestroy() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        cache.get(config);
-        MockReferenceConfig configCopy = buildMockReferenceConfig(""XxxService"", ""group1"", ""1.0.0"");
-        cache.get(configCopy);
-        assertEquals(2, cache.cache.size());
-        cache.destroy(config);
-        assertTrue(config.isDestroyMethodRun());
-        assertEquals(1, cache.cache.size());
-        cache.destroy(configCopy);
-        assertTrue(configCopy.isDestroyMethodRun());
-        assertEquals(0, cache.cache.size());
-    }
-
-    @Test
-    public void testDestroyAll() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        cache.get(config);
-        MockReferenceConfig configCopy = buildMockReferenceConfig(""XxxService"", ""group1"", ""1.0.0"");
-        cache.get(configCopy);
-        assertEquals(2, cache.cache.size());
-        cache.destroyAll();
-        assertTrue(config.isDestroyMethodRun());
-        assertTrue(configCopy.isDestroyMethodRun());
-        assertEquals(0, cache.cache.size());
-    }
-
-    private MockReferenceConfig buildMockReferenceConfig(String service, String group, String version) {
-        MockReferenceConfig config = new MockReferenceConfig();
-        config.setInterface(service);
-        config.setGroup(group);
-        config.setVersion(version);
-        return config;
-    }
-}
@@ -1,106 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.validation;
-
-import javax.validation.constraints.Future;
-import javax.validation.constraints.Max;
-import javax.validation.constraints.Min;
-import javax.validation.constraints.NotNull;
-import javax.validation.constraints.Past;
-import javax.validation.constraints.Pattern;
-import javax.validation.constraints.Size;
-import java.io.Serializable;
-import java.util.Date;
-
-/**
- * ValidationParameter
- */
-public class ValidationParameter implements Serializable {
-
-    private static final long serialVersionUID = 7158911668568000392L;
-
-    @NotNull(groups = ValidationService.Update.class)
-    private Integer id;
-
-    @NotNull
-    @Size(min = 2, max = 20)
-    private String name;
-
-    // not allow to save null, but allow to update with null which means not update the field
-    @NotNull(groups = ValidationService.Save.class)
-    @Pattern(regexp = ""^\\s*\\w+(?:\\.{0,1}[\\w-]+)*@[a-zA-Z0-9]+(?:[-.][a-zA-Z0-9]+)*\\.[a-zA-Z]+\\s*$"")
-    private String email;
-
-    @Min(18)
-    @Max(100)
-    private int age;
-
-    @Past
-    private Date loginDate;
-
-    @Future
-    private Date expiryDate;
-
-    public Integer getId() {
-        return id;
-    }
-
-    public void setId(Integer id) {
-        this.id = id;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getEmail() {
-        return email;
-    }
-
-    public void setEmail(String email) {
-        this.email = email;
-    }
-
-    public int getAge() {
-        return age;
-    }
-
-    public void setAge(int age) {
-        this.age = age;
-    }
-
-    public Date getLoginDate() {
-        return loginDate;
-    }
-
-    public void setLoginDate(Date loginDate) {
-        this.loginDate = loginDate;
-    }
-
-    public Date getExpiryDate() {
-        return expiryDate;
-    }
-
-    public void setExpiryDate(Date expiryDate) {
-        this.expiryDate = expiryDate;
-    }
-
-}
@@ -1,70 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.validation;
-
-import org.apache.dubbo.validation.MethodValidated;
-
-import javax.validation.constraints.Min;
-import javax.validation.constraints.NotNull;
-import javax.validation.constraints.Pattern;
-import javax.validation.constraints.Size;
-
-
-/**
- * ValidationService
- * <p>
- * Use service interface to distinguish validation scenario, for example: @NotNull(groups = ValidationService.class)
- */
-public interface ValidationService {
-
-    /**
-     * The current logic will not verify 'groups = ValidationService.Save.class' if
-     * '@MethodValidated(ValidationService.Save.class)' is not present
-     *
-     * @param parameter
-     */
-    @MethodValidated(Save.class)
-    void save(ValidationParameter parameter);
-
-    void update(ValidationParameter parameter);
-
-    void delete(@Min(1) long id, @NotNull @Size(min = 2, max = 16) @Pattern(regexp = ""^[a-zA-Z]+$"") String operator);
-
-    /**
-     * Assume both id and email are needed to pass in, need to verify Save group and Update group.
-     *
-     * @param parameter
-     */
-    @MethodValidated({Save.class, Update.class})
-    void relatedQuery(ValidationParameter parameter);
-
-    /**
-     * annotation which has the same name with the method but has the first letter in capital
-     * used for distinguish validation scenario, for example: @NotNull(groups = ValidationService.Save.class)
-     * optional
-     */
-    @interface Save {
-    }
-
-    /**
-     * annotation which has the same name with the method but has the first letter in capital
-     * used for distinguish validation scenario, for example: @NotNull(groups = ValidationService.Update.class)
-     * optional
-     */
-    @interface Update {
-    }
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.validation;
-
-/**
- * ValidationServiceImpl
- */
-public class ValidationServiceImpl implements ValidationService {
-
-    public void save(ValidationParameter parameter) {
-    }
-
-    public void update(ValidationParameter parameter) {
-    }
-
-    public void delete(long id, String operator) {
-    }
-
-    public void relatedQuery(ValidationParameter parameter){
-
-    }
-
-}
@@ -1,302 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.validation;
-
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.ProtocolConfig;
-import org.apache.dubbo.config.ReferenceConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.service.GenericException;
-import org.apache.dubbo.rpc.service.GenericService;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import javax.validation.ConstraintViolation;
-import javax.validation.ConstraintViolationException;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * GenericServiceTest
- */
-public class ValidationTest {
-
-    @Test
-    public void testValidation() {
-        ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();
-        service.setApplication(new ApplicationConfig(""validation-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29582));
-        service.setInterface(ValidationService.class.getName());
-        service.setRef(new ValidationServiceImpl());
-        service.setValidation(String.valueOf(true));
-        service.export();
-        try {
-            ReferenceConfig<ValidationService> reference = new ReferenceConfig<ValidationService>();
-            reference.setApplication(new ApplicationConfig(""validation-consumer""));
-            reference.setInterface(ValidationService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29582?scope=remote&validation=true"");
-            ValidationService validationService = reference.get();
-            try {
-                // Save OK
-                ValidationParameter parameter = new ValidationParameter();
-                parameter.setName(""liangfei"");
-                parameter.setEmail(""liangfei@liang.fei"");
-                parameter.setAge(50);
-                parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                validationService.save(parameter);
-
-                try {
-                    parameter = new ValidationParameter();
-                    parameter.setName(""l"");
-                    parameter.setEmail(""liangfei@liang.fei"");
-                    parameter.setAge(50);
-                    parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                    parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                    validationService.save(parameter);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                }
-
-                // verify save group, save error
-                try {
-                    parameter = new ValidationParameter();
-                    parameter.setName(""liangfei"");
-                    parameter.setAge(50);
-                    parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                    parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                    validationService.save(parameter);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                }
-
-                // relatedQuery error, no id and email is passed, will trigger validation exception for both Save
-                // and Update
-                try {
-                    parameter = new ValidationParameter();
-                    parameter.setName(""liangfei"");
-                    parameter.setAge(50);
-                    parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                    parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                    validationService.relatedQuery(parameter);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertEquals(violations.size(),2);
-                }
-
-                // Save Error
-                try {
-                    parameter = new ValidationParameter();
-                    validationService.save(parameter);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertTrue(violations.size() == 3);
-                    Assert.assertNotNull(violations);
-                }
-
-                // Delete OK
-                validationService.delete(2, ""abc"");
-
-                // Delete Error
-                try {
-                    validationService.delete(2, ""a"");
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                    Assert.assertEquals(1, violations.size());
-                }
-
-                // Delete Error
-                try {
-                    validationService.delete(0, ""abc"");
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                    Assert.assertEquals(1, violations.size());
-                }
-                try {
-                    validationService.delete(2, null);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                    Assert.assertEquals(1, violations.size());
-                }
-                try {
-                    validationService.delete(0, null);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                    Assert.assertEquals(2, violations.size());
-                }
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testProviderValidation() {
-        ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();
-        service.setApplication(new ApplicationConfig(""validation-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29582));
-        service.setInterface(ValidationService.class.getName());
-        service.setRef(new ValidationServiceImpl());
-        service.setValidation(String.valueOf(true));
-        service.export();
-        try {
-            ReferenceConfig<ValidationService> reference = new ReferenceConfig<ValidationService>();
-            reference.setApplication(new ApplicationConfig(""validation-consumer""));
-            reference.setInterface(ValidationService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29582"");
-            ValidationService validationService = reference.get();
-            try {
-                // Save OK
-                ValidationParameter parameter = new ValidationParameter();
-                parameter.setName(""liangfei"");
-                parameter.setEmail(""liangfei@liang.fei"");
-                parameter.setAge(50);
-                parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                validationService.save(parameter);
-
-                // Save Error
-                try {
-                    parameter = new ValidationParameter();
-                    validationService.save(parameter);
-                    Assert.fail();
-                } catch (RpcException e) {
-                    Assert.assertTrue(e.getMessage().contains(""ConstraintViolation""));
-                }
-
-                // Delete OK
-                validationService.delete(2, ""abc"");
-
-                // Delete Error
-                try {
-                    validationService.delete(0, ""abc"");
-                    Assert.fail();
-                } catch (RpcException e) {
-                    Assert.assertTrue(e.getMessage().contains(""ConstraintViolation""));
-                }
-                try {
-                    validationService.delete(2, null);
-                    Assert.fail();
-                } catch (RpcException e) {
-                    Assert.assertTrue(e.getMessage().contains(""ConstraintViolation""));
-                }
-                try {
-                    validationService.delete(0, null);
-                    Assert.fail();
-                } catch (RpcException e) {
-                    Assert.assertTrue(e.getMessage().contains(""ConstraintViolation""));
-                }
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testGenericValidation() {
-        ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();
-        service.setApplication(new ApplicationConfig(""validation-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29582));
-        service.setInterface(ValidationService.class.getName());
-        service.setRef(new ValidationServiceImpl());
-        service.setValidation(String.valueOf(true));
-        service.export();
-        try {
-            ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();
-            reference.setApplication(new ApplicationConfig(""validation-consumer""));
-            reference.setInterface(ValidationService.class.getName());
-            reference.setUrl(""dubbo://127.0.0.1:29582?scope=remote&validation=true&timeout=9000000"");
-            reference.setGeneric(true);
-            GenericService validationService = reference.get();
-            try {
-                // Save OK
-                Map<String, Object> parameter = new HashMap<String, Object>();
-                parameter.put(""name"", ""liangfei"");
-                parameter.put(""Email"", ""liangfei@liang.fei"");
-                parameter.put(""Age"", 50);
-                parameter.put(""LoginDate"", new Date(System.currentTimeMillis() - 1000000));
-                parameter.put(""ExpiryDate"", new Date(System.currentTimeMillis() + 1000000));
-                validationService.$invoke(""save"", new String[]{ValidationParameter.class.getName()}, new Object[]{parameter});
-
-                // Save Error
-                try {
-                    parameter = new HashMap<String, Object>();
-                    validationService.$invoke(""save"", new String[]{ValidationParameter.class.getName()}, new Object[]{parameter});
-                    Assert.fail();
-                } catch (GenericException e) {
-                    Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-                }
-
-                // Delete OK
-                validationService.$invoke(""delete"", new String[]{long.class.getName(), String.class.getName()}, new Object[]{2, ""abc""});
-
-                // Delete Error
-                try {
-                    validationService.$invoke(""delete"", new String[]{long.class.getName(), String.class.getName()}, new Object[]{0, ""abc""});
-                    Assert.fail();
-                } catch (GenericException e) {
-                    Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-                }
-                try {
-                    validationService.$invoke(""delete"", new String[]{long.class.getName(), String.class.getName()}, new Object[]{2, null});
-                    Assert.fail();
-                } catch (GenericException e) {
-                    Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-                }
-                try {
-                    validationService.$invoke(""delete"", new String[]{long.class.getName(), String.class.getName()}, new Object[]{0, null});
-                    Assert.fail();
-                } catch (GenericException e) {
-                    Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-                }
-            } catch (GenericException e) {
-                Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-}
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockstatuschecker=org.apache.dubbo.config.mock.MockStatusChecker
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockthreadpool=org.apache.dubbo.config.mock.MockThreadPool
\ No newline at end of file
@@ -1,2 +0,0 @@
-mockregistry=org.apache.dubbo.config.mock.MockRegistryFactory
-mockprotocol2=org.apache.dubbo.config.mock.MockRegistryFactory2
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockcodec=org.apache.dubbo.config.mock.MockCodec
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockdispatcher=org.apache.dubbo.config.mock.MockDispatcher
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mocktransporter=org.apache.dubbo.config.mock.MockTransporter
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockexchanger=org.apache.dubbo.config.mock.MockExchanger
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-mocktelnethandler=org.apache.dubbo.config.mock.MockTelnetHandler
-
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockexporterlistener=org.apache.dubbo.config.mock.MockExporterListener
\ No newline at end of file
@@ -1 +0,0 @@
-mockfilter=org.apache.dubbo.config.mock.MockFilter
\ No newline at end of file
@@ -1 +0,0 @@
-mockinvokerlistener=org.apache.dubbo.config.mock.MockInvokerListener
\ No newline at end of file
@@ -1,2 +0,0 @@
-mockprotocol=org.apache.dubbo.config.mock.MockProtocol
-mockprotocol2=org.apache.dubbo.config.mock.MockProtocol2
\ No newline at end of file
@@ -1,2 +0,0 @@
-mockproxyfactory=org.apache.dubbo.config.mock.MockProxyFactory
-testproxyfactory=org.apache.dubbo.config.mock.TestProxyFactory
\ No newline at end of file
@@ -1 +0,0 @@
-mockcluster=org.apache.dubbo.config.mock.MockCluster
\ No newline at end of file
@@ -1 +0,0 @@
-mockloadbalance=org.apache.dubbo.config.mock.MockLoadBalance
\ No newline at end of file
@@ -1,28 +0,0 @@
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the ""License""); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an ""AS IS"" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-  -->
-<!DOCTYPE log4j:configuration SYSTEM ""log4j.dtd"">
-<log4j:configuration xmlns:log4j=""http://jakarta.apache.org/log4j/"" debug=""false"">
-    <appender name=""CONSOLE"" class=""org.apache.log4j.ConsoleAppender"">
-        <layout class=""org.apache.log4j.PatternLayout"">
-            <param name=""ConversionPattern"" value=""[%d{dd/MM/yy hh:mm:ss:sss z}] %t %5p %c{2}: %m%n""/>
-        </layout>
-    </appender>
-    <root>
-        <level value=""INFO""/>
-        <appender-ref ref=""CONSOLE""/>
-    </root>
-</log4j:configuration>
\ No newline at end of file
"
https://github.com/junit-team/junit4/commit/46036e7146f9dd0ca44baaec490692b967edd0ce,"javadoc'ed, and with better names ",https://api.github.com/repos/junit-team/junit4/commits/46036e7146f9dd0ca44baaec490692b967edd0ce,"@@ -0,0 +1,112 @@
+/**
+ * 
+ */
+package org.junit.experimental.categories;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import org.junit.runner.Description;
+import org.junit.runner.manipulation.Filter;
+import org.junit.runner.manipulation.NoTestsRemainException;
+import org.junit.runners.Suite;
+import org.junit.runners.model.InitializationError;
+import org.junit.runners.model.RunnerBuilder;
+
+/**
+ * From a given set of test classes, runs only the classes and methods
+ * that are annotated with either the category given with the @IncludeCategory
+ * annotation, or a subtype of that category.
+ * 
+ * Example:
+<pre>
+	public interface FastTests extends CategoryType {}
+	public interface SlowTests extends CategoryType {}
+
+	public static class A {
+		@Test
+		public void a() {
+			fail();
+		}
+
+		@Category(SlowTests.class)
+		@Test
+		public void b() {
+		}
+	}
+
+	@Category({SlowTests.class, FastTests.class})
+	public static class B {
+		@Test
+		public void c() {
+
+		}
+	}
+
+	@RunWith(Categories.class)
+	@IncludeCategory(SlowTests.class)
+	@SuiteClasses( { A.class, B.class }) // Note that Categories is a kind of Suite
+	public static class SlowTestSuite {}
+</pre>
+ */
+public class Categories extends Suite {
+	@Retention(RetentionPolicy.RUNTIME)
+	public @interface IncludeCategory {
+		public Class<? extends CategoryType> value();
+	}
+	
+	public static class CategoryFilter extends Filter {
+		public static CategoryFilter include(
+				Class<? extends CategoryType> categoryClass) {
+			return new CategoryFilter(categoryClass);
+		}
+
+		private final Class<? extends CategoryType> fCategoryClass;
+
+		public CategoryFilter(Class<? extends CategoryType> categoryClass) {
+			fCategoryClass= categoryClass;
+		}
+
+		@Override
+		public String describe() {
+			return ""category "" + fCategoryClass;
+		}
+
+		@Override
+		public boolean shouldRun(Description description) {
+			if (hasCorrectCategoryAnnotation(description))
+				return true;
+
+			// TODO: feels as if we've done this child crawl several times.
+			// Change design?
+			for (Description each : description.getChildren())
+				if (shouldRun(each))
+					return true;
+			return false;
+		}
+
+		private boolean hasCorrectCategoryAnnotation(Description description) {
+			Category annotation= description.getAnnotation(Category.class);
+			if (annotation == null)
+				return false;
+			for (Class<? extends CategoryType> each : annotation.value())
+				if (fCategoryClass.isAssignableFrom(each))
+					return true;
+			return false;
+		}
+	}
+
+	public Categories(Class<?> klass, RunnerBuilder builder)
+			throws InitializationError {
+		super(klass, builder);
+		try {
+			filter(new CategoryFilter(getCategory(klass)));
+		} catch (NoTestsRemainException e) {
+			throw new InitializationError(e);
+		}
+	}
+
+	private Class<? extends CategoryType> getCategory(Class<?> klass) {
+		return klass.getAnnotation(IncludeCategory.class).value();
+	}
+}
\ No newline at end of file
@@ -1,12 +1,44 @@
-/**
- * 
- */
 package org.junit.experimental.categories;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
+/**
+ * Marks a test class or test method as belonging to one or more categories of tests.
+ * The value is an array of interface classes that extend the {@link CategoryType}
+ * superinterface.
+ * 
+ * This annotation is only interpreted by the Categories runner (at present).
+ * 
+ * For example:
+<pre>
+	public interface FastTests extends CategoryType {}
+	public interface SlowTests extends CategoryType {}
+
+	public static class A {
+		@Test
+		public void a() {
+			fail();
+		}
+
+		@Category(SlowTests.class)
+		@Test
+		public void b() {
+		}
+	}
+
+	@Category({SlowTests.class, FastTests.class})
+	public static class B {
+		@Test
+		public void c() {
+
+		}
+	}
+</pre>
+ * 
+ * For more usage, see code example on {@link Categories}.
+ */
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Category {
-	Class<? extends CategoryClass>[] value();
+	Class<? extends CategoryType>[] value();
 }
\ No newline at end of file
@@ -0,0 +1,11 @@
+package org.junit.experimental.categories;
+
+/**
+ * Super-interface for all interface classes that are used to represent
+ * categories.  Representing categories as types allows compile-time
+ * checking of typos in category names, preventing accidental test
+ * exclusion.
+ */
+public interface CategoryType {
+
+}
\ No newline at end of file
@@ -8,10 +8,10 @@
 import static org.junit.experimental.results.ResultMatchers.isSuccessful;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import org.junit.experimental.categories.CategoryClass;
-import org.junit.experimental.categories.CategoryRunner;
-import org.junit.experimental.categories.CategoryRunner.CategoryFilter;
-import org.junit.experimental.categories.CategoryRunner.IncludeCategory;
+import org.junit.experimental.categories.CategoryType;
+import org.junit.experimental.categories.Categories;
+import org.junit.experimental.categories.Categories.CategoryFilter;
+import org.junit.experimental.categories.Categories.IncludeCategory;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Request;
 import org.junit.runner.Result;
@@ -23,11 +23,11 @@
 import org.junit.runners.model.InitializationError;
 
 public class CategoryTest {
-	public static interface FastTests extends CategoryClass {
+	public interface FastTests extends CategoryType {
 
 	}
 
-	public interface SlowTests extends CategoryClass {
+	public interface SlowTests extends CategoryType {
 
 	}
 
@@ -58,7 +58,13 @@ public void d() {
 		}
 	}
 
-	@RunWith(CategoryRunner.class)
+	@RunWith(Categories.class)
+	@IncludeCategory(SlowTests.class)
+	@SuiteClasses( { A.class, B.class, C.class })
+	public static class SlowTestSuite {
+	}
+
+	@RunWith(Categories.class)
 	@IncludeCategory(SlowTests.class)
 	@SuiteClasses( { A.class })
 	public static class JustA {
@@ -69,12 +75,6 @@ public void testCountOnJustA() {
 		assertThat(testResult(JustA.class), isSuccessful());
 	}
 
-	@RunWith(CategoryRunner.class)
-	@IncludeCategory(SlowTests.class)
-	@SuiteClasses( { A.class, B.class, C.class })
-	public static class SlowTestSuite {
-	}
-
 	@Test
 	public void testCount() {
 		assertThat(testResult(SlowTestSuite.class), isSuccessful());
@@ -134,7 +134,7 @@ public void a() {
 		}
 	}
 
-	@RunWith(CategoryRunner.class)
+	@RunWith(Categories.class)
 	@IncludeCategory(SlowTests.class)
 	@SuiteClasses( { OneFast.class })
 	public static class OneFastSuite {
@@ -161,7 +161,7 @@ public void a() {
 		}
 	}
 
-	@RunWith(CategoryRunner.class)
+	@RunWith(Categories.class)
 	@IncludeCategory(SlowTests.class)
 	@SuiteClasses( { OneThatIsBothFastAndSlow.class })
 	public static class ChooseSlowFromBoth {
@@ -183,7 +183,7 @@ public void a() {
 		}
 	}
 
-	@RunWith(CategoryRunner.class)
+	@RunWith(Categories.class)
 	@IncludeCategory(SlowTests.class)
 	@SuiteClasses( { OneVerySlowTest.class })
 	public static class RunSlowFromVerySlow {
"
https://github.com/spring-projects/spring-boot/commit/9d4ada793902c15f6b62ae0dd4ad45ca0ef5b197,"Add Tomcat 7 and Jetty 8 samples  <enter> Switch the Tomcat 8 and Jetty 9 samples to Tomcat 7 and Jetty 8. Since Tomcat 8 and Jetty 9 are now the default versions the previous samples are no longer relevant, however, we do need integration tests to check that we remain compatible with Tomcat 7 and Jetty 8. <enter> See  <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/9d4ada793902c15f6b62ae0dd4ad45ca0ef5b197,
https://github.com/apache/dubbo/commit/81e61cc5c3d83b716ca2e712ccdc444c0fff208a,remove unnecessary null check  before instance of (#4321) <enter>  <enter> Signed-off-by: jimin.jm <slievrly@163.com>,https://api.github.com/repos/apache/dubbo/commits/81e61cc5c3d83b716ca2e712ccdc444c0fff208a,"@@ -237,12 +237,12 @@ private static void deserializeInternal(Object result, JavaBeanDescriptor beanDe
             for (Map.Entry<Object, Object> entry : beanDescriptor) {
                 Object key = entry.getKey();
                 Object value = entry.getValue();
-                if (key != null && key instanceof JavaBeanDescriptor) {
+                if (key instanceof JavaBeanDescriptor) {
                     JavaBeanDescriptor keyDescriptor = (JavaBeanDescriptor) entry.getKey();
                     key = instantiateForDeserialize(keyDescriptor, loader, cache);
                     deserializeInternal(key, keyDescriptor, loader, cache);
                 }
-                if (value != null && value instanceof JavaBeanDescriptor) {
+                if (value instanceof JavaBeanDescriptor) {
                     JavaBeanDescriptor valueDescriptor = (JavaBeanDescriptor) entry.getValue();
                     value = instantiateForDeserialize(valueDescriptor, loader, cache);
                     deserializeInternal(value, valueDescriptor, loader, cache);
@@ -47,7 +47,7 @@ public Object get(int index) {
      */
     public boolean getBoolean(int index, boolean def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Boolean ? ((Boolean) tmp).booleanValue() : def;
+        return tmp instanceof Boolean ? ((Boolean) tmp).booleanValue() : def;
     }
 
     /**
@@ -59,7 +59,7 @@ public boolean getBoolean(int index, boolean def) {
      */
     public int getInt(int index, int def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).intValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).intValue() : def;
     }
 
     /**
@@ -71,7 +71,7 @@ public int getInt(int index, int def) {
      */
     public long getLong(int index, long def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).longValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).longValue() : def;
     }
 
     /**
@@ -83,7 +83,7 @@ public long getLong(int index, long def) {
      */
     public float getFloat(int index, float def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).floatValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).floatValue() : def;
     }
 
     /**
@@ -95,7 +95,7 @@ public float getFloat(int index, float def) {
      */
     public double getDouble(int index, double def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).doubleValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).doubleValue() : def;
     }
 
     /**
@@ -47,7 +47,7 @@ public Object get(String key) {
      */
     public boolean getBoolean(String key, boolean def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Boolean ? (Boolean) tmp : def;
+        return tmp instanceof Boolean ? (Boolean) tmp : def;
     }
 
     /**
@@ -59,7 +59,7 @@ public boolean getBoolean(String key, boolean def) {
      */
     public int getInt(String key, int def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).intValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).intValue() : def;
     }
 
     /**
@@ -71,7 +71,7 @@ public int getInt(String key, int def) {
      */
     public long getLong(String key, long def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).longValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).longValue() : def;
     }
 
     /**
@@ -83,7 +83,7 @@ public long getLong(String key, long def) {
      */
     public float getFloat(String key, float def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).floatValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).floatValue() : def;
     }
 
     /**
@@ -95,7 +95,7 @@ public float getFloat(String key, float def) {
      */
     public double getDouble(String key, double def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).doubleValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).doubleValue() : def;
     }
 
     /**
@@ -90,7 +90,7 @@ public void setReg(boolean reg) {
 
     @Override
     public boolean equals(Object o) {
-        if (o == null || !(o instanceof ProviderInvokerWrapper)) {
+        if (!(o instanceof ProviderInvokerWrapper)) {
             return false;
         }
         ProviderInvokerWrapper other = (ProviderInvokerWrapper) o;
@@ -27,7 +27,7 @@ final class NettyHelper {
 
     public static void setNettyLoggerFactory() {
         InternalLoggerFactory factory = InternalLoggerFactory.getDefaultFactory();
-        if (factory == null || !(factory instanceof DubboLoggerFactory)) {
+        if (!(factory instanceof DubboLoggerFactory)) {
             InternalLoggerFactory.setDefaultFactory(new DubboLoggerFactory());
         }
     }
@@ -452,7 +452,7 @@ private ByteBuf createDubboByteBuf() throws IOException {
     }
 
     private static boolean checkTelnetDecoded(Object msg) {
-        if (msg != null && msg instanceof String && !msg.toString().contains(""Unsupported command:"")) {
+        if (msg instanceof String && !msg.toString().contains(""Unsupported command:"")) {
             return true;
         }
         return false;
"
https://github.com/spring-projects/spring-boot/commit/9a9111af2132ff50afe4aa0704be4bce19cf76fa,"Support path discovery for main dispatcher servlet  <enter> Add an `DispatcherServletPath` interface which provides a much more consistent way to discover the path of the main dispatcher servet. <enter> Prior to this commit, auto-configurations would often make use of the `ServerProperties` class to discover the dispatcher servlet path. This mechanism isn't very explicit and also makes it hard for us to relocate that property in Spring Boot 2.1. <enter> This commit also reverts most of  <otherCommit_link>  since it is now clear that the supporting multiple dispatcher servlet paths will be much more involved that we originally anticipated. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/9a9111af2132ff50afe4aa0704be4bce19cf76fa,"@@ -16,9 +16,6 @@
 
 package org.springframework.boot.actuate.autoconfigure.endpoint.web;
 
-import java.util.Set;
-import java.util.stream.Collectors;
-
 import org.glassfish.jersey.server.ResourceConfig;
 
 import org.springframework.boot.actuate.autoconfigure.endpoint.ExposeExcludePropertyEndpointFilter;
@@ -30,11 +27,10 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
-import org.springframework.util.StringUtils;
 import org.springframework.web.servlet.DispatcherServlet;
 
 /**
@@ -72,27 +68,13 @@ public WebMvcServletEndpointManagementContextConfiguration(
 		public ServletEndpointRegistrar servletEndpointRegistrar(
 				WebEndpointProperties properties,
 				ServletEndpointsSupplier servletEndpointsSupplier) {
-			DispatcherServletPathProvider servletPathProvider = this.context
-					.getBean(DispatcherServletPathProvider.class);
-			Set<String> cleanedPaths = getServletPaths(properties, servletPathProvider);
-			return new ServletEndpointRegistrar(cleanedPaths,
+			DispatcherServletPath dispatcherServletPath = this.context
+					.getBean(DispatcherServletPath.class);
+			return new ServletEndpointRegistrar(
+					dispatcherServletPath.getRelativePath(properties.getBasePath()),
 					servletEndpointsSupplier.getEndpoints());
 		}
 
-		private Set<String> getServletPaths(WebEndpointProperties properties,
-				DispatcherServletPathProvider servletPathProvider) {
-			return servletPathProvider.getServletPaths().stream()
-					.map((p) -> cleanServletPath(p) + properties.getBasePath())
-					.collect(Collectors.toSet());
-		}
-
-		private String cleanServletPath(String servletPath) {
-			if (StringUtils.hasText(servletPath) && servletPath.endsWith(""/"")) {
-				return servletPath.substring(0, servletPath.length() - 1);
-			}
-			return servletPath;
-		}
-
 	}
 
 	@Configuration
@@ -33,7 +33,7 @@
 import org.springframework.boot.actuate.autoconfigure.endpoint.web.WebEndpointProperties;
 import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
 import org.springframework.boot.actuate.endpoint.web.PathMappedEndpoints;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.security.servlet.ApplicationContextRequestMatcher;
 import org.springframework.core.annotation.AnnotatedElementUtils;
 import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
@@ -137,23 +137,20 @@ protected final boolean matches(HttpServletRequest request,
 
 		private RequestMatcher createDelegate(WebApplicationContext context) {
 			try {
-				Set<String> servletPaths = getServletPaths(context);
-				RequestMatcherFactory requestMatcherFactory = new RequestMatcherFactory(
-						servletPaths);
-				return createDelegate(context, requestMatcherFactory);
+				String pathPrefix = getPathPrefix(context);
+				return createDelegate(context, new RequestMatcherFactory(pathPrefix));
 			}
 			catch (NoSuchBeanDefinitionException ex) {
 				return EMPTY_MATCHER;
 			}
 		}
 
-		private Set<String> getServletPaths(WebApplicationContext context) {
+		private String getPathPrefix(WebApplicationContext context) {
 			try {
-				return context.getBean(DispatcherServletPathProvider.class)
-						.getServletPaths();
+				return context.getBean(DispatcherServletPath.class).getPrefix();
 			}
 			catch (NoSuchBeanDefinitionException ex) {
-				return Collections.singleton("""");
+				return """";
 			}
 		}
 
@@ -225,7 +222,7 @@ protected RequestMatcher createDelegate(WebApplicationContext context,
 					requestMatcherFactory, paths);
 			if (this.includeLinks
 					&& StringUtils.hasText(pathMappedEndpoints.getBasePath())) {
-				delegateMatchers.addAll(
+				delegateMatchers.add(
 						requestMatcherFactory.antPath(pathMappedEndpoints.getBasePath()));
 			}
 			return new OrRequestMatcher(delegateMatchers);
@@ -258,8 +255,7 @@ private String getEndpointId(Class<?> source) {
 		private List<RequestMatcher> getDelegateMatchers(
 				RequestMatcherFactory requestMatcherFactory, Set<String> paths) {
 			return paths.stream()
-					.flatMap(
-							(path) -> requestMatcherFactory.antPath(path, ""/**"").stream())
+					.map((path) -> requestMatcherFactory.antPath(path, ""/**""))
 					.collect(Collectors.toList());
 		}
 
@@ -276,9 +272,7 @@ protected RequestMatcher createDelegate(WebApplicationContext context,
 			WebEndpointProperties properties = context
 					.getBean(WebEndpointProperties.class);
 			if (StringUtils.hasText(properties.getBasePath())) {
-				List<RequestMatcher> matchers = requestMatcherFactory
-						.antPath(properties.getBasePath());
-				return new OrRequestMatcher(matchers);
+				return requestMatcherFactory.antPath(properties.getBasePath());
 			}
 			return EMPTY_MATCHER;
 		}
@@ -290,19 +284,18 @@ protected RequestMatcher createDelegate(WebApplicationContext context,
 	 */
 	private static class RequestMatcherFactory {
 
-		private final Set<String> servletPaths = new LinkedHashSet<>();
+		private final String prefix;
 
-		RequestMatcherFactory(Set<String> servletPaths) {
-			this.servletPaths.addAll(servletPaths);
+		RequestMatcherFactory(String prefix) {
+			this.prefix = prefix;
 		}
 
-		List<RequestMatcher> antPath(String... parts) {
-			return this.servletPaths.stream()
-					.map((p) -> (StringUtils.hasText(p) && !p.equals(""/"") ? p : """"))
-					.distinct()
-					.map((path) -> Arrays.stream(parts)
-							.collect(Collectors.joining("""", path, """")))
-					.map(AntPathRequestMatcher::new).collect(Collectors.toList());
+		public RequestMatcher antPath(String... parts) {
+			String pattern = this.prefix;
+			for (String part : parts) {
+				pattern += part;
+			}
+			return new AntPathRequestMatcher(pattern);
 		}
 
 	}
@@ -16,8 +16,6 @@
 
 package org.springframework.boot.actuate.autoconfigure.web.servlet;
 
-import java.util.Collections;
-
 import org.springframework.beans.factory.ListableBeanFactory;
 import org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration;
 import org.springframework.boot.actuate.autoconfigure.web.ManagementContextType;
@@ -27,7 +25,7 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;
 import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;
 import org.springframework.boot.web.servlet.error.ErrorAttributes;
 import org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter;
 import org.springframework.context.annotation.Bean;
@@ -72,6 +70,12 @@ public DispatcherServlet dispatcherServlet() {
 		return dispatcherServlet;
 	}
 
+	@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
+	public DispatcherServletRegistrationBean dispatcherServletRegistrationBean(
+			DispatcherServlet dispatcherServlet) {
+		return new DispatcherServletRegistrationBean(dispatcherServlet, ""/"");
+	}
+
 	@Bean(name = DispatcherServlet.HANDLER_MAPPING_BEAN_NAME)
 	public CompositeHandlerMapping compositeHandlerMapping() {
 		return new CompositeHandlerMapping();
@@ -95,9 +99,4 @@ public RequestContextFilter requestContextFilter() {
 		return new OrderedRequestContextFilter();
 	}
 
-	@Bean
-	public DispatcherServletPathProvider childDispatcherServletPathProvider() {
-		return () -> Collections.singleton("""");
-	}
-
 }
@@ -17,15 +17,13 @@
 package org.springframework.boot.actuate.autoconfigure.endpoint.web;
 
 import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Set;
 
 import org.glassfish.jersey.server.ResourceConfig;
 import org.junit.Test;
 
 import org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar;
 import org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.boot.test.context.FilteredClassLoader;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;
@@ -50,32 +48,27 @@ public class ServletEndpointManagementContextConfigurationTests {
 			.withUserConfiguration(TestConfig.class);
 
 	@Test
-	@SuppressWarnings(""unchecked"")
 	public void contextShouldContainServletEndpointRegistrar() {
 		FilteredClassLoader classLoader = new FilteredClassLoader(ResourceConfig.class);
 		this.contextRunner.withClassLoader(classLoader).run((context) -> {
 			assertThat(context).hasSingleBean(ServletEndpointRegistrar.class);
 			ServletEndpointRegistrar bean = context
 					.getBean(ServletEndpointRegistrar.class);
-			Set<String> basePaths = (Set<String>) ReflectionTestUtils.getField(bean,
-					""basePaths"");
-			assertThat(basePaths).containsExactlyInAnyOrder(""/test/actuator"", ""/actuator"",
-					""/foo/actuator"");
+			String basePath = (String) ReflectionTestUtils.getField(bean, ""basePath"");
+			assertThat(basePath).isEqualTo(""/test/actuator"");
 		});
 	}
 
 	@Test
-	@SuppressWarnings(""unchecked"")
 	public void servletPathShouldNotAffectJerseyConfiguration() {
 		FilteredClassLoader classLoader = new FilteredClassLoader(
 				DispatcherServlet.class);
 		this.contextRunner.withClassLoader(classLoader).run((context) -> {
 			assertThat(context).hasSingleBean(ServletEndpointRegistrar.class);
 			ServletEndpointRegistrar bean = context
 					.getBean(ServletEndpointRegistrar.class);
-			Set<String> basePaths = (Set<String>) ReflectionTestUtils.getField(bean,
-					""basePaths"");
-			assertThat(basePaths).containsExactly(""/actuator"");
+			String basePath = (String) ReflectionTestUtils.getField(bean, ""basePath"");
+			assertThat(basePath).isEqualTo(""/actuator"");
 		});
 	}
 
@@ -97,14 +90,8 @@ public ServletEndpointsSupplier servletEndpointsSupplier() {
 		}
 
 		@Bean
-		public DispatcherServletPathProvider servletPathProvider() {
-			return () -> {
-				Set<String> paths = new LinkedHashSet<>();
-				paths.add(""/"");
-				paths.add(""/test"");
-				paths.add(""/foo/"");
-				return paths;
-			};
+		public DispatcherServletPath dispatcherServletPath() {
+			return () -> ""/test"";
 		}
 
 	}
@@ -17,8 +17,6 @@
 package org.springframework.boot.actuate.autoconfigure.security.servlet;
 
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
 import java.util.List;
 
 import javax.servlet.http.HttpServletRequest;
@@ -33,7 +31,7 @@
 import org.springframework.boot.actuate.endpoint.web.PathMappedEndpoint;
 import org.springframework.boot.actuate.endpoint.web.PathMappedEndpoints;
 import org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.mock.web.MockHttpServletRequest;
 import org.springframework.mock.web.MockServletContext;
 import org.springframework.security.web.util.matcher.RequestMatcher;
@@ -78,12 +76,11 @@ public void toAnyEndpointShouldNotMatchOtherPath() {
 	@Test
 	public void toAnyEndpointWhenServletPathNotEmptyShouldMatch() {
 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
-		assertMatcher(matcher, ""/actuator"", ""/spring"", ""/admin"")
-				.matches(Arrays.asList(""/spring"", ""/admin""), ""/actuator/foo"");
-		assertMatcher(matcher, ""/actuator"", ""/spring"", ""/admin"")
-				.matches(Arrays.asList(""/spring"", ""/admin""), ""/actuator/bar"");
-		assertMatcher(matcher, ""/actuator"", ""/spring"").matches(Arrays.asList(""/spring""),
-				""/actuator"");
+		assertMatcher(matcher, ""/actuator"", ""/spring"").matches(""/spring"",
+				""/actuator/foo"");
+		assertMatcher(matcher, ""/actuator"", ""/spring"").matches(""/spring"",
+				""/actuator/bar"");
+		assertMatcher(matcher, ""/actuator"", ""/spring"").matches(""/spring"", ""/actuator"");
 		assertMatcher(matcher, ""/actuator"", ""/spring"").doesNotMatch(""/spring"",
 				""/actuator/baz"");
 		assertMatcher(matcher, ""/actuator"", ""/spring"").doesNotMatch("""", ""/actuator/foo"");
@@ -92,10 +89,10 @@ public void toAnyEndpointWhenServletPathNotEmptyShouldMatch() {
 	@Test
 	public void toAnyEndpointWhenDispatcherServletPathProviderNotAvailableUsesEmptyPath() {
 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
-		assertMatcher(matcher, ""/actuator"", (String) null).matches(""/actuator/foo"");
-		assertMatcher(matcher, ""/actuator"", (String) null).matches(""/actuator/bar"");
-		assertMatcher(matcher, ""/actuator"", (String) null).matches(""/actuator"");
-		assertMatcher(matcher, ""/actuator"", (String) null).doesNotMatch(""/actuator/baz"");
+		assertMatcher(matcher, ""/actuator"", null).matches(""/actuator/foo"");
+		assertMatcher(matcher, ""/actuator"", null).matches(""/actuator/bar"");
+		assertMatcher(matcher, ""/actuator"", null).matches(""/actuator"");
+		assertMatcher(matcher, ""/actuator"", null).doesNotMatch(""/actuator/baz"");
 	}
 
 	@Test
@@ -222,8 +219,8 @@ private RequestMatcherAssert assertMatcher(RequestMatcher matcher, String basePa
 	}
 
 	private RequestMatcherAssert assertMatcher(RequestMatcher matcher, String basePath,
-			String... servletPaths) {
-		return assertMatcher(matcher, mockPathMappedEndpoints(basePath), servletPaths);
+			String servletPath) {
+		return assertMatcher(matcher, mockPathMappedEndpoints(basePath), servletPath);
 	}
 
 	private PathMappedEndpoints mockPathMappedEndpoints(String basePath) {
@@ -246,7 +243,7 @@ private RequestMatcherAssert assertMatcher(RequestMatcher matcher,
 	}
 
 	private RequestMatcherAssert assertMatcher(RequestMatcher matcher,
-			PathMappedEndpoints pathMappedEndpoints, String... servletPaths) {
+			PathMappedEndpoints pathMappedEndpoints, String dispatcherServletPath) {
 		StaticWebApplicationContext context = new StaticWebApplicationContext();
 		context.registerBean(WebEndpointProperties.class);
 		if (pathMappedEndpoints != null) {
@@ -257,10 +254,9 @@ private RequestMatcherAssert assertMatcher(RequestMatcher matcher,
 				properties.setBasePath(pathMappedEndpoints.getBasePath());
 			}
 		}
-		if (servletPaths != null) {
-			DispatcherServletPathProvider pathProvider = () -> new LinkedHashSet<>(
-					Arrays.asList(servletPaths));
-			context.registerBean(DispatcherServletPathProvider.class, () -> pathProvider);
+		if (dispatcherServletPath != null) {
+			DispatcherServletPath path = () -> dispatcherServletPath;
+			context.registerBean(DispatcherServletPath.class, () -> path);
 		}
 		return assertThat(new RequestMatcherAssert(context, matcher));
 	}
@@ -280,8 +276,8 @@ public void matches(String servletPath) {
 			matches(mockRequest(servletPath));
 		}
 
-		public void matches(List<String> servletPaths, String pathInfo) {
-			servletPaths.forEach((p) -> matches(mockRequest(p, pathInfo)));
+		public void matches(String servletPath, String pathInfo) {
+			matches(mockRequest(servletPath, pathInfo));
 		}
 
 		private void matches(HttpServletRequest request) {
@@ -18,7 +18,7 @@
 
 import org.junit.Test;
 
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.test.context.runner.WebApplicationContextRunner;
 import org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter;
 import org.springframework.context.annotation.Bean;
@@ -64,12 +64,12 @@ public void contextShouldNotConfigureRequestContextFilterWhenRequestContextListe
 	}
 
 	@Test
-	public void contextShouldConfigureDispatcherServletPathProviderWithEmptyPath() {
+	public void contextShouldConfigureDispatcherServletPathWithRootPath() {
 		this.contextRunner
 				.withUserConfiguration(WebMvcEndpointChildContextConfiguration.class)
-				.run((context) -> assertThat(context
-						.getBean(DispatcherServletPathProvider.class).getServletPaths())
-								.containsExactly(""""));
+				.run((context) -> assertThat(
+						context.getBean(DispatcherServletPath.class).getPath())
+								.isEqualTo(""/""));
 	}
 
 	static class ExistingConfig {
@@ -16,10 +16,7 @@
 
 package org.springframework.boot.actuate.endpoint.web;
 
-import java.util.Arrays;
 import java.util.Collection;
-import java.util.LinkedHashSet;
-import java.util.Set;
 
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
@@ -30,7 +27,6 @@
 
 import org.springframework.boot.web.servlet.ServletContextInitializer;
 import org.springframework.util.Assert;
-import org.springframework.util.CollectionUtils;
 
 /**
  * {@link ServletContextInitializer} to register {@link ExposableServletEndpoint servlet
@@ -44,24 +40,14 @@ public class ServletEndpointRegistrar implements ServletContextInitializer {
 
 	private static final Log logger = LogFactory.getLog(ServletEndpointRegistrar.class);
 
-	private final Set<String> basePaths = new LinkedHashSet<>();
+	private final String basePath;
 
 	private final Collection<ExposableServletEndpoint> servletEndpoints;
 
 	public ServletEndpointRegistrar(String basePath,
 			Collection<ExposableServletEndpoint> servletEndpoints) {
 		Assert.notNull(servletEndpoints, ""ServletEndpoints must not be null"");
-		this.basePaths.add((basePath != null ? basePath : """"));
-		this.servletEndpoints = servletEndpoints;
-	}
-
-	public ServletEndpointRegistrar(Set<String> basePaths,
-			Collection<ExposableServletEndpoint> servletEndpoints) {
-		Assert.notNull(servletEndpoints, ""ServletEndpoints must not be null"");
-		this.basePaths.addAll(basePaths);
-		if (CollectionUtils.isEmpty(this.basePaths)) {
-			this.basePaths.add("""");
-		}
+		this.basePath = (basePath != null ? basePath : """");
 		this.servletEndpoints = servletEndpoints;
 	}
 
@@ -74,24 +60,14 @@ public void onStartup(ServletContext servletContext) throws ServletException {
 	private void register(ServletContext servletContext,
 			ExposableServletEndpoint endpoint) {
 		String name = endpoint.getId() + ""-actuator-endpoint"";
+		String path = this.basePath + ""/"" + endpoint.getRootPath();
+		String urlMapping = (path.endsWith(""/"") ? path + ""*"" : path + ""/*"");
 		EndpointServlet endpointServlet = endpoint.getEndpointServlet();
 		Dynamic registration = servletContext.addServlet(name,
 				endpointServlet.getServlet());
-		String[] urlMappings = getUrlMappings(endpoint.getRootPath());
-		registration.addMapping(urlMappings);
-		if (logger.isInfoEnabled()) {
-			Arrays.stream(urlMappings).forEach(
-					(mapping) -> logger.info(""Registered '"" + mapping + ""' to "" + name));
-		}
+		registration.addMapping(urlMapping);
 		registration.setInitParameters(endpointServlet.getInitParameters());
-	}
-
-	private String[] getUrlMappings(String endpointPath) {
-		return this.basePaths.stream()
-				.map((basePath) -> (basePath != null ? basePath + ""/"" + endpointPath
-						: ""/"" + endpointPath))
-				.distinct().map((path) -> (path.endsWith(""/"") ? path + ""*"" : path + ""/*""))
-				.toArray(String[]::new);
+		logger.info(""Registered '"" + path + ""' to "" + name);
 	}
 
 }
@@ -18,8 +18,6 @@
 
 import java.io.IOException;
 import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Set;
 
 import javax.servlet.GenericServlet;
 import javax.servlet.Servlet;
@@ -49,7 +47,6 @@
  * Tests for {@link ServletEndpointRegistrar}.
  *
  * @author Phillip Webb
- * @author Madhura Bhave
  */
 public class ServletEndpointRegistrarTests {
 
@@ -76,14 +73,14 @@ public void setup() {
 	public void createWhenServletEndpointsIsNullShouldThrowException() {
 		this.thrown.expect(IllegalArgumentException.class);
 		this.thrown.expectMessage(""ServletEndpoints must not be null"");
-		new ServletEndpointRegistrar((String) null, null);
+		new ServletEndpointRegistrar(null, null);
 	}
 
 	@Test
 	public void onStartupShouldRegisterServlets() throws Exception {
 		ExposableServletEndpoint endpoint = mockEndpoint(
 				new EndpointServlet(TestServlet.class));
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar((String) null,
+		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(null,
 				Collections.singleton(endpoint));
 		registrar.onStartup(this.servletContext);
 		verify(this.servletContext).addServlet(eq(""test-actuator-endpoint""),
@@ -105,64 +102,6 @@ public void onStartupWhenHasBasePathShouldIncludeBasePath() throws Exception {
 		verify(this.dynamic).addMapping(""/actuator/test/*"");
 	}
 
-	@Test
-	public void onStartupWhenHasMultipleBasePathsShouldIncludeAllBasePaths()
-			throws Exception {
-		ExposableServletEndpoint endpoint = mockEndpoint(
-				new EndpointServlet(TestServlet.class));
-		Set<String> basePaths = new LinkedHashSet<>();
-		basePaths.add(""/actuator"");
-		basePaths.add(""/admin"");
-		basePaths.add(""/application"");
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePaths,
-				Collections.singleton(endpoint));
-		registrar.onStartup(this.servletContext);
-		verify(this.servletContext).addServlet(eq(""test-actuator-endpoint""),
-				this.servlet.capture());
-		assertThat(this.servlet.getValue()).isInstanceOf(TestServlet.class);
-		ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
-		verify(this.dynamic).addMapping(captor.capture());
-		assertThat(captor.getAllValues()).containsExactlyInAnyOrder(""/application/test/*"",
-				""/admin/test/*"", ""/actuator/test/*"");
-	}
-
-	@Test
-	public void onStartupWhenHasEmptyBasePathsShouldIncludeRoot() throws Exception {
-		ExposableServletEndpoint endpoint = mockEndpoint(
-				new EndpointServlet(TestServlet.class));
-		Set<String> basePaths = Collections.emptySet();
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePaths,
-				Collections.singleton(endpoint));
-		registrar.onStartup(this.servletContext);
-		verify(this.dynamic).addMapping(""/test/*"");
-	}
-
-	@Test
-	public void onStartupWhenHasBasePathsHasNullValueShouldIncludeRoot()
-			throws Exception {
-		ExposableServletEndpoint endpoint = mockEndpoint(
-				new EndpointServlet(TestServlet.class));
-		Set<String> basePaths = new LinkedHashSet<>();
-		basePaths.add(null);
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePaths,
-				Collections.singleton(endpoint));
-		registrar.onStartup(this.servletContext);
-		verify(this.dynamic).addMapping(""/test/*"");
-	}
-
-	@Test
-	public void onStartupWhenDuplicateValuesShouldIncludeDistinct() throws Exception {
-		ExposableServletEndpoint endpoint = mockEndpoint(
-				new EndpointServlet(TestServlet.class));
-		Set<String> basePaths = new LinkedHashSet<>();
-		basePaths.add("""");
-		basePaths.add(null);
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePaths,
-				Collections.singleton(endpoint));
-		registrar.onStartup(this.servletContext);
-		verify(this.dynamic).addMapping(""/test/*"");
-	}
-
 	@Test
 	public void onStartupWhenHasInitParametersShouldRegisterInitParameters()
 			throws Exception {
@@ -27,7 +27,7 @@
 import javax.servlet.http.HttpServletRequest;
 
 import org.springframework.boot.autoconfigure.security.StaticResourceLocation;
-import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.security.servlet.ApplicationContextRequestMatcher;
 import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
 import org.springframework.security.web.util.matcher.OrRequestMatcher;
@@ -96,14 +96,14 @@ public StaticResourceRequestMatcher at(Set<StaticResourceLocation> locations) {
 	 * Locations}.
 	 */
 	public static final class StaticResourceRequestMatcher
-			extends ApplicationContextRequestMatcher<ServerProperties> {
+			extends ApplicationContextRequestMatcher<DispatcherServletPath> {
 
 		private final Set<StaticResourceLocation> locations;
 
 		private volatile RequestMatcher delegate;
 
 		private StaticResourceRequestMatcher(Set<StaticResourceLocation> locations) {
-			super(ServerProperties.class);
+			super(DispatcherServletPath.class);
 			this.locations = locations;
 		}
 
@@ -134,25 +134,26 @@ public StaticResourceRequestMatcher excluding(
 		}
 
 		@Override
-		protected void initialized(Supplier<ServerProperties> serverProperties) {
+		protected void initialized(
+				Supplier<DispatcherServletPath> dispatcherServletPath) {
 			this.delegate = new OrRequestMatcher(
-					getDelegateMatchers(serverProperties.get()));
+					getDelegateMatchers(dispatcherServletPath.get()));
 		}
 
 		private List<RequestMatcher> getDelegateMatchers(
-				ServerProperties serverProperties) {
-			return getPatterns(serverProperties).map(AntPathRequestMatcher::new)
+				DispatcherServletPath dispatcherServletPath) {
+			return getPatterns(dispatcherServletPath).map(AntPathRequestMatcher::new)
 					.collect(Collectors.toList());
 		}
 
-		private Stream<String> getPatterns(ServerProperties serverProperties) {
+		private Stream<String> getPatterns(DispatcherServletPath dispatcherServletPath) {
 			return this.locations.stream().flatMap(StaticResourceLocation::getPatterns)
-					.map(serverProperties.getServlet()::getPath);
+					.map(dispatcherServletPath::getRelativePath);
 		}
 
 		@Override
 		protected boolean matches(HttpServletRequest request,
-				Supplier<ServerProperties> context) {
+				Supplier<DispatcherServletPath> context) {
 			return this.delegate.matches(request);
 		}
 
@@ -269,6 +269,13 @@ public Session getSession() {
 			return this.session;
 		}
 
+		/**
+		 * Return the mapping used to map a servlet to the path.
+		 * @return the servlet mapping
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getServletUrlMapping}
+		 */
+		@Deprecated
 		public String getServletMapping() {
 			if (this.path.equals("""") || this.path.equals(""/"")) {
 				return ""/"";
@@ -282,6 +289,14 @@ public String getServletMapping() {
 			return this.path + ""/*"";
 		}
 
+		/**
+		 * Return a path relative to the servlet prefix.
+		 * @param path the path to make relative
+		 * @return the relative path
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getRelativePath(String)}
+		 */
+		@Deprecated
 		public String getPath(String path) {
 			String prefix = getServletPrefix();
 			if (!path.startsWith(""/"")) {
@@ -290,6 +305,13 @@ public String getPath(String path) {
 			return prefix + path;
 		}
 
+		/**
+		 * Return the servlet prefix.
+		 * @return the servlet prefix
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getPrefix()}
+		 */
+		@Deprecated
 		public String getServletPrefix() {
 			String result = this.path;
 			int index = result.indexOf('*');
@@ -302,6 +324,14 @@ public String getServletPrefix() {
 			return result;
 		}
 
+		/**
+		 * Create a array of relative paths from the given source.
+		 * @param paths the source paths
+		 * @return the relative paths
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getRelativePath(String)}
+		 */
+		@Deprecated
 		public String[] getPathsArray(Collection<String> paths) {
 			String[] result = new String[paths.size()];
 			int i = 0;
@@ -311,6 +341,14 @@ public String[] getPathsArray(Collection<String> paths) {
 			return result;
 		}
 
+		/**
+		 * Create a array of relative paths from the given source.
+		 * @param paths the source paths
+		 * @return the relative paths
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getRelativePath(String)}
+		 */
+		@Deprecated
 		public String[] getPathsArray(String[] paths) {
 			String[] result = new String[paths.length];
 			int i = 0;
@@ -17,7 +17,6 @@
 package org.springframework.boot.autoconfigure.web.servlet;
 
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import javax.servlet.MultipartConfigElement;
@@ -34,7 +33,6 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;
 import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
@@ -139,11 +137,10 @@ public DispatcherServletRegistrationConfiguration(
 
 		@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
 		@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
-		public ServletRegistrationBean<DispatcherServlet> dispatcherServletRegistration(
+		public DispatcherServletRegistrationBean dispatcherServletRegistration(
 				DispatcherServlet dispatcherServlet) {
-			ServletRegistrationBean<DispatcherServlet> registration = new ServletRegistrationBean<>(
-					dispatcherServlet,
-					this.serverProperties.getServlet().getServletMapping());
+			DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(
+					dispatcherServlet, this.serverProperties.getServlet().getPath());
 			registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
 			registration.setLoadOnStartup(
 					this.webMvcProperties.getServlet().getLoadOnStartup());
@@ -153,15 +150,6 @@ public ServletRegistrationBean<DispatcherServlet> dispatcherServletRegistration(
 			return registration;
 		}
 
-		@Bean
-		@ConditionalOnMissingBean(DispatcherServletPathProvider.class)
-		@ConditionalOnSingleCandidate(DispatcherServlet.class)
-		public DispatcherServletPathProvider dispatcherServletPathProvider() {
-			return () -> Collections.singleton(
-					DispatcherServletRegistrationConfiguration.this.serverProperties
-							.getServlet().getPath());
-		}
-
 	}
 
 	@Order(Ordered.LOWEST_PRECEDENCE - 10)
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.web.servlet;
+
+import org.springframework.boot.web.servlet.ServletRegistrationBean;
+import org.springframework.web.servlet.DispatcherServlet;
+
+/**
+ * Interface that can be used by auto-configurations that need path details for the
+ * {@link DispatcherServletAutoConfiguration#DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME
+ * default} {@link DispatcherServlet}.
+ *
+ * @author Madhura Bhave
+ * @author Stephane Nicoll
+ * @since 2.0.4
+ */
+@FunctionalInterface
+public interface DispatcherServletPath {
+
+	/**
+	 * Returns the configured path of the dispatcher servlet.
+	 * @return the configured path
+	 */
+	String getPath();
+
+	/**
+	 * Return a form of the given path that's relative to the dispatcher servlet path.
+	 * @param path the path to make relative
+	 * @return the relative path
+	 */
+	default String getRelativePath(String path) {
+		String prefix = getPrefix();
+		if (!path.startsWith(""/"")) {
+			path = ""/"" + path;
+		}
+		return prefix + path;
+	}
+
+	/**
+	 * Return a cleaned up version of the path that can be used as a prefix for URLs. The
+	 * resulting path will have path will not have a trailing slash.
+	 * @return the prefix
+	 * @see #getRelativePath(String)
+	 */
+	default String getPrefix() {
+		String result = getPath();
+		int index = result.indexOf('*');
+		if (index != -1) {
+			result = result.substring(0, index);
+		}
+		if (result.endsWith(""/"")) {
+			result = result.substring(0, result.length() - 1);
+		}
+		return result;
+	}
+
+	/**
+	 * Return a URL mapping pattern that can be used with a
+	 * {@link ServletRegistrationBean} to map the dispatcher servlet.
+	 * @return the path as a servlet URL mapping
+	 */
+	default String getServletUrlMapping() {
+		if (getPath().equals("""") || getPath().equals(""/"")) {
+			return ""/"";
+		}
+		if (getPath().contains(""*"")) {
+			return getPath();
+		}
+		if (getPath().endsWith(""/"")) {
+			return getPath() + ""*"";
+		}
+		return getPath() + ""/*"";
+	}
+
+}
@@ -16,8 +16,6 @@
 
 package org.springframework.boot.autoconfigure.web.servlet;
 
-import java.util.Set;
-
 import org.springframework.web.servlet.DispatcherServlet;
 
 /**
@@ -26,10 +24,13 @@
  *
  * @author Madhura Bhave
  * @since 2.0.2
+ * @deprecated since 2.0.4 in favor of {@link DispatcherServletPath} and
+ * {@link DispatcherServletRegistrationBean}
  */
+@Deprecated
 @FunctionalInterface
 public interface DispatcherServletPathProvider {
 
-	Set<String> getServletPaths();
+	String getServletPath();
 
 }
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.web.servlet;
+
+import java.util.Collection;
+
+import org.springframework.boot.web.servlet.ServletRegistrationBean;
+import org.springframework.util.Assert;
+import org.springframework.web.servlet.DispatcherServlet;
+
+/**
+ * {@link ServletRegistrationBean} for the auto-configured {@link DispatcherServlet}. Both
+ * registeres the servlet and exposes {@link DispatcherServletPath} information.
+ *
+ * @author Phillip Webb
+ * @since 2.0.4
+ */
+public class DispatcherServletRegistrationBean extends
+		ServletRegistrationBean<DispatcherServlet> implements DispatcherServletPath {
+
+	private final String path;
+
+	/**
+	 * Create a new {@link DispatcherServletRegistrationBean} instance for the given
+	 * servlet and path.
+	 * @param servlet the dispatcher servlet
+	 * @param path the dispatcher servlet path
+	 */
+	public DispatcherServletRegistrationBean(DispatcherServlet servlet, String path) {
+		super(servlet);
+		Assert.notNull(path, ""Path must not be null"");
+		this.path = path;
+		super.addUrlMappings(getServletUrlMapping());
+	}
+
+	@Override
+	public String getPath() {
+		return this.path;
+	}
+
+	@Override
+	public void setUrlMappings(Collection<String> urlMappings) {
+		throw new UnsupportedOperationException(
+				""URL Mapping cannot be changed on a DispatcherServlet registration"");
+	}
+
+	@Override
+	public void addUrlMappings(String... urlMappings) {
+		throw new UnsupportedOperationException(
+				""URL Mapping cannot be changed on a DispatcherServlet registration"");
+	}
+
+}
@@ -49,6 +49,7 @@
 import org.springframework.boot.autoconfigure.template.TemplateAvailabilityProviders;
 import org.springframework.boot.autoconfigure.web.ResourceProperties;
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.boot.web.server.ErrorPage;
@@ -94,11 +95,15 @@ public class ErrorMvcAutoConfiguration {
 
 	private final ServerProperties serverProperties;
 
+	private final DispatcherServletPath dispatcherServletPath;
+
 	private final List<ErrorViewResolver> errorViewResolvers;
 
 	public ErrorMvcAutoConfiguration(ServerProperties serverProperties,
+			DispatcherServletPath dispatcherServletPath,
 			ObjectProvider<List<ErrorViewResolver>> errorViewResolversProvider) {
 		this.serverProperties = serverProperties;
+		this.dispatcherServletPath = dispatcherServletPath;
 		this.errorViewResolvers = errorViewResolversProvider.getIfAvailable();
 	}
 
@@ -118,7 +123,7 @@ public BasicErrorController basicErrorController(ErrorAttributes errorAttributes
 
 	@Bean
 	public ErrorPageCustomizer errorPageCustomizer() {
-		return new ErrorPageCustomizer(this.serverProperties);
+		return new ErrorPageCustomizer(this.serverProperties, this.dispatcherServletPath);
 	}
 
 	@Bean
@@ -327,15 +332,18 @@ private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered
 
 		private final ServerProperties properties;
 
-		protected ErrorPageCustomizer(ServerProperties properties) {
+		private final DispatcherServletPath dispatcherServletPath;
+
+		protected ErrorPageCustomizer(ServerProperties properties,
+				DispatcherServletPath dispatcherServletPath) {
 			this.properties = properties;
+			this.dispatcherServletPath = dispatcherServletPath;
 		}
 
 		@Override
 		public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {
-			ErrorPage errorPage = new ErrorPage(
-					this.properties.getServlet().getServletPrefix()
-							+ this.properties.getError().getPath());
+			ErrorPage errorPage = new ErrorPage(this.dispatcherServletPath
+					.getRelativePath(this.properties.getError().getPath()));
 			errorPageRegistry.addErrorPages(errorPage);
 		}
 
@@ -25,6 +25,7 @@
 
 import org.springframework.boot.autoconfigure.security.StaticResourceLocation;
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.mock.web.MockHttpServletRequest;
 import org.springframework.mock.web.MockServletContext;
 import org.springframework.security.web.util.matcher.RequestMatcher;
@@ -96,15 +97,20 @@ public void excludeFromSetWhenSetIsNullShouldThrowException() {
 	}
 
 	private RequestMatcherAssert assertMatcher(RequestMatcher matcher) {
+		DispatcherServletPath dispatcherServletPath = () -> """";
 		StaticWebApplicationContext context = new StaticWebApplicationContext();
 		context.registerBean(ServerProperties.class);
+		context.registerBean(DispatcherServletPath.class, () -> dispatcherServletPath);
 		return assertThat(new RequestMatcherAssert(context, matcher));
 	}
 
 	private RequestMatcherAssert assertMatcher(RequestMatcher matcher,
 			ServerProperties serverProperties) {
+		DispatcherServletPath dispatcherServletPath = () -> serverProperties.getServlet()
+				.getPath();
 		StaticWebApplicationContext context = new StaticWebApplicationContext();
 		context.registerBean(ServerProperties.class, () -> serverProperties);
+		context.registerBean(DispatcherServletPath.class, () -> dispatcherServletPath);
 		return assertThat(new RequestMatcherAssert(context, matcher));
 	}
 
@@ -79,13 +79,15 @@ public void testConnectionTimeout() {
 	}
 
 	@Test
+	@Deprecated
 	public void testServletPathAsMapping() {
 		bind(""server.servlet.path"", ""/foo/*"");
 		assertThat(this.properties.getServlet().getServletMapping()).isEqualTo(""/foo/*"");
 		assertThat(this.properties.getServlet().getServletPrefix()).isEqualTo(""/foo"");
 	}
 
 	@Test
+	@Deprecated
 	public void testServletPathAsPrefix() {
 		bind(""server.servlet.path"", ""/foo"");
 		assertThat(this.properties.getServlet().getServletMapping()).isEqualTo(""/foo/*"");
@@ -66,8 +66,7 @@ public void registrationNonServletBean() {
 				.run((context) -> {
 					assertThat(context).doesNotHaveBean(ServletRegistrationBean.class);
 					assertThat(context).doesNotHaveBean(DispatcherServlet.class);
-					assertThat(context)
-							.doesNotHaveBean(DispatcherServletPathProvider.class);
+					assertThat(context).doesNotHaveBean(DispatcherServletPath.class);
 				});
 	}
 
@@ -77,7 +76,7 @@ public void registrationNonServletBean() {
 	public void registrationOverrideWithDispatcherServletWrongName() {
 		this.contextRunner
 				.withUserConfiguration(CustomDispatcherServletDifferentName.class,
-						CustomDispatcherServletPathProvider.class)
+						CustomDispatcherServletPath.class)
 				.run((context) -> {
 					ServletRegistrationBean<?> registration = context
 							.getBean(ServletRegistrationBean.class);
@@ -91,7 +90,7 @@ public void registrationOverrideWithDispatcherServletWrongName() {
 	@Test
 	public void registrationOverrideWithAutowiredServlet() {
 		this.contextRunner.withUserConfiguration(CustomAutowiredRegistration.class,
-				CustomDispatcherServletPathProvider.class).run((context) -> {
+				CustomDispatcherServletPath.class).run((context) -> {
 					ServletRegistrationBean<?> registration = context
 							.getBean(ServletRegistrationBean.class);
 					assertThat(registration.getUrlMappings()).containsExactly(""/foo"");
@@ -111,43 +110,35 @@ public void servletPath() {
 					assertThat(registration.getUrlMappings())
 							.containsExactly(""/spring/*"");
 					assertThat(registration.getMultipartConfig()).isNull();
-					assertThat(context.getBean(DispatcherServletPathProvider.class)
-							.getServletPaths()).containsExactly(""/spring"");
+					assertThat(context.getBean(DispatcherServletPath.class).getPath())
+							.isEqualTo(""/spring"");
 				});
 	}
 
 	@Test
-	public void pathProviderNotCreatedWhenMultipleDispatcherServletsPresent() {
-		this.contextRunner
-				.withUserConfiguration(CustomDispatcherServletDifferentName.class)
-				.run((context) -> assertThat(context)
-						.doesNotHaveBean(DispatcherServletPathProvider.class));
-	}
-
-	@Test
-	public void pathProviderWhenCustomDispatcherServletSameNameShouldReturnConfiguredServletPath() {
+	public void dispatcherServletPathWhenCustomDispatcherServletSameNameShouldReturnConfiguredServletPath() {
 		this.contextRunner.withUserConfiguration(CustomDispatcherServletSameName.class)
 				.withPropertyValues(""server.servlet.path:/spring"")
-				.run((context) -> assertThat(context
-						.getBean(DispatcherServletPathProvider.class).getServletPaths())
-								.containsExactly(""/spring""));
+				.run((context) -> assertThat(
+						context.getBean(DispatcherServletPath.class).getPath())
+								.isEqualTo(""/spring""));
 	}
 
 	@Test
-	public void pathProviderNotCreatedWhenDefaultDispatcherServletNotAvailable() {
+	public void dispatcherServletPathNotCreatedWhenDefaultDispatcherServletNotAvailable() {
 		this.contextRunner
 				.withUserConfiguration(CustomDispatcherServletDifferentName.class,
 						NonServletConfiguration.class)
 				.run((context) -> assertThat(context)
-						.doesNotHaveBean(DispatcherServletPathProvider.class));
+						.doesNotHaveBean(DispatcherServletPath.class));
 	}
 
 	@Test
-	public void pathProviderNotCreatedWhenCustomRegistrationBeanPresent() {
+	public void dispatcherServletPathNotCreatedWhenCustomRegistrationBeanPresent() {
 		this.contextRunner
 				.withUserConfiguration(CustomDispatcherServletRegistration.class)
 				.run((context) -> assertThat(context)
-						.doesNotHaveBean(DispatcherServletPathProvider.class));
+						.doesNotHaveBean(DispatcherServletPath.class));
 	}
 
 	@Test
@@ -237,11 +228,11 @@ public DispatcherServlet customDispatcherServlet() {
 	}
 
 	@Configuration
-	protected static class CustomDispatcherServletPathProvider {
+	protected static class CustomDispatcherServletPath {
 
 		@Bean
-		public DispatcherServletPathProvider dispatcherServletPathProvider() {
-			return mock(DispatcherServletPathProvider.class);
+		public DispatcherServletPath dispatcherServletPath() {
+			return mock(DispatcherServletPath.class);
 		}
 
 	}
@@ -259,8 +250,8 @@ public ServletRegistrationBean<?> dispatcherServletRegistration(
 		}
 
 		@Bean
-		public DispatcherServletPathProvider dispatcherServletPathProvider() {
-			return mock(DispatcherServletPathProvider.class);
+		public DispatcherServletPath dispatcherServletPath() {
+			return mock(DispatcherServletPath.class);
 		}
 
 	}
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.web.servlet;
+
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link DispatcherServletPath}.
+ *
+ * @author Phillip Webb
+ */
+public class DispatcherServletPathTests {
+
+	@Test
+	public void getRelativePathReturnsRelativePath() {
+		assertThat(((DispatcherServletPath) () -> ""spring"").getRelativePath(""boot""))
+				.isEqualTo(""spring/boot"");
+		assertThat(((DispatcherServletPath) () -> ""spring/"").getRelativePath(""boot""))
+				.isEqualTo(""spring/boot"");
+		assertThat(((DispatcherServletPath) () -> ""spring"").getRelativePath(""/boot""))
+				.isEqualTo(""spring/boot"");
+	}
+
+	@Test
+	public void getPrefixWhenHasSimplePathReturnPath() {
+		assertThat(((DispatcherServletPath) () -> ""spring"").getPrefix())
+				.isEqualTo(""spring"");
+	}
+
+	@Test
+	public void getPrefixWhenHasPatternRemovesPattern() {
+		assertThat(((DispatcherServletPath) () -> ""spring/*.do"").getPrefix())
+				.isEqualTo(""spring"");
+	}
+
+	@Test
+	public void getPathWhenPathEndsWithSlashRemovesSlash() {
+		assertThat(((DispatcherServletPath) () -> ""spring/"").getPrefix())
+				.isEqualTo(""spring"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenPathIsEmptyReturnsSlash() {
+		assertThat(((DispatcherServletPath) () -> """").getServletUrlMapping())
+				.isEqualTo(""/"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenPathIsSlashReturnsSlash() {
+		assertThat(((DispatcherServletPath) () -> ""/"").getServletUrlMapping())
+				.isEqualTo(""/"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenPathContainsStarReturnsPath() {
+		assertThat(((DispatcherServletPath) () -> ""spring/*.do"").getServletUrlMapping())
+				.isEqualTo(""spring/*.do"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenHasPathNotEndingSlashReturnsSlashStarPattern() {
+		assertThat(((DispatcherServletPath) () -> ""spring/boot"").getServletUrlMapping())
+				.isEqualTo(""spring/boot/*"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenHasPathEndingWithSlashReturnsSlashStarPattern() {
+		assertThat(((DispatcherServletPath) () -> ""spring/boot/"").getServletUrlMapping())
+				.isEqualTo(""spring/boot/*"");
+	}
+
+}
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.web.servlet;
+
+import java.util.Collections;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import org.springframework.web.servlet.DispatcherServlet;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link DispatcherServletRegistrationBean}.
+ *
+ * @author Phillip Webb
+ */
+public class DispatcherServletRegistrationBeanTests {
+
+	@Rule
+	public ExpectedException thrown = ExpectedException.none();
+
+	@Test
+	public void createWhenPathIsNullThrowsException() {
+		this.thrown.expect(IllegalArgumentException.class);
+		this.thrown.expectMessage(""Path must not be null"");
+		new DispatcherServletRegistrationBean(new DispatcherServlet(), null);
+	}
+
+	@Test
+	public void getPathReturnsPath() {
+		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(
+				new DispatcherServlet(), ""/test"");
+		assertThat(bean.getPath()).isEqualTo(""/test"");
+	}
+
+	@Test
+	public void getUrlMappingsReturnsSinglePathMappedPattern() {
+		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(
+				new DispatcherServlet(), ""/test"");
+		assertThat(bean.getUrlMappings()).containsOnly(""/test/*"");
+	}
+
+	@Test
+	public void setUrlMappingsCannotBeCalled() {
+		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(
+				new DispatcherServlet(), ""/test"");
+		this.thrown.expect(UnsupportedOperationException.class);
+		bean.setUrlMappings(Collections.emptyList());
+	}
+
+	@Test
+	public void addUrlMappingsCannotBeCalled() {
+		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(
+				new DispatcherServlet(), ""/test"");
+		this.thrown.expect(UnsupportedOperationException.class);
+		bean.addUrlMappings(""/test"");
+	}
+
+}
@@ -20,6 +20,7 @@
 import org.junit.Test;
 
 import org.springframework.boot.autoconfigure.AutoConfigurations;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;
 import org.springframework.boot.test.context.runner.WebApplicationContextRunner;
 import org.springframework.boot.test.rule.OutputCapture;
 import org.springframework.boot.web.servlet.error.ErrorAttributes;
@@ -39,7 +40,9 @@
 public class ErrorMvcAutoConfigurationTests {
 
 	private WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
-			.withConfiguration(AutoConfigurations.of(ErrorMvcAutoConfiguration.class));
+			.withConfiguration(
+					AutoConfigurations.of(DispatcherServletAutoConfiguration.class,
+							ErrorMvcAutoConfiguration.class));
 
 	@Rule
 	public OutputCapture outputCapture = new OutputCapture();
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,8 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;
+import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
 import org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
@@ -48,19 +50,28 @@
 @Configuration
 @ConditionalOnWebApplication(type = Type.SERVLET)
 @AutoConfigureAfter(WebMvcAutoConfiguration.class)
-@EnableConfigurationProperties(WebMvcProperties.class)
+@EnableConfigurationProperties({ ServerProperties.class, WebMvcProperties.class })
 public class MockMvcAutoConfiguration {
 
 	private final WebApplicationContext context;
 
+	private final ServerProperties serverProperties;
+
 	private final WebMvcProperties webMvcProperties;
 
 	MockMvcAutoConfiguration(WebApplicationContext context,
-			WebMvcProperties webMvcProperties) {
+			ServerProperties serverProperties, WebMvcProperties webMvcProperties) {
 		this.context = context;
+		this.serverProperties = serverProperties;
 		this.webMvcProperties = webMvcProperties;
 	}
 
+	@Bean
+	@ConditionalOnMissingBean
+	public DispatcherServletPath dispatcherServletPath() {
+		return () -> this.serverProperties.getServlet().getPath();
+	}
+
 	@Bean
 	@ConditionalOnMissingBean(MockMvcBuilder.class)
 	public DefaultMockMvcBuilder mockMvcBuilder(
"
https://github.com/spring-projects/spring-boot/commit/fcf468062602966c508c260ef54da55e2d48c49a,Polish 'Document how to add metadata for collection and enum default values' <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/fcf468062602966c508c260ef54da55e2d48c49a,"@@ -815,20 +815,21 @@ The annotation processor also supports the use of the `@Data`, `@Getter`, and `@
 lombok annotations.
 
 
-The annotation processor cannot auto-detect default values for ``Enum``s and ``Collections``s.
-In the cases where a `Collection` or `Enum` property has a non-empty default value,
-<<configuration-metadata-additional-metadata,manual metadata>> should be provided.
+The annotation processor cannot auto-detect default values for ``Enum``s and
+``Collections``s. In the cases where a `Collection` or `Enum` property has a non-empty
+default value, <<configuration-metadata-additional-metadata,manual metadata>> should be
+provided.
 
 Consider the following class:
 
 [source,java,indent=0,subs=""verbatim,quotes,attributes""]
 ----
-	@ConfigurationProperties(prefix=""rabbit"")
-	public class RabbitProperties {
+	@ConfigurationProperties(prefix=""acme.messaging"")
+	public class MessagingProperties {
 
 		private List<String> addresses = new ArrayList<>(Arrays.asList(""a"", ""b"")) ;
 
-		private ContainerType  = ContainerType.SIMPLE;
+		private ContainerType = ContainerType.SIMPLE;
 
 		// ... getter and setters
 
@@ -843,21 +844,27 @@ Consider the following class:
 	}
 ----
 
-In order to document default values for properties in the class above, you could add the following
-JSON to <<configuration-metadata-additional-metadata,the manual metadata of the module>>:
+In order to document default values for properties in the class above, you could add the
+following content to <<configuration-metadata-additional-metadata,the manual metadata of
+the module>>:
 
 [source,json,indent=0]
 ----
-	{
-		""name"": ""rabbit.addresses"",
-		""defaultValue"": ""a, b""
-	},
-	{
-		""name"": ""rabbit.container-type"",
-		""defaultValue"": ""simple""
-	}
+	{""properties"": [
+		{
+			""name"": ""acme.messaging.addresses"",
+			""defaultValue"": [""a, b""]
+		},
+		{
+			""name"": ""acme.messaging.container-type"",
+			""defaultValue"": ""simple""
+		}
+	]}
 ----
 
+Only the `name` of the property is required to document additional fields with manual
+metadata.
+
 
 [NOTE]
 ====
"
https://github.com/junit-team/junit4/commit/e15b287ccec2a1f4866a8bd1cd2a313a6163163d,"Only use a property where multiple entries need syncing  <enter> * The hamcrest version is only used in one place, i.e. the dependency. * Using properties to define dependency versions can cause issues for others. * Using properties to define a shared version across multiple dependencies causes less issues when you have multiple dependencies that need to be kept in sync. * We only have one dependency here and it doesn't need syncing to any other dependency * Therefore the right thing is to just specify the version in the dependency * End users can still override the dependency in their poms. ",https://api.github.com/repos/junit-team/junit4/commits/e15b287ccec2a1f4866a8bd1cd2a313a6163163d,"@@ -73,7 +73,6 @@
     </distributionManagement>
 
     <properties>
-        <hamcrestVersion>1.3</hamcrestVersion>
         <jdkVersion>1.5</jdkVersion>
         <project.build.sourceEncoding>ISO-8859-1</project.build.sourceEncoding>
     </properties>
@@ -82,7 +81,7 @@
         <dependency>
             <groupId>org.hamcrest</groupId>
             <artifactId>hamcrest-core</artifactId>
-            <version>${hamcrestVersion}</version>
+            <version>1.3</version>
         </dependency>
     </dependencies>
 
"
https://github.com/junit-team/junit4/commit/fd2c4fbbf74f01eecef1680fa1365052d0302d19,Added some names to list of contributors ,https://api.github.com/repos/junit-team/junit4/commits/fd2c4fbbf74f01eecef1680fa1365052d0302d19,"@@ -110,6 +110,8 @@
 			<li><a href=""http://www.petrikainulainen.net/blog/"">Petri Kainulainen</a></li>
 			<li>Jean-Christophe Sirot</li>
       <li>Max Schwaab</li>
+      <li>Brian Clozel</li>
+      <li>Per-Ingemar Andersson</li>
 		</ul>
   </body>
 </html>
"
https://github.com/square/retrofit/commit/eccfe208bcb7c54d357c60842aa6e33cc15424cd,"Switch to a better, custom validating subscriber.  <enter> TestSubscriber is a poor implementation for correctness testing. This new subscriber ensures all events are tested by being a JUnit rule. It also consumes events as they're validated so that assertion becomes more like a script than a ledger. <enter> This also switches tests to use unsafeSubscribe to ensure that any contract violations are not being suppressed. The latest version of RxJava is required for accessing this method on Completable. ",https://api.github.com/repos/square/retrofit/commits/eccfe208bcb7c54d357c60842aa6e33cc15424cd,"@@ -53,7 +53,7 @@
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.1.5</rxjava.version>
+    <rxjava.version>1.1.9</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.7</gson.version>
@@ -24,13 +24,13 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
-import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class CompletableTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Completable completable();
@@ -49,25 +49,24 @@ interface Service {
   @Test public void completableSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
     subscriber.assertCompleted();
   }
 
   @Test public void completableSuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
-    Throwable cause = subscriber.getOnErrorEvents().get(0);
-    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, ""HTTP 404 Client Error"");
   }
 
   @Test public void completableFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 }
@@ -23,11 +23,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
 public final class CompletableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Completable completable();
@@ -47,9 +47,9 @@ interface Service {
   @Test public void completableUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
     subscriber.assertCompleted();
@@ -25,13 +25,13 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ObservableTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Observable<String> body();
@@ -53,42 +53,37 @@ interface Service {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertValues(""Hi"");
-    subscriber.assertCompleted();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue(""Hi"").assertCompleted();
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    Throwable cause = subscriber.getOnErrorEvents().get(0);
-    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, ""HTTP 404 Client Error"");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 
   @Test public void bodyRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>(0);
-    Observable<String> o = service.body();
-
-    o.subscribe(subscriber);
+    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.body().unsafeSubscribe(subscriber);
     assertThat(server.getRequestCount()).isEqualTo(0);
 
     subscriber.requestMore(1);
     assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
@@ -97,45 +92,39 @@ interface Service {
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    Response<String> response = subscriber.getOnNextEvents().get(0);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo(""Hi"");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo(""Hi"");
     subscriber.assertCompleted();
   }
 
   @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+    server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    Response<String> response = subscriber.getOnNextEvents().get(0);
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
     subscriber.assertCompleted();
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 
   @Test public void responseRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>(0);
-    Observable<Response<String>> o = service.response();
-
-    o.subscribe(subscriber);
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.response().unsafeSubscribe(subscriber);
     assertThat(server.getRequestCount()).isEqualTo(0);
 
     subscriber.requestMore(1);
     assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
@@ -144,51 +133,40 @@ interface Service {
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo(""Hi"");
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo(""Hi"");
     subscriber.assertCompleted();
   }
 
   @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
-
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
     subscriber.assertCompleted();
   }
 
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
     subscriber.assertCompleted();
   }
 
   @Test public void resultRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>(0);
-    Observable<Result<String>> o = service.result();
-
-    o.subscribe(subscriber);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.result().unsafeSubscribe(subscriber);
     assertThat(server.getRequestCount()).isEqualTo(0);
 
     subscriber.requestMore(1);
     assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
@@ -24,11 +24,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
 public final class ObservableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Observable<String> body();
@@ -51,39 +51,33 @@ interface Service {
   @Test public void bodyUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void responseUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void resultUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 }
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import rx.Notification;
+import rx.Subscriber;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSubscriber<T> extends Subscriber<T> {
+  private final long initialRequest;
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingSubscriber(long initialRequest) {
+    this.initialRequest = initialRequest;
+  }
+
+  @Override public void onStart() {
+    request(initialRequest);
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onCompleted() {
+    events.add(Notification.<T>createOnCompleted());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError(""No event found!"");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .overridingErrorMessage(""Expected onNext event but was %s"", notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .overridingErrorMessage(""Expected onError event but was %s"", notification)
+        .isTrue();
+    return notification.getThrowable();
+  }
+
+  public RecordingSubscriber<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSubscriber<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertCompleted() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnCompleted())
+        .overridingErrorMessage(""Expected onCompleted event but was %s"", notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as(""Unconsumed events found!"").isEmpty();
+  }
+
+  public void requestMore(long amount) {
+    request(amount);
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSubscriber<T> create() {
+      return createWithInitialRequest(Long.MAX_VALUE);
+    }
+
+    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSubscriber<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
@@ -25,13 +25,13 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SingleTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Single<String> body();
@@ -53,87 +53,77 @@ interface Service {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertValue(""Hi"");
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue(""Hi"").assertCompleted();
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    Throwable cause = subscriber.getOnErrorEvents().get(0);
-    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, ""HTTP 404 Client Error"");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    Response<String> response = subscriber.getOnNextEvents().get(0);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo(""Hi"");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+    server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    Response<String> response = subscriber.getOnNextEvents().get(0);
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
+    subscriber.assertCompleted();
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo(""Hi"");
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
-
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+    subscriber.assertCompleted();
   }
 
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
   }
 }
@@ -24,11 +24,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
 public final class SingleWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Single<String> body();
@@ -51,36 +51,33 @@ interface Service {
   @Test public void bodyUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void responseUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void resultUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 }
"
https://github.com/square/retrofit/commit/46cdff20b53a84e816d6022541347b3c06a5a52b,"Fatal errors should crash the dispatcher thread  <enter> This is an imperfect fix as uncaught exceptions reaching OkHttpCall which are not fatal still only log, but most of the adapters are defending against anything getting this far already. <enter> Also contained is a fix for the RxJava 2 async adapter. Non-200 responses delivered to the body observer would be forwarded to onError. If that callback threw a fatal exception, it would be re-delivered to the body observer despite it having already called a downstream terminal method. The fatal error should have been propagated by the async observer instead of attempting to make its way back downstream. ",https://api.github.com/repos/square/retrofit/commits/46cdff20b53a84e816d6022541347b3c06a5a52b,"@@ -64,6 +64,7 @@ private static final class CallCallback<T> implements Disposable, Callback<T> {
           observer.onComplete();
         }
       } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
         if (terminated) {
           RxJavaPlugins.onError(t);
         } else if (!disposed) {
@@ -22,10 +22,18 @@
 import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.Dispatcher;
+import okhttp3.OkHttpClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -36,7 +44,10 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 public final class AsyncTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -46,14 +57,36 @@ interface Service {
   }
 
   private Service service;
+  private List<Throwable> uncaughtExceptions = new ArrayList<>();
+
   @Before public void setUp() {
+    ExecutorService executorService = Executors.newCachedThreadPool(new ThreadFactory() {
+      @Override public Thread newThread(Runnable r) {
+        Thread thread = new Thread(r);
+        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+          @Override public void uncaughtException(Thread t, Throwable e) {
+            uncaughtExceptions.add(e);
+          }
+        });
+        return thread;
+      }
+    });
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .dispatcher(new Dispatcher(executorService))
+        .build();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url(""/""))
+        .client(client)
         .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
         .build();
     service = retrofit.create(Service.class);
   }
 
+  @After public void tearDown() {
+    assertTrue(""Uncaught exceptions: "" + uncaughtExceptions, uncaughtExceptions.isEmpty());
+  }
+
   @Test public void success() throws InterruptedException {
     TestObserver<Void> observer = new TestObserver<>();
     service.completable().subscribe(observer);
@@ -130,4 +163,23 @@ interface Service {
     CompositeException composite = (CompositeException) pluginRef.get();
     assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
   }
+
+  @Test public void bodyThrowingFatalInOnErrorPropagates() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final Error e = new OutOfMemoryError(""Not real"");
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+
+    assertEquals(1, uncaughtExceptions.size());
+    assertSame(e, uncaughtExceptions.remove(0));
+  }
 }
@@ -128,7 +128,8 @@ final class OkHttpCall<T> implements Call<T> {
         try {
           callback.onResponse(OkHttpCall.this, response);
         } catch (Throwable t) {
-          t.printStackTrace();
+          throwIfFatal(t);
+          t.printStackTrace(); // TODO this is not great
         }
       }
 
@@ -140,7 +141,8 @@ private void callFailure(Throwable e) {
         try {
           callback.onFailure(OkHttpCall.this, e);
         } catch (Throwable t) {
-          t.printStackTrace();
+          throwIfFatal(t);
+          t.printStackTrace(); // TODO this is not great
         }
       }
     });
"
https://github.com/spring-projects/spring-boot/commit/3b07e4e633ebcbdb0836ed7ad0b21fc8f0b42a9e,Fix typos in the documentation: though -> through  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/3b07e4e633ebcbdb0836ed7ad0b21fc8f0b42a9e,"@@ -265,7 +265,7 @@ to override version numbers if necessary.
 === Default exclude rules
 Gradle handles ``exclude rules'' in a slightly different way to Maven which can cause
 unexpected results when using the starter POMs. Specifically, exclusions declared on
-a dependency will not be applied when the dependency can be reached though a different
+a dependency will not be applied when the dependency can be reached through a different
 path. For example, if a starter POM declares the following:
 
 [source,xml,indent=0,subs=""verbatim,attributes""]
@@ -549,7 +549,7 @@ file named `src/main/java/Example.java`:
 	}
 ----
 
-Although there isn't much code here, quite a lot is going on. Let's step though the
+Although there isn't much code here, quite a lot is going on. Let's step through the
 important parts.
 
 
@@ -1504,7 +1504,7 @@ would only ever be a development time trick probably).
 
 [[howto-reload-springloaded-gradle-and-intellij]]
 ==== Configuring Spring Loaded for use with Gradle and IntelliJ
-You need to jump though a few hoops if you want to use Spring Loaded in combination with
+You need to jump through a few hoops if you want to use Spring Loaded in combination with
 Gradle and IntelliJ. By default, IntelliJ will compile classes into a different location
 than Gradle, causing Spring Loaded monitoring to fail.
 
"
https://github.com/square/okhttp/commit/e3e829d2060542d50f33d1a9864f7ace82c9db5c,"API change: Make OkHttpClient accessors final  <enter> If we want these to be vals to Kotlin, they can't be open. I think the motivation to make these non-final was pretty weak, and I don't mind breaking API compatibility here. ",https://api.github.com/repos/square/okhttp/commits/e3e829d2060542d50f33d1a9864f7ace82c9db5c,"@@ -354,6 +354,33 @@ task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
       'okhttp3.Route#requiresTunnel()',
       'okhttp3.Route#socketAddress()',
       'okhttp3.TlsVersion#javaName()',
+      // Real API change! Became 'final' despite a non-final enclosing class in 4.0.0:
+      'okhttp3.OkHttpClient#authenticator()',
+      'okhttp3.OkHttpClient#cache()',
+      'okhttp3.OkHttpClient#callTimeoutMillis()',
+      'okhttp3.OkHttpClient#certificatePinner()',
+      'okhttp3.OkHttpClient#connectionPool()',
+      'okhttp3.OkHttpClient#connectionSpecs()',
+      'okhttp3.OkHttpClient#connectTimeoutMillis()',
+      'okhttp3.OkHttpClient#cookieJar()',
+      'okhttp3.OkHttpClient#dispatcher()',
+      'okhttp3.OkHttpClient#dns()',
+      'okhttp3.OkHttpClient#eventListenerFactory()',
+      'okhttp3.OkHttpClient#followRedirects()',
+      'okhttp3.OkHttpClient#followSslRedirects()',
+      'okhttp3.OkHttpClient#hostnameVerifier()',
+      'okhttp3.OkHttpClient#interceptors()',
+      'okhttp3.OkHttpClient#networkInterceptors()',
+      'okhttp3.OkHttpClient#pingIntervalMillis()',
+      'okhttp3.OkHttpClient#protocols()',
+      'okhttp3.OkHttpClient#proxy()',
+      'okhttp3.OkHttpClient#proxyAuthenticator()',
+      'okhttp3.OkHttpClient#proxySelector()',
+      'okhttp3.OkHttpClient#readTimeoutMillis()',
+      'okhttp3.OkHttpClient#retryOnConnectionFailure()',
+      'okhttp3.OkHttpClient#socketFactory()',
+      'okhttp3.OkHttpClient#sslSocketFactory()',
+      'okhttp3.OkHttpClient#writeTimeoutMillis()',
   ]
 }
 check.dependsOn(japicmp)
@@ -184,75 +184,75 @@ open class OkHttpClient internal constructor(
     }
   }
 
-  open fun dispatcher(): Dispatcher = dispatcher
+  fun dispatcher(): Dispatcher = dispatcher
 
-  open fun proxy(): Proxy? = proxy
+  fun proxy(): Proxy? = proxy
 
-  open fun protocols(): List<Protocol> = protocols
+  fun protocols(): List<Protocol> = protocols
 
-  open fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
+  fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
 
   /**
    * Returns an immutable list of interceptors that observe the full span of each call: from before
    * the connection is established (if any) until after the response source is selected (either the
    * origin server, cache, or both).
    */
-  open fun interceptors(): List<Interceptor> = interceptors
+  fun interceptors(): List<Interceptor> = interceptors
 
   /**
    * Returns an immutable list of interceptors that observe a single network request and response.
    * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for
    * a network interceptor to short-circuit or repeat a network request.
    */
-  open fun networkInterceptors(): List<Interceptor> = networkInterceptors
+  fun networkInterceptors(): List<Interceptor> = networkInterceptors
 
-  open fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
+  fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
 
-  open fun proxySelector(): ProxySelector = proxySelector
+  fun proxySelector(): ProxySelector = proxySelector
 
-  open fun cookieJar(): CookieJar = cookieJar
+  fun cookieJar(): CookieJar = cookieJar
 
-  open fun cache(): Cache? = cache
+  fun cache(): Cache? = cache
 
-  open fun socketFactory(): SocketFactory = socketFactory
+  fun socketFactory(): SocketFactory = socketFactory
 
-  open fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory!!
+  fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory!!
 
-  open fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
+  fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
 
-  open fun certificatePinner(): CertificatePinner = certificatePinner
+  fun certificatePinner(): CertificatePinner = certificatePinner
 
-  open fun proxyAuthenticator(): Authenticator = proxyAuthenticator
+  fun proxyAuthenticator(): Authenticator = proxyAuthenticator
 
-  open fun authenticator(): Authenticator = authenticator
+  fun authenticator(): Authenticator = authenticator
 
-  open fun connectionPool(): ConnectionPool = connectionPool
+  fun connectionPool(): ConnectionPool = connectionPool
 
-  open fun dns(): Dns = dns
+  fun dns(): Dns = dns
 
-  open fun followSslRedirects(): Boolean = followSslRedirects
+  fun followSslRedirects(): Boolean = followSslRedirects
 
-  open fun followRedirects(): Boolean = followRedirects
+  fun followRedirects(): Boolean = followRedirects
 
-  open fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
+  fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
 
   /**
    * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
    * there is for the connect, write, and read actions within a call.
    */
-  open fun callTimeoutMillis(): Int = callTimeout
+  fun callTimeoutMillis(): Int = callTimeout
 
   /** Default connect timeout (in milliseconds). The default is 10 seconds.  */
-  open fun connectTimeoutMillis(): Int = connectTimeout
+  fun connectTimeoutMillis(): Int = connectTimeout
 
   /** Default read timeout (in milliseconds). The default is 10 seconds. */
-  open fun readTimeoutMillis(): Int = readTimeout
+  fun readTimeoutMillis(): Int = readTimeout
 
   /** Default write timeout (in milliseconds). The default is 10 seconds. */
-  open fun writeTimeoutMillis(): Int = writeTimeout
+  fun writeTimeoutMillis(): Int = writeTimeout
 
   /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
-  open fun pingIntervalMillis(): Int = pingInterval
+  fun pingIntervalMillis(): Int = pingInterval
 
   internal fun internalCache(): InternalCache? {
     return cache?.internalCache ?: internalCache
"
https://github.com/square/retrofit/commit/d80636923c595ed665adc6066f1377a6a1304f6a,Move source/target config out of error-prone block  <enter> Error-prone only works on pre-12 at the moment and we need this configuration to apply for all JDKs. ,https://api.github.com/repos/square/retrofit/commits/d80636923c595ed665adc6066f1377a6a1304f6a,"@@ -59,6 +59,12 @@ subprojects {
     jcenter()
   }
 
+  tasks.withType(JavaCompile).configureEach { task ->
+    task.options.encoding = 'UTF-8'
+    task.sourceCompatibility = JavaVersion.VERSION_1_8
+    task.targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
   // Error-prone only works on JDK 11 or older currently.
   if (!Jvm.current().javaVersion.isJava12Compatible()) {
     apply plugin: 'net.ltgt.errorprone'
@@ -69,10 +75,6 @@ subprojects {
     }
 
     tasks.withType(JavaCompile).configureEach { task ->
-      task.options.encoding = 'UTF-8'
-      task.sourceCompatibility = JavaVersion.VERSION_1_8
-      task.targetCompatibility = JavaVersion.VERSION_1_8
-
       task.options.errorprone {
         excludedPaths = '.*/build/generated/source/proto/.*'
         check('MissingFail', CheckSeverity.ERROR)
"
https://github.com/junit-team/junit4/commit/6ee76dc22e56457cb5904eb6c5c0bf97939880cb,Update build_tests.sh to test 'ant profile' ,https://api.github.com/repos/junit-team/junit4/commits/6ee76dc22e56457cb5904eb6c5c0bf97939880cb,"@@ -11,3 +11,4 @@ MaxCore.max
 build
 out
 
+java.hprof.txt
@@ -14,6 +14,12 @@ function TEST_ant_dist {
   ls junit${version}/junit-${version}.jar
 }
 
+function TEST_ant_profile {
+  rm -rf java.hprof.txt
+  ant profile
+  ls java.hprof.txt
+}
+
 function get_junit_version {
   ant print.version | grep echo | sed 's/.*echo..\([1-9].*\)/\1/'
 }
@@ -0,0 +1,4 @@
+Can't open /Users/saff/git-repos/cry-overconfident-headline/junit/doc/ReleaseNotes4.9-RC1.txt: No such file or directory at buil
+d/Markdown.pl line 218.
+Use of uninitialized value $text in substitution (s///) at build/Markdown.pl line 245.
+Use of uninitialized value $text in substitution (s///) at build/Markdown.pl line 246.
@@ -9,7 +9,7 @@ private Version() {
 	}
 
 	public static String id() {
-		return ""4.9-SNAPSHOT-20100512-0041"";
+		return ""4.9-RC1"";
 	}
 	
 	public static void main(String[] args) {
"
https://github.com/square/okhttp/commit/855c114f4f6fce3e0e1ae71479f89c9d5ad066d6,"Read/write access for byte, short and int.  <enter> This is big-endian only because that's all we use in OkHttp. ",https://api.github.com/repos/square/okhttp/commits/855c114f4f6fce3e0e1ae71479f89c9d5ad066d6,"@@ -51,6 +51,91 @@ public long byteCount() {
     return byteCount;
   }
 
+  /** Reads a byte from the front of this buffer and returns it. */
+  public byte readByte() {
+    if (byteCount < 1) throw new IllegalArgumentException(""byteCount < 1: "" + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    byte[] data = segment.data;
+    byte b = data[pos++];
+    byteCount -= 1;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return b;
+  }
+
+  /** Reads a Big-Endian short from the front of this buffer and returns it. */
+  public short readShort() {
+    if (byteCount < 2) throw new IllegalArgumentException(""byteCount < 2: "" + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the short is split across multiple segments, delegate to readByte().
+    if (limit - pos < 2) {
+      int s = (readByte() & 0xff) << 8
+          |   (readByte() & 0xff);
+      return (short) s;
+    }
+
+    byte[] data = segment.data;
+    int s = (data[pos++] & 0xff) << 8
+        |   (data[pos++] & 0xff);
+    byteCount -= 2;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return (short) s;
+  }
+
+  /** Reads a Big-Endian int from the front of this buffer and returns it. */
+  public int readInt() {
+    if (byteCount < 4) throw new IllegalArgumentException(""byteCount < 4: "" + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the int is split across multiple segments, delegate to readByte().
+    if (limit - pos < 4) {
+      return (readByte() & 0xff) << 24
+          |  (readByte() & 0xff) << 16
+          |  (readByte() & 0xff) << 8
+          |  (readByte() & 0xff);
+    }
+
+    byte[] data = segment.data;
+    int i = (data[pos++] & 0xff) << 24
+        |   (data[pos++] & 0xff) << 16
+        |   (data[pos++] & 0xff) << 8
+        |   (data[pos++] & 0xff);
+    byteCount -= 4;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return i;
+  }
+
   /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
   public ByteString readByteString(int byteCount) {
     return new ByteString(readBytes(byteCount));
@@ -87,20 +172,21 @@ private byte[] readBytes(int byteCount) {
 
   /** Appends {@code byteString} to this. */
   public void write(ByteString byteString) {
-    write(byteString.data);
+    write(byteString.data, 0, byteString.data.length);
   }
 
   /** Encodes {@code string} as UTF-8 and appends the bytes to this. */
   public void writeUtf8(String string) {
-    write(string.getBytes(Util.UTF_8));
+    byte[] data = string.getBytes(Util.UTF_8);
+    write(data, 0, data.length);
   }
 
-  private void write(byte[] data) {
-    int offset = 0;
-    while (offset < data.length) {
-      Segment tail = writableSegment();
+  void write(byte[] data, int offset, int byteCount) {
+    int limit = offset + byteCount;
+    while (offset < limit) {
+      Segment tail = writableSegment(1);
 
-      int toCopy = Math.min(data.length - offset, Segment.SIZE - tail.limit);
+      int toCopy = Math.min(limit - offset, Segment.SIZE - tail.limit);
       System.arraycopy(data, offset, tail.data, tail.limit, toCopy);
 
       offset += toCopy;
@@ -110,15 +196,54 @@ private void write(byte[] data) {
     this.byteCount += data.length;
   }
 
-  /** Returns a tail segment that we can write bytes to, creating it if necessary. */
-  Segment writableSegment() {
+  /** Appends a Big-Endian byte to the end of this buffer. */
+  public OkBuffer writeByte(int b) {
+    Segment tail = writableSegment(1);
+    tail.data[tail.limit++] = (byte) b;
+    byteCount += 1;
+    return this;
+  }
+
+  /** Appends a Big-Endian short to the end of this buffer. */
+  public OkBuffer writeShort(int s) {
+    Segment tail = writableSegment(2);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((s >> 8) & 0xff);
+    data[limit++] = (byte)  (s       & 0xff);
+    tail.limit = limit;
+    byteCount += 2;
+    return this;
+  }
+
+  /** Appends a Big-Endian int to the end of this buffer. */
+  public OkBuffer writeInt(int i) {
+    Segment tail = writableSegment(4);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((i >> 24) & 0xff);
+    data[limit++] = (byte) ((i >> 16) & 0xff);
+    data[limit++] = (byte) ((i >>  8) & 0xff);
+    data[limit++] = (byte)  (i        & 0xff);
+    tail.limit = limit;
+    byteCount += 4;
+    return this;
+  }
+
+  /**
+   * Returns a tail segment that we can write at least {@code minimumCapacity}
+   * bytes to, creating it if necessary.
+   */
+  Segment writableSegment(int minimumCapacity) {
+    if (minimumCapacity < 1 || minimumCapacity > Segment.SIZE) throw new IllegalArgumentException();
+
     if (head == null) {
       head = SegmentPool.INSTANCE.take(); // Acquire a first segment.
       return head.next = head.prev = head;
     }
 
     Segment tail = head.prev;
-    if (tail.limit == Segment.SIZE) {
+    if (tail.limit + minimumCapacity > Segment.SIZE) {
       tail = tail.push(SegmentPool.INSTANCE.take()); // Append a new empty segment to fill up.
     }
     return tail;
@@ -264,14 +389,14 @@ List<Integer> segmentSizes() {
    */
   @Override public String toString() {
     if (byteCount > 0x100000) return super.toString();
-    char[] result = new char[(int) (byteCount * 2)];
+    int charCount = (int) (byteCount * 2);
+    char[] result = new char[charCount];
     int offset = 0;
-    for (Segment s = head; offset < byteCount; s = s.next) {
+    for (Segment s = head; offset < charCount; s = s.next) {
       for (int i = s.pos; i < s.limit; i++) {
         result[offset++] = HEX_DIGITS[(s.data[i] >> 4) & 0xf];
         result[offset++] = HEX_DIGITS[s.data[i] & 0xf];
       }
-      offset += s.limit - s.pos;
     }
     return new String(result);
   }
@@ -67,7 +67,7 @@ public static Source source(final InputStream in) {
           OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
         if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
         deadline.throwIfReached();
-        Segment tail = sink.writableSegment();
+        Segment tail = sink.writableSegment(1);
         int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);
         int bytesRead = in.read(tail.data, tail.limit, maxToCopy);
         if (bytesRead == -1) return -1;
@@ -316,6 +316,106 @@ private List<Integer> moveBytesBetweenBuffers(String... contents) {
     assertEquals(-1, source.read(sink, 1, Deadline.NONE));
   }
 
+  @Test public void writeBytes() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeByte(0xab);
+    data.writeByte(0xcd);
+    assertEquals(""abcd"", data.toString());
+  }
+
+  @Test public void writeLastByteInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 1));
+    data.writeByte(0x20);
+    data.writeByte(0x21);
+    assertEquals(asList(Segment.SIZE, 1), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 1), data.readUtf8(Segment.SIZE - 1));
+    assertEquals(""2021"", data.toString());
+  }
+
+  @Test public void writeShort() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeShort(0xabcd);
+    data.writeShort(0x4321);
+    assertEquals(""abcd4321"", data.toString());
+  }
+
+  @Test public void writeInt() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(""abcdef0187654321"", data.toString());
+  }
+
+  @Test public void writeLastIntegerInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 4));
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(asList(Segment.SIZE, 4), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 4), data.readUtf8(Segment.SIZE - 4));
+    assertEquals(""abcdef0187654321"", data.toString());
+  }
+
+  @Test public void writeIntegerDoesntQuiteFitInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 3));
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(asList(Segment.SIZE - 3, 8), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 3), data.readUtf8(Segment.SIZE - 3));
+    assertEquals(""abcdef0187654321"", data.toString());
+  }
+
+  @Test public void readByte() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] { (byte) 0xab, (byte) 0xcd }));
+    assertEquals((byte) 0xab, data.readByte());
+    assertEquals((byte) 0xcd, data.readByte());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readShort() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
+    }));
+    assertEquals((short) 0xabcd, data.readShort());
+    assertEquals((short) 0xef01, data.readShort());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readShortSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 1));
+    data.write(new ByteString(new byte[] { (byte) 0xab, (byte) 0xcd }));
+    data.readUtf8(Segment.SIZE - 1);
+    assertEquals((short) 0xabcd, data.readShort());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readInt() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01,
+        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21
+    }));
+    assertEquals(0xabcdef01, data.readInt());
+    assertEquals(0x87654321, data.readInt());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readIntSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 3));
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
+    }));
+    data.readUtf8(Segment.SIZE - 3);
+    assertEquals(0xabcdef01, data.readInt());
+    assertEquals(0, data.byteCount());
+  }
+
   private String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
"
https://github.com/square/okhttp/commit/37c01895cca5ec2bec26a3d381611f0938acd6d0,Define async APIs and switch Job to use HttpEngine directly.  <enter> Using HttpEngine directly introduces some duplicated code with HttpURLConnection. It also breaks the response cache. I think this is the best route going forward; and eventually we could invert this relationship to have HttpURLConnection depending on Job directly rather than vice versa. ,https://api.github.com/repos/square/okhttp/commits/37c01895cca5ec2bec26a3d381611f0938acd6d0,"@@ -15,9 +15,9 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.http.ResponseHeaders;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -33,8 +33,8 @@ final class Dispatcher {
   private final Map<Object, List<Job>> enqueuedJobs = new LinkedHashMap<Object, List<Job>>();
 
   public synchronized void enqueue(
-      HttpURLConnection connection, Request request, Response.Receiver responseReceiver) {
-    Job job = new Job(this, connection, request, responseReceiver);
+      OkHttpClient client, Request request, Response.Receiver responseReceiver) {
+    Job job = new Job(this, client, request, responseReceiver);
     List<Job> jobsForTag = enqueuedJobs.get(request.tag());
     if (jobsForTag == null) {
       jobsForTag = new ArrayList<Job>(2);
@@ -53,25 +53,30 @@ public synchronized void cancel(Object tag) {
   }
 
   synchronized void finished(Job job) {
-    List<Job> jobs = enqueuedJobs.get(job.request.tag());
+    List<Job> jobs = enqueuedJobs.get(job.tag());
     if (jobs != null) jobs.remove(job);
   }
 
   static class RealResponseBody extends Response.Body {
-    private final HttpURLConnection connection;
+    private final ResponseHeaders responseHeaders;
     private final InputStream in;
 
-    RealResponseBody(HttpURLConnection connection, InputStream in) {
-      this.connection = connection;
+    RealResponseBody(ResponseHeaders responseHeaders, InputStream in) {
+      this.responseHeaders = responseHeaders;
       this.in = in;
     }
 
-    @Override public String contentType() {
-      return connection.getHeaderField(""Content-Type"");
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
+
+    @Override public MediaType contentType() {
+      String contentType = responseHeaders.getContentType();
+      return contentType != null ? MediaType.parse(contentType) : null;
     }
 
     @Override public long contentLength() {
-      return connection.getContentLength(); // TODO: getContentLengthLong
+      return responseHeaders.getContentLength();
     }
 
     @Override public InputStream byteStream() throws IOException {
@@ -15,71 +15,218 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.http.HttpAuthenticator;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.HttpTransport;
+import com.squareup.okhttp.internal.http.HttpsEngine;
+import com.squareup.okhttp.internal.http.Policy;
+import com.squareup.okhttp.internal.http.RawHeaders;
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.URL;
 
-final class Job implements Runnable {
-  final HttpURLConnection connection;
-  final Request request;
-  final Response.Receiver responseReceiver;
-  final Dispatcher dispatcher;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_PERM;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_TEMP;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MULT_CHOICE;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_PROXY_AUTH;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_SEE_OTHER;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_TEMP_REDIRECT;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_UNAUTHORIZED;
 
-  public Job(Dispatcher dispatcher, HttpURLConnection connection, Request request,
+final class Job implements Runnable, Policy {
+  private final Dispatcher dispatcher;
+  private final OkHttpClient client;
+  private final Response.Receiver responseReceiver;
+
+  /** The request; possibly a consequence of redirects or auth headers. */
+  private Request request;
+
+  public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
       Response.Receiver responseReceiver) {
     this.dispatcher = dispatcher;
-    this.connection = connection;
+    this.client = client;
     this.request = request;
     this.responseReceiver = responseReceiver;
   }
 
+  @Override public int getChunkLength() {
+    return request.body().contentLength() == -1 ? HttpTransport.DEFAULT_CHUNK_LENGTH : -1;
+  }
+
+  @Override public long getFixedContentLength() {
+    return request.body().contentLength();
+  }
+
+  @Override public boolean getUseCaches() {
+    return false; // TODO.
+  }
+
+  @Override public HttpURLConnection getHttpConnectionToCache() {
+    return null;
+  }
+
+  @Override public URL getURL() {
+    return request.url();
+  }
+
+  @Override public long getIfModifiedSince() {
+    return 0; // For HttpURLConnection only. We let the cache drive this.
+  }
+
+  @Override public boolean usingProxy() {
+    return false; // We let the connection decide this.
+  }
+
+  @Override public void setSelectedProxy(Proxy proxy) {
+    // Do nothing.
+  }
+
+  Object tag() {
+    return request.tag();
+  }
+
   @Override public void run() {
     try {
-      sendRequest();
-      Response response = readResponse();
+      Response response = execute();
       responseReceiver.onResponse(response);
     } catch (IOException e) {
       responseReceiver.onFailure(new Failure.Builder()
           .request(request)
           .exception(e)
           .build());
     } finally {
-      connection.disconnect();
+      // TODO: close the response body
+      // TODO: release the HTTP engine (potentially multiple!)
       dispatcher.finished(this);
     }
   }
 
-  private HttpURLConnection sendRequest() throws IOException {
-    for (int i = 0; i < request.headerCount(); i++) {
-      connection.addRequestProperty(request.headerName(i), request.headerValue(i));
-    }
-    Request.Body body = request.body();
-    if (body != null) {
-      connection.setDoOutput(true);
-      long contentLength = body.contentLength();
-      if (contentLength == -1 || contentLength > Integer.MAX_VALUE) {
-        connection.setChunkedStreamingMode(0);
-      } else {
-        // Don't call setFixedLengthStreamingMode(long); that's only available on Java 1.7+.
-        connection.setFixedLengthStreamingMode((int) contentLength);
+  private Response execute() throws IOException {
+    Connection connection = null;
+    Response redirectedBy = null;
+
+    while (true) {
+      HttpEngine engine = newEngine(connection);
+
+      Request.Body body = request.body();
+      if (body != null) {
+        MediaType contentType = body.contentType();
+        if (contentType == null) throw new IllegalStateException(""contentType == null"");
+        if (engine.getRequestHeaders().getContentType() == null) {
+          engine.getRequestHeaders().setContentType(contentType.toString());
+        }
+      }
+
+      engine.sendRequest();
+
+      if (body != null) {
+        body.writeTo(engine.getRequestBody());
       }
-      body.writeTo(connection.getOutputStream());
+
+      engine.readResponse();
+
+      int responseCode = engine.getResponseCode();
+      Dispatcher.RealResponseBody responseBody = new Dispatcher.RealResponseBody(
+          engine.getResponseHeaders(), engine.getResponseBody());
+
+      Response response = new Response.Builder(request, responseCode)
+          .rawHeaders(engine.getResponseHeaders().getHeaders())
+          .body(responseBody)
+          .redirectedBy(redirectedBy)
+          .build();
+
+      Request redirect = processResponse(engine, response);
+
+      if (redirect == null) {
+        engine.automaticallyReleaseConnectionToPool();
+        return response;
+      }
+
+      // TODO: fail if too many redirects
+      // TODO: fail if not following redirects
+      // TODO: release engine
+
+      connection = sameConnection(request, redirect) ? engine.getConnection() : null;
+      redirectedBy = response;
+      request = redirect;
     }
-    return connection;
   }
 
-  private Response readResponse() throws IOException {
-    int responseCode = connection.getResponseCode();
-    Response.Builder responseBuilder = new Response.Builder(request, responseCode);
+  HttpEngine newEngine(Connection connection) throws IOException {
+    String protocol = request.url().getProtocol();
+    RawHeaders requestHeaders = request.rawHeaders();
+    if (protocol.equals(""http"")) {
+      return new HttpEngine(client, this, request.method(), requestHeaders, connection, null);
+    } else if (protocol.equals(""https"")) {
+      return new HttpsEngine(client, this, request.method(), requestHeaders, connection, null);
+    } else {
+      throw new AssertionError();
+    }
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving {@code
+   * response}. This will either add authentication headers or follow
+   * redirects. If a follow-up is either unnecessary or not applicable, this
+   * returns null.
+   */
+  private Request processResponse(HttpEngine engine, Response response) throws IOException {
+    Request request = response.request();
+    Proxy selectedProxy = engine.getConnection() != null
+        ? engine.getConnection().getRoute().getProxy()
+        : client.getProxy();
+    int responseCode = response.code();
+
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException(""Received HTTP_PROXY_AUTH (407) code while not using proxy"");
+        }
+        // fall-through
+      case HTTP_UNAUTHORIZED:
+        RawHeaders successorRequestHeaders = request.rawHeaders();
+        boolean credentialsFound = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
+            response.code(), response.rawHeaders(), successorRequestHeaders, selectedProxy,
+            this.request.url());
+        return credentialsFound
+            ? request.newBuilder().rawHeaders(successorRequestHeaders).build()
+            : null;
 
-    for (int i = 0; true; i++) {
-      String name = connection.getHeaderFieldKey(i);
-      if (name == null) break;
-      String value = connection.getHeaderField(i);
-      responseBuilder.addHeader(name, value);
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+      case HTTP_TEMP_REDIRECT:
+        String method = request.method();
+        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals(""GET"") && !method.equals(""HEAD"")) {
+          // ""If the 307 status code is received in response to a request other than GET or HEAD,
+          // the user agent MUST NOT automatically redirect the request""
+          return null;
+        }
+
+        String location = response.header(""Location"");
+        if (location == null) {
+          return null;
+        }
+
+        URL url = new URL(request.url(), location);
+        if (!url.getProtocol().equals(""https"") && !url.getProtocol().equals(""http"")) {
+          return null; // Don't follow redirects to unsupported protocols.
+        }
+
+        return this.request.newBuilder().url(url).build();
+
+      default:
+        return null;
     }
+  }
 
-    responseBuilder.body(new Dispatcher.RealResponseBody(connection, connection.getInputStream()));
-    // TODO: set redirectedBy
-    return responseBuilder.build();
+  private boolean sameConnection(Request a, Request b) {
+    return a.url().getHost().equals(b.url().getHost())
+        && getEffectivePort(a.url()) == getEffectivePort(b.url())
+        && a.url().getProtocol().equals(b.url().getProtocol());
   }
 }
@@ -324,7 +324,7 @@ public List<String> getTransports() {
     // Create the HttpURLConnection immediately so the enqueued job gets the current settings of
     // this client. Otherwise changes to this client (socket factory, redirect policy, etc.) may
     // incorrectly be reflected in the request when it is dispatched later.
-    dispatcher.enqueue(open(request.url()), request, responseReceiver);
+    dispatcher.enqueue(copyWithDefaults(), request, responseReceiver);
   }
 
   /**
@@ -74,6 +74,10 @@ public Set<String> headerNames() {
     return headers.names();
   }
 
+  RawHeaders rawHeaders() {
+    return new RawHeaders(headers);
+  }
+
   public int headerCount() {
     return headers.length();
   }
@@ -94,16 +98,21 @@ public Object tag() {
     return tag;
   }
 
+  Builder newBuilder() {
+    return new Builder(url)
+        .method(method, body)
+        .rawHeaders(headers)
+        .tag(tag);
+  }
+
   public abstract static class Body {
+    /** Returns the Content-Type header for this body. */
+    public abstract MediaType contentType();
+
     /**
-     * Returns the Content-Type header for this body, or null if the content
-     * type is unknown.
+     * Returns the number of bytes that will be written to {@code out} in a call
+     * to {@link #writeTo}, or -1 if that count is unknown.
      */
-    public MediaType contentType() {
-      return null;
-    }
-
-    /** Returns the number of bytes in this body, or -1 if that count is unknown. */
     public long contentLength() {
       return -1;
     }
@@ -183,7 +192,7 @@ public static Body create(final MediaType contentType, final File file) {
   public static class Builder {
     private URL url;
     private String method = ""GET"";
-    private final RawHeaders headers = new RawHeaders();
+    private RawHeaders headers = new RawHeaders();
     private Body body;
     private Object tag;
 
@@ -228,6 +237,11 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    Builder rawHeaders(RawHeaders rawHeaders) {
+      headers = new RawHeaders(rawHeaders);
+      return this;
+    }
+
     public Builder get() {
       return method(""GET"", null);
     }
@@ -22,9 +22,12 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.nio.charset.Charset;
 import java.util.List;
 import java.util.Set;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
+
 /**
  * An HTTP response. Instances of this class are not immutable: the response
  * body is a one-shot value that may be consumed only once. All other properties
@@ -93,6 +96,10 @@ public String headerName(int index) {
     return headers.getFieldName(index);
   }
 
+  RawHeaders rawHeaders() {
+    return new RawHeaders(headers);
+  }
+
   public String headerValue(int index) {
     return headers.getValue(index);
   }
@@ -112,17 +119,34 @@ public Response redirectedBy() {
   }
 
   public abstract static class Body {
-    public String contentType() {
-      return null;
-    }
+    /** Multiple calls to {@link #charStream()} must return the same instance. */
+    private Reader reader;
 
-    public long contentLength() {
-      return -1;
-    }
+    /**
+     * Returns true if further data from this response body should be read at
+     * this time. For asynchronous transports like SPDY and HTTP/2.0, this will
+     * return false once all locally-available body bytes have been read.
+     *
+     * <p>Clients with many concurrent downloads can use this method to reduce
+     * the number of idle threads blocking on reads. See {@link
+     * Receiver#onResponse} for details.
+     */
+    // <h3>Body.ready() vs. InputStream.available()</h3>
+    // TODO: Can we fix response bodies to implement InputStream.available well?
+    // The deflater implementation is broken by default but we could do better.
+    public abstract boolean ready() throws IOException;
+
+    public abstract MediaType contentType();
+
+    /**
+     * Returns the number of bytes in that will returned by {@link #bytes}, or
+     * {@link #byteStream}, or -1 if unknown.
+     */
+    public abstract long contentLength();
 
     public abstract InputStream byteStream() throws IOException;
 
-    public byte[] bytes() throws IOException {
+    public final byte[] bytes() throws IOException {
       long contentLength = contentLength();
       if (contentLength > Integer.MAX_VALUE) {
         throw new IOException(""Cannot buffer entire body for content length: "" + contentLength);
@@ -143,33 +167,77 @@ public byte[] bytes() throws IOException {
     }
 
     /**
-     * Returns the response bytes as a UTF-8 character stream. Do not call this
-     * method if the response content is not a UTF-8 character stream.
+     * Returns the response as a character stream decoded with the charset
+     * of the Content-Type header. If that header is either absent or lacks a
+     * charset, this will attempt to decode the response body as UTF-8.
      */
-    public Reader charStream() throws IOException {
-      // TODO: parse content-type.
-      return new InputStreamReader(byteStream(), ""UTF-8"");
+    public final Reader charStream() throws IOException {
+      if (reader == null) {
+        reader = new InputStreamReader(byteStream(), charset());
+      }
+      return reader;
     }
 
     /**
-     * Returns the response bytes as a UTF-8 string. Do not call this method if
-     * the response content is not a UTF-8 character stream.
+     * Returns the response as a string decoded with the charset of the
+     * Content-Type header. If that header is either absent or lacks a charset,
+     * this will attempt to decode the response body as UTF-8.
      */
-    public String string() throws IOException {
-      // TODO: parse content-type.
-      return new String(bytes(), ""UTF-8"");
+    public final String string() throws IOException {
+      return new String(bytes(), charset().name());
+    }
+
+    private Charset charset() {
+      MediaType contentType = contentType();
+      return contentType != null ? contentType.charset(UTF_8) : UTF_8;
     }
   }
 
   public interface Receiver {
+    /**
+     * Called when the request could not be executed due to a connectivity
+     * problem or timeout. Because networks can fail during an exchange, it is
+     * possible that the remote server accepted the request before the failure.
+     */
     void onFailure(Failure failure);
-    void onResponse(Response response) throws IOException;
+
+    /**
+     * Called when the HTTP response was successfully returned by the remote
+     * server. The receiver may proceed to read the response body with the
+     * response's {@link #body} method.
+     *
+     * <p>Note that transport-layer success (receiving a HTTP response code,
+     * headers and body) does not necessarily indicate application-layer
+     * success: {@code response} may still indicate an unhappy HTTP response
+     * code like 404 or 500.
+     *
+     * <h3>Non-blocking responses</h3>
+     *
+     * <p>Receivers do not need to block while waiting for the response body to
+     * download. Instead, they can get called back as data arrives. Use {@link
+     * Body#ready} to check if bytes should be read immediately. While there is
+     * data ready, read it. If there isn't, return false: receivers will be
+     * called back with {@code onResponse()} as additional data is downloaded.
+     *
+     * <p>Return true to indicate that the receiver has finished handling the
+     * response body. If the response body has unread data, it will be
+     * discarded.
+     *
+     * <p>When the response body has been fully consumed the returned value is
+     * undefined.
+     *
+     * <p>The current implementation of {@link Body#ready} always returns true
+     * when the underlying transport is HTTP/1. This results in blocking on that
+     * transport. For effective non-blocking your server must support SPDY or
+     * HTTP/2.
+     */
+    boolean onResponse(Response response) throws IOException;
   }
 
   public static class Builder {
     private final Request request;
     private final int code;
-    private final RawHeaders headers = new RawHeaders();
+    private RawHeaders headers = new RawHeaders();
     private Body body;
     private Response redirectedBy;
 
@@ -198,6 +266,11 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    Builder rawHeaders(RawHeaders rawHeaders) {
+      headers = new RawHeaders(rawHeaders);
+      return this;
+    }
+
     public Builder body(Body body) {
       this.body = body;
       return this;
@@ -370,10 +370,10 @@ private void writeBufferedChunkToSocket() throws IOException {
 
   /** An HTTP body with a fixed length specified in advance. */
   private static class FixedLengthInputStream extends AbstractHttpInputStream {
-    private int bytesRemaining;
+    private long bytesRemaining;
 
     public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine,
-        int length) throws IOException {
+        long length) throws IOException {
       super(is, httpEngine, cacheRequest);
       bytesRemaining = length;
       if (bytesRemaining == 0) {
@@ -387,7 +387,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
       if (bytesRemaining == 0) {
         return -1;
       }
-      int read = in.read(buffer, offset, Math.min(count, bytesRemaining));
+      int read = in.read(buffer, offset, (int) Math.min(count, bytesRemaining));
       if (read == -1) {
         unexpectedEndOfInput(); // the server didn't supply the promised content length
         throw new ProtocolException(""unexpected end of stream"");
@@ -402,7 +402,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
 
     @Override public int available() throws IOException {
       checkNotClosed();
-      return bytesRemaining == 0 ? 0 : Math.min(in.available(), bytesRemaining);
+      return bytesRemaining == 0 ? 0 : (int) Math.min(in.available(), bytesRemaining);
     }
 
     @Override public void close() throws IOException {
@@ -60,7 +60,7 @@
 public class HttpURLConnectionImpl extends HttpURLConnection implements Policy {
 
   /** Numeric status code, 307: Temporary Redirect. */
-  static final int HTTP_TEMP_REDIRECT = 307;
+  public static final int HTTP_TEMP_REDIRECT = 307;
 
   /**
    * How many redirects should we follow? Chrome follows 21; Firefox, curl,
@@ -311,7 +311,7 @@ private HttpEngine getResponse() throws IOException {
       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
       // redirect should keep the same method, Chrome, Firefox and the
       // RI all issue GETs when following any redirect.
-      int responseCode = getResponseCode();
+      int responseCode = httpEngine.getResponseCode();
       if (responseCode == HTTP_MULT_CHOICE
           || responseCode == HTTP_MOVED_PERM
           || responseCode == HTTP_MOVED_TEMP
@@ -321,8 +321,7 @@ private HttpEngine getResponse() throws IOException {
       }
 
       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {
-        throw new HttpRetryException(""Cannot retry streamed HTTP body"",
-            httpEngine.getResponseCode());
+        throw new HttpRetryException(""Cannot retry streamed HTTP body"", responseCode);
       }
 
       if (retry == Retry.DIFFERENT_CONNECTION) {
@@ -413,7 +412,7 @@ enum Retry {
 
   /**
    * Returns the retry action to take for the current response headers. The
-   * headers, proxy and target URL or this connection may be adjusted to
+   * headers, proxy and target URL for this connection may be adjusted to
    * prepare for a follow up request.
    */
   private Retry processResponseHeaders() throws IOException {
@@ -114,8 +114,9 @@ public final class ResponseHeaders {
 
   private String contentEncoding;
   private String transferEncoding;
-  private int contentLength = -1;
+  private long contentLength = -1;
   private String connection;
+  private String contentType;
 
   public ResponseHeaders(URI uri, RawHeaders headers) {
     this.uri = uri;
@@ -172,9 +173,11 @@ public ResponseHeaders(URI uri, RawHeaders headers) {
         transferEncoding = value;
       } else if (""Content-Length"".equalsIgnoreCase(fieldName)) {
         try {
-          contentLength = Integer.parseInt(value);
+          contentLength = Long.parseLong(value);
         } catch (NumberFormatException ignored) {
         }
+      } else if (""Content-Type"".equalsIgnoreCase(fieldName)) {
+        contentType = value;
       } else if (""Connection"".equalsIgnoreCase(fieldName)) {
         connection = value;
       } else if (SENT_MILLIS.equalsIgnoreCase(fieldName)) {
@@ -263,10 +266,14 @@ public String getContentEncoding() {
     return contentEncoding;
   }
 
-  public int getContentLength() {
+  public long getContentLength() {
     return contentLength;
   }
 
+  public String getContentType() {
+    return contentType;
+  }
+
   public String getConnection() {
     return connection;
   }
@@ -68,5 +68,6 @@ public final class AsyncApiTest {
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals(""def"", recordedRequest.getUtf8Body());
     assertEquals(""3"", recordedRequest.getHeader(""Content-Length""));
+    assertEquals(""text/plain; charset=utf-8"", recordedRequest.getHeader(""Content-Type""));
   }
 }
@@ -15,9 +15,12 @@
  */
 package com.squareup.okhttp;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -26,17 +29,40 @@
 public class RecordingReceiver implements Response.Receiver {
   public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
+  private final Map<Request, ByteArrayOutputStream> inFlightResponses
+      = new LinkedHashMap<Request, ByteArrayOutputStream>();
   private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
 
   @Override public synchronized void onFailure(Failure failure) {
     responses.add(new RecordedResponse(failure.request(), null, null, failure));
     notifyAll();
   }
 
-  @Override public synchronized void onResponse(Response response) throws IOException {
-    responses.add(new RecordedResponse(
-        response.request(), response, response.body().string(), null));
-    notifyAll();
+  @Override public synchronized boolean onResponse(Response response) throws IOException {
+    ByteArrayOutputStream out = inFlightResponses.get(response.request());
+    if (out == null) {
+      out = new ByteArrayOutputStream();
+      inFlightResponses.put(response.request(), out);
+    }
+
+    byte[] buffer = new byte[1024];
+    Response.Body body = response.body();
+
+    while (body.ready()) {
+      int c = body.byteStream().read(buffer);
+
+      if (c == -1) {
+        inFlightResponses.remove(response.request());
+        responses.add(new RecordedResponse(
+            response.request(), response, out.toString(""UTF-8""), null));
+        notifyAll();
+        return true;
+      }
+
+      out.write(buffer, 0, c);
+    }
+
+    return false;
   }
 
   /**
"
https://github.com/junit-team/junit4/commit/236e75bd968935cf8728c3f7aaaccaefd2f9c737,Adapt links to reflect repo rename ,https://api.github.com/repos/junit-team/junit4/commits/236e75bd968935cf8728c3f7aaaccaefd2f9c737,"@@ -11,4 +11,4 @@ BUILDING FROM JARS OR ZIPS:
 The contents of the zip and jar files are largely maintained for historical
 reasons.  We do not at this time have an official way to build from the src
 jar or zip.  If this is an important missing feature, please let us know
-at http://github.com/junit-team/junit/issues
+at http://github.com/junit-team/junit4/issues
@@ -2,9 +2,9 @@
 JUnit is a simple framework to write repeatable tests. It is an instance of the xUnit architecture for unit testing frameworks.
 
 For more information, please visit:
-* [Wiki](https://github.com/junit-team/junit/wiki)
-* [Download and Install guide](https://github.com/junit-team/junit/wiki/Download-and-Install)
-* [Getting Started](https://github.com/junit-team/junit/wiki/Getting-started)
+* [Wiki](https://github.com/junit-team/junit4/wiki)
+* [Download and Install guide](https://github.com/junit-team/junit4/wiki/Download-and-Install)
+* [Getting Started](https://github.com/junit-team/junit4/wiki/Getting-started)
 
 [![Latest Build Status](https://junit.ci.cloudbees.com/job/JUnit/badge/icon)](https://junit.ci.cloudbees.com/)
 
@@ -82,7 +82,7 @@
      reinholdfuereder@github For initial test for GH-39
 
 2011 Apr 15
-     ububenheimer@github for bug report https://github.com/junit-team/junit/issues/208
+     ububenheimer@github for bug report https://github.com/junit-team/junit4/issues/208
 
 2011 Apr 29
      reinholdfuereder@github: bug report, test, and fix for GH-38:
@@ -1,6 +1,6 @@
 <h2>Summary of Changes in version 4.10 [unreleased!]</h2>
 
-<p>A full summary of commits between 4.9 and 4.10 is on <a href=""https://github.com/junit-team/junit/compare/r4.9...4.10"">github</a></p>
+<p>A full summary of commits between 4.9 and 4.10 is on <a href=""https://github.com/junit-team/junit4/compare/r4.9...4.10"">github</a></p>
 
 <h3>junit-dep has correct contents</h3>
 
@@ -2,7 +2,7 @@
 
 Thanks to a full cast of contributors of bug fixes and new features.
 
-A full summary of commits between 4.9 and 4.10 is on [github](https://github.com/junit-team/junit/compare/r4.9...4.10)
+A full summary of commits between 4.9 and 4.10 is on [github](https://github.com/junit-team/junit4/compare/r4.9...4.10)
 
 ### junit-dep has correct contents ###
 
@@ -2,23 +2,23 @@
 
 # Assertions
 
-### [Pull request #611:](https://github.com/junit-team/junit/pull/611) Assert.assertNotEquals() for `float` parameters
+### [Pull request #611:](https://github.com/junit-team/junit4/pull/611) Assert.assertNotEquals() for `float` parameters
 
 Version 4.11 added `Assert.assertEquals()` for `float` parameters with a delta, and `Assert.assertNotEquals()`. This is the combination of those two features.
 
 
-### [Pull request #632:](https://github.com/junit-team/junit/pull/632) Assert.assertArrayEquals() for `boolean[]` parameters.
+### [Pull request #632:](https://github.com/junit-team/junit4/pull/632) Assert.assertArrayEquals() for `boolean[]` parameters.
 
 `Assert.assertArrayEquals()` previously existed for all primitive array types, except `boolean[]`. This has now been added for `boolean[]`.
 
 
-### [Pull request #918:](https://github.com/junit-team/junit/pull/918) Avoid potentially expensive reflection-based loop in Assert.assertArrayEquals()
+### [Pull request #918:](https://github.com/junit-team/junit4/pull/918) Avoid potentially expensive reflection-based loop in Assert.assertArrayEquals()
 
 In the usual case, where the array elements are in fact exactly equal, the potentially expensive reflection-based loop to compare them is avoided by using `Arrays.deepEquals()` first. The exact comparison is only executed when `deepEquals()` returns `false`.
 
 
 # Command-line options
-### [Pull request #647:](https://github.com/junit-team/junit/pull/647) Support command-line `--filter` param.
+### [Pull request #647:](https://github.com/junit-team/junit4/pull/647) Support command-line `--filter` param.
 
 When running JUnit from the command line, a command-line parameter can be supplied using `--filter`, which supplies a filter that will restrict which tests and subtests from the rest of the command will be run.  For example, this will run only the tests in ExampleTestSuite that are in categories Cat1 or Cat2:
 
@@ -33,12 +33,12 @@ In general, the argument to `--filter` should be `ClassName=param`, where `Class
 # Test Runners
 
 
-### [Pull request #763:](https://github.com/junit-team/junit/pull/763) Allow custom test runners to create their own TestClasses and customize the scanning of annotations.
+### [Pull request #763:](https://github.com/junit-team/junit4/pull/763) Allow custom test runners to create their own TestClasses and customize the scanning of annotations.
 
 This introduces some extension points to `ParentRunner` to allow subclasses to control creation
 of the `TestClass` instance and to scan for annotations.
 
-### [Pull request #817:](https://github.com/junit-team/junit/pull/817) Support for context hierarchies
+### [Pull request #817:](https://github.com/junit-team/junit4/pull/817) Support for context hierarchies
 
 The `AnnotatedBuilder` is a strategy for constructing runners for test classes that have been annotated with the `@RunWith` annotation. All tests within such a class will be executed using the runner that was specified within the annotation.
 
@@ -95,30 +95,30 @@ The key points to note here are:
 One example of a runner that makes use of this extension is the Hierarchical Context Runner (see https://github.com/bechte/junit-hierarchicalcontextrunner/wiki).
 
 
-### [Pull request #716:](https://github.com/junit-team/junit/pull/716) Fix annotation collection from superclasses of JUnit3 tests.
+### [Pull request #716:](https://github.com/junit-team/junit4/pull/716) Fix annotation collection from superclasses of JUnit3 tests.
 
 Previously `Description.getAnnotations()` would always return an empty list for _test*_ methods derived from superclasses. 
 
 
-### [Pull request #625 (commit 72af03c49f):](https://github.com/junit-team/junit/commit/72af03c49fdad5f10e36c7eb4e7045feb971d253) Make `RunNotifier` code concurrent.
+### [Pull request #625 (commit 72af03c49f):](https://github.com/junit-team/junit4/commit/72af03c49fdad5f10e36c7eb4e7045feb971d253) Make `RunNotifier` code concurrent.
 
 When running tests from multiple threads, JUnit will now call `RunListener` methods from multiple threads if the listener class is annotated with `@RunListener.ThreadSafe`. In addition, the code in `RunNotifier` has been modified to not use locks.
 
 
-### [Pull request #684:](https://github.com/junit-team/junit/pull/684) Adding `AnnotationValidator` framework and validation checks for `@Category`.
+### [Pull request #684:](https://github.com/junit-team/junit4/pull/684) Adding `AnnotationValidator` framework and validation checks for `@Category`.
 
 This allows for validation to be added to annotations. Validators should extend `AnnotationValidator` and be attached to annotations with the `@ValidateWith` annotation. `CategoryValidator` extends `AnnotationValidator` and ensures that incompatible annotations (`@BeforeClass`, `@AfterClass`, `@Before`, `@After`) are not used in conjunction with `@Category`.
 
 
 # Exception Testing
 
 
-### [Pull request #583:](https://github.com/junit-team/junit/pull/583) [Pull request #720:](https://github.com/junit-team/junit/pull/720) Fix handling of `AssertionError` and `AssumptionViolatedException` in `ExpectedException` rule.
+### [Pull request #583:](https://github.com/junit-team/junit4/pull/583) [Pull request #720:](https://github.com/junit-team/junit4/pull/720) Fix handling of `AssertionError` and `AssumptionViolatedException` in `ExpectedException` rule.
 
 `ExpectedException` didn't handle `AssertionError`s and `AssumptionViolatedException` well. This has been fixed. The new documentation explains the usage of `ExpectedException` for testing these exceptions. The two methods `handleAssertionErrors()` and `handleAssumptionViolatedExceptions()` are not needed anymore. If you have used them, just remove it and read `ExpectedException`'s documentation.
 
 
-### [Pull request #818:](https://github.com/junit-team/junit/pull/818) [Pull request #993:](https://github.com/junit-team/junit/pull/993) External version of AssumptionViolatedException
+### [Pull request #818:](https://github.com/junit-team/junit4/pull/818) [Pull request #993:](https://github.com/junit-team/junit4/pull/993) External version of AssumptionViolatedException
 
 In JUnit 4.11 and earlier, if you wanted to write a custom runner that handled
 `AssumptionViolatedException` or you needed to create an instance of `AssumptionViolatedException`
@@ -133,7 +133,7 @@ simpler than the ones in the internal version. That being said,
 it's recommended that you create `AssumptionViolatedException` via the methods in `Assume`.
 
 
-### [Pull request #985:](https://github.com/junit-team/junit/pull/985) Change AssumptionViolatedException to not set the cause to null; fixes issue #494
+### [Pull request #985:](https://github.com/junit-team/junit4/pull/985) Change AssumptionViolatedException to not set the cause to null; fixes issue #494
 
 Previously, the `AssumptionViolatedException` constructors would explicitly set the cause to `null`
 (unless you use a constructor where you provide a `Throwable`, in which case it would set that as
@@ -144,7 +144,7 @@ With this change, the cause is only set if you pass in a `Throwable`.
 It's recommended that you create `AssumptionViolatedException` via the methods in `Assume`.
 
 
-### [Pull request #542:](https://github.com/junit-team/junit/pull/542) Customized failure message for `ExpectedException`
+### [Pull request #542:](https://github.com/junit-team/junit4/pull/542) Customized failure message for `ExpectedException`
 
 `ExpectedException` now allows customization of the failure message when the test does not throw the expected exception. For example:
 
@@ -163,14 +163,14 @@ return type will match the type of the callable.
 
 
 # Timeout for Tests
-*See also [Timeout for tests](https://github.com/junit-team/junit/wiki/Timeout-for-tests)*
+*See also [Timeout for tests](https://github.com/junit-team/junit4/wiki/Timeout-for-tests)*
 
-### [Pull request #823:](https://github.com/junit-team/junit/pull/823) Throw `TestFailedOnTimeoutException` instead of plain `Exception` on timeout
+### [Pull request #823:](https://github.com/junit-team/junit4/pull/823) Throw `TestFailedOnTimeoutException` instead of plain `Exception` on timeout
 
 When a test times out, a `org.junit.runners.model.TestTimedOutException` is now thrown instead of a plain `java.lang.Exception`.
 
 
-### [Pull request #742:](https://github.com/junit-team/junit/pull/742) [Pull request #986:](https://github.com/junit-team/junit/pull/986) `Timeout` exceptions now include stack trace from stuck thread (experimental)
+### [Pull request #742:](https://github.com/junit-team/junit4/pull/742) [Pull request #986:](https://github.com/junit-team/junit4/pull/986) `Timeout` exceptions now include stack trace from stuck thread (experimental)
 
 `Timeout` exceptions try to determine if there is a child thread causing the problem, and if so its stack trace is included in the exception in addition to the one of the main thread. This feature must be enabled with the timeout rule by creating it through the new `Timeout.builder()` method:
 
@@ -190,7 +190,7 @@ public class HasGlobalTimeout {
 ```
 
 
-### [Pull request #544:](https://github.com/junit-team/junit/pull/544) New constructor and factories in `Timeout`
+### [Pull request #544:](https://github.com/junit-team/junit4/pull/544) New constructor and factories in `Timeout`
 
 `Timeout` deprecated the old constructor `Timeout(int millis)`.
 A new constructor is available: `Timeout(long timeout, TimeUnit unit)`. It enables you to use different granularities of time units like `NANOSECONDS`, `MICROSECONDS`, `MILLISECONDS`, and `SECONDS`. Examples:
@@ -216,7 +216,7 @@ and factory methods in `Timeout`:
 This usage avoids the truncation, which was the problem in the deprecated constructor `Timeout(int millis)` when casting `long` to `int`.
 
 
-### [Pull request #549:](https://github.com/junit-team/junit/pull/549) fixes for #544 and #545
+### [Pull request #549:](https://github.com/junit-team/junit4/pull/549) fixes for #544 and #545
 
 The `Timeout` rule applies the same timeout to all test methods in a class:
 
@@ -250,26 +250,26 @@ public class HasGlobalTimeout {
 ```
 Each test is run in a new _daemon_ thread. If the specified timeout elapses before the test completes, its execution is interrupted via `Thread#interrupt()`. This happens in interruptable I/O (operations throwing `java.io.InterruptedIOException` and `java.nio.channels.ClosedByInterruptException`), locks (package `java.util.concurrent`) and methods in `java.lang.Object` and `java.lang.Thread` throwing `java.lang.InterruptedException`.
 
-### [Pull request #876:](https://github.com/junit-team/junit/pull/876) The timeout rule never times out if you pass in a timeout of zero.
+### [Pull request #876:](https://github.com/junit-team/junit4/pull/876) The timeout rule never times out if you pass in a timeout of zero.
 
 
 # Parameterized Tests
 
 
-### [Pull request #702:](https://github.com/junit-team/junit/pull/702) Support more return types for the `@Parameters` method of the `Parameterized` runner
+### [Pull request #702:](https://github.com/junit-team/junit4/pull/702) Support more return types for the `@Parameters` method of the `Parameterized` runner
 
 The return types `Iterator<? extends Object>`, `Object[]` and `Object[][]` are now supported on methods annotated with `@Parameters`. You don't have to wrap arrays with `Iterable`s and single parameters with `Object` arrays.
 
 
-### [Pull request #773:](https://github.com/junit-team/junit/pull/773) Allow configurable creation of child runners of parameterized suites
+### [Pull request #773:](https://github.com/junit-team/junit4/pull/773) Allow configurable creation of child runners of parameterized suites
 
 The factory for creating the `Runner` instance of a single set of parameters is now configurable. It can be specified by the `@UseParametersRunnerFactory` annotation.
 
 
 # Rules
 
 
-### [Pull request #552:](https://github.com/junit-team/junit/pull/552) [Pull request #937:](https://github.com/junit-team/junit/pull/937) `Stopwatch` rule
+### [Pull request #552:](https://github.com/junit-team/junit4/pull/552) [Pull request #937:](https://github.com/junit-team/junit4/pull/937) `Stopwatch` rule
 
 The `Stopwatch` Rule notifies one of its own protected methods of the time spent by a test. Override them to get the time in nanoseconds. For example, this class will keep logging the time spent by each passed, failed, skipped, and finished test:
 
@@ -334,9 +334,9 @@ public void performanceTest() throws InterruptedException {
 }
 ```
 
-### [Pull request #932:](https://github.com/junit-team/junit/pull/932) Allow static `@Rule`s also annotated with `@ClassRule`
+### [Pull request #932:](https://github.com/junit-team/junit4/pull/932) Allow static `@Rule`s also annotated with `@ClassRule`
 
-JUnit 4.11 introduced restrictions requiring `@Rule` members to be non-static and `@ClassRule` members to be static. These restrictions have been relaxed slightly, in that a static member annotated with both `@Rule` and `@ClassRule` is now considered valid. This means a single rule may be used to perform actions both before/after a class (e.g. setup/tear down an external resource) and between tests (e.g. reset the external resource), without the need for any workarounds mentioned in issue [#793](https://github.com/junit-team/junit/issues/793).
+JUnit 4.11 introduced restrictions requiring `@Rule` members to be non-static and `@ClassRule` members to be static. These restrictions have been relaxed slightly, in that a static member annotated with both `@Rule` and `@ClassRule` is now considered valid. This means a single rule may be used to perform actions both before/after a class (e.g. setup/tear down an external resource) and between tests (e.g. reset the external resource), without the need for any workarounds mentioned in issue [#793](https://github.com/junit-team/junit4/issues/793).
 
 Note that a non-static `@ClassRule` annotated member is still considered invalid, even if annotated with `@Rule`.
 
@@ -350,7 +350,7 @@ public class CommonRuleTest {
 
 Be warned that if you have static methods or fields annotated with `@Rule` you will not be able to run your test methods in parallel.
 
-### [Pull request #956:](https://github.com/junit-team/junit/pull/956) `DisableOnDebug` rule
+### [Pull request #956:](https://github.com/junit-team/junit4/pull/956) `DisableOnDebug` rule
 
 The `DisableOnDebug` rule allows users to disable other rules when the JVM is launched in debug mode. Prior to this feature the common approach to disable rules that make debugging difficult was to comment them out and remember to revert the change. When using this feature users no longer have to modify their test code nor do they need to remember to revert changes.
 
@@ -361,15 +361,15 @@ This rule is particularly useful in combination with the `Timeout` rule.
 public DisableOnDebug timeout = new DisableOnDebug(Timeout.seconds(1));
 ```
 
-See the Javadoc for more detail and limitations. Related to https://github.com/junit-team/junit/issues/738
+See the Javadoc for more detail and limitations. Related to https://github.com/junit-team/junit4/issues/738
 
-### [Pull request #974:](https://github.com/junit-team/junit/pull/974) Updated `TemporaryFolder.newFolder()` to give an error message if a path contains a slash.
+### [Pull request #974:](https://github.com/junit-team/junit4/pull/974) Updated `TemporaryFolder.newFolder()` to give an error message if a path contains a slash.
 
 If you call `TemporaryFolder.newFolder(""foo/bar"")` in JUnit 4.10 the method returns a `File` object for the new folder but actually fails to create it. That is contrary to the expected behaviour of the method which is to actually create the folder. In JUnit 4.11 the same call throws an exception. Nowhere in the documentation does it explain that the String(s) passed to that method can only be single path components.
 
 With this fix, folder names are validated to contain single path name. If the folder name consists of multiple path names, an exception is thrown stating that usage of multiple path components in a string containing folder name is disallowed.
 
-### [Pull request #1015:](https://github.com/junit-team/junit/pull/1015) Methods annotated with `Rule` can return a `MethodRule`.
+### [Pull request #1015:](https://github.com/junit-team/junit4/pull/1015) Methods annotated with `Rule` can return a `MethodRule`.
 
 Methods annotated with `@Rule` can now return either a `TestRule` (or subclass) or a
 `MethodRule` (or subclass).
@@ -380,7 +380,7 @@ the method is only called if the return type could be assigned to `TestRule` or
 `MethodRule`. For methods annotated with `@Rule` that return other values, see the notes
 for pull request #1020.
 
-### [Pull request #1020:](https://github.com/junit-team/junit/pull/1020) Added validation that @ClassRule should only be implementation of TestRule.
+### [Pull request #1020:](https://github.com/junit-team/junit4/pull/1020) Added validation that @ClassRule should only be implementation of TestRule.
 
 Prior to this change, fields annotated with `@ClassRule` that did not have a type of `TestRule`
 (or a class that implements `TestRule`) were ignored. With this change, the test will fail
@@ -390,20 +390,20 @@ Prior to this change, methods annotated with `@ClassRule` that did specify a ret
 of `TestRule`(or a class that implements `TestRule`) were ignored. With this change, the test
 will fail with a validation error.
 
-### [Pull request #1021:](https://github.com/junit-team/junit/pull/1021) JavaDoc of TemporaryFolder: folder not guaranteed to be deleted.
+### [Pull request #1021:](https://github.com/junit-team/junit4/pull/1021) JavaDoc of TemporaryFolder: folder not guaranteed to be deleted.
 
 Adjusted JavaDoc of TemporaryFolder to reflect that temporary folders are not guaranteed to be
 deleted.
 
 # Theories
 
 
-### [Pull request #529:](https://github.com/junit-team/junit/pull/529) `@DataPoints`-annotated methods can now yield `null` values
+### [Pull request #529:](https://github.com/junit-team/junit4/pull/529) `@DataPoints`-annotated methods can now yield `null` values
 
 Up until JUnit 4.11 a `@DataPoints`-annotated array field could contain `null` values, but the array returned by a `@DataPoints`-annotated method could not. This asymmetry has been resolved: _both_ can now provide a `null` data point. 
 
 
-### [Pull request #572:](https://github.com/junit-team/junit/pull/572) Ensuring no-generic-type-parms validator called/tested for theories
+### [Pull request #572:](https://github.com/junit-team/junit4/pull/572) Ensuring no-generic-type-parms validator called/tested for theories
 
 The `Theories` runner now disallows `Theory` methods with parameters that have ""unresolved"" generic type parameters (e.g. `List<T>` where `T` is a type variable). It is exceedingly difficult for the `DataPoint(s)` scraper or other `ParameterSupplier`s to correctly decide values that can legitimately be assigned to such parameters in a type-safe way, so JUnit now disallows them altogether. Theory parameters such as `List<String>` and `Iterable<? extends Number>` are still allowed.
 
@@ -412,7 +412,7 @@ The machinery to perform this validation was in the code base for some time, but
 [junit.contrib](https://github.com/junit-team/junit.contrib)'s rendition of theories performs the same validation.
 
 
-### [Pull request #607:](https://github.com/junit-team/junit/pull/607) Improving theory failure messages
+### [Pull request #607:](https://github.com/junit-team/junit4/pull/607) Improving theory failure messages
 
 Theory failure messages previously were of the form: `ParameterizedAssertionError: theoryTest(badDatapoint, allValues[1], otherVar)`, where allValues, badDatapoint and otherVar were the variables the datapoints was sourced from. These messages are now of the form: 
 
@@ -422,7 +422,7 @@ ParameterizedAssertionError: theoryTest(null <from badDatapoint>, ""good value"" <
 ```
 
 
-### [Pull request #601:](https://github.com/junit-team/junit/pull/601) Allow use of `Assume` in tests run by `Theories` runner
+### [Pull request #601:](https://github.com/junit-team/junit4/pull/601) Allow use of `Assume` in tests run by `Theories` runner
 
 If, in a theory, all parameters were ""assumed"" away, the `Theories` runner would properly fail, informing you that no parameters were found to actually test something. However, if you had another method in that same class, that was not a theory (annotated with `@Test` only,) you could not use Assume in that test. Now, the `Theories` runner will verify the method is annotated with `@Theory` before failing due to no parameters being found.
 
@@ -447,12 +447,12 @@ public class TheoriesAndTestsTogether {
 ```
 
 
-### [Pull request #623:](https://github.com/junit-team/junit/pull/623) Ensure data points array fields and methods are `public` and `static` in Theory classes.
+### [Pull request #623:](https://github.com/junit-team/junit4/pull/623) Ensure data points array fields and methods are `public` and `static` in Theory classes.
 
 Previously if a data points array field or method was non-`static` or non-`public` it would be silently ignored and the data points not used. Now the `Theories` runner verifies that all `@DataPoint` or `@DataPoints` annotated fields or methods in classes are both `public` and `static`, and such classes will fail to run with `InitializationError`s if they are not.
 
 
-### [Pull request #621:](https://github.com/junit-team/junit/pull/621) Added mechanism for matching specific data points in theories to specific parameters, by naming data points.
+### [Pull request #621:](https://github.com/junit-team/junit4/pull/621) Added mechanism for matching specific data points in theories to specific parameters, by naming data points.
 
 `@DataPoints` fields or methods can now be given (one or more) names in the annotation, and `@Theory` method parameters can be annotated with `@FromDataPoints(name)`, to limit the data points considered for that parameter to only the data points with that name:
 
@@ -482,39 +482,39 @@ public void regexTheory(@FromDataPoints(""regexes"") String regex,
 ```
 
 
-### [Pull request #654:](https://github.com/junit-team/junit/pull/654) Auto-generation of `enum` and `boolean` data points
+### [Pull request #654:](https://github.com/junit-team/junit4/pull/654) Auto-generation of `enum` and `boolean` data points
 
 Any theory method parameters with `boolean` or `enum` types that cannot be supplied with values by any other sources will be automatically supplied with default values: `true` and `false`, or every value of the given `enum`. If other explicitly defined values are available (e.g. from a specified `ParameterSupplier` or some `DataPoints` method in the theory class), only those explicitly defined values will be used.
 
 
-### [Pull request #651:](https://github.com/junit-team/junit/pull/651) Improvements to Theory parameter and DataPoint type matching
+### [Pull request #651:](https://github.com/junit-team/junit4/pull/651) Improvements to Theory parameter and DataPoint type matching
 
  * Validity of `DataPoints` for theory parameters for all field data points and multi-valued method data points (i.e. not single-valued method data points) is now done on runtime type, not field/method return type (previously this was the case for multi-valued array methods only).
 
  * Validity of `DataPoints` for theory parameters for all data points now correctly handles boxing and unboxing for primitive and wrapper types; e.g. `int` values will be considered for theory parameters that are `Integer` assignable, and vice versa.
 
 
-### [Pull request #639:](https://github.com/junit-team/junit/pull/639) Failing theory datapoint methods now cause theory test failures
+### [Pull request #639:](https://github.com/junit-team/junit4/pull/639) Failing theory datapoint methods now cause theory test failures
 
 Previously `@DataPoint(s)` methods that threw exceptions were quietly ignored and if another `DataPoint` source was available then those values alone were used, leaving the theory passing using only a subset of the (presumably) intended input values. Now, any data point method failures during invocation of a theory will cause the theory being tested to fail immediately.
 
 *This is a non-backward-compatible change*, and could potentially break theory tests that depended on failing methods. If that was desired behavior, then the expected exceptions can instead be specifically ignored using the new `ignoredExceptions` array attribute on `@DataPoint` and `@DataPoints` methods. Adding an exception to this `ignoredExceptions` array will stop theory methods from failing if the given exception, or subclasses of it, are thrown in the annotated method. This attribute has no effect on data point fields.
 
 
-### [Pull request #658:](https://github.com/junit-team/junit/pull/658) `Iterable`s can now be used as data points
+### [Pull request #658:](https://github.com/junit-team/junit4/pull/658) `Iterable`s can now be used as data points
 
 Previously, when building sets of data points for theory parameters, the only valid multi-valued `@DataPoints` types were arrays. This has now been extended to also take parameters from `Iterable` `@DataPoints` methods and fields.
 
 
 # Categories
 
 
-### [Pull request #566:](https://github.com/junit-team/junit/pull/566) Enables inheritance on `Category` by adding `@Inherited`
+### [Pull request #566:](https://github.com/junit-team/junit4/pull/566) Enables inheritance on `Category` by adding `@Inherited`
 
 `@interface Category` now is annotated with `@Inherited` itself. This enables inheritance of categories from ancestors (e.g. abstract test-classes). Note that you are able to ""overwrite"" `@Category` on inheritors and that this has no effect on method-level categories (see [@Inherited](http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/annotation/Inherited.html)).
 
 
-### [Pull request #503:](https://github.com/junit-team/junit/pull/503) Configurable Categories
+### [Pull request #503:](https://github.com/junit-team/junit4/pull/503) Configurable Categories
 
 From a given set of test classes, the `Categories` runner runs only the classes and methods
 that are annotated with either the category given with the `@IncludeCategory` annotation, or a subtype of that category. Either classes or interfaces can be used as categories. Subtyping works, so if you say `@IncludeCategory(SuperClass.class)`, a test marked `@Category({SubClass.class})` will be run.
@@ -589,7 +589,7 @@ public class SlowTestSuiteWithoutFast {
 # Use with Maven
 
 
-### [Pull request #879:] (https://github.com/junit-team/junit/pull/879) Add the default 'Implementation-*' headers to the manifest
+### [Pull request #879:] (https://github.com/junit-team/junit4/pull/879) Add the default 'Implementation-*' headers to the manifest
 
 The default Maven-style 'Implementation-*' headers are now present in the manifest of `junit.jar`. Example:
 ```
@@ -600,7 +600,7 @@ Implementation-Vendor-Id: junit
 ```
 
 
-### [Pull request #511:](https://github.com/junit-team/junit/pull/511) Maven project junit:junit:jar
+### [Pull request #511:](https://github.com/junit-team/junit4/pull/511) Maven project junit:junit:jar
 
 
 #### How to install Maven
@@ -666,15 +666,15 @@ Follow this link for _IntelliJ IDEA_: [http://www.jetbrains.com/idea/webhelp/act
 # Miscellaneous
 
 
-### [Pull request #776:](https://github.com/junit-team/junit/pull/776) Add support for [Travis CI](http://travis-ci.org)
+### [Pull request #776:](https://github.com/junit-team/junit4/pull/776) Add support for [Travis CI](http://travis-ci.org)
 
 Travis CI is a free CI server for public Github repositories. Every pull request is run by Travis CI and Github's web interface shows the CI result for each pull request. Every user can use Travis CI for testing her branches, too.
 
-### [Pull request #921:](https://github.com/junit-team/junit/pull/921) Apply Google Code Style
+### [Pull request #921:](https://github.com/junit-team/junit4/pull/921) Apply Google Code Style
 
 JUnit is now using the well documented [Google Code Style](http://google-styleguide.googlecode.com/svn/trunk/javaguide.html)
 
-### [Pull request #939](https://github.com/junit-team/junit/pull/939) Renamed license file
+### [Pull request #939](https://github.com/junit-team/junit4/pull/939) Renamed license file
 
 While using JUnit in Android apps, if any other referenced library has a file named `LICENSE.txt`, the APK generation failed with the following error -
 
@@ -683,7 +683,7 @@ While using JUnit in Android apps, if any other referenced library has a file na
 To avoid this, the license file has been renamed to `LICENSE-junit.txt` 
 
 
-### [Pull request #962:](https://github.com/junit-team/junit/pull/962) Do not include thread start time in test timeout measurements.
+### [Pull request #962:](https://github.com/junit-team/junit4/pull/962) Do not include thread start time in test timeout measurements.
 
 The time it takes to start a thread can be surprisingly large.
 Especially in virtualized cloud environments where noisy neighbours.
@@ -700,31 +700,31 @@ The following section lists fixes to problems introduced in the first
 release candidates for JUnit 4.12. You can ignore this section if you are
 trying to understand the changes between 4.11 and 4.12.
 
-### [Pull request #961:](https://github.com/junit-team/junit/pull/961) Restore field names with f prefix.
+### [Pull request #961:](https://github.com/junit-team/junit4/pull/961) Restore field names with f prefix.
 
 In order to make the JUnit code more consistent with current coding practices, we changed
 a number of field names to not start with the prefix ""f"". Unfortunately, at least one IDE
 referenced a private field via reflection. This change reverts the field names for fields
 known to be read via reflection.
 
-### [Pull request #988:](https://github.com/junit-team/junit/pull/988) Revert ""Delete classes that are deprecated for six years.""
+### [Pull request #988:](https://github.com/junit-team/junit4/pull/988) Revert ""Delete classes that are deprecated for six years.""
 
-In [745ca05](https://github.com/junit-team/junit/commit/745ca05dccf5cc907e43a58142bb8be97da2b78f)
+In [745ca05](https://github.com/junit-team/junit4/commit/745ca05dccf5cc907e43a58142bb8be97da2b78f)
 we removed classes that were deprecated for many releases. There was some concern that people
 might not expect classes to be removed in a 4.x release. Even though we are not aware of any
 problems from the deletion, we decided to add them back.
 
 These classes may be removed in JUnit 5.0 or later.
 
-### [Pull request #989:](https://github.com/junit-team/junit/pull/989) Add JUnitSystem.exit() back.
+### [Pull request #989:](https://github.com/junit-team/junit4/pull/989) Add JUnitSystem.exit() back.
 
-In [917a88f](https://github.com/junit-team/junit/commit/917a88fad06ce108a596a8fdb4607b1a2fbb3f3e)
+In [917a88f](https://github.com/junit-team/junit4/commit/917a88fad06ce108a596a8fdb4607b1a2fbb3f3e)
 the exit() method in JUnit was removed. This caused problems for at least one user. Even
 though this class is in an internal package, we decided to add it back, and deprecated it.
 
 This method may be removed in JUnit 5.0 or later.
 
-### [Pull request #994:](https://github.com/junit-team/junit/pull/994) [Pull request #1000:](https://github.com/junit-team/junit/pull/1000) Ensure serialization compatibility where possible.
+### [Pull request #994:](https://github.com/junit-team/junit4/pull/994) [Pull request #1000:](https://github.com/junit-team/junit4/pull/1000) Ensure serialization compatibility where possible.
 
 JUnit 4.12 RC1 introduced serilization incompatibilities with some of the classes. For example,
 these pre-release versions of JUnit could not read instances of `Result` that were serialized
@@ -1,6 +1,6 @@
 ## Summary of changes in version 4.13 [unreleased!]
 
 We collect release notes in the wiki:
-https://github.com/junit-team/junit/wiki/4.13-release-notes
+https://github.com/junit-team/junit4/wiki/4.13-release-notes
 
 This file will be updated right before release.
@@ -49,7 +49,7 @@
             <name>JUnit contributors</name>
             <organization>JUnit</organization>
             <email>junit@yahoogroups.com</email>
-            <url>https://github.com/junit-team/junit/graphs/contributors</url>
+            <url>https://github.com/junit-team/junit4/graphs/contributors</url>
             <roles>
                 <role>developers</role>
             </roles>
@@ -71,19 +71,19 @@
     <scm>
         <connection>scm:git:git://github.com/junit-team/junit4.git</connection>
         <developerConnection>scm:git:git@github.com:junit-team/junit4.git</developerConnection>
-        <url>http://github.com/junit-team/junit/tree/master</url>
+        <url>http://github.com/junit-team/junit4/tree/master</url>
       <tag>HEAD</tag>
   </scm>
     <issueManagement>
         <system>github</system>
-        <url>https://github.com/junit-team/junit/issues</url>
+        <url>https://github.com/junit-team/junit4/issues</url>
     </issueManagement>
     <ciManagement>
         <system>jenkins</system>
         <url>https://junit.ci.cloudbees.com/</url>
     </ciManagement>
     <distributionManagement>
-        <downloadUrl>https://github.com/junit-team/junit/wiki/Download-and-Install</downloadUrl>
+        <downloadUrl>https://github.com/junit-team/junit4/wiki/Download-and-Install</downloadUrl>
         <snapshotRepository>
             <id>junit-snapshot-repo</id>
             <name>Nexus Snapshot Repository</name>
@@ -14,7 +14,7 @@
  * basically means ""don't run this test if these conditions don't apply"". The default JUnit runner skips tests with
  * failing assumptions. Custom runners may behave differently.
  * <p>
- *     A good example of using assumptions is in <a href=""https://github.com/junit-team/junit/wiki/Theories"">Theories</a> where they are needed to exclude certain datapoints that aren't suitable or allowed for a certain test case.
+ *     A good example of using assumptions is in <a href=""https://github.com/junit-team/junit4/wiki/Theories"">Theories</a> where they are needed to exclude certain datapoints that aren't suitable or allowed for a certain test case.
  * </p>
  * Failed assumptions are usually not logged, because there may be many tests that don't apply to certain
  * configurations.
@@ -29,7 +29,7 @@
  * </pre>
  * </p>
  *
- * @see <a href=""https://github.com/junit-team/junit/wiki/Theories"">Theories</a>
+ * @see <a href=""https://github.com/junit-team/junit4/wiki/Theories"">Theories</a>
  *
  * @since 4.4
  */
@@ -21,7 +21,7 @@ public class ComparisonFailure extends AssertionError {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private String fExpected;
     private String fActual;
@@ -35,7 +35,7 @@
  * If the exception's message or one of its properties should be verified, the
  * {@link org.junit.rules.ExpectedException ExpectedException} rule can be used. Further
  * information about exception testing can be found at the
- * <a href=""https://github.com/junit-team/junit/wiki/Exception-testing"">JUnit Wiki</a>.
+ * <a href=""https://github.com/junit-team/junit4/wiki/Exception-testing"">JUnit Wiki</a>.
  * <p>
  * The second optional parameter, <code>timeout</code>, causes a test to fail if it takes
  * longer than a specified amount of clock time (measured in milliseconds). The following test fails:
@@ -76,7 +76,7 @@
  * </pre>
  *
  * @version 4.12
- * @see <a href=""https://github.com/junit-team/junit/wiki/Categories"">Categories at JUnit wiki</a>
+ * @see <a href=""https://github.com/junit-team/junit4/wiki/Categories"">Categories at JUnit wiki</a>
  */
 public class Categories extends Suite {
 
@@ -64,7 +64,7 @@ private static MaxHistory readHistory(File storedResults)
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final Map<String, Long> fDurations = new HashMap<String, Long>();
     private final Map<String, Long> fFailureTimestamps = new HashMap<String, Long>();
@@ -17,7 +17,7 @@ public class ArrayComparisonFailure extends AssertionError {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final List<Integer> fIndices = new ArrayList<Integer>();
     private final String fMessage;
@@ -18,7 +18,7 @@ public class AssumptionViolatedException extends RuntimeException implements Sel
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final String fAssumption;
     private final boolean fValueMatcher;
@@ -10,7 +10,7 @@ public class ClassRequest extends Request {
     /*
      * We have to use the f prefix, because IntelliJ's JUnit4IdeaTestRunner uses
      * reflection to access this field. See
-     * https://github.com/junit-team/junit/issues/960
+     * https://github.com/junit-team/junit4/issues/960
      */
     private final Class<?> fTestClass;
     private final boolean canUseSuiteMethod;
@@ -14,7 +14,7 @@ public final class FilterRequest extends Request {
     /*
      * We have to use the f prefix, because IntelliJ's JUnit4IdeaTestRunner uses
      * reflection to access this field. See
-     * https://github.com/junit-team/junit/issues/960
+     * https://github.com/junit-team/junit4/issues/960
      */
     private final Filter fFilter;
 
@@ -15,7 +15,7 @@ public class InitializationError extends Exception {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final List<Throwable> fErrors;
 
@@ -139,7 +139,7 @@ public static Description createSuiteDescription(Class<?> testClass) {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final Collection<Description> fChildren = new ConcurrentLinkedQueue<Description>();
     private final String fDisplayName;
@@ -21,7 +21,7 @@ public class Failure implements Serializable {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final Description fDescription;
     private final Throwable fThrownException;
@@ -14,7 +14,7 @@ public class InitializationError extends Exception {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final List<Throwable> fErrors;
 
@@ -17,7 +17,7 @@ public class MultipleFailureException extends Exception {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final List<Throwable> fErrors;
 
@@ -74,52 +74,52 @@
         <div class=""span4"" id=""welcome-section"">
           <p><b>Welcome</b></p>
           <ul>
-            <li><a href=""https://github.com/junit-team/junit/wiki/Download-and-Install"">Download and install</a></li>
-            <li><a href=""https://github.com/junit-team/junit/wiki/Getting-started"">Getting started</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki/Download-and-Install"">Download and install</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki/Getting-started"">Getting started</a></li>
             <li>Release Notes
               <ul>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.12.md"">4.12</a></li>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.11.md"">4.11</a></li>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.10.md"">4.10</a></li>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.9.1.md"">4.9.1</a></li>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.9.md"">4.9</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.12.md"">4.12</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.11.md"">4.11</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.10.md"">4.10</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.9.1.md"">4.9.1</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.9.md"">4.9</a></li>
               </ul>
             </li>
-            <li><a href=""https://github.com/junit-team/junit/wiki/Maintainer-documentation"">Maintainer Documentation</a></li>
-            <li><a href=""https://github.com/junit-team/junit/wiki/I-want-to-help%21"">I want to help!</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki/Maintainer-documentation"">Maintainer Documentation</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki/I-want-to-help%21"">I want to help!</a></li>
             <li><a href=""http://stackoverflow.com/questions/tagged/junit"">Latest JUnit Questions on StackOverflow</a></li>
             <li><a href=""javadoc/latest/index.html"">JavaDocs</a></li>
             <li><a href=""./faq.html"">Frequently asked questions</a></li>
-            <li><a href=""https://github.com/junit-team/junit/wiki"">Wiki</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki"">Wiki</a></li>
             <li><a href=""./license.html"">License</a></li>
           </ul>
         </div>
         <div class=""span4"" id=""concepts-section"">
           <p><b>Usage and Idioms</b></p>
           <ul>
-<li><a href=""https://github.com/junit-team/junit/wiki/Assertions"">Assertions</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Test-runners"">Test Runners</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Aggregating-tests-in-suites"">Aggregating tests in Suites</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Test-execution-order"">Test Execution Order</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Exception-testing"">Exception Testing</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Matchers-and-assertthat"">Matchers and assertThat</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Ignoring-tests"">Ignoring Tests</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Timeout-for-tests"">Timeout for Tests</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Parameterized-tests"">Parameterized Tests</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Assumptions-with-assume"">Assumptions with Assume</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Rules"">Rules</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Theories"">Theories</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Test-fixtures"">Test Fixtures</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Categories"">Categories</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Use-with-Maven"">Use with Maven</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Multithreaded-code-and-concurrency"">Multithreaded code and Concurrency</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Java-contract-test-helpers"">Java contract test helpers</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Continuous-testing"">Continuous Testing</a></li>          </ul>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Assertions"">Assertions</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Test-runners"">Test Runners</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites"">Aggregating tests in Suites</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Test-execution-order"">Test Execution Order</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Exception-testing"">Exception Testing</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Matchers-and-assertthat"">Matchers and assertThat</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Ignoring-tests"">Ignoring Tests</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Timeout-for-tests"">Timeout for Tests</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Parameterized-tests"">Parameterized Tests</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Assumptions-with-assume"">Assumptions with Assume</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Rules"">Rules</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Theories"">Theories</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Test-fixtures"">Test Fixtures</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Categories"">Categories</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Use-with-Maven"">Use with Maven</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Multithreaded-code-and-concurrency"">Multithreaded code and Concurrency</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Java-contract-test-helpers"">Java contract test helpers</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Continuous-testing"">Continuous Testing</a></li>          </ul>
         </div>
         <div class=""span4"" id=""thirdparty-section"">
           <p><b>Third-party extensions</b></p>
           <ul>
-<li><a href=""https://github.com/junit-team/junit/wiki/Custom-runners"">Custom Runners</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Custom-runners"">Custom Runners</a></li>
 <li>
 <a href=""http://site.trajano.net/commons-testing/"">net.trajano.commons:commons-testing for UtilityClassTestUtil</a> per #646</li>
 <li>
@@ -252,7 +252,7 @@ public void throwsMore() {
         }
     }
 
-    //https://github.com/junit-team/junit/pull/583
+    //https://github.com/junit-team/junit4/pull/583
     public static class ExpectAssertionErrorWhichIsNotThrown {
         @Rule
         public ExpectedException thrown = none();
@@ -322,7 +322,7 @@ public void doNothing() {
      * then it should also be run.
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/589"">Issue #589</a> - 
+     * <a href=""https://github.com/junit-team/junit4/issues/589"">Issue #589</a> - 
      * Support @Rule for methods works only for TestRule but not for MethodRule
      */
     @Test
@@ -354,7 +354,7 @@ public void doNothing() {
      * then all the rules returned should be run.
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/589"">Issue #589</a> - 
+     * <a href=""https://github.com/junit-team/junit4/issues/589"">Issue #589</a> - 
      * Support @Rule for methods works only for TestRule but not for MethodRule
      */
     @Test
@@ -398,7 +398,7 @@ public void doNothing() {
      * then method should be called only once.
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/589"">Issue #589</a> - 
+     * <a href=""https://github.com/junit-team/junit4/issues/589"">Issue #589</a> - 
      * Support @Rule for methods works only for TestRule but not for MethodRule
      */
     @Test
@@ -76,7 +76,7 @@ static class NonPublicTestWithClassRule {
      * {@link TestRule}
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/1019"">Issue #1019</a>
+     * <a href=""https://github.com/junit-team/junit4/issues/1019"">Issue #1019</a>
      */
     @Test
     public void rejectClassRuleThatIsImplemetationOfMethodRule() {
@@ -100,7 +100,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
      * implementation of {@link TestRule}
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/1019"">Issue #1019</a>
+     * <a href=""https://github.com/junit-team/junit4/issues/1019"">Issue #1019</a>
      */
     @Test
     public void rejectClassRuleThatReturnsImplementationOfMethodRule() {
@@ -126,7 +126,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
      * {@link TestRule}
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/1019"">Issue #1019</a>
+     * <a href=""https://github.com/junit-team/junit4/issues/1019"">Issue #1019</a>
      */
     @Test
     public void rejectClassRuleIsAnArbitraryObject() throws Exception {
@@ -145,7 +145,7 @@ public static class TestWithClassRuleIsAnArbitraryObject {
      * implementation of {@link TestRule}
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/1019"">Issue #1019</a> 
+     * <a href=""https://github.com/junit-team/junit4/issues/1019"">Issue #1019</a> 
      */
     @Test
     public void rejectClassRuleMethodReturnsAnArbitraryObject() throws Exception {
"
https://github.com/junit-team/junit4/commit/bcf2c17851197328bb7bc008f916a6648de193aa,Converted tabs to spaces  <enter> Converted tabs to spaces for newly added code to be in line with guidelines. ,https://api.github.com/repos/junit-team/junit4/commits/bcf2c17851197328bb7bc008f916a6648de193aa,"@@ -119,8 +119,8 @@ public ExpectedException handleAssumptionViolatedExceptions() {
      * @return self
      */
     public ExpectedException reportMissingExceptionWithMessage(String providedMessage) {
-    	missingExceptionMessage = providedMessage;
-    	return this;
+        missingExceptionMessage = providedMessage;
+        return this;
     }
 
     public Statement apply(Statement base,
@@ -193,14 +193,14 @@ public void evaluate() throws Throwable {
     }
 
     private void failDueToMissingException() throws AssertionError {
-    	String failureMessage;
-    	
-    	if ( isMissingExceptionMessageEmpty() ) {
-    		String expectation = StringDescription.toString(fMatcherBuilder.build());
-    		failureMessage = ""Expected test to throw "" + expectation;
-    	} else {
-    		failureMessage = missingExceptionMessage;
-    	}
+        String failureMessage;
+        
+        if ( isMissingExceptionMessageEmpty() ) {
+            String expectation = StringDescription.toString(fMatcherBuilder.build());
+            failureMessage = ""Expected test to throw "" + expectation;
+        } else {
+            failureMessage = missingExceptionMessage;
+        }
 
         fail(failureMessage);
     }
@@ -223,6 +223,6 @@ private void handleException(Throwable e) throws Throwable {
     }
     
     private boolean isMissingExceptionMessageEmpty() {
-    	return missingExceptionMessage == null || missingExceptionMessage.isEmpty();
+        return missingExceptionMessage == null || missingExceptionMessage.isEmpty();
     }
 }
"
https://github.com/spring-projects/spring-boot/commit/abd7bc0466722b2a6e2b145a630fdb342a7f1656,Add OAuth2 resource server sample  <enter> Shows how to use @EnableResourceServer in a pure resource server and configure the secure paths. ,https://api.github.com/repos/spring-projects/spring-boot/commits/abd7bc0466722b2a6e2b145a630fdb342a7f1656,"@@ -0,0 +1,57 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.security.oauth2.authserver;
+
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+/**
+ * @author Dave Syer
+ */
+@ConfigurationProperties(""security.oauth2.authorization"")
+public class AuthorizationServerProperties {
+
+	private String checkTokenAccess;
+
+	private String tokenKeyAccess;
+
+	private String realm;
+
+	public String getCheckTokenAccess() {
+		return this.checkTokenAccess;
+	}
+
+	public void setCheckTokenAccess(String checkTokenAccess) {
+		this.checkTokenAccess = checkTokenAccess;
+	}
+
+	public String getTokenKeyAccess() {
+		return this.tokenKeyAccess;
+	}
+
+	public void setTokenKeyAccess(String tokenKeyAccess) {
+		this.tokenKeyAccess = tokenKeyAccess;
+	}
+
+	public String getRealm() {
+		return this.realm;
+	}
+
+	public void setRealm(String realm) {
+		this.realm = realm;
+	}
+
+}
@@ -24,7 +24,6 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -44,6 +43,7 @@
 import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerEndpointsConfiguration;
 import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
 import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
+import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
 import org.springframework.security.oauth2.provider.client.BaseClientDetails;
 import org.springframework.security.oauth2.provider.token.TokenStore;
 
@@ -60,7 +60,7 @@
 @ConditionalOnClass(EnableAuthorizationServer.class)
 @ConditionalOnMissingBean(AuthorizationServerConfigurer.class)
 @ConditionalOnBean(AuthorizationServerEndpointsConfiguration.class)
-@EnableConfigurationProperties
+@EnableConfigurationProperties(AuthorizationServerProperties.class)
 public class OAuth2AuthorizationServerConfiguration
 		extends AuthorizationServerConfigurerAdapter {
 
@@ -76,6 +76,9 @@ public class OAuth2AuthorizationServerConfiguration
 	@Autowired(required = false)
 	private TokenStore tokenStore;
 
+	@Autowired
+	private AuthorizationServerProperties properties;
+
 	@Override
 	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
 		ClientDetailsServiceBuilder<InMemoryClientDetailsServiceBuilder>.ClientBuilder builder = clients
@@ -105,6 +108,20 @@ public void configure(AuthorizationServerEndpointsConfigurer endpoints)
 		}
 	}
 
+	@Override
+	public void configure(AuthorizationServerSecurityConfigurer security)
+			throws Exception {
+		if (this.properties.getCheckTokenAccess() != null) {
+			security.checkTokenAccess(this.properties.getCheckTokenAccess());
+		}
+		if (this.properties.getTokenKeyAccess() != null) {
+			security.tokenKeyAccess(this.properties.getTokenKeyAccess());
+		}
+		if (this.properties.getRealm() != null) {
+			security.realm(this.properties.getRealm());
+		}
+	}
+
 	@Configuration
 	protected static class ClientDetailsLogger {
 
@@ -0,0 +1,56 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<!-- Your own application should inherit from spring-boot-starter-parent -->
+		<groupId>org.springframework.boot</groupId>
+		<artifactId>spring-boot-samples</artifactId>
+		<version>1.3.0.BUILD-SNAPSHOT</version>
+	</parent>
+	<artifactId>spring-boot-sample-secure-oauth2-resource</artifactId>
+	<name>spring-boot-sample-secure-oauth2-resource</name>
+	<description>Spring Boot Security OAuth2 Sample</description>
+	<url>http://projects.spring.io/spring-boot/</url>
+	<organization>
+		<name>Pivotal Software, Inc.</name>
+		<url>http://www.spring.io</url>
+	</organization>
+	<properties>
+		<main.basedir>${basedir}/../..</main.basedir>
+	</properties>
+	<dependencies>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-security</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-data-jpa</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-data-rest</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>com.h2database</groupId>
+			<artifactId>h2</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.security.oauth</groupId>
+			<artifactId>spring-security-oauth2</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-test</artifactId>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
+	<build>
+		<plugins>
+			<plugin>
+				<groupId>org.springframework.boot</groupId>
+				<artifactId>spring-boot-maven-plugin</artifactId>
+			</plugin>
+		</plugins>
+	</build>
+</project>
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package sample.secure.oauth2;
+
+import java.util.Date;
+
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.GenerationType;
+import javax.persistence.Id;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+
+/**
+ * Domain object for tracking flights
+ *
+ * @author Craig Walls
+ * @author Greg Turnquist
+ */
+@Entity
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class Flight {
+
+	@Id
+	@GeneratedValue(strategy = GenerationType.AUTO)
+	private Long id;
+
+	private String origin;
+
+	private String destination;
+
+	private String airline;
+
+	private String flightNumber;
+
+	private Date date;
+
+	private String traveler;
+
+	public Long getId() {
+		return this.id;
+	}
+
+	public void setId(Long id) {
+		this.id = id;
+	}
+
+	public String getOrigin() {
+		return this.origin;
+	}
+
+	public void setOrigin(String origin) {
+		this.origin = origin;
+	}
+
+	public String getDestination() {
+		return this.destination;
+	}
+
+	public void setDestination(String destination) {
+		this.destination = destination;
+	}
+
+	public String getAirline() {
+		return this.airline;
+	}
+
+	public void setAirline(String airline) {
+		this.airline = airline;
+	}
+
+	public String getFlightNumber() {
+		return this.flightNumber;
+	}
+
+	public void setFlightNumber(String flightNumber) {
+		this.flightNumber = flightNumber;
+	}
+
+	public Date getDate() {
+		return this.date;
+	}
+
+	public void setDate(Date date) {
+		this.date = date;
+	}
+
+	public String getTraveler() {
+		return this.traveler;
+	}
+
+	public void setTraveler(String traveler) {
+		this.traveler = traveler;
+	}
+
+}
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package sample.secure.oauth2;
+
+import org.springframework.data.repository.CrudRepository;
+
+/**
+ * Spring Data interface with secured methods
+ *
+ * @author Craig Walls
+ * @author Greg Turnquist
+ */
+public interface FlightRepository extends CrudRepository<Flight, Long> {
+
+	@Override
+	Iterable<Flight> findAll();
+
+	@Override
+	Flight findOne(Long aLong);
+
+	@Override
+	<S extends Flight> S save(S entity);
+
+}
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package sample.secure.oauth2;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.autoconfigure.SpringBootApplication;
+import org.springframework.security.config.annotation.web.builders.HttpSecurity;
+import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
+import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
+
+@SpringBootApplication
+@EnableResourceServer
+public class SampleSecureOAuth2ResourceApplication extends ResourceServerConfigurerAdapter {
+	
+	@Override
+	public void configure(HttpSecurity http) throws Exception {
+		http.antMatcher(""/flights/**"").authorizeRequests().anyRequest().authenticated();
+	}
+
+	public static void main(String[] args) {
+		SpringApplication.run(SampleSecureOAuth2ResourceApplication.class, args);
+	}
+
+}
@@ -0,0 +1,6 @@
+server.port=8081
+spring.datasource.platform=h2
+security.basic.enabled=false
+security.oauth2.resource.id=service
+security.oauth2.resource.userInfoUri=http://localhost:8080/user
+logging.level.org.springframework.security=DEBUG
@@ -0,0 +1,4 @@
+insert into FLIGHT
+(id, origin, destination, airline, flight_number, traveler)
+values
+(1, 'Nashville', 'Dallas', 'Spring Ways', 'OAUTH2', 'Greg Turnquist');
@@ -0,0 +1,65 @@
+package sample.secure.oauth2;
+
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+import static org.springframework.test.web.servlet.setup.MockMvcBuilders.webAppContextSetup;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.SpringApplicationConfiguration;
+import org.springframework.boot.test.WebIntegrationTest;
+import org.springframework.hateoas.MediaTypes;
+import org.springframework.security.core.context.SecurityContextHolder;
+import org.springframework.security.web.FilterChainProxy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+import org.springframework.test.web.servlet.MockMvc;
+import org.springframework.web.context.WebApplicationContext;
+
+/**
+ * Series of automated integration tests to verify proper behavior of auto-configured,
+ * OAuth2-secured system
+ *
+ * @author Greg Turnquist
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@SpringApplicationConfiguration(SampleSecureOAuth2ResourceApplication.class)
+@WebIntegrationTest(randomPort = true)
+public class SampleSecureOAuth2ResourceApplicationTests {
+
+	@Autowired
+	WebApplicationContext context;
+
+	@Autowired
+	FilterChainProxy filterChain;
+
+	private MockMvc mvc;
+	@Before
+	public void setUp() {
+		this.mvc = webAppContextSetup(this.context).addFilters(this.filterChain).build();
+		SecurityContextHolder.clearContext();
+	}
+
+	@Test
+	public void homePageAvailable() throws Exception {
+		this.mvc.perform(get(""/"").accept(MediaTypes.HAL_JSON))
+				.andExpect(status().isOk()).andDo(print());
+	}
+
+	@Test
+	public void flightsSecuredByDefault() throws Exception {
+		this.mvc.perform(get(""/flights"").accept(MediaTypes.HAL_JSON))
+				.andExpect(status().isUnauthorized()).andDo(print());
+		this.mvc.perform(get(""/flights/1"").accept(MediaTypes.HAL_JSON))
+				.andExpect(status().isUnauthorized()).andDo(print());
+	}
+
+	@Test
+	public void profileAvailable() throws Exception {
+		this.mvc.perform(get(""/profile"").accept(MediaTypes.HAL_JSON))
+				.andExpect(status().isOk()).andDo(print());
+	}
+
+}
@@ -15,11 +15,15 @@
  */
 package sample.secure.oauth2;
 
+import java.security.Principal;
+
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.SpringBootApplication;
 import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
 import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
 import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RestController;
 
 /**
  * After you launch the app, you can seek a bearer token like this:
@@ -92,7 +96,13 @@
 @EnableAuthorizationServer
 @EnableResourceServer
 @EnableGlobalMethodSecurity(prePostEnabled = true)
+@RestController
 public class SampleSecureOAuth2Application {
+	
+	@RequestMapping(""/user"")
+	public Principal user(Principal user) {
+		return user;
+	}
 
 	public static void main(String[] args) {
 		SpringApplication.run(SampleSecureOAuth2Application.class, args);
@@ -4,5 +4,6 @@ security.user.name=greg
 security.user.password=turnquist
 security.oauth2.client.client-id=foo
 security.oauth2.client.client-secret=bar
+security.oauth2.authorization.checkTokenAccess=isAuthenticated()
 
 logging.level.org.springframework.security=DEBUG
"
https://github.com/spring-projects/spring-boot/commit/8e8bf8e1779ffcef2ec35c6921b6b596c0c8353a,Uses the latest version of Tomcat 7 in the sample ,https://api.github.com/repos/spring-projects/spring-boot/commits/8e8bf8e1779ffcef2ec35c6921b6b596c0c8353a,"@@ -19,7 +19,7 @@
 	<properties>
 		<main.basedir>${basedir}/../..</main.basedir>
 		<m2eclipse.wtp.contextRoot>/</m2eclipse.wtp.contextRoot>
-		<tomcat.version>7.0.56</tomcat.version>
+		<tomcat.version>7.0.57</tomcat.version>
 		<java.version>1.7</java.version>
 	</properties>
 	<dependencies>
"
https://github.com/square/retrofit/commit/6108179c09dae0ccdd7e8d97d4a3b79f9f4443a4,"Use custom exception type when triggering mock failure.  <enter> Since we omit the stack trace, this more clearly indicates the source being from Retrofit's mock behavior. ",https://api.github.com/repos/square/retrofit/commits/6108179c09dae0ccdd7e8d97d4a3b79f9f4443a4,"@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+
+final class MockRetrofitIOException extends IOException {
+  MockRetrofitIOException() {
+    super(""Failure triggered by MockRetrofit's NetworkBehavior"");
+  }
+}
@@ -76,7 +76,7 @@ public static NetworkBehavior create(Random random) {
   private NetworkBehavior(Random random) {
     this.random = random;
 
-    failureException = new IOException(""Mock failure!"");
+    failureException = new MockRetrofitIOException();
     failureException.setStackTrace(new StackTraceElement[0]);
   }
 
@@ -33,7 +33,8 @@ public final class NetworkBehaviorTest {
 
   @Test public void defaultThrowable() {
     Throwable t = behavior.failureException();
-    assertThat(t).isExactlyInstanceOf(IOException.class).hasMessage(""Mock failure!"");
+    assertThat(t).isInstanceOf(IOException.class)
+        .isExactlyInstanceOf(MockRetrofitIOException.class);
     assertThat(t.getStackTrace()).isEmpty();
   }
 
"
https://github.com/square/retrofit/commit/49bba7d60f2a920e138e9388c515ee58fc8c4bcf,Rewrite RxJava call adapter tests to be more understandable. ,https://api.github.com/repos/square/retrofit/commits/49bba7d60f2a920e138e9388c515ee58fc8c4bcf,"@@ -39,5 +39,10 @@
       <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
@@ -17,124 +17,139 @@
 
 import com.google.gson.reflect.TypeToken;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.List;
+import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import retrofit.converter.Converter;
+import retrofit.http.GET;
 import rx.Observable;
+import rx.observables.BlockingObservable;
 
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ObservableCallAdapterFactoryTest {
-  private final ObservableCallAdapterFactory factory = ObservableCallAdapterFactory.create();
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  interface Service {
+    @GET(""/"") Observable<String> body();
+    @GET(""/"") Observable<Response<String>> response();
+    @GET(""/"") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    RestAdapter ra = new RestAdapter.Builder()
+        .endpoint(server.getUrl(""/"").toString())
+        .converter(new StringConverter())
+        .addCallAdapterFactory(ObservableCallAdapterFactory.create())
+        .build();
+    service = ra.create(Service.class);
+  }
 
   @Test public void bodySuccess200() {
-    Type type = new TypeToken<Observable<String>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    Observable<String> observable = (Observable<String>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.success(Response.fromBody(""Hi""));
-      }
-    });
-    String body = observable.toBlocking().first();
-    assertThat(body).isEqualTo(""Hi"");
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    assertThat(o.first()).isEqualTo(""Hi"");
   }
 
   @Test public void bodySuccess404() {
-    Type type = new TypeToken<Observable<String>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    Observable<String> observable = (Observable<String>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.success(
-            Response.fromError(404, ResponseBody.create(MediaType.parse(""application/json""), ""Hi"")));
-      }
-    });
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingObservable<String> o = service.body().toBlocking();
     try {
-      observable.toBlocking().first();
+      o.first();
       fail();
     } catch (RuntimeException e) {
       // TODO assert on some indicator of 404.
     }
   }
 
   @Test public void bodyFailure() {
-    Type type = new TypeToken<Observable<String>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Throwable throwable = new IOException();
-    Observable<String> observable = (Observable<String>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.failure(throwable);
-      }
-    });
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<String> o = service.body().toBlocking();
     try {
-      observable.toBlocking().first();
+      o.first();
       fail();
     } catch (RuntimeException e) {
-      assertThat(e.getCause()).isSameAs(throwable);
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
   }
 
-  @Test public void responseSuccess() {
-    Type type = new TypeToken<Observable<Response<String>>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Response<Object> response = Response.fromBody(""Hi"");
-    Observable<Response<String>> observable = (Observable<Response<String>>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.success(response);
-      }
-    });
-    Response<String> body = observable.toBlocking().first();
-    assertThat(body).isSameAs(response);
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo(""Hi"");
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
   }
 
   @Test public void responseFailure() {
-    Type type = new TypeToken<Observable<Response<String>>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Throwable throwable = new IOException();
-    Observable<Response<String>> observable = (Observable<Response<String>>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.failure(throwable);
-      }
-    });
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
     try {
-      observable.toBlocking().first();
+      o.first();
       fail();
     } catch (RuntimeException t) {
-      assertThat(t.getCause()).isSameAs(throwable);
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
     }
   }
 
-  @Test public void resultSuccess() {
-    Type type = new TypeToken<Observable<Result<String>>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Response<Object> response = Response.fromBody(""Hi"");
-    Observable<Result<String>> observable = (Observable<Result<String>>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.success(response);
-      }
-    });
-    Result<String> result = observable.toBlocking().first();
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo(""Hi"");
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
-    assertThat(result.response()).isSameAs(response);
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
   }
 
   @Test public void resultFailure() {
-    Type type = new TypeToken<Observable<Result<String>>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Throwable throwable = new IOException();
-    Observable<Result<String>> observable = (Observable<Result<String>>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.failure(throwable);
-      }
-    });
-    Result<String> result = observable.toBlocking().first();
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
     assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isSameAs(throwable);
+    assertThat(result.error()).isInstanceOf(IOException.class);
   }
 
   @Test public void responseType() {
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     Type classType = new TypeToken<Observable<String>>() {}.getType();
     assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
     Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
@@ -150,6 +165,7 @@ public final class ObservableCallAdapterFactoryTest {
 
   @Test public void rawTypeThrows() {
     Type type = new TypeToken<Observable>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
       factory.get(type);
       fail();
@@ -160,6 +176,7 @@ public final class ObservableCallAdapterFactoryTest {
 
   @Test public void rawResponseTypeThrows() {
     Type type = new TypeToken<Observable<Response>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
       factory.get(type);
       fail();
@@ -170,6 +187,7 @@ public final class ObservableCallAdapterFactoryTest {
 
   @Test public void rawResultTypeThrows() {
     Type type = new TypeToken<Observable<Result>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
       factory.get(type);
       fail();
@@ -178,20 +196,13 @@ public final class ObservableCallAdapterFactoryTest {
     }
   }
 
-  static abstract class EmptyCall implements Call<Object> {
-    @Override public Response<Object> execute() throws IOException {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public void cancel() {
+  static class StringConverter implements Converter {
+    @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+      return body.string();
     }
 
-    @Override public Call<Object> clone() {
-      try {
-        return (Call<Object>) super.clone();
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
+    @Override public RequestBody toBody(Object object, Type type) {
+      return RequestBody.create(MediaType.parse(""text/plain""), String.valueOf(type));
     }
   }
 }
"
https://github.com/square/okhttp/commit/32b7675b726a1ca62f5080581f6daaf9b7c6a48e,Use ResponseBody to model the response body everywhere.  <enter> This makes cache writing and gzip layering work a bit nicer because there are fewer fields in HttpEngine to track the various competing streams. ,https://api.github.com/repos/square/okhttp/commits/32b7675b726a1ca62f5080581f6daaf9b7c6a48e,"@@ -126,8 +126,9 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final InputStream getErrorStream() {
     try {
       HttpEngine response = getResponse();
-      if (response.hasResponseBody() && response.getResponse().code() >= HTTP_BAD_REQUEST) {
-        return response.getResponseBodyBytes();
+      if (HttpEngine.hasBody(response.getResponse())
+          && response.getResponse().code() >= HTTP_BAD_REQUEST) {
+        return response.getResponse().body().byteStream();
       }
       return null;
     } catch (IOException e) {
@@ -228,11 +229,7 @@ private static String responseSourceHeader(Response response) {
       throw new FileNotFoundException(url.toString());
     }
 
-    InputStream result = response.getResponseBodyBytes();
-    if (result == null) {
-      throw new ProtocolException(""No response body exists; responseCode="" + getResponseCode());
-    }
-    return result;
+    return response.getResponse().body().byteStream();
   }
 
   @Override public final OutputStream getOutputStream() throws IOException {
@@ -349,8 +346,8 @@ private HttpEngine newHttpEngine(String method, Connection connection,
       engineClient = client.clone().setCache(null);
     }
 
-    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody,
-        priorResponse);
+    return new HttpEngine(engineClient, request, bufferRequestBody, true, connection, null,
+        requestBody, priorResponse);
   }
 
   private String defaultUserAgent() {
@@ -426,7 +423,7 @@ private boolean execute(boolean readResponse) throws IOException {
           ? httpEngine.getConnection().getHandshake()
           : null;
       if (readResponse) {
-        httpEngine.readResponse(false);
+        httpEngine.readResponse(false, null);
       }
 
       return true;
@@ -17,14 +17,11 @@
 
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.OkHeaders;
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.URL;
 import java.util.logging.Level;
-import okio.BufferedSink;
-import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.Internal.logger;
 import static com.squareup.okhttp.internal.http.HttpEngine.MAX_REDIRECTS;
@@ -248,7 +245,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, null, null, null, null);
+    engine = new HttpEngine(client, request, false, false, null, null, null, null);
 
     int redirectionCount = 0;
     while (true) {
@@ -259,13 +256,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
 
       try {
         engine.sendRequest();
-
-        if (request.body() != null) {
-          BufferedSink sink = engine.getBufferedRequestBody();
-          request.body().writeTo(sink);
-        }
-
-        engine.readResponse(forWebSocket);
+        engine.readResponse(forWebSocket, request.body());
       } catch (IOException e) {
         HttpEngine retryEngine = engine.recover(e, null);
         if (retryEngine != null) {
@@ -281,12 +272,10 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
       Request followUp = engine.followUpRequest();
 
       if (followUp == null) {
-        Response.Builder builder = response.newBuilder();
         if (!forWebSocket) {
           engine.releaseConnection();
-          builder.body(new RealResponseBody(response, engine.getResponseBody()));
         }
-        return builder.build();
+        return response;
       }
 
       if (engine.getResponse().isRedirect() && ++redirectionCount > MAX_REDIRECTS) {
@@ -299,30 +288,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
 
       Connection connection = engine.close();
       request = followUp;
-      engine = new HttpEngine(client, request, false, connection, null, null, response);
-    }
-  }
-
-  private static class RealResponseBody extends ResponseBody {
-    private final Response response;
-    private final BufferedSource source;
-
-    RealResponseBody(Response response, BufferedSource source) {
-      this.response = response;
-      this.source = source;
-    }
-
-    @Override public MediaType contentType() {
-      String contentType = response.header(""Content-Type"");
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      return OkHeaders.contentLength(response);
-    }
-
-    @Override public BufferedSource source() {
-      return source;
+      engine = new HttpEngine(client, request, false, false, connection, null, null, response);
     }
   }
 }
@@ -33,7 +33,6 @@
 import java.security.cert.X509Certificate;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLSocket;
-
 import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
@@ -406,12 +405,12 @@ private void makeTunnel(Request request, int readTimeout, int writeTimeout)
       // The response body from a CONNECT should be empty, but if it is not then we should consume
       // it before proceeding.
       long contentLength = OkHeaders.contentLength(response);
-      if (contentLength != -1) {
-        Source body = tunnelConnection.newFixedLengthSource(contentLength);
-        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      } else {
-        tunnelConnection.emptyResponseBody();
+      if (contentLength == -1L) {
+        contentLength = 0L;
       }
+      Source body = tunnelConnection.newFixedLengthSource(contentLength);
+      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+      body.close();
 
       switch (response.code()) {
         case HTTP_OK:
@@ -23,6 +23,7 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.Route;
@@ -31,7 +32,6 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Proxy;
@@ -150,12 +150,6 @@ public final class HttpEngine {
    */
   private Response cacheResponse;
 
-  /**
-   * The response read from the network. Null if the network response hasn't
-   * been read yet, or if the network is not used. Never modified by OkHttp.
-   */
-  private Response networkResponse;
-
   /**
    * The user-visible response. This is derived from either the network
    * response, cache response, or both. It is customized to support OkHttp
@@ -165,33 +159,31 @@ public final class HttpEngine {
 
   private Sink requestBodyOut;
   private BufferedSink bufferedRequestBody;
-
-  /** Null until a response is received from the network or the cache. */
-  private Source responseTransferSource;
-  private BufferedSource responseBody;
-  private InputStream responseBodyBytes;
+  private final boolean callerWritesRequestBody;
 
   /** The cache request currently being populated from a network response. */
   private CacheRequest storeRequest;
   private CacheStrategy cacheStrategy;
 
   /**
-   * @param request the HTTP request without a body. The body must be
-   *     written via the engine's request body stream.
-   * @param connection the connection used for an intermediate response
-   *     immediately prior to this request/response pair, such as a same-host
-   *     redirect. This engine assumes ownership of the connection and must
-   *     release it when it is unneeded.
-   * @param routeSelector the route selector used for a failed attempt
-   *     immediately preceding this attempt, or null if this request doesn't
-   *     recover from a failure.
+   * @param request the HTTP request without a body. The body must be written via the engine's
+   *     request body stream.
+   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
+   *     model where control flow is returned to the calling application to write the request body
+   *     before the response body is readable.
+   * @param connection the connection used for an intermediate response immediately prior to this
+   *     request/response pair, such as a same-host redirect. This engine assumes ownership of the
+   *     connection and must release it when it is unneeded.
+   * @param routeSelector the route selector used for a failed attempt immediately preceding this
+   *     attempt, or null if this request doesn't
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut,
-      Response priorResponse) {
+      boolean callerWritesRequestBody, Connection connection, RouteSelector routeSelector,
+      RetryableSink requestBodyOut, Response priorResponse) {
     this.client = client;
     this.userRequest = request;
     this.bufferRequestBody = bufferRequestBody;
+    this.callerWritesRequestBody = callerWritesRequestBody;
     this.connection = connection;
     this.routeSelector = routeSelector;
     this.requestBodyOut = requestBodyOut;
@@ -242,9 +234,11 @@ public void sendRequest() throws IOException {
 
       transport = Internal.instance.newTransport(connection, this);
 
-      // Create a request body if we don't have one already. We'll already have
-      // one if we're retrying a failed POST.
-      if (permitsRequestBody() && requestBodyOut == null) {
+      // If the caller's control flow writes the request body, we need to create that stream
+      // immediately. And that means we need to immediately write the request headers, so we can
+      // start streaming the request body. (We may already have a request body if we're retrying a
+      // failed POST.)
+      if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
         long contentLength = OkHeaders.contentLength(request);
         if (bufferRequestBody) {
           if (contentLength > Integer.MAX_VALUE) {
@@ -254,7 +248,7 @@ public void sendRequest() throws IOException {
 
           if (contentLength != -1) {
             // Buffer a request body of a known length.
-            transport.writeRequestHeaders(request);
+            transport.writeRequestHeaders(networkRequest);
             requestBodyOut = new RetryableSink((int) contentLength);
           } else {
             // Buffer a request body of an unknown length. Don't write request
@@ -263,8 +257,8 @@ public void sendRequest() throws IOException {
             requestBodyOut = new RetryableSink();
           }
         } else {
-          transport.writeRequestHeaders(request);
-          requestBodyOut = transport.createRequestBody(request, contentLength);
+          transport.writeRequestHeaders(networkRequest);
+          requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
         }
       }
 
@@ -294,9 +288,7 @@ public void sendRequest() throws IOException {
             .build();
       }
 
-      if (userResponse.body() != null) {
-        initContentStream(userResponse.body().source());
-      }
+      userResponse = unzip(userResponse);
     }
   }
 
@@ -361,18 +353,6 @@ public Response getResponse() {
     return userResponse;
   }
 
-  public BufferedSource getResponseBody() {
-    if (userResponse == null) throw new IllegalStateException();
-    return responseBody;
-  }
-
-  public InputStream getResponseBodyBytes() {
-    InputStream result = responseBodyBytes;
-    return result != null
-        ? result
-        : (responseBodyBytes = Okio.buffer(getResponseBody()).inputStream());
-  }
-
   public Connection getConnection() {
     return connection;
   }
@@ -399,8 +379,8 @@ public HttpEngine recover(IOException e, Sink requestBodyOut) {
     Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, connection, routeSelector,
-        (RetryableSink) requestBodyOut, priorResponse);
+    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+        connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
   }
 
   public HttpEngine recover(IOException e) {
@@ -484,17 +464,14 @@ public Connection close() {
     }
 
     // If this engine never achieved a response body, its connection cannot be reused.
-    if (responseBody == null) {
+    if (userResponse == null) {
       if (connection != null) closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
       connection = null;
       return null;
     }
 
     // Close the response body. This will recycle the connection if it is eligible.
-    closeQuietly(responseBody);
-
-    // Clear the buffer held by the response body input stream adapter.
-    closeQuietly(responseBodyBytes);
+    closeQuietly(userResponse.body());
 
     // Close the connection if it cannot be reused.
     if (transport != null && connection != null && !transport.canReuseConnection()) {
@@ -514,45 +491,49 @@ public Connection close() {
   }
 
   /**
-   * Initialize the response content stream from the response transfer source.
-   * These two sources are the same unless we're doing transparent gzip, in
-   * which case the content source is decompressed.
+   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
+   * was both offered by OkHttp and used by the origin server.
    *
-   * <p>Whenever we do transparent gzip we also strip the corresponding headers.
-   * We strip the Content-Encoding header to prevent the application from
-   * attempting to double decompress. We strip the Content-Length header because
-   * it is the length of the compressed content, but the application is only
-   * interested in the length of the uncompressed content.
+   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
+   * Content-Encoding header to prevent the application from attempting to double decompress. We
+   * strip the Content-Length header because it is the length of the compressed content, but the
+   * application is only interested in the length of the uncompressed content.
    *
-   * <p>This method should only be used for non-empty response bodies. Response
-   * codes like ""304 Not Modified"" can include ""Content-Encoding: gzip"" without
-   * a response body and we will crash if we attempt to decompress the zero-byte
-   * source.
+   * <p>This method should only be used for non-empty response bodies. Response codes like ""304 Not
+   * Modified"" can include ""Content-Encoding: gzip"" without a response body and we will crash if we
+   * attempt to decompress the zero-byte source.
    */
-  private void initContentStream(Source transferSource) throws IOException {
-    responseTransferSource = transferSource;
-    if (transparentGzip && ""gzip"".equalsIgnoreCase(userResponse.header(""Content-Encoding""))) {
-      userResponse = userResponse.newBuilder()
-          .removeHeader(""Content-Encoding"")
-          .removeHeader(""Content-Length"")
-          .build();
-      responseBody = Okio.buffer(new GzipSource(transferSource));
-    } else {
-      responseBody = Okio.buffer(transferSource);
+  private Response unzip(final Response response) throws IOException {
+    if (!transparentGzip || !""gzip"".equalsIgnoreCase(userResponse.header(""Content-Encoding""))) {
+      return response;
+    }
+
+    if (response.body() == null) {
+      return response;
     }
+
+    GzipSource responseBody = new GzipSource(response.body().source());
+    Headers strippedHeaders = response.headers().newBuilder()
+        .removeAll(""Content-Encoding"")
+        .removeAll(""Content-Length"")
+        .build();
+    return response.newBuilder()
+        .headers(strippedHeaders)
+        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
+        .build();
   }
 
   /**
    * Returns true if the response must have a (possibly 0-length) body.
    * See RFC 2616 section 4.3.
    */
-  public boolean hasResponseBody() {
+  public static boolean hasBody(Response response) {
     // HEAD requests never yield a body regardless of the response headers.
-    if (userRequest.method().equals(""HEAD"")) {
+    if (response.request().method().equals(""HEAD"")) {
       return false;
     }
 
-    int responseCode = userResponse.code();
+    int responseCode = response.code();
     if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
         && responseCode != HTTP_NO_CONTENT
         && responseCode != HTTP_NOT_MODIFIED) {
@@ -562,8 +543,8 @@ public boolean hasResponseBody() {
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (OkHeaders.contentLength(networkResponse) != -1
-        || ""chunked"".equalsIgnoreCase(networkResponse.header(""Transfer-Encoding""))) {
+    if (OkHeaders.contentLength(response) != -1
+        || ""chunked"".equalsIgnoreCase(response.header(""Transfer-Encoding""))) {
       return true;
     }
 
@@ -623,7 +604,7 @@ public static String hostHeader(URL url) {
    * Flushes the remaining request header and body, parses the HTTP response
    * headers and starts reading the HTTP response body if it exists.
    */
-  public void readResponse(boolean forWebSocket) throws IOException {
+  public void readResponse(boolean forWebSocket, RequestBody requestBody) throws IOException {
     if (userResponse != null) {
       return; // Already ready.
     }
@@ -634,43 +615,60 @@ public void readResponse(boolean forWebSocket) throws IOException {
       return; // No network response to read.
     }
 
-    // Flush the request body if there's data outstanding.
-    if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
-      bufferedRequestBody.flush();
-    }
-
-    if (sentRequestMillis == -1) {
-      if (OkHeaders.contentLength(networkRequest) == -1
-          && requestBodyOut instanceof RetryableSink) {
-        // We might not learn the Content-Length until the request body has been buffered.
-        long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-        networkRequest = networkRequest.newBuilder()
-            .header(""Content-Length"", Long.toString(contentLength))
-            .build();
-      }
+    if (!callerWritesRequestBody) {
+      // If we haven't written the request body yet, write it now.
       transport.writeRequestHeaders(networkRequest);
-    }
-
-    if (requestBodyOut != null) {
-      if (bufferedRequestBody != null) {
-        // This also closes the wrapped requestBodyOut.
+      if (permitsRequestBody() && requestBody != null) {
+        requestBodyOut = transport.createRequestBody(networkRequest, requestBody.contentLength());
+        bufferedRequestBody = Okio.buffer(requestBodyOut);
+        requestBody.writeTo(bufferedRequestBody);
         bufferedRequestBody.close();
-      } else {
-        requestBodyOut.close();
       }
-      if (requestBodyOut instanceof RetryableSink) {
-        transport.writeRequestBody((RetryableSink) requestBodyOut);
+    } else {
+      // Emit the request body's buffer so that everything is in requestBodyOut.
+      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
+        bufferedRequestBody.emit();
+      }
+
+      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
+      if (sentRequestMillis == -1) {
+        if (OkHeaders.contentLength(networkRequest) == -1
+            && requestBodyOut instanceof RetryableSink) {
+          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
+          networkRequest = networkRequest.newBuilder()
+              .header(""Content-Length"", Long.toString(contentLength))
+              .build();
+        }
+        transport.writeRequestHeaders(networkRequest);
+      }
+
+      // Write the request body to the socket.
+      if (requestBodyOut != null) {
+        if (bufferedRequestBody != null) {
+          // This also closes the wrapped requestBodyOut.
+          bufferedRequestBody.close();
+        } else {
+          requestBodyOut.close();
+        }
+        if (requestBodyOut instanceof RetryableSink) {
+          transport.writeRequestBody((RetryableSink) requestBodyOut);
+        }
       }
     }
 
-    transport.flushRequest();
+    transport.finishRequest();
 
-    networkResponse = transport.readResponseHeaders()
+    Response networkResponse = transport.readResponseHeaders()
         .request(networkRequest)
         .handshake(connection.getHandshake())
         .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
         .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
         .build();
+    if (!forWebSocket) {
+      networkResponse = networkResponse.newBuilder()
+          .body(transport.openResponseBody(networkResponse))
+          .build();
+    }
     Internal.instance.setProtocol(connection, networkResponse.protocol());
     receiveHeaders(networkResponse.headers());
 
@@ -684,18 +682,15 @@ public void readResponse(boolean forWebSocket) throws IOException {
             .cacheResponse(stripBody(cacheResponse))
             .networkResponse(stripBody(networkResponse))
             .build();
-        transport.emptyTransferStream();
+        networkResponse.body().close();
         releaseConnection();
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
         InternalCache responseCache = Internal.instance.internalCache(client);
         responseCache.trackConditionalCacheHit();
         responseCache.update(cacheResponse, stripBody(userResponse));
-
-        if (cacheResponse.body() != null) {
-          initContentStream(cacheResponse.body().source());
-        }
+        userResponse = unzip(userResponse);
         return;
       } else {
         closeQuietly(cacheResponse.body());
@@ -709,34 +704,28 @@ public void readResponse(boolean forWebSocket) throws IOException {
         .networkResponse(stripBody(networkResponse))
         .build();
 
-    if (!hasResponseBody()) {
-      if (!forWebSocket) {
-        // Don't call initContentStream() when the response doesn't have any content.
-        responseTransferSource = transport.getTransferStream();
-        responseBody = Okio.buffer(responseTransferSource);
-      }
-      return;
+    if (hasBody(userResponse)) {
+      maybeCache();
+      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
     }
-
-    maybeCache();
-    initContentStream(cacheWritingSource(storeRequest, transport.getTransferStream()));
   }
 
   /**
    * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
    * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
    * may never exhaust the source stream and therefore not complete the cached response.
    */
-  private Source cacheWritingSource(final CacheRequest cacheRequest, final Source source)
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
       throws IOException {
     // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return source;
+    if (cacheRequest == null) return response;
     Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return source;
+    if (cacheBodyUnbuffered == null) return response;
 
+    final BufferedSource source = response.body().source();
     final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
 
-    return new Source() {
+    Source cacheWritingSource = new Source() {
       boolean cacheRequestClosed;
 
       @Override public long read(Buffer sink, long byteCount) throws IOException {
@@ -777,6 +766,10 @@ private Source cacheWritingSource(final CacheRequest cacheRequest, final Source
         source.close();
       }
     };
+
+    return response.newBuilder()
+        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+        .build();
   }
 
   /**
@@ -18,7 +18,9 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okio.Okio;
 import okio.Sink;
 import okio.Source;
 
@@ -46,7 +48,7 @@ public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
         ""Cannot stream a request body without chunked encoding or a known content length!"");
   }
 
-  @Override public void flushRequest() throws IOException {
+  @Override public void finishRequest() throws IOException {
     httpConnection.flush();
   }
 
@@ -104,20 +106,21 @@ public void writeRequestHeaders(Request request) throws IOException {
     return true;
   }
 
-  @Override public void emptyTransferStream() throws IOException {
-    httpConnection.emptyResponseBody();
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = getTransferStream(response);
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
   }
 
-  @Override public Source getTransferStream() throws IOException {
-    if (!httpEngine.hasResponseBody()) {
+  private Source getTransferStream(Response response) throws IOException {
+    if (!HttpEngine.hasBody(response)) {
       return httpConnection.newFixedLengthSource(0);
     }
 
-    if (""chunked"".equalsIgnoreCase(httpEngine.getResponse().header(""Transfer-Encoding""))) {
+    if (""chunked"".equalsIgnoreCase(response.header(""Transfer-Encoding""))) {
       return httpConnection.newChunkedSource(httpEngine);
     }
 
-    long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
+    long contentLength = OkHeaders.contentLength(response);
     if (contentLength != -1) {
       return httpConnection.newFixedLengthSource(contentLength);
     }
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import okio.BufferedSource;
+
+public final class RealResponseBody extends ResponseBody {
+  private final Headers headers;
+  private final BufferedSource source;
+
+  public RealResponseBody(Headers headers, BufferedSource source) {
+    this.headers = headers;
+    this.source = source;
+  }
+
+  @Override public MediaType contentType() {
+    String contentType = headers.get(""Content-Type"");
+    return contentType != null ? MediaType.parse(contentType) : null;
+  }
+
+  @Override public long contentLength() {
+    return OkHeaders.contentLength(headers);
+  }
+
+  @Override public BufferedSource source() {
+    return source;
+  }
+}
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
@@ -34,8 +35,8 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import okio.ByteString;
+import okio.Okio;
 import okio.Sink;
-import okio.Source;
 
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
@@ -95,7 +96,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     requestBody.writeToSocket(stream.getSink());
   }
 
-  @Override public void flushRequest() throws IOException {
+  @Override public void finishRequest() throws IOException {
     stream.getSink().close();
   }
 
@@ -204,12 +205,8 @@ public static Response.Builder readNameValueBlock(List<Header> headerBlock,
         .headers(headersBuilder.build());
   }
 
-  @Override public void emptyTransferStream() {
-    // Do nothing.
-  }
-
-  @Override public Source getTransferStream() throws IOException {
-    return stream.getSource();
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));
   }
 
   @Override public void releaseConnectionOnIdle() {
@@ -18,9 +18,9 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import okio.Sink;
-import okio.Source;
 
 public interface Transport {
   /**
@@ -42,16 +42,14 @@ public interface Transport {
    */
   void writeRequestBody(RetryableSink requestBody) throws IOException;
 
-  /** Flush the request body to the underlying socket. */
-  void flushRequest() throws IOException;
+  /** Flush the request to the underlying socket. */
+  void finishRequest() throws IOException;
 
-  /** Read response headers and update the cookie manager. */
+  /** Read and return response headers. */
   Response.Builder readResponseHeaders() throws IOException;
 
-  /** Notify the transport that no response body will be read. */
-  void emptyTransferStream() throws IOException;
-
-  Source getTransferStream() throws IOException;
+  /** Returns a stream that reads the response body. */
+  ResponseBody openResponseBody(Response response) throws IOException;
 
   /**
    * Configures the response body to pool or close the socket connection when
"
https://github.com/square/okhttp/commit/59a6804c91328c2d1eb096054590b213ab711d22,Tests for canceling async requests. ,https://api.github.com/repos/square/okhttp/commits/59a6804c91328c2d1eb096054590b213ab711d22,"@@ -17,12 +17,16 @@
 
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.File;
+import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLContext;
 import org.junit.After;
 import org.junit.Before;
@@ -178,4 +182,59 @@ public final class AsyncApiTest {
         .assertCode(301)
         .assertContainsHeaders(""Test: Redirect from /a to /b"");
   }
+
+  @Test public void canceledBeforeResponseReadIsNeverDelivered() throws Exception {
+    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    server.setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel(""request A"");
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+    server.play();
+
+    // Canceling a request after the server has received a request but before
+    // it has delivered the response. That request will never be received to the
+    // client.
+    Request requestA = new Request.Builder().url(server.getUrl(""/a"")).tag(""request A"").build();
+    client.enqueue(requestA, receiver);
+    assertEquals(""/a"", server.takeRequest().getPath());
+
+    // We then make a second request (not canceled) to make sure the receiver
+    // has nothing left to wait for.
+    Request requestB = new Request.Builder().url(server.getUrl(""/b"")).tag(""request B"").build();
+    client.enqueue(requestB, receiver);
+    assertEquals(""/b"", server.takeRequest().getPath());
+    receiver.await(requestB.url()).assertBody(""B"");
+
+    // At this point we know the receiver is ready: if it hasn't received 'A'
+    // yet it never will.
+    receiver.assertNoResponse(requestA.url());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredDoesNothing() throws Exception {
+    server.enqueue(new MockResponse().setBody(""A""));
+    server.play();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+
+    Request request = new Request.Builder().url(server.getUrl(""/a"")).tag(""request A"").build();
+    client.enqueue(request, new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        throw new AssertionError();
+      }
+
+      @Override public boolean onResponse(Response response) throws IOException {
+        client.cancel(""request A"");
+        bodyRef.set(response.body().string());
+        latch.countDown();
+        return true;
+      }
+    });
+
+    latch.await();
+    assertEquals(""A"", bodyRef.get());
+  }
 }
@@ -86,4 +86,12 @@ public synchronized RecordedResponse await(URL url) throws Exception {
 
     throw new AssertionError(""Timed out waiting for response to "" + url);
   }
+
+  public synchronized void assertNoResponse(URL url) throws Exception {
+    for (RecordedResponse recordedResponse : responses) {
+      if (recordedResponse.request.url().equals(url)) {
+        throw new AssertionError(""Expected no response for "" + url);
+      }
+    }
+  }
 }
"
https://github.com/square/okhttp/commit/40ff76547064c3fb5acb9047a6f679dd4379a4d0,Make HttpConnection.connect return full working connections.  <enter> Previously the returned connections required the caller to do extra work: setting up tunnels (which could require auth) and performing an SSL handshake. With this change we make a complete working connection in HttpConnection.connect(). <enter> This will make it easier to fix fallback when a single domain has multiple IP addresses and some of those addresses are not reachable. <enter> This will also make it easier to do SPDY through HTTP proxies. ,https://api.github.com/repos/square/okhttp/commits/40ff76547064c3fb5acb9047a6f679dd4379a4d0,"@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package libcore.net.http;
-
-/**
- * An RFC 2617 challenge.
- */
-final class Challenge {
-    final String scheme;
-    final String realm;
-
-    Challenge(String scheme, String realm) {
-        this.scheme = scheme;
-        this.realm = realm;
-    }
-
-    @Override public boolean equals(Object o) {
-        return o instanceof Challenge
-                && ((Challenge) o).scheme.equals(scheme)
-                && ((Challenge) o).realm.equals(realm);
-    }
-
-    @Override public int hashCode() {
-        return scheme.hashCode() + 31 * realm.hashCode();
-    }
-}
@@ -65,61 +65,12 @@ public static void parseCacheControl(String value, CacheControlHandler handler)
         }
     }
 
-    /**
-     * Parse RFC 2617 challenges. This API is only interested in the scheme
-     * name and realm.
-     */
-    public static List<Challenge> parseChallenges(
-            RawHeaders responseHeaders, String challengeHeader) {
-        /*
-         * auth-scheme = token
-         * auth-param  = token ""="" ( token | quoted-string )
-         * challenge   = auth-scheme 1*SP 1#auth-param
-         * realm       = ""realm"" ""="" realm-value
-         * realm-value = quoted-string
-         */
-        List<Challenge> result = new ArrayList<Challenge>();
-        for (int h = 0; h < responseHeaders.length(); h++) {
-            if (!challengeHeader.equalsIgnoreCase(responseHeaders.getFieldName(h))) {
-                continue;
-            }
-            String value = responseHeaders.getValue(h);
-            int pos = 0;
-            while (pos < value.length()) {
-                int tokenStart = pos;
-                pos = skipUntil(value, pos, "" "");
-
-                String scheme = value.substring(tokenStart, pos).trim();
-                pos = skipWhitespace(value, pos);
-
-                // TODO: This currently only handles schemes with a 'realm' parameter;
-                //       It needs to be fixed to handle any scheme and any parameters
-                //       http://code.google.com/p/android/issues/detail?id=11140
-
-                if (!value.regionMatches(pos, ""realm=\"""", 0, ""realm=\"""".length())) {
-                    break; // unexpected challenge parameter; give up
-                }
-
-                pos += ""realm=\"""".length();
-                int realmStart = pos;
-                pos = skipUntil(value, pos, ""\"""");
-                String realm = value.substring(realmStart, pos);
-                pos++; // consume '""' close quote
-                pos = skipUntil(value, pos, "","");
-                pos++; // consume ',' comma
-                pos = skipWhitespace(value, pos);
-                result.add(new Challenge(scheme, realm));
-            }
-        }
-        return result;
-    }
-
     /**
      * Returns the next index in {@code input} at or after {@code pos} that
      * contains a character from {@code characters}. Returns the input length if
      * none of the requested characters can be found.
      */
-    private static int skipUntil(String input, int pos, String characters) {
+    public static int skipUntil(String input, int pos, String characters) {
         for (; pos < input.length(); pos++) {
             if (characters.indexOf(input.charAt(pos)) != -1) {
                 break;
@@ -132,7 +83,7 @@ private static int skipUntil(String input, int pos, String characters) {
      * Returns the next non-whitespace character in {@code input} that is white
      * space. Result is undefined if input contains newline characters.
      */
-    private static int skipWhitespace(String input, int pos) {
+    public static int skipWhitespace(String input, int pos) {
         for (; pos < input.length(); pos++) {
             char c = input.charAt(pos);
             if (c != ' ' && c != '\t') {
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package libcore.net.http;
+
+import static com.squareup.okhttp.OkHttpConnection.HTTP_PROXY_AUTH;
+import static com.squareup.okhttp.OkHttpConnection.HTTP_UNAUTHORIZED;
+import java.io.IOException;
+import java.net.Authenticator;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.PasswordAuthentication;
+import java.net.Proxy;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import libcore.io.Base64;
+
+/**
+ * Handles HTTP authentication headers from origin and proxy servers.
+ */
+public final class HttpAuthenticator {
+    /**
+     * React to a failed authorization response by looking up new credentials.
+     *
+     * @return true if credentials have been added to successorRequestHeaders
+     *     and another request should be attempted.
+     */
+    public static final boolean processAuthHeader(int responseCode, RawHeaders responeHeaders,
+            RawHeaders successorRequestHeaders, Proxy proxy, URL url) throws IOException {
+        if (responseCode != HTTP_PROXY_AUTH && responseCode != HTTP_UNAUTHORIZED) {
+            throw new IllegalArgumentException();
+        }
+
+        // Keep asking for username/password until authorized.
+        String challengeHeader = responseCode == HTTP_PROXY_AUTH
+                ? ""Proxy-Authenticate""
+                : ""WWW-Authenticate"";
+        String credentials = getCredentials(responeHeaders, challengeHeader, proxy, url);
+        if (credentials == null) {
+            return false; // Could not find credentials so end the request cycle.
+        }
+
+        // Add authorization credentials, bypassing the already-connected check.
+        String fieldName = responseCode == HTTP_PROXY_AUTH
+                ? ""Proxy-Authorization""
+                : ""Authorization"";
+        successorRequestHeaders.set(fieldName, credentials);
+        return true;
+    }
+
+    /**
+     * Returns the authorization credentials that may satisfy the challenge.
+     * Returns null if a challenge header was not provided or if credentials
+     * were not available.
+     */
+    private static String getCredentials(RawHeaders responseHeaders,
+            String challengeHeader, Proxy proxy, URL url) throws IOException {
+        List<Challenge> challenges = parseChallenges(responseHeaders, challengeHeader);
+        if (challenges.isEmpty()) {
+            return null;
+        }
+
+        for (Challenge challenge : challenges) {
+            // Use the global authenticator to get the password.
+            PasswordAuthentication auth;
+            if (responseHeaders.getResponseCode() == HTTP_PROXY_AUTH) {
+                InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
+                auth = Authenticator.requestPasswordAuthentication(
+                        proxyAddress.getHostName(), getConnectToInetAddress(proxy, url),
+                        proxyAddress.getPort(), url.getProtocol(), challenge.realm,
+                        challenge.scheme, url, Authenticator.RequestorType.PROXY);
+            } else {
+                auth = Authenticator.requestPasswordAuthentication(
+                        url.getHost(), getConnectToInetAddress(proxy, url), url.getPort(),
+                        url.getProtocol(), challenge.realm, challenge.scheme, url,
+                        Authenticator.RequestorType.SERVER);
+            }
+            if (auth == null) {
+                continue;
+            }
+
+            // Use base64 to encode the username and password.
+            String usernameAndPassword = auth.getUserName() + "":"" + new String(auth.getPassword());
+            byte[] bytes = usernameAndPassword.getBytes(""ISO-8859-1"");
+            String encoded = Base64.encode(bytes);
+            return challenge.scheme + "" "" + encoded;
+        }
+
+        return null;
+    }
+
+    private static InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
+        return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+                ? ((InetSocketAddress) proxy.address()).getAddress()
+                : InetAddress.getByName(url.getHost());
+    }
+
+    /**
+     * Parse RFC 2617 challenges. This API is only interested in the scheme
+     * name and realm.
+     */
+    private static List<Challenge> parseChallenges(
+            RawHeaders responseHeaders, String challengeHeader) {
+        /*
+         * auth-scheme = token
+         * auth-param  = token ""="" ( token | quoted-string )
+         * challenge   = auth-scheme 1*SP 1#auth-param
+         * realm       = ""realm"" ""="" realm-value
+         * realm-value = quoted-string
+         */
+        List<Challenge> result = new ArrayList<Challenge>();
+        for (int h = 0; h < responseHeaders.length(); h++) {
+            if (!challengeHeader.equalsIgnoreCase(responseHeaders.getFieldName(h))) {
+                continue;
+            }
+            String value = responseHeaders.getValue(h);
+            int pos = 0;
+            while (pos < value.length()) {
+                int tokenStart = pos;
+                pos = HeaderParser.skipUntil(value, pos, "" "");
+
+                String scheme = value.substring(tokenStart, pos).trim();
+                pos = HeaderParser.skipWhitespace(value, pos);
+
+                // TODO: This currently only handles schemes with a 'realm' parameter;
+                //       It needs to be fixed to handle any scheme and any parameters
+                //       http://code.google.com/p/android/issues/detail?id=11140
+
+                if (!value.regionMatches(pos, ""realm=\"""", 0, ""realm=\"""".length())) {
+                    break; // Unexpected challenge parameter; give up!
+                }
+
+                pos += ""realm=\"""".length();
+                int realmStart = pos;
+                pos = HeaderParser.skipUntil(value, pos, ""\"""");
+                String realm = value.substring(realmStart, pos);
+                pos++; // Consume '""' close quote.
+                pos = HeaderParser.skipUntil(value, pos, "","");
+                pos++; // Consume ',' comma.
+                pos = HeaderParser.skipWhitespace(value, pos);
+                result.add(new Challenge(scheme, realm));
+            }
+        }
+        return result;
+    }
+
+    /**
+     * An RFC 2617 challenge.
+     */
+    private static final class Challenge {
+        final String scheme;
+        final String realm;
+
+        Challenge(String scheme, String realm) {
+            this.scheme = scheme;
+            this.realm = realm;
+        }
+
+        @Override public boolean equals(Object o) {
+            return o instanceof Challenge
+                    && ((Challenge) o).scheme.equals(scheme)
+                    && ((Challenge) o).realm.equals(realm);
+        }
+
+        @Override public int hashCode() {
+            return scheme.hashCode() + 31 * realm.hashCode();
+        }
+    }
+}
@@ -17,22 +17,26 @@
 
 package libcore.net.http;
 
+import static com.squareup.okhttp.OkHttpConnection.HTTP_PROXY_AUTH;
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import static java.net.HttpURLConnection.HTTP_OK;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.Socket;
 import java.net.SocketAddress;
-import java.net.SocketException;
 import java.net.URI;
+import java.net.URL;
 import java.net.UnknownHostException;
+import java.security.cert.CertificateException;
 import java.util.Arrays;
 import java.util.List;
 import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import libcore.io.IoUtils;
@@ -62,82 +66,50 @@ final class HttpConnection {
     };
 
     private final Address address;
-    private final Socket socket;
-    private InputStream inputStream;
-    private OutputStream outputStream;
-    private SSLSocket sslSocket;
-    private InputStream sslInputStream;
-    private OutputStream sslOutputStream;
+    private Socket socket;
+    private InputStream in;
+    private OutputStream out;
     private boolean recycled = false;
     private SpdyConnection spdyConnection;
 
+    HttpConnection(Address address, Socket socket, InputStream in, OutputStream out) {
+        this.address = address;
+        this.socket = socket;
+        this.in = in;
+        this.out = out;
+    }
+
     /**
      * The version this client will use. Either 0 for HTTP/1.0, or 1 for
      * HTTP/1.1. Upon receiving a non-HTTP/1.1 response, this client
      * automatically sets its version to HTTP/1.0.
      */
     int httpMinorVersion = 1; // Assume HTTP/1.1
 
-    private HttpConnection(Address config, int connectTimeout) throws IOException {
-        this.address = config;
-
-        /*
-         * Try each of the host's addresses for best behavior in mixed IPv4/IPv6
-         * environments. See http://b/2876927
-         * TODO: add a hidden method so that Socket.tryAllAddresses can does this for us
-         */
-        Socket socketCandidate = null;
-        InetAddress[] addresses = InetAddress.getAllByName(config.socketHost);
-        for (int i = 0; i < addresses.length; i++) {
-            socketCandidate = (config.proxy != null && config.proxy.type() != Proxy.Type.HTTP)
-                    ? new Socket(config.proxy)
-                    : new Socket();
-            try {
-                socketCandidate.connect(
-                        new InetSocketAddress(addresses[i], config.socketPort), connectTimeout);
-                break;
-            } catch (IOException e) {
-                if (i == addresses.length - 1) {
-                    throw e;
-                }
-            }
-        }
-
-        if (socketCandidate == null) {
-            throw new IOException();
-        }
-
-        this.socket = socketCandidate;
-
-        /*
-         * Buffer the socket stream to permit efficient parsing of HTTP headers
-         * and chunk sizes. Benchmarks suggest 128 is sufficient. We cannot
-         * buffer when setting up a tunnel because we may consume bytes intended
-         * for the SSL socket.
-         */
-        int bufferSize = 128;
-        inputStream = address.requiresTunnel()
-                ? socket.getInputStream()
-                : new BufferedInputStream(socket.getInputStream(), bufferSize);
-        outputStream = socket.getOutputStream();
+    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,
+            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,
+            TunnelConfig tunnelConfig) throws IOException {
+        HttpConnection result = getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,
+                connectTimeout, tunnelConfig);
+        result.socket.setSoTimeout(readTimeout);
+        return result;
     }
 
-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,
-            Proxy proxy, int connectTimeout) throws IOException {
-        /*
-         * Try an explicitly-specified proxy.
-         */
+    /**
+     * Selects a proxy and gets a connection with that proxy.
+     */
+    private static HttpConnection getConnection(URI uri, SSLSocketFactory sslSocketFactory,
+            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout,
+            TunnelConfig tunnelConfig) throws IOException {
+        // Try an explicitly-specified proxy.
         if (proxy != null) {
             Address address = (proxy.type() == Proxy.Type.DIRECT)
-                    ? new Address(uri, sslSocketFactory)
-                    : new Address(uri, sslSocketFactory, proxy);
-            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);
+                    ? new Address(uri, sslSocketFactory, hostnameVerifier)
+                    : new Address(uri, sslSocketFactory, hostnameVerifier, proxy);
+            return getConnectionToAddress(address, connectTimeout, tunnelConfig);
         }
 
-        /*
-         * Try connecting to each of the proxies provided by the ProxySelector
-         * until a connection succeeds.
-         */
+        // Try each proxy provided by the ProxySelector until a connection succeeds.
         ProxySelector selector = ProxySelector.getDefault();
         List<Proxy> proxyList = selector.select(uri);
         if (proxyList != null) {
@@ -148,58 +120,118 @@ public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,
                     continue;
                 }
                 try {
-                    Address address = new Address(uri, sslSocketFactory, selectedProxy);
-                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);
+                    return getConnectionToAddress(new Address(uri, sslSocketFactory,
+                            hostnameVerifier, selectedProxy), connectTimeout, tunnelConfig);
                 } catch (IOException e) {
                     // failed to connect, tell it to the selector
                     selector.connectFailed(uri, selectedProxy.address(), e);
                 }
             }
         }
 
+        // Try a direct connection. If this fails, this method will throw.
+        return getConnectionToAddress(new Address(uri, sslSocketFactory, hostnameVerifier),
+                connectTimeout, tunnelConfig);
+    }
+
+    /**
+     * Selects a proxy and gets a connection with that proxy.
+     */
+    private static HttpConnection getConnectionToAddress(Address address, int connectTimeout,
+            TunnelConfig tunnelConfig) throws IOException {
+        HttpConnection pooled = HttpConnectionPool.INSTANCE.get(address);
+        if (pooled != null) {
+            return pooled;
+        }
+
+        Socket socket = connectSocket(address, connectTimeout);
+        HttpConnection result = new HttpConnection(
+                address, socket, socket.getInputStream(), socket.getOutputStream());
+
+        if (address.sslSocketFactory != null) {
+            // First try an SSL connection with compression and various TLS
+            // extensions enabled, if it fails (and its not unheard of that it
+            // will) fallback to a barebones connection.
+            try {
+                result = new HttpConnection(
+                        address, socket, socket.getInputStream(), socket.getOutputStream());
+                result.upgradeToTls(true, tunnelConfig);
+            } catch (IOException e) {
+                // If the problem was a CertificateException from the X509TrustManager,
+                // do not retry, we didn't have an abrupt server initiated exception.
+                if (e instanceof SSLHandshakeException
+                        && e.getCause() instanceof CertificateException) {
+                    throw e;
+                }
+                result.closeSocketAndStreams();
+
+                socket = connectSocket(address, connectTimeout);
+                result = new HttpConnection(
+                        address, socket, socket.getInputStream(), socket.getOutputStream());
+                result.upgradeToTls(false, tunnelConfig);
+            }
+        }
+
         /*
-         * Try a direct connection. If this fails, this method will throw.
+         * Buffer the socket stream to permit efficient parsing of HTTP headers
+         * and chunk sizes. This also masks SSL InputStream's degenerate
+         * available() implementation. That way we can read the end of a chunked
+         * response without blocking and will recycle connections more reliably.
+         * http://code.google.com/p/android/issues/detail?id=38817
          */
-        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);
-    }
+        int bufferSize = 128;
+        result.in = new BufferedInputStream(result.in, bufferSize);
 
-    public void closeSocketAndStreams() {
-        IoUtils.closeQuietly(sslOutputStream);
-        IoUtils.closeQuietly(sslInputStream);
-        IoUtils.closeQuietly(sslSocket);
-        IoUtils.closeQuietly(outputStream);
-        IoUtils.closeQuietly(inputStream);
-        IoUtils.closeQuietly(socket);
+        return result;
     }
 
-    public void setSoTimeout(int readTimeout) throws SocketException {
-        socket.setSoTimeout(readTimeout);
-    }
+    /**
+     * Try each of the host's addresses for best behavior in mixed IPv4/IPv6
+     * environments. See http://b/2876927
+     */
+    private static Socket connectSocket(Address address, int connectTimeout) throws IOException {
+        Socket socket = null;
+        InetAddress[] addresses = InetAddress.getAllByName(address.socketHost);
+        for (int i = 0; i < addresses.length; i++) {
+            socket = (address.proxy != null && address.proxy.type() != Proxy.Type.HTTP)
+                    ? new Socket(address.proxy)
+                    : new Socket();
+            try {
+                socket.connect(
+                        new InetSocketAddress(addresses[i], address.socketPort), connectTimeout);
+                break;
+            } catch (IOException e) {
+                if (i == addresses.length - 1) {
+                    throw e;
+                }
+            }
+        }
 
-    Socket getSocket() {
-        return sslSocket != null ? sslSocket : socket;
-    }
+        if (socket == null) {
+            throw new IOException();
+        }
 
-    public Address getAddress() {
-        return address;
+        return socket;
     }
 
     /**
-     * Create an {@code SSLSocket} and perform the SSL handshake
-     * (performing certificate validation.
+     * Create an {@code SSLSocket} and perform the TLS handshake and certificate
+     * validation.
      *
-     * @param sslSocketFactory Source of new {@code SSLSocket} instances.
-     * @param tlsTolerant If true, assume server can handle common
+     * @param tlsTolerant If true, assume server can handle common TLS
+     *     extensions and SSL deflate compression. If false, use an SSL3 only
+     *     fallback mode without compression.
      */
-    public SSLSocket setupSecureSocket(SSLSocketFactory sslSocketFactory,
-            HostnameVerifier hostnameVerifier, boolean tlsTolerant) throws IOException {
-        if (spdyConnection != null || sslOutputStream != null || sslInputStream != null) {
-            throw new IllegalStateException();
+    private void upgradeToTls(boolean tlsTolerant, TunnelConfig tunnelConfig) throws IOException {
+        // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+        if (address.requiresTunnel()) {
+            makeTunnel(tunnelConfig);
         }
 
         // Create the wrapper over connected socket.
-        sslSocket = (SSLSocket) sslSocketFactory.createSocket(socket,
-                address.uriHost, address.uriPort, true /* autoClose */);
+        socket = address.sslSocketFactory.createSocket(
+                socket, address.uriHost, address.uriPort, true /* autoClose */);
+        SSLSocket sslSocket = (SSLSocket) socket;
         Libcore.makeTlsTolerant(sslSocket, address.uriHost, tlsTolerant);
 
         if (tlsTolerant) {
@@ -210,40 +242,38 @@ public SSLSocket setupSecureSocket(SSLSocketFactory sslSocketFactory,
         sslSocket.startHandshake();
 
         // Verify that the socket's certificates are acceptable for the target host.
-        if (!hostnameVerifier.verify(address.uriHost, sslSocket.getSession())) {
+        if (!address.hostnameVerifier.verify(address.uriHost, sslSocket.getSession())) {
             throw new IOException(""Hostname '"" + address.uriHost + ""' was not verified"");
         }
 
-        /*
-         * Buffer the input to mask SSL InputStream's degenerate available()
-         * implementation. That way we can read the end of a chunked response
-         * without blocking and will recycle the connection more reliably.
-         * http://code.google.com/p/android/issues/detail?id=38817
-         */
-        sslOutputStream = sslSocket.getOutputStream();
-        sslInputStream = new BufferedInputStream(sslSocket.getInputStream(), 128);
+        out = sslSocket.getOutputStream();
+        in = sslSocket.getInputStream();
 
         byte[] selectedProtocol;
         if (tlsTolerant
                 && (selectedProtocol = Libcore.getNpnSelectedProtocol(sslSocket)) != null) {
             if (Arrays.equals(selectedProtocol, SPDY2)) {
-                spdyConnection = new SpdyConnection.Builder(
-                        true, sslInputStream, sslOutputStream).build();
+                spdyConnection = new SpdyConnection.Builder(true, in, out).build();
                 HttpConnectionPool.INSTANCE.share(this);
             } else if (!Arrays.equals(selectedProtocol, HTTP_11)) {
                 throw new IOException(""Unexpected NPN transport ""
                         + new String(selectedProtocol, ""ISO-8859-1""));
             }
         }
+    }
 
-        return sslSocket;
+    public void closeSocketAndStreams() {
+        IoUtils.closeQuietly(out);
+        IoUtils.closeQuietly(in);
+        IoUtils.closeQuietly(socket);
     }
 
-    /**
-     * Return an {@code SSLSocket} if already connected, otherwise null.
-     */
-    public SSLSocket getSecureSocketIfConnected() {
-        return sslSocket;
+    public Socket getSocket() {
+        return socket;
+    }
+
+    public Address getAddress() {
+        return address;
     }
 
     /**
@@ -274,10 +304,8 @@ protected boolean isEligibleForRecycling() {
     public Transport newTransport(HttpEngine httpEngine) throws IOException {
         if (spdyConnection != null) {
             return new SpdyTransport(httpEngine, spdyConnection);
-        } else if (sslSocket != null) {
-            return new HttpTransport(httpEngine, sslOutputStream, sslInputStream);
         } else {
-            return new HttpTransport(httpEngine, outputStream, inputStream);
+            return new HttpTransport(httpEngine, out, in);
         }
     }
 
@@ -289,6 +317,76 @@ public boolean isSpdy() {
         return spdyConnection != null;
     }
 
+    public static final class TunnelConfig {
+        private final URL url;
+        private final String host;
+        private final String userAgent;
+        private final String proxyAuthorization;
+
+        public TunnelConfig(URL url, String host, String userAgent, String proxyAuthorization) {
+            if (url == null || host == null || userAgent == null) throw new NullPointerException();
+            this.url = url;
+            this.host = host;
+            this.userAgent = userAgent;
+            this.proxyAuthorization = proxyAuthorization;
+        }
+
+        /**
+         * If we're establishing an HTTPS tunnel with CONNECT (RFC 2817 5.2), send
+         * only the minimum set of headers. This avoids sending potentially
+         * sensitive data like HTTP cookies to the proxy unencrypted.
+         */
+        RawHeaders getRequestHeaders() {
+            RawHeaders result = new RawHeaders();
+            result.setRequestLine(""CONNECT "" + url.getHost() + "":""
+                    + Libcore.getEffectivePort(url) + "" HTTP/1.1"");
+
+            // Always set Host and User-Agent.
+            result.set(""Host"", host);
+            result.set(""User-Agent"", userAgent);
+
+            // Copy over the Proxy-Authorization header if it exists.
+            if (proxyAuthorization != null) {
+                result.set(""Proxy-Authorization"", proxyAuthorization);
+            }
+
+            // Always set the Proxy-Connection to Keep-Alive for the benefit of
+            // HTTP/1.0 proxies like Squid.
+            result.set(""Proxy-Connection"", ""Keep-Alive"");
+            return result;
+        }
+    }
+
+    /**
+     * To make an HTTPS connection over an HTTP proxy, send an unencrypted
+     * CONNECT request to create the proxy connection. This may need to be
+     * retried if the proxy requires authorization.
+     */
+    private void makeTunnel(TunnelConfig tunnelConfig) throws IOException {
+        RawHeaders requestHeaders = tunnelConfig.getRequestHeaders();
+        while (true) {
+            out.write(requestHeaders.toBytes());
+            RawHeaders responseHeaders = RawHeaders.fromBytes(in);
+
+            switch (responseHeaders.getResponseCode()) {
+            case HTTP_OK:
+                return;
+            case HTTP_PROXY_AUTH:
+                requestHeaders = new RawHeaders(requestHeaders);
+                boolean credentialsFound = HttpAuthenticator.processAuthHeader(HTTP_PROXY_AUTH,
+                        responseHeaders, requestHeaders, address.proxy, tunnelConfig.url);
+                if (credentialsFound) {
+                    continue;
+                } else {
+                    throw new IOException(""Failed to authenticate with proxy"");
+                }
+            default:
+                throw new IOException(""Unexpected response code for CONNECT: ""
+                        + responseHeaders.getResponseCode());
+            }
+        }
+    }
+
     /**
      * This address has two parts: the address we connect to directly and the
      * origin address of the resource. These are the same unless a proxy is
@@ -302,25 +400,29 @@ public static final class Address {
         private final String socketHost;
         private final int socketPort;
         private final SSLSocketFactory sslSocketFactory;
+        private final HostnameVerifier hostnameVerifier;
 
-        public Address(URI uri, SSLSocketFactory sslSocketFactory) throws UnknownHostException {
+        public Address(URI uri, SSLSocketFactory sslSocketFactory,
+                HostnameVerifier hostnameVerifier) throws UnknownHostException {
             this.proxy = null;
             this.uriHost = uri.getHost();
             this.uriPort = Libcore.getEffectivePort(uri);
             this.sslSocketFactory = sslSocketFactory;
+            this.hostnameVerifier = hostnameVerifier;
             this.socketHost = uriHost;
             this.socketPort = uriPort;
             if (uriHost == null) {
                 throw new UnknownHostException(uri.toString());
             }
         }
 
-        public Address(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy)
-                throws UnknownHostException {
+        public Address(URI uri, SSLSocketFactory sslSocketFactory,
+                HostnameVerifier hostnameVerifier, Proxy proxy) throws UnknownHostException {
             this.proxy = proxy;
             this.uriHost = uri.getHost();
             this.uriPort = Libcore.getEffectivePort(uri);
             this.sslSocketFactory = sslSocketFactory;
+            this.hostnameVerifier = hostnameVerifier;
 
             SocketAddress proxyAddress = proxy.address();
             if (!(proxyAddress instanceof InetSocketAddress)) {
@@ -345,7 +447,8 @@ public Proxy getProxy() {
                 return Objects.equal(this.proxy, that.proxy)
                         && this.uriHost.equals(that.uriHost)
                         && this.uriPort == that.uriPort
-                        && Objects.equal(this.sslSocketFactory, that.sslSocketFactory);
+                        && Objects.equal(this.sslSocketFactory, that.sslSocketFactory)
+                        && Objects.equal(this.hostnameVerifier, that.hostnameVerifier);
             }
             return false;
         }
@@ -355,14 +458,11 @@ public Proxy getProxy() {
             result = 31 * result + uriHost.hashCode();
             result = 31 * result + uriPort;
             result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
+            result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
             result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
             return result;
         }
 
-        public HttpConnection connect(int connectTimeout) throws IOException {
-            return new HttpConnection(this, connectTimeout);
-        }
-
         /**
          * Returns true if the HTTP connection needs to tunnel one protocol over
          * another, such as when using HTTPS through an HTTP proxy. When doing so,
@@ -17,7 +17,6 @@
 
 package libcore.net.http;
 
-import java.io.IOException;
 import java.net.Socket;
 import java.net.SocketException;
 import java.util.ArrayList;
@@ -59,8 +58,7 @@ private HttpConnectionPool() {
                 : 5;
     }
 
-    public HttpConnection get(HttpConnection.Address address, int connectTimeout)
-            throws IOException {
+    public HttpConnection get(HttpConnection.Address address) {
         // First try to reuse an existing HTTP connection.
         synchronized (connectionPool) {
             List<HttpConnection> connections = connectionPool.get(address);
@@ -81,12 +79,7 @@ public HttpConnection get(HttpConnection.Address address, int connectTimeout)
                 }
             }
         }
-
-        /*
-         * We couldn't find a reusable connection, so we need to create a new
-         * connection. We're careful not to do so while holding a lock!
-         */
-        return address.connect(connectTimeout);
+        return null;
     }
 
     /**
@@ -36,6 +36,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.zip.GZIPInputStream;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 import libcore.io.IoUtils;
 import libcore.util.EmptyArray;
@@ -86,7 +87,6 @@ public class HttpEngine {
     public static final String PUT = ""PUT"";
     public static final String DELETE = ""DELETE"";
     public static final String TRACE = ""TRACE"";
-    public static final String CONNECT = ""CONNECT"";
 
     public static final int HTTP_CONTINUE = 100;
 
@@ -274,22 +274,18 @@ private void sendSocketRequest() throws IOException {
      * Connect to the origin server either directly or via a proxy.
      */
     protected void connect() throws IOException {
-        if (connection == null) {
-            connection = openSocketConnection();
+        if (connection != null) {
+            return;
         }
-    }
-
-    protected final HttpConnection openSocketConnection() throws IOException {
-        HttpConnection result = HttpConnection.connect(uri, getSslSocketFactory(),
-                policy.getProxy(), policy.getConnectTimeout());
-        Proxy proxy = result.getAddress().getProxy();
+        connection = HttpConnection.connect(uri, getSslSocketFactory(), getHostnameVerifier(),
+                policy.getProxy(), policy.getConnectTimeout(), policy.getReadTimeout(),
+                getTunnelConfig());
+        Proxy proxy = connection.getAddress().getProxy();
         if (proxy != null) {
             policy.setProxy(proxy);
             // Add the authority to the request line when we're using a proxy.
             requestHeaders.getHeaders().setRequestLine(getRequestLine());
         }
-        result.setSoTimeout(policy.getReadTimeout());
-        return result;
     }
 
     /**
@@ -371,11 +367,6 @@ protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
     }
 
     private void maybeCache() throws IOException {
-        // Never cache responses to proxy CONNECT requests.
-        if (method == CONNECT) {
-            return;
-        }
-
         // Are we caching at all?
         if (!policy.getUseCaches() || responseCache == null) {
             return;
@@ -458,8 +449,7 @@ public final boolean hasResponseBody() {
             return false;
         }
 
-        if (method != CONNECT
-                && (responseCode < HTTP_CONTINUE || responseCode >= 200)
+        if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
                 && responseCode != HttpURLConnectionImpl.HTTP_NO_CONTENT
                 && responseCode != HttpURLConnectionImpl.HTTP_NOT_MODIFIED) {
             return true;
@@ -569,15 +559,23 @@ protected SSLSocketFactory getSslSocketFactory() {
         return null;
     }
 
-    protected final String getDefaultUserAgent() {
+    /**
+     * Returns the hostname verifier for connections created by this engine. We
+     * cannot reuse HTTPS connections if the hostname verifier has changed.
+     */
+    protected HostnameVerifier getHostnameVerifier() {
+        return null;
+    }
+
+    public static final String getDefaultUserAgent() {
         String agent = System.getProperty(""http.agent"");
         return agent != null ? agent : (""Java"" + System.getProperty(""java.version""));
     }
 
-    protected final String getOriginAddress(URL url) {
+    public static String getOriginAddress(URL url) {
         int port = url.getPort();
         String result = url.getHost();
-        if (port > 0 && port != policy.getDefaultPort()) {
+        if (port > 0 && port != Libcore.getDefaultPort(url.getProtocol())) {
             result = result + "":"" + port;
         }
         return result;
@@ -642,4 +640,8 @@ public final void readResponse() throws IOException {
 
         initContentStream(transport.getTransferStream(cacheRequest));
     }
+
+    protected HttpConnection.TunnelConfig getTunnelConfig() {
+        return null;
+    }
 }
@@ -23,7 +23,6 @@
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.CookieHandler;
-import java.net.URL;
 import libcore.io.Streams;
 import libcore.util.Libcore;
 
@@ -124,8 +123,8 @@ public void writeRequestHeaders() throws IOException {
         httpEngine.sentRequestMillis = System.currentTimeMillis();
 
         int contentLength = httpEngine.requestHeaders.getContentLength();
-        RawHeaders headersToSend = getNetworkRequestHeaders();
-        byte[] bytes = headersToSend.toRequestHeader().getBytes(""ISO-8859-1"");
+        RawHeaders headersToSend = httpEngine.requestHeaders.getHeaders();
+        byte[] bytes = headersToSend.toBytes();
 
         if (contentLength != -1 && bytes.length + contentLength <= MAX_REQUEST_BUFFER_LENGTH) {
             requestOut = new BufferedOutputStream(socketOut, bytes.length + contentLength);
@@ -134,71 +133,14 @@ public void writeRequestHeaders() throws IOException {
         requestOut.write(bytes);
     }
 
-    private RawHeaders getNetworkRequestHeaders() {
-        return httpEngine.method == HttpEngine.CONNECT
-                ? getTunnelNetworkRequestHeaders()
-                : httpEngine.requestHeaders.getHeaders();
-    }
-
-    /**
-     * If we're establishing an HTTPS tunnel with CONNECT (RFC 2817 5.2), send
-     * only the minimum set of headers. This avoids sending potentially
-     * sensitive data like HTTP cookies to the proxy unencrypted.
-     */
-    private RawHeaders getTunnelNetworkRequestHeaders() {
-        RequestHeaders privateHeaders = httpEngine.requestHeaders;
-        URL url = httpEngine.policy.getURL();
-
-        RawHeaders result = new RawHeaders();
-        result.setRequestLine(""CONNECT "" + url.getHost() + "":"" + Libcore.getEffectivePort(url)
-                + "" HTTP/1.1"");
-
-        // Always set Host and User-Agent.
-        String host = privateHeaders.getHost();
-        if (host == null) {
-            host = httpEngine.getOriginAddress(url);
-        }
-        result.set(""Host"", host);
-
-        String userAgent = privateHeaders.getUserAgent();
-        if (userAgent == null) {
-            userAgent = httpEngine.getDefaultUserAgent();
-        }
-        result.set(""User-Agent"", userAgent);
-
-        // Copy over the Proxy-Authorization header if it exists.
-        String proxyAuthorization = privateHeaders.getProxyAuthorization();
-        if (proxyAuthorization != null) {
-            result.set(""Proxy-Authorization"", proxyAuthorization);
-        }
-
-        // Always set the Proxy-Connection to Keep-Alive for the benefit of
-        // HTTP/1.0 proxies like Squid.
-        result.set(""Proxy-Connection"", ""Keep-Alive"");
-        return result;
-    }
-
     @Override public ResponseHeaders readResponseHeaders() throws IOException {
-        RawHeaders headers;
-        do {
-            headers = new RawHeaders();
-            headers.setStatusLine(Streams.readAsciiLine(socketIn));
-            httpEngine.connection.httpMinorVersion = headers.getHttpMinorVersion();
-            readHeaders(headers);
-        } while (headers.getResponseCode() == HttpEngine.HTTP_CONTINUE);
+        RawHeaders headers = RawHeaders.fromBytes(socketIn);
+        httpEngine.connection.httpMinorVersion = headers.getHttpMinorVersion();
+        receiveHeaders(headers);
         return new ResponseHeaders(httpEngine.uri, headers);
     }
 
-    /**
-     * Reads headers or trailers and updates the cookie store.
-     */
-    private void readHeaders(RawHeaders headers) throws IOException {
-        // parse the result headers until the first blank line
-        String line;
-        while ((line = Streams.readAsciiLine(socketIn)).length() != 0) {
-            headers.addLine(line);
-        }
-
+    private void receiveHeaders(RawHeaders headers) throws IOException {
         CookieHandler cookieHandler = CookieHandler.getDefault();
         if (cookieHandler != null) {
             cookieHandler.put(httpEngine.uri, headers.toMultimap(true));
@@ -211,11 +153,8 @@ public boolean makeReusable(OutputStream requestBodyOut, InputStream responseBod
             return false;
         }
 
-        // If the request specified that the connection shouldn't be reused,
-        // don't reuse it. This advice doesn't apply to CONNECT requests because
-        // the ""Connection: close"" header goes the origin server, not the proxy.
-        if (httpEngine.requestHeaders.hasConnectionClose()
-                && httpEngine.method != HttpEngine.CONNECT) {
+        // If the request specified that the connection shouldn't be reused, don't reuse it.
+        if (httpEngine.requestHeaders.hasConnectionClose()) {
             return false;
         }
 
@@ -531,7 +470,9 @@ private void readChunkSize() throws IOException {
             }
             if (bytesRemainingInChunk == 0) {
                 hasMoreChunks = false;
-                transport.readHeaders(httpEngine.responseHeaders.getHeaders());
+                RawHeaders rawResponseHeaders = httpEngine.responseHeaders.getHeaders();
+                RawHeaders.readHeaders(transport.socketIn, rawResponseHeaders);
+                transport.receiveHeaders(rawResponseHeaders);
                 endOfInput(true);
             }
         }
@@ -22,19 +22,15 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.Authenticator;
 import java.net.HttpRetryException;
-import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
 import java.security.Permission;
 import java.util.List;
 import java.util.Map;
-import libcore.io.Base64;
 import libcore.io.IoUtils;
 import libcore.util.Libcore;
 
@@ -367,8 +363,8 @@ private Retry processResponseHeaders() throws IOException {
             }
             // fall-through
         case HTTP_UNAUTHORIZED:
-            boolean credentialsFound = processAuthHeader(getResponseCode(),
-                    httpEngine.getResponseHeaders(), rawRequestHeaders);
+            boolean credentialsFound = HttpAuthenticator.processAuthHeader(getResponseCode(),
+                    httpEngine.getResponseHeaders().getHeaders(), rawRequestHeaders, proxy, url);
             return credentialsFound ? Retry.SAME_CONNECTION : Retry.NONE;
 
         case HTTP_MULT_CHOICE:
@@ -402,81 +398,6 @@ private Retry processResponseHeaders() throws IOException {
         }
     }
 
-    /**
-     * React to a failed authorization response by looking up new credentials.
-     *
-     * @return true if credentials have been added to successorRequestHeaders
-     *     and another request should be attempted.
-     */
-    final boolean processAuthHeader(int responseCode, ResponseHeaders response,
-            RawHeaders successorRequestHeaders) throws IOException {
-        if (responseCode != HTTP_PROXY_AUTH && responseCode != HTTP_UNAUTHORIZED) {
-            throw new IllegalArgumentException();
-        }
-
-        // keep asking for username/password until authorized
-        String challengeHeader = responseCode == HTTP_PROXY_AUTH
-                ? ""Proxy-Authenticate""
-                : ""WWW-Authenticate"";
-        String credentials = getAuthorizationCredentials(response.getHeaders(), challengeHeader);
-        if (credentials == null) {
-            return false; // could not find credentials, end request cycle
-        }
-
-        // add authorization credentials, bypassing the already-connected check
-        String fieldName = responseCode == HTTP_PROXY_AUTH
-                ? ""Proxy-Authorization""
-                : ""Authorization"";
-        successorRequestHeaders.set(fieldName, credentials);
-        return true;
-    }
-
-    /**
-     * Returns the authorization credentials that may satisfy the challenge.
-     * Returns null if a challenge header was not provided or if credentials
-     * were not available.
-     */
-    private String getAuthorizationCredentials(RawHeaders responseHeaders, String challengeHeader)
-            throws IOException {
-        List<Challenge> challenges = HeaderParser.parseChallenges(responseHeaders, challengeHeader);
-        if (challenges.isEmpty()) {
-            return null;
-        }
-
-        for (Challenge challenge : challenges) {
-            // use the global authenticator to get the password
-            PasswordAuthentication auth;
-            if (responseHeaders.getResponseCode() == HTTP_PROXY_AUTH) {
-                InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-                auth = Authenticator.requestPasswordAuthentication(
-                        proxyAddress.getHostName(), getConnectToInetAddress(),
-                        proxyAddress.getPort(), url.getProtocol(), challenge.realm,
-                        challenge.scheme, url, Authenticator.RequestorType.PROXY);
-            } else {
-                auth = Authenticator.requestPasswordAuthentication(
-                        url.getHost(), getConnectToInetAddress(), url.getPort(), url.getProtocol(),
-                        challenge.realm, challenge.scheme, url, Authenticator.RequestorType.SERVER);
-            }
-            if (auth == null) {
-                continue;
-            }
-
-            // base64 encode the username and password
-            String usernameAndPassword = auth.getUserName() + "":"" + new String(auth.getPassword());
-            byte[] bytes = usernameAndPassword.getBytes(""ISO-8859-1"");
-            String encoded = Base64.encode(bytes);
-            return challenge.scheme + "" "" + encoded;
-        }
-
-        return null;
-    }
-
-    private InetAddress getConnectToInetAddress() throws IOException {
-        return usingProxy()
-                ? ((InetSocketAddress) proxy.address()).getAddress()
-                : InetAddress.getByName(getURL().getHost());
-    }
-
     final int getDefaultPort() {
         return defaultPort;
     }
@@ -29,10 +29,9 @@
 import java.security.Permission;
 import java.security.Principal;
 import java.security.cert.Certificate;
-import java.security.cert.CertificateException;
 import java.util.List;
 import java.util.Map;
-import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
@@ -419,87 +418,10 @@ private HttpsEngine(HttpURLConnectionImpl policy, String method, RawHeaders requ
                 HttpConnection connection, RetryableOutputStream requestBody,
                 HttpsURLConnectionImpl enclosing) throws IOException {
             super(policy, method, requestHeaders, connection, requestBody);
-            this.sslSocket = connection != null ? connection.getSecureSocketIfConnected() : null;
+            this.sslSocket = connection != null ? (SSLSocket) connection.getSocket() : null;
             this.enclosing = enclosing;
         }
 
-        @Override protected void connect() throws IOException {
-            // First try an SSL connection with compression and various TLS
-            // extensions enabled, if it fails (and its not unheard of that it
-            // will) fallback to a barebones connection.
-            try {
-                makeSslConnection(true);
-            } catch (IOException e) {
-                // If the problem was a CertificateException from the X509TrustManager,
-                // do not retry, we didn't have an abrupt server initiated exception.
-                if (e instanceof SSLHandshakeException
-                        && e.getCause() instanceof CertificateException) {
-                    throw e;
-                }
-                release(false);
-                makeSslConnection(false);
-            }
-        }
-
-        /**
-         * Attempt to make an HTTPS connection.
-         *
-         * @param tlsTolerant If true, assume server can handle common
-         * TLS extensions and SSL deflate compression. If false, use
-         * an SSL3 only fallback mode without compression.
-         */
-        private void makeSslConnection(boolean tlsTolerant) throws IOException {
-            // Get a connection. This may return a pooled connection!
-            if (connection == null) {
-                connection = openSocketConnection();
-            }
-            sslSocket = connection.getSecureSocketIfConnected();
-
-            // If the TLS connection is ready, use it.
-            if (sslSocket != null) {
-                return;
-            }
-
-            // The TLS connection isn't ready. Build a tunnel if necessary and then handshake.
-            if (connection.getAddress().requiresTunnel()) {
-                makeTunnel(policy, connection, getRequestHeaders());
-            }
-            sslSocket = connection.setupSecureSocket(
-                    enclosing.getSSLSocketFactory(), enclosing.getHostnameVerifier(), tlsTolerant);
-        }
-
-        /**
-         * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-         * CONNECT request to create the proxy connection. This may need to be
-         * retried if the proxy requires authorization.
-         */
-        private void makeTunnel(HttpURLConnectionImpl policy, HttpConnection connection,
-                RequestHeaders requestHeaders) throws IOException {
-            RawHeaders rawRequestHeaders = requestHeaders.getHeaders();
-            while (true) {
-                HttpEngine connect = new ProxyConnectEngine(policy, rawRequestHeaders, connection);
-                connect.sendRequest();
-                connect.readResponse();
-
-                int responseCode = connect.getResponseCode();
-                switch (connect.getResponseCode()) {
-                case HTTP_OK:
-                    return;
-                case HTTP_PROXY_AUTH:
-                    rawRequestHeaders = new RawHeaders(rawRequestHeaders);
-                    boolean credentialsFound = policy.processAuthHeader(HTTP_PROXY_AUTH,
-                            connect.getResponseHeaders(), rawRequestHeaders);
-                    if (credentialsFound) {
-                        continue;
-                    } else {
-                        throw new IOException(""Failed to authenticate with proxy"");
-                    }
-                default:
-                    throw new IOException(""Unexpected response code for CONNECT: "" + responseCode);
-                }
-            }
-        }
-
         @Override protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
             return cacheResponse instanceof SecureCacheResponse;
         }
@@ -513,15 +435,28 @@ private void makeTunnel(HttpURLConnectionImpl policy, HttpConnection connection,
             return enclosing.getSSLSocketFactory();
         }
 
+        @Override protected HostnameVerifier getHostnameVerifier() {
+            return enclosing.getHostnameVerifier();
+        }
+
         @Override protected OkHttpConnection getHttpConnectionToCache() {
             return enclosing;
         }
-    }
 
-    private static class ProxyConnectEngine extends HttpEngine {
-        public ProxyConnectEngine(HttpURLConnectionImpl policy, RawHeaders requestHeaders,
-                HttpConnection connection) throws IOException {
-            super(policy, HttpEngine.CONNECT, requestHeaders, connection, null);
+        @Override protected HttpConnection.TunnelConfig getTunnelConfig() {
+            String host = requestHeaders.getHost();
+            if (host == null) {
+                host = HttpEngine.getOriginAddress(policy.getURL());
+            }
+
+            String userAgent = requestHeaders.getUserAgent();
+            if (userAgent == null) {
+                userAgent = HttpEngine.getDefaultUserAgent();
+            }
+
+            String proxyAuthorization = requestHeaders.getProxyAuthorization();
+            return new HttpConnection.TunnelConfig(
+                    policy.getURL(), host, userAgent, proxyAuthorization);
         }
     }
 }
@@ -18,6 +18,8 @@
 package libcore.net.http;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -28,6 +30,7 @@
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.TreeMap;
+import libcore.io.Streams;
 import libcore.util.Libcore;
 
 /**
@@ -74,6 +77,7 @@ public RawHeaders() {
 
     public RawHeaders(RawHeaders copyFrom) {
         namesAndValues.addAll(copyFrom.namesAndValues);
+        requestLine = copyFrom.requestLine;
         statusLine = copyFrom.statusLine;
         httpMinorVersion = copyFrom.httpMinorVersion;
         responseCode = copyFrom.responseCode;
@@ -284,15 +288,42 @@ public RawHeaders getAll(Set<String> fieldNames) {
         return result;
     }
 
-    public String toRequestHeader() {
+    /**
+     * Returns bytes of a request header for sending on an HTTP transport.
+     */
+    public byte[] toBytes() throws UnsupportedEncodingException {
         StringBuilder result = new StringBuilder(256);
         result.append(requestLine).append(""\r\n"");
         for (int i = 0; i < namesAndValues.size(); i += 2) {
             result.append(namesAndValues.get(i)).append("": "")
                     .append(namesAndValues.get(i + 1)).append(""\r\n"");
         }
         result.append(""\r\n"");
-        return result.toString();
+        return result.toString().getBytes(""ISO-8859-1"");
+    }
+
+    /**
+     * Parses bytes of a response header from an HTTP transport.
+     */
+    public static RawHeaders fromBytes(InputStream in) throws IOException {
+        RawHeaders headers;
+        do {
+            headers = new RawHeaders();
+            headers.setStatusLine(Streams.readAsciiLine(in));
+            readHeaders(in, headers);
+        } while (headers.getResponseCode() == HttpEngine.HTTP_CONTINUE);
+        return headers;
+    }
+
+    /**
+     * Reads headers or trailers into {@code out}.
+     */
+    public static void readHeaders(InputStream in, RawHeaders out) throws IOException {
+        // parse the result headers until the first blank line
+        String line;
+        while ((line = Streams.readAsciiLine(in)).length() != 0) {
+            out.addLine(line);
+        }
     }
 
     /**
@@ -197,10 +197,12 @@ public static int getEffectivePort(URL url) {
     }
 
     private static int getEffectivePort(String scheme, int specifiedPort) {
-        if (specifiedPort != -1) {
-            return specifiedPort;
-        }
+        return specifiedPort != -1
+                ? specifiedPort
+                : getDefaultPort(scheme);
+    }
 
+    public static int getDefaultPort(String scheme) {
         if (""http"".equalsIgnoreCase(scheme)) {
             return 80;
         } else if (""https"".equalsIgnoreCase(scheme)) {
@@ -20,6 +20,10 @@
 import com.google.mockwebserver.MockWebServer;
 import com.google.mockwebserver.RecordedRequest;
 import com.google.mockwebserver.SocketPolicy;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import com.squareup.okhttp.OkHttpConnection;
 import com.squareup.okhttp.OkHttpsConnection;
 import java.io.ByteArrayOutputStream;
@@ -69,11 +73,6 @@
 import junit.framework.TestCase;
 import libcore.net.ssl.SslContextBuilder;
 
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-
 /**
  * Android's URLConnectionTest.
  */
@@ -478,15 +477,16 @@ public void testConnectViaHttpsReusingConnections() throws IOException, Interrup
 
         // The pool will only reuse sockets if the SSL socket factories are the same.
         SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
+        RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
         OkHttpsConnection connection = (OkHttpsConnection) openConnection(server.getUrl(""/""));
         connection.setSSLSocketFactory(clientSocketFactory);
-        connection.setHostnameVerifier(new RecordingHostnameVerifier());
+        connection.setHostnameVerifier(hostnameVerifier);
         assertContent(""this response comes via HTTPS"", connection);
 
         connection = (OkHttpsConnection) openConnection(server.getUrl(""/""));
         connection.setSSLSocketFactory(clientSocketFactory);
-        connection.setHostnameVerifier(new RecordingHostnameVerifier());
+        connection.setHostnameVerifier(hostnameVerifier);
         assertContent(""another response via HTTPS"", connection);
 
         assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -516,7 +516,7 @@ public void testConnectViaHttpsReusingConnectionsDifferentFactories()
 
     public void testConnectViaHttpsWithSSLFallback() throws IOException, InterruptedException {
         server.useHttps(sslContext.getSocketFactory(), false);
-        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
         server.enqueue(new MockResponse().setBody(""this response comes via SSL""));
         server.play();
 
"
https://github.com/apache/dubbo/commit/3308a197751eeb97baddf157f53813a3447d159f,fix typo:metodName ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/3308a197751eeb97baddf157f53813a3447d159f,"@@ -54,7 +54,6 @@ public ConsumerModel(String serviceKey
             , ReferenceConfigBase<?> referenceConfig) {
 
         Assert.notEmptyString(serviceKey, ""Service name can't be null or blank"");
-//        Assert.notNull(proxyObject, ""Proxy object can't be null"");
 
         this.serviceKey = serviceKey;
         this.proxyObject = proxyObject;
@@ -172,7 +171,7 @@ public ConsumerMethodModel getMethodModel(String method) {
     }
 
     /**
-     * @param method   metodName
+     * @param method   methodName
      * @param argsType method arguments type
      * @return
      */
"
https://github.com/spring-projects/spring-boot/commit/49ef93602e4db89944a5897fb250121186161d2c,Add external-file-property to LogFileMvcEndpoint  <enter> Add an additional property to LogFileMvcEndpoint to allow log files to be read from an external location. This is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr. <enter>  Fixes   <issue_link>   Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/49ef93602e4db89944a5897fb250121186161d2c,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2015 the original author or authors.
+ * Copyright 2012-2016 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -40,6 +40,7 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
+import org.springframework.boot.bind.RelaxedPropertyResolver;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.ConditionContext;
@@ -180,6 +181,12 @@ public ConditionOutcome getMatchOutcome(ConditionContext context,
 			if (StringUtils.hasText(config)) {
 				return ConditionOutcome.match(""Found logging.path: "" + config);
 			}
+			config = new RelaxedPropertyResolver(environment, ""endpoints.logfile."")
+					.getProperty(""external-file"");
+			if (StringUtils.hasText(config)) {
+				return ConditionOutcome
+						.match(""Found endpoints.logfile.external-file: "" + config);
+			}
 			return ConditionOutcome.noMatch(""Found no log file configuration"");
 		}
 
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.actuate.endpoint.mvc;
 
+import java.io.File;
 import java.io.IOException;
 
 import javax.servlet.ServletException;
@@ -72,6 +73,12 @@ public class LogFileMvcEndpoint implements MvcEndpoint, EnvironmentAware {
 	 */
 	private Boolean sensitive;
 
+	/**
+	 * External Logfile to be accessed. Can be used if the logfile is written by output
+	 * redirect and not by the logging-system itself.
+	 */
+	private File externalFile;
+
 	private Environment environment;
 
 	@Override
@@ -105,6 +112,14 @@ public void setSensitive(Boolean sensitive) {
 		this.sensitive = sensitive;
 	}
 
+	public File getExternalFile() {
+		return this.externalFile;
+	}
+
+	public void setExternalFile(File externalFile) {
+		this.externalFile = externalFile;
+	}
+
 	@Override
 	@SuppressWarnings(""rawtypes"")
 	public Class<? extends Endpoint> getEndpointType() {
@@ -119,23 +134,25 @@ public void invoke(HttpServletRequest request, HttpServletResponse response)
 			return;
 		}
 		Resource resource = getLogFileResource();
+		if (resource != null && !resource.exists()) {
+			if (logger.isDebugEnabled()) {
+				logger.debug(""Log file '"" + resource + ""' does not exist"");
+			}
+			resource = null;
+		}
 		new Handler(resource).handleRequest(request, response);
 	}
 
 	private Resource getLogFileResource() {
+		if (this.externalFile != null) {
+			return new FileSystemResource(this.externalFile);
+		}
 		LogFile logFile = LogFile.get(this.environment);
 		if (logFile == null) {
 			logger.debug(""Missing 'logging.file' or 'logging.path' properties"");
 			return null;
 		}
-		FileSystemResource resource = new FileSystemResource(logFile.toString());
-		if (!resource.exists()) {
-			if (logger.isDebugEnabled()) {
-				logger.debug(""Log file '"" + resource + ""' does not exist"");
-			}
-			return null;
-		}
-		return resource;
+		return new FileSystemResource(logFile.toString());
 	}
 
 	/**
@@ -110,4 +110,15 @@ public void invokeGetsContent() throws Exception {
 		assertThat(response.getContentAsString()).isEqualTo(""--TEST--"");
 	}
 
+	@Test
+	public void invokeGetsContentExternalFile() throws Exception {
+		this.mvc.setExternalFile(this.logFile);
+		MockHttpServletResponse response = new MockHttpServletResponse();
+		MockHttpServletRequest request = new MockHttpServletRequest(HttpMethod.GET.name(),
+				""/logfile"");
+		this.mvc.invoke(request, response);
+		assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value());
+		assertThat(""--TEST--"").isEqualTo(response.getContentAsString());
+	}
+
 }
"
https://github.com/spring-projects/spring-boot/commit/5b2de5c81dc1cc3ab4e8c21ae615bc4d19567347,"Configure PathPattern for RSocket routing  <enter> This commit configures a `PathPatternRouteMatcher` in the RSocket support if spring-web is on the classpath. This `RouteMatcher` implementation is more efficient than the `SimpleRouteMatcher`, which is based on the `AntPathMatcher`. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/5b2de5c81dc1cc3ab4e8c21ae615bc4d19567347,"@@ -28,6 +28,9 @@
 import org.springframework.messaging.rsocket.MessageHandlerAcceptor;
 import org.springframework.messaging.rsocket.RSocketRequester;
 import org.springframework.messaging.rsocket.RSocketStrategies;
+import org.springframework.util.ClassUtils;
+import org.springframework.web.util.pattern.PathPatternParser;
+import org.springframework.web.util.pattern.PathPatternRouteMatcher;
 
 /**
  * {@link EnableAutoConfiguration Auto-configuration} for Spring RSocket support in Spring
@@ -42,12 +45,19 @@
 @AutoConfigureAfter(RSocketStrategiesAutoConfiguration.class)
 public class RSocketMessagingAutoConfiguration {
 
+	private static String PATHPATTERN_ROUTEMATCHER_CLASS = ""org.springframework.web.util.pattern.PathPatternRouteMatcher"";
+
 	@Bean
 	@ConditionalOnMissingBean
 	public MessageHandlerAcceptor messageHandlerAcceptor(
 			RSocketStrategies rSocketStrategies) {
 		MessageHandlerAcceptor acceptor = new MessageHandlerAcceptor();
 		acceptor.setRSocketStrategies(rSocketStrategies);
+		if (ClassUtils.isPresent(PATHPATTERN_ROUTEMATCHER_CLASS, null)) {
+			PathPatternParser parser = new PathPatternParser();
+			parser.setSeparator('.');
+			acceptor.setRouteMatcher(new PathPatternRouteMatcher(parser));
+		}
 		return acceptor;
 	}
 
@@ -26,6 +26,7 @@
 import org.springframework.core.codec.StringDecoder;
 import org.springframework.messaging.rsocket.MessageHandlerAcceptor;
 import org.springframework.messaging.rsocket.RSocketStrategies;
+import org.springframework.web.util.pattern.PathPatternRouteMatcher;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -43,8 +44,11 @@ public class RSocketMessagingAutoConfigurationTests {
 
 	@Test
 	public void shouldCreateDefaultBeans() {
-		this.contextRunner.run((context) -> assertThat(context)
-				.getBeans(MessageHandlerAcceptor.class).hasSize(1));
+		this.contextRunner.run((context) -> {
+			assertThat(context).getBeans(MessageHandlerAcceptor.class).hasSize(1);
+			assertThat(context.getBean(MessageHandlerAcceptor.class).getRouteMatcher())
+					.isInstanceOf(PathPatternRouteMatcher.class);
+		});
 	}
 
 	@Test
"
https://github.com/junit-team/junit4/commit/d3d7a8b1389e53055d4de9de3aa319053b4a5524,Identify reflection package jdk.internal.reflect  <enter> JDK 9 uses classes from the package jdk.internal.reflect instead of sun.reflect. ,https://api.github.com/repos/junit-team/junit4/commits/d3d7a8b1389e53055d4de9de3aa319053b4a5524,"@@ -247,6 +247,7 @@ private static boolean isTestFrameworkMethod(String methodName) {
     private static final String[] REFLECTION_METHOD_NAME_PREFIXES = {
         ""sun.reflect."",
         ""java.lang.reflect."",
+        ""jdk.internal.reflect."",
         ""org.junit.rules.RunRules.<init>("",
         ""org.junit.rules.RunRules.applyAll("", // calls TestRules
         ""org.junit.runners.RuleContainer.apply("", // calls MethodRules & TestRules
"
https://github.com/spring-projects/spring-boot/commit/644ab5f3e4319610632b60cbbc4f9141f3ba3470,Align SessionsEndpoint with Spring Session API improvements  <enter> This commit aligns SessionsEndpoint with FindByIndexNameSessionRepository API improvements that simplifies retrieval of sessions by principal name. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/644ab5f3e4319610632b60cbbc4f9141f3ba3470,"@@ -89,9 +89,7 @@ public void sessionsForUsername() throws Exception {
 		sessions.put(sessionOne.getId(), sessionOne);
 		sessions.put(sessionTwo.getId(), sessionTwo);
 		sessions.put(sessionThree.getId(), sessionThree);
-		given(this.sessionRepository.findByIndexNameAndIndexValue(
-				FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, ""alice""))
-						.willReturn(sessions);
+		given(this.sessionRepository.findByPrincipalName(""alice"")).willReturn(sessions);
 		this.mockMvc.perform(get(""/actuator/sessions"").param(""username"", ""alice""))
 				.andExpect(status().isOk())
 				.andDo(document(""sessions/username"",
@@ -52,9 +52,7 @@ public SessionsEndpoint(
 	@ReadOperation
 	public SessionsReport sessionsForUsername(String username) {
 		Map<String, ? extends Session> sessions = this.sessionRepository
-				.findByIndexNameAndIndexValue(
-						FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME,
-						username);
+				.findByPrincipalName(username);
 		return new SessionsReport(sessions);
 	}
 
@@ -48,9 +48,8 @@ public class SessionsEndpointTests {
 
 	@Test
 	public void sessionsForUsername() {
-		given(this.repository.findByIndexNameAndIndexValue(
-				FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, ""user""))
-						.willReturn(Collections.singletonMap(session.getId(), session));
+		given(this.repository.findByPrincipalName(""user""))
+				.willReturn(Collections.singletonMap(session.getId(), session));
 		List<SessionDescriptor> result = this.endpoint.sessionsForUsername(""user"")
 				.getSessions();
 		assertThat(result).hasSize(1);
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -58,9 +58,7 @@ public void sessionsForUsernameWithoutUsernameParam() {
 
 	@Test
 	public void sessionsForUsernameNoResults() {
-		given(repository.findByIndexNameAndIndexValue(
-				FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, ""user""))
-						.willReturn(Collections.emptyMap());
+		given(repository.findByPrincipalName(""user"")).willReturn(Collections.emptyMap());
 		client.get()
 				.uri((builder) -> builder.path(""/actuator/sessions"")
 						.queryParam(""username"", ""user"").build())
@@ -70,9 +68,8 @@ public void sessionsForUsernameNoResults() {
 
 	@Test
 	public void sessionsForUsernameFound() {
-		given(repository.findByIndexNameAndIndexValue(
-				FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, ""user""))
-						.willReturn(Collections.singletonMap(session.getId(), session));
+		given(repository.findByPrincipalName(""user""))
+				.willReturn(Collections.singletonMap(session.getId(), session));
 		client.get()
 				.uri((builder) -> builder.path(""/actuator/sessions"")
 						.queryParam(""username"", ""user"").build())
"
https://github.com/apache/dubbo/commit/a5cc7a26179aab97b3bee3fcc93fe90ac0ecb29f,reduce the level of request data in timeout log ( <pr_link> )  <enter> to control the size of log ,https://api.github.com/repos/apache/dubbo/commits/a5cc7a26179aab97b3bee3fcc93fe90ac0ecb29f,"@@ -225,10 +225,16 @@ private String getTimeoutMessage(boolean scan) {
                 + (sent > 0 ? "" client elapsed: "" + (sent - start)
                 + "" ms, server elapsed: "" + (nowTimestamp - sent)
                 : "" elapsed: "" + (nowTimestamp - start)) + "" ms, timeout: ""
-                + timeout + "" ms, request: "" + request + "", channel: "" + channel.getLocalAddress()
+                + timeout + "" ms, request: "" + (logger.isDebugEnabled() ? request : getRequestWithoutData()) + "", channel: "" + channel.getLocalAddress()
                 + "" -> "" + channel.getRemoteAddress();
     }
 
+    private Request getRequestWithoutData() {
+        Request newRequest = request;
+        newRequest.setData(null);
+        return newRequest;
+    }
+
     private static class TimeoutCheckTask implements TimerTask {
 
         private final Long requestID;
"
https://github.com/apache/dubbo/commit/9396ace4fc00ca8f2e331b49ddabcb1e138e9e1c,fix typo ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/9396ace4fc00ca8f2e331b49ddabcb1e138e9e1c,"@@ -75,39 +75,39 @@ public void setUp() {
     @Test
     public void testRegister() {
         dubboRegistry.register(serviceURL);
-        assertEquals(1, getRegistereds());
+        assertEquals(1, getRegisteredSize());
     }
 
     @Test
     public void testUnRegister() {
-        assertEquals(0, getRegistereds());
+        assertEquals(0, getRegisteredSize());
         dubboRegistry.register(serviceURL);
-        assertEquals(1, getRegistereds());
+        assertEquals(1, getRegisteredSize());
         dubboRegistry.unregister(serviceURL);
-        assertEquals(0, getRegistereds());
+        assertEquals(0, getRegisteredSize());
     }
 
     @Test
     public void testSubscribe() {
         dubboRegistry.register(serviceURL);
-        assertEquals(1, getRegistereds());
+        assertEquals(1, getRegisteredSize());
         dubboRegistry.subscribe(serviceURL, notifyListener);
-        assertEquals(1, getSubscribeds());
+        assertEquals(1, getSubscribedSize());
         assertEquals(1, getNotifiedListeners());
     }
 
     @Test
     public void testUnsubscribe() {
         dubboRegistry.subscribe(serviceURL, notifyListener);
-        assertEquals(1, getSubscribeds());
+        assertEquals(1, getSubscribedSize());
         assertEquals(1, getNotifiedListeners());
         dubboRegistry.unsubscribe(serviceURL, notifyListener);
         assertEquals(0, getNotifiedListeners());
     }
 
     private class MockDubboRegistry extends FailbackRegistry {
 
-        private volatile boolean isAvaliable = false;
+        private volatile boolean isAvailable = false;
 
         public MockDubboRegistry(URL url) {
             super(url);
@@ -116,13 +116,13 @@ public MockDubboRegistry(URL url) {
         @Override
         public void doRegister(URL url) {
             logger.info(""Begin to register: "" + url);
-            isAvaliable = true;
+            isAvailable = true;
         }
 
         @Override
         public void doUnregister(URL url) {
             logger.info(""Begin to ungister: "" + url);
-            isAvaliable = false;
+            isAvailable = false;
         }
 
         @Override
@@ -137,19 +137,19 @@ public void doUnsubscribe(URL url, NotifyListener listener) {
 
         @Override
         public boolean isAvailable() {
-            return isAvaliable;
+            return isAvailable;
         }
     }
 
     private int getNotifiedListeners() {
         return dubboRegistry.getSubscribed().get(serviceURL).size();
     }
 
-    private int getRegistereds() {
+    private int getRegisteredSize() {
         return dubboRegistry.getRegistered().size();
     }
 
-    private int getSubscribeds() {
+    private int getSubscribedSize() {
         return dubboRegistry.getSubscribed().size();
     }
 }
"
https://github.com/square/retrofit/commit/46598adb1da0f6d2498d9f8b815b170bf95fe1f8,Use the annotations directly for parameter handling.  <enter> Before we attempted to normalize the parameter annotations into a name and type model. The introduction of multi-part transfer encodings required something more expressive so the annotation instances themselves were used. This change removes the name and type in favor of using the annotation for everything. <enter> Deprecate the pre-encoded annotations in favor of boolean fields on the corresponding 'regular' annotation. ,https://api.github.com/repos/square/retrofit/commits/46598adb1da0f6d2498d9f8b815b170bf95fe1f8,"@@ -28,20 +28,24 @@
 import retrofit.client.Header;
 import retrofit.client.Request;
 import retrofit.converter.Converter;
+import retrofit.http.Body;
+import retrofit.http.EncodedPath;
+import retrofit.http.EncodedQuery;
+import retrofit.http.EncodedQueryMap;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
 import retrofit.http.Part;
 import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
 import retrofit.mime.FormUrlEncodedTypedOutput;
 import retrofit.mime.MultipartTypedOutput;
 import retrofit.mime.TypedOutput;
 import retrofit.mime.TypedString;
 
-import static retrofit.RestMethodInfo.ParamUsage.QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY_MAP;
-
 final class RequestBuilder implements RequestInterceptor.RequestFacade {
   private final Converter converter;
-  private final String[] paramNames;
-  private final RestMethodInfo.ParamUsage[] paramUsages;
   private final Annotation[] paramAnnotations;
   private final String requestMethod;
   private final boolean isSynchronous;
@@ -61,9 +65,7 @@ final class RequestBuilder implements RequestInterceptor.RequestFacade {
     this.apiUrl = apiUrl;
     this.converter = converter;
 
-    paramNames = methodInfo.requestParamNames;
-    paramUsages = methodInfo.requestParamUsage;
-    paramAnnotations = methodInfo.requestParamAnnotation;
+    paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
     isSynchronous = methodInfo.isSynchronous;
     isObservable = methodInfo.isObservable;
@@ -151,37 +153,75 @@ private void addPathParam(String name, String value, boolean urlEncodeValue) {
   }
 
   @Override public void addQueryParam(String name, String value) {
-    addQueryParam(name, value, true);
+    addQueryParam(name, value, false, true);
   }
 
   @Override public void addEncodedQueryParam(String name, String value) {
-    addQueryParam(name, value, false);
+    addQueryParam(name, value, false, false);
+  }
+
+  private void addQueryParam(String name, Object value, boolean encodeName, boolean encodeValue) {
+    if (value instanceof Iterable) {
+      for (Object iterableValue : (Iterable<?>) value) {
+        if (iterableValue != null) { // Skip null values
+          addQueryParam(name, iterableValue.toString(), encodeName, encodeValue);
+        }
+      }
+    } else if (value.getClass().isArray()) {
+      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+        Object arrayValue = Array.get(value, x);
+        if (arrayValue != null) { // Skip null values
+          addQueryParam(name, arrayValue.toString(), encodeName, encodeValue);
+        }
+      }
+    } else {
+      addQueryParam(name, value.toString(), encodeName, encodeValue);
+    }
   }
 
-  private void addQueryParam(String name, String value, boolean urlEncodeValue) {
+  private void addQueryParam(String name, String value, boolean encodeName, boolean encodeValue) {
     if (name == null) {
       throw new IllegalArgumentException(""Query param name must not be null."");
     }
     if (value == null) {
       throw new IllegalArgumentException(""Query param \"""" + name + ""\"" value must not be null."");
     }
     try {
-      if (urlEncodeValue) {
-        value = URLEncoder.encode(String.valueOf(value), ""UTF-8"");
-      }
       StringBuilder queryParams = this.queryParams;
       if (queryParams == null) {
         this.queryParams = queryParams = new StringBuilder();
       }
 
       queryParams.append(queryParams.length() > 0 ? '&' : '?');
+
+      if (encodeName) {
+        name = URLEncoder.encode(name, ""UTF-8"");
+      }
+      if (encodeValue) {
+        value = URLEncoder.encode(value, ""UTF-8"");
+      }
       queryParams.append(name).append('=').append(value);
     } catch (UnsupportedEncodingException e) {
       throw new RuntimeException(
           ""Unable to convert query parameter \"""" + name + ""\"" value to UTF-8: "" + value, e);
     }
   }
 
+  private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encodeNames,
+      boolean encodeValues) {
+    for (Map.Entry<?, ?> entry : map.entrySet()) {
+      Object entryKey = entry.getKey();
+      if (entryKey == null) {
+        throw new IllegalArgumentException(
+            ""Parameter #"" + (parameterNumber + 1) + "" query map contained null key."");
+      }
+      Object entryValue = entry.getValue();
+      if (entryValue != null) { // Skip null values.
+        addQueryParam(entryKey.toString(), entryValue.toString(), encodeNames, encodeValues);
+      }
+    }
+  }
+
   void setArguments(Object[] args) {
     if (args == null) {
       return;
@@ -191,137 +231,130 @@ void setArguments(Object[] args) {
       count -= 1;
     }
     for (int i = 0; i < count; i++) {
-      String name = paramNames[i];
-      Annotation annotation = paramAnnotations[i];
       Object value = args[i];
-      RestMethodInfo.ParamUsage paramUsage = paramUsages[i];
-      switch (paramUsage) {
-        case PATH:
-          if (value == null) {
-            throw new IllegalArgumentException(
-                ""Path parameter \"""" + name + ""\"" value must not be null."");
-          }
-          addPathParam(name, value.toString());
-          break;
-        case ENCODED_PATH:
-          if (value == null) {
-            throw new IllegalArgumentException(
-                ""Path parameter \"""" + name + ""\"" value must not be null."");
-          }
-          addEncodedPathParam(name, value.toString());
-          break;
-        case QUERY:
-        case ENCODED_QUERY:
-          if (value != null) { // Skip null values.
-            boolean urlEncodeValue = paramUsage == QUERY;
-            if (value instanceof Iterable) {
-              for (Object iterableValue : (Iterable<?>) value) {
-                if (iterableValue != null) { // Skip null values
-                  addQueryParam(name, iterableValue.toString(), urlEncodeValue);
-                }
-              }
-            } else if (value.getClass().isArray()) {
-              for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-                Object arrayValue = Array.get(value, x);
-                if (arrayValue != null) { // Skip null values
-                  addQueryParam(name, arrayValue.toString(), urlEncodeValue);
-                }
+
+      Annotation annotation = paramAnnotations[i];
+      Class<? extends Annotation> annotationType = annotation.annotationType();
+      if (annotationType == Path.class) {
+        Path path = (Path) annotation;
+        String name = path.value();
+        if (value == null) {
+          throw new IllegalArgumentException(
+              ""Path parameter \"""" + name + ""\"" value must not be null."");
+        }
+        addPathParam(name, value.toString(), path.encode());
+      } else if (annotationType == EncodedPath.class) {
+        String name = ((EncodedPath) annotation).value();
+        if (value == null) {
+          throw new IllegalArgumentException(
+              ""Path parameter \"""" + name + ""\"" value must not be null."");
+        }
+        addPathParam(name, value.toString(), false);
+      } else if (annotationType == Query.class) {
+        if (value != null) { // Skip null values.
+          Query query = (Query) annotation;
+          addQueryParam(query.value(), value, query.encodeName(), query.encodeValue());
+        }
+      } else if (annotationType == EncodedQuery.class) {
+        if (value != null) { // Skip null values.
+          EncodedQuery query = (EncodedQuery) annotation;
+          addQueryParam(query.value(), value, false, false);
+        }
+      } else if (annotationType == QueryMap.class) {
+        if (value != null) { // Skip null values.
+          QueryMap queryMap = (QueryMap) annotation;
+          addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
+        }
+      } else if (annotationType == EncodedQueryMap.class) {
+        if (value != null) { // Skip null values.
+          addQueryParamMap(i, (Map<?, ?>) value, false, false);
+        }
+      } else if (annotationType == retrofit.http.Header.class) {
+        if (value != null) { // Skip null values.
+          String name = ((retrofit.http.Header) annotation).value();
+          addHeader(name, value.toString());
+        }
+      } else if (annotationType == Field.class) {
+        String name = ((Field) annotation).value();
+        if (value != null) { // Skip null values.
+          if (value instanceof Iterable) {
+            for (Object iterableValue : (Iterable<?>) value) {
+              if (iterableValue != null) { // Skip null values.
+                formBody.addField(name, iterableValue.toString());
               }
-            } else {
-              addQueryParam(name, value.toString(), urlEncodeValue);
             }
-          }
-          break;
-        case QUERY_MAP:
-        case ENCODED_QUERY_MAP:
-          if (value != null) { // Skip null values.
-            boolean urlEncodeValue = paramUsage == QUERY_MAP;
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                addQueryParam(entry.getKey().toString(), entryValue.toString(), urlEncodeValue);
+          } else if (value.getClass().isArray()) {
+            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+              Object arrayValue = Array.get(value, x);
+              if (arrayValue != null) { // Skip null values.
+                formBody.addField(name, arrayValue.toString());
               }
             }
+          } else {
+            formBody.addField(name, value.toString());
           }
-          break;
-        case HEADER:
-          if (value != null) { // Skip null values.
-            addHeader(name, value.toString());
-          }
-          break;
-        case FIELD:
-          if (value != null) { // Skip null values.
-            if (value instanceof Iterable) {
-              for (Object iterableValue : (Iterable<?>) value) {
-                if (iterableValue != null) { // Skip null values.
-                  formBody.addField(name, iterableValue.toString());
-                }
-              }
-            } else if (value.getClass().isArray()) {
-              for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-                Object arrayValue = Array.get(value, x);
-                if (arrayValue != null) { // Skip null values.
-                  formBody.addField(name, arrayValue.toString());
-                }
-              }
-            } else {
-              formBody.addField(name, value.toString());
+        }
+      } else if (annotationType == FieldMap.class) {
+        if (value != null) { // Skip null values.
+          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+            Object entryKey = entry.getKey();
+            if (entryKey == null) {
+              throw new IllegalArgumentException(
+                  ""Parameter #"" + (i + 1) + "" field map contained null key."");
             }
-          }
-          break;
-        case FIELD_MAP:
-          if (value != null) { // Skip null values.
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                formBody.addField(entry.getKey().toString(), entryValue.toString());
-              }
+            Object entryValue = entry.getValue();
+            if (entryValue != null) { // Skip null values.
+              formBody.addField(entryKey.toString(), entryValue.toString());
             }
           }
-          break;
-        case PART:
-          if (value != null) { // Skip null values.
-            String transferEncoding = ((Part) annotation).encoding();
-            if (value instanceof TypedOutput) {
-              multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
-            } else if (value instanceof String) {
-              multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
-            } else {
-              multipartBody.addPart(name, transferEncoding, converter.toBody(value));
-            }
+        }
+      } else if (annotationType == Part.class) {
+        String name = ((Part) annotation).value();
+        if (value != null) { // Skip null values.
+          String transferEncoding = ((Part) annotation).encoding();
+          if (value instanceof TypedOutput) {
+            multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
+          } else if (value instanceof String) {
+            multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
+          } else {
+            multipartBody.addPart(name, transferEncoding, converter.toBody(value));
           }
-          break;
-        case PART_MAP:
-          if (value != null) { // Skip null values.
-            String transferEncoding = ((PartMap) annotation).encoding();
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              String entryName = entry.getKey().toString();
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                if (entryValue instanceof TypedOutput) {
-                  multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
-                } else if (entryValue instanceof String) {
-                  multipartBody.addPart(entryName, transferEncoding,
-                      new TypedString((String) entryValue));
-                } else {
-                  multipartBody.addPart(entryName, transferEncoding, converter.toBody(entryValue));
-                }
+        }
+      } else if (annotationType == PartMap.class) {
+        if (value != null) { // Skip null values.
+          String transferEncoding = ((PartMap) annotation).encoding();
+          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+            Object entryKey = entry.getKey();
+            if (entryKey == null) {
+              throw new IllegalArgumentException(
+                  ""Parameter #"" + (i + 1) + "" part map contained null key."");
+            }
+            String entryName = entryKey.toString();
+            Object entryValue = entry.getValue();
+            if (entryValue != null) { // Skip null values.
+              if (entryValue instanceof TypedOutput) {
+                multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
+              } else if (entryValue instanceof String) {
+                multipartBody.addPart(entryName, transferEncoding,
+                    new TypedString((String) entryValue));
+              } else {
+                multipartBody.addPart(entryName, transferEncoding, converter.toBody(entryValue));
               }
             }
           }
-          break;
-        case BODY:
-          if (value == null) {
-            throw new IllegalArgumentException(""Body parameter value must not be null."");
-          }
-          if (value instanceof TypedOutput) {
-            body = (TypedOutput) value;
-          } else {
-            body = converter.toBody(value);
-          }
-          break;
-        default:
-          throw new IllegalArgumentException(""Unknown parameter usage: "" + paramUsage);
+        }
+      } else if (annotationType == Body.class) {
+        if (value == null) {
+          throw new IllegalArgumentException(""Body parameter value must not be null."");
+        }
+        if (value instanceof TypedOutput) {
+          body = (TypedOutput) value;
+        } else {
+          body = converter.toBody(value);
+        }
+      } else {
+        throw new IllegalArgumentException(
+            ""Unknown annotation: "" + annotationType.getCanonicalName());
       }
     }
   }
@@ -54,9 +54,7 @@
  * Method parameters can be used to replace parts of the URL by annotating them with
  * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
  * by curly braces (e.g., ""{foo}""). To add items to the query string of a URL use
- * {@link retrofit.http.Query @Query}. If the path or query element has already been URI encoded
- * use {@link retrofit.http.EncodedPath @EncodedPath} or
- * {@link retrofit.http.EncodedQuery @EncodedQuery} to prevent repeated encoding.
+ * {@link retrofit.http.Query @Query}.
  * <p>
  * HTTP requests happen in one of two ways:
  * <ul>
@@ -61,21 +61,6 @@ private enum ResponseType {
   private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
   private static final Pattern PARAM_URL_REGEX = Pattern.compile(""\\{("" + PARAM + "")\\}"");
 
-  enum ParamUsage {
-    PATH,
-    ENCODED_PATH,
-    QUERY,
-    ENCODED_QUERY,
-    QUERY_MAP,
-    ENCODED_QUERY_MAP,
-    FIELD,
-    FIELD_MAP,
-    PART,
-    PART_MAP,
-    BODY,
-    HEADER
-  }
-
   enum RequestType {
     /** No content-specific logic required. */
     SIMPLE,
@@ -105,9 +90,7 @@ enum RequestType {
   boolean isStreaming;
 
   // Parameter-level details
-  String[] requestParamNames;
-  ParamUsage[] requestParamUsage;
-  Annotation[] requestParamAnnotation;
+  Annotation[] requestParamAnnotations;
 
   RestMethodInfo(Method method) {
     this.method = method;
@@ -321,8 +304,7 @@ private static Type getParameterUpperBound(ParameterizedType type) {
   }
 
   /**
-   * Loads {@link #requestParamNames}, {@link #requestParamUsage}, and
-   * {@link #requestParamAnnotation}. Must be called after {@link #parseMethodAnnotations()}.
+   * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
    */
   private void parseParameters() {
     Class<?>[] methodParameterTypes = method.getParameterTypes();
@@ -333,9 +315,7 @@ private void parseParameters() {
       count -= 1; // Callback is last argument when not a synchronous method.
     }
 
-    String[] requestParamNames = new String[count];
-    ParamUsage[] requestParamUsage = new ParamUsage[count];
-    Annotation[] requestParamAnnotation = new Annotation[count];
+    Annotation[] requestParamAnnotations = new Annotation[count];
 
     boolean gotField = false;
     boolean gotPart = false;
@@ -352,52 +332,31 @@ private void parseParameters() {
           if (methodAnnotationType == Path.class) {
             String name = ((Path) methodParameterAnnotation).value();
             validatePathName(i, name);
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.PATH;
           } else if (methodAnnotationType == EncodedPath.class) {
             String name = ((EncodedPath) methodParameterAnnotation).value();
             validatePathName(i, name);
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.ENCODED_PATH;
           } else if (methodAnnotationType == Query.class) {
-            String name = ((Query) methodParameterAnnotation).value();
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.QUERY;
+            // Nothing to do.
           } else if (methodAnnotationType == EncodedQuery.class) {
-            String name = ((EncodedQuery) methodParameterAnnotation).value();
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.ENCODED_QUERY;
+            // Nothing to do.
           } else if (methodAnnotationType == QueryMap.class) {
             if (!Map.class.isAssignableFrom(methodParameterType)) {
               throw parameterError(i, ""@QueryMap parameter type must be Map."");
             }
 
-            requestParamUsage[i] = ParamUsage.QUERY_MAP;
           } else if (methodAnnotationType == EncodedQueryMap.class) {
             if (!Map.class.isAssignableFrom(methodParameterType)) {
               throw parameterError(i, ""@EncodedQueryMap parameter type must be Map."");
             }
 
-            requestParamUsage[i] = ParamUsage.ENCODED_QUERY_MAP;
           } else if (methodAnnotationType == Header.class) {
-            String name = ((Header) methodParameterAnnotation).value();
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.HEADER;
+            // Nothing to do.
           } else if (methodAnnotationType == Field.class) {
             if (requestType != RequestType.FORM_URL_ENCODED) {
               throw parameterError(i, ""@Field parameters can only be used with form encoding."");
             }
 
-            String name = ((Field) methodParameterAnnotation).value();
-
             gotField = true;
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.FIELD;
           } else if (methodAnnotationType == FieldMap.class) {
             if (requestType != RequestType.FORM_URL_ENCODED) {
               throw parameterError(i, ""@FieldMap parameters can only be used with form encoding."");
@@ -407,17 +366,12 @@ private void parseParameters() {
             }
 
             gotField = true;
-            requestParamUsage[i] = ParamUsage.FIELD_MAP;
           } else if (methodAnnotationType == Part.class) {
             if (requestType != RequestType.MULTIPART) {
               throw parameterError(i, ""@Part parameters can only be used with multipart encoding."");
             }
 
-            String name = ((Part) methodParameterAnnotation).value();
-
             gotPart = true;
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.PART;
           } else if (methodAnnotationType == PartMap.class) {
             if (requestType != RequestType.MULTIPART) {
               throw parameterError(i,
@@ -428,7 +382,6 @@ private void parseParameters() {
             }
 
             gotPart = true;
-            requestParamUsage[i] = ParamUsage.PART_MAP;
           } else if (methodAnnotationType == Body.class) {
             if (requestType != RequestType.SIMPLE) {
               throw parameterError(i,
@@ -439,23 +392,22 @@ private void parseParameters() {
             }
 
             gotBody = true;
-            requestParamUsage[i] = ParamUsage.BODY;
           } else {
             // This is a non-Retrofit annotation. Skip to the next one.
             continue;
           }
 
-          if (requestParamAnnotation[i] != null) {
+          if (requestParamAnnotations[i] != null) {
             throw parameterError(i,
                 ""Multiple Retrofit annotations found, only one allowed: @%s, @%s."",
-                requestParamAnnotation[i].annotationType().getSimpleName(),
+                requestParamAnnotations[i].annotationType().getSimpleName(),
                 methodAnnotationType.getSimpleName());
           }
-          requestParamAnnotation[i] = methodParameterAnnotation;
+          requestParamAnnotations[i] = methodParameterAnnotation;
         }
       }
 
-      if (requestParamUsage[i] == null) {
+      if (requestParamAnnotations[i] == null) {
         throw parameterError(i, ""No Retrofit annotation found."");
       }
     }
@@ -470,9 +422,7 @@ private void parseParameters() {
       throw methodError(""Multipart method must contain at least one @Part."");
     }
 
-    this.requestParamNames = requestParamNames;
-    this.requestParamUsage = requestParamUsage;
-    this.requestParamAnnotation = requestParamAnnotation;
+    this.requestParamAnnotations = requestParamAnnotations;
   }
 
   private void validatePathName(int index, String name) {
@@ -33,8 +33,12 @@
  * </pre>
  * <p>
  * Path parameters may not be {@code null}.
+ *
+ * @see Path
+ * @deprecated Use {@link Path} with {@link Path#encode() encode = false}.
  */
 @Documented
+@Deprecated
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface EncodedPath {
@@ -31,9 +31,10 @@
  *
  * @see Query
  * @see QueryMap
- * @see EncodedQueryMap
+ * @deprecated Use {@link Query} with {@link Query#encodeValue() encodeValue = false}.
  */
 @Documented
+@Deprecated
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface EncodedQuery {
@@ -31,9 +31,10 @@
  *
  * @see Query
  * @see QueryMap
- * @see EncodedQuery
+ * @deprecated Use {@link QueryMap} with {@link QueryMap#encodeValues() encodeValues = false}.
  */
 @Documented
+@Deprecated
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface EncodedQueryMap {
@@ -24,12 +24,25 @@
 
 /**
  * Named replacement in the URL path. Values are converted to string using
- * {@link String#valueOf(Object)}. Replaced values will be URL encoded.
+ * {@link String#valueOf(Object)} and URL encoded.
  * <p>
+ * Simple example:
  * <pre>
  * &#64;GET(""/image/{id}"")
- * void example(@Path(""id"") int id, ..);
+ * void example(@Path(""id"") int id);
  * </pre>
+ * Calling with {@code foo.example(1)} yields {@code /image/1}.
+ * <p>
+ * Values are URL encoded by default. Disable with {@code encode=false}.
+ * <pre>
+ * &#64;GET(""/user/{name}"")
+ * void encoded(@Path(""name"") String name);
+ *
+ * &#64;GET(""/user/{name}"")
+ * void notEncoded(@Path(value=""name"", encode=false) String name);
+ * </pre>
+ * Calling {@code foo.encoded(""John+Doe"")} yields {@code /user/John%2BDoe} whereas
+ * {@code foo.notEncoded(""John+Doe"")} yields {@code /user/John+Doe}.
  * <p>
  * Path parameters may not be {@code null}.
  */
@@ -38,4 +51,7 @@
 @Target(PARAMETER)
 public @interface Path {
   String value();
+
+  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
+  boolean encode() default true;
 }
@@ -50,14 +50,35 @@
  * </pre>
  * Calling with {@code foo.list(""bar"", ""baz"")} yields
  * {@code /list?category=foo&category=bar}.
+ * <p>
+ * Parameter names are not URL encoded. Specify {@link #encodeName() encodeName=true} to change
+ * this behavior.
+ * <pre>
+ * &#64;GET(""/search"")
+ * void list(@Query(value=""foo+bar"", encodeName=true) String foobar);
+ * </pre>
+ * Calling with {@code foo.list(""baz"")} yields {@code /search?foo%2Bbar=foo}.
+ * <p>
+ * Parameter values are URL encoded by default. Specify {@link #encodeValue() encodeValue=false} to
+ * change this behavior.
+ * <pre>
+ * &#64;GET(""/search"")
+ * void list(@Query(value=""foo"", encodeValue=false) String foo);
+ * </pre>
+ * Calling with {@code foo.list(""foo+foo""))} yields {@code /search?foo=foo+bar}.
  *
- * @see EncodedQuery
  * @see QueryMap
- * @see EncodedQueryMap
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Query {
+  /** The query parameter name. */
   String value();
+
+  /** Specifies whether {@link #value()} is URL encoded. */
+  boolean encodeName() default false;
+
+  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
+  boolean encodeValue() default true;
 }
@@ -26,7 +26,8 @@
  * Query parameter keys and values appended to the URL.
  * <p>
  * Both keys and values are converted to strings using {@link String#valueOf(Object)}. Values are
- * URL encoded and {@code null} will not include the query parameter in the URL.
+ * URL encoded and {@code null} will not include the query parameter in the URL. {@code null} keys
+ * are not allowed.
  * <p>
  * Simple Example:
  * <pre>
@@ -35,13 +36,34 @@
  * </pre>
  * Calling with {@code foo.list(ImmutableMap.of(""foo"", ""bar"", ""kit"", ""kat""))} yields
  * {@code /search?foo=bar&kit=kat}.
+ * <p>
+ * Map keys representing the parameter names are not URL encoded. Specify
+ * {@link #encodeNames() encodeNames=true} to change this behavior.
+ * <pre>
+ * &#64;GET(""/search"")
+ * void list(@QueryMap(encodeNames=true) Map&lt;String, String&gt; filters);
+ * </pre>
+ * Calling with {@code foo.list(ImmutableMap.of(""foo+bar"", ""foo+bar""))} yields
+ * {@code /search?foo%2Bbar=foo}.
+ * <p>
+ * Map values representing parameter values are URL encoded by default. Specify
+ * {@link #encodeValues() encodeValues=false} to change this behavior.
+ * <pre>
+ * &#64;GET(""/search"")
+ * void list(@QueryMap(encodeValues=false) Map&lt;String, String&gt; filters);
+ * </pre>
+ * Calling with {@code foo.list(ImmutableMap.of(""foo"", ""foo+foo""))} yields
+ * {@code /search?foo=foo%2Bbar}.
  *
  * @see Query
- * @see QueryMap
- * @see EncodedQueryMap
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface QueryMap {
+  /** Specifies whether parameter names (keys in the map) are URL encoded. */
+  boolean encodeNames() default false;
+
+  /** Specifies whether parameter values (values in the map) are URL encoded. */
+  boolean encodeValues() default true;
 }
@@ -579,6 +579,26 @@ Response method(@QueryMap List<String> a) {
     }
   }
 
+  @Test public void queryMapRejectsNullKeys() {
+    class Example {
+      @GET(""/"") //
+      Response method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Map<String, String> queryParams = new LinkedHashMap<String, String>();
+    queryParams.put(""ping"", ""pong"");
+    queryParams.put(null, ""kat"");
+
+    try {
+      buildRequest(Example.class, queryParams);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""Parameter #1 query map contained null key."");
+    }
+  }
+
   @Test public void twoBodies() {
     class Example {
       @PUT(""/"") //
@@ -710,6 +730,20 @@ Response method(@Path(""ping"") String ping) {
   }
 
   @Test public void getWithEncodedPathParam() {
+    class Example {
+      @GET(""/foo/bar/{ping}/"") //
+      Response method(@Path(value = ""ping"", encode = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, ""po%20ng"");
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/po%20ng/"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodedPathParamDeprecated() {
     class Example {
       @GET(""/foo/bar/{ping}/"") //
       Response method(@EncodedPath(""ping"") String ping) {
@@ -876,7 +910,7 @@ Response method(@Path(""ping"") String ping) {
   @Test public void getWithQueryParam() {
     class Example {
       @GET(""/foo/bar/"") //
-      Response method(@EncodedQuery(""ping"") String ping) {
+      Response method(@Query(""ping"") String ping) {
         return null;
       }
     }
@@ -888,6 +922,48 @@ Response method(@EncodedQuery(""ping"") String ping) {
   }
 
   @Test public void getWithEncodedQueryParam() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@Query(value = ""ping"", encodeValue = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, ""p+o+n+g"");
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?ping=p+o+n+g"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodeNameQueryParam() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@Query(value = ""pi ng"", encodeName = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, ""pong"");
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?pi+ng=pong"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodeNameEncodedValueQueryParam() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@Query(value = ""pi ng"", encodeName = true, encodeValue = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, ""po+ng"");
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?pi+ng=po+ng"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryParamDeprecated() {
     class Example {
       @GET(""/foo/bar/"") //
       Response method(@EncodedQuery(""ping"") String ping) {
@@ -1081,7 +1157,7 @@ Response method(@QueryMap Map<String, Object> query) {
     assertThat(request.getBody()).isNull();
   }
 
-  @Test public void getWithEncodedQueryParamMap() {
+  @Test public void getWithEncodedQueryParamMapDeprecated() {
     class Example {
       @GET(""/foo/bar/"") //
       Response method(@EncodedQueryMap Map<String, Object> query) {
@@ -1101,6 +1177,67 @@ Response method(@EncodedQueryMap Map<String, Object> query) {
     assertThat(request.getBody()).isNull();
   }
 
+  @Test public void getWithEncodedQueryParamMap() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@QueryMap(encodeValues = false) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put(""kit"", ""k%20t"");
+    params.put(""foo"", null);
+    params.put(""ping"", ""p%20g"");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?kit=k%20t&ping=p%20g"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodeNameQueryParamMap() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@QueryMap(encodeNames = true) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put(""k it"", ""k t"");
+    params.put(""fo o"", null);
+    params.put(""pi ng"", ""p g"");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?k+it=k+t&pi+ng=p+g"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodeNameEncodedValueQueryParamMap() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(
+          @QueryMap(encodeNames = true, encodeValues = false) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put(""k it"", ""k%20t"");
+    params.put(""fo o"", null);
+    params.put(""pi ng"", ""p%20g"");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?k+it=k%20t&pi+ng=p%20g"");
+    assertThat(request.getBody()).isNull();
+  }
+
   @Test public void encodedQueryMapMustBeAMap() {
     class Example {
       @GET(""/"") //
@@ -1314,6 +1451,27 @@ Response method(@PartMap(encoding = ""8-bit"") Map<String, Object> parts) {
         .endsWith(""\r\nkat"");
   }
 
+  @Test public void multipartPartMapRejectsNullKeys() {
+    class Example {
+      @Multipart //
+      @POST(""/foo/bar/"") //
+      Response method(@PartMap Map<String, Object> parts) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put(""ping"", ""pong"");
+    params.put(null, ""kat"");
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""Parameter #1 part map contained null key."");
+    }
+  }
+
   @Test public void multipartNullRemovesPart() {
     class Example {
       @Multipart //
@@ -1438,6 +1596,28 @@ Response method(@FieldMap Map<String, Object> fieldMap) {
     assertTypedBytes(request.getBody(), ""kit=kat&ping=pong"");
   }
 
+  @Test public void fieldMapRejectsNullKeys() {
+    class Example {
+      @FormUrlEncoded //
+      @POST(""/"") //
+      Response method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+    fieldMap.put(""kit"", ""kat"");
+    fieldMap.put(""foo"", null);
+    fieldMap.put(null, ""pong"");
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""Parameter #1 field map contained null key."");
+    }
+  }
+
   @Test public void fieldMapMustBeAMap() {
     class Example {
       @FormUrlEncoded //
@@ -1633,12 +1813,8 @@ private static void assertTypedBytes(TypedOutput bytes, String expected) {
   private static final Converter GSON = new GsonConverter(new Gson());
 
   private Request buildRequest(Class<?> cls, Object... args) {
-    Method[] methods = cls.getDeclaredMethods();
-    if (methods.length != 1) {
-      throw new IllegalStateException(""More than one method declared."");
-    }
-
-    RestMethodInfo methodInfo = new RestMethodInfo(methods[0]);
+    Method method = TestingUtils.onlyMethod(cls);
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
     RequestBuilder builder = new RequestBuilder(""http://example.com/"", methodInfo, GSON);
@@ -51,7 +51,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -63,7 +63,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -75,7 +75,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -87,7 +87,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -99,7 +99,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -111,7 +111,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
 
@@ -129,7 +129,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(
@@ -143,7 +143,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isTrue();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -156,7 +156,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isTrue();
 
@@ -171,7 +171,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
@@ -185,7 +185,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
@@ -200,7 +200,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.isObservable).isTrue();
@@ -214,7 +214,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.isObservable).isTrue();
@@ -11,13 +11,12 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class TestingUtils {
-  public static Method getMethod(Class c, String name) {
-    for (Method method : c.getDeclaredMethods()) {
-      if (method.getName().equals(name)) {
-        return method;
-      }
+  public static Method onlyMethod(Class c) {
+    Method[] declaredMethods = c.getDeclaredMethods();
+    if (declaredMethods.length == 1) {
+      return declaredMethods[0];
     }
-    throw new IllegalArgumentException(""Unknown method '"" + name + ""' on "" + c);
+    throw new IllegalArgumentException(""More than one method declared."");
   }
 
   public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
"
https://github.com/junit-team/junit4/commit/7e77e49c40afb951ae5a5cbdf75ebb4a478e2bb7,Updated README.html ,https://api.github.com/repos/junit-team/junit4/commits/7e77e49c40afb951ae5a5cbdf75ebb4a478e2bb7,"@@ -12,14 +12,13 @@ <h1>
 <b><font color=""#00CC00"">J</font><font color=""#FF0000"">U</font><font color=""#000000"">nit
 4.5</b></h1> 
 <br>Brought to you by <a href=""http://www.threeriversinstitute.org"">Kent Beck</a>, Erich 
-
 Gamma, and <a href=""http://david.saff.net"">David Saff</a>. 
 <br>FAQ edited by <a href=""http://www.clarkware.com"">Mike Clark</a>. Web mastering by Erik 
 Meade.
 <br>(see also <a href=""http://www.junit.org"">JUnit.org</a>)
 
 <hr WIDTH=""100%"">
-<br>[old date] 18 July 2007
+<br>8 August 2008
 <p>JUnit is a simple framework to write repeatable tests. It is an instance
 of the xUnit architecture for unit testing frameworks.
 <ul>
@@ -44,6 +43,95 @@ <h1>
 <a NAME=""Summary of"">
 <h2>Summary of Changes in version 4.5</h2>
 
+<h3>Installation</h3>
+
+<ul>
+<li>We are releasing <code>junit-4.5.jar</code>, which contains all the classes
+necessary to run JUnit, and <code>junit-dep-4.5.jar</code>, which leaves out
+hamcrest classes, for developers who already use hamcrest outside of
+JUnit.</li>
+</ul>
+
+<h3>Basic JUnit operation</h3>
+
+<ul>
+<li><p>JUnitCore now more often exits with the correct exit code (0 for
+success, 1 for failure)</p></li>
+<li><p>Badly formed test classes (exceptions in constructors, classes
+without tests, multiple constructors, Suite without @SuiteClasses)
+produce more helpful error messages</p></li>
+<li><p>Test classes whose only test methods are inherited from superclasses
+now run.</p></li>
+<li><p>Optimization to annotation processing can cut JUnit overhead by more than half
+on large test classes, especially when using Theories.  [Bug 1796847]</p></li>
+<li><p>A failing assumption in a constructor ignores the class</p></li>
+<li><p>Correct results when comparing the string ""null"" with potentially
+null values.  [Bug 1857283]</p></li>
+<li><p>Annotating a class with <code>@RunWith(JUnit4.class)</code> will always invoke the
+default JUnit 4 runner in the current version of JUnit.  This default changed
+from <code>JUnit4ClassRunner</code> in 4.4 to <code>BlockJUnit4ClassRunner</code> in 4.5 (see below),
+and may change again.</p></li>
+</ul>
+
+<h3>Extension</h3>
+
+<ul>
+<li><p><code>BlockJUnit4Runner</code> is a new implementation of the standard JUnit 4
+test class functionality.  In contrast to <code>JUnit4ClassRunner</code> (the old
+implementation):</p>
+
+<ul>
+<li><p><code>BlockJUnit4Runner</code> has a much simpler implementation based on
+Statements, allowing new operations to be inserted into the
+appropriate point in the execution flow.</p></li>
+<li><p><code>BlockJUnit4Runner</code> is published, and extension and reuse are
+encouraged, whereas <code>JUnit4ClassRunner</code> was in an internal package,
+and is now deprecated.</p></li>
+</ul></li>
+<li><p><code>ParentRunner</code> is a base class for runners that iterate over
+a list of ""children"", each an object representing a test or suite to run.
+<code>ParentRunner</code> provides filtering, sorting, <code>@BeforeClass</code>, <code>@AfterClass</code>,
+and method validation to subclasses.</p></li>
+<li><p><code>TestClass</code> wraps a class to be run, providing efficient, repeated access
+to all methods with a given annotation.</p></li>
+<li><p>The new <code>RunnerBuilder</code> API allows extending the behavior of
+Suite-like custom runners.</p></li>
+<li><p><code>AssumptionViolatedException.toString()</code> is more informative</p></li>
+</ul>
+
+<h3>Extra Runners</h3>
+
+<ul>
+<li><p><code>Parameterized.eachOne()</code> has been removed</p></li>
+<li><p>New runner <code>Enclosed</code> runs all static inner classes of an outer class.</p></li>
+</ul>
+
+<h3>Theories</h3>
+
+<ul>
+<li><p><code>@Before</code> and <code>@After</code> methods are run before and after each set of attempted parameters
+on a Theory, and each set of parameters is run on a new instance of the test class.</p></li>
+<li><p>Exposed API's <code>ParameterSignature.getType()</code> and <code>ParameterSignature.getAnnotations()</code></p></li>
+<li><p>An array of data points can be introduced by a field or method
+marked with the new annotation <code>@DataPoints</code></p></li>
+<li><p>The Theories custom runner has been refactored to make it faster and
+easier to extend</p></li>
+</ul>
+
+<h3>Development</h3>
+
+<ul>
+<li><p>Source has been split into directories <code>src/main/java</code> and
+<code>src/test/java</code>, making it easier to exclude tests from builds, and
+making JUnit more maven-friendly</p></li>
+<li><p>Test classes in <code>org.junit.tests</code> have been organized into
+subpackages, hopefully making finding tests easier.</p></li>
+<li><p><code>ResultMatchers</code> has more informative descriptions.</p></li>
+<li><p><code>TestSystem</code> allows testing return codes and other system-level interactions.</p></li>
+</ul>
+
+<h2>Summary of Changes in version 4.4</h2>
+
 <p>JUnit is designed to efficiently capture developers' intentions about
 their code, and quickly check their code matches those intentions.
 Over the last year, we've been talking about what things developers
"
https://github.com/spring-projects/spring-boot/commit/a79f71cbe802a8d87bc22e6eba67553ccedd54a7,Add @IntegrationComponentScan auto-configuration  <enter> Update Spring Integration auto-configuration so that `@IntegrationComponentScan` from `AutoConfigurationPackages` is implicitly applied. Prior to this commit `@MessagingGateway` interfaces would only get picked up if `@IntegrationComponentScan` was added alongside with the `@SpringBootApplication`. <enter>  Fixes   <issue_link>   Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/a79f71cbe802a8d87bc22e6eba67553ccedd54a7,"@@ -16,11 +16,15 @@
 
 package org.springframework.boot.autoconfigure.integration;
 
+import java.util.Map;
+
 import javax.management.MBeanServer;
 
 import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
+import org.springframework.beans.factory.support.BeanDefinitionRegistry;
+import org.springframework.boot.autoconfigure.AutoConfigurationPackages;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
@@ -31,9 +35,15 @@
 import org.springframework.context.EnvironmentAware;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Import;
 import org.springframework.core.env.Environment;
+import org.springframework.core.type.AnnotationMetadata;
+import org.springframework.core.type.StandardAnnotationMetadata;
+import org.springframework.integration.annotation.IntegrationComponentScan;
 import org.springframework.integration.config.EnableIntegration;
 import org.springframework.integration.config.EnableIntegrationManagement;
+import org.springframework.integration.config.IntegrationComponentScanRegistrar;
+import org.springframework.integration.gateway.GatewayProxyFactoryBean;
 import org.springframework.integration.jmx.config.EnableIntegrationMBeanExport;
 import org.springframework.integration.monitor.IntegrationMBeanExporter;
 import org.springframework.integration.support.management.IntegrationManagementConfigurer;
@@ -107,6 +117,46 @@ protected static class IntegrationManagementConfiguration {
 		@Configuration
 		@EnableIntegrationManagement(defaultCountsEnabled = ""true"", defaultStatsEnabled = ""true"")
 		protected static class EnableIntegrationManagementConfiguration {
+		}
+
+	}
+
+	@ConditionalOnMissingBean(GatewayProxyFactoryBean.class)
+	@Import(AutoIntegrationComponentScanRegistrar.class)
+	protected static class IntegrationComponentScanAutoConfiguration {
+
+	}
+
+	private static class AutoIntegrationComponentScanRegistrar
+			extends IntegrationComponentScanRegistrar {
+
+		@Override
+		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
+				final BeanDefinitionRegistry registry) {
+			StandardAnnotationMetadata metadata = new StandardAnnotationMetadata(
+					IntegrationComponentScanConfiguration.class, true) {
+
+				@Override
+				public Map<String, Object> getAnnotationAttributes(
+						String annotationName) {
+					Map<String, Object> annotationAttributes = super.getAnnotationAttributes(
+							annotationName);
+					if (IntegrationComponentScan.class.getName().equals(annotationName)) {
+						BeanFactory beanFactory = (BeanFactory) registry;
+						if (AutoConfigurationPackages.has(beanFactory)) {
+							annotationAttributes.put(""value"",
+									AutoConfigurationPackages.get(beanFactory));
+						}
+					}
+					return annotationAttributes;
+				}
+
+			};
+			super.registerBeanDefinitions(metadata, registry);
+		}
+
+		@IntegrationComponentScan
+		private class IntegrationComponentScanConfiguration {
 
 		}
 
@@ -30,6 +30,9 @@
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Primary;
+import org.springframework.integration.annotation.IntegrationComponentScan;
+import org.springframework.integration.annotation.MessagingGateway;
+import org.springframework.integration.gateway.RequestReplyExchanger;
 import org.springframework.integration.support.channel.HeaderChannelRegistry;
 import org.springframework.integration.support.management.IntegrationManagementConfigurer;
 import org.springframework.jmx.export.MBeanExporter;
@@ -61,24 +64,34 @@ public void close() {
 	@Test
 	public void integrationIsAvailable() {
 		load();
-		assertThat(this.context.getBean(HeaderChannelRegistry.class)).isNotNull();
+		assertThat(this.context.getBean(TestGateway.class)).isNotNull();
+		assertThat(this.context.getBean(IntegrationAutoConfiguration.IntegrationComponentScanAutoConfiguration.class))
+				.isNotNull();
 	}
 
 	@Test
-	public void parentContext() {
+	public void explicitIntegrationComponentScan() {
 		this.context = new AnnotationConfigApplicationContext();
-		this.context.register(JmxAutoConfiguration.class,
+		this.context.register(IntegrationComponentScanConfiguration.class,
+				JmxAutoConfiguration.class,
 				IntegrationAutoConfiguration.class);
 		this.context.refresh();
+		assertThat(this.context.getBean(TestGateway.class)).isNotNull();
+		assertThat(this.context.getBeansOfType(IntegrationAutoConfiguration.IntegrationComponentScanAutoConfiguration.class))
+				.isEmpty();
+	}
+
+	@Test
+	public void parentContext() {
+		load();
 		AnnotationConfigApplicationContext parent = this.context;
 		this.context = new AnnotationConfigApplicationContext();
 		this.context.setParent(parent);
 		this.context.register(JmxAutoConfiguration.class,
 				IntegrationAutoConfiguration.class);
+		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, ""SPRING_JMX_DEFAULT_DOMAIN=org.foo"");
 		this.context.refresh();
 		assertThat(this.context.getBean(HeaderChannelRegistry.class)).isNotNull();
-		((ConfigurableApplicationContext) this.context.getParent()).close();
-		this.context.close();
 	}
 
 	@Test
@@ -151,4 +164,15 @@ public MBeanExporter myMBeanExporter() {
 
 	}
 
+	@Configuration
+	@IntegrationComponentScan
+	static class IntegrationComponentScanConfiguration {
+
+	}
+
+	@MessagingGateway
+	public interface TestGateway extends RequestReplyExchanger {
+
+	}
+
 }
"
https://github.com/spring-projects/spring-boot/commit/b0579c1cf38aa6815ee180a2e61640cfbc2447d2,"Ensure JPA vendor properties are period separated  <enter> If you bind to Map<String,Object> you get a nested Map instead of period-separated keys. This change just makes JpaProperties expose a Map<String,String> so the keys are sane. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/b0579c1cf38aa6815ee180a2e61640cfbc2447d2,"@@ -137,7 +137,7 @@ public Builder persistenceUnit(String persistenceUnit) {
 		 * @param properties the properties to use
 		 * @return the builder for fluent usage
 		 */
-		public Builder properties(Map<String, Object> properties) {
+		public Builder properties(Map<String, String> properties) {
 			this.properties.putAll(properties);
 			return this;
 		}
@@ -71,13 +71,13 @@ protected AbstractJpaVendorAdapter createJpaVendorAdapter() {
 	}
 
 	@Override
-	protected Map<String, Object> getVendorProperties() {
+	protected Map<String, String> getVendorProperties() {
 		return this.properties.getInitialHibernateProperties(this.dataSource);
 	}
 
 	@Override
 	protected EntityManagerFactoryBeanCallback getVendorCallback() {
-		final Map<String, Object> map = this.properties
+		final Map<String, String> map = this.properties
 				.getHibernateProperties(this.dataSource);
 		return new EntityManagerFactoryBeanCallback() {
 			@Override
@@ -93,18 +93,18 @@ public void execute(
 	private static class DeferredSchemaAction implements
 			ApplicationListener<ContextRefreshedEvent> {
 
-		private Map<String, Object> map;
+		private Map<String, String> map;
 		private LocalContainerEntityManagerFactoryBean factory;
 
 		public DeferredSchemaAction(LocalContainerEntityManagerFactoryBean factory,
-				Map<String, Object> map) {
+				Map<String, String> map) {
 			this.factory = factory;
 			this.map = map;
 		}
 
 		@Override
 		public void onApplicationEvent(ContextRefreshedEvent event) {
-			String ddlAuto = (String) this.map.get(""hibernate.hbm2ddl.auto"");
+			String ddlAuto = this.map.get(""hibernate.hbm2ddl.auto"");
 			if (ddlAuto == null || ""none"".equals(ddlAuto)) {
 				return;
 			}
@@ -105,7 +105,7 @@ public LocalContainerEntityManagerFactoryBean entityManagerFactory(
 
 	protected abstract AbstractJpaVendorAdapter createJpaVendorAdapter();
 
-	protected abstract Map<String, Object> getVendorProperties();
+	protected abstract Map<String, String> getVendorProperties();
 
 	protected abstract EntityManagerFactoryBuilder.EntityManagerFactoryBeanCallback getVendorCallback();
 
@@ -40,7 +40,7 @@ public class JpaProperties {
 
 	private static final Log logger = LogFactory.getLog(JpaProperties.class);
 
-	private Map<String, Object> properties = new HashMap<String, Object>();
+	private Map<String, String> properties = new HashMap<String, String>();
 
 	private String databasePlatform;
 
@@ -52,11 +52,11 @@ public class JpaProperties {
 
 	private Hibernate hibernate = new Hibernate();
 
-	public Map<String, Object> getProperties() {
+	public Map<String, String> getProperties() {
 		return this.properties;
 	}
 
-	public void setProperties(Map<String, Object> properties) {
+	public void setProperties(Map<String, String> properties) {
 		this.properties = properties;
 	}
 
@@ -107,7 +107,7 @@ public void setHibernate(Hibernate hibernate) {
 	 * @param dataSource the DataSource in case it is needed to determine the properties
 	 * @return some Hibernate properties for configuration
 	 */
-	public Map<String, Object> getInitialHibernateProperties(DataSource dataSource) {
+	public Map<String, String> getInitialHibernateProperties(DataSource dataSource) {
 		return this.hibernate.getAdditionalProperties(this.properties);
 	}
 
@@ -116,7 +116,7 @@ public Map<String, Object> getInitialHibernateProperties(DataSource dataSource)
 	 * @param dataSource the DataSource in case it is needed to determine the properties
 	 * @return some Hibernate properties for configuration
 	 */
-	public Map<String, Object> getHibernateProperties(DataSource dataSource) {
+	public Map<String, String> getHibernateProperties(DataSource dataSource) {
 		return this.hibernate
 				.getDeferredAdditionalProperties(this.properties, dataSource);
 	}
@@ -158,7 +158,7 @@ public boolean isDeferDdl() {
 			return this.deferDdl;
 		}
 
-		private String getDeferredDdlAuto(Map<String, Object> existing,
+		private String getDeferredDdlAuto(Map<String, String> existing,
 				DataSource dataSource) {
 			if (!this.deferDdl) {
 				return ""none"";
@@ -169,7 +169,7 @@ private String getDeferredDdlAuto(Map<String, Object> existing,
 				return ddlAuto;
 			}
 			if (isAlreadyProvided(existing, ""hbm2ddl.auto"")) {
-				return (String) existing.get(""hibernate.hbm2ddl.auto"");
+				return existing.get(""hibernate.hbm2ddl.auto"");
 			}
 			return ""none"";
 		}
@@ -178,16 +178,16 @@ public void setDdlAuto(String ddlAuto) {
 			this.ddlAuto = ddlAuto;
 		}
 
-		private Map<String, Object> getDeferredAdditionalProperties(
-				Map<String, Object> properties, DataSource dataSource) {
-			Map<String, Object> deferred = getAdditionalProperties(properties);
+		private Map<String, String> getDeferredAdditionalProperties(
+				Map<String, String> properties, DataSource dataSource) {
+			Map<String, String> deferred = getAdditionalProperties(properties);
 			deferred.put(""hibernate.hbm2ddl.auto"",
 					getDeferredDdlAuto(properties, dataSource));
 			return deferred;
 		}
 
-		private Map<String, Object> getAdditionalProperties(Map<String, Object> existing) {
-			Map<String, Object> result = new HashMap<String, Object>();
+		private Map<String, String> getAdditionalProperties(Map<String, String> existing) {
+			Map<String, String> result = new HashMap<String, String>();
 			if (!isAlreadyProvided(existing, ""ejb.naming_strategy"")
 					&& this.namingStrategy != null) {
 				result.put(""hibernate.ejb.naming_strategy"", this.namingStrategy.getName());
@@ -205,7 +205,7 @@ else if (this.namingStrategy == null) {
 			return result;
 		}
 
-		private boolean isAlreadyProvided(Map<String, Object> existing, String key) {
+		private boolean isAlreadyProvided(Map<String, String> existing, String key) {
 			return existing.containsKey(""hibernate."" + key);
 		}
 
@@ -139,14 +139,15 @@ public void testOpenEntityManagerInViewInterceptorNotRegisteredWhenExplicitlyOff
 	@Test
 	public void customJpaProperties() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.context, ""spring.jpa.properties.a:b"",
-				""spring.jpa.properties.c:d"");
+				""spring.jpa.properties.a.b:c"", ""spring.jpa.properties.c:d"");
 		setupTestConfiguration();
 		this.context.refresh();
 		LocalContainerEntityManagerFactoryBean bean = this.context
 				.getBean(LocalContainerEntityManagerFactoryBean.class);
 		Map<String, Object> map = bean.getJpaPropertyMap();
 		assertThat(map.get(""a""), equalTo((Object) ""b""));
 		assertThat(map.get(""c""), equalTo((Object) ""d""));
+		assertThat(map.get(""a.b""), equalTo((Object) ""c""));
 	}
 
 	@Test
@@ -61,7 +61,7 @@ public void testDefaultDdlAutoForMySql() throws Exception {
 		this.context.refresh();
 		JpaProperties bean = this.context.getBean(JpaProperties.class);
 		DataSource dataSource = this.context.getBean(DataSource.class);
-		String actual = (String) bean.getHibernateProperties(dataSource).get(
+		String actual = bean.getHibernateProperties(dataSource).get(
 				""hibernate.hbm2ddl.auto"");
 		// Default is generic and safe
 		assertThat(actual, equalTo(""none""));
@@ -78,7 +78,7 @@ public void testDefaultDdlAutoForEmbedded() throws Exception {
 		this.context.refresh();
 		JpaProperties bean = this.context.getBean(JpaProperties.class);
 		DataSource dataSource = this.context.getBean(DataSource.class);
-		String actual = (String) bean.getHibernateProperties(dataSource).get(
+		String actual = bean.getHibernateProperties(dataSource).get(
 				""hibernate.hbm2ddl.auto"");
 		assertThat(actual, equalTo(""create-drop""));
 	}
@@ -47,7 +47,7 @@ public void entityManagerFactoryPropertiesNotOverwritingDefaults() {
 				new HibernateJpaVendorAdapter(), this.properties, null);
 		LocalContainerEntityManagerFactoryBean result1 = factory
 				.dataSource(this.dataSource1)
-				.properties(Collections.singletonMap(""foo"", (Object) ""spam"")).build();
+				.properties(Collections.singletonMap(""foo"", ""spam"")).build();
 		assertFalse(result1.getJpaPropertyMap().isEmpty());
 		assertTrue(this.properties.getProperties().isEmpty());
 	}
@@ -58,7 +58,7 @@ public void multipleEntityManagerFactoriesDoNotOverwriteEachOther() {
 				new HibernateJpaVendorAdapter(), this.properties, null);
 		LocalContainerEntityManagerFactoryBean result1 = factory
 				.dataSource(this.dataSource1)
-				.properties(Collections.singletonMap(""foo"", (Object) ""spam"")).build();
+				.properties(Collections.singletonMap(""foo"", ""spam"")).build();
 		assertFalse(result1.getJpaPropertyMap().isEmpty());
 		LocalContainerEntityManagerFactoryBean result2 = factory.dataSource(
 				this.dataSource2).build();
"
https://github.com/junit-team/junit4/commit/2568203bdebd5a4a4ad9aa74b1d8369d22f668a3,Replaced IllegalArgumentException for IOException  <enter> It's more consistent to throw an IOException instead of an IllegalArgumentException ,https://api.github.com/repos/junit-team/junit4/commits/2568203bdebd5a4a4ad9aa74b1d8369d22f668a3,"@@ -61,7 +61,7 @@ public void create() throws IOException {
 	public File newFile(String fileName) throws IOException {
 		File file= new File(getRoot(), fileName);
 		if (!file.createNewFile())
-			throw new IllegalArgumentException(
+			throw new IOException(
 					""a file with the name \'"" + fileName + ""\' already exists in the test folder"");
 		return file;
 	}
@@ -77,21 +77,21 @@ public File newFile() throws IOException {
 	 * Returns a new fresh folder with the given name under the temporary
 	 * folder.
 	 */
-	public File newFolder(String folder) {
+	public File newFolder(String folder) throws IOException {
 		return newFolder(new String[]{folder});
 	}
 
 	/**
 	 * Returns a new fresh folder with the given name(s) under the temporary
 	 * folder.
 	 */
-	public File newFolder(String... folderNames) {
+	public File newFolder(String... folderNames) throws IOException {
 		File file= getRoot();
 		for (int i = 0; i < folderNames.length; i++) {
 			String folderName = folderNames[i];
 			file = new File(file, folderName);
 			if (!file.mkdir() && isLastElementInArray(i, folderNames))
-				throw new IllegalArgumentException(
+				throw new IOException(
 						""a folder with the name \'"" + folderName + ""\' already exists"");
 		}
 		return file;
@@ -217,7 +217,7 @@ public void testNewFile() throws IOException {
 		}
 
 		@Test
-		public void testNewFolder() {
+		public void testNewFolder() throws IOException {
 			folder.newFolder(NEW_FOLDER_DUMMY);
 		}
 	}
@@ -59,7 +59,7 @@ public void newFileWithGivenFilenameThrowsIllegalArgumentExceptionIfFileExists()
 		tempFolder.create();
 		tempFolder.newFile(""MyFile.txt"");
 
-		thrown.expect(IllegalArgumentException.class);
+		thrown.expect(IOException.class);
 		thrown.expectMessage(""a file with the name 'MyFile.txt' already exists in the test folder"");
 		tempFolder.newFile(""MyFile.txt"");
 	}
@@ -71,7 +71,7 @@ public void newFolderThrowsIllegalStateExceptionIfCreateWasNotInvoked()
 	}
 
 	@Test(expected= IllegalStateException.class)
-	public void newFolderWithGivenPathThrowsIllegalStateExceptionIfCreateWasNotInvoked() {
+	public void newFolderWithGivenPathThrowsIllegalStateExceptionIfCreateWasNotInvoked() throws IOException {
 		new TemporaryFolder().newFolder(""level1"", ""level2"", ""level3"");
 	}
 
@@ -80,7 +80,7 @@ public void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists
 		tempFolder.create();
 		tempFolder.newFolder(""level1"");
 
-		thrown.expect(IllegalArgumentException.class);
+		thrown.expect(IOException.class);
 		thrown.expectMessage(""a folder with the name 'level1' already exists"");
 		tempFolder.newFolder(""level1"");
 	}
@@ -90,7 +90,7 @@ public void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfPathExists() t
 		tempFolder.create();
 		tempFolder.newFolder(""level1"", ""level2"", ""level3"");
 
-		thrown.expect(IllegalArgumentException.class);
+		thrown.expect(IOException.class);
 		thrown.expectMessage(""a folder with the name 'level3' already exists"");
 		tempFolder.newFolder(""level1"", ""level2"", ""level3"");
 	}
"
https://github.com/square/retrofit/commit/1d64f9763e1f5aa3d049710df8366f425109672f,Use a dummy value to further validation optional delegation  <enter> Prior to this other things might cause a null value. This ensures the value can only come from only place. ,https://api.github.com/repos/square/retrofit/commits/1d64f9763e1f5aa3d049710df8366f425109672f,"@@ -68,6 +68,7 @@ interface Service {
   }
 
   @Test public void delegates() throws IOException {
+    final Object object = new Object();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url(""/""))
         .addConverterFactory(new Converter.Factory() {
@@ -78,7 +79,7 @@ interface Service {
             }
             return new Converter<ResponseBody, Object>() {
               @Override public Object convert(ResponseBody value) {
-                return null;
+                return object;
               }
             };
           }
@@ -91,6 +92,6 @@ interface Service {
     Service service = retrofit.create(Service.class);
     Optional<Object> optional = service.optional().execute().body();
     assertThat(optional).isNotNull();
-    assertThat(optional.isPresent()).isFalse();
+    assertThat(optional.get()).isSameAs(object);
   }
 }
@@ -68,6 +68,7 @@ interface Service {
   }
 
   @Test public void delegates() throws IOException {
+    Object object = new Object();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url(""/""))
         .addConverterFactory(new Converter.Factory() {
@@ -76,11 +77,7 @@ interface Service {
             if (getRawType(type) != Object.class) {
               return null;
             }
-            return new Converter<ResponseBody, Object>() {
-              @Override public Object convert(ResponseBody value) {
-                return null;
-              }
-            };
+            return value -> object;
           }
         })
         .addConverterFactory(Java8OptionalConverterFactory.create())
@@ -91,6 +88,6 @@ interface Service {
     Service service = retrofit.create(Service.class);
     Optional<Object> optional = service.optional().execute().body();
     assertThat(optional).isNotNull();
-    assertThat(optional.isPresent()).isFalse();
+    assertThat(optional.get()).isSameAs(object);
   }
 }
"
https://github.com/apache/dubbo/commit/9157beac5da52530fc6336e419bf02d57e9cce6c,refactor package  <enter> git-svn-id:  http://code.alibabatech.com/svn/dubbo/trunk@1386  1a56cb94-b969-4eaa-88fa-be21384802f2 ,https://api.github.com/repos/apache/dubbo/commits/9157beac5da52530fc6336e419bf02d57e9cce6c,
https://github.com/spring-projects/spring-boot/commit/1a764d9c06f2a96722c04b8d8bb1edf89e424628,Default Tomcat to not save SESSIONS.ser file  <enter> Update TomcatEmbeddedServletContainerFactory so that session data isn't serialized by default. Prior to this commit the SESSIONS.ser file would either be written to `/tmp` or into `baseDir` (if one was set). <enter> By not saving session data we align Tomcat with the other embedded servlet containers and reduce the risk of sensitive information being left in `/tmp`. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/1a764d9c06f2a96722c04b8d8bb1edf89e424628,"@@ -394,18 +394,31 @@ protected void configureContext(Context context,
 	private void configureSession(Context context) {
 		long sessionTimeout = getSessionTimeoutInMinutes();
 		context.setSessionTimeout((int) sessionTimeout);
+		Manager manager = context.getManager();
+		if (manager == null) {
+			manager = new StandardManager();
+			context.setManager(manager);
+		}
 		if (isPersistSession()) {
-			Manager manager = context.getManager();
-			if (manager == null) {
-				manager = new StandardManager();
-				context.setManager(manager);
-			}
-			Assert.state(manager instanceof StandardManager,
-					""Unable to persist HTTP session state using manager type ""
-							+ manager.getClass().getName());
-			File folder = new ApplicationTemp().getFolder(""tomcat-sessions"");
-			File file = new File(folder, ""SESSIONS.ser"");
-			((StandardManager) manager).setPathname(file.getAbsolutePath());
+			configurePersistSession(manager);
+		}
+		else {
+			disablePersistSession(manager);
+		}
+	}
+
+	private void configurePersistSession(Manager manager) {
+		Assert.state(manager instanceof StandardManager,
+				""Unable to persist HTTP session state using manager type ""
+						+ manager.getClass().getName());
+		File folder = new ApplicationTemp().getFolder(""tomcat-sessions"");
+		File file = new File(folder, ""SESSIONS.ser"");
+		((StandardManager) manager).setPathname(file.getAbsolutePath());
+	}
+
+	private void disablePersistSession(Manager manager) {
+		if (manager instanceof StandardManager) {
+			((StandardManager) manager).setPathname(null);
 		}
 	}
 
@@ -723,7 +723,7 @@ public void service(ServletRequest request, ServletResponse response)
 		return bean;
 	}
 
-	private ServletContextInitializer sessionServletRegistration() {
+	protected final ServletContextInitializer sessionServletRegistration() {
 		ServletRegistrationBean bean = new ServletRegistrationBean(new ExampleServlet() {
 
 			@Override
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.context.embedded.tomcat;
 
+import java.io.File;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.ServerSocket;
@@ -45,6 +46,7 @@
 
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.not;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
@@ -333,6 +335,31 @@ public void useForwardHeaders() throws Exception {
 		assertForwardHeaderIsUsed(factory);
 	}
 
+	@Test
+	public void disableDoesNotSaveSessionFiles() throws Exception {
+		File baseDir = this.temporaryFolder.newFolder();
+		TomcatEmbeddedServletContainerFactory factory = getFactory();
+		// If baseDir is not set SESSIONS.ser is written to a different temp folder
+		// each time. By setting it we can really ensure that data isn't saved
+		factory.setBaseDirectory(baseDir);
+		this.container = factory
+				.getEmbeddedServletContainer(sessionServletRegistration());
+		this.container.start();
+		String s1 = getResponse(getLocalUrl(""/session""));
+		String s2 = getResponse(getLocalUrl(""/session""));
+		this.container.stop();
+		this.container = factory
+				.getEmbeddedServletContainer(sessionServletRegistration());
+		this.container.start();
+		String s3 = getResponse(getLocalUrl(""/session""));
+		System.out.println(s1);
+		System.out.println(s2);
+		System.out.println(s3);
+		String message = ""Session error s1="" + s1 + "" s2="" + s2 + "" s3="" + s3;
+		assertThat(message, s2.split("":"")[0], equalTo(s1.split("":"")[1]));
+		assertThat(message, s3.split("":"")[0], not(equalTo(s2.split("":"")[1])));
+	}
+
 	@Override
 	protected Wrapper getJspServlet() {
 		Container context = ((TomcatEmbeddedServletContainer) this.container).getTomcat()
"
https://github.com/square/okhttp/commit/02b08fbde7b1726d7a4c0dc971152751ac82ca0a,"Allow HTAB in header values.  <enter> RFC 7230 section 3.2 allows HTAB ('	', 'u0009') inside header values as long as there is not more than one in a row:    https://tools.ietf.org/html/rfc7230#section-3.2  <enter> Before this CL, OkHttp previously disallowed HTAB in header values. This CL changes behavior to allow any number of consecutive HTABs inside a header value; this is more permissive than the RFC, but is consistent with how OkHttp currently treats space characters (' ', 'u0020'). ",https://api.github.com/repos/square/okhttp/commits/02b08fbde7b1726d7a4c0dc971152751ac82ca0a,"@@ -75,10 +75,12 @@ public final class HeadersTest {
         .add(""foo: bar"")
         .add("" foo: baz"") // Name leading whitespace is trimmed.
         .add(""foo : bak"") // Name trailing whitespace is trimmed.
+        .add(""\tkey\t:\tvalue\t"") // '\t' also counts as whitespace
         .add(""ping:  pong  "") // Value whitespace is trimmed.
         .add(""kit:kat"") // Space after colon is not required.
         .build();
     assertEquals(Arrays.asList(""bar"", ""baz"", ""bak""), headers.values(""foo""));
+    assertEquals(Arrays.asList(""value""), headers.values(""key""));
     assertEquals(Arrays.asList(""pong""), headers.values(""ping""));
     assertEquals(Arrays.asList(""kat""), headers.values(""kit""));
   }
@@ -198,11 +198,20 @@ public final class RequestTest {
     }
   }
 
+  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header(""key"", ""sample\tvalue"");
+    try {
+      builder.header(""sample\tkey"", ""value"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   @Test public void headerForbidsControlCharacters() throws Exception {
     assertForbiddenHeader(""\u0000"");
     assertForbiddenHeader(""\r"");
     assertForbiddenHeader(""\n"");
-    assertForbiddenHeader(""\t"");
     assertForbiddenHeader(""\u001f"");
     assertForbiddenHeader(""\u007f"");
     assertForbiddenHeader(""\u0080"");
@@ -316,7 +316,7 @@ private void checkNameAndValue(String name, String value) {
       if (value == null) throw new NullPointerException(""value == null"");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
-        if (c <= '\u001f' || c >= '\u007f') {
+        if ((c <= '\u001f' && c != '\u0009' /* htab */) || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               ""Unexpected char %#04x at %d in %s value: %s"", (int) c, i, name, value));
         }
"
https://github.com/spring-projects/spring-boot/commit/985c8f75982da4fabc1c8a5958a57706d4d4feab,Polish RSocket support ,https://api.github.com/repos/spring-projects/spring-boot/commits/985c8f75982da4fabc1c8a5958a57706d4d4feab,"@@ -44,7 +44,7 @@
 @AutoConfigureAfter(RSocketStrategiesAutoConfiguration.class)
 public class RSocketMessagingAutoConfiguration {
 
-	private static String PATHPATTERN_ROUTEMATCHER_CLASS = ""org.springframework.web.util.pattern.PathPatternRouteMatcher"";
+	private static final String PATHPATTERN_ROUTEMATCHER_CLASS = ""org.springframework.web.util.pattern.PathPatternRouteMatcher"";
 
 	@Bean
 	@ConditionalOnMissingBean
@@ -35,7 +35,7 @@ public Server getServer() {
 		return this.server;
 	}
 
-	static class Server {
+	public static class Server {
 
 		/**
 		 * Server port.
@@ -48,7 +48,7 @@ public class RSocketRequesterAutoConfiguration {
 	@Bean
 	@Scope(""prototype"")
 	@ConditionalOnMissingBean
-	public RSocketRequester.Builder rsocketRequesterBuilder(RSocketStrategies strategies) {
+	public RSocketRequester.Builder rSocketRequesterBuilder(RSocketStrategies strategies) {
 		return RSocketRequester.builder().rsocketStrategies(strategies);
 	}
 
@@ -81,7 +81,7 @@ static class EmbeddedServerAutoConfiguration {
 
 		@Bean
 		@ConditionalOnMissingBean
-		public ReactorResourceFactory reactorServerResourceFactory() {
+		public ReactorResourceFactory reactorResourceFactory() {
 			return new ReactorResourceFactory();
 		}
 
@@ -109,7 +109,7 @@ public RSocketServerBootstrap rSocketServerBootstrap(RSocketServerFactory rSocke
 	static class OnRSocketWebServerCondition extends AllNestedConditions {
 
 		OnRSocketWebServerCondition() {
-			super(ConfigurationPhase.REGISTER_BEAN);
+			super(ConfigurationPhase.PARSE_CONFIGURATION);
 		}
 
 		@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@@ -76,7 +76,7 @@ protected static class JacksonCborStrategyConfiguration {
 		@Bean
 		@Order(0)
 		@ConditionalOnBean(Jackson2ObjectMapperBuilder.class)
-		public RSocketStrategiesCustomizer jacksonCborStrategyCustomizer(Jackson2ObjectMapperBuilder builder) {
+		public RSocketStrategiesCustomizer jacksonCborRSocketStrategyCustomizer(Jackson2ObjectMapperBuilder builder) {
 			return (strategy) -> {
 				ObjectMapper objectMapper = builder.factory(new CBORFactory()).build();
 				strategy.decoder(new Jackson2CborDecoder(objectMapper, SUPPORTED_TYPES));
@@ -96,7 +96,7 @@ protected static class JacksonJsonStrategyConfiguration {
 		@Bean
 		@Order(1)
 		@ConditionalOnBean(ObjectMapper.class)
-		public RSocketStrategiesCustomizer jacksonJsonStrategyCustomizer(ObjectMapper objectMapper) {
+		public RSocketStrategiesCustomizer jacksonJsonRSocketStrategyCustomizer(ObjectMapper objectMapper) {
 			return (strategy) -> {
 				strategy.decoder(new Jackson2JsonDecoder(objectMapper, SUPPORTED_TYPES));
 				strategy.encoder(new Jackson2JsonEncoder(objectMapper, SUPPORTED_TYPES));
@@ -37,7 +37,7 @@
  */
 class RSocketMessagingAutoConfigurationTests {
 
-	private ApplicationContextRunner contextRunner = new ApplicationContextRunner()
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
 			.withConfiguration(AutoConfigurations.of(RSocketMessagingAutoConfiguration.class))
 			.withUserConfiguration(BaseConfiguration.class);
 
@@ -67,7 +67,7 @@ void shouldUseCustomMessageHandlerAcceptor() {
 						.containsOnly(""customMessageHandlerAcceptor""));
 	}
 
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class BaseConfiguration {
 
 		@Bean
@@ -78,7 +78,7 @@ public RSocketStrategies rSocketStrategies() {
 
 	}
 
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class CustomMessageHandlerAcceptor {
 
 		@Bean
@@ -34,7 +34,7 @@
  */
 class RSocketRequesterAutoConfigurationTests {
 
-	private ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
 			AutoConfigurations.of(RSocketStrategiesAutoConfiguration.class, RSocketRequesterAutoConfiguration.class));
 
 	@Test
@@ -42,22 +42,20 @@ class RSocketServerAutoConfigurationTests {
 
 	@Test
 	void shouldNotCreateBeansByDefault() {
-		ApplicationContextRunner contextRunner = createContextRunner();
-		contextRunner.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
+		contextRunner().run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
 				.doesNotHaveBean(RSocketServerFactory.class).doesNotHaveBean(RSocketServerBootstrap.class));
 	}
 
 	@Test
 	void shouldNotCreateDefaultBeansForReactiveWebAppWithoutMapping() {
-		ReactiveWebApplicationContextRunner contextRunner = createReactiveWebContextRunner();
-		contextRunner.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
-				.doesNotHaveBean(RSocketServerFactory.class).doesNotHaveBean(RSocketServerBootstrap.class));
+		reactiveWebContextRunner()
+				.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
+						.doesNotHaveBean(RSocketServerFactory.class).doesNotHaveBean(RSocketServerBootstrap.class));
 	}
 
 	@Test
 	void shouldNotCreateDefaultBeansForReactiveWebAppWithWrongTransport() {
-		ReactiveWebApplicationContextRunner contextRunner = createReactiveWebContextRunner();
-		contextRunner
+		reactiveWebContextRunner()
 				.withPropertyValues(""spring.rsocket.server.transport=tcp"",
 						""spring.rsocket.server.mapping-path=/rsocket"")
 				.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
@@ -66,31 +64,30 @@ void shouldNotCreateDefaultBeansForReactiveWebAppWithWrongTransport() {
 
 	@Test
 	void shouldCreateDefaultBeansForReactiveWebApp() {
-		ReactiveWebApplicationContextRunner contextRunner = createReactiveWebContextRunner();
-		contextRunner
+		reactiveWebContextRunner()
 				.withPropertyValues(""spring.rsocket.server.transport=websocket"",
 						""spring.rsocket.server.mapping-path=/rsocket"")
 				.run((context) -> assertThat(context).hasSingleBean(RSocketWebSocketNettyRouteProvider.class));
 	}
 
 	@Test
 	void shouldCreateDefaultBeansForRSocketServerWhenPortIsSet() {
-		ReactiveWebApplicationContextRunner contextRunner = createReactiveWebContextRunner();
-		contextRunner.withPropertyValues(""spring.rsocket.server.port=0"").run((context) -> assertThat(context)
-				.hasSingleBean(RSocketServerFactory.class).hasSingleBean(RSocketServerBootstrap.class));
+		reactiveWebContextRunner().withPropertyValues(""spring.rsocket.server.port=0"")
+				.run((context) -> assertThat(context).hasSingleBean(RSocketServerFactory.class)
+						.hasSingleBean(RSocketServerBootstrap.class));
 	}
 
-	private ApplicationContextRunner createContextRunner() {
+	private ApplicationContextRunner contextRunner() {
 		return new ApplicationContextRunner().withUserConfiguration(BaseConfiguration.class)
 				.withConfiguration(AutoConfigurations.of(RSocketServerAutoConfiguration.class));
 	}
 
-	private ReactiveWebApplicationContextRunner createReactiveWebContextRunner() {
+	private ReactiveWebApplicationContextRunner reactiveWebContextRunner() {
 		return new ReactiveWebApplicationContextRunner().withUserConfiguration(BaseConfiguration.class)
 				.withConfiguration(AutoConfigurations.of(RSocketServerAutoConfiguration.class));
 	}
 
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class BaseConfiguration {
 
 		@Bean
@@ -16,10 +16,10 @@
 
 package org.springframework.boot.autoconfigure.rsocket;
 
-import com.fasterxml.jackson.databind.ObjectMapper;
 import org.junit.jupiter.api.Test;
 
 import org.springframework.boot.autoconfigure.AutoConfigurations;
+import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;
 import org.springframework.boot.rsocket.messaging.RSocketStrategiesCustomizer;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;
 import org.springframework.context.annotation.Bean;
@@ -32,7 +32,6 @@
 import org.springframework.http.codec.cbor.Jackson2CborEncoder;
 import org.springframework.http.codec.json.Jackson2JsonDecoder;
 import org.springframework.http.codec.json.Jackson2JsonEncoder;
-import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
 import org.springframework.messaging.rsocket.RSocketStrategies;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -44,9 +43,8 @@
  */
 class RSocketStrategiesAutoConfigurationTests {
 
-	private ApplicationContextRunner contextRunner = new ApplicationContextRunner()
-			.withUserConfiguration(BaseConfiguration.class)
-			.withConfiguration(AutoConfigurations.of(RSocketStrategiesAutoConfiguration.class));
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
+			AutoConfigurations.of(JacksonAutoConfiguration.class, RSocketStrategiesAutoConfiguration.class));
 
 	@Test
 	void shouldCreateDefaultBeans() {
@@ -82,22 +80,7 @@ void shouldUseStrategiesCustomizer() {
 		});
 	}
 
-	@Configuration
-	static class BaseConfiguration {
-
-		@Bean
-		public ObjectMapper objectMapper() {
-			return new ObjectMapper();
-		}
-
-		@Bean
-		public Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder() {
-			return new Jackson2ObjectMapperBuilder();
-		}
-
-	}
-
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class UserStrategies {
 
 		@Bean
@@ -108,7 +91,7 @@ public RSocketStrategies customRSocketStrategies() {
 
 	}
 
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class StrategiesCustomizer {
 
 		@Bean
"
https://github.com/square/okhttp/commit/0137eb9dbad165caea7189c5c3e09382563ef8bd,Remove unnecessary use of grouping parentheses  <enter> Let's remove warnings found by errorprone. <enter> - attempt ``` okhttp/okhttp/src/test/java/okhttp3/CallTest.java:2056: warning: [UnnecessaryParentheses] Unnecessary use of grouping parentheses             sink.writeUtf8('attempt ' + (attempt++));                                         ^     (see  https://errorprone.info/bugpattern/UnnecessaryParentheses )   Did you mean 'sink.writeUtf8('attempt ' + attempt++);'? ``` <enter> - isEaualTo ``` okhttp/src/test/java/okhttp3/OkHttpClientTest.java:287: warning: [UnnecessaryParentheses] Unnecessary use of grouping parentheses       assertThat(expected.getMessage()).isEqualTo(('protocols must not contain null'));                                                   ^     (see  https://errorprone.info/bugpattern/UnnecessaryParentheses ) ``` ,https://api.github.com/repos/square/okhttp/commits/0137eb9dbad165caea7189c5c3e09382563ef8bd,"@@ -2022,7 +2022,7 @@ public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exceptio
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8(""attempt "" + (attempt++));
+            sink.writeUtf8(""attempt "" + attempt++);
           }
         })
         .build();
@@ -2053,7 +2053,7 @@ public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exceptio
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8(""attempt "" + (attempt++));
+            sink.writeUtf8(""attempt "" + attempt++);
           }
 
           @Override public boolean isOneShot() {
@@ -284,7 +284,7 @@ public final class OkHttpClientTest {
       new OkHttpClient.Builder().protocols(protocols);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo((""protocols must not contain null""));
+      assertThat(expected.getMessage()).isEqualTo(""protocols must not contain null"");
     }
   }
 
"
https://github.com/spring-projects/spring-boot/commit/123ffd736c0a435f24f8d9c647e5d384de8cab4a,Exclude @ManagedResources from Endpoint MBeans  <enter> If an Endpoint is already @ManagedResource then it doesn't need an additional (probably wrong) MBEan registration based on the invoke() method. ,https://api.github.com/repos/spring-projects/spring-boot/commits/123ffd736c0a435f24f8d9c647e5d384de8cab4a,"@@ -38,9 +38,11 @@
 import org.springframework.context.ApplicationContextAware;
 import org.springframework.context.ApplicationListener;
 import org.springframework.context.SmartLifecycle;
+import org.springframework.core.annotation.AnnotationUtils;
 import org.springframework.jmx.export.MBeanExportException;
 import org.springframework.jmx.export.MBeanExporter;
 import org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource;
+import org.springframework.jmx.export.annotation.ManagedResource;
 import org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler;
 import org.springframework.jmx.export.naming.MetadataNamingStrategy;
 import org.springframework.jmx.export.naming.SelfNaming;
@@ -144,6 +146,18 @@ protected void locateAndRegisterEndpoints() {
 	}
 
 	protected void registerEndpoint(String beanName, Endpoint<?> endpoint) {
+		@SuppressWarnings(""rawtypes"")
+		Class<? extends Endpoint> type = endpoint.getClass();
+		if (AnnotationUtils.findAnnotation(type, ManagedResource.class) != null) {
+			// Already managed
+			return;
+		}
+		if (type.isMemberClass()
+				&& AnnotationUtils.findAnnotation(type.getEnclosingClass(),
+						ManagedResource.class) != null) {
+			// Nested class with @ManagedResource in parent
+			return;
+		}
 		try {
 			registerBeanNameOrInstance(getEndpointMBean(beanName, endpoint), beanName);
 		}
@@ -19,12 +19,14 @@
 import org.springframework.boot.actuate.endpoint.Endpoint;
 import org.springframework.boot.actuate.endpoint.ShutdownEndpoint;
 import org.springframework.jmx.export.annotation.ManagedOperation;
+import org.springframework.jmx.export.annotation.ManagedResource;
 
 /**
  * Special endpoint wrapper for {@link ShutdownEndpoint}.
  * 
  * @author Christian Dupuis
  */
+@ManagedResource
 public class ShutdownEndpointMBean extends EndpointMBean {
 
 	public ShutdownEndpointMBean(String beanName, Endpoint<?> endpoint) {
@@ -25,18 +25,26 @@
 import org.junit.After;
 import org.junit.Test;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
+import org.springframework.boot.actuate.endpoint.AbstractEndpoint;
+import org.springframework.boot.actuate.endpoint.Endpoint;
 import org.springframework.boot.actuate.endpoint.jmx.EndpointMBeanExporter;
+import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
 import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.EnableMBeanExport;
 import org.springframework.jmx.export.MBeanExporter;
+import org.springframework.jmx.export.annotation.ManagedResource;
 import org.springframework.jmx.support.ObjectNameManager;
 import org.springframework.mock.env.MockEnvironment;
+import org.springframework.stereotype.Component;
 import org.springframework.util.ObjectUtils;
 
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
@@ -55,13 +63,51 @@ public void close() {
 	}
 
 	@Test
-	public void testEndpointMBeanExporterIsInstalled() {
+	public void testEndpointMBeanExporterIsInstalled() throws Exception {
 		this.context = new AnnotationConfigApplicationContext();
 		this.context.register(TestConfiguration.class, JmxAutoConfiguration.class,
 				EndpointAutoConfiguration.class,
-				EndpointMBeanExportAutoConfiguration.class);
+				EndpointMBeanExportAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
+		this.context.refresh();
+		assertNotNull(this.context.getBean(EndpointMBeanExporter.class));
+		MBeanExporter mbeanExporter = this.context.getBean(EndpointMBeanExporter.class);
+
+		assertFalse(mbeanExporter.getServer()
+				.queryNames(getObjectName(""*"", ""*,*"", this.context), null).isEmpty());
+	}
+
+	@Test
+	public void testEndpointMBeanExporterIsNotInstalledIfManagedResource()
+			throws Exception {
+		this.context = new AnnotationConfigApplicationContext();
+		this.context.register(TestConfiguration.class, JmxAutoConfiguration.class,
+				ManagedEndpoint.class, EndpointMBeanExportAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
+		this.context.refresh();
+		assertNotNull(this.context.getBean(EndpointMBeanExporter.class));
+
+		MBeanExporter mbeanExporter = this.context.getBean(EndpointMBeanExporter.class);
+
+		assertTrue(mbeanExporter.getServer()
+				.queryNames(getObjectName(""*"", ""*,*"", this.context), null).isEmpty());
+	}
+
+	@Test
+	public void testEndpointMBeanExporterIsNotInstalledIfNestedInManagedResource()
+			throws Exception {
+		this.context = new AnnotationConfigApplicationContext();
+		this.context.register(TestConfiguration.class, JmxAutoConfiguration.class,
+				NestedInManagedEndpoint.class,
+				EndpointMBeanExportAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
 		this.context.refresh();
 		assertNotNull(this.context.getBean(EndpointMBeanExporter.class));
+
+		MBeanExporter mbeanExporter = this.context.getBean(EndpointMBeanExporter.class);
+
+		assertTrue(mbeanExporter.getServer()
+				.queryNames(getObjectName(""*"", ""*,*"", this.context), null).isEmpty());
 	}
 
 	@Test(expected = NoSuchBeanDefinitionException.class)
@@ -125,21 +171,23 @@ public void testEndpointMBeanExporterInParentChild() throws IntrospectionExcepti
 
 	private ObjectName getObjectName(String domain, String beanKey,
 			ApplicationContext applicationContext) throws MalformedObjectNameException {
+		String name = ""%s:type=Endpoint,name=%s"";
+		if (applicationContext.getParent() != null) {
+			name = name + "",context=%s"";
+		}
+		if (applicationContext.getEnvironment().getProperty(""endpoints.jmx.unique_names"",
+				Boolean.class, false)) {
+			name = name
+					+ "",identity=""
+					+ ObjectUtils.getIdentityHexString(applicationContext
+							.getBean(beanKey));
+		}
 		if (applicationContext.getParent() != null) {
-			return ObjectNameManager
-					.getInstance(String.format(
-							""%s:type=Endpoint,name=%s,context=%s,identity=%s"", domain,
-							beanKey,
-							ObjectUtils.getIdentityHexString(applicationContext),
-							ObjectUtils.getIdentityHexString(applicationContext
-									.getBean(beanKey))));
+			return ObjectNameManager.getInstance(String.format(name, domain, beanKey,
+					ObjectUtils.getIdentityHexString(applicationContext)));
 		}
 		else {
-			return ObjectNameManager
-					.getInstance(String.format(""%s:type=Endpoint,name=%s,identity=%s"",
-							domain, beanKey, ObjectUtils
-									.getIdentityHexString(applicationContext
-											.getBean(beanKey))));
+			return ObjectNameManager.getInstance(String.format(name, domain, beanKey));
 		}
 	}
 
@@ -148,4 +196,43 @@ private ObjectName getObjectName(String domain, String beanKey,
 	public static class TestConfiguration {
 
 	}
+
+	@Component
+	@ManagedResource
+	protected static class ManagedEndpoint extends AbstractEndpoint<Boolean> {
+
+		public ManagedEndpoint() {
+			super(""managed"", true, true);
+		}
+
+		@Override
+		public Boolean invoke() {
+			return true;
+		}
+
+	}
+
+	@Configuration
+	@ManagedResource
+	protected static class NestedInManagedEndpoint {
+
+		@Bean
+		public Endpoint<Boolean> nested() {
+			return new Nested();
+		}
+
+		class Nested extends AbstractEndpoint<Boolean> {
+
+			public Nested() {
+				super(""managed"", true, true);
+			}
+
+			@Override
+			public Boolean invoke() {
+				return true;
+			}
+		}
+
+	}
+
 }
"
https://github.com/junit-team/junit4/commit/13bda470bfa1fe989ce80d616fb096af1b937146,Make ParallelComputer more beautiful by creating a Decorator  <enter> extension point in ParentRunner <enter> Signed-off-by: Kent Beck <kent@threeriversinstitute.org> ,https://api.github.com/repos/junit-team/junit4/commits/13bda470bfa1fe989ce80d616fb096af1b937146,"@@ -8,14 +8,9 @@
 import java.util.concurrent.Future;
 
 import org.junit.runner.Computer;
-import org.junit.runner.Description;
 import org.junit.runner.Runner;
-import org.junit.runner.notification.RunNotifier;
-import org.junit.runners.BlockJUnit4ClassRunner;
 import org.junit.runners.ParentRunner;
-import org.junit.runners.Suite;
-import org.junit.runners.model.InitializationError;
-import org.junit.runners.model.RunnerBuilder;
+import org.junit.tests.SafeStatement;
 
 public class ParallelComputer extends Computer {
 	private final boolean fClasses;
@@ -35,69 +30,50 @@ public static Computer methods() {
 		return new ParallelComputer(false, true);
 	}
 
-	private static <T> Runner parallelize(ParentRunner<T> runner)
-			throws InitializationError {
-		return new ParallelParentRunner<T>(runner);
+	private static void parallelize(Runner runner) {
+		((ParentRunner<?>) runner).installDecorator(new ParentRunner.Decorator() {
+			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();
+
+			private final ExecutorService fService= Executors
+					.newCachedThreadPool();
+
+			public void runAll(SafeStatement statement) {
+				statement.execute();
+				for (Future<Object> each : fResults)
+					try {
+						each.get();
+					} catch (Exception e) {
+						e.printStackTrace();
+					}
+
+			}
+
+			public void runChild(final SafeStatement statement) {
+				fResults.add(fService.submit(new Callable<Object>() {
+					public Object call() throws Exception {
+						statement.execute();
+						return null;
+					}
+				}));
+			}
+		});
 	}
-
-	private static class ParallelParentRunner<T> extends ParentRunner<T> {
-		private final ParentRunner<T> fDelegate;
-
-		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();
-
-		private final ExecutorService fService= Executors.newCachedThreadPool();
-
-		public ParallelParentRunner(ParentRunner<T> delegate)
-				throws InitializationError {
-			super(delegate.getTestClass().getJavaClass());
-			fDelegate= delegate;
-		}
-
-		@Override
-		public Description describeChild(T child) {
-			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
-			return fDelegate.internalDescribeChild(child);
-		}
-
-		@Override
-		public List<T> getChildren() {
-			return fDelegate.internalGetChildren();
-		}
-
-		@Override
-		public void runChild(final T child, final RunNotifier notifier) {
-			fResults.add(fService.submit(new Callable<Object>() {
-				public Object call() throws Exception {
-					fDelegate.internalRunChild(child, notifier);
-					return null;
-				}
-			}));
-		}
-
-		@Override
-		public void run(RunNotifier notifier) {
-			super.run(notifier);
-			for (Future<Object> each : fResults)
-				try {
-					each.get();
-				} catch (Exception e) {
-					e.printStackTrace();
-				}
-		}
-	}
-
+	
 	@Override
-	public Runner getSuite(RunnerBuilder builder, java.lang.Class<?>[] classes)
-			throws InitializationError {
-		Suite suite= (Suite) super.getSuite(builder, classes);
-		return fClasses ? parallelize(suite) : suite;
+	protected Runner modify(Runner runner) {
+		if (shouldParallelize(runner))
+			parallelize(runner);
+		return runner;
 	}
 
-	@Override
-	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
-			throws Throwable {
-		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
-		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super.getRunner(builder, testClass);
-		return fMethods ? parallelize(runner) : runner;
+	private boolean shouldParallelize(Runner runner) {
+		if (runner instanceof ParentRunner) {
+			ParentRunner<?> parentRunner= (ParentRunner<?>) runner;
+			if (fClasses && parentRunner.isSuite())
+				return true;
+			if (fMethods && !parentRunner.isSuite())
+				return true;
+		}
+		return false;
 	}
 }
@@ -11,15 +11,19 @@ public static Computer serial() {
 
 	public Runner getSuite(final RunnerBuilder builder,
 			Class<?>[] classes) throws InitializationError {
-		return new Suite(new RunnerBuilder() {
+		return modify(new Suite(new RunnerBuilder() {
 			@Override
 			public Runner runnerForClass(Class<?> testClass) throws Throwable {
 				return getRunner(builder, testClass);
 			}
-		}, classes);
+		}, classes));
+	}
+
+	protected Runner modify(Runner runner) {
+		return runner;
 	}
 
 	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {
-		return builder.runnerForClass(testClass);
+		return modify(builder.runnerForClass(testClass));
 	}
 }
@@ -27,6 +27,7 @@
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.Statement;
 import org.junit.runners.model.TestClass;
+import org.junit.tests.SafeStatement;
 
 /**
  * Provides most of the functionality specific to a Runner that implements a
@@ -40,15 +41,32 @@
  */
 public abstract class ParentRunner<T> extends Runner implements Filterable,
 		Sortable {
+	public interface Decorator {
+		void runChild(SafeStatement statement);
+
+		void runAll(SafeStatement statement);
+	}
+
 	private final TestClass fTestClass;
 
 	private Filter fFilter= null;
 
 	private Sorter fSorter= Sorter.NULL;
 
+	private Decorator fDecorator= new Decorator() {
+		public void runAll(SafeStatement statement) {
+			statement.execute();
+		}
+
+		public void runChild(SafeStatement statement) {
+			statement.execute();
+		}
+	};
+
 	/**
 	 * Constructs a new {@code ParentRunner} that will run {@code @TestClass}
-	 * @throws InitializationError 
+	 * 
+	 * @throws InitializationError
 	 */
 	protected ParentRunner(Class<?> testClass) throws InitializationError {
 		fTestClass= new TestClass(testClass);
@@ -77,38 +95,40 @@ protected ParentRunner(Class<?> testClass) throws InitializationError {
 	 * reported through {@code notifier}
 	 */
 	protected abstract void runChild(T child, RunNotifier notifier);
-	
-	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows delegation without breaking subclasses
+
+	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows
+	// delegation without breaking subclasses
 	/**
-	 * Interim interface during 4.7 development.  _Very_ likely to go away.
+	 * Interim interface during 4.7 development. _Very_ likely to go away.
 	 */
 	public List<T> internalGetChildren() {
 		return getChildren();
 	}
 
 	/**
-	 * Interim interface during 4.7 development.  _Very_ likely to go away.
+	 * Interim interface during 4.7 development. _Very_ likely to go away.
 	 */
 	public Description internalDescribeChild(T child) {
 		return describeChild(child);
 	}
 
 	/**
-	 * Interim interface during 4.7 development.  _Very_ likely to go away.
+	 * Interim interface during 4.7 development. _Very_ likely to go away.
 	 */
 	public void internalRunChild(T child, RunNotifier notifier) {
 		runChild(child, notifier);
 	}
-	
+
 	//
 	// May be overridden
 	//
-	
+
 	/**
-	 * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).
-	 * Default implementation adds an error for each method annotated with
-	 * {@code @BeforeClass} or {@code @AfterClass} that is not
-	 * {@code public static void} with no arguments.
+	 * Adds to {@code errors} a throwable for each problem noted with the test
+	 * class (available from {@link #getTestClass()}). Default implementation
+	 * adds an error for each method annotated with {@code @BeforeClass} or
+	 * {@code @AfterClass} that is not {@code public static void} with no
+	 * arguments.
 	 */
 	protected void collectInitializationErrors(List<Throwable> errors) {
 		validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);
@@ -125,28 +145,33 @@ protected void collectInitializationErrors(List<Throwable> errors) {
 	 * <li>is static (given {@code isStatic is false}), or
 	 * <li>is not static (given {@code isStatic is true}).
 	 */
-	protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,
-			boolean isStatic, List<Throwable> errors) {
-		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(annotation);
+	protected void validatePublicVoidNoArgMethods(
+			Class<? extends Annotation> annotation, boolean isStatic,
+			List<Throwable> errors) {
+		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(
+				annotation);
 
 		for (FrameworkMethod eachTestMethod : methods)
 			eachTestMethod.validatePublicVoidNoArg(isStatic, errors);
 	}
 
-	/** 
-	 * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing. 
-	 * Here is an outline of the implementation:
+	/**
+	 * Constructs a {@code Statement} to run all of the tests in the test class.
+	 * Override to add pre-/post-processing. Here is an outline of the
+	 * implementation:
 	 * <ul>
-	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).</li>
-	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class
-	 * and superclasses before the previous step; if any throws an
+	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned
+	 * by {@link #getChildren()} (subject to any imposed filter and sort).</li>
+	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this
+	 * class and superclasses before the previous step; if any throws an
 	 * Exception, stop execution and pass the exception on.
-	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class
-	 * and superclasses before any of the previous steps; all AfterClass methods are
-	 * always executed: exceptions thrown by previous steps are combined, if
-	 * necessary, with exceptions from AfterClass methods into a
+	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this
+	 * class and superclasses before any of the previous steps; all AfterClass
+	 * methods are always executed: exceptions thrown by previous steps are
+	 * combined, if necessary, with exceptions from AfterClass methods into a
 	 * {@link MultipleFailureException}.
 	 * </ul>
+	 * 
 	 * @param notifier
 	 * @return {@code Statement}
 	 */
@@ -158,9 +183,9 @@ protected Statement classBlock(final RunNotifier notifier) {
 	}
 
 	/**
-	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class
-	 * and superclasses before executing {@code statement}; if any throws an
-	 * Exception, stop execution and pass the exception on.
+	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass}
+	 * methods on this class and superclasses before executing {@code statement}
+	 * ; if any throws an Exception, stop execution and pass the exception on.
 	 */
 	protected Statement withBeforeClasses(Statement statement) {
 		List<FrameworkMethod> befores= fTestClass
@@ -170,11 +195,11 @@ protected Statement withBeforeClasses(Statement statement) {
 	}
 
 	/**
-	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class
-	 * and superclasses before executing {@code statement}; all AfterClass methods are
-	 * always executed: exceptions thrown by previous steps are combined, if
-	 * necessary, with exceptions from AfterClass methods into a
-	 * {@link MultipleFailureException}.
+	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass}
+	 * methods on this class and superclasses before executing {@code statement}
+	 * ; all AfterClass methods are always executed: exceptions thrown by
+	 * previous steps are combined, if necessary, with exceptions from
+	 * AfterClass methods into a {@link MultipleFailureException}.
 	 */
 	protected Statement withAfterClasses(Statement statement) {
 		List<FrameworkMethod> afters= fTestClass
@@ -198,8 +223,16 @@ public void evaluate() {
 	}
 
 	private void runChildren(final RunNotifier notifier) {
-		for (T each : getFilteredChildren())
-			runChild(each, notifier);
+		fDecorator.runAll(new SafeStatement() {
+			public void execute() {
+				for (final T each : getFilteredChildren())
+					fDecorator.runChild(new SafeStatement() {
+						public void execute() {
+							runChild(each, notifier);
+						}
+					});
+			}
+		});
 	}
 
 	/**
@@ -223,7 +256,7 @@ public final TestClass getTestClass() {
 	//
 	// Implementation of Runner
 	// 
-	
+
 	@Override
 	public Description getDescription() {
 		Description description= Description.createSuiteDescription(getName(),
@@ -248,7 +281,7 @@ public void run(final RunNotifier notifier) {
 			testNotifier.addFailure(e);
 		}
 	}
-	
+
 	//
 	// Implementation of Filterable and Sortable
 	//
@@ -265,7 +298,7 @@ public void filter(Filter filter) throws NoTestsRemainException {
 	public void sort(Sorter sorter) {
 		fSorter= sorter;
 	}
-	
+
 	//
 	// Private implementation
 	// 
@@ -312,4 +345,14 @@ public int compare(T o1, T o2) {
 			}
 		};
 	}
+
+	// TODO (May 11, 2009 2:53:54 PM): complex
+	public void installDecorator(Decorator decorator) {
+		this.fDecorator= decorator;
+	}
+
+	// TODO (May 11, 2009 4:19:18 PM): move?
+	public boolean isSuite() {
+		return false;
+	}
 }
\ No newline at end of file
@@ -118,4 +118,9 @@ protected Description describeChild(Runner child) {
 	protected void runChild(Runner runner, final RunNotifier notifier) {
 		runner.run(notifier);
 	}
+	
+	@Override
+	public boolean isSuite() {
+		return true;
+	}
 }
@@ -124,7 +124,8 @@
 	InterceptorTest.class,
 	TimeoutInterceptorTest.class,
 	ParallelClassTest.class,
-	ParallelMethodTest.class
+	ParallelMethodTest.class,
+	ParentRunnerTest.class
 })
 public class AllTests {
 	public static Test suite() {
@@ -0,0 +1,68 @@
+package org.junit.tests;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.Comparator;
+
+import org.junit.Test;
+import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
+import org.junit.runner.Description;
+import org.junit.runner.manipulation.Sorter;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.BlockJUnit4ClassRunner;
+import org.junit.runners.ParentRunner;
+import org.junit.runners.model.FrameworkMethod;
+
+// TODO (May 11, 2009 2:42:38 PM): move package
+
+public class ParentRunnerTest {
+	private static StringBuffer log= new StringBuffer();
+
+	public static class FruitTests {
+		@Test
+		public void apple() {
+			log.append(""apple "");
+		}
+
+		@Test
+		public void banana() {
+			log.append(""banana "");
+		}
+
+		@Test
+		public void pear() {
+			log.append(""pear "");
+		}
+	}
+
+	@Test
+	public void installDecorator() throws Throwable {
+		log.setLength(0);
+		ParentRunner<FrameworkMethod> runner= (BlockJUnit4ClassRunner) new AllDefaultPossibilitiesBuilder(
+				true).runnerForClass(FruitTests.class);
+		// TODO (May 11, 2009 2:58:11 PM): DUP?
+		runner.sort(new Sorter(new Comparator<Description>() {
+			public int compare(Description o1, Description o2) {
+				return o1.toString().compareTo(o2.toString());
+			}
+		}));
+		runner.installDecorator(new ParentRunner.Decorator() {
+			public void runChild(SafeStatement statement) {
+				log.append(""before "");
+				statement.execute();
+				log.append(""after "");
+			}
+
+			public void runAll(SafeStatement statement) {
+				log.append(""beforeAll "");
+				statement.execute();
+				log.append(""afterAll "");
+			}
+		});
+
+		runner.run(new RunNotifier());
+		assertEquals(
+				""beforeAll before apple after before banana after before pear after afterAll "",
+				log.toString());
+	}
+}
@@ -0,0 +1,8 @@
+package org.junit.tests;
+
+// TODO (May 11, 2009 2:54:22 PM): move elsewhere
+public interface SafeStatement {
+
+	void execute();
+
+}
@@ -15,7 +15,6 @@
 
 
 public class ParallelClassTest {
-
 	public static class Example1 {
 		@Test public void one() throws InterruptedException {
 			Thread.sleep(1000);
@@ -30,7 +29,7 @@ public static class Example2 {
 	@RunWith(Suite.class)
 	@SuiteClasses({Example1.class, Example2.class})
 	public static class ExampleSuite {}
-	
+
 	// TODO(parallel) we need to push parallel execution down through suites (i.e. run a Suite with a parallel executioner and you get parallel execution)
 	@Test(timeout=1500) public void testsRunInParallel() {
 		long start= System.currentTimeMillis();
@@ -39,6 +38,15 @@ public static class ExampleSuite {}
 		long end= System.currentTimeMillis();
 		assertThat(end - start, greaterThan(999)); // Overhead could be less than half a millisecond
 	}
+	
+	// TODO(parallel) we need to push parallel execution down through suites (i.e. run a Suite with a parallel executioner and you get parallel execution)
+	@Test(timeout=2500) public void testsDontRunInParallelIfOnlyMethods() {
+		long start= System.currentTimeMillis();
+		Result result= JUnitCore.runClasses(ParallelComputer.methods(), Example1.class, Example2.class);
+		assertTrue(result.wasSuccessful());
+		long end= System.currentTimeMillis();
+		assertThat(end - start, greaterThan(1999)); // Overhead could be less than half a millisecond
+	}
 
 	private Matcher<Long> greaterThan(final long l) {
 		return new TypeSafeMatcher<Long>() {
"
https://github.com/apache/dubbo/commit/243e57130646c69c047910dd079f19cbadc57613,Remove unnecessary null check. ,https://api.github.com/repos/apache/dubbo/commits/243e57130646c69c047910dd079f19cbadc57613,"@@ -338,7 +338,7 @@ public synchronized void unexport() {
         if (unexported) {
             return;
         }
-        if (exporters != null && !exporters.isEmpty()) {
+        if (!exporters.isEmpty()) {
             for (Exporter<?> exporter : exporters) {
                 try {
                     exporter.unexport();
"
https://github.com/spring-projects/spring-boot/commit/e3899df22c1f8de17081fababcbd5c406a3c8541,"Configure Spring Data Couchbase explicitly  <enter> This commit configures Spring Data Couchbase explicitly rather than relying on the abstract configuration class. This has the advantage of simplifying the auto-configuration and let it us proxy-free configuration classes. <enter> Spring Boot no longer uses or interacts with CouchbaseConfigurer. Users relying on that to teach Spring Boot which components to use should rely on `@Primary` flag instead in case of multiple beans of the same type. <enter> `CouchbaseConfiguration` is no longer public as extending from it is no longer necessary. If the `CouchbaseEnvironment` has to be customized, a `CouchbaseEnvironmentBuilderCustomizer` bean can be registered to tune the auto-configured environment. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/e3899df22c1f8de17081fababcbd5c406a3c8541,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -16,18 +16,28 @@
 
 package org.springframework.boot.autoconfigure.couchbase;
 
+import com.couchbase.client.core.env.KeyValueServiceConfig;
+import com.couchbase.client.core.env.QueryServiceConfig;
+import com.couchbase.client.core.env.ViewServiceConfig;
+import com.couchbase.client.java.Bucket;
 import com.couchbase.client.java.Cluster;
 import com.couchbase.client.java.CouchbaseBucket;
+import com.couchbase.client.java.CouchbaseCluster;
+import com.couchbase.client.java.cluster.ClusterInfo;
+import com.couchbase.client.java.env.CouchbaseEnvironment;
+import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;
+import com.couchbase.client.java.env.DefaultCouchbaseEnvironment.Builder;
 
+import org.springframework.beans.factory.ObjectProvider;
 import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
-import org.springframework.boot.autoconfigure.condition.AnyNestedCondition;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties.Endpoints;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Conditional;
 import org.springframework.context.annotation.Configuration;
-import org.springframework.context.annotation.Import;
+import org.springframework.context.annotation.DependsOn;
 
 /**
  * {@link EnableAutoConfiguration Auto-configuration} for Couchbase.
@@ -39,42 +49,105 @@
  */
 @Configuration(proxyBeanMethods = false)
 @ConditionalOnClass({ CouchbaseBucket.class, Cluster.class })
-@Conditional(CouchbaseAutoConfiguration.CouchbaseCondition.class)
+@Conditional(OnBootstrapHostsCondition.class)
 @EnableConfigurationProperties(CouchbaseProperties.class)
 public class CouchbaseAutoConfiguration {
 
-	@Configuration(proxyBeanMethods = false)
-	@ConditionalOnMissingBean(value = CouchbaseConfiguration.class,
-			type = ""org.springframework.data.couchbase.config.CouchbaseConfigurer"")
-	@Import(CouchbaseConfiguration.class)
-	static class DefaultCouchbaseConfiguration {
-
+	@Bean
+	@ConditionalOnMissingBean(CouchbaseEnvironment.class)
+	public DefaultCouchbaseEnvironment couchbaseEnvironment(CouchbaseProperties properties,
+			ObjectProvider<CouchbaseEnvironmentBuilderCustomizer> customizers) {
+		Builder builder = initializeEnvironmentBuilder(properties);
+		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
+		return builder.build();
 	}
 
-	/**
-	 * Determine if Couchbase should be configured. This happens if either the
-	 * user-configuration defines a {@code CouchbaseConfigurer} or if at least the
-	 * ""bootstrapHosts"" property is specified.
-	 * <p>
-	 * The reason why we check for the presence of {@code CouchbaseConfigurer} is that it
-	 * might use {@link CouchbaseProperties} for its internal customization.
-	 */
-	static class CouchbaseCondition extends AnyNestedCondition {
-
-		CouchbaseCondition() {
-			super(ConfigurationPhase.REGISTER_BEAN);
+	@Bean
+	@ConditionalOnMissingBean(Cluster.class)
+	public CouchbaseCluster couchbaseCluster(CouchbaseProperties properties,
+			CouchbaseEnvironment couchbaseEnvironment) {
+		CouchbaseCluster couchbaseCluster = CouchbaseCluster.create(couchbaseEnvironment,
+				properties.getBootstrapHosts());
+		if (isRoleBasedAccessControlEnabled(properties)) {
+			return couchbaseCluster.authenticate(properties.getUsername(), properties.getPassword());
 		}
+		return couchbaseCluster;
+	}
 
-		@Conditional(OnBootstrapHostsCondition.class)
-		static class BootstrapHostsProperty {
+	@Bean
+	@ConditionalOnMissingBean
+	@DependsOn(""couchbaseClient"")
+	public ClusterInfo couchbaseClusterInfo(CouchbaseProperties properties, Cluster couchbaseCluster) {
+		if (isRoleBasedAccessControlEnabled(properties)) {
+			return couchbaseCluster.clusterManager().info();
+		}
+		return couchbaseCluster.clusterManager(properties.getBucket().getName(), properties.getBucket().getPassword())
+				.info();
+	}
 
+	@Bean
+	@ConditionalOnMissingBean
+	public Bucket couchbaseClient(CouchbaseProperties properties, Cluster couchbaseCluster) {
+		if (isRoleBasedAccessControlEnabled(properties)) {
+			return couchbaseCluster.openBucket(properties.getBucket().getName());
 		}
+		return couchbaseCluster.openBucket(properties.getBucket().getName(), properties.getBucket().getPassword());
+	}
 
-		@ConditionalOnBean(type = ""org.springframework.data.couchbase.config.CouchbaseConfigurer"")
-		static class CouchbaseConfigurerAvailable {
+	private boolean isRoleBasedAccessControlEnabled(CouchbaseProperties properties) {
+		return properties.getUsername() != null && properties.getPassword() != null;
+	}
 
+	private DefaultCouchbaseEnvironment.Builder initializeEnvironmentBuilder(CouchbaseProperties properties) {
+		CouchbaseProperties.Endpoints endpoints = properties.getEnv().getEndpoints();
+		CouchbaseProperties.Timeouts timeouts = properties.getEnv().getTimeouts();
+		CouchbaseProperties.Bootstrap bootstrap = properties.getEnv().getBootstrap();
+		DefaultCouchbaseEnvironment.Builder builder = DefaultCouchbaseEnvironment.builder();
+		if (bootstrap.getHttpDirectPort() != null) {
+			builder.bootstrapHttpDirectPort(bootstrap.getHttpDirectPort());
+		}
+		if (bootstrap.getHttpSslPort() != null) {
+			builder.bootstrapHttpSslPort(bootstrap.getHttpSslPort());
+		}
+		if (timeouts.getConnect() != null) {
+			builder = builder.connectTimeout(timeouts.getConnect().toMillis());
 		}
+		builder = builder.keyValueServiceConfig(KeyValueServiceConfig.create(endpoints.getKeyValue()));
+		if (timeouts.getKeyValue() != null) {
+			builder = builder.kvTimeout(timeouts.getKeyValue().toMillis());
+		}
+		if (timeouts.getQuery() != null) {
+			builder = builder.queryTimeout(timeouts.getQuery().toMillis());
+			builder = builder.queryServiceConfig(getQueryServiceConfig(endpoints));
+			builder = builder.viewServiceConfig(getViewServiceConfig(endpoints));
+		}
+		if (timeouts.getSocketConnect() != null) {
+			builder = builder.socketConnectTimeout((int) timeouts.getSocketConnect().toMillis());
+		}
+		if (timeouts.getView() != null) {
+			builder = builder.viewTimeout(timeouts.getView().toMillis());
+		}
+		CouchbaseProperties.Ssl ssl = properties.getEnv().getSsl();
+		if (ssl.getEnabled()) {
+			builder = builder.sslEnabled(true);
+			if (ssl.getKeyStore() != null) {
+				builder = builder.sslKeystoreFile(ssl.getKeyStore());
+			}
+			if (ssl.getKeyStorePassword() != null) {
+				builder = builder.sslKeystorePassword(ssl.getKeyStorePassword());
+			}
+		}
+		return builder;
+	}
+
+	private QueryServiceConfig getQueryServiceConfig(Endpoints endpoints) {
+		return QueryServiceConfig.create(endpoints.getQueryservice().getMinEndpoints(),
+				endpoints.getQueryservice().getMaxEndpoints());
+	}
 
+	private ViewServiceConfig getViewServiceConfig(Endpoints endpoints) {
+		return ViewServiceConfig.create(endpoints.getViewservice().getMinEndpoints(),
+				endpoints.getViewservice().getMaxEndpoints());
 	}
 
 }
@@ -1,159 +0,0 @@
-/*
- * Copyright 2012-2020 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.couchbase;
-
-import java.util.List;
-
-import com.couchbase.client.core.env.KeyValueServiceConfig;
-import com.couchbase.client.core.env.QueryServiceConfig;
-import com.couchbase.client.core.env.ViewServiceConfig;
-import com.couchbase.client.java.Bucket;
-import com.couchbase.client.java.Cluster;
-import com.couchbase.client.java.CouchbaseCluster;
-import com.couchbase.client.java.cluster.ClusterInfo;
-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;
-
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties.Endpoints;
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.context.annotation.DependsOn;
-import org.springframework.context.annotation.Primary;
-
-/**
- * Support class to configure Couchbase based on {@link CouchbaseProperties}.
- *
- * @author Stephane Nicoll
- * @author Brian Clozel
- * @since 2.1.0
- */
-@Configuration
-public class CouchbaseConfiguration {
-
-	private final CouchbaseProperties properties;
-
-	public CouchbaseConfiguration(CouchbaseProperties properties) {
-		this.properties = properties;
-	}
-
-	@Bean
-	@Primary
-	public DefaultCouchbaseEnvironment couchbaseEnvironment() {
-		return initializeEnvironmentBuilder(this.properties).build();
-	}
-
-	@Bean
-	@Primary
-	public Cluster couchbaseCluster() {
-		CouchbaseCluster couchbaseCluster = CouchbaseCluster.create(couchbaseEnvironment(), determineBootstrapHosts());
-		if (isRoleBasedAccessControlEnabled()) {
-			return couchbaseCluster.authenticate(this.properties.getUsername(), this.properties.getPassword());
-		}
-		return couchbaseCluster;
-	}
-
-	/**
-	 * Determine the Couchbase nodes to bootstrap from.
-	 * @return the Couchbase nodes to bootstrap from
-	 */
-	protected List<String> determineBootstrapHosts() {
-		return this.properties.getBootstrapHosts();
-	}
-
-	@Bean
-	@Primary
-	@DependsOn(""couchbaseClient"")
-	public ClusterInfo couchbaseClusterInfo() {
-		if (isRoleBasedAccessControlEnabled()) {
-			return couchbaseCluster().clusterManager().info();
-		}
-		return couchbaseCluster()
-				.clusterManager(this.properties.getBucket().getName(), this.properties.getBucket().getPassword())
-				.info();
-	}
-
-	@Bean
-	@Primary
-	public Bucket couchbaseClient() {
-		if (isRoleBasedAccessControlEnabled()) {
-			return couchbaseCluster().openBucket(this.properties.getBucket().getName());
-		}
-		return couchbaseCluster().openBucket(this.properties.getBucket().getName(),
-				this.properties.getBucket().getPassword());
-	}
-
-	private boolean isRoleBasedAccessControlEnabled() {
-		return this.properties.getUsername() != null && this.properties.getPassword() != null;
-	}
-
-	/**
-	 * Initialize an environment builder based on the specified settings.
-	 * @param properties the couchbase properties to use
-	 * @return the {@link DefaultCouchbaseEnvironment} builder.
-	 */
-	protected DefaultCouchbaseEnvironment.Builder initializeEnvironmentBuilder(CouchbaseProperties properties) {
-		CouchbaseProperties.Endpoints endpoints = properties.getEnv().getEndpoints();
-		CouchbaseProperties.Timeouts timeouts = properties.getEnv().getTimeouts();
-		CouchbaseProperties.Bootstrap bootstrap = properties.getEnv().getBootstrap();
-		DefaultCouchbaseEnvironment.Builder builder = DefaultCouchbaseEnvironment.builder();
-		if (bootstrap.getHttpDirectPort() != null) {
-			builder.bootstrapHttpDirectPort(bootstrap.getHttpDirectPort());
-		}
-		if (bootstrap.getHttpSslPort() != null) {
-			builder.bootstrapHttpSslPort(bootstrap.getHttpSslPort());
-		}
-		if (timeouts.getConnect() != null) {
-			builder = builder.connectTimeout(timeouts.getConnect().toMillis());
-		}
-		builder = builder.keyValueServiceConfig(KeyValueServiceConfig.create(endpoints.getKeyValue()));
-		if (timeouts.getKeyValue() != null) {
-			builder = builder.kvTimeout(timeouts.getKeyValue().toMillis());
-		}
-		if (timeouts.getQuery() != null) {
-			builder = builder.queryTimeout(timeouts.getQuery().toMillis());
-			builder = builder.queryServiceConfig(getQueryServiceConfig(endpoints));
-			builder = builder.viewServiceConfig(getViewServiceConfig(endpoints));
-		}
-		if (timeouts.getSocketConnect() != null) {
-			builder = builder.socketConnectTimeout((int) timeouts.getSocketConnect().toMillis());
-		}
-		if (timeouts.getView() != null) {
-			builder = builder.viewTimeout(timeouts.getView().toMillis());
-		}
-		CouchbaseProperties.Ssl ssl = properties.getEnv().getSsl();
-		if (ssl.getEnabled()) {
-			builder = builder.sslEnabled(true);
-			if (ssl.getKeyStore() != null) {
-				builder = builder.sslKeystoreFile(ssl.getKeyStore());
-			}
-			if (ssl.getKeyStorePassword() != null) {
-				builder = builder.sslKeystorePassword(ssl.getKeyStorePassword());
-			}
-		}
-		return builder;
-	}
-
-	private QueryServiceConfig getQueryServiceConfig(Endpoints endpoints) {
-		return QueryServiceConfig.create(endpoints.getQueryservice().getMinEndpoints(),
-				endpoints.getQueryservice().getMaxEndpoints());
-	}
-
-	private ViewServiceConfig getViewServiceConfig(Endpoints endpoints) {
-		return ViewServiceConfig.create(endpoints.getViewservice().getMinEndpoints(),
-				endpoints.getViewservice().getMaxEndpoints());
-	}
-
-}
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2012-2020 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.couchbase;
+
+import com.couchbase.client.java.env.CouchbaseEnvironment;
+import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;
+
+/**
+ * Callback interface that can be implemented by beans wishing to customize the
+ * {@link CouchbaseEnvironment} via a {@link DefaultCouchbaseEnvironment.Builder} whilst
+ * retaining default auto-configuration.
+ *
+ * @author Stephane Nicoll
+ * @since 2.3.0
+ */
+@FunctionalInterface
+public interface CouchbaseEnvironmentBuilderCustomizer {
+
+	/**
+	 * Customize the {@link DefaultCouchbaseEnvironment.Builder}.
+	 * @param builder the builder to customize
+	 */
+	void customize(DefaultCouchbaseEnvironment.Builder builder);
+
+}
@@ -1,52 +0,0 @@
-/*
- * Copyright 2012-2019 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.data.couchbase;
-
-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseConfiguration;
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-
-/**
- * Adapt the core Couchbase configuration to an expected {@link CouchbaseConfigurer} if
- * necessary.
- *
- * @author Stephane Nicoll
- */
-@Configuration(proxyBeanMethods = false)
-@ConditionalOnClass(CouchbaseConfigurer.class)
-@ConditionalOnBean(CouchbaseConfiguration.class)
-class CouchbaseConfigurerAdapterConfiguration {
-
-	private final CouchbaseConfiguration configuration;
-
-	CouchbaseConfigurerAdapterConfiguration(CouchbaseConfiguration configuration) {
-		this.configuration = configuration;
-	}
-
-	@Bean
-	@ConditionalOnMissingBean
-	CouchbaseConfigurer springBootCouchbaseConfigurer() throws Exception {
-		return new SpringBootCouchbaseConfigurer(this.configuration.couchbaseEnvironment(),
-				this.configuration.couchbaseCluster(), this.configuration.couchbaseClusterInfo(),
-				this.configuration.couchbaseClient());
-	}
-
-}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -44,7 +44,7 @@
 @ConditionalOnClass({ Bucket.class, CouchbaseRepository.class })
 @AutoConfigureAfter({ CouchbaseAutoConfiguration.class, ValidationAutoConfiguration.class })
 @EnableConfigurationProperties(CouchbaseDataProperties.class)
-@Import({ CouchbaseConfigurerAdapterConfiguration.class, SpringBootCouchbaseDataConfiguration.class })
+@Import(CouchbaseDataConfiguration.class)
 public class CouchbaseDataAutoConfiguration {
 
 	@Configuration(proxyBeanMethods = false)
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2012-2020 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.data.couchbase;
+
+import java.util.Collections;
+
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.cluster.ClusterInfo;
+
+import org.springframework.beans.BeanUtils;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;
+import org.springframework.boot.autoconfigure.domain.EntityScanner;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.data.annotation.Persistent;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions;
+import org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;
+import org.springframework.data.couchbase.core.convert.translation.JacksonTranslationService;
+import org.springframework.data.couchbase.core.convert.translation.TranslationService;
+import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
+import org.springframework.data.couchbase.core.mapping.Document;
+import org.springframework.data.couchbase.repository.config.RepositoryOperationsMapping;
+import org.springframework.data.couchbase.repository.support.IndexManager;
+import org.springframework.data.mapping.model.FieldNamingStrategy;
+
+/**
+ * Configuration for Spring Data's couchbase support.
+ *
+ * @author Stephane Nicoll
+ */
+@Configuration(proxyBeanMethods = false)
+class CouchbaseDataConfiguration {
+
+	@Bean(name = BeanNames.COUCHBASE_MAPPING_CONVERTER)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_MAPPING_CONVERTER)
+	MappingCouchbaseConverter couchbaseMappingConverter(CouchbaseDataProperties properties,
+			CouchbaseMappingContext couchbaseMappingContext, CouchbaseCustomConversions couchbaseCustomConversions) {
+		MappingCouchbaseConverter converter = new MappingCouchbaseConverter(couchbaseMappingContext,
+				properties.getTypeKey());
+		converter.setCustomConversions(couchbaseCustomConversions);
+		return converter;
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_TRANSLATION_SERVICE)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_TRANSLATION_SERVICE)
+	TranslationService couchbaseTranslationService() {
+		return new JacksonTranslationService();
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_MAPPING_CONTEXT)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_MAPPING_CONTEXT)
+	CouchbaseMappingContext couchbaseMappingContext(CouchbaseDataProperties properties,
+			ApplicationContext applicationContext, CouchbaseCustomConversions couchbaseCustomConversions)
+			throws Exception {
+		CouchbaseMappingContext mappingContext = new CouchbaseMappingContext();
+		mappingContext
+				.setInitialEntitySet(new EntityScanner(applicationContext).scan(Document.class, Persistent.class));
+		mappingContext.setSimpleTypeHolder(couchbaseCustomConversions.getSimpleTypeHolder());
+		Class<?> fieldNamingStrategy = properties.getFieldNamingStrategy();
+		if (fieldNamingStrategy != null) {
+			mappingContext
+					.setFieldNamingStrategy((FieldNamingStrategy) BeanUtils.instantiateClass(fieldNamingStrategy));
+		}
+		return mappingContext;
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
+	CouchbaseCustomConversions couchbaseCustomConversions() {
+		return new CouchbaseCustomConversions(Collections.emptyList());
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_INDEX_MANAGER)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_INDEX_MANAGER)
+	IndexManager indexManager(CouchbaseDataProperties properties) {
+		if (properties.isAutoIndex()) {
+			return new IndexManager(true, true, true);
+		}
+		return new IndexManager(false, false, false);
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_TEMPLATE)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_TEMPLATE)
+	@ConditionalOnBean({ ClusterInfo.class, Bucket.class })
+	CouchbaseTemplate couchbaseTemplate(CouchbaseDataProperties properties, ClusterInfo clusterInfo, Bucket bucket,
+			MappingCouchbaseConverter mappingCouchbaseConverter, TranslationService translationService) {
+		CouchbaseTemplate template = new CouchbaseTemplate(clusterInfo, bucket, mappingCouchbaseConverter,
+				translationService);
+		template.setDefaultConsistency(properties.getConsistency());
+		return template;
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_OPERATIONS_MAPPING)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_OPERATIONS_MAPPING)
+	@ConditionalOnSingleCandidate(CouchbaseTemplate.class)
+	RepositoryOperationsMapping repositoryOperationsMapping(CouchbaseTemplate couchbaseTemplate) {
+		return new RepositoryOperationsMapping(couchbaseTemplate);
+	}
+
+}
@@ -39,6 +39,11 @@ public class CouchbaseDataProperties {
 	 */
 	private Consistency consistency = Consistency.READ_YOUR_OWN_WRITES;
 
+	/**
+	 * Fully qualified name of the FieldNamingStrategy to use.
+	 */
+	private Class<?> fieldNamingStrategy;
+
 	/**
 	 * Name of the field that stores the type information for complex types when using
 	 * ""MappingCouchbaseConverter"".
@@ -61,6 +66,14 @@ public void setConsistency(Consistency consistency) {
 		this.consistency = consistency;
 	}
 
+	public Class<?> getFieldNamingStrategy() {
+		return this.fieldNamingStrategy;
+	}
+
+	public void setFieldNamingStrategy(Class<?> fieldNamingStrategy) {
+		this.fieldNamingStrategy = fieldNamingStrategy;
+	}
+
 	public String getTypeKey() {
 		return this.typeKey;
 	}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -36,7 +36,7 @@
 @Configuration(proxyBeanMethods = false)
 @ConditionalOnClass({ Bucket.class, ReactiveCouchbaseRepository.class, Flux.class })
 @AutoConfigureAfter(CouchbaseDataAutoConfiguration.class)
-@Import(SpringBootCouchbaseReactiveDataConfiguration.class)
+@Import(CouchbaseReactiveDataConfiguration.class)
 public class CouchbaseReactiveDataAutoConfiguration {
 
 }
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2012-2020 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.data.couchbase;
+
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.cluster.ClusterInfo;
+
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.RxJavaCouchbaseTemplate;
+import org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;
+import org.springframework.data.couchbase.core.convert.translation.TranslationService;
+import org.springframework.data.couchbase.repository.config.ReactiveRepositoryOperationsMapping;
+
+/**
+ * Configuration for Spring Data's couchbase reactive support.
+ *
+ * @author Stephane Nicoll
+ */
+@Configuration(proxyBeanMethods = false)
+class CouchbaseReactiveDataConfiguration {
+
+	@Bean(name = BeanNames.RXJAVA1_COUCHBASE_TEMPLATE)
+	@ConditionalOnMissingBean(name = BeanNames.RXJAVA1_COUCHBASE_TEMPLATE)
+	@ConditionalOnBean({ ClusterInfo.class, Bucket.class })
+	RxJavaCouchbaseTemplate reactiveCouchbaseTemplate(CouchbaseDataProperties properties, ClusterInfo clusterInfo,
+			Bucket bucket, MappingCouchbaseConverter mappingCouchbaseConverter, TranslationService translationService) {
+		RxJavaCouchbaseTemplate template = new RxJavaCouchbaseTemplate(clusterInfo, bucket, mappingCouchbaseConverter,
+				translationService);
+		template.setDefaultConsistency(properties.getConsistency());
+		return template;
+	}
+
+	@Bean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
+	@ConditionalOnMissingBean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
+	@ConditionalOnSingleCandidate(RxJavaCouchbaseTemplate.class)
+	ReactiveRepositoryOperationsMapping reactiveRepositoryOperationsMapping(
+			RxJavaCouchbaseTemplate reactiveCouchbaseTemplate) {
+		return new ReactiveRepositoryOperationsMapping(reactiveCouchbaseTemplate);
+	}
+
+}
@@ -1,70 +0,0 @@
-/*
- * Copyright 2012-2019 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.data.couchbase;
-
-import com.couchbase.client.java.Bucket;
-import com.couchbase.client.java.Cluster;
-import com.couchbase.client.java.cluster.ClusterInfo;
-import com.couchbase.client.java.env.CouchbaseEnvironment;
-
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-
-/**
- * A simple {@link CouchbaseConfigurer} implementation.
- *
- * @author Stephane Nicoll
- * @since 1.4.0
- */
-public class SpringBootCouchbaseConfigurer implements CouchbaseConfigurer {
-
-	private final CouchbaseEnvironment env;
-
-	private final Cluster cluster;
-
-	private final ClusterInfo clusterInfo;
-
-	private final Bucket bucket;
-
-	public SpringBootCouchbaseConfigurer(CouchbaseEnvironment env, Cluster cluster, ClusterInfo clusterInfo,
-			Bucket bucket) {
-		this.env = env;
-		this.cluster = cluster;
-		this.clusterInfo = clusterInfo;
-		this.bucket = bucket;
-	}
-
-	@Override
-	public CouchbaseEnvironment couchbaseEnvironment() throws Exception {
-		return this.env;
-	}
-
-	@Override
-	public Cluster couchbaseCluster() throws Exception {
-		return this.cluster;
-	}
-
-	@Override
-	public ClusterInfo couchbaseClusterInfo() throws Exception {
-		return this.clusterInfo;
-	}
-
-	@Override
-	public Bucket couchbaseClient() throws Exception {
-		return this.bucket;
-	}
-
-}
@@ -1,105 +0,0 @@
-/*
- * Copyright 2012-2020 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.data.couchbase;
-
-import java.util.Set;
-
-import org.springframework.beans.factory.ObjectProvider;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.boot.autoconfigure.domain.EntityScanner;
-import org.springframework.context.ApplicationContext;
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.data.annotation.Persistent;
-import org.springframework.data.convert.CustomConversions;
-import org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration;
-import org.springframework.data.couchbase.config.BeanNames;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-import org.springframework.data.couchbase.core.CouchbaseTemplate;
-import org.springframework.data.couchbase.core.mapping.Document;
-import org.springframework.data.couchbase.core.query.Consistency;
-import org.springframework.data.couchbase.repository.support.IndexManager;
-
-/**
- * Configure Spring Data's couchbase support.
- *
- * @author Stephane Nicoll
- */
-@Configuration
-@ConditionalOnMissingBean(AbstractCouchbaseDataConfiguration.class)
-@ConditionalOnBean(CouchbaseConfigurer.class)
-class SpringBootCouchbaseDataConfiguration extends AbstractCouchbaseDataConfiguration {
-
-	private final ApplicationContext applicationContext;
-
-	private final CouchbaseDataProperties properties;
-
-	private final CouchbaseConfigurer couchbaseConfigurer;
-
-	SpringBootCouchbaseDataConfiguration(ApplicationContext applicationContext, CouchbaseDataProperties properties,
-			ObjectProvider<CouchbaseConfigurer> couchbaseConfigurer) {
-		this.applicationContext = applicationContext;
-		this.properties = properties;
-		this.couchbaseConfigurer = couchbaseConfigurer.getIfAvailable();
-	}
-
-	@Override
-	protected CouchbaseConfigurer couchbaseConfigurer() {
-		return this.couchbaseConfigurer;
-	}
-
-	@Override
-	protected Consistency getDefaultConsistency() {
-		return this.properties.getConsistency();
-	}
-
-	@Override
-	protected Set<Class<?>> getInitialEntitySet() throws ClassNotFoundException {
-		return new EntityScanner(this.applicationContext).scan(Document.class, Persistent.class);
-	}
-
-	@Override
-	public String typeKey() {
-		return this.properties.getTypeKey();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_TEMPLATE)
-	@Bean(name = BeanNames.COUCHBASE_TEMPLATE)
-	public CouchbaseTemplate couchbaseTemplate() throws Exception {
-		return super.couchbaseTemplate();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
-	@Bean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
-	public CustomConversions customConversions() {
-		return super.customConversions();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_INDEX_MANAGER)
-	@Bean(name = BeanNames.COUCHBASE_INDEX_MANAGER)
-	public IndexManager indexManager() {
-		if (this.properties.isAutoIndex()) {
-			return new IndexManager(true, true, true);
-		}
-		return new IndexManager(false, false, false);
-	}
-
-}
@@ -1,75 +0,0 @@
-/*
- * Copyright 2012-2019 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.data.couchbase;
-
-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.data.couchbase.config.AbstractReactiveCouchbaseDataConfiguration;
-import org.springframework.data.couchbase.config.BeanNames;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-import org.springframework.data.couchbase.core.RxJavaCouchbaseTemplate;
-import org.springframework.data.couchbase.core.query.Consistency;
-import org.springframework.data.couchbase.repository.config.ReactiveRepositoryOperationsMapping;
-
-/**
- * Configure Spring Data's reactive couchbase support.
- *
- * @author Alex Derkach
- */
-@Configuration
-@ConditionalOnMissingBean(AbstractReactiveCouchbaseDataConfiguration.class)
-@ConditionalOnBean(CouchbaseConfigurer.class)
-class SpringBootCouchbaseReactiveDataConfiguration extends AbstractReactiveCouchbaseDataConfiguration {
-
-	private final CouchbaseDataProperties properties;
-
-	private final CouchbaseConfigurer couchbaseConfigurer;
-
-	SpringBootCouchbaseReactiveDataConfiguration(CouchbaseDataProperties properties,
-			CouchbaseConfigurer couchbaseConfigurer) {
-		this.properties = properties;
-		this.couchbaseConfigurer = couchbaseConfigurer;
-	}
-
-	@Override
-	protected CouchbaseConfigurer couchbaseConfigurer() {
-		return this.couchbaseConfigurer;
-	}
-
-	@Override
-	protected Consistency getDefaultConsistency() {
-		return this.properties.getConsistency();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.RXJAVA1_COUCHBASE_TEMPLATE)
-	@Bean(name = BeanNames.RXJAVA1_COUCHBASE_TEMPLATE)
-	public RxJavaCouchbaseTemplate reactiveCouchbaseTemplate() throws Exception {
-		return super.reactiveCouchbaseTemplate();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
-	@Bean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
-	public ReactiveRepositoryOperationsMapping reactiveRepositoryOperationsMapping(
-			RxJavaCouchbaseTemplate reactiveCouchbaseTemplate) throws Exception {
-		return super.reactiveRepositoryOperationsMapping(reactiveCouchbaseTemplate);
-	}
-
-}
@@ -22,24 +22,21 @@
 
 import com.couchbase.client.java.Bucket;
 import com.couchbase.client.java.Cluster;
-import com.couchbase.client.java.CouchbaseBucket;
 import com.couchbase.client.java.bucket.BucketType;
 import com.couchbase.client.java.cluster.BucketSettings;
 import com.couchbase.client.java.cluster.ClusterInfo;
 import com.couchbase.client.java.cluster.DefaultBucketSettings;
 import com.couchbase.client.java.cluster.UserRole;
 import com.couchbase.client.java.cluster.UserSettings;
 import com.couchbase.client.java.env.CouchbaseEnvironment;
-import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.testcontainers.couchbase.CouchbaseContainer;
 import org.testcontainers.junit.jupiter.Container;
 import org.testcontainers.junit.jupiter.Testcontainers;
 
-import org.springframework.boot.test.util.TestPropertyValues;
-import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.boot.autoconfigure.AutoConfigurations;
+import org.springframework.boot.test.context.runner.ApplicationContextRunner;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -59,7 +56,12 @@ class CouchbaseAutoConfigurationIntegrationTests {
 	static final CouchbaseContainer couchbase = new CouchbaseContainer().withClusterAdmin(""spring"", ""password"")
 			.withStartupAttempts(5).withStartupTimeout(Duration.ofMinutes(10));
 
-	private AnnotationConfigApplicationContext context;
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
+			.withConfiguration(AutoConfigurations.of(CouchbaseAutoConfiguration.class))
+			.withPropertyValues(""spring.couchbase.bootstrap-hosts=localhost"",
+					""spring.couchbase.env.bootstrap.http-direct-port:"" + couchbase.getMappedPort(8091),
+					""spring.couchbase.username:spring"", ""spring.couchbase.password:password"",
+					""spring.couchbase.bucket.name:default"");
 
 	@BeforeAll
 	static void createBucket() {
@@ -70,40 +72,10 @@ static void createBucket() {
 				UserSettings.build().password(bucketSettings.password()).roles(userSettings), true);
 	}
 
-	@BeforeEach
-	void setUp() {
-		this.context = new AnnotationConfigApplicationContext();
-		this.context.register(CouchbaseAutoConfiguration.class);
-		TestPropertyValues.of(""spring.couchbase.bootstrap-hosts=localhost"",
-				""spring.couchbase.env.bootstrap.http-direct-port:"" + couchbase.getMappedPort(8091),
-				""spring.couchbase.username:spring"", ""spring.couchbase.password:password"",
-				""spring.couchbase.bucket.name:default"").applyTo(this.context.getEnvironment());
-	}
-
-	@AfterEach
-	void close() {
-		if (this.context != null) {
-			this.context.close();
-		}
-	}
-
 	@Test
 	void defaultConfiguration() {
-		this.context.refresh();
-		assertThat(this.context.getBeansOfType(Cluster.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(ClusterInfo.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(CouchbaseEnvironment.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(Bucket.class)).hasSize(1);
-	}
-
-	@Test
-	void customConfiguration() {
-		this.context.register(CustomConfiguration.class);
-		this.context.refresh();
-		assertThat(this.context.getBeansOfType(Cluster.class)).hasSize(2);
-		assertThat(this.context.getBeansOfType(ClusterInfo.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(CouchbaseEnvironment.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(Bucket.class)).hasSize(2);
+		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(CouchbaseEnvironment.class)
+				.hasSingleBean(Cluster.class).hasSingleBean(ClusterInfo.class).hasSingleBean(Bucket.class));
 	}
 
 	@Configuration(proxyBeanMethods = false)
@@ -116,7 +88,7 @@ Cluster myCustomCouchbaseCluster() {
 
 		@Bean
 		Bucket myCustomCouchbaseClient() {
-			return mock(CouchbaseBucket.class);
+			return mock(Bucket.class);
 		}
 
 	}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -18,22 +18,17 @@
 
 import java.util.function.Consumer;
 
-import com.couchbase.client.java.Bucket;
 import com.couchbase.client.java.Cluster;
-import com.couchbase.client.java.CouchbaseBucket;
-import com.couchbase.client.java.cluster.ClusterInfo;
 import com.couchbase.client.java.env.CouchbaseEnvironment;
 import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;
 import org.junit.jupiter.api.Test;
 
 import org.springframework.boot.autoconfigure.AutoConfigurations;
-import org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration;
-import org.springframework.boot.test.context.assertj.AssertableApplicationContext;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
 
 /**
  * Tests for {@link CouchbaseAutoConfiguration}.
@@ -43,38 +38,25 @@
  */
 class CouchbaseAutoConfigurationTests {
 
-	private ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
-			AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class, CouchbaseAutoConfiguration.class));
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
+			.withConfiguration(AutoConfigurations.of(CouchbaseAutoConfiguration.class));
 
 	@Test
 	void bootstrapHostsIsRequired() {
-		this.contextRunner.run(this::assertNoCouchbaseBeans);
+		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(CouchbaseEnvironment.class)
+				.doesNotHaveBean(Cluster.class));
 	}
 
 	@Test
-	void bootstrapHostsNotRequiredIfCouchbaseConfigurerIsSet() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class).run((context) -> {
-			assertThat(context).hasSingleBean(CouchbaseTestConfigurer.class);
-			// No beans are going to be created
-			assertNoCouchbaseBeans(context);
-		});
-	}
-
-	@Test
-	void bootstrapHostsIgnoredIfCouchbaseConfigurerIsSet() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
-				.withPropertyValues(""spring.couchbase.bootstrapHosts=localhost"").run((context) -> {
-					assertThat(context).hasSingleBean(CouchbaseTestConfigurer.class);
-					assertNoCouchbaseBeans(context);
+	void bootstrapHostsCreateEnvironmentAndCluster() {
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
+				.withPropertyValues(""spring.couchbase.bootstrap-hosts=localhost"").run((context) -> {
+					assertThat(context).hasSingleBean(CouchbaseEnvironment.class).hasSingleBean(Cluster.class);
+					assertThat(context.getBean(Cluster.class))
+							.isSameAs(context.getBean(CouchbaseTestConfiguration.class).couchbaseCluster());
 				});
 	}
 
-	private void assertNoCouchbaseBeans(AssertableApplicationContext context) {
-		// No beans are going to be created
-		assertThat(context).doesNotHaveBean(CouchbaseEnvironment.class).doesNotHaveBean(ClusterInfo.class)
-				.doesNotHaveBean(Cluster.class).doesNotHaveBean(Bucket.class);
-	}
-
 	@Test
 	void customizeEnvEndpoints() {
 		testCouchbaseEnv((env) -> {
@@ -147,53 +129,32 @@ void disableSslEvenWithKeyStore() {
 	}
 
 	private void testCouchbaseEnv(Consumer<DefaultCouchbaseEnvironment> environmentConsumer, String... environment) {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class).withPropertyValues(environment)
-				.run((context) -> {
-					CouchbaseProperties properties = context.getBean(CouchbaseProperties.class);
-					DefaultCouchbaseEnvironment env = new CouchbaseConfiguration(properties)
-							.initializeEnvironmentBuilder(properties).build();
-					environmentConsumer.accept(env);
-				});
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
+				.withPropertyValues(""spring.couchbase.bootstrap-hosts=localhost"").withPropertyValues(environment)
+				.run((context) -> environmentConsumer.accept(context.getBean(DefaultCouchbaseEnvironment.class)));
 	}
 
 	@Test
 	void customizeEnvWithCustomCouchbaseConfiguration() {
-		this.contextRunner.withUserConfiguration(CustomCouchbaseConfiguration.class)
+		this.contextRunner
+				.withUserConfiguration(CouchbaseTestConfiguration.class,
+						CouchbaseEnvironmentCustomizerConfiguration.class)
 				.withPropertyValues(""spring.couchbase.bootstrap-hosts=localhost"",
 						""spring.couchbase.env.timeouts.connect=100"")
 				.run((context) -> {
-					assertThat(context).hasSingleBean(CouchbaseConfiguration.class);
+					assertThat(context).hasSingleBean(DefaultCouchbaseEnvironment.class);
 					DefaultCouchbaseEnvironment env = context.getBean(DefaultCouchbaseEnvironment.class);
 					assertThat(env.socketConnectTimeout()).isEqualTo(5000);
 					assertThat(env.connectTimeout()).isEqualTo(2000);
 				});
 	}
 
-	@Configuration
-	static class CustomCouchbaseConfiguration extends CouchbaseConfiguration {
-
-		CustomCouchbaseConfiguration(CouchbaseProperties properties) {
-			super(properties);
-		}
-
-		@Override
-		protected DefaultCouchbaseEnvironment.Builder initializeEnvironmentBuilder(CouchbaseProperties properties) {
-			return super.initializeEnvironmentBuilder(properties).socketConnectTimeout(5000).connectTimeout(2000);
-		}
-
-		@Override
-		public Cluster couchbaseCluster() {
-			return mock(Cluster.class);
-		}
-
-		@Override
-		public ClusterInfo couchbaseClusterInfo() {
-			return mock(ClusterInfo.class);
-		}
+	@Configuration(proxyBeanMethods = false)
+	static class CouchbaseEnvironmentCustomizerConfiguration {
 
-		@Override
-		public Bucket couchbaseClient() {
-			return mock(CouchbaseBucket.class);
+		@Bean
+		CouchbaseEnvironmentBuilderCustomizer couchbaseEnvironmentBuilderCustomizer() {
+			return (builder) -> builder.socketConnectTimeout(5000).connectTimeout(2000);
 		}
 
 	}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -20,37 +20,33 @@
 import com.couchbase.client.java.Cluster;
 import com.couchbase.client.java.CouchbaseBucket;
 import com.couchbase.client.java.cluster.ClusterInfo;
-import com.couchbase.client.java.env.CouchbaseEnvironment;
 
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-import org.springframework.stereotype.Component;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
 
 import static org.mockito.Mockito.mock;
 
 /**
- * Test configurer for couchbase that mocks access.
+ * Test configuration for couchbase that mocks access.
  *
  * @author Stephane Nicoll
  */
-@Component
-public class CouchbaseTestConfigurer implements CouchbaseConfigurer {
+@Configuration(proxyBeanMethods = false)
+public class CouchbaseTestConfiguration {
 
-	@Override
-	public CouchbaseEnvironment couchbaseEnvironment() throws Exception {
-		return mock(CouchbaseEnvironment.class);
-	}
+	private final Cluster cluster = mock(Cluster.class);
 
-	@Override
-	public Cluster couchbaseCluster() throws Exception {
-		return mock(Cluster.class);
+	@Bean
+	public Cluster couchbaseCluster() {
+		return this.cluster;
 	}
 
-	@Override
+	@Bean
 	public ClusterInfo couchbaseClusterInfo() {
 		return mock(ClusterInfo.class);
 	}
 
-	@Override
+	@Bean
 	public Bucket couchbaseClient() {
 		return mock(CouchbaseBucket.class);
 	}
@@ -24,7 +24,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.couchbase.city.City;
 import org.springframework.boot.autoconfigure.domain.EntityScan;
 import org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration;
@@ -33,12 +33,11 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Import;
 import org.springframework.core.convert.converter.Converter;
-import org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration;
 import org.springframework.data.couchbase.config.BeanNames;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
 import org.springframework.data.couchbase.core.CouchbaseTemplate;
 import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions;
 import org.springframework.data.couchbase.core.convert.DefaultCouchbaseTypeMapper;
+import org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;
 import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
 import org.springframework.data.couchbase.core.mapping.event.ValidatingCouchbaseEventListener;
 import org.springframework.data.couchbase.core.query.Consistency;
@@ -60,26 +59,17 @@ class CouchbaseDataAutoConfigurationTests {
 
 	@Test
 	void disabledIfCouchbaseIsNotConfigured() {
-		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(IndexManager.class));
-	}
-
-	@Test
-	void customConfiguration() {
-		this.contextRunner.withUserConfiguration(CustomCouchbaseConfiguration.class).run((context) -> {
-			CouchbaseTemplate couchbaseTemplate = context.getBean(CouchbaseTemplate.class);
-			assertThat(couchbaseTemplate.getDefaultConsistency()).isEqualTo(Consistency.STRONGLY_CONSISTENT);
-		});
+		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(CouchbaseTemplate.class));
 	}
 
 	@Test
 	void validatorIsPresent() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
-				.run((context) -> assertThat(context).hasSingleBean(ValidatingCouchbaseEventListener.class));
+		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ValidatingCouchbaseEventListener.class));
 	}
 
 	@Test
 	void autoIndexIsDisabledByDefault() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class).run((context) -> {
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class).run((context) -> {
 			IndexManager indexManager = context.getBean(IndexManager.class);
 			assertThat(indexManager.isIgnoreViews()).isTrue();
 			assertThat(indexManager.isIgnoreN1qlPrimary()).isTrue();
@@ -89,7 +79,7 @@ void autoIndexIsDisabledByDefault() {
 
 	@Test
 	void enableAutoIndex() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
 				.withPropertyValues(""spring.data.couchbase.auto-index=true"").run((context) -> {
 					IndexManager indexManager = context.getBean(IndexManager.class);
 					assertThat(indexManager.isIgnoreViews()).isFalse();
@@ -100,11 +90,10 @@ void enableAutoIndex() {
 
 	@Test
 	void changeConsistency() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
 				.withPropertyValues(""spring.data.couchbase.consistency=eventually-consistent"").run((context) -> {
-					SpringBootCouchbaseDataConfiguration configuration = context
-							.getBean(SpringBootCouchbaseDataConfiguration.class);
-					assertThat(configuration.getDefaultConsistency()).isEqualTo(Consistency.EVENTUALLY_CONSISTENT);
+					CouchbaseTemplate couchbaseTemplate = context.getBean(CouchbaseTemplate.class);
+					assertThat(couchbaseTemplate.getDefaultConsistency()).isEqualTo(Consistency.EVENTUALLY_CONSISTENT);
 				});
 	}
 
@@ -121,16 +110,16 @@ void entityScanShouldSetInitialEntitySet() {
 
 	@Test
 	void typeKeyDefault() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
-				.run((context) -> assertThat(context.getBean(AbstractCouchbaseDataConfiguration.class).typeKey())
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
+				.run((context) -> assertThat(context.getBean(MappingCouchbaseConverter.class).getTypeKey())
 						.isEqualTo(DefaultCouchbaseTypeMapper.DEFAULT_TYPE_KEY));
 	}
 
 	@Test
 	void typeKeyCanBeCustomized() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
 				.withPropertyValues(""spring.data.couchbase.type-key=_custom"")
-				.run((context) -> assertThat(context.getBean(AbstractCouchbaseDataConfiguration.class).typeKey())
+				.run((context) -> assertThat(context.getBean(MappingCouchbaseConverter.class).getTypeKey())
 						.isEqualTo(""_custom""));
 	}
 
@@ -144,23 +133,8 @@ void customConversions() {
 		});
 	}
 
-	@Configuration
-	static class CustomCouchbaseConfiguration extends AbstractCouchbaseDataConfiguration {
-
-		@Override
-		protected CouchbaseConfigurer couchbaseConfigurer() {
-			return new CouchbaseTestConfigurer();
-		}
-
-		@Override
-		protected Consistency getDefaultConsistency() {
-			return Consistency.STRONGLY_CONSISTENT;
-		}
-
-	}
-
 	@Configuration(proxyBeanMethods = false)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class CustomConversionsConfig {
 
 		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
@@ -172,7 +146,7 @@ CouchbaseCustomConversions myCustomConversions() {
 
 	@Configuration(proxyBeanMethods = false)
 	@EntityScan(""org.springframework.boot.autoconfigure.data.couchbase.city"")
-	@Import(CustomCouchbaseConfiguration.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class EntityScanConfig {
 
 	}
@@ -23,7 +23,7 @@
 
 import org.springframework.boot.autoconfigure.TestAutoConfigurationPackage;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.couchbase.city.CityRepository;
 import org.springframework.boot.autoconfigure.data.couchbase.city.ReactiveCityRepository;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;
@@ -62,7 +62,7 @@ static class ImperativeAndReactiveConfiguration {
 	}
 
 	@Configuration(proxyBeanMethods = false)
-	@Import({ CouchbaseTestConfigurer.class, Registrar.class })
+	@Import({ CouchbaseTestConfiguration.class, Registrar.class })
 	static class BaseConfiguration {
 
 	}
@@ -24,7 +24,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.couchbase.city.City;
 import org.springframework.boot.autoconfigure.domain.EntityScan;
 import org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration;
@@ -33,15 +33,11 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Import;
 import org.springframework.core.convert.converter.Converter;
-import org.springframework.data.couchbase.config.AbstractReactiveCouchbaseDataConfiguration;
 import org.springframework.data.couchbase.config.BeanNames;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
 import org.springframework.data.couchbase.core.RxJavaCouchbaseTemplate;
 import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions;
 import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
 import org.springframework.data.couchbase.core.mapping.event.ValidatingCouchbaseEventListener;
-import org.springframework.data.couchbase.core.query.Consistency;
-import org.springframework.data.couchbase.repository.support.IndexManager;
 import org.springframework.test.util.ReflectionTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -60,20 +56,12 @@ class CouchbaseReactiveDataAutoConfigurationTests {
 
 	@Test
 	void disabledIfCouchbaseIsNotConfigured() {
-		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(IndexManager.class));
-	}
-
-	@Test
-	void customConfiguration() {
-		this.contextRunner.withUserConfiguration(CustomCouchbaseConfiguration.class).run((context) -> {
-			RxJavaCouchbaseTemplate rxJavaCouchbaseTemplate = context.getBean(RxJavaCouchbaseTemplate.class);
-			assertThat(rxJavaCouchbaseTemplate.getDefaultConsistency()).isEqualTo(Consistency.STRONGLY_CONSISTENT);
-		});
+		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(RxJavaCouchbaseTemplate.class));
 	}
 
 	@Test
 	void validatorIsPresent() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
 				.run((context) -> assertThat(context).hasSingleBean(ValidatingCouchbaseEventListener.class));
 	}
 
@@ -98,23 +86,8 @@ void customConversions() {
 		});
 	}
 
-	@Configuration
-	static class CustomCouchbaseConfiguration extends AbstractReactiveCouchbaseDataConfiguration {
-
-		@Override
-		protected CouchbaseConfigurer couchbaseConfigurer() {
-			return new CouchbaseTestConfigurer();
-		}
-
-		@Override
-		protected Consistency getDefaultConsistency() {
-			return Consistency.STRONGLY_CONSISTENT;
-		}
-
-	}
-
 	@Configuration(proxyBeanMethods = false)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class CustomConversionsConfig {
 
 		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
@@ -126,7 +99,7 @@ CouchbaseCustomConversions myCustomConversions() {
 
 	@Configuration(proxyBeanMethods = false)
 	@EntityScan(""org.springframework.boot.autoconfigure.data.couchbase.city"")
-	@Import(CustomCouchbaseConfiguration.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class EntityScanConfig {
 
 	}
@@ -21,7 +21,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.autoconfigure.TestAutoConfigurationPackage;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.alt.couchbase.CityCouchbaseRepository;
 import org.springframework.boot.autoconfigure.data.alt.couchbase.ReactiveCityCouchbaseRepository;
 import org.springframework.boot.autoconfigure.data.couchbase.city.City;
@@ -86,22 +86,22 @@ void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(City.class)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class DefaultConfiguration {
 
 	}
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(EmptyDataPackage.class)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class NoRepositoryConfiguration {
 
 	}
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(CouchbaseReactiveRepositoriesAutoConfigurationTests.class)
 	@EnableCouchbaseRepositories(basePackageClasses = CityCouchbaseRepository.class)
-	@Import(CouchbaseDataAutoConfigurationTests.CustomCouchbaseConfiguration.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class CustomizedConfiguration {
 
 	}
@@ -21,7 +21,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.autoconfigure.TestAutoConfigurationPackage;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.couchbase.city.City;
 import org.springframework.boot.autoconfigure.data.couchbase.city.CityRepository;
 import org.springframework.boot.autoconfigure.data.empty.EmptyDataPackage;
@@ -82,14 +82,14 @@ static class CouchbaseNotAvailableConfiguration {
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(City.class)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class DefaultConfiguration {
 
 	}
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(EmptyDataPackage.class)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class NoRepositoryConfiguration {
 
 	}
@@ -4485,7 +4485,6 @@ Generally, you provide the bootstrap hosts, bucket name, and password, as shown
 ----
 
 TIP: You need to provide _at least_ the bootstrap host(s), in which case the bucket name is `default` and the password is an empty String.
-Alternatively, you can define your own `org.springframework.data.couchbase.config.CouchbaseConfigurer` `@Bean` to take control over the whole configuration.
 
 It is also possible to customize some of the `CouchbaseEnvironment` settings.
 For instance, the following configuration changes the timeout to use to open a new `Bucket` and enables SSL support:
@@ -4497,7 +4496,8 @@ For instance, the following configuration changes the timeout to use to open a n
 	spring.couchbase.env.ssl.key-store-password=secret
 ----
 
-Check the `spring.couchbase.env.*` properties for more details.
+TIP: Check the `spring.couchbase.env.*` properties for more details.
+To take more control, one or more `CouchbaseEnvironmentBuilderCustomizer` beans can be used.
 
 
 
"
https://github.com/apache/dubbo/commit/09722e3a93ad4ba40edf38ebdbfd7afee4977ee6,Remove unnecessary dependencies ,https://api.github.com/repos/apache/dubbo/commits/09722e3a93ad4ba40edf38ebdbfd7afee4977ee6,"@@ -35,20 +35,6 @@ limitations under the License.
             <artifactId>dubbo-common</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
-        <dependency>
-            <groupId>org.mortbay.jetty</groupId>
-            <artifactId>jetty</artifactId>
-            <exclusions>
-                <exclusion>
-                    <groupId>org.mortbay.jetty</groupId>
-                    <artifactId>servlet-api</artifactId>
-                </exclusion>
-            </exclusions>
-        </dependency>
-        <dependency>
-            <groupId>javax.servlet</groupId>
-            <artifactId>javax.servlet-api</artifactId>
-        </dependency>
     </dependencies>
     <build>
         <plugins>
"
https://github.com/spring-projects/spring-boot/commit/12bfca56d617f935e0a53760bf18f300eba8a430,Remove unnecessary null check  <enter> See  <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/12bfca56d617f935e0a53760bf18f300eba8a430,"@@ -34,7 +34,6 @@
 import org.springframework.context.annotation.Conditional;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.core.env.Environment;
-import org.springframework.core.io.DefaultResourceLoader;
 import org.springframework.core.io.Resource;
 import org.springframework.core.io.ResourceLoader;
 import org.springframework.core.io.support.EncodedResource;
@@ -95,12 +94,9 @@ private Properties loadSource(Resource location, Charset encoding) throws IOExce
 
 	static class GitResourceAvailableCondition extends SpringBootCondition {
 
-		private final ResourceLoader defaultResourceLoader = new DefaultResourceLoader();
-
 		@Override
 		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
 			ResourceLoader loader = context.getResourceLoader();
-			loader = (loader != null) ? loader : this.defaultResourceLoader;
 			Environment environment = context.getEnvironment();
 			String location = environment.getProperty(""spring.info.git.location"");
 			if (location == null) {
"
https://github.com/spring-projects/spring-boot/commit/036aace2cca7f33c0e96d3b222376b48947b735f,Add details in Jest ElasticSearch HealthIndicator  <enter> This commit polishes the previous one and aligns the Jest HealthIndicator with the changes made for the REST variant. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/036aace2cca7f33c0e96d3b222376b48947b735f,"@@ -16,14 +16,16 @@
 
 package org.springframework.boot.actuate.elasticsearch;
 
-import com.google.gson.JsonElement;
-import com.google.gson.JsonParser;
+import java.util.Map;
+
 import io.searchbox.client.JestClient;
 import io.searchbox.client.JestResult;
 
 import org.springframework.boot.actuate.health.AbstractHealthIndicator;
 import org.springframework.boot.actuate.health.Health;
 import org.springframework.boot.actuate.health.HealthIndicator;
+import org.springframework.boot.json.JsonParser;
+import org.springframework.boot.json.JsonParserFactory;
 
 /**
  * {@link HealthIndicator} for Elasticsearch using a {@link JestClient}.
@@ -37,7 +39,7 @@ public class ElasticsearchJestHealthIndicator extends AbstractHealthIndicator {
 
 	private final JestClient jestClient;
 
-	private final JsonParser jsonParser = new JsonParser();
+	private final JsonParser jsonParser = JsonParserFactory.getJsonParser();
 
 	public ElasticsearchJestHealthIndicator(JestClient jestClient) {
 		super(""Elasticsearch health check failed"");
@@ -50,17 +52,19 @@ protected void doHealthCheck(Health.Builder builder) throws Exception {
 				.execute(new io.searchbox.cluster.Health.Builder().build());
 		if (healthResult.getResponseCode() != 200 || !healthResult.isSucceeded()) {
 			builder.down();
+			builder.withDetail(""statusCode"", healthResult.getResponseCode());
 		}
 		else {
-			JsonElement root = this.jsonParser.parse(healthResult.getJsonString());
-			JsonElement status = root.getAsJsonObject().get(""status"");
-			if (status.getAsString()
-					.equals(io.searchbox.cluster.Health.Status.RED.getKey())) {
+			Map<String, Object> response = this.jsonParser
+					.parseMap(healthResult.getJsonString());
+			String status = (String) response.get(""status"");
+			if (status.equals(io.searchbox.cluster.Health.Status.RED.getKey())) {
 				builder.outOfService();
 			}
 			else {
 				builder.up();
 			}
+			builder.withDetails(response);
 		}
 	}
 
@@ -17,6 +17,7 @@
 package org.springframework.boot.actuate.elasticsearch;
 
 import java.io.IOException;
+import java.util.Map;
 
 import com.google.gson.Gson;
 import com.google.gson.JsonParser;
@@ -31,6 +32,7 @@
 import org.springframework.boot.actuate.health.Status;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.entry;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
@@ -56,6 +58,16 @@ public void elasticsearchIsUp() throws IOException {
 				.willReturn(createJestResult(200, true, ""green""));
 		Health health = this.healthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.UP);
+		assertHealthDetailsWithStatus(health.getDetails(), ""green"");
+	}
+
+	@Test
+	public void elasticsearchWithYellowStatusIsUp() throws IOException {
+		given(this.jestClient.execute(any(Action.class)))
+				.willReturn(createJestResult(200, true, ""yellow""));
+		Health health = this.healthIndicator.health();
+		assertThat(health.getStatus()).isEqualTo(Status.UP);
+		assertHealthDetailsWithStatus(health.getDetails(), ""yellow"");
 	}
 
 	@SuppressWarnings(""unchecked"")
@@ -83,6 +95,7 @@ public void elasticsearchIsDownByResponseCode() throws IOException {
 				.willReturn(createJestResult(500, false, """"));
 		Health health = this.healthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
+		assertThat(health.getDetails()).contains(entry(""statusCode"", 500));
 	}
 
 	@SuppressWarnings(""unchecked"")
@@ -92,6 +105,21 @@ public void elasticsearchIsOutOfServiceByStatus() throws IOException {
 				.willReturn(createJestResult(200, true, ""red""));
 		Health health = this.healthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
+		assertHealthDetailsWithStatus(health.getDetails(), ""red"");
+	}
+
+	private void assertHealthDetailsWithStatus(Map<String, Object> details,
+			String status) {
+		assertThat(details).contains(entry(""cluster_name"", ""elasticsearch""),
+				entry(""status"", status), entry(""timed_out"", false),
+				entry(""number_of_nodes"", 1), entry(""number_of_data_nodes"", 1),
+				entry(""active_primary_shards"", 0), entry(""active_shards"", 0),
+				entry(""relocating_shards"", 0), entry(""initializing_shards"", 0),
+				entry(""unassigned_shards"", 0), entry(""delayed_unassigned_shards"", 0),
+				entry(""number_of_pending_tasks"", 0),
+				entry(""number_of_in_flight_fetch"", 0),
+				entry(""task_max_waiting_in_queue_millis"", 0),
+				entry(""active_shards_percent_as_number"", 100.0));
 	}
 
 	private static JestResult createJestResult(int responseCode, boolean succeeded,
@@ -18,6 +18,7 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.util.Map;
 
 import org.apache.http.StatusLine;
 import org.apache.http.entity.BasicHttpEntity;
@@ -64,17 +65,7 @@ public void elasticsearchIsUp() throws IOException {
 
 		Health health = this.elasticsearchRestHealthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.UP);
-
-		assertThat(health.getDetails()).contains(entry(""cluster_name"", ""elasticsearch""),
-				entry(""status"", ""green""), entry(""timed_out"", false),
-				entry(""number_of_nodes"", 1), entry(""number_of_data_nodes"", 1),
-				entry(""active_primary_shards"", 0), entry(""active_shards"", 0),
-				entry(""relocating_shards"", 0), entry(""initializing_shards"", 0),
-				entry(""unassigned_shards"", 0), entry(""delayed_unassigned_shards"", 0),
-				entry(""number_of_pending_tasks"", 0),
-				entry(""number_of_in_flight_fetch"", 0),
-				entry(""task_max_waiting_in_queue_millis"", 0),
-				entry(""active_shards_percent_as_number"", 100.0));
+		assertHealthDetailsWithStatus(health.getDetails(), ""green"");
 	}
 
 	@Test
@@ -93,17 +84,7 @@ public void elasticsearchWithYellowStatusIsUp() throws IOException {
 
 		Health health = this.elasticsearchRestHealthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.UP);
-
-		assertThat(health.getDetails()).contains(entry(""cluster_name"", ""elasticsearch""),
-				entry(""status"", ""yellow""), entry(""timed_out"", false),
-				entry(""number_of_nodes"", 1), entry(""number_of_data_nodes"", 1),
-				entry(""active_primary_shards"", 0), entry(""active_shards"", 0),
-				entry(""relocating_shards"", 0), entry(""initializing_shards"", 0),
-				entry(""unassigned_shards"", 0), entry(""delayed_unassigned_shards"", 0),
-				entry(""number_of_pending_tasks"", 0),
-				entry(""number_of_in_flight_fetch"", 0),
-				entry(""task_max_waiting_in_queue_millis"", 0),
-				entry(""active_shards_percent_as_number"", 100.0));
+		assertHealthDetailsWithStatus(health.getDetails(), ""yellow"");
 	}
 
 	@Test
@@ -119,7 +100,6 @@ public void elasticsearchIsDown() throws IOException {
 
 	@Test
 	public void elasticsearchIsDownByResponseCode() throws IOException {
-
 		Response response = mock(Response.class);
 		StatusLine statusLine = mock(StatusLine.class);
 
@@ -150,8 +130,13 @@ public void elasticsearchIsOutOfServiceByStatus() throws IOException {
 
 		Health health = this.elasticsearchRestHealthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
-		assertThat(health.getDetails()).contains(entry(""cluster_name"", ""elasticsearch""),
-				entry(""status"", ""red""), entry(""timed_out"", false),
+		assertHealthDetailsWithStatus(health.getDetails(), ""red"");
+	}
+
+	private void assertHealthDetailsWithStatus(Map<String, Object> details,
+			String status) {
+		assertThat(details).contains(entry(""cluster_name"", ""elasticsearch""),
+				entry(""status"", status), entry(""timed_out"", false),
 				entry(""number_of_nodes"", 1), entry(""number_of_data_nodes"", 1),
 				entry(""active_primary_shards"", 0), entry(""active_shards"", 0),
 				entry(""relocating_shards"", 0), entry(""initializing_shards"", 0),
"
https://github.com/square/retrofit/commit/a19609a16359af66aec5410459899291b2c45cf1,Add example of using JSON converter as a String converter.  <enter> This also adds the Retrofit instance as a param to the string converter to allow it to delegate to others directly. This brings it into parity with the method signatures of the other converter methods anyway. ,https://api.github.com/repos/square/retrofit/commits/a19609a16359af66aec5410459899291b2c45cf1,"@@ -47,7 +47,8 @@ public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] an
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     if (type == String.class) {
       return StringConverter.INSTANCE;
     }
@@ -69,7 +69,8 @@ public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] an
      * {@link Header @Header}, {@link Path @Path}, {@link Query @Query}, and
      * {@link QueryMap @QueryMap} values.
      */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
       return null;
     }
   }
@@ -343,7 +343,7 @@ public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotati
 
     for (int i = 0, count = converterFactories.size(); i < count; i++) {
       Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations);
+          converterFactories.get(i).stringConverter(type, annotations, this);
       if (converter != null) {
         //noinspection unchecked
         return (Converter<T, String>) converter;
@@ -354,7 +354,8 @@ public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] an
   @Test public void parameterAnnotationsPassedToStringConverter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         annotationsRef.set(annotations);
 
         return new Converter<Object, String>() {
@@ -377,7 +378,8 @@ class MyConverterFactory extends Converter.Factory {
 
   @Test public void stringConverterNotCalledForString() {
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         throw new AssertionError();
       }
     }
@@ -394,7 +396,8 @@ class MyConverterFactory extends Converter.Factory {
   @Test public void stringConverterReturningNullResultsInDefault() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -945,12 +948,12 @@ class MyConverterFactory extends Converter.Factory {
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations);
+    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
 
     Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
-    verify(factory).stringConverter(type, annotations);
+    verify(factory).stringConverter(type, annotations, retrofit);
     verifyNoMoreInteractions(factory);
   }
 
@@ -39,7 +39,8 @@ public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] an
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     called = true;
     return null;
   }
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.http.GET;
+import retrofit2.http.Query;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+public final class JsonQueryParameters {
+  @Retention(RUNTIME)
+  @interface Json {
+  }
+
+  static class JsonStringConverterFactory extends Converter.Factory {
+    private final Converter.Factory delegateFactory;
+
+    JsonStringConverterFactory(Converter.Factory delegateFactory) {
+      this.delegateFactory = delegateFactory;
+    }
+
+    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        if (annotation instanceof Json) {
+          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+          // reference to it explicitly as a field.
+          Converter<?, RequestBody> delegate =
+              delegateFactory.requestBodyConverter(type, annotations, retrofit);
+          return new DelegateToStringConverter<>(delegate);
+        }
+      }
+      return null;
+    }
+
+    static class DelegateToStringConverter<T> implements Converter<T, String> {
+      private final Converter<T, RequestBody> delegate;
+
+      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override public String convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        delegate.convert(value).writeTo(buffer);
+        return buffer.readUtf8();
+      }
+    }
+  }
+
+  static class Filter {
+    public final String userId;
+
+    public Filter(String userId) {
+      this.userId = userId;
+    }
+  }
+
+  interface Service {
+    @GET(""/filter"")
+    Call<ResponseBody> example(@Json @Query(""value"") Filter value);
+  }
+
+  public static void main(String... args) throws IOException, InterruptedException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse());
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url(""/""))
+        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Call<ResponseBody> call = service.example(new Filter(""123""));
+    Response<ResponseBody> response = call.execute();
+    // TODO handle user response...
+
+    // Print the request path that the server saw to show the JSON query param:
+    RecordedRequest recordedRequest = server.takeRequest();
+    System.out.println(recordedRequest.getPath());
+
+    server.shutdown();
+  }
+}
"
https://github.com/apache/dubbo/commit/8b6f4456d5664f4e7f32b0e772befc4b12086aaa,Minor improvement on test cases: <pr_link> <enter> 1. Use org.junit.Assert instead of junit.framework.Assert(@Deprecated since Junit 4) <enter> 2. Use assertTrue and other assert methods through static import to make codes easier to read,https://api.github.com/repos/apache/dubbo/commits/8b6f4456d5664f4e7f32b0e772befc4b12086aaa,"@@ -19,8 +19,8 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class StatItemTest {
 
@@ -21,12 +21,16 @@
 import com.alibaba.dubbo.rpc.Invocation;
 import com.alibaba.dubbo.rpc.RpcInvocation;
 
-import junit.framework.Assert;
 import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.Map;
 
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+
 public class RpcUtilsTest {
 
     /**
@@ -43,9 +47,9 @@ public void testAttachInvocationIdIfAsync_normal() {
         long id1 = RpcUtils.getInvocationId(inv);
         RpcUtils.attachInvocationIdIfAsync(url, inv);
         long id2 = RpcUtils.getInvocationId(inv);
-        Assert.assertTrue(id1 == id2); // verify if it's idempotent
-        Assert.assertTrue(id1 >= 0);
-        Assert.assertEquals(""bb"", attachments.get(""aa""));
+        assertTrue(id1 == id2); // verify if it's idempotent
+        assertTrue(id1 >= 0);
+        assertEquals(""bb"", attachments.get(""aa""));
     }
 
     /**
@@ -57,7 +61,7 @@ public void testAttachInvocationIdIfAsync_sync() {
         URL url = URL.valueOf(""dubbo://localhost/"");
         Invocation inv = new RpcInvocation(""test"", new Class[]{}, new String[]{});
         RpcUtils.attachInvocationIdIfAsync(url, inv);
-        Assert.assertNull(RpcUtils.getInvocationId(inv));
+        assertNull(RpcUtils.getInvocationId(inv));
     }
 
     /**
@@ -69,7 +73,7 @@ public void testAttachInvocationIdIfAsync_nullAttachments() {
         URL url = URL.valueOf(""dubbo://localhost/?test.async=true"");
         Invocation inv = new RpcInvocation(""test"", new Class[]{}, new String[]{});
         RpcUtils.attachInvocationIdIfAsync(url, inv);
-        Assert.assertTrue(RpcUtils.getInvocationId(inv) >= 0l);
+        assertTrue(RpcUtils.getInvocationId(inv) >= 0l);
     }
 
     /**
@@ -81,7 +85,7 @@ public void testAttachInvocationIdIfAsync_forceNotAttache() {
         URL url = URL.valueOf(""dubbo://localhost/?test.async=true&"" + Constants.AUTO_ATTACH_INVOCATIONID_KEY + ""=false"");
         Invocation inv = new RpcInvocation(""test"", new Class[]{}, new String[]{});
         RpcUtils.attachInvocationIdIfAsync(url, inv);
-        Assert.assertNull(RpcUtils.getInvocationId(inv));
+        assertNull(RpcUtils.getInvocationId(inv));
     }
 
     /**
@@ -93,6 +97,6 @@ public void testAttachInvocationIdIfAsync_forceAttache() {
         URL url = URL.valueOf(""dubbo://localhost/?"" + Constants.AUTO_ATTACH_INVOCATIONID_KEY + ""=true"");
         Invocation inv = new RpcInvocation(""test"", new Class[]{}, new String[]{});
         RpcUtils.attachInvocationIdIfAsync(url, inv);
-        Assert.assertNotNull(RpcUtils.getInvocationId(inv));
+        assertNotNull(RpcUtils.getInvocationId(inv));
     }
 }
"
https://github.com/junit-team/junit4/commit/a3e01b1ebea12f5fdfb6349e9e72623ac1f3b232,Cleaning up indentation  <enter> The inline method refactoring conducted by eclipse introduced some extra tabs. <enter> Incomplete - task : Issue 551: Resolve sensitive equality in MethodSorter test. ,https://api.github.com/repos/junit-team/junit4/commits/a3e01b1ebea12f5fdfb6349e9e72623ac1f3b232,"@@ -54,18 +54,18 @@ void subBowser() {
     }
 
     private List<String> getDeclaredFilteredMethods(Class<?> clazz, List<String> ofInterest) {
-    	// the method under test.
-		Method[] actualMethods = MethodSorter.getDeclaredMethods(clazz);
-		
-		// obtain just the names instead of the full methods.
-		List<String> names = new ArrayList<String>();
-		for (Method m : actualMethods) {
-			names.add(m.toString().replace(clazz.getName() + '.', """"));
-		}
-		
-		// filter to just the methods of interest
-    	names.retainAll(ofInterest);   	
-    	return names;
+        // the method under test.
+	    Method[] actualMethods = MethodSorter.getDeclaredMethods(clazz);
+
+        // obtain just the names instead of the full methods.
+        List<String> names = new ArrayList<String>();
+        for (Method m : actualMethods) {
+            names.add(m.toString().replace(clazz.getName() + '.', """"));
+        }
+
+        // filter to just the methods of interest
+        names.retainAll(ofInterest);   	
+        return names;
     }
 
 	@Test
@@ -142,7 +142,7 @@ void delta() {
         void epsilon() {
         }
     }
-    
+
     @Test
     public void testJvmMethodSorter() {
     	Method[] fromJvm = DummySortJvm.class.getDeclaredMethods();
"
https://github.com/junit-team/junit4/commit/638e82435a01af83e77c23e9f8d7b658a89eb4bf,"Use %n in string.format() ( <pr_link> )  <enter> In format strings, it is generally preferable better to use %n, which will produce the platform-specific line separator. ",https://api.github.com/repos/junit-team/junit4/commits/638e82435a01af83e77c23e9f8d7b658a89eb4bf,"@@ -40,7 +40,7 @@ public String getMessage() {
         StringBuilder sb = new StringBuilder(
                 String.format(""There were %d errors:"", fErrors.size()));
         for (Throwable e : fErrors) {
-            sb.append(String.format(""\n  %s(%s)"", e.getClass().getName(), e.getMessage()));
+            sb.append(String.format(""%n  %s(%s)"", e.getClass().getName(), e.getMessage()));
         }
         return sb.toString();
     }
"
https://github.com/spring-projects/spring-boot/commit/7019894f0ec7f6fd27121d94aa08022bd3040af9,"Clarify the role of spring-boot-starter-cache  <enter> The cache abstraction is a core feature of the Spring Framework. Basic features such as `@EnableCaching` are therefore available by default with no extra dependencies necessary. <enter> However, the actual cache adapters for JCache, Ehcache 2.x, Caffeine and Guava are located in a separated module, `spring-context-support`. Spring Boot provides that artifact via the `spring-boot-starter-cache` starter. <enter> It is quite easy to 'only' add the cache library dependencies and forget about this extra dependencies since `@EnableCaching` is available by default. This commit clarifies the role of the starer in each section so that it is more obvious. We're already explaining this at the beginning of the section but it seems that's not enough. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/7019894f0ec7f6fd27121d94aa08022bd3040af9,"@@ -3782,9 +3782,10 @@ enabled via the `@EnableCaching` annotation.
 NOTE: If you are using the cache infrastructure with beans that are not interface-based,
 make sure to enable the `proxyTargetClass` attribute of `@EnableCaching`.
 
-TIP: Use the `spring-boot-starter-cache` '`Starter`' to quickly add required caching
-dependencies. If you are adding dependencies manually you should note that certain
-implementations are only provided by the `spring-context-support` jar.
+TIP: Use the `spring-boot-starter-cache` '`Starter`' to quickly add basic caching
+dependencies. The starter brings `spring-context-support`: if you are adding dependencies
+manually, you must include it if you intend to use the JCache, EhCache 2.x or Guava
+support.
 
 If you haven't defined a bean of type `CacheManager` or a `CacheResolver` named
 `cacheResolver` (see `CachingConfigurer`), Spring Boot tries to detect the following
@@ -3842,9 +3843,10 @@ Generic caching is used if the context defines _at least_ one
 [[boot-features-caching-provider-jcache]]
 ==== JCache (JSR-107)
 JCache is bootstrapped via the presence of a `javax.cache.spi.CachingProvider` on the
-classpath (i.e. a JSR-107 compliant caching library). There are various compliant
+classpath (i.e. a JSR-107 compliant caching library) and the `JCacheCacheManager`
+provided by the `spring-boot-starter-cache` '`Starter`'. There are various compliant
 libraries out there and Spring Boot provides dependency management for Ehcache 3,
-Hazelcast and Infinispan). Any other compliant library can be added as well.
+Hazelcast and Infinispan. Any other compliant library can be added as well.
 
 It might happen that more than one provider is present, in which case the provider must
 be explicitly specified. Even if the JSR-107 standard does not enforce a standardized
@@ -3879,8 +3881,9 @@ abstraction expects. No further customization is applied on it.
 [[boot-features-caching-provider-ehcache2]]
 ==== EhCache 2.x
 EhCache 2.x is used if a file named `ehcache.xml` can be found at the root of the
-classpath. If EhCache 2.x and such file is present it is used to bootstrap the cache
-manager. An alternate configuration file can be provide a well using:
+classpath. If EhCache 2.x, the `EhCacheCacheManager` provided by the
+`spring-boot-starter-cache` '`Starter`' and such file is present it is used to bootstrap
+the cache manager. An alternate configuration file can be provide a well using:
 
 [source,properties,indent=0]
 ----
@@ -3994,9 +3997,10 @@ recommend to keep this setting enabled if you create your own `RedisCacheManager
 [[boot-features-caching-provider-caffeine]]
 ==== Caffeine
 Caffeine is a Java 8 rewrite of Guava’s cache and will supersede the Guava support in
-Spring Boot 2.0. If Caffeine is present, a `CaffeineCacheManager` is auto-configured.
-Caches can be created on startup using the `spring.cache.cache-names` property and
-customized by one of the following (in this order):
+Spring Boot 2.0. If Caffeine is present, a `CaffeineCacheManager` (provided by the
+`spring-boot-starter-cache` '`Starter`') is auto-configured. Caches can be created on
+startup using the `spring.cache.cache-names` property and customized by one of the
+following (in this order):
 
 1. A cache spec defined by `spring.cache.caffeine.spec`
 2. A `com.github.benmanes.caffeine.cache.CaffeineSpec` bean is defined
"
https://github.com/square/retrofit/commit/8eed9f264c13710fc0ac8251b3c5382a129a10ce,Add missing Call wrappers as return type ,https://api.github.com/repos/square/retrofit/commits/8eed9f264c13710fc0ac8251b3c5382a129a10ce,"@@ -80,13 +80,13 @@ <h4>Request Method</h4>
               <h4>URL Manipulation</h4>
               <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
               <pre class=""prettyprint"">@GET(""/group/{id}/users"")
-List&lt;User> groupList(@Path(""id"") int groupId);</pre>
+Call&lt;List&lt;User>> groupList(@Path(""id"") int groupId);</pre>
               <p>Query parameters can also be added.</p>
               <pre class=""prettyprint"">@GET(""/group/{id}/users"")
-List&lt;User> groupList(@Path(""id"") int groupId, @Query(""sort"") String sort);</pre>
+Call&lt;List&lt;User>> groupList(@Path(""id"") int groupId, @Query(""sort"") String sort);</pre>
               <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
               <pre class=""prettyprint"">@GET(""/group/{id}/users"")
-List&lt;User> groupList(@Path(""id"") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
+Call&lt;List&lt;User>> groupList(@Path(""id"") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
               <h4>Request Body</h4>
               <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
"
https://github.com/square/okhttp/commit/99f2bafe1c0abb2791131dde5a702d3bb3ba28f3,"Fix isClosed() when a cache has not been initialized  <enter> isClosed() now means 'has close() been called', after commit  <otherCommit_link>  it meant 'has not been initialized or close() has been called'. <enter> Introduced explicit closed state. Minor tweak to use initialized state to determine whether cleanup will do anything. Added a test. ",https://api.github.com/repos/square/okhttp/commits/99f2bafe1c0abb2791131dde5a702d3bb3ba28f3,"@@ -1081,6 +1081,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertFalse(iterator.hasNext());
   }
 
+  @Test public void isClosed_uninitializedCache() throws Exception {
+    // Create an uninitialized cache.
+    cache = new DiskLruCache(cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    assertFalse(cache.isClosed());
+    cache.close();
+    assertTrue(cache.isClosed());
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -152,6 +152,7 @@ public final class DiskLruCache implements Closeable {
 
   // Must be read and written when synchronized on 'this'.
   private boolean initialized;
+  private boolean closed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given
@@ -165,8 +166,8 @@ public final class DiskLruCache implements Closeable {
   private final Runnable cleanupRunnable = new Runnable() {
     public void run() {
       synchronized (DiskLruCache.this) {
-        if (isClosed()) {
-          return; // Closed.
+        if (!initialized | closed) {
+          return; // Nothing to do
         }
         try {
           trimToSize();
@@ -221,6 +222,7 @@ void initialize() throws IOException {
         Platform.get().logW(""DiskLruCache "" + directory + "" is corrupt: ""
             + journalIsCorrupt.getMessage() + "", removing"");
         delete();
+        closed = false;
       }
     }
 
@@ -490,7 +492,9 @@ public synchronized long getMaxSize() {
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
-    executor.execute(cleanupRunnable);
+    if (initialized) {
+      executor.execute(cleanupRunnable);
+    }
   }
 
   /**
@@ -615,7 +619,7 @@ private boolean removeEntry(Entry entry) throws IOException {
 
   /** Returns true if this cache has been closed. */
   public synchronized boolean isClosed() {
-    return journalWriter == null;
+    return closed;
   }
 
   private synchronized void checkNotClosed() {
@@ -635,8 +639,9 @@ public synchronized void flush() throws IOException {
 
   /** Closes this cache. Stored values will remain on the filesystem. */
   public synchronized void close() throws IOException {
-    if (isClosed()) {
-      return; // Already closed.
+    if (!initialized || closed) {
+      closed = true;
+      return;
     }
     // Copying for safe iteration.
     for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
@@ -647,6 +652,7 @@ public synchronized void close() throws IOException {
     trimToSize();
     journalWriter.close();
     journalWriter = null;
+    closed = true;
   }
 
   private void trimToSize() throws IOException {
@@ -726,7 +732,7 @@ public synchronized Iterator<Snapshot> snapshots() throws IOException {
 
         synchronized (DiskLruCache.this) {
           // If the cache is closed, truncate the iterator.
-          if (isClosed()) return false;
+          if (closed) return false;
 
           while (delegate.hasNext()) {
             Entry entry = delegate.next();
"
https://github.com/square/retrofit/commit/6f8a9a664c0198992b8478e0671cc4a7db4f1d8e,Add missing import. ,https://api.github.com/repos/square/retrofit/commits/6f8a9a664c0198992b8478e0671cc4a7db4f1d8e,"@@ -24,6 +24,7 @@
 import retrofit2.http.Field;
 import retrofit2.http.FieldMap;
 import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
 import retrofit2.http.Part;
 import retrofit2.http.PartMap;
 import retrofit2.http.Path;
"
https://github.com/junit-team/junit4/commit/5785d9df8fe25f68567272850cd65b4dc07da617,Deprecate rule ExpectedException ( <pr_link> )  <enter> The method Assert.assertThrows provides a nicer way for verifying exceptions. In addition the use of ExpectedException is error-prone when used with other rules like TestWatcher because the order of rules is important in that case. ,https://api.github.com/repos/junit-team/junit4/commits/5785d9df8fe25f68567272850cd65b4dc07da617,"@@ -14,11 +14,7 @@
 
 /**
  * The {@code ExpectedException} rule allows you to verify that your code
- * throws a specific exception. Note that, starting with Java 8,
- * {@link org.junit.Assert#assertThrows(java.lang.Class, org.junit.function.ThrowingRunnable)
- * Assert.assertThrows}
- * is often a better choice since it allows you to express exactly where you
- * expect the exception to be thrown.
+ * throws a specific exception.
  *
  * <h3>Usage</h3>
  *
@@ -110,6 +106,10 @@
  * exception. E.g. ""Test doesn't throw %s."" will fail with the error message
  * ""Test doesn't throw an instance of foo."".
  *
+ * @deprecated Since 4.13
+ * {@link org.junit.Assert#assertThrows(Class, org.junit.function.ThrowingRunnable)
+ * Assert.assertThrows} can be used to verify that your code throws a specific
+ * exception.
  * @since 4.7
  */
 public class ExpectedException implements TestRule {
"
https://github.com/square/okhttp/commit/6909923b89d98fef39600a170aa50e566dbb730a,Update CHANGELOG.md ,https://api.github.com/repos/square/okhttp/commits/6909923b89d98fef39600a170aa50e566dbb730a,"@@ -35,7 +35,7 @@ _2014-12-30_
  *  Fix: Cache 302s and 308s that include appropriate response headers.
  *  Fix: Improve pooling of connections that use proxy selectors.
  *  Fix: Don't leak connections when using ALPN on the desktop.
- *  Fix: Update Jetty ALPN to `7.1.2.v20141202` (Java 7) and 8.1.2.v20141202 (Java 8).
+ *  Fix: Update Jetty ALPN to `7.1.2.v20141202` (Java 7) and `8.1.2.v20141202` (Java 8).
     This fixes a bug in resumed TLS sessions where the wrong protocol could be
     selected.
  *  Fix: Don't crash in SPDY and HTTP/2 when disconnecting before connecting.
"
https://github.com/square/retrofit/commit/fb746cb2f67a51c100e368844ac26dedb9e8eac4,"Expose success type on RetrofitError.  <enter> There's a bit of a test gap going on for all the variants of successful and erroneous handling of sync, async, and rx. This new behavior is fully tested in all three but more general behavior testing for them will be needed in in a follow-up. ",https://api.github.com/repos/square/retrofit/commits/fb746cb2f67a51c100e368844ac26dedb9e8eac4,"@@ -8,7 +8,7 @@ class MockHttpRetrofitError extends RetrofitError {
   private final Object body;
 
   MockHttpRetrofitError(String message, String url, Response response, Object body) {
-    super(message, url, response, null, null, false, null);
+    super(message, url, response, null, body.getClass(), false, null);
     this.body = body;
   }
 
@@ -37,7 +37,7 @@ interface SyncExample {
   }
 
   interface AsyncExample {
-    @GET(""/"") void doStuff(Callback<Object> cb);
+    @GET(""/"") void doStuff(Callback<String> cb);
   }
 
   interface AsyncCallbackSubtypeExample {
@@ -47,7 +47,7 @@ abstract class Foo implements Callback<String> {}
   }
 
   interface ObservableExample {
-    @GET(""/"") Observable<Object> doStuff();
+    @GET(""/"") Observable<String> doStuff();
   }
 
   private Executor httpExecutor;
@@ -242,16 +242,16 @@ class MockSyncExample implements SyncExample {
     mockRestAdapter.setErrorPercentage(100);
 
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw new AssertionError();
       }
     }
 
     AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
 
     final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -298,9 +298,11 @@ class MockSyncExample implements SyncExample {
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Hi"");
+
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         cb.success(expected, null);
       }
     }
@@ -310,8 +312,8 @@ class MockAsyncExample implements AsyncExample {
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
     final AtomicReference<Object> actual = new AtomicReference<Object>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object result, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String result, Response response) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         actual.set(result);
       }
@@ -333,9 +335,11 @@ class MockAsyncExample implements AsyncExample {
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Hello"");
+
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         return Observable.from(expected);
       }
     }
@@ -373,9 +377,11 @@ class MockObservableExample implements ObservableExample {
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Hello"");
+
     class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
+      @Override public String doStuff() {
         throw new MockHttpException(404, ""Not Found"", expected);
       }
     }
@@ -393,6 +399,7 @@ class MockSyncExample implements SyncExample {
       assertThat(e.getResponse().getStatus()).isEqualTo(404);
       assertThat(e.getResponse().getReason()).isEqualTo(""Not Found"");
       assertThat(e.getBody()).isSameAs(expected);
+      assertThat(e.getSuccessType()).isEqualTo(String.class);
     }
   }
 
@@ -401,9 +408,11 @@ class MockSyncExample implements SyncExample {
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Greetings"");
+
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw new MockHttpException(404, ""Not Found"", expected);
       }
     }
@@ -413,8 +422,8 @@ class MockAsyncExample implements AsyncExample {
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
     final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -433,16 +442,19 @@ class MockAsyncExample implements AsyncExample {
     assertThat(error.getResponse().getStatus()).isEqualTo(404);
     assertThat(error.getResponse().getReason()).isEqualTo(""Not Found"");
     assertThat(error.getBody()).isSameAs(expected);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void observableHttpExceptionBecomesError() {
     mockRestAdapter.setDelay(100);
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Hi"");
+
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         throw new MockHttpException(404, ""Not Found"", expected);
       }
     }
@@ -474,6 +486,7 @@ class MockObservableExample implements ObservableExample {
     assertThat(error.getResponse().getStatus()).isEqualTo(404);
     assertThat(error.getResponse().getReason()).isEqualTo(""Not Found"");
     assertThat(error.getBody()).isSameAs(expected);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void syncErrorUsesErrorHandler() {
@@ -504,7 +517,7 @@ class MockSyncExample implements SyncExample {
     mockRestAdapter.setErrorPercentage(0);
 
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw MockHttpException.newNotFound(new Object());
       }
     }
@@ -513,8 +526,8 @@ class MockAsyncExample implements AsyncExample {
     nextError = new IllegalArgumentException(""Test"");
 
     final CountDownLatch latch = new CountDownLatch(1);
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -532,7 +545,7 @@ class MockAsyncExample implements AsyncExample {
     mockRestAdapter.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         throw MockHttpException.newNotFound(new Object());
       }
     }
@@ -349,6 +349,9 @@ private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodIn
 
           TypedInput body = response.getBody();
           if (body == null) {
+            if (methodInfo.isSynchronous) {
+              return null;
+            }
             return new ResponseWrapper(response, null);
           }
 
@@ -83,6 +83,14 @@ public Object getBody() {
     return getBodyAs(successType);
   }
 
+  /**
+   * The type declared by either the interface method return type or the generic type of the
+   * supplied {@link Callback} parameter.
+   */
+  public Type getSuccessType() {
+    return successType;
+  }
+
   /**
    * HTTP response body converted to specified {@code type}. {@code null} if there is no response.
    */
@@ -34,9 +34,7 @@
 import static org.assertj.core.api.Assertions.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
 import static org.mockito.Matchers.same;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doReturn;
@@ -68,16 +66,16 @@ public class RestAdapterTest {
     }
 
     @Override public InputStream in() throws IOException {
-      return new ByteArrayInputStream(""{}"".getBytes(""UTF-8""));
+      return new ByteArrayInputStream(""Hi"".getBytes(""UTF-8""));
     }
   };
 
   private interface Example {
     @Headers(""Foo: Bar"")
-    @GET(""/"") Object something();
+    @GET(""/"") String something();
     @Headers(""Foo: Bar"")
     @POST(""/"") Object something(@Body TypedOutput body);
-    @GET(""/"") void something(Callback<Object> callback);
+    @GET(""/"") void something(Callback<String> callback);
     @GET(""/"") Response direct();
     @GET(""/"") void direct(Callback<Response> callback);
     @POST(""/"") Observable<String> observable(@Body String body);
@@ -127,7 +125,7 @@ private interface InvalidExample extends Example {
     Object data = new Object();
     when(mockProfiler.beforeCall()).thenReturn(data);
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, null));
+        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hey"")));
 
     example.something();
 
@@ -155,7 +153,7 @@ public void log(String message) {
         .create(Example.class);
 
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", TWO_HEADERS, new TypedString(""{}"")));
+        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", TWO_HEADERS, new TypedString(""Hi"")));
 
     example.something();
     assertThat(logMessages).hasSize(2);
@@ -182,7 +180,7 @@ public void log(String message) {
         .create(Example.class);
 
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", TWO_HEADERS, new TypedString(""{}"")));
+        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", TWO_HEADERS, new TypedString(""Hi"")));
 
     example.something();
     assertThat(logMessages).hasSize(7);
@@ -302,13 +300,13 @@ public void log(String message) {
     assertThat(logMessages.get(4)).isEqualTo(""Content-Type: application/json"");
     assertThat(logMessages.get(5)).isEqualTo(""Content-Length: 42"");
     assertThat(logMessages.get(6)).isEqualTo("""");
-    assertThat(logMessages.get(7)).isEqualTo(""{}"");
+    assertThat(logMessages.get(7)).isEqualTo(""Hi"");
     assertThat(logMessages.get(8)).isEqualTo(""<--- END HTTP (2-byte body)"");
   }
 
   @Test public void synchronousDoesNotUseExecutors() throws Exception {
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, null));
+        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hi"")));
 
     example.something();
 
@@ -317,15 +315,15 @@ public void log(String message) {
   }
 
   @Test public void asynchronousUsesExecutors() throws Exception {
-    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""{}""));
+    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hey""));
     when(mockClient.execute(any(Request.class))).thenReturn(response);
-    Callback<Object> callback = mock(Callback.class);
+    Callback<String> callback = mock(Callback.class);
 
     example.something(callback);
 
     verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
     verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(anyString(), same(response));
+    verify(callback).success(eq(""Hey""), same(response));
   }
 
   @Test public void malformedResponseThrowsConversionException() throws Exception {
@@ -351,6 +349,7 @@ public void log(String message) {
       fail(""RetrofitError expected on non-2XX response code."");
     } catch (RetrofitError e) {
       assertThat(e.getResponse().getStatus()).isEqualTo(500);
+      assertThat(e.getSuccessType()).isEqualTo(String.class);
     }
   }
 
@@ -392,7 +391,7 @@ public void log(String message) {
     assertThat(logMessages.get(4)).isEqualTo(""Content-Type: application/json"");
     assertThat(logMessages.get(5)).isEqualTo(""Content-Length: 42"");
     assertThat(logMessages.get(6)).isEqualTo("""");
-    assertThat(logMessages.get(7)).isEqualTo(""{}"");
+    assertThat(logMessages.get(7)).isEqualTo(""Hi"");
     assertThat(logMessages.get(8)).isEqualTo(""<--- END HTTP (2-byte body)"");
   }
 
@@ -510,7 +509,7 @@ public void log(String message) {
   }
 
   @Test public void getResponseDirectlyAsync() throws Exception {
-    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, null);
+    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hey""));
     when(mockClient.execute(any(Request.class))) //
         .thenReturn(response);
     Callback<Response> callback = mock(Callback.class);
@@ -522,6 +521,43 @@ public void log(String message) {
     verify(callback).success(eq(response), same(response));
   }
 
+  @Test public void getAsync() throws Exception {
+    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hey""));
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(response);
+    Callback<String> callback = mock(Callback.class);
+
+    example.something(callback);
+
+    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+    verify(mockCallbackExecutor).execute(any(Runnable.class));
+
+    ArgumentCaptor<String> responseCaptor = ArgumentCaptor.forClass(String.class);
+    verify(callback).success(responseCaptor.capture(), same(response));
+    assertThat(responseCaptor.getValue()).isEqualTo(""Hey"");
+  }
+
+
+  @Test public void errorAsync() throws Exception {
+    Response response = new Response(""http://example.com/"", 500, ""Broken!"", NO_HEADERS, new TypedString(""Hey""));
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(response);
+    Callback<String> callback = mock(Callback.class);
+
+    example.something(callback);
+
+    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+    verify(mockCallbackExecutor).execute(any(Runnable.class));
+
+    ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
+    verify(callback).failure(errorCaptor.capture());
+    RetrofitError error = errorCaptor.getValue();
+    assertThat(error.getResponse().getStatus()).isEqualTo(500);
+    assertThat(error.getResponse().getReason()).isEqualTo(""Broken!"");
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
+    assertThat(error.getBody()).isEqualTo(""Hey"");
+  }
+
   @Test public void observableCallsOnNext() throws Exception {
     when(mockClient.execute(any(Request.class))) //
         .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""hello"")));
@@ -537,7 +573,11 @@ public void log(String message) {
     Action1<Throwable> onError = mock(Action1.class);
     example.observable(""Howdy"").subscribe(onSuccess, onError);
     verifyZeroInteractions(onSuccess);
-    verify(onError).call(isA(RetrofitError.class));
+
+    ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
+    verify(onError).call(errorCaptor.capture());
+    RetrofitError value = errorCaptor.getValue();
+    assertThat(value.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void observableHandlesParams() throws Exception {
"
https://github.com/square/okhttp/commit/2ec2027fc00e24a83cd7bb7fef8b11e7c751bc13,Add missing copyright headers.  <enter> <issue_link> ,https://api.github.com/repos/square/okhttp/commits/2ec2027fc00e24a83cd7bb7fef8b11e7c751bc13,"@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 // http://tools.ietf.org/html/draft-ietf-httpbis-http2-12#section-7
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 import java.io.IOException;
"
https://github.com/square/okhttp/commit/aaf2695b00dfd69df6fd915ba16665eee8c1962d,"Fix ResponseCacheTest for Android  <enter> Pull  <pr_link>  broke ResponseCacheTest on Android. <enter> The test was asserting a header generated using a copy of the old broken implementation. <enter> The test now just uses HttpDate, which now has its own tests. ",https://api.github.com/repos/square/okhttp/commits/aaf2695b00dfd69df6fd915ba16665eee8c1962d,"@@ -21,6 +21,7 @@
 import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
@@ -911,7 +912,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     connection.setIfModifiedSince(since.getTime());
     assertEquals(""A"", readAscii(connection));
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeaders().contains(""If-Modified-Since: "" + formatDate(since)));
+    assertTrue(request.getHeaders().contains(""If-Modified-Since: "" + HttpDate.format(since)));
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
@@ -1262,13 +1263,7 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
    * future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss zzz"", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone(""GMT""));
-    return rfc1123.format(date);
+    return HttpDate.format(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
   }
 
   private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
"
https://github.com/spring-projects/spring-boot/commit/5e9b8c3340d25fbf0e7d64b306ae7b3557188b9a,Add missing depdendency ,https://api.github.com/repos/spring-projects/spring-boot/commits/5e9b8c3340d25fbf0e7d64b306ae7b3557188b9a,"@@ -49,8 +49,8 @@
 		</dependency>
 		<dependency>
 			<groupId>org.springframework</groupId>
-			<artifactId>spring-test</artifactId>
-			<scope>test</scope>
+			<artifactId>spring-jdbc</artifactId>
+			<optional>true</optional>
 		</dependency>
 		<dependency>
 			<groupId>org.springframework</groupId>
@@ -73,6 +73,11 @@
 			<optional>true</optional>
 		</dependency>
 		<!-- Test -->
+		<dependency>
+			<groupId>org.springframework</groupId>
+			<artifactId>spring-test</artifactId>
+			<scope>test</scope>
+		</dependency>
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>spring-boot</artifactId>
"
https://github.com/spring-projects/spring-boot/commit/e370b592d66ad9b01ff2bfff4b5991f0ac3a9751,"Introduce defined extension point for modifying the environment  <enter> The commit introduces a new extension point, EnvironmentPostProcessor, that can be implemented by classes that want to modify the environment. Implementations of EnvironmentPostProcessor are loaded via spring.factories and called in response to the ApplicationEnvironmentPreparedEvent. Application listeners that wish to work with the post-processed environment can continue to listen to ApplicationEnvironmentPreparedEvent and order themselves to run after EnvironmentPostProcessingApplicationListener. <enter> Existing ApplicationListeners that modify the environment have, where possible, been updated to implement EnvironmentPostProcessor instead. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/e370b592d66ad9b01ff2bfff4b5991f0ac3a9751,"@@ -455,7 +455,7 @@ protected void configurePropertySources(ConfigurableEnvironment environment,
 	 * @param environment this application's environment
 	 * @param args arguments passed to the {@code run} method
 	 * @see #configureEnvironment(ConfigurableEnvironment, String[])
-	 * @see org.springframework.boot.context.config.ConfigFileApplicationListener
+	 * @see org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor
 	 */
 	protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {
 		environment.getActiveProfiles(); // ensure they are initialized
@@ -25,11 +25,11 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.springframework.boot.context.config.ConfigFileApplicationListener;
-import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor;
+import org.springframework.boot.env.EnvironmentPostProcessor;
 import org.springframework.boot.json.JsonParser;
 import org.springframework.boot.json.JsonParserFactory;
-import org.springframework.context.ApplicationListener;
 import org.springframework.core.Ordered;
 import org.springframework.core.env.CommandLinePropertySource;
 import org.springframework.core.env.ConfigurableEnvironment;
@@ -39,8 +39,8 @@
 import org.springframework.util.StringUtils;
 
 /**
- * An {@link ApplicationListener} that knows where to find VCAP (a.k.a. Cloud Foundry)
- * meta data in the existing environment. It parses out the VCAP_APPLICATION and
+ * An {@link EnvironmentPostProcessor} that knows where to find VCAP (a.k.a. Cloud
+ * Foundry) meta data in the existing environment. It parses out the VCAP_APPLICATION and
  * VCAP_SERVICES meta data and dumps it in a form that is easily consumed by
  * {@link Environment} users. If the app is running in Cloud Foundry then both meta data
  * items are JSON objects encoded in OS environment variables. VCAP_APPLICATION is a
@@ -86,18 +86,19 @@
  * Cloud is more convenient and more robust against potential changes in Cloud Foundry.
  *
  * @author Dave Syer
+ * @author Andy Wilkinson
  */
-public class VcapApplicationListener implements
-		ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {
+public class VcapEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
 
-	private static final Log logger = LogFactory.getLog(VcapApplicationListener.class);
+	private static final Log logger = LogFactory
+			.getLog(VcapEnvironmentPostProcessor.class);
 
 	private static final String VCAP_APPLICATION = ""VCAP_APPLICATION"";
 
 	private static final String VCAP_SERVICES = ""VCAP_SERVICES"";
 
 	// Before ConfigFileApplicationListener so values there can use these ones
-	private int order = ConfigFileApplicationListener.DEFAULT_ORDER - 1;
+	private int order = ConfigFileEnvironmentPostProcessor.DEFAULT_ORDER - 1;
 
 	private final JsonParser parser = JsonParserFactory.getJsonParser();
 
@@ -111,8 +112,8 @@ public int getOrder() {
 	}
 
 	@Override
-	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
-		ConfigurableEnvironment environment = event.getEnvironment();
+	public void postProcessEnvironment(ConfigurableEnvironment environment,
+			SpringApplication application) {
 		if (!environment.containsProperty(VCAP_APPLICATION)
 				&& !environment.containsProperty(VCAP_SERVICES)) {
 			return;
@@ -20,6 +20,7 @@
 import org.springframework.boot.ansi.AnsiOutput.Enabled;
 import org.springframework.boot.bind.RelaxedPropertyResolver;
 import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
+import org.springframework.boot.env.EnvironmentPostProcessingApplicationListener;
 import org.springframework.context.ApplicationListener;
 import org.springframework.core.Ordered;
 
@@ -51,8 +52,9 @@ public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
 
 	@Override
 	public int getOrder() {
-		// Apply after the ConfigFileApplicationListener
-		return ConfigFileApplicationListener.DEFAULT_ORDER + 1;
+		// Apply after the EnvironmentPostProcessingApplicationListener has called all
+		// EnvironmentPostProcessors
+		return EnvironmentPostProcessingApplicationListener.ORDER + 1;
 	}
 
 }
@@ -33,12 +33,11 @@
 import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.bind.PropertiesConfigurationFactory;
-import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
 import org.springframework.boot.context.event.ApplicationPreparedEvent;
 import org.springframework.boot.env.EnumerableCompositePropertySource;
+import org.springframework.boot.env.EnvironmentPostProcessor;
 import org.springframework.boot.env.PropertySourcesLoader;
 import org.springframework.boot.logging.DeferredLog;
-import org.springframework.context.ApplicationEvent;
 import org.springframework.context.ApplicationListener;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.context.annotation.ConfigurationClassPostProcessor;
@@ -47,7 +46,6 @@
 import org.springframework.core.convert.support.DefaultConversionService;
 import org.springframework.core.env.ConfigurableEnvironment;
 import org.springframework.core.env.EnumerablePropertySource;
-import org.springframework.core.env.Environment;
 import org.springframework.core.env.MutablePropertySources;
 import org.springframework.core.env.PropertySource;
 import org.springframework.core.io.DefaultResourceLoader;
@@ -59,7 +57,7 @@
 import org.springframework.validation.BindException;
 
 /**
- * {@link ApplicationListener} that configures the context environment by loading
+ * {@link EnvironmentPostProcessor} that configures the context environment by loading
  * properties from well known file locations. By default properties will be loaded from
  * 'application.properties' and/or 'application.yml' files in the following locations:
  * <ul>
@@ -89,9 +87,10 @@
  * @author Dave Syer
  * @author Phillip Webb
  * @author Stephane Nicoll
+ * @author Andy Wilkinson
  */
-public class ConfigFileApplicationListener implements
-		ApplicationListener<ApplicationEvent>, Ordered {
+public class ConfigFileEnvironmentPostProcessor implements EnvironmentPostProcessor,
+		ApplicationListener<ApplicationPreparedEvent>, Ordered {
 
 	private static final String DEFAULT_PROPERTIES = ""defaultProperties"";
 
@@ -121,34 +120,15 @@ public class ConfigFileApplicationListener implements
 	private final ConversionService conversionService = new DefaultConversionService();
 
 	@Override
-	public void onApplicationEvent(ApplicationEvent event) {
-		if (event instanceof ApplicationEnvironmentPreparedEvent) {
-			onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);
-		}
-		if (event instanceof ApplicationPreparedEvent) {
-			onApplicationPreparedEvent((ApplicationPreparedEvent) event);
-		}
-	}
-
-	private void onApplicationEnvironmentPreparedEvent(
-			ApplicationEnvironmentPreparedEvent event) {
-		Environment environment = event.getEnvironment();
-		if (environment instanceof ConfigurableEnvironment) {
-			onApplicationEnvironmentPreparedEvent((ConfigurableEnvironment) environment,
-					event.getSpringApplication());
-		}
-	}
-
-	private void onApplicationEnvironmentPreparedEvent(
-			ConfigurableEnvironment environment, SpringApplication application) {
+	public void postProcessEnvironment(ConfigurableEnvironment environment,
+			SpringApplication application) {
 		addPropertySources(environment, application.getResourceLoader());
 		bindToSpringApplication(environment, application);
 	}
 
-	private void onApplicationPreparedEvent(ApplicationPreparedEvent event) {
-		// logging is deferred because the Logging initialization might not have
-		// run at the time that config file decisions are taken
-		this.logger.replayTo(ConfigFileApplicationListener.class);
+	@Override
+	public void onApplicationEvent(ApplicationPreparedEvent event) {
+		this.logger.replayTo(ConfigFileEnvironmentPostProcessor.class);
 		addPostProcessors(event.getApplicationContext());
 	}
 
@@ -272,7 +252,7 @@ private void reorderSources(ConfigurableEnvironment environment) {
 	 */
 	private class Loader {
 
-		private final Log logger = ConfigFileApplicationListener.this.logger;
+		private final Log logger = ConfigFileEnvironmentPostProcessor.this.logger;
 
 		private final ConfigurableEnvironment environment;
 
@@ -472,7 +452,7 @@ private Set<String> getSearchLocations() {
 				}
 			}
 			locations.addAll(asResolvedSet(
-					ConfigFileApplicationListener.this.searchLocations,
+					ConfigFileEnvironmentPostProcessor.this.searchLocations,
 					DEFAULT_SEARCH_LOCATIONS));
 			return locations;
 		}
@@ -482,7 +462,8 @@ private Set<String> getSearchNames() {
 				return asResolvedSet(this.environment.getProperty(CONFIG_NAME_PROPERTY),
 						null);
 			}
-			return asResolvedSet(ConfigFileApplicationListener.this.names, DEFAULT_NAMES);
+			return asResolvedSet(ConfigFileEnvironmentPostProcessor.this.names,
+					DEFAULT_NAMES);
 		}
 
 		private Set<String> asResolvedSet(String value, String fallback) {
@@ -18,7 +18,7 @@
  * External configuration support allowing 'application.properties' to be loaded
  * and used within a Spring Boot application.
  *
- * @see org.springframework.boot.context.config.ConfigFileApplicationListener
+ * @see org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor
  */
 package org.springframework.boot.context.config;
 
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.env;
+
+import java.util.List;
+
+import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
+import org.springframework.context.ApplicationListener;
+import org.springframework.core.Ordered;
+import org.springframework.core.annotation.AnnotationAwareOrderComparator;
+import org.springframework.core.io.support.SpringFactoriesLoader;
+
+/**
+ * An {@link ApplicationListener} that responds to an
+ * {@link ApplicationEnvironmentPreparedEvent} and calls all
+ * {@link EnvironmentPostProcessor EnvironmentPostProcessors} that are available via
+ * {@code spring.factories}.
+ * <p>
+ * Post-processors are called in the order defined by
+ * {@link AnnotationAwareOrderComparator}.
+ *
+ * @author Andy Wilkinson
+ * @since 1.3.0
+ * @see SpringFactoriesLoader#loadFactories(Class, ClassLoader)
+ */
+public class EnvironmentPostProcessingApplicationListener implements
+		ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {
+
+	public static final int ORDER = Ordered.HIGHEST_PRECEDENCE + 10;
+
+	@Override
+	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
+		List<EnvironmentPostProcessor> postProcessors = SpringFactoriesLoader
+				.loadFactories(EnvironmentPostProcessor.class, getClass()
+						.getClassLoader());
+		for (EnvironmentPostProcessor postProcessor : postProcessors) {
+			postProcessor.postProcessEnvironment(event.getEnvironment(),
+					event.getSpringApplication());
+		}
+	}
+
+	@Override
+	public int getOrder() {
+		return ORDER;
+	}
+
+}
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.env;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.core.env.ConfigurableEnvironment;
+import org.springframework.core.env.Environment;
+
+/**
+ * Allows for customization of the application's {@link Environment} prior to the
+ * application context being refreshed.
+ *
+ * @author Andy Wilkinson
+ * @since 1.3.0
+ */
+public interface EnvironmentPostProcessor {
+
+	/**
+	 * Post-process the given {@code environment}
+	 *
+	 * @param environment the environment to post-process
+	 * @param application the application to which the environment belongs
+	 */
+	void postProcessEnvironment(ConfigurableEnvironment environment,
+			SpringApplication application);
+
+}
@@ -16,7 +16,7 @@
 
 package org.springframework.boot.test;
 
-import org.springframework.boot.context.config.ConfigFileApplicationListener;
+import org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor;
 import org.springframework.context.ApplicationContextInitializer;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.test.context.ContextConfiguration;
@@ -27,14 +27,14 @@
  * {@literal application.properties}.
  *
  * @author Phillip Webb
- * @see ConfigFileApplicationListener
+ * @see ConfigFileEnvironmentPostProcessor
  */
 public class ConfigFileApplicationContextInitializer implements
 		ApplicationContextInitializer<ConfigurableApplicationContext> {
 
 	@Override
 	public void initialize(final ConfigurableApplicationContext applicationContext) {
-		new ConfigFileApplicationListener() {
+		new ConfigFileEnvironmentPostProcessor() {
 			public void apply() {
 				addPropertySources(applicationContext.getEnvironment(),
 						applicationContext);
@@ -17,11 +17,16 @@ org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer
 # Application Listeners
 org.springframework.context.ApplicationListener=\
 org.springframework.boot.builder.ParentContextCloserApplicationListener,\
-org.springframework.boot.cloudfoundry.VcapApplicationListener,\
 org.springframework.boot.context.FileEncodingApplicationListener,\
 org.springframework.boot.context.config.AnsiOutputApplicationListener,\
-org.springframework.boot.context.config.ConfigFileApplicationListener,\
+org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor,\
 org.springframework.boot.context.config.DelegatingApplicationListener,\
+org.springframework.boot.env.EnvironmentPostProcessingApplicationListener,\
 org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\
 org.springframework.boot.logging.ClasspathLoggingApplicationListener,\
 org.springframework.boot.logging.LoggingApplicationListener
+
+# Environment Post Processors
+org.springframework.boot.env.EnvironmentPostProcessor=\
+org.springframework.boot.cloudfoundry.VcapEnvironmentPostProcessor,\
+org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor
\ No newline at end of file
@@ -17,8 +17,6 @@
 package org.springframework.boot.cloudfoundry;
 
 import org.junit.Test;
-import org.springframework.boot.SpringApplication;
-import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
 import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
@@ -27,19 +25,17 @@
 import static org.junit.Assert.assertNull;
 
 /**
- * Tests for {@link VcapApplicationListener}.
+ * Tests for {@link VcapEnvironmentPostProcessor}.
  *
  * @author Dave Syer
+ * @author Andy Wilkinson
  */
-public class VcapApplicationListenerTests {
+public class VcapEnvironmentPostProcessorTests {
 
-	private final VcapApplicationListener initializer = new VcapApplicationListener();
+	private final VcapEnvironmentPostProcessor initializer = new VcapEnvironmentPostProcessor();
 
 	private final ConfigurableApplicationContext context = new AnnotationConfigApplicationContext();
 
-	private final ApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(
-			new SpringApplication(), new String[0], this.context.getEnvironment());
-
 	@Test
 	public void testApplicationProperties() {
 		EnvironmentTestUtils
@@ -57,7 +53,7 @@ public void testApplicationProperties() {
 								+ ""\""name\"":\""dsyerenv\"",\""uris\"":[\""dsyerenv.cfapps.io\""],""
 								+ ""\""users\"":[],\""start\"":\""2013-05-29 02:37:59 +0000\"",""
 								+ ""\""state_timestamp\"":1369795079}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertEquals(""bb7935245adf3e650dfb7c58a06e9ece"", this.context.getEnvironment()
 				.getProperty(""vcap.application.instance_id""));
 	}
@@ -68,15 +64,15 @@ public void testApplicationUris() {
 				.addEnvironment(
 						this.context,
 						""VCAP_APPLICATION:{\""instance_id\"":\""bb7935245adf3e650dfb7c58a06e9ece\"",\""instance_index\"":0,\""uris\"":[\""foo.cfapps.io\""]}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertEquals(""foo.cfapps.io"",
 				this.context.getEnvironment().getProperty(""vcap.application.uris[0]""));
 	}
 
 	@Test
 	public void testUnparseableApplicationProperties() {
 		EnvironmentTestUtils.addEnvironment(this.context, ""VCAP_APPLICATION:"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertNull(getProperty(""vcap""));
 	}
 
@@ -97,7 +93,7 @@ public void testNullApplicationProperties() {
 								+ ""\""name\"":\""dsyerenv\"",\""uris\"":[\""dsyerenv.cfapps.io\""],""
 								+ ""\""users\"":[],\""start\"":\""2013-05-29 02:37:59 +0000\"",""
 								+ ""\""state_timestamp\"":1369795079}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertNull(getProperty(""vcap""));
 	}
 
@@ -115,7 +111,7 @@ public void testServiceProperties() {
 								+ ""\""host\"":\""mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\"",""
 								+ ""\""port\"":3306,\""user\"":\""urpRuqTf8Cpe6\"",\""username\"":""
 								+ ""\""urpRuqTf8Cpe6\"",\""password\"":\""pxLsGVpsC9A5S\""}}]}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertEquals(""mysql"", getProperty(""vcap.services.mysql.name""));
 		assertEquals(""3306"", getProperty(""vcap.services.mysql.credentials.port""));
 		assertEquals(""true"", getProperty(""vcap.services.mysql.credentials.ssl""));
@@ -135,7 +131,7 @@ public void testServicePropertiesWithoutNA() {
 								+ ""\""port\"":3306,\""user\"":\""urpRuqTf8Cpe6\"",""
 								+ ""\""username\"":\""urpRuqTf8Cpe6\"",""
 								+ ""\""password\"":\""pxLsGVpsC9A5S\""}}]}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertEquals(""mysql"", getProperty(""vcap.services.mysql.name""));
 		assertEquals(""3306"", getProperty(""vcap.services.mysql.credentials.port""));
 	}
@@ -35,8 +35,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.springframework.boot.SpringApplication;
-import org.springframework.boot.context.config.ConfigFileApplicationListener.ConfigurationPropertySources;
-import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
+import org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor.ConfigurationPropertySources;
 import org.springframework.boot.env.EnumerableCompositePropertySource;
 import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.ConfigurableApplicationContext;
@@ -63,19 +62,18 @@
 import static org.junit.Assert.assertThat;
 
 /**
- * Tests for {@link ConfigFileApplicationListener}.
+ * Tests for {@link ConfigFileEnvironmentPostProcessor}.
  *
  * @author Phillip Webb
  * @author Dave Syer
  */
-public class ConfigFileApplicationListenerTests {
+public class ConfigFileEnvironmentPostProcessorTests {
 
 	private final StandardEnvironment environment = new StandardEnvironment();
 
-	private final ApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(
-			new SpringApplication(), new String[0], this.environment);
+	private final SpringApplication application = new SpringApplication();
 
-	private final ConfigFileApplicationListener initializer = new ConfigFileApplicationListener();
+	private final ConfigFileEnvironmentPostProcessor initializer = new ConfigFileEnvironmentPostProcessor();
 
 	@Rule
 	public ExpectedException expected = ExpectedException.none();
@@ -89,7 +87,7 @@ public void cleanup() {
 
 	@Test
 	public void loadCustomResource() throws Exception {
-		this.event.getSpringApplication().setResourceLoader(new ResourceLoader() {
+		this.application.setResourceLoader(new ResourceLoader() {
 			@Override
 			public Resource getResource(final String location) {
 				if (location.equals(""classpath:/custom.properties"")) {
@@ -110,15 +108,15 @@ public ClassLoader getClassLoader() {
 			}
 		});
 		this.initializer.setSearchNames(""custom"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromcustom""));
 	}
 
 	@Test
 	public void loadPropertiesFile() throws Exception {
 		this.initializer.setSearchNames(""testproperties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""frompropertiesfile""));
 	}
@@ -127,7 +125,7 @@ public void loadPropertiesFile() throws Exception {
 	public void loadDefaultPropertiesFile() throws Exception {
 		this.environment.setDefaultProfiles(""thedefault"");
 		this.initializer.setSearchNames(""testprofiles"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromdefaultpropertiesfile""));
 	}
@@ -136,7 +134,7 @@ public void loadDefaultPropertiesFile() throws Exception {
 	public void loadTwoPropertiesFile() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ ""classpath:application.properties,classpath:testproperties.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""frompropertiesfile""));
 	}
@@ -145,7 +143,7 @@ public void loadTwoPropertiesFile() throws Exception {
 	public void loadTwoPropertiesFilesWithProfiles() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ ""classpath:enableprofile.properties,classpath:enableother.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertEquals(""other"", StringUtils.arrayToCommaDelimitedString(this.environment
 				.getActiveProfiles()));
 		String property = this.environment.getProperty(""my.property"");
@@ -157,7 +155,7 @@ public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() throws Exception
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ ""classpath:enabletwoprofiles.properties,""
 				+ ""classpath:enableprofile.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertEquals(""myprofile"",
 				StringUtils.arrayToCommaDelimitedString(this.environment
 						.getActiveProfiles()));
@@ -173,7 +171,7 @@ public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOffFromSpecificLocatio
 		EnvironmentTestUtils.addEnvironment(this.environment,
 				""spring.config.name:enabletwoprofiles"",
 				""spring.config.location:classpath:enableprofile.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertEquals(""myprofile"",
 				StringUtils.arrayToCommaDelimitedString(this.environment
 						.getActiveProfiles()));
@@ -197,7 +195,7 @@ public void localFileTakesPrecedenceOverClasspath() throws Exception {
 			finally {
 				out.close();
 			}
-			this.initializer.onApplicationEvent(this.event);
+			this.initializer.postProcessEnvironment(this.environment, this.application);
 			String property = this.environment.getProperty(""the.property"");
 			assertThat(property, equalTo(""fromlocalfile""));
 		}
@@ -210,7 +208,7 @@ public void localFileTakesPrecedenceOverClasspath() throws Exception {
 	public void moreSpecificLocationTakesPrecedenceOverRoot() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment,
 				""spring.config.name:specific"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""specific""));
 	}
@@ -221,22 +219,22 @@ public void loadTwoOfThreePropertiesFile() throws Exception {
 				+ ""classpath:application.properties,""
 				+ ""classpath:testproperties.properties,""
 				+ ""classpath:nonexistent.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""frompropertiesfile""));
 	}
 
 	@Test
 	public void randomValue() throws Exception {
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""random.value"");
 		assertThat(property, notNullValue());
 	}
 
 	@Test
 	public void loadTwoPropertiesFiles() throws Exception {
 		this.initializer.setSearchNames(""moreproperties,testproperties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		// The search order has highest precedence last (like merging a map)
 		assertThat(property, equalTo(""frompropertiesfile""));
@@ -245,7 +243,7 @@ public void loadTwoPropertiesFiles() throws Exception {
 	@Test
 	public void loadYamlFile() throws Exception {
 		this.initializer.setSearchNames(""testyaml"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromyamlfile""));
 		assertThat(this.environment.getProperty(""my.array[0]""), equalTo(""1""));
@@ -255,7 +253,7 @@ public void loadYamlFile() throws Exception {
 	@Test
 	public void loadProfileEmptySameAsNotSpecified() throws Exception {
 		this.initializer.setSearchNames(""testprofilesempty"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromemptyprofile""));
 	}
@@ -264,7 +262,7 @@ public void loadProfileEmptySameAsNotSpecified() throws Exception {
 	public void loadDefaultYamlDocument() throws Exception {
 		this.environment.setDefaultProfiles(""thedefault"");
 		this.initializer.setSearchNames(""testprofilesdocument"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromdefaultprofile""));
 	}
@@ -274,7 +272,7 @@ public void loadDefaultYamlDocumentNotActivated() throws Exception {
 		this.environment.setDefaultProfiles(""thedefault"");
 		this.environment.setActiveProfiles(""other"");
 		this.initializer.setSearchNames(""testprofilesdocument"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromotherprofile""));
 	}
@@ -284,7 +282,7 @@ public void commandLineWins() throws Exception {
 		this.environment.getPropertySources().addFirst(
 				new SimpleCommandLinePropertySource(""--the.property=fromcommandline""));
 		this.initializer.setSearchNames(""testproperties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromcommandline""));
 	}
@@ -293,34 +291,27 @@ public void commandLineWins() throws Exception {
 	public void systemPropertyWins() throws Exception {
 		System.setProperty(""the.property"", ""fromsystem"");
 		this.initializer.setSearchNames(""testproperties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromsystem""));
 	}
 
 	@Test
 	public void defaultPropertyAsFallback() throws Exception {
-		this.event
-				.getEnvironment()
-				.getPropertySources()
-				.addLast(
-						new MapPropertySource(""defaultProperties"", Collections
-								.singletonMap(""my.fallback"", (Object) ""foo"")));
-		this.initializer.onApplicationEvent(this.event);
+		this.environment.getPropertySources().addLast(
+				new MapPropertySource(""defaultProperties"", Collections.singletonMap(
+						""my.fallback"", (Object) ""foo"")));
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.fallback"");
 		assertThat(property, equalTo(""foo""));
 	}
 
 	@Test
 	public void defaultPropertyAsFallbackDuringFileParsing() throws Exception {
-		this.event
-				.getEnvironment()
-				.getPropertySources()
-				.addLast(
-						new MapPropertySource(""defaultProperties"", Collections
-								.singletonMap(""spring.config.name"",
-										(Object) ""testproperties"")));
-		this.initializer.onApplicationEvent(this.event);
+		this.environment.getPropertySources().addLast(
+				new MapPropertySource(""defaultProperties"", Collections.singletonMap(
+						""spring.config.name"", (Object) ""testproperties"")));
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""frompropertiesfile""));
 	}
@@ -331,7 +322,7 @@ public void loadPropertiesThenProfilePropertiesActivatedInSpringApplication()
 		// This should be the effect of calling
 		// SpringApplication.setAdditionalProfiles(""other"")
 		this.environment.setActiveProfiles(""other"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		// The ""other"" profile is activated in SpringApplication so it should take
 		// precedence over the default profile
@@ -343,7 +334,7 @@ public void twoProfilesFromProperties() throws Exception {
 		// This should be the effect of calling
 		// SpringApplication.setAdditionalProfiles(""other"", ""dev"")
 		this.environment.setActiveProfiles(""other"", ""dev"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		// The ""dev"" profile is activated in SpringApplication so it should take
 		// precedence over the default profile
@@ -353,7 +344,7 @@ public void twoProfilesFromProperties() throws Exception {
 	@Test
 	public void loadPropertiesThenProfilePropertiesActivatedInFirst() throws Exception {
 		this.initializer.setSearchNames(""enableprofile"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		// The ""myprofile"" profile is activated in enableprofile.properties so its value
 		// should show up here
@@ -366,7 +357,7 @@ public void loadPropertiesThenProfilePropertiesWithOverride() throws Exception {
 		// EnvironmentTestUtils.addEnvironment(this.environment,
 		// ""spring.profiles.active:other"");
 		this.initializer.setSearchNames(""enableprofile"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""other.property"");
 		// The ""other"" profile is activated before any processing starts
 		assertThat(property, equalTo(""fromotherpropertiesfile""));
@@ -380,7 +371,7 @@ public void loadPropertiesThenProfilePropertiesWithOverride() throws Exception {
 	@Test
 	public void profilePropertiesUsedInPlaceholders() throws Exception {
 		this.initializer.setSearchNames(""enableprofile"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""one.more"");
 		assertThat(property, equalTo(""fromprofilepropertiesfile""));
 	}
@@ -389,7 +380,7 @@ public void profilePropertiesUsedInPlaceholders() throws Exception {
 	public void yamlProfiles() throws Exception {
 		this.initializer.setSearchNames(""testprofiles"");
 		this.environment.setActiveProfiles(""dev"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromdevprofile""));
 		property = this.environment.getProperty(""my.other"");
@@ -400,7 +391,7 @@ public void yamlProfiles() throws Exception {
 	public void yamlTwoProfiles() throws Exception {
 		this.initializer.setSearchNames(""testprofiles"");
 		this.environment.setActiveProfiles(""other"", ""dev"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromdevprofile""));
 		property = this.environment.getProperty(""my.other"");
@@ -410,7 +401,7 @@ public void yamlTwoProfiles() throws Exception {
 	@Test
 	public void yamlSetsProfiles() throws Exception {
 		this.initializer.setSearchNames(""testsetprofiles"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertEquals(""dev"", StringUtils.arrayToCommaDelimitedString(this.environment
 				.getActiveProfiles()));
 		String property = this.environment.getProperty(""my.property"");
@@ -444,7 +435,7 @@ public void yamlProfileCanBeChanged() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment,
 				""spring.profiles.active:prod"");
 		this.initializer.setSearchNames(""testsetprofiles"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertThat(this.environment.getActiveProfiles(), equalTo(new String[] { ""prod"" }));
 	}
 
@@ -453,7 +444,7 @@ public void specificNameAndProfileFromExistingSource() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment,
 				""spring.profiles.active=specificprofile"",
 				""spring.config.name=specificfile"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromspecificpropertiesfile""));
 	}
@@ -463,7 +454,7 @@ public void specificResource() throws Exception {
 		String location = ""classpath:specificlocation.properties"";
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ location);
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromspecificlocation""));
 		assertThat(this.environment, containsPropertySource(""applicationConfig: ""
@@ -479,7 +470,7 @@ public void specificResourceAsFile() throws Exception {
 		String location = ""file:src/test/resources/specificlocation.properties"";
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ location);
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertThat(this.environment, containsPropertySource(""applicationConfig: [""
 				+ location + ""]""));
 	}
@@ -489,7 +480,7 @@ public void specificResourceDefaultsToFile() throws Exception {
 		String location = ""src/test/resources/specificlocation.properties"";
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ location);
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertThat(this.environment, containsPropertySource(""applicationConfig: [file:""
 				+ location + ""]""));
 	}
@@ -500,7 +491,7 @@ public void absoluteResourceDefaultsToFile() throws Exception {
 				.getAbsolutePath();
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ location);
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertThat(this.environment, containsPropertySource(""applicationConfig: [file:""
 				+ location.replace(File.separatorChar, '/') + ""]""));
 	}
@@ -633,22 +624,20 @@ public void profileSubDocumentInProfileSpecificFile() throws Exception {
 	public void bindsToSpringApplication() throws Exception {
 		// gh-346
 		this.initializer.setSearchNames(""bindtoapplication"");
-		this.initializer.onApplicationEvent(this.event);
-		SpringApplication application = this.event.getSpringApplication();
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		Field field = ReflectionUtils.findField(SpringApplication.class, ""showBanner"");
 		field.setAccessible(true);
-		assertThat((Boolean) field.get(application), equalTo(false));
+		assertThat((Boolean) field.get(this.application), equalTo(false));
 	}
 
 	@Test
 	public void bindsSystemPropertyToSpringApplication() throws Exception {
 		// gh-951
 		System.setProperty(""spring.main.showBanner"", ""false"");
-		this.initializer.onApplicationEvent(this.event);
-		SpringApplication application = this.event.getSpringApplication();
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		Field field = ReflectionUtils.findField(SpringApplication.class, ""showBanner"");
 		field.setAccessible(true);
-		assertThat((Boolean) field.get(application), equalTo(false));
+		assertThat((Boolean) field.get(this.application), equalTo(false));
 	}
 
 	private static Matcher<? super ConfigurableEnvironment> containsPropertySource(
"
https://github.com/apache/dubbo/commit/b0064d78a3b929eb3b25e0de9055412cb61f48ce,Make code of process callback of method cleaner in DubboBeanDefinitionParser ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/b0064d78a3b929eb3b25e0de9055412cb61f48ce,"@@ -62,6 +62,10 @@ public class DubboBeanDefinitionParser implements BeanDefinitionParser {
 
     private static final Logger logger = LoggerFactory.getLogger(DubboBeanDefinitionParser.class);
     private static final Pattern GROUP_AND_VERION = Pattern.compile(""^[\\-.0-9_a-zA-Z]+(\\:[\\-.0-9_a-zA-Z]+)?$"");
+    private static final String ONRETURN = ""onreturn"";
+    private static final String ONTHROW = ""onthrow"";
+    private static final String ONINVOKE = ""oninvoke"";
+    private static final String METHOD = ""Method"";
     private final Class<?> beanClass;
     private final boolean required;
 
@@ -190,24 +194,12 @@ private static BeanDefinition parse(Element element, ParserContext parserContext
                                         value = null;
                                     }
                                     reference = value;
-                                } else if (""onreturn"".equals(property)) {
+                                } else if(ONRETURN.equals(property) || ONTHROW.equals(property) || ONINVOKE.equals(property)) {
                                     int index = value.lastIndexOf(""."");
-                                    String returnRef = value.substring(0, index);
-                                    String returnMethod = value.substring(index + 1);
-                                    reference = new RuntimeBeanReference(returnRef);
-                                    beanDefinition.getPropertyValues().addPropertyValue(""onreturnMethod"", returnMethod);
-                                } else if (""onthrow"".equals(property)) {
-                                    int index = value.lastIndexOf(""."");
-                                    String throwRef = value.substring(0, index);
-                                    String throwMethod = value.substring(index + 1);
-                                    reference = new RuntimeBeanReference(throwRef);
-                                    beanDefinition.getPropertyValues().addPropertyValue(""onthrowMethod"", throwMethod);
-                                } else if (""oninvoke"".equals(property)) {
-                                    int index = value.lastIndexOf(""."");
-                                    String invokeRef = value.substring(0, index);
-                                    String invokeRefMethod = value.substring(index + 1);
-                                    reference = new RuntimeBeanReference(invokeRef);
-                                    beanDefinition.getPropertyValues().addPropertyValue(""oninvokeMethod"", invokeRefMethod);
+                                    String ref = value.substring(0, index);
+                                    String method = value.substring(index + 1);
+                                    reference = new RuntimeBeanReference(ref);
+                                    beanDefinition.getPropertyValues().addPropertyValue(property + METHOD, method);
                                 } else {
                                     if (""ref"".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {
                                         BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);
"
https://github.com/square/retrofit/commit/7e31520f844b5c8eedc3b8fe82e2e48c79e47a5a,Get rid of the now-useless HttpServiceMethod.Builder  <enter> A simple static factory will do. ,https://api.github.com/repos/square/retrofit/commits/7e31520f844b5c8eedc3b8fe82e2e48c79e47a5a,"@@ -25,79 +25,69 @@
 
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
-  private final RequestFactory requestFactory;
-  private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<ResponseT, ReturnT> callAdapter;
-  private final Converter<ResponseBody, ResponseT> responseConverter;
-
-  HttpServiceMethod(Builder<ResponseT, ReturnT> builder) {
-    requestFactory = builder.requestFactory;
-    callFactory = builder.retrofit.callFactory();
-    callAdapter = builder.callAdapter;
-    responseConverter = builder.responseConverter;
-  }
-
-  @Override ReturnT invoke(@Nullable Object[] args) {
-    return callAdapter.adapt(
-        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
-  }
-
   /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
+   * Inspects the annotations on an interface method to construct a reusable service method that
+   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
+   * method only once and reuse it.
    */
-  static final class Builder<ResponseT, ReturnT> {
-    final Retrofit retrofit;
-    final Method method;
-
-    RequestFactory requestFactory;
-    Type responseType;
-    Converter<ResponseBody, ResponseT> responseConverter;
-    CallAdapter<ResponseT, ReturnT> callAdapter;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
+  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
+      Retrofit retrofit, Method method, RequestFactory requestFactory) {
+    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);
+    Type responseType = callAdapter.responseType();
+    if (responseType == Response.class || responseType == okhttp3.Response.class) {
+      throw methodError(method, ""'""
+          + Utils.getRawType(responseType).getName()
+          + ""' is not a valid response body type. Did you mean ResponseBody?"");
+    }
+    if (requestFactory.httpMethod.equals(""HEAD"") && !Void.class.equals(responseType)) {
+      throw methodError(method, ""HEAD method must use Void as response type."");
     }
 
-    HttpServiceMethod<ResponseT, ReturnT> build() {
-      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
-
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError(method, ""'""
-            + Utils.getRawType(responseType).getName()
-            + ""' is not a valid response body type. Did you mean ResponseBody?"");
-      }
-      responseConverter = createResponseConverter();
+    Converter<ResponseBody, ResponseT> responseConverter =
+        createResponseConverter(retrofit, method, responseType);
 
-      if (requestFactory.httpMethod.equals(""HEAD"") && !Void.class.equals(responseType)) {
-        throw methodError(method, ""HEAD method must use Void as response type."");
-      }
+    okhttp3.Call.Factory callFactory = retrofit.callFactory;
+    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);
+  }
 
-      return new HttpServiceMethod<>(this);
+  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
+      Retrofit retrofit, Method method) {
+    Type returnType = method.getGenericReturnType();
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      //noinspection unchecked
+      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, ""Unable to create call adapter for %s"", returnType);
     }
+  }
 
-    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(method, e, ""Unable to create call adapter for %s"", returnType);
-      }
+  private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
+      Retrofit retrofit, Method method, Type responseType) {
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.responseBodyConverter(responseType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, ""Unable to create converter for %s"", responseType);
     }
+  }
 
-    private Converter<ResponseBody, ResponseT> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(method, e, ""Unable to create converter for %s"", responseType);
-      }
-    }
+  private final RequestFactory requestFactory;
+  private final okhttp3.Call.Factory callFactory;
+  private final CallAdapter<ResponseT, ReturnT> callAdapter;
+  private final Converter<ResponseBody, ResponseT> responseConverter;
+
+  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+      CallAdapter<ResponseT, ReturnT> callAdapter,
+      Converter<ResponseBody, ResponseT> responseConverter) {
+    this.requestFactory = requestFactory;
+    this.callFactory = callFactory;
+    this.callAdapter = callAdapter;
+    this.responseConverter = responseConverter;
+  }
+
+  @Override ReturnT invoke(@Nullable Object[] args) {
+    return callAdapter.adapt(
+        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
   }
 }
@@ -23,6 +23,8 @@
 
 abstract class ServiceMethod<T> {
   static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
     Type returnType = method.getGenericReturnType();
     if (Utils.hasUnresolvableType(returnType)) {
       throw methodError(method,
@@ -32,7 +34,7 @@ static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
       throw methodError(method, ""Service methods cannot return void."");
     }
 
-    return new HttpServiceMethod.Builder<Object, T>(retrofit, method).build();
+    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
   }
 
   abstract T invoke(@Nullable Object[] args);
"
https://github.com/junit-team/junit4/commit/0733bbffdadf05a6ebe0c38942904071a4060af4,<pr_link> Fix many warnings (Eclipse 4.2/Juno based)  <enter> - Enh: add new 'staticondemandthreshold' setting to eclipse project jdt.ui preference settings file (although this is in fact not related to kcooney's import ordering change comment) ,https://api.github.com/repos/junit-team/junit4/commits/0733bbffdadf05a6ebe0c38942904071a4060af4,"@@ -1,13 +1,13 @@
-#Tue Jul 22 09:31:38 PDT 2008
-eclipse.preferences.version=1
-formatter_profile=_junit
-formatter_settings_version=11
-internal.default.compliance=default
-org.eclipse.jdt.ui.exception.name=e
-org.eclipse.jdt.ui.gettersetter.use.is=true
-org.eclipse.jdt.ui.ignorelowercasenames=true
-org.eclipse.jdt.ui.importorder=java;javax;com;
-org.eclipse.jdt.ui.keywordthis=false
-org.eclipse.jdt.ui.ondemandthreshold=99
-org.eclipse.jdt.ui.overrideannotation=true
-org.eclipse.jdt.ui.text.custom_code_templates=<?xml version\=""1.0"" encoding\=""UTF-8"" standalone\=""no""?><templates/>
+eclipse.preferences.version=1
+formatter_profile=_junit
+formatter_settings_version=12
+internal.default.compliance=default
+org.eclipse.jdt.ui.exception.name=e
+org.eclipse.jdt.ui.gettersetter.use.is=true
+org.eclipse.jdt.ui.ignorelowercasenames=true
+org.eclipse.jdt.ui.importorder=java;javax;com;
+org.eclipse.jdt.ui.keywordthis=false
+org.eclipse.jdt.ui.ondemandthreshold=99
+org.eclipse.jdt.ui.overrideannotation=true
+org.eclipse.jdt.ui.staticondemandthreshold=99
+org.eclipse.jdt.ui.text.custom_code_templates=<?xml version\=""1.0"" encoding\=""UTF-8"" standalone\=""no""?><templates/>
"
https://github.com/spring-projects/spring-boot/commit/4f9258a345130a5b031a3c4170dcb7046a1bd9b8,Fixup version numbers following release ,https://api.github.com/repos/spring-projects/spring-boot/commits/4f9258a345130a5b031a3c4170dcb7046a1bd9b8,"@@ -1,5 +1,4 @@
-<?xml version=""1.0"" encoding=""UTF-8""?>
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+<?xml version=""1.0"" encoding=""UTF-8""?><project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
 	<groupId>org.springframework.boot</groupId>
 	<artifactId>spring-boot-dependencies</artifactId>
@@ -45,7 +44,7 @@
 	</developers>
 	<properties>
 		<!-- Spring Boot -->
-		<spring-boot.version>1.1.7.BUILD-SNAPSHOT</spring-boot.version>
+		<spring-boot.version>1.1.8.BUILD-SNAPSHOT</spring-boot.version>
 		<!-- Third Party -->
 		<activemq.version>5.9.1</activemq.version>
 		<aspectj.version>1.8.2</aspectj.version>
@@ -1296,4 +1295,4 @@
 			</plugins>
 		</pluginManagement>
 	</build>
-</project>
+</project>
\ No newline at end of file
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 	}
 	repositories {
 		// NOTE: You should declare only repositories that you need here
@@ -5,7 +5,7 @@
 		'$ ant -lib ivy-2.2.jar' (substitute the location of your actual ivy jar). Run with '$ java -jar target/*.jar'. 
 	</description>
 
-	<property name=""spring-boot.version"" value=""1.1.7.BUILD-SNAPSHOT"" />
+	<property name=""spring-boot.version"" value=""1.1.8.BUILD-SNAPSHOT"" />
 	<property name=""start-class"" value=""org.springframework.boot.sample.actuator.SampleActuatorApplication"" />
 
 	<target name=""resolve"" description=""--> retrieve dependencies with ivy"">
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 	}
 	repositories {
 		// NOTE: You should declare only repositories that you need here
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 	}
 	repositories {
 		// NOTE: You should declare only repositories that you need here
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 	}
 	repositories {
 		// NOTE: You should declare only repositories that you need here
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 		springLoadedVersion = '1.2.0.RELEASE'
 	}
 	repositories {
"
https://github.com/apache/dubbo/commit/5b4816dfa6ae92d0b94af4ed41c07ca6c9d0fcb9,fix:Remove unused variable parameters in AbstractProxyInvoker ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/5b4816dfa6ae92d0b94af4ed41c07ca6c9d0fcb9,"@@ -82,7 +82,7 @@ public void destroy() {
     public Result invoke(Invocation invocation) throws RpcException {
         try {
             Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());
-            CompletableFuture<Object> future = wrapWithFuture(value, invocation);
+			CompletableFuture<Object> future = wrapWithFuture(value);
             CompletableFuture<AppResponse> appResponseFuture = future.handle((obj, t) -> {
                 AppResponse result = new AppResponse();
                 if (t != null) {
@@ -107,7 +107,7 @@ public Result invoke(Invocation invocation) throws RpcException {
         }
     }
 
-    private CompletableFuture<Object> wrapWithFuture (Object value, Invocation invocation) {
+	private CompletableFuture<Object> wrapWithFuture(Object value) {
         if (RpcContext.getContext().isAsyncStarted()) {
             return ((AsyncContextImpl)(RpcContext.getContext().getAsyncContext())).getInternalFuture();
         } else if (value instanceof CompletableFuture) {
"
https://github.com/square/okhttp/commit/59b1c1dc5290b9f96ebeefb7ea2369d58042fed3,Pom version updates. Drop unused dependencies. ,https://api.github.com/repos/square/okhttp/commits/59b1c1dc5290b9f96ebeefb7ea2369d58042fed3,"@@ -31,10 +31,8 @@
     <java.version>1.6</java.version>
     <npn.version>8.1.2.v20120308</npn.version>
     <mockwebserver.version>20130122</mockwebserver.version>
-    <bouncycastle.version>1.47</bouncycastle.version>
-    <android.version>4.1.1.4</android.version>
-    <dagger.version>0.9.1</dagger.version>
-    <gson.version>2.2.2</gson.version>
+    <bouncycastle.version>1.48</bouncycastle.version>
+    <gson.version>2.2.3</gson.version>
     <apache.http.version>4.2.2</apache.http.version>
 
     <!-- Test Dependencies -->
@@ -81,21 +79,11 @@
         <artifactId>bcprov-jdk15on</artifactId>
         <version>${bouncycastle.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
       <dependency>
         <groupId>com.google.code.gson</groupId>
         <artifactId>gson</artifactId>
         <version>${gson.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.squareup</groupId>
-        <artifactId>dagger</artifactId>
-        <version>${dagger.version}</version>
-      </dependency>
       <dependency>
         <groupId>org.apache.httpcomponents</groupId>
         <artifactId>httpclient</artifactId>
"
https://github.com/junit-team/junit4/commit/5ea3196f1cdbc32bc3a91b96bedc1964d3bb76d1,Used assertArrayEquals to avoid converting an array to a list.  <enter> Incomplete - task : Issue 551: Resolve sensitive equality in MethodSorter test. ,https://api.github.com/repos/junit-team/junit4/commits/5ea3196f1cdbc32bc3a91b96bedc1964d3bb76d1,"@@ -1,6 +1,7 @@
 package org.junit.internal;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertArrayEquals;
 
 import java.lang.reflect.Method;
 import java.util.ArrayList;
@@ -145,9 +146,9 @@ void epsilon() {
 
     @Test
     public void testJvmMethodSorter() {
-    	Method[] fromJvm = DummySortJvm.class.getDeclaredMethods();
-    	Method[] sorted = MethodSorter.getDeclaredMethods(DummySortJvm.class);
-    	assertEquals( Arrays.asList(fromJvm), Arrays.asList(sorted));
+        Method[] fromJvm = DummySortJvm.class.getDeclaredMethods();
+        Method[] sorted = MethodSorter.getDeclaredMethods(DummySortJvm.class);
+        assertArrayEquals(fromJvm, sorted);
     }
 
     @FixMethodOrder(MethodSorters.NAME_ASCENDING)
"
https://github.com/square/retrofit/commit/365a0cd97bd8ee597e937ebf88170b30685047f4,Add UrlConnection Client.  <enter> Use this on Android 2.2 and prior and when on the JVM. <enter> Also update our sample to use GitHub contributors rather than the Twitter API because the latter is shutting down and subject to lame rate limiting when on common networks. <enter> Bump some dependencies to their latest versions. ,https://api.github.com/repos/square/retrofit/commits/365a0cd97bd8ee597e937ebf88170b30685047f4,"@@ -44,21 +44,21 @@
     <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
     <!-- Compilation -->
-    <android-maven.version>3.4.0</android-maven.version>
+    <android-maven.version>3.5.1</android-maven.version>
     <java.version>1.6</java.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.2.3-SNAPSHOT</gson.version>
-    <httpcomponents.version>4.0.1</httpcomponents.version>
+    <gson.version>2.2.2</gson.version>
+    <httpmime.version>4.2.3</httpmime.version>
     <javax.inject.version>1</javax.inject.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
-    <fest.version>2.0M8</fest.version>
+    <fest.version>2.0M10</fest.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>14.0-rc3</guava.version>
+    <guava.version>14.0</guava.version>
   </properties>
 
   <scm>
@@ -114,12 +114,7 @@
       <dependency>
         <groupId>org.apache.httpcomponents</groupId>
         <artifactId>httpmime</artifactId>
-        <version>${httpcomponents.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.httpcomponents</groupId>
-        <artifactId>httpclient</artifactId>
-        <version>${httpcomponents.version}</version>
+        <version>${httpmime.version}</version>
       </dependency>
 
       <dependency>
@@ -20,18 +20,14 @@
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpclient</artifactId>
-    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpmime</artifactId>
     </dependency>
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
 
     <dependency>
@@ -1,5 +1,6 @@
 package retrofit.http;
 
+import android.os.Build;
 import android.os.Process;
 import com.google.gson.Gson;
 import java.util.concurrent.Executor;
@@ -8,10 +9,11 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import retrofit.http.android.AndroidApacheClient;
 import retrofit.http.android.MainThreadExecutor;
-import retrofit.http.client.ApacheClient;
 import retrofit.http.client.Client;
+import retrofit.http.client.UrlConnectionClient;
 
 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
+import static java.lang.Thread.MIN_PRIORITY;
 import static retrofit.http.RestAdapter.THREAD_PREFIX;
 import static retrofit.http.Utils.SynchronousExecutor;
 
@@ -41,7 +43,7 @@ Converter defaultConverter() {
   /** Provides sane defaults for operation on the JVM. */
   private static class Base extends Platform {
     @Override Client.Provider defaultClient() {
-      final Client client = new ApacheClient();
+      final Client client = new UrlConnectionClient();
       return new Client.Provider() {
         @Override public Client get() {
           return client;
@@ -56,7 +58,7 @@ private static class Base extends Platform {
         @Override public Thread newThread(final Runnable r) {
           return new Thread(new Runnable() {
             @Override public void run() {
-              Thread.currentThread().setPriority(THREAD_PRIORITY_BACKGROUND);
+              Thread.currentThread().setPriority(MIN_PRIORITY);
               r.run();
             }
           }, THREAD_PREFIX + threadCounter.getAndIncrement());
@@ -72,7 +74,12 @@ private static class Base extends Platform {
   /** Provides sane defaults for operation on Android. */
   private static class Android extends Platform {
     @Override Client.Provider defaultClient() {
-      final Client client = new AndroidApacheClient();
+      final Client client;
+      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+        client = new AndroidApacheClient();
+      } else {
+        client = new UrlConnectionClient();
+      }
       return new Client.Provider() {
         @Override public Client get() {
           return client;
@@ -18,15 +18,14 @@
 import org.apache.http.entity.AbstractHttpEntity;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HTTP;
 import org.apache.http.util.EntityUtils;
 import retrofit.http.Header;
 import retrofit.http.mime.TypedByteArray;
 import retrofit.http.mime.TypedOutput;
 
 /** A {@link Client} which uses an implementation of Apache's {@link HttpClient}. */
 public class ApacheClient implements Client {
-  private static final String HEADER_CONTENT_TYPE = ""Content-Type"";
-
   private final HttpClient client;
 
   /** Creates an instance backed by {@link DefaultHttpClient}. */
@@ -68,11 +67,11 @@ static Response parseResponse(HttpResponse response) throws IOException {
     String reason = statusLine.getReasonPhrase();
 
     List<Header> headers = new ArrayList<Header>();
-    String contentType = ""application/octet-stream"";
+    String contentType = HTTP.OCTET_STREAM_TYPE;
     for (org.apache.http.Header header : response.getAllHeaders()) {
       String name = header.getName();
       String value = header.getValue();
-      if (name.equalsIgnoreCase(HEADER_CONTENT_TYPE)) {
+      if (name.equalsIgnoreCase(HTTP.CONTENT_TYPE)) {
         contentType = value;
       }
       headers.add(new Header(name, value));
@@ -0,0 +1,93 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import retrofit.http.Header;
+import retrofit.http.mime.TypedInput;
+import retrofit.http.mime.TypedOutput;
+
+public class UrlConnectionClient implements Client {
+  @Override public Response execute(Request request) throws IOException {
+    HttpURLConnection connection = openConnection(request);
+    prepareRequest(connection, request);
+    return readResponse(connection);
+  }
+
+  protected HttpURLConnection openConnection(Request request) throws IOException {
+    return (HttpURLConnection) new URL(request.getUrl()).openConnection();
+  }
+
+  void prepareRequest(HttpURLConnection connection, Request request) throws IOException {
+    connection.setRequestMethod(request.getMethod());
+    connection.setDoInput(true);
+
+    for (Header header : request.getHeaders()) {
+      connection.addRequestProperty(header.getName(), header.getValue());
+    }
+
+    TypedOutput body = request.getBody();
+    if (body != null) {
+      connection.setDoOutput(true);
+      connection.addRequestProperty(""Content-Type"", body.mimeType());
+      long length = body.length();
+      if (length != -1) {
+        connection.addRequestProperty(""Content-Length"", String.valueOf(length));
+      }
+      body.writeTo(connection.getOutputStream());
+    }
+  }
+
+  Response readResponse(HttpURLConnection connection) throws IOException {
+    int status = connection.getResponseCode();
+    String reason = connection.getResponseMessage();
+
+    List<Header> headers = new ArrayList<Header>();
+    for (Map.Entry<String, List<String>> field : connection.getHeaderFields().entrySet()) {
+      String name = field.getKey();
+      for (String value : field.getValue()) {
+        headers.add(new Header(name, value));
+      }
+    }
+
+    String mimeType = connection.getContentType();
+    int length = connection.getContentLength();
+    InputStream stream;
+    if (status == 200) {
+      stream = connection.getInputStream();
+    } else {
+      stream = connection.getErrorStream();
+    }
+    TypedInput responseBody = new TypedInputStream(mimeType, length, stream);
+    return new Response(status, reason, headers, responseBody);
+  }
+
+  private static class TypedInputStream implements TypedInput {
+    private final String mimeType;
+    private final long length;
+    private final InputStream stream;
+
+    private TypedInputStream(String mimeType, long length, InputStream stream) {
+      this.mimeType = mimeType;
+      this.length = length;
+      this.stream = stream;
+    }
+
+    @Override public String mimeType() {
+      return mimeType;
+    }
+
+    @Override public long length() {
+      return length;
+    }
+
+    @Override public InputStream in() throws IOException {
+      return stream;
+    }
+  }
+}
@@ -42,4 +42,8 @@ public static HttpMultipart extractEntity(TypedOutput output)
   public static void assertMultipart(TypedOutput typedOutput) {
     assertThat(typedOutput).isInstanceOf(MultipartTypedOutput.class);
   }
+
+  public static void assertBytes(byte[] bytes, String expected) throws Exception {
+    assertThat(new String(bytes, ""UTF-8"")).isEqualTo(expected);
+  }
 }
@@ -21,6 +21,7 @@
 import retrofit.http.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static retrofit.http.TestingUtils.assertBytes;
 import static retrofit.http.TestingUtils.assertMultipart;
 import static retrofit.http.client.ApacheClient.TypedOutputEntity;
 
@@ -123,8 +124,4 @@ public class ApacheClientTest {
         .containsExactly(new Header(""foo"", ""bar""), new Header(""kit"", ""kat""));
     assertThat(response.getBody()).isNull();
   }
-
-  private static void assertBytes(byte[] bytes, String expected) throws Exception {
-    assertThat(new String(bytes, ""UTF-8"")).isEqualTo(expected);
-  }
 }
@@ -0,0 +1,115 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Provides POJO behavior for all of the APIs {@link retrofit.http.client.UrlConnectionClient}
+ * interacts with.
+ */
+public class DummyHttpUrlConnection extends HttpURLConnection {
+  private final Map<String, List<String>> responseHeaders =
+      new LinkedHashMap<String, List<String>>();
+  private final Map<String, List<String>> requestHeaders =
+      new LinkedHashMap<String, List<String>>();
+  private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+  private int responseCode;
+  private String responseMessage;
+  private InputStream inputStream;
+  private InputStream errorStream;
+
+  protected DummyHttpUrlConnection(String url) throws MalformedURLException {
+    super(new URL(url));
+  }
+
+  public void setResponseCode(int responseCode) {
+    this.responseCode = responseCode;
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return responseCode;
+  }
+
+  public void setResponseMessage(String responseMessage) {
+    this.responseMessage = responseMessage;
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return responseMessage;
+  }
+
+  @Override public ByteArrayOutputStream getOutputStream() throws IOException {
+    return outputStream;
+  }
+
+  public void setInputStream(InputStream inputStream) {
+    this.inputStream = inputStream;
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return inputStream;
+  }
+
+  public void setErrorStream(InputStream errorStream) {
+    this.errorStream = errorStream;
+  }
+
+  @Override public InputStream getErrorStream() {
+    return errorStream;
+  }
+
+  public void addResponseHeader(String name, String value) {
+    List<String> values = responseHeaders.get(name);
+    if (values == null) {
+      values = new ArrayList<String>();
+      responseHeaders.put(name, values);
+    }
+    values.add(value);
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    return responseHeaders;
+  }
+
+  @Override public void addRequestProperty(String name, String value) {
+    List<String> values = requestHeaders.get(name);
+    if (values == null) {
+      values = new ArrayList<String>();
+      requestHeaders.put(name, values);
+    }
+    values.add(value);
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    return requestHeaders;
+  }
+
+  @Override public String getRequestProperty(String name) {
+    List<String> values = requestHeaders.get(name);
+    if (values == null || values.isEmpty()) {
+      return null;
+    }
+    return values.get(0);
+  }
+
+  @Override public void disconnect() {
+    throw new AssertionError(""Not implemented."");
+  }
+
+  @Override public boolean usingProxy() {
+    return false;
+  }
+
+  @Override public void connect() throws IOException {
+    throw new AssertionError(""Not implemented."");
+  }
+}
@@ -0,0 +1,132 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import org.junit.Test;
+import retrofit.http.Header;
+import retrofit.http.TestingUtils;
+import retrofit.http.mime.TypedOutput;
+import retrofit.http.mime.TypedString;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static retrofit.http.TestingUtils.assertBytes;
+
+public class UrlConnectionClientTest {
+  private static final String HOST = ""http://example.com"";
+
+  private UrlConnectionClient client = new UrlConnectionClient() {
+    @Override protected HttpURLConnection openConnection(Request request) throws IOException {
+      return new DummyHttpUrlConnection(request.getUrl());
+    }
+  };
+
+  @Test public void get() throws Exception {
+    Request request = new Request(""GET"", HOST + ""/foo/bar/?kit=kat"", null, null);
+
+    HttpURLConnection connection = client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo(""GET"");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + ""/foo/bar/?kit=kat"");
+    assertThat(connection.getHeaderFields()).isEmpty();
+  }
+
+  @Test public void post() throws Exception {
+    TypedString body = new TypedString(""hi"");
+    Request request = new Request(""POST"", HOST + ""/foo/bar/"", null, body);
+
+    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo(""POST"");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + ""/foo/bar/"");
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty(""Content-Type"")) //
+        .isEqualTo(""text/plain; charset=UTF-8"");
+    assertThat(connection.getRequestProperty(""Content-Length"")).isEqualTo(""2"");
+    assertBytes(connection.getOutputStream().toByteArray(), ""hi"");
+  }
+
+  @Test public void multipart() throws Exception {
+    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
+    bodyParams.put(""foo"", new TypedString(""bar""));
+    bodyParams.put(""ping"", new TypedString(""pong""));
+    TypedOutput body = TestingUtils.createMultipart(bodyParams);
+    Request request = new Request(""POST"", HOST + ""/that/"", null, body);
+
+    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo(""POST"");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + ""/that/"");
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty(""Content-Type"")).startsWith(""multipart/form-data;"");
+    assertThat(connection.getRequestProperty(""Content-Length"")).isNotNull();
+    assertThat(connection.getOutputStream().toByteArray().length).isGreaterThan(0);
+  }
+
+  @Test public void headers() throws Exception {
+    List<Header> headers = new ArrayList<Header>();
+    headers.add(new Header(""kit"", ""kat""));
+    headers.add(new Header(""foo"", ""bar""));
+    Request request = new Request(""GET"", HOST + ""/this/"", headers, null);
+
+    HttpURLConnection connection = client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty(""kit"")).isEqualTo(""kat"");
+    assertThat(connection.getRequestProperty(""foo"")).isEqualTo(""bar"");
+  }
+
+  @Test public void response() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(200);
+    connection.setResponseMessage(""OK"");
+    connection.addResponseHeader(""Content-Type"", ""text/plain"");
+    connection.addResponseHeader(""foo"", ""bar"");
+    connection.addResponseHeader(""kit"", ""kat"");
+    connection.setInputStream(new ByteArrayInputStream(""hello"".getBytes(""UTF-8"")));
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getReason()).isEqualTo(""OK"");
+    assertThat(response.getHeaders()).hasSize(3) //
+        .containsOnly(new Header(""foo"", ""bar""), new Header(""kit"", ""kat""),
+            new Header(""Content-Type"", ""text/plain""));
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), ""hello"");
+  }
+
+  @Test public void errorResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(401);
+    connection.setResponseMessage(""Not Authorized"");
+    connection.addResponseHeader(""Content-Type"", ""text/plain"");
+    connection.setInputStream(new ByteArrayInputStream(""input"".getBytes(""UTF-8"")));
+    connection.setErrorStream(new ByteArrayInputStream(""error"".getBytes(""UTF-8"")));
+    Response response = client.readResponse(connection);
+
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), ""error"");
+  }
+
+  @Test public void emptyResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(200);
+    connection.setResponseMessage(""OK"");
+    connection.addResponseHeader(""foo"", ""bar"");
+    connection.addResponseHeader(""kit"", ""kat"");
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getReason()).isEqualTo(""OK"");
+    assertThat(response.getHeaders()).hasSize(2) //
+        .containsExactly(new Header(""foo"", ""bar""), new Header(""kit"", ""kat""));
+  }
+}
@@ -7,30 +7,34 @@
 import retrofit.http.RestAdapter;
 
 public class Client {
-  private static final String API_URL = ""https://api.twitter.com/1/"";
+  private static final String API_URL = ""https://api.github.com"";
 
-  class Tweet {
-    String text;
+  class Contributor {
+    String login;
+    int contributions;
   }
 
-  interface Twitter {
-    @GET(""/statuses/user_timeline.json"")
-    List<Tweet> tweets(@Name(""screen_name"") String user);
+  interface GitHub {
+    @GET(""/repos/{owner}/{repo}/contributors"")
+    List<Contributor> contributors(
+        @Name(""owner"") String owner,
+        @Name(""repo"") String repo
+    );
   }
 
   public static void main(String... args) {
-    // Create a very simple REST adapter which points the Twitter API endpoint.
+    // Create a very simple REST adapter which points the GitHub API endpoint.
     RestAdapter restAdapter = new RestAdapter.Builder()
         .setServer(API_URL)
         .build();
 
-    // Create an instance of our Twitter API interface.
-    Twitter twitter = restAdapter.create(Twitter.class);
+    // Create an instance of our GitHub API interface.
+    GitHub github = restAdapter.create(GitHub.class);
 
-    // Fetch and print a list of the 20 most recent tweets for a user.
-    List<Tweet> tweets = twitter.tweets(""horse_ebooks"");
-    for (Tweet tweet : tweets) {
-      System.out.println(tweet.text);
+    // Fetch and print a list of the contributors to this library.
+    List<Contributor> contributors = github.contributors(""square"", ""retrofit"");
+    for (Contributor contributor : contributors) {
+      System.out.println(contributor.login + "" ("" + contributor.contributions + "")"");
     }
   }
 }
"
https://github.com/spring-projects/spring-boot/commit/a9c9c383f4c7afe0119bded0d005d1481acf71ed,"Polish pom.xml  <enter> Aplly consistent formatting, drop JDK 8 support and cleanup repo locations to use spring.io. ",https://api.github.com/repos/spring-projects/spring-boot/commits/a9c9c383f4c7afe0119bded0d005d1481acf71ed,"@@ -116,11 +116,11 @@
 			<artifactId>spring-security-acl</artifactId>
 			<optional>true</optional>
 		</dependency>
-        <dependency>
-            <groupId>org.springframework.amqp</groupId>
-            <artifactId>spring-rabbit</artifactId>
-            <optional>true</optional>
-        </dependency>
+		<dependency>
+			<groupId>org.springframework.amqp</groupId>
+			<artifactId>spring-rabbit</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>org.springframework.mobile</groupId>
 			<artifactId>spring-mobile-device</artifactId>
@@ -152,9 +152,9 @@
 			<optional>true</optional>
 		</dependency>
 		<dependency>
-			 <groupId>org.apache.geronimo.specs</groupId>
-			 <artifactId>geronimo-jms_1.1_spec</artifactId>
-			 <optional>true</optional>
+			<groupId>org.apache.geronimo.specs</groupId>
+			<artifactId>geronimo-jms_1.1_spec</artifactId>
+			<optional>true</optional>
 		</dependency>
 		<dependency>
 			<groupId>org.aspectj</groupId>
@@ -71,7 +71,7 @@
 			<groupId>org.eclipse.aether</groupId>
 			<artifactId>aether-util</artifactId>
 		</dependency>
-		<!--  Test -->
+		<!-- Test -->
 		<dependency>
 			<groupId>junit</groupId>
 			<artifactId>junit</artifactId>
@@ -134,7 +134,8 @@
 		</plugins>
 		<pluginManagement>
 			<plugins>
-				<!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build itself.-->
+				<!--This plugin's configuration is used to store Eclipse m2e settings
+					only. It has no influence on the Maven build itself. -->
 				<plugin>
 					<groupId>org.eclipse.m2e</groupId>
 					<artifactId>lifecycle-mapping</artifactId>
@@ -152,7 +153,7 @@
 										</goals>
 									</pluginExecutionFilter>
 									<action>
-										<execute/>
+										<execute />
 									</action>
 								</pluginExecution>
 							</pluginExecutions>
@@ -51,7 +51,7 @@
 			<artifactId>groovy-templates</artifactId>
 			<optional>true</optional>
 		</dependency>
-		<!--  Provided -->
+		<!-- Provided -->
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>spring-boot-cli-grape</artifactId>
@@ -93,9 +93,9 @@
 			<resource>
 				<directory>src/main/resources</directory>
 				<filtering>true</filtering>
-                <excludes>
-                    <exclude>**/*.vpp</exclude>
-                </excludes>
+				<excludes>
+					<exclude>**/*.vpp</exclude>
+				</excludes>
 			</resource>
 			<resource>
 				<directory>src/main/groovy</directory>
@@ -216,7 +216,8 @@
 		</plugins>
 		<pluginManagement>
 			<plugins>
-				<!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build itself.-->
+				<!--This plugin's configuration is used to store Eclipse m2e settings
+					only. It has no influence on the Maven build itself. -->
 				<plugin>
 					<groupId>org.eclipse.m2e</groupId>
 					<artifactId>lifecycle-mapping</artifactId>
@@ -234,7 +235,7 @@
 										</goals>
 									</pluginExecutionFilter>
 									<action>
-										<execute/>
+										<execute />
 									</action>
 								</pluginExecution>
 							</pluginExecutions>
@@ -8,7 +8,6 @@
 	<packaging>pom</packaging>
 	<properties>
 		<activemq.version>5.4.0</activemq.version>
-		<aether.version>0.9.0.M3</aether.version>
 		<aspectj.version>1.7.3</aspectj.version>
 		<commons-dbcp.version>1.4</commons-dbcp.version>
 		<commons-httpclient.version>3.1</commons-httpclient.version>
@@ -441,11 +440,11 @@
 				<artifactId>spring-security-acl</artifactId>
 				<version>${spring-security.version}</version>
 			</dependency>
-            <dependency>
-                <groupId>org.springframework.amqp</groupId>
-                <artifactId>spring-rabbit</artifactId>
-                <version>${spring-rabbit.version}</version>
-            </dependency>
+			<dependency>
+				<groupId>org.springframework.amqp</groupId>
+				<artifactId>spring-rabbit</artifactId>
+				<version>${spring-rabbit.version}</version>
+			</dependency>
 			<dependency>
 				<groupId>org.springframework.mobile</groupId>
 				<artifactId>spring-mobile-device</artifactId>
@@ -11,6 +11,7 @@
 	<artifactId>spring-boot-parent</artifactId>
 	<packaging>pom</packaging>
 	<properties>
+		<aether.version>0.9.0.M3</aether.version>
 		<java.version>1.6</java.version>
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
@@ -253,6 +254,57 @@
 					<artifactId>sonar-maven-plugin</artifactId>
 					<version>2.0</version>
 				</plugin>
+				<!--This plugin's configuration is used to store Eclipse m2e settings
+					only. It has no influence on the Maven build itself. -->
+				<plugin>
+					<groupId>org.eclipse.m2e</groupId>
+					<artifactId>lifecycle-mapping</artifactId>
+					<version>1.0.0</version>
+					<configuration>
+						<lifecycleMappingMetadata>
+							<pluginExecutions>
+								<pluginExecution>
+									<pluginExecutionFilter>
+										<groupId>
+											org.apache.maven.plugins
+										</groupId>
+										<artifactId>
+											maven-enforcer-plugin
+										</artifactId>
+										<versionRange>
+											[1.3.1,)
+										</versionRange>
+										<goals>
+											<goal>enforce-once</goal>
+										</goals>
+									</pluginExecutionFilter>
+									<action>
+										<ignore></ignore>
+									</action>
+								</pluginExecution>
+								<pluginExecution>
+									<pluginExecutionFilter>
+										<groupId>
+											org.apache.maven.plugins
+										</groupId>
+										<artifactId>
+											maven-dependency-plugin
+										</artifactId>
+										<versionRange>
+											[2.8,)
+										</versionRange>
+										<goals>
+											<goal>copy</goal>
+										</goals>
+									</pluginExecutionFilter>
+									<action>
+										<ignore></ignore>
+									</action>
+								</pluginExecution>
+							</pluginExecutions>
+						</lifecycleMappingMetadata>
+					</configuration>
+				</plugin>
 			</plugins>
 		</pluginManagement>
 		<plugins>
@@ -281,7 +333,21 @@
 			</plugin>
 			<plugin>
 				<artifactId>maven-enforcer-plugin</artifactId>
-				<version>1.3.1</version>
+				<executions>
+					<execution>
+						<id>enforce-rules</id>
+						<goals>
+							<goal>enforce-once</goal>
+						</goals>
+						<configuration>
+							<rules>
+								<requireJavaVersion>
+									<version>(1.7,1.8)</version>
+								</requireJavaVersion>
+							</rules>
+						</configuration>
+					</execution>
+				</executions>
 			</plugin>
 			<plugin>
 				<artifactId>maven-jar-plugin</artifactId>
@@ -406,15 +472,15 @@
 				<repository>
 					<id>spring-milestones</id>
 					<name>Spring Milestones</name>
-					<url>http://maven.springframework.org/milestone</url>
+					<url>http://repo.spring.io/milestone</url>
 					<snapshots>
 						<enabled>false</enabled>
 					</snapshots>
 				</repository>
 				<repository>
 					<id>spring-snapshots</id>
 					<name>Spring Snapshots</name>
-					<url>http://maven.springframework.org/snapshot</url>
+					<url>http://repo.spring.io/snapshot</url>
 					<snapshots>
 						<enabled>true</enabled>
 					</snapshots>
@@ -424,15 +490,15 @@
 				<pluginRepository>
 					<id>spring-milestones</id>
 					<name>Spring Milestones</name>
-					<url>http://maven.springframework.org/milestone</url>
+					<url>http://repo.spring.io/milestone</url>
 					<snapshots>
 						<enabled>false</enabled>
 					</snapshots>
 				</pluginRepository>
 				<pluginRepository>
 					<id>spring-snapshots</id>
 					<name>Spring Snapshots</name>
-					<url>http://maven.springframework.org/snapshot</url>
+					<url>http://repo.spring.io/snapshot</url>
 					<snapshots>
 						<enabled>true</enabled>
 					</snapshots>
@@ -447,7 +513,7 @@
 				<repository>
 					<id>spring-milestones</id>
 					<name>Spring Milestones</name>
-					<url>http://maven.springframework.org/milestone</url>
+					<url>http://repo.spring.io/milestone</url>
 					<snapshots>
 						<enabled>false</enabled>
 					</snapshots>
@@ -457,7 +523,7 @@
 				<pluginRepository>
 					<id>spring-milestones</id>
 					<name>Spring Milestones</name>
-					<url>http://maven.springframework.org/milestone</url>
+					<url>http://repo.spring.io/snapshot</url>
 					<snapshots>
 						<enabled>false</enabled>
 					</snapshots>
@@ -488,8 +554,6 @@
 		</profile>
 		<profile>
 			<id>release</id>
-			<activation>
-			</activation>
 			<build>
 				<plugins>
 					<plugin>
@@ -513,21 +577,5 @@
 				</plugins>
 			</build>
 		</profile>
-		<profile>
-			<id>jdk8</id>
-			<activation>
-				<jdk>1.8</jdk>
-			</activation>
-			<build>
-				<plugins>
-					<plugin>
-						<artifactId>maven-javadoc-plugin</artifactId>
-						<configuration>
-							<additionalparam>-Xdoclint:none -quiet</additionalparam>
-						</configuration>
-					</plugin>
-				</plugins>
-			</build>
-		</profile>
 	</profiles>
 </project>
@@ -1,5 +1,6 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
 	<parent>
 		<groupId>org.springframework.boot</groupId>
@@ -258,17 +259,22 @@
 							</goals>
 							<configuration>
 								<transformers>
-									<transformer implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
+									<transformer
+										implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
 										<resource>META-INF/spring.handlers</resource>
 									</transformer>
-									<transformer implementation=""org.springframework.maven.packaging.PropertiesMergingResourceTransformer"">
+									<transformer
+										implementation=""org.springframework.maven.packaging.PropertiesMergingResourceTransformer"">
 										<resource>META-INF/spring.factories</resource>
 									</transformer>
-									<transformer implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
+									<transformer
+										implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
 										<resource>META-INF/spring.schemas</resource>
 									</transformer>
-									<transformer implementation=""org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"" />
-									<transformer implementation=""org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"">
+									<transformer
+										implementation=""org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"" />
+									<transformer
+										implementation=""org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"">
 										<mainClass>${start-class}</mainClass>
 									</transformer>
 								</transformers>
@@ -29,7 +29,7 @@
 		</dependency>
 		<dependency>
 			<groupId>org.apache.maven</groupId>
-			<artifactId>maven-core</artifactId>			
+			<artifactId>maven-core</artifactId>
 		</dependency>
 		<dependency>
 			<groupId>org.apache.maven</groupId>
@@ -65,7 +65,7 @@
 		<dependency>
 			<groupId>org.apache.maven.plugins</groupId>
 			<artifactId>maven-shade-plugin</artifactId>
-			<optional>true</optional>			
+			<optional>true</optional>
 		</dependency>
 		<!-- Provided -->
 		<dependency>
"
https://github.com/spring-projects/spring-boot/commit/7c13c01cb6a62b86478aa53d3516ae8aaea48bca,Fix mapping of Cassandra's idle-timeout and heartbeat-interval  <enter> Previous to this commit the connection idle timeout and heartbeat interval were mapped to seconds whereas Cassandra expects ms for all duration types. <enter> This commit fixes the mapping and removes the default duration unit since it should be considered ms like every other duration properties. <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/7c13c01cb6a62b86478aa53d3516ae8aaea48bca,"@@ -146,11 +146,11 @@ private void mapConnectionOptions(CassandraProperties properties, CassandraDrive
 	}
 
 	private void mapPoolingOptions(CassandraProperties properties, CassandraDriverOptions options) {
-		PropertyMapper map = PropertyMapper.get();
+		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
 		CassandraProperties.Pool poolProperties = properties.getPool();
-		map.from(poolProperties::getIdleTimeout).whenNonNull().asInt(Duration::getSeconds)
+		map.from(poolProperties::getIdleTimeout).asInt(Duration::toMillis)
 				.to((idleTimeout) -> options.add(DefaultDriverOption.HEARTBEAT_TIMEOUT, idleTimeout));
-		map.from(poolProperties::getHeartbeatInterval).whenNonNull().asInt(Duration::getSeconds)
+		map.from(poolProperties::getHeartbeatInterval).asInt(Duration::toMillis)
 				.to((heartBeatInterval) -> options.add(DefaultDriverOption.HEARTBEAT_INTERVAL, heartBeatInterval));
 	}
 
@@ -17,7 +17,6 @@
 package org.springframework.boot.autoconfigure.cassandra;
 
 import java.time.Duration;
-import java.time.temporal.ChronoUnit;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -26,7 +25,6 @@
 
 import org.springframework.boot.context.properties.ConfigurationProperties;
 import org.springframework.boot.context.properties.DeprecatedConfigurationProperty;
-import org.springframework.boot.convert.DurationUnit;
 
 /**
  * Configuration properties for Cassandra.
@@ -360,18 +358,14 @@ public Throttler getThrottler() {
 	public static class Pool {
 
 		/**
-		 * Idle timeout before an idle connection is removed. If a duration suffix is not
-		 * specified, seconds will be used.
+		 * Idle timeout before an idle connection is removed.
 		 */
-		@DurationUnit(ChronoUnit.SECONDS)
 		private Duration idleTimeout = Duration.ofSeconds(120);
 
 		/**
 		 * Heartbeat interval after which a message is sent on an idle connection to make
-		 * sure it's still alive. If a duration suffix is not specified, seconds will be
-		 * used.
+		 * sure it's still alive.
 		 */
-		@DurationUnit(ChronoUnit.SECONDS)
 		private Duration heartbeatInterval = Duration.ofSeconds(30);
 
 		public Duration getIdleTimeout() {
"
https://github.com/square/okhttp/commit/e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab,"Move cache writing out of the transport.  <enter> This is necessary to unblock network interceptors, where the interceptor may elect to rewrite the response body. If we've already cached the original response body, we're too late. ",https://api.github.com/repos/square/okhttp/commits/e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab,"@@ -660,9 +660,11 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         .method(requestMethod, requestBodyOrNull(requestMethod))
         .build();
     Response response1 = client.newCall(request).execute();
+    response1.body().close();
     assertEquals(""1"", response1.header(""X-Response-ID""));
 
     Response response2 = get(url);
+    response2.body().close();
     if (expectCached) {
       assertEquals(""1"", response2.header(""X-Response-ID""));
     } else {
@@ -629,9 +629,11 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     HttpURLConnection request1 = client.open(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
     assertEquals(""1"", request1.getHeaderField(""X-Response-ID""));
 
     URLConnection request2 = client.open(url);
+    request2.getInputStream().close();
     if (expectCached) {
       assertEquals(""1"", request2.getHeaderField(""X-Response-ID""));
     } else {
@@ -556,9 +556,11 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     HttpURLConnection request1 = openConnection(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
     assertEquals(""1"", request1.getHeaderField(""X-Response-ID""));
 
     URLConnection request2 = openConnection(url);
+    request2.getInputStream().close();
     if (expectCached) {
       assertEquals(""1"", request2.getHeaderField(""X-Response-ID""));
     } else {
@@ -169,7 +169,7 @@ Call get() {
           // Do not signal the callback twice!
           logger.log(Level.INFO, ""Callback failure for "" + toLoggableString(), e);
         } else {
-          responseCallback.onFailure(originalRequest, e);
+          responseCallback.onFailure(engine.getRequest(), e);
         }
       } finally {
         client.getDispatcher().finished(this);
@@ -31,6 +31,7 @@
 import java.net.Socket;
 import java.net.URL;
 import java.security.cert.X509Certificate;
+import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLSocket;
 
 import okio.Source;
@@ -406,8 +407,8 @@ private void makeTunnel(Request request, int readTimeout, int writeTimeout)
       // it before proceeding.
       long contentLength = OkHeaders.contentLength(response);
       if (contentLength != -1) {
-        Source body = tunnelConnection.newFixedLengthSource(null, contentLength);
-        Util.skipAll(body, Integer.MAX_VALUE);
+        Source body = tunnelConnection.newFixedLengthSource(contentLength);
+        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
       } else {
         tunnelConnection.emptyResponseBody();
       }
@@ -21,6 +21,7 @@
 import java.io.EOFException;
 import java.io.File;
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.io.UnsupportedEncodingException;
 import java.net.ServerSocket;
 import java.net.Socket;
@@ -37,13 +38,12 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Source;
 
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
 /** Junk drawer of utility methods. */
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
@@ -174,17 +174,44 @@ public static void deleteContents(File dir) throws IOException {
     }
   }
 
-  /** Reads until {@code in} is exhausted or the timeout has elapsed. */
-  public static boolean skipAll(Source in, int timeoutMillis) throws IOException {
-    // TODO: Implement deadlines everywhere so they can do this work.
-    long startNanos = System.nanoTime();
-    Buffer skipBuffer = new Buffer();
-    while (NANOSECONDS.toMillis(System.nanoTime() - startNanos) < timeoutMillis) {
-      long read = in.read(skipBuffer, 2048);
-      if (read == -1) return true; // Successfully exhausted the stream.
-      skipBuffer.clear();
+  /**
+   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
+   * a complete source is helpful, such as when doing so completes a cache body or frees a socket
+   * connection for reuse.
+   */
+  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
+    try {
+      return skipAll(source, timeout, timeUnit);
+    } catch (IOException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
+   * extend the deadline if one exists already.
+   */
+  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
+    long now = System.nanoTime();
+    long originalDuration = source.timeout().hasDeadline()
+        ? source.timeout().deadlineNanoTime() - now
+        : Long.MAX_VALUE;
+    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
+    try {
+      Buffer skipBuffer = new Buffer();
+      while (source.read(skipBuffer, 2048) != -1) {
+        skipBuffer.clear();
+      }
+      return true; // Success! The source has been exhausted.
+    } catch (InterruptedIOException e) {
+      return false; // We ran out of time before exhausting the source.
+    } finally {
+      if (originalDuration == Long.MAX_VALUE) {
+        source.timeout().clearDeadline();
+      } else {
+        source.timeout().deadlineNanoTime(now + originalDuration);
+      }
     }
-    return false; // Ran out of time.
   }
 
   /** Returns a 32 character string containing an MD5 hash of {@code s}. */
@@ -26,7 +26,6 @@
 import java.net.ProtocolException;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
-import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -38,6 +37,7 @@
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
 import static com.squareup.okhttp.internal.http.Transport.DISCARD_STREAM_TIMEOUT_MILLIS;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 /**
  * A socket connection that can be used to send HTTP/1.1 messages. This class
@@ -90,10 +90,10 @@ public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
 
   public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
     if (readTimeoutMillis != 0) {
-      source.timeout().timeout(readTimeoutMillis, TimeUnit.MILLISECONDS);
+      source.timeout().timeout(readTimeoutMillis, MILLISECONDS);
     }
     if (writeTimeoutMillis != 0) {
-      sink.timeout().timeout(writeTimeoutMillis, TimeUnit.MILLISECONDS);
+      sink.timeout().timeout(writeTimeoutMillis, MILLISECONDS);
     }
   }
 
@@ -211,26 +211,6 @@ public void readHeaders(Headers.Builder builder) throws IOException {
     }
   }
 
-  /**
-   * Discards the response body so that the connection can be reused and the
-   * cache entry can be completed. This needs to be done judiciously, since it
-   * delays the current request in order to speed up a potential future request
-   * that may never occur.
-   */
-  public boolean discard(Source in, int timeoutMillis) {
-    try {
-      int socketTimeout = socket.getSoTimeout();
-      socket.setSoTimeout(timeoutMillis);
-      try {
-        return Util.skipAll(in, timeoutMillis);
-      } finally {
-        socket.setSoTimeout(socketTimeout);
-      }
-    } catch (IOException e) {
-      return false;
-    }
-  }
-
   public Sink newChunkedSink() {
     if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_WRITING_REQUEST_BODY;
@@ -249,32 +229,30 @@ public void writeRequestBody(RetryableSink requestBody) throws IOException {
     requestBody.writeToSocket(sink);
   }
 
-  public Source newFixedLengthSource(CacheRequest cacheRequest, long length)
-      throws IOException {
+  public Source newFixedLengthSource(long length) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthSource(cacheRequest, length);
+    return new FixedLengthSource(length);
   }
 
   /**
    * Call this to advance past a response body for HTTP responses that do not
    * have a response body.
    */
   public void emptyResponseBody() throws IOException {
-    newFixedLengthSource(null, 0L); // Transition to STATE_IDLE.
+    newFixedLengthSource(0L); // Transition to STATE_IDLE.
   }
 
-  public Source newChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine)
-      throws IOException {
+  public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(cacheRequest, httpEngine);
+    return new ChunkedSource(httpEngine);
   }
 
-  public Source newUnknownLengthSource(CacheRequest cacheRequest) throws IOException {
+  public Source newUnknownLengthSource() throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new UnknownLengthSource(cacheRequest);
+    return new UnknownLengthSource();
   }
 
   /** An HTTP body with a fixed length known in advance. */
@@ -370,40 +348,15 @@ private void writeHex(long i) throws IOException {
   }
 
   private class AbstractSource {
-    private final CacheRequest cacheRequest;
-    protected final BufferedSink cacheBody;
     protected boolean closed;
 
-    AbstractSource(CacheRequest cacheRequest) throws IOException {
-      // Some apps return a null body; for compatibility we treat that like a null cache request.
-      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
-      if (cacheBody == null) {
-        cacheRequest = null;
-      }
-
-      this.cacheBody = cacheBody != null ? Okio.buffer(cacheBody) : null;
-      this.cacheRequest = cacheRequest;
-    }
-
-    /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
-    protected final void cacheWrite(Buffer source, long byteCount) throws IOException {
-      if (cacheBody != null) {
-        source.copyTo(cacheBody.buffer(), source.size() - byteCount, byteCount);
-        cacheBody.emitCompleteSegments();
-      }
-    }
-
     /**
      * Closes the cache entry and makes the socket available for reuse. This
      * should be invoked when the end of the body has been reached.
      */
     protected final void endOfInput(boolean recyclable) throws IOException {
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
 
-      if (cacheRequest != null) {
-        cacheBody.close();
-      }
-
       state = STATE_IDLE;
       if (recyclable && onIdle == ON_IDLE_POOL) {
         onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
@@ -427,9 +380,6 @@ protected final void endOfInput(boolean recyclable) throws IOException {
      * to cancel the transfer, closing the connection is the only solution.
      */
     protected final void unexpectedEndOfInput() {
-      if (cacheRequest != null) {
-        cacheRequest.abort();
-      }
       Util.closeQuietly(connection.getSocket());
       state = STATE_CLOSED;
     }
@@ -439,28 +389,25 @@ protected final void unexpectedEndOfInput() {
   private class FixedLengthSource extends AbstractSource implements Source {
     private long bytesRemaining;
 
-    public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOException {
-      super(cacheRequest);
+    public FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
         endOfInput(true);
       }
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
       if (closed) throw new IllegalStateException(""closed"");
       if (bytesRemaining == 0) return -1;
 
       long read = source.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised content length
+        unexpectedEndOfInput(); // The server didn't supply the promised content length.
         throw new ProtocolException(""unexpected end of stream"");
       }
 
       bytesRemaining -= read;
-      cacheWrite(sink, read);
       if (bytesRemaining == 0) {
         endOfInput(true);
       }
@@ -474,7 +421,8 @@ public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOExcept
     @Override public void close() throws IOException {
       if (closed) return;
 
-      if (bytesRemaining != 0 && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
+      if (bytesRemaining != 0
+          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
         unexpectedEndOfInput();
       }
 
@@ -489,13 +437,11 @@ private class ChunkedSource extends AbstractSource implements Source {
     private boolean hasMoreChunks = true;
     private final HttpEngine httpEngine;
 
-    ChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
-      super(cacheRequest);
+    ChunkedSource(HttpEngine httpEngine) throws IOException {
       this.httpEngine = httpEngine;
     }
 
-    @Override public long read(
-        Buffer sink, long byteCount) throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
       if (closed) throw new IllegalStateException(""closed"");
       if (!hasMoreChunks) return -1;
@@ -507,16 +453,15 @@ private class ChunkedSource extends AbstractSource implements Source {
 
       long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised chunk length
+        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
         throw new IOException(""unexpected end of stream"");
       }
       bytesRemainingInChunk -= read;
-      cacheWrite(sink, read);
       return read;
     }
 
     private void readChunkSize() throws IOException {
-      // read the suffix of the previous chunk
+      // Read the suffix of the previous chunk.
       if (bytesRemainingInChunk != NO_CHUNK_YET) {
         source.readUtf8LineStrict();
       }
@@ -545,7 +490,7 @@ private void readChunkSize() throws IOException {
 
     @Override public void close() throws IOException {
       if (closed) return;
-      if (hasMoreChunks && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
+      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
         unexpectedEndOfInput();
       }
       closed = true;
@@ -556,10 +501,6 @@ private void readChunkSize() throws IOException {
   class UnknownLengthSource extends AbstractSource implements Source {
     private boolean inputExhausted;
 
-    UnknownLengthSource(CacheRequest cacheRequest) throws IOException {
-      super(cacheRequest);
-    }
-
     @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
@@ -572,7 +513,6 @@ class UnknownLengthSource extends AbstractSource implements Source {
         endOfInput(false);
         return -1;
       }
-      cacheWrite(sink, read);
       return read;
     }
 
@@ -582,7 +522,6 @@ class UnknownLengthSource extends AbstractSource implements Source {
 
     @Override public void close() throws IOException {
       if (closed) return;
-      // TODO: discard unknown length streams for best caching?
       if (!inputExhausted) {
         unexpectedEndOfInput();
       }
@@ -28,6 +28,7 @@
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
 import java.io.InputStream;
@@ -48,6 +49,7 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Timeout;
 
 import static com.squareup.okhttp.internal.Util.closeQuietly;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
@@ -63,6 +65,7 @@
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -709,14 +712,71 @@ public void readResponse(boolean forWebSocket) throws IOException {
     if (!hasResponseBody()) {
       if (!forWebSocket) {
         // Don't call initContentStream() when the response doesn't have any content.
-        responseTransferSource = transport.getTransferStream(storeRequest);
+        responseTransferSource = transport.getTransferStream();
         responseBody = Okio.buffer(responseTransferSource);
       }
       return;
     }
 
     maybeCache();
-    initContentStream(transport.getTransferStream(storeRequest));
+    initContentStream(cacheWritingSource(storeRequest, transport.getTransferStream()));
+  }
+
+  /**
+   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+   * may never exhaust the source stream and therefore not complete the cached response.
+   */
+  private Source cacheWritingSource(final CacheRequest cacheRequest, final Source source)
+      throws IOException {
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
+    if (cacheRequest == null) return source;
+    Sink cacheBodyUnbuffered = cacheRequest.body();
+    if (cacheBodyUnbuffered == null) return source;
+
+    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+    return new Source() {
+      boolean cacheRequestClosed;
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        long bytesRead;
+        try {
+          bytesRead = source.read(sink, byteCount);
+        } catch (IOException e) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheRequest.abort(); // Failed to write a complete cache response.
+          }
+          throw e;
+        }
+
+        if (bytesRead == -1) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheBody.close(); // The cache response is complete!
+          }
+          return -1;
+        }
+
+        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+        cacheBody.emitCompleteSegments();
+        return bytesRead;
+      }
+
+      @Override public Timeout timeout() {
+        return source.timeout();
+      }
+
+      @Override public void close() throws IOException {
+        if (!cacheRequestClosed
+            && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+          cacheRequestClosed = true;
+          cacheRequest.abort();
+        }
+        source.close();
+      }
+    };
   }
 
   /**
@@ -108,24 +108,24 @@ public void writeRequestHeaders(Request request) throws IOException {
     httpConnection.emptyResponseBody();
   }
 
-  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
+  @Override public Source getTransferStream() throws IOException {
     if (!httpEngine.hasResponseBody()) {
-      return httpConnection.newFixedLengthSource(cacheRequest, 0);
+      return httpConnection.newFixedLengthSource(0);
     }
 
     if (""chunked"".equalsIgnoreCase(httpEngine.getResponse().header(""Transfer-Encoding""))) {
-      return httpConnection.newChunkedSource(cacheRequest, httpEngine);
+      return httpConnection.newChunkedSource(httpEngine);
     }
 
     long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
     if (contentLength != -1) {
-      return httpConnection.newFixedLengthSource(cacheRequest, contentLength);
+      return httpConnection.newFixedLengthSource(contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
     // ""socketIn"" directly here), so that we can control its use after the
     // reference escapes.
-    return httpConnection.newUnknownLengthSource(cacheRequest);
+    return httpConnection.newUnknownLengthSource();
   }
 
   @Override public void disconnect(HttpEngine engine) throws IOException {
@@ -33,13 +33,9 @@
 import java.util.Locale;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.BufferedSink;
 import okio.ByteString;
-import okio.Okio;
 import okio.Sink;
 import okio.Source;
-import okio.Timeout;
 
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
@@ -212,8 +208,8 @@ public static Response.Builder readNameValueBlock(List<Header> headerBlock,
     // Do nothing.
   }
 
-  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
-    return new SpdySource(stream, cacheRequest);
+  @Override public Source getTransferStream() throws IOException {
+    return stream.getSource();
   }
 
   @Override public void releaseConnectionOnIdle() {
@@ -237,86 +233,4 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       throw new AssertionError(protocol);
     }
   }
-
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private static class SpdySource implements Source {
-    private final SpdyStream stream;
-    private final Source source;
-    private final CacheRequest cacheRequest;
-    private final BufferedSink cacheBody;
-
-    private boolean inputExhausted;
-    private boolean closed;
-
-    SpdySource(SpdyStream stream, CacheRequest cacheRequest) throws IOException {
-      this.stream = stream;
-      this.source = stream.getSource();
-
-      // Some apps return a null body; for compatibility we treat that like a null cache request.
-      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
-      if (cacheBody == null) {
-        cacheRequest = null;
-      }
-
-      this.cacheBody = cacheBody != null ? Okio.buffer(cacheBody) : null;
-      this.cacheRequest = cacheRequest;
-    }
-
-    @Override public long read(Buffer buffer, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
-      if (closed) throw new IllegalStateException(""closed"");
-      if (inputExhausted) return -1;
-
-      long read = source.read(buffer, byteCount);
-      if (read == -1) {
-        inputExhausted = true;
-        if (cacheRequest != null) {
-          cacheBody.close();
-        }
-        return -1;
-      }
-
-      if (cacheBody != null) {
-        buffer.copyTo(cacheBody.buffer(), buffer.size() - read, read);
-        cacheBody.emitCompleteSegments();
-      }
-
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-
-      if (!inputExhausted && cacheBody != null) {
-        discardStream(); // Could make inputExhausted true!
-      }
-
-      closed = true;
-
-      if (!inputExhausted) {
-        stream.closeLater(ErrorCode.CANCEL);
-        if (cacheRequest != null) {
-          cacheRequest.abort();
-        }
-      }
-    }
-
-    private boolean discardStream() {
-      long oldTimeoutNanos = stream.readTimeout().timeoutNanos();
-      stream.readTimeout().timeout(DISCARD_STREAM_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      try {
-        Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
-        return true;
-      } catch (IOException e) {
-        return false;
-      } finally {
-        stream.readTimeout().timeout(oldTimeoutNanos, TimeUnit.NANOSECONDS);
-      }
-    }
-  }
 }
@@ -51,8 +51,7 @@ public interface Transport {
   /** Notify the transport that no response body will be read. */
   void emptyTransferStream() throws IOException;
 
-  // TODO: make this the content stream?
-  Source getTransferStream(CacheRequest cacheRequest) throws IOException;
+  Source getTransferStream() throws IOException;
 
   /**
    * Configures the response body to pool or close the socket connection when
"
https://github.com/spring-projects/spring-boot/commit/15de956566b0737d3e53a816a6be60ed3e41c759,Fix typo `Assert4J` -> `AssertJ`  <enter> See  <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/15de956566b0737d3e53a816a6be60ed3e41c759,"@@ -7468,7 +7468,7 @@ TIP: If multiple auto-configurations have to be defined, there is no need to ord
 
 Each test can use the runner to represent a particular use case.
 For instance, the sample below invokes a user configuration (`UserConfiguration`) and checks that the auto-configuration backs off properly.
-Invoking `run` provides a callback context that can be used with `Assert4J`.
+Invoking `run` provides a callback context that can be used with `AssertJ`.
 
 [source,java,indent=0]
 ----
"
https://github.com/square/retrofit/commit/9b6bd6bbbe752fceaa4517b3eda7cd678679198d,"Use ServerError directly in sessionExpired and serverError.  <enter> This is a short step on the road to HTTP body format agnostic support. And it's not a pretty step, either. ",https://api.github.com/repos/square/retrofit/commits/9b6bd6bbbe752fceaa4517b3eda7cd678679198d,"@@ -7,7 +7,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -21,8 +21,10 @@ public interface Callback<T> {
   /**
    * The session expired or the account has been disabled. Prompt the user to
    * log in again.
+   *
+   * @param error message to show user, or null if no message was returned
    */
-  void sessionExpired();
+  void sessionExpired(ServerError error);
 
   /**
    * Couldn't reach the server. Check network settings and try again.
@@ -43,10 +45,10 @@ public interface Callback<T> {
    * We reached the server, but it encountered an error (5xx) or its response
    * was unparseable. Please try again later.
    *
-   * @param message to show user, or null if no message was returned
+   * @param error message to show user, or null if no message was returned
    * @param statusCode the HTTP response code
    */
-  void serverError(String message, int statusCode);
+  void serverError(ServerError error, int statusCode);
 
   /**
    * An unexpected error occurred. Called if the framework throws an unexpected
@@ -55,4 +57,14 @@ public interface Callback<T> {
    * would have been caught sooner. The user should try updating their client.
    */
   void unexpectedError(Throwable t);
+
+
+  /** JSON object for parsing server error responses. */
+  static class ServerError {
+    public final String message;
+
+    public ServerError(String message) {
+      this.message = message;
+    }
+  }
 }
@@ -2,15 +2,17 @@
 package retrofit.http;
 
 import com.google.gson.Gson;
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpStatus;
 import org.apache.http.StatusLine;
 import org.apache.http.client.ResponseHandler;
 import org.apache.http.entity.BufferedHttpEntity;
+import retrofit.http.Callback.ServerError;
+
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * Support for response handlers that invoke {@link Callback}.
@@ -63,14 +65,21 @@ public Void handleResponse(HttpResponse response) throws IOException {
 
     StatusLine statusLine = response.getStatusLine();
     int statusCode = statusLine.getStatusCode();
+    HttpEntity entity = response.getEntity();
 
     if (statusCode == HttpStatus.SC_UNAUTHORIZED) {
-      LOGGER.fine(""Session expired.  Request url "" + requestUrl);
-      callback.sessionExpired();
+      if (entity != null) {
+        // TODO: Use specified encoding.
+        String body = new String(HttpClients.entityToBytes(entity), ""UTF-8"");
+        LOGGER.fine(""Session expired. Body: "" + body + "". Request url "" + requestUrl);
+        callback.sessionExpired(parseServerMessage(statusCode, body));
+      } else {
+        LOGGER.fine(""Session expired.  Request url "" + requestUrl);
+        callback.sessionExpired(null);
+      }
       return null;
     }
 
-    HttpEntity entity = response.getEntity();
 
     // 2XX == successful request
     if (statusCode >= 200 && statusCode < 300) {
@@ -131,24 +140,16 @@ public Void handleResponse(HttpResponse response) throws IOException {
   /**
    * Parses a server error message.
    */
-  private String parseServerMessage(int statusCode, String body) {
+  private ServerError parseServerMessage(int statusCode, String body) {
     if (statusCode == HttpStatus.SC_BAD_GATEWAY || statusCode == HttpStatus.SC_GATEWAY_TIMEOUT
         || statusCode < 500) {
       try {
-        ServerError serverError = gson.fromJson(body, ServerError.class);
-        if (serverError != null) return serverError.message;
+        return gson.fromJson(body, ServerError.class);
       } catch (Throwable t) {
         // The server error takes precedence.
         LOGGER.log(Level.WARNING, t.getMessage(), t);
       }
     }
     return null;
   }
-
-  /**
-   * Gson POJO for parsing server error messages.
-   */
-  static class ServerError {
-    String message;
-  }
 }
@@ -1,6 +1,17 @@
 package retrofit.http;
 
 import com.google.gson.Gson;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.ResponseHandler;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Singleton;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -14,16 +25,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.ResponseHandler;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpUriRequest;
 
 /**
  * Converts Java method calls to Rest calls.
@@ -108,8 +109,8 @@ private class RestHandler implements InvocationHandler {
         url = request.getURI().toString();
 
         // The last parameter should be of type Callback<T>. Determine T.
-        Type[] genericParameterTypes = method.getGenericParameterTypes();
-        final Type resultType = getCallbackParameterType(method, genericParameterTypes);
+        Type[] resultTypes = getCallbackParameterTypes(method);
+        final Type resultType = resultTypes[resultTypes.length - 1];
         LOGGER.fine(""Sending "" + request.getMethod() + "" to "" + request.getURI());
         final Date start = new Date();
         startTime = dateFormat.get().format(start);
@@ -183,44 +184,36 @@ private <T> ProfilingResponseHandler<T> createProfiler(ResponseHandler<Void> han
 
       return responseHandler;
     }
+  }
 
-    private static final String NOT_CALLBACK =
-        ""Last parameter of %s must be"" + "" of type Callback<X> or Callback<? super X>."";
-
-    /** Gets the callback parameter type. */
-    private Type getCallbackParameterType(Method method, Type[] parameterTypes) {
-      Type lastType = parameterTypes[parameterTypes.length - 1];
-
-      /*
-       * Note: When more than one parameter is present, we seem to get
-       * ParameterizedType Callback<? extends Object> instead of
-       * WilcardType Callback<? super Foo> like we expected. File a bug.
-       */
-      if (lastType instanceof ParameterizedType) {
-        ParameterizedType pType = (ParameterizedType) lastType;
-        if (pType.getRawType() != Callback.class) {
-          throw notCallback(method);
-        }
-        return pType.getActualTypeArguments()[0];
-      }
-
-      if (lastType instanceof WildcardType) {
-        // Example: ? super SimpleResponse
-        // Use the lower bound.
-        WildcardType wildcardType = (WildcardType) lastType;
-        Type[] lowerBounds = wildcardType.getLowerBounds();
-        if (lowerBounds.length != 1) {
-          throw notCallback(method);
+  /** Get the callback parameter types. */
+  static Type[] getCallbackParameterTypes(Method method) {
+    Type[] parameterTypes = method.getGenericParameterTypes();
+    Type callbackType = parameterTypes[parameterTypes.length - 1];
+    Class<?> callbackClass;
+    if (callbackType instanceof Class) {
+      callbackClass = (Class<?>) callbackType;
+    } else if (callbackType instanceof ParameterizedType) {
+      callbackClass = (Class<?>) ((ParameterizedType) callbackType).getRawType();
+    } else {
+      throw new ClassCastException(
+          String.format(""Last parameter of %s must be a Class or ParameterizedType"", method));
+    }
+    if (Callback.class.isAssignableFrom(callbackClass)) {
+      callbackType = Types.getGenericSupertype(callbackType, callbackClass, Callback.class);
+      if (callbackType instanceof ParameterizedType) {
+        Type[] types = ((ParameterizedType) callbackType).getActualTypeArguments();
+        for (int i = 0; i < types.length; i++) {
+          Type type = types[i];
+          if (type instanceof WildcardType) {
+            types[i] = ((WildcardType) type).getUpperBounds()[0];
+          }
         }
-        return lowerBounds[0];
+        return types;
       }
-
-      throw notCallback(method);
-    }
-
-    private IllegalArgumentException notCallback(Method method) {
-      return new IllegalArgumentException(String.format(NOT_CALLBACK, method));
     }
+    throw new IllegalArgumentException(
+        String.format(""Last parameter of %s must be of type Callback<X,Y,Z> or Callback<? super X,..,..>."", method));
   }
 
   /** Sends server call times and response status codes to {@link HttpProfiler}. */
@@ -0,0 +1,52 @@
+// Copyright 2012 Square, Inc.
+package retrofit.http;
+
+/**
+ * Helper methods for dealing with generic types via reflection.
+ *
+ * @author Jake Wharton (jw@squareup.com)
+ */
+import java.lang.reflect.Type;
+
+class Types {
+  /**
+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   * <p/>
+   * NOTE: This method is copied from Guice's {@code MoreTypes} class.
+   */
+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+    if (toResolve == rawType) {
+      return context;
+    }
+
+    // we skip searching through interfaces if unknown is an interface
+    if (toResolve.isInterface()) {
+      Class<?>[] interfaces = rawType.getInterfaces();
+      for (int i = 0, length = interfaces.length; i < length; i++) {
+        if (interfaces[i] == toResolve) {
+          return rawType.getGenericInterfaces()[i];
+        } else if (toResolve.isAssignableFrom(interfaces[i])) {
+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+        }
+      }
+    }
+
+    // check our supertypes
+    if (!rawType.isInterface()) {
+      while (rawType != Object.class) {
+        Class<?> rawSupertype = rawType.getSuperclass();
+        if (rawSupertype == toResolve) {
+          return rawType.getGenericSuperclass();
+        } else if (toResolve.isAssignableFrom(rawSupertype)) {
+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+        }
+        rawType = rawSupertype;
+      }
+    }
+
+    // we can't resolve this further
+    return toResolve;
+  }
+}
\ No newline at end of file
@@ -29,10 +29,10 @@ public void run() {
     });
   }
 
-  public void sessionExpired() {
+  public void sessionExpired(final ServerError error) {
     mainThread.execute(new Runnable() {
       public void run() {
-        delegate.sessionExpired();
+        delegate.sessionExpired(error);
       }
     });
   }
@@ -53,10 +53,10 @@ public void run() {
     });
   }
 
-  public void serverError(final String message, final int statusCode) {
+  public void serverError(final ServerError error, final int statusCode) {
     mainThread.execute(new Runnable() {
       public void run() {
-        delegate.serverError(message, statusCode);
+        delegate.serverError(error, statusCode);
       }
     });
   }
@@ -224,7 +224,7 @@ private class MyCallback implements Callback<SimpleResponse> {
     @Override public void call(SimpleResponse simpleResponse) {
     }
 
-    @Override public void sessionExpired() {
+    @Override public void sessionExpired(ServerError error) {
     }
 
     @Override public void networkError() {
@@ -233,7 +233,7 @@ private class MyCallback implements Callback<SimpleResponse> {
     @Override public void clientError(SimpleResponse response, int statusCode) {
     }
 
-    @Override public void serverError(String message, int statusCode) {
+    @Override public void serverError(ServerError error, int statusCode) {
     }
 
     @Override public void unexpectedError(Throwable t) {
@@ -1,6 +1,7 @@
 package retrofit.http;
 
 import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
 import org.apache.http.HttpMessage;
 import org.apache.http.HttpResponse;
 import org.apache.http.ProtocolVersion;
@@ -15,12 +16,16 @@
 import org.easymock.Capture;
 import org.easymock.IAnswer;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import javax.inject.Named;
 import javax.inject.Provider;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.List;
 import java.util.concurrent.Executor;
 
 import static org.easymock.EasyMock.capture;
@@ -251,6 +256,47 @@ public class RestAdapterTest {
     verifyAll();
   }
 
+  @Test public void testConcreteCallbackTypes() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""a""))).as(""a"").isEqualTo(expected);
+  }
+
+  @Test public void testConcreteCallbackTypesWithParams() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""b""))).as(""b"").isEqualTo(expected);
+  }
+
+  @Test public void testGenericCallbackTypes() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""c""))).as(""c"").isEqualTo(expected);
+  }
+
+  @Test public void testGenericCallbackTypesWithParams() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""d""))).as(""d"").isEqualTo(expected);
+  }
+
+  @Test public void testWildcardGenericCallbackTypes() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""e""))).as(""e"").isEqualTo(expected);
+  }
+
+  @Test public void testGenericCallbackWithGenericType() {
+    Type[] expected = new Type[] { new TypeToken<List<String>>() {}.getType() };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""f""))).as(""f"").isEqualTo(expected);
+  }
+
+  @Ignore // TODO support this case!
+  @Test public void testExtendingGenericCallback() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""g""))).as(""g"").isEqualTo(expected);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testMissingCallbackTypes() {
+    RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""h""));
+  }
+
   //
   // Utility Methods:
   //
@@ -432,6 +478,33 @@ public Response(String text) {
     @Override public boolean equals(Object obj) {
       return obj instanceof Response && text.equals(((Response)obj).text);
     }
+  }
+
+  @SuppressWarnings(""UnusedDeclaration"")
+  private interface TypeTestService {
+    @GET(ENTITY) void a(ResponseCallback c);
+    @GET(ENTITY) void b(@Named(""id"") String id, ResponseCallback c);
+    @GET(ENTITY) void c(Callback<Response> c);
+    @GET(ENTITY) void d(@Named(""id"") String id, Callback<Response> c);
+    @GET(ENTITY) void e(Callback<? extends Response> c);
+    @GET(ENTITY) void f(Callback<List<String>> c);
+    @GET(ENTITY) void g(ExtendingCallback<Response> callback);
+    @GET(ENTITY) void h(@Named(""id"") String id);
+  }
+
+  private static Method getTypeTestMethod(String name) {
+    Method[] methods = TypeTestService.class.getDeclaredMethods();
+    for (Method method : methods) {
+      if (method.getName().equals(name)) {
+        return method;
+      }
+    }
+    throw new IllegalArgumentException(""Unknown method '"" + name + ""' on "" + TypeTestService.class.getSimpleName());
+  }
+
+  private interface ResponseCallback extends Callback<Response> {
+  }
 
+  private interface ExtendingCallback<T> extends Callback<T> {
   }
 }
@@ -7,7 +7,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -26,7 +26,7 @@
 
   <groupId>com.squareup</groupId>
   <artifactId>retrofit</artifactId>
-  <version>0.7.0-SNAPSHOT</version>
+  <version>0.8.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit</name>
@@ -7,7 +7,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -7,7 +7,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -7,7 +7,7 @@
   <parent>
     <artifactId>retrofit</artifactId>
     <groupId>com.squareup</groupId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>retrofit-sync</artifactId>
"
https://github.com/square/retrofit/commit/3bdad39745db76928fce0f31b3c2a8e8922c40b3,Properly name ignored exception in 'catch' block. ,https://api.github.com/repos/square/retrofit/commits/3bdad39745db76928fce0f31b3c2a8e8922c40b3,"@@ -173,7 +173,7 @@ private static boolean hasRxJavaOnClasspath() {
     try {
       Class.forName(""rx.Observable"");
       return true;
-    } catch (ClassNotFoundException e) {
+    } catch (ClassNotFoundException ignored) {
     }
     return false;
   }
"
https://github.com/square/okhttp/commit/abb0a790802996d1039c35424b70b0f3f06b94b7,First step towards HTTP/2 automatic pings. ( <pr_link> )  <enter> This changes the executor services in HTTP/2 connection to split up listener executors (of which there may be many threads) from writer executors (of which there is one per connection). <enter> This adds a scheduled executor job to send pings on an interval. We don't yet fail the connection if pongs are not received. <enter> For follow-up there's some work to remove exising APIs to send pings through the HTTP/2 APIs. These are unused and make it awkard to confirm that only the automatic pings are being replied to. <enter> See  <issue_link> ,https://api.github.com/repos/square/okhttp/commits/abb0a790802996d1039c35424b70b0f3f06b94b7,"@@ -28,6 +28,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.net.ssl.HostnameVerifier;
@@ -54,20 +55,19 @@
 import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.PushPromise;
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.mockwebserver.internal.tls.SslClient;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
-import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -922,15 +922,52 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertThat(""data logged"", firstFrame(logs, ""DATA""), containsString(""0 DATA          END_STREAM""));
   }
 
+  @Test public void pingsTransmitted() throws Exception {
+    // Ping every 500 ms, starting at 500 ms.
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    // Delay the response to give 1 ping enough time to be sent and replied to.
+    server.enqueue(new MockResponse()
+        .setBodyDelay(750, TimeUnit.MILLISECONDS)
+        .setBody(""ABC""));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url(""/""))
+        .build());
+    Response response = call.execute();
+    assertEquals(""ABC"", response.body().string());
+
+    assertEquals(Protocol.HTTP_2, response.protocol());
+
+    // Confirm a single ping was sent and received, and its reply was sent and received.
+    List<String> logs = http2Handler.takeAll();
+    assertEquals(1, countFrames(logs, ""FINE: >> 0x00000000     8 PING          ""));
+    assertEquals(1, countFrames(logs, ""FINE: << 0x00000000     8 PING          ""));
+    assertEquals(1, countFrames(logs, ""FINE: >> 0x00000000     8 PING          ACK""));
+    assertEquals(1, countFrames(logs, ""FINE: << 0x00000000     8 PING          ACK""));
+  }
+
   private String firstFrame(List<String> logs, String type) {
-    for (String l: logs) {
-      if (l.contains(type)) {
-        return l;
+    for (String log: logs) {
+      if (log.contains(type)) {
+        return log;
       }
     }
     return null;
   }
 
+  private int countFrames(List<String> logs, String message) {
+    int result = 0;
+    for (String log: logs) {
+      if (log.equals(message)) {
+        result++;
+      }
+    }
+    return result;
+  }
+
   /**
    * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
    * confirm that the third concurrent request prepared a new connection.
@@ -568,14 +568,15 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
     }
 
     /**
-     * Sets the interval between web socket pings initiated by this client. Use this to
-     * automatically send web socket ping frames until either the web socket fails or it is closed.
-     * This keeps the connection alive and may detect connectivity failures.
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
      *
      * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens the connection is
-     * canceled and its listener is {@linkplain WebSocketListener#onFailure notified of the
-     * failure}.
+     * client will assume that connectivity has been lost. When this happens on a web socket the
+     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
      *
      * <p>The default value of 0 disables client-initiated pings.
      */
@@ -128,7 +128,8 @@ public static RealConnection testConnection(
   }
 
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled, Call call, EventListener eventListener) {
+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,
+      EventListener eventListener) {
     if (protocol != null) throw new IllegalStateException(""already connected"");
 
     RouteException routeException = null;
@@ -158,7 +159,7 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         } else {
           connectSocket(connectTimeout, readTimeout, call, eventListener);
         }
-        establishProtocol(connectionSpecSelector, call, eventListener);
+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
         break;
       } catch (IOException e) {
@@ -257,8 +258,8 @@ private void connectSocket(int connectTimeout, int readTimeout, Call call,
     }
   }
 
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Call call,
-      EventListener eventListener) throws IOException {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
+      int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
     if (route.address().sslSocketFactory() == null) {
       protocol = Protocol.HTTP_1_1;
       socket = rawSocket;
@@ -274,6 +275,7 @@ private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Ca
       http2Connection = new Http2Connection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
           .listener(this)
+          .pingIntervalMillis(pingIntervalMillis)
           .build();
       http2Connection.start();
     }
@@ -107,11 +107,12 @@ public HttpCodec newStream(
     int connectTimeout = chain.connectTimeoutMillis();
     int readTimeout = chain.readTimeoutMillis();
     int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
     boolean connectionRetryEnabled = client.retryOnConnectionFailure();
 
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
       HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
 
       synchronized (connectionPool) {
@@ -128,11 +129,11 @@ public HttpCodec newStream(
    * until a healthy connection is found.
    */
   private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException {
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
     while (true) {
       RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          connectionRetryEnabled);
+          pingIntervalMillis, connectionRetryEnabled);
 
       // If this is a brand new connection, we can skip the extensive health checks.
       synchronized (connectionPool) {
@@ -157,7 +158,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    * then the pool, finally building a new connection.
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException {
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
     boolean foundPooledConnection = false;
     RealConnection result = null;
     Route selectedRoute = null;
@@ -253,8 +254,8 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     }
 
     // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(
-        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
     routeDatabase().connected(result.route());
 
     Socket socket = null;
@@ -27,6 +27,8 @@
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -40,6 +42,7 @@
 import okio.ByteString;
 import okio.Okio;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.http2.ErrorCode.REFUSED_STREAM;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.platform.Platform.INFO;
@@ -67,7 +70,13 @@ public final class Http2Connection implements Closeable {
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  static final ExecutorService executor = new ThreadPoolExecutor(0,
+  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+
+  /**
+   * Shared executor to send notifications of incoming streams. This executor requires multiple
+   * threads because listeners are not required to return promptly.
+   */
+  private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory(""OkHttp Http2Connection"", true));
 
@@ -76,7 +85,7 @@ public final class Http2Connection implements Closeable {
 
   /**
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on {@link #executor}.
+   * on {@link #listenerExecutor}.
    */
   final Listener listener;
   final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
@@ -85,6 +94,9 @@ public final class Http2Connection implements Closeable {
   int nextStreamId;
   boolean shutdown;
 
+  /** Asynchronously writes frames to the outgoing socket. */
+  private final ScheduledExecutorService writerExecutor;
+
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
 
@@ -110,8 +122,6 @@ public final class Http2Connection implements Closeable {
   /** Settings we communicate to the peer. */
   Settings okHttpSettings = new Settings();
 
-  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
-
   /** Settings we receive from the peer. */
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
@@ -145,6 +155,13 @@ public final class Http2Connection implements Closeable {
 
     hostname = builder.hostname;
 
+    writerExecutor = new ScheduledThreadPoolExecutor(1,
+        Util.threadFactory(Util.format(""OkHttp %s Writer"", hostname), false));
+    if (builder.pingIntervalMillis != 0) {
+      writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0, null),
+          builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
+    }
+
     // Like newSingleThreadExecutor, except lazy creates the thread.
     pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(),
@@ -305,11 +322,12 @@ void addBytesToWriteWindow(long delta) {
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.execute(new NamedRunnable(""OkHttp %s stream %d"", hostname, streamId) {
+    writerExecutor.execute(new NamedRunnable(""OkHttp %s stream %d"", hostname, streamId) {
       @Override public void execute() {
         try {
           writeSynReset(streamId, errorCode);
-        } catch (IOException ignored) {
+        } catch (IOException e) {
+          failConnection();
         }
       }
     });
@@ -320,14 +338,16 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.execute(new NamedRunnable(""OkHttp Window Update %s stream %d"", hostname, streamId) {
-      @Override public void execute() {
-        try {
-          writer.windowUpdate(streamId, unacknowledgedBytesRead);
-        } catch (IOException ignored) {
-        }
-      }
-    });
+    writerExecutor.execute(
+        new NamedRunnable(""OkHttp Window Update %s stream %d"", hostname, streamId) {
+          @Override public void execute() {
+            try {
+              writer.windowUpdate(streamId, unacknowledgedBytesRead);
+            } catch (IOException e) {
+              failConnection();
+            }
+          }
+        });
   }
 
   /**
@@ -350,17 +370,28 @@ public Ping ping() throws IOException {
     return ping;
   }
 
-  void writePingLater(
-      final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.execute(new NamedRunnable(""OkHttp %s ping %08x%08x"",
-        hostname, payload1, payload2) {
-      @Override public void execute() {
-        try {
-          writePing(reply, payload1, payload2, ping);
-        } catch (IOException ignored) {
-        }
+  final class PingRunnable extends NamedRunnable {
+    final boolean reply;
+    final int payload1;
+    final int payload2;
+    final Ping ping;
+
+    PingRunnable(boolean reply, int payload1, int payload2, Ping ping) {
+      super(""OkHttp %s ping %08x%08x"", hostname, payload1, payload2);
+      this.reply = reply;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
+      this.ping = ping;
+    }
+
+    @Override public void execute() {
+      try {
+        // TODO(jwilson): fail the connection if replies are missing (and this is not a reply).
+        writePing(reply, payload1, payload2, ping);
+      } catch (IOException e) {
+        failConnection();
       }
-    });
+    }
   }
 
   void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
@@ -463,6 +494,13 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     if (thrown != null) throw thrown;
   }
 
+  private void failConnection() {
+    try {
+      close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR);
+    } catch (IOException ignored) {
+    }
+  }
+
   /**
    * Sends any initial frames and starts reading frames from the remote peer. This should be called
    * after {@link Builder#build} for all new connections.
@@ -512,6 +550,7 @@ public static class Builder {
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     PushObserver pushObserver = PushObserver.CANCEL;
     boolean client;
+    int pingIntervalMillis;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -545,6 +584,11 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
+    public Builder pingIntervalMillis(int pingIntervalMillis) {
+      this.pingIntervalMillis = pingIntervalMillis;
+      return this;
+    }
+
     public Http2Connection build() {
       return new Http2Connection(this);
     }
@@ -626,7 +670,7 @@ class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
               false, inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.execute(new NamedRunnable(""OkHttp %s stream %d"", hostname, streamId) {
+          listenerExecutor.execute(new NamedRunnable(""OkHttp %s stream %d"", hostname, streamId) {
             @Override public void execute() {
               try {
                 listener.onStream(newStream);
@@ -678,7 +722,7 @@ class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
             streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
           }
         }
-        executor.execute(new NamedRunnable(""OkHttp %s settings"", hostname) {
+        listenerExecutor.execute(new NamedRunnable(""OkHttp %s settings"", hostname) {
           @Override public void execute() {
             listener.onSettings(Http2Connection.this);
           }
@@ -694,11 +738,12 @@ class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
     }
 
     private void applyAndAckSettings(final Settings peerSettings) {
-      executor.execute(new NamedRunnable(""OkHttp %s ACK Settings"", hostname) {
+      writerExecutor.execute(new NamedRunnable(""OkHttp %s ACK Settings"", hostname) {
         @Override public void execute() {
           try {
             writer.applyAndAckSettings(peerSettings);
-          } catch (IOException ignored) {
+          } catch (IOException e) {
+            failConnection();
           }
         }
       });
@@ -716,7 +761,7 @@ private void applyAndAckSettings(final Settings peerSettings) {
         }
       } else {
         // Send a reply to a client ping if this is a server and vice versa.
-        writePingLater(true, payload1, payload2, null);
+        writerExecutor.execute(new PingRunnable(true, payload1, payload2, null));
       }
     }
 
"
https://github.com/spring-projects/spring-boot/commit/26345d39003514348ca0be2f9c350c92b5cf3ef7,Polish docs  <enter> This commit replaces tabs to spaces in a yaml example for configuring endpoint web exposure include. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/26345d39003514348ca0be2f9c350c92b5cf3ef7,"@@ -349,10 +349,10 @@ exclude) all endpoints, as shown in the following example:
 [source,yaml,indent=0]
 ----
 	management:
-		endpoints:
-			web:
-				exposure:
-					include: ""*""
+	  endpoints:
+	    web:
+	      exposure:
+	        include: ""*""
 ----
 ====
 
"
https://github.com/spring-projects/spring-boot/commit/599792097cfc690d2adf52a6c4d4f98c44a77162,Upgrade Spring WS to 2.2.1.RELEASE  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/599792097cfc690d2adf52a6c4d4f98c44a77162,"@@ -126,7 +126,7 @@
 		<spring-social-facebook.version>1.1.1.RELEASE</spring-social-facebook.version>
 		<spring-social-linkedin.version>1.0.1.RELEASE</spring-social-linkedin.version>
 		<spring-social-twitter.version>1.1.0.RELEASE</spring-social-twitter.version>
-		<spring-ws.version>2.2.0.RELEASE</spring-ws.version>
+		<spring-ws.version>2.2.1.RELEASE</spring-ws.version>
 		<sun-mail.version>${javax-mail.version}</sun-mail.version>
 		<thymeleaf.version>2.1.4.RELEASE</thymeleaf.version>
 		<thymeleaf-extras-springsecurity3.version>2.1.1.RELEASE</thymeleaf-extras-springsecurity3.version>
"
https://github.com/junit-team/junit4/commit/3d7de190844d92de87ca197cfd1fce74ae432f0f,Add test for handling InitializationError  <enter> The code was changed by commit  <otherCommit_link>  but unfortunately the test was not part of the commit. The test is based on Philip Graf's test in pull request  <pr_link> . <enter> Co-authored-by: Philip Graf <git@acanda.ch> ,https://api.github.com/repos/junit-team/junit4/commits/3d7de190844d92de87ca197cfd1fce74ae432f0f,"@@ -13,7 +13,7 @@
 import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunListener;
 
-class EventCollector extends RunListener {
+public class EventCollector extends RunListener {
     static Matcher<EventCollector> everyTestRunSuccessful() {
         return allOf(hasNoFailure(), hasNoAssumptionFailure());
     }
@@ -73,7 +73,7 @@ static Matcher<EventCollector> hasNoAssumptionFailure() {
         return hasNumberOfAssumptionFailures(0);
     }
 
-    static Matcher<EventCollector> hasSingleFailureWithMessage(String message) {
+    public static Matcher<EventCollector> hasSingleFailureWithMessage(String message) {
         return hasSingleFailureWithMessage(equalTo(message));
     }
 
@@ -2,8 +2,12 @@
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.rules.EventCollector.hasSingleFailureWithMessage;
 
 import org.junit.Test;
+import org.junit.rules.EventCollector;
+import org.junit.runners.model.InitializationError;
+import org.junit.runners.model.RunnerBuilder;
 
 public class RequestTest {
 
@@ -18,4 +22,29 @@ public void createsADescriptionWithANameForClasses() {
                 .getDescription();
         assertThat(description.toString(), is(""classes""));
     }
+
+    @Test
+    public void reportsInitializationErrorThrownWhileCreatingSuite() {
+        EventCollector collector = new EventCollector();
+        JUnitCore core = new JUnitCore();
+        core.addListener(collector);
+
+        core.run(new FailingComputer(), FooTest.class, BarTest.class);
+
+        assertThat(collector, hasSingleFailureWithMessage(""cannot create suite""));
+    }
+
+    private static class FailingComputer extends Computer {
+        @Override
+        public Runner getSuite(RunnerBuilder builder, Class<?>[] classes)
+                throws InitializationError {
+            throw new InitializationError(""cannot create suite"");
+        }
+    }
+
+    private static class FooTest {
+    }
+
+    private static class BarTest {
+    }
 }
"
https://github.com/square/retrofit/commit/fe6d0f9b2a68063a086fa9da80d04293fbe3becf,Introduce factory for converter concept.  <enter> This is still highly-inefficient in its internal use and there are no tests proving that we now fail earlier in configuring a service method. Both of those will come in follow up commits ,https://api.github.com/repos/square/retrofit/commits/fe6d0f9b2a68063a086fa9da80d04293fbe3becf,"@@ -49,7 +49,7 @@ interface Service {
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .callAdapterFactory(ObservableCallAdapterFactory.create())
         .build();
     service = retrofit.create(Service.class);
@@ -195,13 +195,17 @@ interface Service {
     }
   }
 
-  static class StringConverter implements Converter {
-    @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-      return body.string();
-    }
+  static class StringConverterFactory implements Converter.Factory {
+    @Override public Converter<?> get(Type type) {
+      return new Converter<String>() {
+        @Override public String fromBody(ResponseBody body) throws IOException {
+          return body.string();
+        }
 
-    @Override public RequestBody toBody(Object object, Type type) {
-      return RequestBody.create(MediaType.parse(""text/plain""), String.valueOf(object));
+        @Override public RequestBody toBody(String value) {
+          return RequestBody.create(MediaType.parse(""text/plain""), value);
+        }
+      };
     }
   }
 }
@@ -15,71 +15,48 @@
  */
 package retrofit;
 
-import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.reflect.Type;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
 import java.nio.charset.Charset;
+import okio.Buffer;
 
-/**
- * A {@link Converter} which uses GSON for serialization and deserialization of entities.
- */
-public class GsonConverter implements Converter {
-  private final Gson gson;
-  private final Charset charset;
-  private final MediaType mediaType;
-
-  /**
-   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter() {
-    this(new Gson());
-  }
+final class GsonConverter<T> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse(""application/json; charset=UTF-8"");
+  private static final Charset UTF_8 = Charset.forName(""UTF-8"");
 
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter(Gson gson) {
-    this(gson, Charset.forName(""UTF-8""));
-  }
+  private final TypeAdapter<T> typeAdapter;
 
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
-   */
-  public GsonConverter(Gson gson, Charset charset) {
-    if (gson == null) throw new NullPointerException(""gson == null"");
-    if (charset == null) throw new NullPointerException(""charset == null"");
-    this.gson = gson;
-    this.charset = charset;
-    this.mediaType = MediaType.parse(""application/json; charset="" + charset.name());
+  GsonConverter(TypeAdapter<T> typeAdapter) {
+    this.typeAdapter = typeAdapter;
   }
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    Charset charset = this.charset;
-    if (body.contentType() != null) {
-      charset = body.contentType().charset(charset);
-    }
-
-    InputStream is = body.byteStream();
+  @Override public T fromBody(ResponseBody body) throws IOException {
+    Reader in = body.charStream();
     try {
-      return gson.fromJson(new InputStreamReader(is, charset), type);
+      return typeAdapter.fromJson(in);
     } finally {
       try {
-        is.close();
+        in.close();
       } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
-    String json = gson.toJson(object, type);
-    return RequestBody.create(mediaType, json);
+  @Override public RequestBody toBody(T value) {
+    Buffer buffer = new Buffer();
+    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+    try {
+      typeAdapter.toJson(writer, value);
+      writer.flush();
+    } catch (IOException e) {
+      throw new AssertionError(e); // Writing to Buffer does no I/O.
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.reflect.TypeToken;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Gson for JSON. */
+public final class GsonConverterFactory implements Converter.Factory {
+  /**
+   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create() {
+    return create(new Gson());
+  }
+
+  /**
+   * Create an instance using {@code gson} for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create(Gson gson) {
+    return new GsonConverterFactory(gson);
+  }
+
+  private final Gson gson;
+
+  private GsonConverterFactory(Gson gson) {
+    if (gson == null) throw new NullPointerException(""gson == null"");
+    this.gson = gson;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+    return new GsonConverter<>(adapter);
+  }
+}
@@ -33,7 +33,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class GsonConverterTest {
+public final class GsonConverterFactoryTest {
   interface AnInterface {
     String getName();
   }
@@ -87,10 +87,9 @@ interface Service {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
         .create();
-    Converter converter = new GsonConverter(gson);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(GsonConverterFactory.create(gson))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -1,39 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit;
 
 import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.Type;
 
-/**
- * A {@link Converter} which uses Jackson for reading and writing entities.
- *
- * @author Kai Waldron (kaiwaldron@gmail.com)
- */
-public class JacksonConverter implements Converter {
+final class JacksonConverter<T> implements Converter<T> {
   private static final MediaType MEDIA_TYPE = MediaType.parse(""application/json; charset=UTF-8"");
 
-  private final ObjectMapper objectMapper;
+  private final ObjectWriter writer;
+  private final ObjectReader reader;
 
-  public JacksonConverter() {
-    this(new ObjectMapper());
+  JacksonConverter(ObjectWriter writer, ObjectReader reader) {
+    this.writer = writer;
+    this.reader = reader;
   }
 
-  public JacksonConverter(ObjectMapper objectMapper) {
-    if (objectMapper == null) throw new NullPointerException(""objectMapper == null"");
-    this.objectMapper = objectMapper;
-  }
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+  @Override public T fromBody(ResponseBody body) throws IOException {
     InputStream is = body.byteStream();
     try {
-      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      return objectMapper.readValue(is, javaType);
+      return reader.readValue(is);
     } finally {
       try {
         is.close();
@@ -42,11 +48,10 @@ public JacksonConverter(ObjectMapper objectMapper) {
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
+  @Override public RequestBody toBody(T value) {
     try {
-      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      String json = objectMapper.writerWithType(javaType).writeValueAsString(object);
-      return RequestBody.create(MEDIA_TYPE, json);
+      byte[] bytes = writer.writeValueAsBytes(value);
+      return RequestBody.create(MEDIA_TYPE, bytes);
     } catch (JsonProcessingException e) {
       throw new RuntimeException(e);
     }
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Jackson. */
+public final class JacksonConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
+  public static JacksonConverterFactory create() {
+    return create(new ObjectMapper());
+  }
+
+  /** Create an instance using {@code mapper} for conversion. */
+  public static JacksonConverterFactory create(ObjectMapper mapper) {
+    return new JacksonConverterFactory(mapper);
+  }
+
+  private final ObjectMapper mapper;
+
+  private JacksonConverterFactory(ObjectMapper mapper) {
+    if (mapper == null) throw new NullPointerException(""mapper == null"");
+    this.mapper = mapper;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    JavaType javaType = mapper.getTypeFactory().constructType(type);
+    ObjectWriter writer = mapper.writerWithType(javaType);
+    ObjectReader reader = mapper.reader(javaType);
+    return new JacksonConverter<>(writer, reader);
+  }
+}
@@ -119,10 +119,9 @@ interface Service {
         .getDefaultVisibilityChecker()
         .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
 
-    Converter converter = new JacksonConverter(mapper);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(JacksonConverterFactory.create(mapper))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -15,36 +15,27 @@
  */
 package retrofit;
 
-import com.squareup.moshi.Moshi;
+import com.squareup.moshi.JsonAdapter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.lang.reflect.Type;
 import okio.Buffer;
 import okio.BufferedSource;
 
-/** A {@link Converter} which uses Moshi for serialization and deserialization of entities. */
-public final class MoshiConverter implements Converter {
-  private final Moshi moshi;
-  private final MediaType mediaType;
+final class MoshiConverter<T> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse(""application/json; charset=UTF-8"");
 
-  /** Create an instance using a default {@link Moshi} instance for conversion. */
-  public MoshiConverter() {
-    this(new Moshi.Builder().build());
-  }
+  private JsonAdapter<T> adapter;
 
-  /** Create an instance using the supplied {@link Moshi} object for conversion. */
-  public MoshiConverter(Moshi moshi) {
-    if (moshi == null) throw new NullPointerException(""moshi == null"");
-    this.moshi = moshi;
-    this.mediaType = MediaType.parse(""application/json; charset=UTF-8"");
+  MoshiConverter(JsonAdapter<T> adapter) {
+    this.adapter = adapter;
   }
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+  @Override public T fromBody(ResponseBody body) throws IOException {
     BufferedSource source = body.source();
     try {
-      return moshi.adapter(type).fromJson(source);
+      return adapter.fromJson(source);
     } finally {
       try {
         source.close();
@@ -53,13 +44,13 @@ public MoshiConverter(Moshi moshi) {
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
+  @Override public RequestBody toBody(T value) {
     Buffer buffer = new Buffer();
     try {
-      moshi.adapter(type).toJson(buffer, object);
+      adapter.toJson(buffer, value);
     } catch (IOException e) {
       throw new AssertionError(e);
     }
-    return RequestBody.create(mediaType, buffer.snapshot());
+    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
   }
 }
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Moshi for JSON. */
+public final class MoshiConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Moshi} instance for conversion. */
+  public static MoshiConverterFactory create() {
+    return create(new Moshi.Builder().build());
+  }
+
+  /** Create an instance using {@code moshi} for conversion. */
+  public static MoshiConverterFactory create(Moshi moshi) {
+    return new MoshiConverterFactory(moshi);
+  }
+
+  private final Moshi moshi;
+
+  private MoshiConverterFactory(Moshi moshi) {
+    if (moshi == null) throw new NullPointerException(""moshi == null"");
+    this.moshi = moshi;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    JsonAdapter<Object> adapter = moshi.adapter(type);
+    return new MoshiConverter<>(adapter);
+  }
+}
@@ -51,7 +51,6 @@ static class AnImplementation implements AnInterface {
 
   static class AnInterfaceAdapter {
     @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      System.out.println(""TO JSON: "" + anInterface);
       jsonWriter.beginObject();
       jsonWriter.name(""name"").value(anInterface.getName());
       jsonWriter.endObject();
@@ -87,10 +86,9 @@ interface Service {
     Moshi moshi = new Moshi.Builder()
         .add(new AnInterfaceAdapter())
         .build();
-    Converter converter = new MoshiConverter(moshi);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(MoshiConverterFactory.create(moshi))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -1,39 +1,44 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit;
 
-import com.google.protobuf.AbstractMessageLite;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
 
-/** A {@link Converter} that reads and writes protocol buffers. */
-public class ProtoConverter implements Converter {
+final class ProtoConverter<T extends MessageLite> implements Converter<T> {
   private static final MediaType MEDIA_TYPE = MediaType.parse(""application/x-protobuf"");
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException(""Expected a raw Class<?> but was "" + type);
-    }
-    Class<?> c = (Class<?>) type;
-    if (!AbstractMessageLite.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException(""Expected a protobuf message but was "" + c.getName());
-    }
+  private Parser<T> parser;
 
+  ProtoConverter(Parser<T> parser) {
+    this.parser = parser;
+  }
+
+  @Override public T fromBody(ResponseBody body) throws IOException {
     InputStream is = body.byteStream();
     try {
-      Method parseFrom = c.getMethod(""parseFrom"", InputStream.class);
-      return parseFrom.invoke(null, is);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException(c.getName() + "".parseFrom() failed"", e.getCause());
-    } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException(""Expected a protobuf message but was "" + c.getName());
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
+      return parser.parseFrom(is);
+    } catch (InvalidProtocolBufferException e) {
+      throw new RuntimeException(e);
     } finally {
       try {
         is.close();
@@ -42,13 +47,8 @@ public class ProtoConverter implements Converter {
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
-    if (!(object instanceof AbstractMessageLite)) {
-      throw new IllegalArgumentException(
-          ""Expected a protobuf message but was "" + (object != null ? object.getClass().getName()
-              : ""null""));
-    }
-    byte[] bytes = ((AbstractMessageLite) object).toByteArray();
+  @Override public RequestBody toBody(T value) {
+    byte[] bytes = value.toByteArray();
     return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Protocol Buffers. */
+public final class ProtoConverterFactory implements Converter.Factory {
+  public static ProtoConverterFactory create() {
+    return new ProtoConverterFactory();
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class<?>)) {
+      throw new IllegalArgumentException(""Expected a raw Class<?> but was "" + type);
+    }
+    Class<?> c = (Class<?>) type;
+    if (!MessageLite.class.isAssignableFrom(c)) {
+      throw new IllegalArgumentException(""Expected a protobuf message but was "" + c.getName());
+    }
+
+    Parser<MessageLite> parser;
+    try {
+      Field field = c.getDeclaredField(""PARSER"");
+      //noinspection unchecked
+      parser = (Parser<MessageLite>) field.get(null);
+    } catch (NoSuchFieldException | IllegalAccessException e) {
+      throw new IllegalArgumentException(
+          ""Expected a protobuf message but "" + c.getName() + "" had no PARSER field."");
+    }
+
+    return new ProtoConverter<>(parser);
+  }
+}
@@ -49,7 +49,7 @@ interface Service {
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new ProtoConverter())
+        .converterFactory(ProtoConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -21,49 +21,30 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStreamWriter;
-import java.lang.reflect.Type;
 import okio.Buffer;
 import org.simpleframework.xml.Serializer;
-import org.simpleframework.xml.core.Persister;
 
-/**
- * A {@link Converter} which uses SimpleXML for reading and writing entities.
- *
- * @author Fabien Ric (fabien.ric@gmail.com)
- */
-public class SimpleXmlConverter implements Converter {
-  private static final boolean DEFAULT_STRICT = true;
+final class SimpleXmlConverter<T> implements Converter<T> {
   private static final String CHARSET = ""UTF-8"";
   private static final MediaType MEDIA_TYPE =
       MediaType.parse(""application/xml; charset="" + CHARSET);
 
+  private final Class<T> cls;
   private final Serializer serializer;
-
   private final boolean strict;
 
-  public SimpleXmlConverter() {
-    this(DEFAULT_STRICT);
-  }
-
-  public SimpleXmlConverter(boolean strict) {
-    this(new Persister(), strict);
-  }
-
-  public SimpleXmlConverter(Serializer serializer) {
-    this(serializer, DEFAULT_STRICT);
-  }
-
-  public SimpleXmlConverter(Serializer serializer, boolean strict) {
+  SimpleXmlConverter(Class<T> cls, Serializer serializer, boolean strict) {
+    this.cls = cls;
     this.serializer = serializer;
     this.strict = strict;
   }
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+  @Override public T fromBody(ResponseBody body) throws IOException {
     InputStream is = body.byteStream();
     try {
-      Object read = serializer.read((Class<?>) type, is, strict);
+      T read = serializer.read(cls, is, strict);
       if (read == null) {
-        throw new IllegalStateException(""Could not deserialize body as "" + type);
+        throw new IllegalStateException(""Could not deserialize body as "" + cls);
       }
       return read;
     } catch (RuntimeException | IOException e) {
@@ -78,19 +59,15 @@ public SimpleXmlConverter(Serializer serializer, boolean strict) {
     }
   }
 
-  @Override public RequestBody toBody(Object source, Type type) {
+  @Override public RequestBody toBody(T value) {
     Buffer buffer = new Buffer();
     try {
       OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
-      serializer.write(source, osw);
+      serializer.write(value, osw);
       osw.flush();
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
-
-  public boolean isStrict() {
-    return strict;
-  }
 }
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.reflect.Type;
+import org.simpleframework.xml.Serializer;
+import org.simpleframework.xml.core.Persister;
+
+/** A {@linkplain Converter.Factory converter} which uses Simple Framework for XML. */
+public final class SimpleXmlConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Persister} instance for conversion. */
+  public static SimpleXmlConverterFactory create() {
+    return create(new Persister());
+  }
+
+  /** Create an instance using {@code serializer} for conversion. */
+  public static SimpleXmlConverterFactory create(Serializer serializer) {
+    return new SimpleXmlConverterFactory(serializer, true);
+  }
+
+  /** Create an instance using a default {@link Persister} instance for non-strict conversion. */
+  public static SimpleXmlConverterFactory createNonStrict() {
+    return createNonStrict(new Persister());
+  }
+
+  /** Create an instance using {@code serializer} for non-strict conversion. */
+  public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+    return new SimpleXmlConverterFactory(serializer, false);
+  }
+
+  private final Serializer serializer;
+  private final boolean strict;
+
+  private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
+    if (serializer == null) throw new NullPointerException(""serializer == null"");
+    this.serializer = serializer;
+    this.strict = strict;
+  }
+
+  public boolean isStrict() {
+    return strict;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class)) {
+      throw new IllegalArgumentException(""Expected a raw class but was "" + type);
+    }
+    Class<?> cls = (Class<?>) type;
+    return new SimpleXmlConverter<>(cls, serializer, strict);
+  }
+}
@@ -48,10 +48,9 @@ interface Service {
   @Before public void setUp() {
     Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
     Persister persister = new Persister(format);
-    Converter converter = new SimpleXmlConverter(persister);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(SimpleXmlConverterFactory.create(persister))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit;
 
 import com.squareup.okhttp.MediaType;
@@ -8,38 +22,22 @@
 import com.squareup.wire.Wire;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.Type;
 
-/** A {@link Converter} that reads and writes protocol buffers using Wire. */
-public class WireConverter implements Converter {
+final class WireConverter<T extends Message> implements Converter<T> {
   private static final MediaType MEDIA_TYPE = MediaType.parse(""application/x-protobuf"");
 
   private final Wire wire;
+  private final Class<T> cls;
 
-  /** Create a converter with a default {@link Wire} instance. */
-  public WireConverter() {
-    this(new Wire());
-  }
-
-  /** Create a converter using the supplied {@link Wire} instance. */
-  public WireConverter(Wire wire) {
-    if (wire == null) throw new NullPointerException(""wire == null"");
+  public WireConverter(Wire wire, Class<T> cls) {
     this.wire = wire;
+    this.cls = cls;
   }
 
-  @SuppressWarnings(""unchecked"") //
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException(""Expected a raw Class<?> but was "" + type);
-    }
-    Class<?> c = (Class<?>) type;
-    if (!Message.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException(""Expected a proto message but was "" + c.getName());
-    }
-
+  @Override public T fromBody(ResponseBody body) throws IOException {
     InputStream in = body.byteStream();
     try {
-      return wire.parseFrom(in, (Class<Message>) c);
+      return wire.parseFrom(in, cls);
     } finally {
       try {
         in.close();
@@ -48,13 +46,8 @@ public WireConverter(Wire wire) {
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
-    if (!(object instanceof Message)) {
-      throw new IllegalArgumentException(
-          ""Expected a proto message but was "" + (object != null ? object.getClass().getName()
-              : ""null""));
-    }
-    byte[] bytes = ((Message) object).toByteArray();
+  @Override public RequestBody toBody(T value) {
+    byte[] bytes = value.toByteArray();
     return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.Wire;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers. */
+public final class WireConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Wire} instance for conversion. */
+  public static WireConverterFactory create() {
+    return create(new Wire());
+  }
+
+  /** Create an instance using {@code wire} for conversion. */
+  public static WireConverterFactory create(Wire wire) {
+    return new WireConverterFactory(wire);
+  }
+
+  private final Wire wire;
+
+  /** Create a converter using the supplied {@link Wire} instance. */
+  private WireConverterFactory(Wire wire) {
+    if (wire == null) throw new NullPointerException(""wire == null"");
+    this.wire = wire;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class<?>)) {
+      throw new IllegalArgumentException(""Expected a raw Class<?> but was "" + type);
+    }
+    Class<?> c = (Class<?>) type;
+    if (!Message.class.isAssignableFrom(c)) {
+      throw new IllegalArgumentException(""Expected a proto message but was "" + c.getName());
+    }
+    //noinspection unchecked
+    return new WireConverter<>(wire, (Class<Message>) c);
+  }
+}
@@ -48,7 +48,7 @@ interface Service {
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new WireConverter())
+        .converterFactory(WireConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -20,24 +20,15 @@
 import java.io.IOException;
 import java.lang.reflect.Type;
 
-/**
- * Arbiter for converting objects to and from their representation in HTTP.
- */
-public interface Converter {
-  /**
-   * Convert an HTTP response body to a concrete object of the specified type.
-   *
-   * @param body HTTP response body.
-   * @param type Target object type.
-   * @return Instance of {@code type} which will be cast by the caller.
-   */
-  Object fromBody(ResponseBody body, Type type) throws IOException;
+/** Convert objects to and from their representation as HTTP bodies. */
+public interface Converter<T> {
+  /** Convert an HTTP response body to a concrete object of the specified type. */
+  T fromBody(ResponseBody body) throws IOException;
+
+  /** Convert an object to an appropriate representation for HTTP transport. */
+  RequestBody toBody(T value);
 
-  /**
-   * Convert an object to an appropriate representation for HTTP transport.
-   *
-   * @param object Object instance to convert.
-   * @return Representation of the specified object as bytes.
-   */
-  RequestBody toBody(Object object, Type type);
+  interface Factory {
+    Converter<?> get(Type type);
+  }
 }
@@ -61,7 +61,7 @@ enum BodyEncoding {
 
   final Method method;
   final CallAdapter.Factory adapterFactory;
-  final Converter converter;
+  final Converter.Factory converterFactory;
 
   // Method-level details
   CallAdapter<?> adapter;
@@ -80,10 +80,11 @@ enum BodyEncoding {
   // Parameter-level details
   Annotation[] requestParamAnnotations;
 
-  MethodInfo(Method method, CallAdapter.Factory adapterFactory, Converter converter) {
+  MethodInfo(Method method, CallAdapter.Factory adapterFactory,
+      Converter.Factory converterFactory) {
     this.method = method;
     this.adapterFactory = adapterFactory;
-    this.converter = converter;
+    this.converterFactory = converterFactory;
     parseResponseType();
     parseMethodAnnotations();
     parseParameters();
@@ -229,7 +230,7 @@ private void parseResponseType() {
           ""Registered call adapter factory was unable to handle return type "" + returnType);
     }
     Type responseType = adapter.responseType();
-    if (converter == null && responseType != ResponseBody.class) {
+    if (converterFactory == null && responseType != ResponseBody.class) {
       throw methodError(""Method response type is ""
           + responseType
           + "" but no converter registered. ""
@@ -291,7 +292,7 @@ private void parseParameters() {
             if (bodyEncoding != BodyEncoding.MULTIPART) {
               throw parameterError(i, ""@Part parameters can only be used with multipart encoding."");
             }
-            if (converter == null && methodParameterType != BodyEncoding.class) {
+            if (converterFactory == null && methodParameterType != BodyEncoding.class) {
               throw parameterError(i, ""@Part parameter is ""
                   + methodParameterType
                   + "" but no converter registered. ""
@@ -317,7 +318,7 @@ private void parseParameters() {
             if (gotBody) {
               throw methodError(""Multiple @Body method annotations found."");
             }
-            if (converter == null && methodParameterType != RequestBody.class) {
+            if (converterFactory == null && methodParameterType != RequestBody.class) {
               throw parameterError(i, ""@Body parameter is ""
                   + methodParameterType
                   + "" but no converter registered. ""
@@ -26,26 +26,26 @@
 
 final class OkHttpCall<T> implements Call<T> {
   private final Endpoint endpoint;
-  private final Converter converter;
+  private final Converter.Factory converterFactory;
   private final OkHttpClient client;
   private final MethodInfo methodInfo;
   private final Object[] args;
 
   private volatile com.squareup.okhttp.Call rawCall;
   private boolean executed; // Guarded by this.
 
-  OkHttpCall(Endpoint endpoint, Converter converter, OkHttpClient client, MethodInfo methodInfo,
-      Object[] args) {
+  OkHttpCall(Endpoint endpoint, Converter.Factory converterFactory, OkHttpClient client,
+      MethodInfo methodInfo, Object[] args) {
     this.endpoint = endpoint;
-    this.converter = converter;
+    this.converterFactory = converterFactory;
     this.client = client;
     this.methodInfo = methodInfo;
     this.args = args;
   }
 
   @SuppressWarnings(""CloneDoesntCallSuperClone"") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(endpoint, converter, client, methodInfo, args);
+    return new OkHttpCall<>(endpoint, converterFactory, client, methodInfo, args);
   }
 
   public void enqueue(final Callback<T> callback) {
@@ -111,7 +111,7 @@ public Response<T> execute() throws IOException {
 
   private com.squareup.okhttp.Call createRawCall() {
     HttpUrl url = endpoint.url();
-    RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo, converter);
+    RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo, converterFactory);
     requestBuilder.setArguments(args);
     Request request = requestBuilder.build();
 
@@ -162,7 +162,7 @@ private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) thro
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
       //noinspection unchecked
-      T body = (T) converter.fromBody(catchingBody, responseType);
+      T body = (T) converterFactory.get(responseType).fromBody(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
@@ -44,7 +44,7 @@ final class RequestBuilder {
   private static final Headers NO_HEADERS = Headers.of();
   private static final byte[] NO_BODY = new byte[0];
 
-  private final Converter converter;
+  private final Converter.Factory converterFactory;
   private final Annotation[] paramAnnotations;
   private final String requestMethod;
   private final boolean requestHasBody;
@@ -59,8 +59,8 @@ final class RequestBuilder {
   private Headers.Builder headers;
   private String contentTypeHeader;
 
-  RequestBuilder(HttpUrl url, MethodInfo methodInfo, Converter converter) {
-    this.converter = converter;
+  RequestBuilder(HttpUrl url, MethodInfo methodInfo, Converter.Factory converterFactory) {
+    this.converterFactory = converterFactory;
 
     paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
@@ -286,7 +286,10 @@ void setArguments(Object[] args) {
             multipartBuilder.addPart(headers,
                 RequestBody.create(MediaType.parse(""text/plain""), (String) value));
           } else {
-            multipartBuilder.addPart(headers, converter.toBody(value, value.getClass()));
+            //noinspection unchecked
+            Converter<Object> converter =
+                (Converter<Object>) converterFactory.get(value.getClass());
+            multipartBuilder.addPart(headers, converter.toBody(value));
           }
         }
       } else if (annotationType == PartMap.class) {
@@ -310,8 +313,10 @@ void setArguments(Object[] args) {
                 multipartBuilder.addPart(headers,
                     RequestBody.create(MediaType.parse(""text/plain""), (String) entryValue));
               } else {
-                multipartBuilder.addPart(headers,
-                    converter.toBody(entryValue, entryValue.getClass()));
+                //noinspection unchecked
+                Converter<Object> converter =
+                    (Converter<Object>) converterFactory.get(entryValue.getClass());
+                multipartBuilder.addPart(headers, converter.toBody(entryValue));
               }
             }
           }
@@ -324,7 +329,9 @@ void setArguments(Object[] args) {
             || (requestType == Object.class && value instanceof RequestBody)) {
           body = (RequestBody) value;
         } else {
-          body = converter.toBody(value, requestType);
+          //noinspection unchecked
+          Converter<Object> converter = (Converter<Object>) converterFactory.get(requestType);
+          body = converter.toBody(value);
         }
       } else {
         throw new IllegalArgumentException(
@@ -22,7 +22,6 @@
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
-import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import retrofit.http.HTTP;
@@ -49,7 +48,7 @@
  * <p>
  * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
  * will be converted to request representation by a call to
- * {@link Converter#toBody(Object, java.lang.reflect.Type) toBody}
+ * {@link Converter#toBody(Object) toBody}
  * on the supplied {@link Converter} for this instance. A {@link RequestBody} can also be used
  * which will not use the {@code Converter}.
  * <p>
@@ -68,7 +67,7 @@
  * <p>
  * By default, methods return a {@link Call} which represents the HTTP request. The generic
  * parameter of the call is the response body type and will be converted by a call to
- * {@link Converter#fromBody(ResponseBody, Type) fromBody} on the supplied {@link Converter} for
+ * {@link Converter#fromBody(ResponseBody) fromBody} on the supplied {@link Converter} for
  * this instance. {@link ResponseBody} can also be used which will not use the {@code Converter}.
  * <p>
  * For example:
@@ -89,14 +88,14 @@ public final class Retrofit {
   private final Map<Method, MethodInfo> methodInfoCache = new LinkedHashMap<>();
   private final OkHttpClient client;
   private final Endpoint endpoint;
-  private final Converter converter;
+  private final Converter.Factory converterFactory;
   private final CallAdapter.Factory adapterFactory;
 
-  private Retrofit(OkHttpClient client, Endpoint endpoint, Converter converter,
+  private Retrofit(OkHttpClient client, Endpoint endpoint, Converter.Factory converterFactory,
       CallAdapter.Factory adapterFactory) {
     this.client = client;
     this.endpoint = endpoint;
-    this.converter = converter;
+    this.converterFactory = converterFactory;
     this.adapterFactory = adapterFactory;
   }
 
@@ -121,7 +120,7 @@ public <T> T create(Class<T> service) {
   // Package-private avoids synthetic accessor method from InvocationHandler. Also for testing.
   Object invokeMethod(Method method, Object... args) {
     MethodInfo methodInfo = loadMethodInfo(method);
-    Call call = new OkHttpCall(endpoint, converter, client, methodInfo, args);
+    Call call = new OkHttpCall(endpoint, converterFactory, client, methodInfo, args);
     return methodInfo.adapter.adapt(call);
   }
 
@@ -131,7 +130,7 @@ private MethodInfo loadMethodInfo(Method method) {
       synchronized (methodInfoCache) {
         methodInfo = methodInfoCache.get(method);
         if (methodInfo == null) {
-          methodInfo = new MethodInfo(method, adapterFactory, converter);
+          methodInfo = new MethodInfo(method, adapterFactory, converterFactory);
           methodInfoCache.put(method, methodInfo);
         }
       }
@@ -152,8 +151,8 @@ public Endpoint endpoint() {
    * <p>
    * May be null.
    */
-  public Converter converter() {
-    return converter;
+  public Converter.Factory converterFactory() {
+    return converterFactory;
   }
 
   public CallAdapter.Factory callAdapterFactory() {
@@ -169,7 +168,7 @@ public CallAdapter.Factory callAdapterFactory() {
   public static class Builder {
     private OkHttpClient client;
     private Endpoint endpoint;
-    private Converter converter;
+    private Converter.Factory converterFactory;
     private CallAdapter.Factory adapterFactory;
 
     /** The HTTP client used for requests. */
@@ -205,8 +204,8 @@ public Builder endpoint(Endpoint endpoint) {
     }
 
     /** The converter used for serialization and deserialization of objects. */
-    public Builder converter(Converter converter) {
-      this.converter = checkNotNull(converter, ""converter == null"");
+    public Builder converterFactory(Converter.Factory converterFactory) {
+      this.converterFactory = checkNotNull(converterFactory, ""converterFactory == null"");
       return this;
     }
 
@@ -232,7 +231,7 @@ public Retrofit build() {
         adapterFactory = Platform.get().defaultCallAdapterFactory();
       }
 
-      return new Retrofit(client, endpoint, converter, adapterFactory);
+      return new Retrofit(client, endpoint, converterFactory, adapterFactory);
     }
   }
 }
@@ -58,7 +58,7 @@ interface Service {
   @Test public void http200Sync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -72,7 +72,7 @@ interface Service {
   @Test public void http200Async() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -100,7 +100,7 @@ interface Service {
   @Test public void http404Sync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -115,7 +115,7 @@ interface Service {
   @Test public void http404Async() throws InterruptedException, IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -144,7 +144,7 @@ interface Service {
   @Test public void transportProblemSync() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -161,7 +161,7 @@ interface Service {
   @Test public void transportProblemAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -188,9 +188,13 @@ interface Service {
   @Test public void conversionProblemOutgoingSync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter() {
-          @Override public RequestBody toBody(Object object, Type type) {
-            throw new UnsupportedOperationException(""I am broken!"");
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public RequestBody toBody(String value) {
+                throw new UnsupportedOperationException(""I am broken!"");
+              }
+            };
           }
         })
         .build();
@@ -208,9 +212,13 @@ interface Service {
   @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter() {
-          @Override public RequestBody toBody(Object object, Type type) {
-            throw new UnsupportedOperationException(""I am broken!"");
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public RequestBody toBody(String value) {
+                throw new UnsupportedOperationException(""I am broken!"");
+              }
+            };
           }
         })
         .build();
@@ -237,9 +245,13 @@ interface Service {
   @Test public void conversionProblemIncomingSync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter() {
-          @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-            throw new UnsupportedOperationException(""I am broken!"");
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                throw new UnsupportedOperationException(""I am broken!"");
+              }
+            };
           }
         })
         .build();
@@ -276,14 +288,18 @@ interface Service {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .client(client)
-        .converter(new StringConverter() {
-          @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-            try {
-              return super.fromBody(body, type);
-            } catch (IOException e) {
-              // Some serialization libraries mask transport problems in runtime exceptions. Bad!
-              throw new RuntimeException(""wrapper"", e);
-            }
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                try {
+                  return super.fromBody(body);
+                } catch (IOException e) {
+                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
+                  throw new RuntimeException(""wrapper"", e);
+                }
+              }
+            };
           }
         })
         .build();
@@ -303,9 +319,13 @@ interface Service {
   @Test public void conversionProblemIncomingAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter() {
-          @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-            throw new UnsupportedOperationException(""I am broken!"");
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                throw new UnsupportedOperationException(""I am broken!"");
+              }
+            };
           }
         })
         .build();
@@ -332,10 +352,14 @@ interface Service {
   }
 
   @Test public void http204SkipsConverter() throws IOException {
-    Converter converter = spy(new StringConverter());
+    final Converter converter = spy(new StringConverterFactory.StringConverter());
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter get(Type type) {
+            return converter;
+          }
+        })
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -348,10 +372,14 @@ interface Service {
   }
 
   @Test public void http205SkipsConverter() throws IOException {
-    Converter converter = spy(new StringConverter());
+    final Converter converter = spy(new StringConverterFactory.StringConverter());
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter get(Type type) {
+            return converter;
+          }
+        })
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -366,7 +394,7 @@ interface Service {
   @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -379,7 +407,7 @@ interface Service {
   @Test public void responseBody() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -392,7 +420,7 @@ interface Service {
   @Test public void responseBodyBuffers() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -413,7 +441,7 @@ interface Service {
   @Test public void responseBodyStreams() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -434,7 +462,7 @@ interface Service {
   @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -456,7 +484,7 @@ interface Service {
   @Test public void emptyResponse() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -15,9 +15,9 @@
 
 @SuppressWarnings(""unused"") // Lots of unused parameters for example code.
 public final class MethodInfoTest {
-  private static CallAdapter.Factory FACTORY =
+  private static CallAdapter.Factory CALL_ADAPTER_FACTORY =
       new DefaultCallAdapterFactory(Executors.newSingleThreadExecutor());
-  private static Converter CONVERTER = new StringConverter();
+  private static Converter.Factory CONVERTER_FACTORY = new StringConverterFactory();
 
   @Test public void pathParameterParsing() throws Exception {
     expectParams(""/"");
@@ -57,7 +57,7 @@ class Example {
     }
 
     Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
     assertThat(methodInfo.requestType).isEqualTo(Dummy.class);
   }
 
@@ -69,7 +69,7 @@ class Example {
     }
 
     Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
     Type expected = new TypeToken<List<Dummy>>() {}.getType();
     assertThat(methodInfo.requestType).isEqualTo(expected);
   }
@@ -82,7 +82,7 @@ class Example {
     }
 
     Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
     Type expected = new TypeToken<List<? super String>>() {}.getType();
     assertThat(methodInfo.requestType).isEqualTo(expected);
   }
@@ -1418,13 +1418,14 @@ private static void assertBody(RequestBody body, String expected) {
 
   private Request buildRequest(Class<?> cls, Object... args) {
     HttpUrl url = HttpUrl.parse(""http://example.com/"");
-    Converter converter = new StringConverter();
-    CallAdapter.Factory factory = new DefaultCallAdapterFactory(new Utils.SynchronousExecutor());
+    Converter.Factory converterFactory = new StringConverterFactory();
+    CallAdapter.Factory callAdapterFactory =
+        new DefaultCallAdapterFactory(new Utils.SynchronousExecutor());
 
     Method method = TestingUtils.onlyMethod(cls);
-    MethodInfo methodInfo = new MethodInfo(method, factory, converter);
+    MethodInfo methodInfo = new MethodInfo(method, callAdapterFactory, converterFactory);
 
-    RequestBuilder builder = new RequestBuilder(url, methodInfo, converter);
+    RequestBuilder builder = new RequestBuilder(url, methodInfo, converterFactory);
     builder.setArguments(args);
     return builder.build();
   }
@@ -135,7 +135,7 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
 
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .callAdapterFactory(new GreetingCallAdapterFactory())
         .build();
     StringService example = retrofit.create(StringService.class);
@@ -218,7 +218,7 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
   @Test public void unresolvableTypeThrows() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Unresolvable example = retrofit.create(Unresolvable.class);
 
@@ -352,27 +352,27 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
 
   @Test public void converterNullThrows() {
     try {
-      new Retrofit.Builder().converter(null);
+      new Retrofit.Builder().converterFactory(null);
       fail();
     } catch (NullPointerException e) {
-      assertThat(e).hasMessage(""converter == null"");
+      assertThat(e).hasMessage(""converterFactory == null"");
     }
   }
 
   @Test public void converterNoDefault() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(""http://example.com/"")
         .build();
-    assertThat(retrofit.converter()).isNull();
+    assertThat(retrofit.converterFactory()).isNull();
   }
 
-  @Test public void converterPropagated() {
-    Converter converter = mock(Converter.class);
+  @Test public void converterFactoryPropagated() {
+    Converter.Factory factory = mock(Converter.Factory.class);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(""http://example.com/"")
-        .converter(converter)
+        .converterFactory(factory)
         .build();
-    assertThat(retrofit.converter()).isSameAs(converter);
+    assertThat(retrofit.converterFactory()).isSameAs(factory);
   }
 
   @Test public void callAdapterFactoryNullThrows() {
@@ -1,17 +0,0 @@
-package retrofit;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.Type;
-
-class StringConverter implements Converter {
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    return body.string();
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    return RequestBody.create(MediaType.parse(""text/plain""), String.valueOf(object));
-  }
-}
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.reflect.Type;
+
+class StringConverterFactory implements Converter.Factory {
+  private static final MediaType MEDIA_TYPE = MediaType.parse(""text/plain"");
+
+  @Override public Converter get(Type type) {
+    if (type != String.class) {
+      throw new IllegalArgumentException(""Type was not "" + String.class);
+    }
+    return new StringConverter();
+  }
+
+  static class StringConverter implements Converter<String> {
+    @Override public String fromBody(ResponseBody body) throws IOException {
+      return body.string();
+    }
+
+    @Override public RequestBody toBody(String value) {
+      return RequestBody.create(MEDIA_TYPE, value);
+    }
+  }
+}
"
https://github.com/square/retrofit/commit/30fabb8e9a87b644d0b78d0962efe6aef027f04b,Revert version to 0.6 to match previous ant/ivy build.  <enter> Add a description too... ,https://api.github.com/repos/square/retrofit/commits/30fabb8e9a87b644d0b78d0962efe6aef027f04b,"@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -14,17 +14,16 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>1.0.0-SNAPSHOT</version>
+    <version>0.6.0-SNAPSHOT</version>
     <packaging>pom</packaging>
 
     <name>Retrofit</name>
-    <description></description>
+    <description>Reusable Java and Android code from Square, Inc. for simplified I/O, HTTP, and more.</description>
     <url>http://github.com/square/retrofit/</url>
 
     <modules>
@@ -158,4 +157,4 @@
             </plugin>
         </plugins>
     </build>
-</project>
\ No newline at end of file
+</project>
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
"
https://github.com/square/okhttp/commit/489c92400f579bace0950c910de2dca03959785e,Revise the upgrading guide for OkHttp 4.x.  <enter> Also change the old OkHttp 3.x Javadoc to set the new docs as canonical.  https://publicobject.com/2017/02/14/canonical-urls-for-javadocs/ ,https://api.github.com/repos/square/okhttp/commits/489c92400f579bace0950c910de2dca03959785e,
https://github.com/spring-projects/spring-boot/commit/4f747d426e0f1b45ec341c021f699c7f25a8c3c2,Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20 ,https://api.github.com/repos/spring-projects/spring-boot/commits/4f747d426e0f1b45ec341c021f699c7f25a8c3c2,"@@ -213,7 +213,7 @@
 		<maven-shade-plugin.version>2.4.3</maven-shade-plugin.version>
 		<maven-site-plugin.version>3.5.1</maven-site-plugin.version>
 		<maven-source-plugin.version>3.0.1</maven-source-plugin.version>
-		<maven-surefire-plugin.version>2.19.2</maven-surefire-plugin.version>
+		<maven-surefire-plugin.version>2.19.1</maven-surefire-plugin.version>
 		<maven-war-plugin.version>3.1.0</maven-war-plugin.version>
 		<versions-maven-plugin.version>2.3</versions-maven-plugin.version>
 	</properties>
"
https://github.com/square/okhttp/commit/4b204037e6415a486df4eadb0c659c666e6b9aba,Remove overlapping package-info.java ,https://api.github.com/repos/square/okhttp/commits/4b204037e6415a486df4eadb0c659c666e6b9aba,"@@ -1,3 +0,0 @@
-/** Support for JDK provider APIs. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3;
"
https://github.com/square/retrofit/commit/3b5a795892ac079320f6e4fb0d715a6d1a619122,Adding a human-readable name to the Server interface ,https://api.github.com/repos/square/retrofit/commits/3b5a795892ac079320f6e4fb0d715a6d1a619122,"@@ -35,6 +35,10 @@ public String webUrl() {
     return webUrl;
   }
 
+  public String getType() {
+    return ""production"";
+  }
+
   /**
    * Returns true if we should ignore SSL warnings. Returns false by default.
    * Ignored for development servers.
"
https://github.com/square/retrofit/commit/f939189f3b825beb66a499686b9f6ca0f3a70cc1,Expose static factory for Invocation  <enter> Also rework the internals of how an Invocation gets instantiated and set as a tag on the Request. This will make a future change easier to land. ,https://api.github.com/repos/square/retrofit/commits/f939189f3b825beb66a499686b9f6ca0f3a70cc1,"@@ -50,15 +50,19 @@
  * types for parameters!
  */
 public final class Invocation {
-  private final Method method;
-  private final List<?> arguments;
-
-  public Invocation(Method method, List<?> arguments) {
+  public static Invocation of(Method method, List<?> arguments) {
     checkNotNull(method, ""method == null"");
     checkNotNull(arguments, ""arguments == null"");
+    return new Invocation(method, new ArrayList<>(arguments)); // Defensive copy.
+  }
+
+  private final Method method;
+  private final List<?> arguments;
 
+  /** Trusted constructor assumes ownership of {@code arguments}. */
+  Invocation(Method method, List<?> arguments) {
     this.method = method;
-    this.arguments = Collections.unmodifiableList(new ArrayList<>(arguments)); // Immutable copy.
+    this.arguments = Collections.unmodifiableList(arguments);
   }
 
   public Method method() {
@@ -46,14 +46,13 @@ final class RequestBuilder {
   private @Nullable FormBody.Builder formBuilder;
   private @Nullable RequestBody body;
 
-  RequestBuilder(Invocation invocation, String method, HttpUrl baseUrl,
+  RequestBuilder(String method, HttpUrl baseUrl,
       @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
       boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
-    this.requestBuilder = new Request.Builder()
-        .tag(Invocation.class, invocation);
+    this.requestBuilder = new Request.Builder();
     this.contentType = contentType;
     this.hasBody = hasBody;
 
@@ -187,7 +186,7 @@ void setBody(RequestBody body) {
     this.body = body;
   }
 
-  Request build() {
+  Request.Builder get() {
     HttpUrl url;
     HttpUrl.Builder urlBuilder = this.urlBuilder;
     if (urlBuilder != null) {
@@ -226,8 +225,7 @@ Request build() {
 
     return requestBuilder
         .url(url)
-        .method(method, body)
-        .build();
+        .method(method, body);
   }
 
   private static class ContentTypeOverridingRequestBody extends RequestBody {
@@ -21,8 +21,9 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URI;
-import java.util.Arrays;
+import java.util.ArrayList;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -98,15 +99,18 @@ okhttp3.Request create(Object[] args) throws IOException {
           + "") doesn't match expected count ("" + handlers.length + "")"");
     }
 
-    Invocation invocation = new Invocation(method, Arrays.asList(args));
-    RequestBuilder requestBuilder = new RequestBuilder(invocation, httpMethod, baseUrl, relativeUrl,
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
         headers, contentType, hasBody, isFormEncoded, isMultipart);
 
+    List<Object> argumentList = new ArrayList<>(argumentCount);
     for (int p = 0; p < argumentCount; p++) {
+      argumentList.add(args[p]);
       handlers[p].apply(requestBuilder, args[p]);
     }
 
-    return requestBuilder.build();
+    return requestBuilder.get()
+        .tag(Invocation.class, new Invocation(method, argumentList))
+        .build();
   }
 
   /**
@@ -58,7 +58,7 @@ Call<ResponseBody> postMethod(
 
   @Test public void nullMethod() {
     try {
-      new Invocation(null, Arrays.asList(""one"", ""two""));
+      Invocation.of(null, Arrays.asList(""one"", ""two""));
       fail();
     } catch (NullPointerException expected) {
       assertThat(expected).hasMessage(""method == null"");
@@ -67,7 +67,7 @@ Call<ResponseBody> postMethod(
 
   @Test public void nullArguments() {
     try {
-      new Invocation(Example.class.getDeclaredMethods()[0], null);
+      Invocation.of(Example.class.getDeclaredMethods()[0], null);
       fail();
     } catch (NullPointerException expected) {
       assertThat(expected).hasMessage(""arguments == null"");
@@ -76,7 +76,7 @@ Call<ResponseBody> postMethod(
 
   @Test public void argumentsAreImmutable() {
     List<String> mutableList = new ArrayList<>(Arrays.asList(""one"", ""two""));
-    Invocation invocation = new Invocation(Example.class.getDeclaredMethods()[0], mutableList);
+    Invocation invocation = Invocation.of(Example.class.getDeclaredMethods()[0], mutableList);
     mutableList.add(""three"");
     assertThat(invocation.arguments()).isEqualTo(Arrays.asList(""one"", ""two""));
     try {
"
https://github.com/junit-team/junit4/commit/5af049cac0c976c586d955607fa459aacb778d3c,Remove unnecessary comments,https://api.github.com/repos/junit-team/junit4/commits/5af049cac0c976c586d955607fa459aacb778d3c,"@@ -19,21 +19,5 @@ public Runner getRunner() {
 		// TODO: (Dec 10, 2007 9:41:13 PM) Should this class exist?
 
 		return new ErrorReportingRunner(fClass, fCause);
-//		List<Throwable> goofs= getCauses(fCause);
-//		CompositeRunner runner= new CompositeRunner(fClass.getName());
-//		for (int i= 0; i < goofs.size(); i++) {
-//			final Description description= Description.createTestDescription(fClass, ""initializationError"" + i);
-//			final Throwable throwable= goofs.get(i);
-//			runner.add(new ErrorReportingRunner(fClass, throwable));
-//		}
-//		return runner;
 	}
-	
-//	private List<Throwable> getCauses(Throwable cause) {
-//		if (cause instanceof InvocationTargetException)
-//			return getCauses(cause.getCause());
-//		if (cause instanceof InitializationError)
-//			return ((InitializationError) cause).getCauses();
-//		return Arrays.asList(cause);	
-//	}
 }
@@ -14,8 +14,6 @@ public class ErrorReportingRunner extends ParentRunner<Throwable> {
 	private final Class<?> fClass;
 
 	public ErrorReportingRunner(Class<?> type, Throwable cause) {
-		// TODO: (Dec 10, 2007 9:35:57 PM) Is this the only time calling super(null)?
-
 		super(null);
 		// TODO: (Dec 10, 2007 9:41:50 PM) remove fClass
 
@@ -1,6 +1,5 @@
 package org.junit.internal.runners;
 
-import java.util.ArrayList;
 import java.util.List;
 
 import org.junit.internal.runners.links.ExpectException;
@@ -29,9 +28,7 @@ public class JUnit4ClassRunner extends ParentRunner<FrameworkMethod> implements
 	public JUnit4ClassRunner(Class<?> klass) throws InitializationError {
 		super(klass);
 		fTestMethods= computeTestMethods();
-		List<Throwable> errors= new ArrayList<Throwable>();
-		collectInitializationErrors(errors);
-		assertValid(errors);
+		validate();
 	}
 	
 	//
@@ -42,6 +39,7 @@ protected List<FrameworkMethod> computeTestMethods() {
 		return getTestClass().getTestMethods();
 	}
 
+	@Override
 	protected void collectInitializationErrors(List<Throwable> errors) {
 		getTestClass().validateMethodsForDefaultRunner(errors);
 	}
@@ -23,7 +23,7 @@
 import org.junit.runner.notification.StoppedByUserException;
 
 public abstract class ParentRunner<T> extends Runner implements Filterable, Sortable {
-	protected final TestClass fTestClass;
+	private final TestClass fTestClass;
 	private List<T> fChildren = null;
 	private Filter fFilter = null;
 	private Sorter fSorter = null;
@@ -35,7 +35,7 @@ public ParentRunner(Class<?> testClass) {
 	//
 	// Must be overridden
 	//
-	
+
 	protected abstract List<T> getChildren();
 	
 	protected abstract Description describeChild(T child);
@@ -46,6 +46,16 @@ public ParentRunner(Class<?> testClass) {
 	// May be overridden
 	//
 	
+	protected void collectInitializationErrors(List<Throwable> errors) {
+	}
+
+	protected Statement classBlock(final RunNotifier notifier) {
+		Statement statement= runChildren(notifier);
+		statement= new RunBefores(statement, fTestClass, null);
+		statement= new RunAfters(statement, fTestClass, null);
+		return statement;
+	}
+	
 	protected Statement runChildren(final RunNotifier notifier) {
 		return new Statement() {
 			@Override
@@ -56,13 +66,6 @@ public void evaluate() {
 		};
 	}
 
-	protected Statement classBlock(final RunNotifier notifier) {
-		Statement statement= runChildren(notifier);
-		statement= new RunBefores(statement, fTestClass, null);
-		statement= new RunAfters(statement, fTestClass, null);
-		return statement;
-	}
-
 	protected Annotation[] classAnnotations() {
 		return fTestClass.getAnnotations();
 	}
@@ -79,15 +82,13 @@ protected final TestClass getTestClass() {
 		return fTestClass;
 	}
 
-	protected final void assertValid(List<Throwable> errors) throws InitializationError {
+	protected void validate() throws InitializationError {
+		List<Throwable> errors= new ArrayList<Throwable>();
+		collectInitializationErrors(errors);
 		if (!errors.isEmpty())
 			throw new InitializationError(errors);
 	}
-	
-	//
-	// Implementation
-	// 
-	
+
 	public void filter(Filter filter) throws NoTestsRemainException {
 		fFilter= filter;
 		
"
https://github.com/square/okhttp/commit/ea014716fd2a8712ee39888725f91bed43148cd3,"Remove CBC-mode ECDSA cipher suites  <enter> This removes the following cipher suites as supported-by-default:   TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA   TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA <enter> This tracks a similar change in Chromium 56:    https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls  <enter> OkHttp's updated cipher suites, plus comparisons to Android, Java, Chromium, Firefox, and Square's server-site configuration is here:    https://tinyurl.com/okhttp-cipher-suites  <enter>  Closes :  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/ea014716fd2a8712ee39888725f91bed43148cd3,"@@ -54,9 +54,7 @@ public final class ConnectionSpec {
       // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
       // continue to include them until better suites are commonly available. For example, none
       // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
"
https://github.com/apache/dubbo/commit/3747cc36fada387a52363fc7dfc97a4c6c2b2670,Remove useless config item in xsd ,https://api.github.com/repos/apache/dubbo/commits/3747cc36fada387a52363fc7dfc97a4c6c2b2670,"@@ -61,9 +61,6 @@ public abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {
     // group
     protected String group;
 
-    // enable dynamic tag
-    protected String enabledynamictag;
-
     public Boolean isCheck() {
         return check;
     }
@@ -313,12 +313,6 @@
                             <![CDATA[ Defines the service tag]]></xsd:documentation>
                     </xsd:annotation>
                 </xsd:attribute>
-                <xsd:attribute name=""enabledynamictag"" type=""xsd:boolean"" default=""false"">
-                    <xsd:annotation>
-                        <xsd:documentation>
-                            <![CDATA[ Defines the service tag]]></xsd:documentation>
-                    </xsd:annotation>
-                </xsd:attribute>
                 <xsd:anyAttribute namespace=""##other"" processContents=""lax""/>
             </xsd:extension>
         </xsd:complexContent>
@@ -313,12 +313,6 @@
                             <![CDATA[ Defines the service tag]]></xsd:documentation>
                     </xsd:annotation>
                 </xsd:attribute>
-                <xsd:attribute name=""enabledynamictag"" type=""xsd:boolean"" default=""false"">
-                    <xsd:annotation>
-                        <xsd:documentation>
-                            <![CDATA[ Defines the service tag]]></xsd:documentation>
-                    </xsd:annotation>
-                </xsd:attribute>
                 <xsd:anyAttribute namespace=""##other"" processContents=""lax""/>
             </xsd:extension>
         </xsd:complexContent>
"
https://github.com/apache/dubbo/commit/51e2e80158c1d2f10cf8c38ae533e8c09ef91e9a,Remove unnecessary null check. ,https://api.github.com/repos/apache/dubbo/commits/51e2e80158c1d2f10cf8c38ae533e8c09ef91e9a,"@@ -175,7 +175,7 @@ private static void putRandomPort(String protocol, Integer port) {
     }
 
     public URL toUrl() {
-        return urls == null || urls.isEmpty() ? null : urls.iterator().next();
+        return urls.isEmpty() ? null : urls.iterator().next();
     }
 
     public List<URL> toUrls() {
"
https://github.com/square/okhttp/commit/112f020c411c9d14f34e480b98325777b25a7434,Change the cache to have non-shared semantics.  <enter> This means we'll cache responses that use an 'Authorization' header. This means OkHttp's cache shouldn't be used on middleboxes that sit between user agents and the origin server; in practice this is never a use case for OkHttp. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/square/okhttp/commits/112f020c411c9d14f34e480b98325777b25a7434,"@@ -1216,40 +1216,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("""", response.body().string());
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
+  @Test public void authorizationRequestFullyCached() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader(""Last-Modified: "" + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader(""Cache-Control: max-age=60"")
-        .setBody(""A""));
-    server.enqueue(new MockResponse()
-        .setBody(""B""));
-
-    URL url = server.getUrl(""/"");
-    Request request = new Request.Builder()
-        .url(url)
-        .header(""Authorization"", ""password"")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals(""A"", response.body().string());
-    assertEquals(""B"", get(url).body().string());
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: s-maxage=60""));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader(""Cache-Control: public""));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: must-revalidate""));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse
         .addHeader(""Cache-Control: max-age=60"")
         .setBody(""A""));
     server.enqueue(new MockResponse()
@@ -1098,36 +1098,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("""", readAscii(connection));
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader(""Last-Modified: "" + formatDate(-2, TimeUnit.MINUTES))
-            .addHeader(""Cache-Control: max-age=60"")
-            .setBody(""A""));
-    server.enqueue(new MockResponse().setBody(""B""));
-
-    URL url = server.getUrl(""/"");
-    URLConnection connection = client.open(url);
-    connection.addRequestProperty(""Authorization"", ""password"");
-    assertEquals(""A"", readAscii(connection));
-    assertEquals(""B"", readAscii(client.open(url)));
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: s-maxage=60""));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader(""Cache-Control: public""));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: must-revalidate""));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.addHeader(""Cache-Control: max-age=60"").setBody(""A""));
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader(""Cache-Control: max-age=60"").setBody(""A""));
     server.enqueue(new MockResponse().setBody(""B""));
 
     URL url = server.getUrl(""/"");
@@ -917,36 +917,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("""", readAscii(connection));
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader(""Last-Modified: "" + formatDate(-2, TimeUnit.MINUTES))
-            .addHeader(""Cache-Control: max-age=60"")
-            .setBody(""A""));
-    server.enqueue(new MockResponse().setBody(""B""));
-
-    URL url = server.getUrl(""/"");
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty(""Authorization"", ""password"");
-    assertEquals(""A"", readAscii(connection));
-    assertEquals(""B"", readAscii(openConnection(url)));
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: s-maxage=60""));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader(""Cache-Control: public""));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: must-revalidate""));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.addHeader(""Cache-Control: max-age=60"").setBody(""A""));
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader(""Cache-Control: max-age=60"").setBody(""A""));
     server.enqueue(new MockResponse().setBody(""B""));
 
     URL url = server.getUrl(""/"");
@@ -50,17 +50,8 @@ public static boolean isCacheable(Response response, Request request) {
       return false;
     }
 
-    // Responses to authorized requests aren't cacheable unless they include
-    // a 'public', 'must-revalidate' or 's-maxage' directive.
-    CacheControl responseCaching = response.cacheControl();
-    if (request.header(""Authorization"") != null
-        && !responseCaching.isPublic()
-        && !responseCaching.mustRevalidate()
-        && responseCaching.sMaxAgeSeconds() == -1) {
-      return false;
-    }
-
     // A 'no-store' directive on request or response prevents the response from being cached.
+    CacheControl responseCaching = response.cacheControl();
     CacheControl requestCaching = request.cacheControl();
     if (responseCaching.noStore() || requestCaching.noStore()) {
       return false;
"
https://github.com/apache/dubbo/commit/57c13e07430a58e77249b96af9574b3db04e6dba,Remove unused import for unit test ( <pr_link> )  <enter> * clear unused import ,https://api.github.com/repos/apache/dubbo/commits/57c13e07430a58e77249b96af9574b3db04e6dba,"@@ -20,7 +20,6 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
-import java.util.Objects;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -44,7 +44,6 @@
 import org.apache.dubbo.rpc.Filter;
 import org.apache.dubbo.rpc.RpcContext;
 import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.service.GenericException;
 import org.apache.dubbo.rpc.service.GenericService;
 
 import org.junit.Assert;
@@ -17,7 +17,6 @@
 package org.apache.dubbo.config.spring.beans.factory.annotation;
 
 import org.apache.dubbo.config.spring.ServiceBean;
-import org.apache.dubbo.config.spring.api.DemoService;
 import org.apache.dubbo.config.spring.api.HelloService;
 
 import org.junit.Assert;
@@ -30,7 +30,6 @@
 import java.io.IOException;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.Properties;
 import java.util.regex.Pattern;
 
 /**
"
https://github.com/junit-team/junit4/commit/eedd1f68fbd014beca60c979e8173c271ea5cf2d,"Upate TestName to make the 'name' field volatile.  <enter> This ensures that the name is published across threads correctly--for instance, if a parallelized runner is used. <enter>  Closes   <pr_link> ",https://api.github.com/repos/junit-team/junit4/commits/eedd1f68fbd014beca60c979e8173c271ea5cf2d,"@@ -25,7 +25,7 @@
  * @since 4.7
  */
 public class TestName extends TestWatcher {
-    private String name;
+    private volatile String name;
 
     @Override
     protected void starting(Description d) {
"
https://github.com/square/retrofit/commit/999c72be0468664c711159cd53deff79e62ee4a1,Refactor Rx tests to avoid the use of blocking operators. ,https://api.github.com/repos/square/retrofit/commits/999c72be0468664c711159cd53deff79e62ee4a1,"@@ -4,7 +4,7 @@ Retrofit Adapters
 Retrofit ships with a default adapter for executing `Call` instances. The child modules contained
 herein are additional adapters for other popular execution mechanisms.
 
-To use, supply an instance of your desired converter when building your `Retrofit` instance.
+To use, supply an instance of your desired adapter when building your `Retrofit` instance.
 
 ```java
 Retrofit retrofit = new Retrofit.Builder()
@@ -4,12 +4,17 @@
 
 /** Exception for an unexpected, non-2xx HTTP response. */
 public final class HttpException extends Exception {
+  private static String getMessage(Response<?> response) {
+    if (response == null) throw new NullPointerException(""response == null"");
+    return ""HTTP "" + response.code() + "" "" + response.message();
+  }
+
   private final int code;
   private final String message;
   private final transient Response<?> response;
 
   public HttpException(Response<?> response) {
-    super(""HTTP "" + response.code() + "" "" + response.message());
+    super(getMessage(response));
     this.code = response.code();
     this.message = response.message();
     this.response = response;
@@ -24,9 +24,11 @@
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
+import rx.Completable;
 import rx.Observable;
 import rx.Producer;
 import rx.Scheduler;
+import rx.Single;
 import rx.Subscriber;
 import rx.Subscription;
 import rx.exceptions.Exceptions;
@@ -35,15 +37,16 @@
 /**
  * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables.
  * <p>
- * Adding this class to {@link Retrofit} allows you to return {@link Observable} from service
- * methods.
+ * Adding this class to {@link Retrofit} allows you to return an {@link Observable}, {@link Single},
+ * or {@link Completable} from service methods.
  * <pre><code>
  * interface MyService {
  *   &#64;GET(""user/me"")
  *   Observable&lt;User&gt; getUser()
  * }
  * </code></pre>
- * There are three configurations supported for the {@code Observable} type parameter:
+ * There are three configurations supported for the {@code Observable} or {@code Single} type
+ * parameter:
  * <ul>
  * <li>Direct body (e.g., {@code Observable<User>}) calls {@code onNext} with the deserialized body
  * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
@@ -54,6 +57,10 @@
  * <li>Result wrapped body (e.g., {@code Observable<Result<User>>}) calls {@code onNext} with a
  * {@link Result} object for all HTTP responses and errors.</li>
  * </ul>
+ * <p>
+ * <em>Note:</em> Support for {@link Single} and {@link Completable} is experimental and subject
+ * to backwards-incompatible changes at any time since both of these types are not considered
+ * stable by RxJava.
  */
 public final class RxJavaCallAdapterFactory extends CallAdapter.Factory {
   /**
@@ -24,10 +24,10 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
+import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class CompletableTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -48,29 +48,26 @@ interface Service {
 
   @Test public void completableSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
-    service.completable().await();
+
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    subscriber.assertCompleted();
   }
 
   @Test public void completableSuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    try {
-      service.completable().await();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
-    }
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    Throwable cause = subscriber.getOnErrorEvents().get(0);
+    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
   }
 
   @Test public void completableFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    try {
-      service.completable().await();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 }
@@ -26,7 +26,7 @@
 import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class CompletableSchedulerTest {
+public final class CompletableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import org.junit.Test;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class HttpExceptionTest {
+  @Test public void response() {
+    Response<String> response = Response.success(""Hi"");
+    HttpException exception = new HttpException(response);
+    assertThat(exception.code()).isEqualTo(200);
+    assertThat(exception.message()).isEqualTo(""OK"");
+    assertThat(exception.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      new HttpException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage(""response == null"");
+    }
+  }
+}
@@ -25,12 +25,10 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.observables.BlockingObservable;
 import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class ObservableTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -55,33 +53,29 @@ interface Service {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    assertThat(o.first()).isEqualTo(""Hi"");
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertValues(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
-    }
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoValues();
+    Throwable cause = subscriber.getOnErrorEvents().get(0);
+    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void bodyRespectsBackpressure() {
@@ -103,31 +97,32 @@ interface Service {
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.first();
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    Response<String> response = subscriber.getOnNextEvents().get(0);
     assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void responseSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.first();
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    Response<String> response = subscriber.getOnNextEvents().get(0);
     assertThat(response.isSuccessful()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void responseRespectsBackpressure() {
@@ -149,32 +144,38 @@ interface Service {
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
     assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void resultSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
     assertThat(response.isSuccessful()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
   }
 
   @Test public void resultRespectsBackpressure() {
@@ -27,7 +27,7 @@
 import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class ObservableSchedulerTest {
+public final class ObservableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
@@ -25,11 +25,10 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.singles.BlockingSingle;
+import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class SingleTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -54,70 +53,62 @@ interface Service {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    assertThat(o.value()).isEqualTo(""Hi"");
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertValue(""Hi"");
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
-    }
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    Throwable cause = subscriber.getOnErrorEvents().get(0);
+    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.value();
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    Response<String> response = subscriber.getOnNextEvents().get(0);
     assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo(""Hi"");
   }
 
   @Test public void responseSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.value();
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    Response<String> response = subscriber.getOnNextEvents().get(0);
     assertThat(response.isSuccessful()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo(""Hi"");
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
     assertThat(response.isSuccessful()).isTrue();
@@ -127,8 +118,9 @@ interface Service {
   @Test public void resultSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
     assertThat(response.isSuccessful()).isFalse();
@@ -138,8 +130,9 @@ interface Service {
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
@@ -27,7 +27,7 @@
 import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class SingleSchedulerTest {
+public final class SingleWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
"
https://github.com/square/okhttp/commit/ff7946416d86aedcf154b868ba869241cd4816e9,"Add some pings to force happens-before in SPDY tests.  <enter> Previously we were relying on accidents to get our tests to pass. There may still be some that require work, but this should fix the three tests that I saw fail. <enter>  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/ff7946416d86aedcf154b868ba869241cd4816e9,"@@ -97,12 +97,15 @@ public final class SpdyConnectionTest {
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries(""b"", ""banana""));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries(""a"", ""android""), false, false);
     assertEquals(1, connection.openStreamCount());
     assertEquals(headerEntries(""b"", ""banana""), stream.getResponseHeaders());
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
   }
 
@@ -334,12 +337,10 @@ public final class SpdyConnectionTest {
     SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
-    synchronized (connection) {
-      assertEquals(0, connection.peerSettings.getHeaderTableSize());
-      Http20Draft10.Reader frameReader = (Http20Draft10.Reader) connection.frameReader;
-      assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
-      // TODO: when supported, check the frameWriter's compression table is unaffected.
-    }
+    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    Http20Draft10.Reader frameReader = (Http20Draft10.Reader) connection.frameReader;
+    assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
+    // TODO: when supported, check the frameWriter's compression table is unaffected.
   }
 
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
@@ -350,9 +351,7 @@ public final class SpdyConnectionTest {
     SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
-    synchronized (connection) {
-      assertFalse(connection.peerSettings.getEnablePush(true));
-    }
+    assertFalse(connection.peerSettings.getEnablePush(true));
   }
 
   @Test public void serverSendsSettingsToClient() throws Exception {
@@ -652,13 +651,16 @@ public final class SpdyConnectionTest {
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries(""b"", ""banana""));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8(""square""));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries(""a"", ""android""), false, true);
     Source source = stream.getSource();
     assertStreamData(""square"", source);
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -1516,6 +1518,8 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     peer.setVariantAndClient(HTTP_20_DRAFT_09, client);
     peer.sendFrame().settings(settings);
     peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
@@ -1526,6 +1530,8 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     assertEquals(TYPE_SETTINGS, ackFrame.type);
     assertEquals(0, ackFrame.streamId);
     assertTrue(ackFrame.ack);
+
+    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
     return connection;
   }
 
"
https://github.com/square/retrofit/commit/c3633423b4a52566446bc6d540904f1f5f715205,"Re-work unresolvable type detection in parameters  <enter> In order to natively support Kotlin's 'suspend' modifier in the future, we need to allow wildcards to be used for the last parameter. As a result, we only validate the shape of a type once a Retrofit annotation is detected. ",https://api.github.com/repos/square/retrofit/commits/c3633423b4a52566446bc6d540904f1f5f715205,"@@ -171,18 +171,7 @@ RequestFactory build() {
       int parameterCount = parameterAnnotationsArray.length;
       parameterHandlers = new ParameterHandler<?>[parameterCount];
       for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(method, p,
-              ""Parameter type must not include a type variable or wildcard: %s"", parameterType);
-        }
-
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(method, p, ""No Retrofit annotation found."");
-        }
-
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+        parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);
       }
 
       if (relativeUrl == null && !gotUrl) {
@@ -290,21 +279,24 @@ private Headers parseHeaders(String[] headers) {
     }
 
     private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
+        int p, Type parameterType, @Nullable Annotation[] annotations) {
       ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+      if (annotations != null) {
+        for (Annotation annotation : annotations) {
+          ParameterHandler<?> annotationAction =
+              parseParameterAnnotation(p, parameterType, annotations, annotation);
 
-        if (annotationAction == null) {
-          continue;
-        }
+          if (annotationAction == null) {
+            continue;
+          }
 
-        if (result != null) {
-          throw parameterError(method, p, ""Multiple Retrofit annotations found, only one allowed."");
-        }
+          if (result != null) {
+            throw parameterError(method, p,
+                ""Multiple Retrofit annotations found, only one allowed."");
+          }
 
-        result = annotationAction;
+          result = annotationAction;
+        }
       }
 
       if (result == null) {
@@ -317,6 +309,7 @@ private ParameterHandler<?> parseParameter(
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
+        validateResolvableType(p, type);
         if (gotUrl) {
           throw parameterError(method, p, ""Multiple @Url method annotations found."");
         }
@@ -349,6 +342,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof Path) {
+        validateResolvableType(p, type);
         if (gotQuery) {
           throw parameterError(method, p, ""A @Path parameter must not come after a @Query."");
         }
@@ -375,6 +369,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.Path<>(name, converter, path.encoded());
 
       } else if (annotation instanceof Query) {
+        validateResolvableType(p, type);
         Query query = (Query) annotation;
         String name = query.value();
         boolean encoded = query.encoded();
@@ -405,6 +400,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof QueryName) {
+        validateResolvableType(p, type);
         QueryName query = (QueryName) annotation;
         boolean encoded = query.encoded();
 
@@ -434,6 +430,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof QueryMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         gotQueryMap = true;
         if (!Map.class.isAssignableFrom(rawParameterType)) {
@@ -456,6 +453,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
       } else if (annotation instanceof Header) {
+        validateResolvableType(p, type);
         Header header = (Header) annotation;
         String name = header.value();
 
@@ -484,6 +482,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof HeaderMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
           throw parameterError(method, p, ""@HeaderMap parameter type must be Map."");
@@ -505,6 +504,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.HeaderMap<>(valueConverter);
 
       } else if (annotation instanceof Field) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p, ""@Field parameters can only be used with form encoding."");
         }
@@ -539,6 +539,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof FieldMap) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p,
               ""@FieldMap parameters can only be used with form encoding."");
@@ -565,6 +566,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
 
       } else if (annotation instanceof Part) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               ""@Part parameters can only be used with multipart encoding."");
@@ -646,6 +648,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof PartMap) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               ""@PartMap parameters can only be used with multipart encoding."");
@@ -680,6 +683,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
 
       } else if (annotation instanceof Body) {
+        validateResolvableType(p, type);
         if (isFormEncoded || isMultipart) {
           throw parameterError(method, p,
               ""@Body parameters cannot be used with form or multi-part encoding."");
@@ -702,6 +706,13 @@ private ParameterHandler<?> parseParameterAnnotation(
       return null; // Not a Retrofit annotation.
     }
 
+    private void validateResolvableType(int p, Type type) {
+      if (Utils.hasUnresolvableType(type)) {
+        throw parameterError(method, p,
+            ""Parameter type must not include a type variable or wildcard: %s"", type);
+      }
+    }
+
     private void validatePathName(int p, String name) {
       if (!PARAM_NAME_REGEX.matcher(name).matches()) {
         throw parameterError(method, p, ""@Path parameter name must match %s. Found: %s"",
"
https://github.com/square/okhttp/commit/53e12cca33f7d24cd8ea6c6ead262559b3553fbb,Request entity tests for the Apache client shim. ,https://api.github.com/repos/square/okhttp/commits/53e12cca33f7d24cd8ea6c6ead262559b3553fbb,"@@ -2,28 +2,40 @@
 
 import com.google.mockwebserver.MockResponse;
 import com.google.mockwebserver.MockWebServer;
+import com.google.mockwebserver.RecordedRequest;
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.util.Arrays;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.ByteArrayEntity;
+import org.apache.http.entity.InputStreamEntity;
 import org.apache.http.util.EntityUtils;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class OkApacheClientTest {
-  private MockWebServer server = new MockWebServer();
-  private OkApacheClient client = new OkApacheClient();
+  private MockWebServer server;
+  private OkApacheClient client;
+
+  @Before public void setUp() throws IOException {
+    client = new OkApacheClient();
+    server = new MockWebServer();
+    server.play();
+  }
 
   @After public void tearDown() throws IOException {
     server.shutdown();
   }
 
   @Test public void success() throws Exception {
     server.enqueue(new MockResponse().setBody(""Hello, World!""));
-    server.play();
 
     HttpGet request = new HttpGet(server.getUrl(""/"").toURI());
     HttpResponse response = client.execute(request);
@@ -34,7 +46,6 @@ public class OkApacheClientTest {
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(302).addHeader(""Location"", ""/foo""));
     server.enqueue(new MockResponse().setBody(""Hello, Redirect!""));
-    server.play();
 
     HttpGet request = new HttpGet(server.getUrl(""/"").toURI());
     HttpResponse response = client.execute(request);
@@ -44,7 +55,6 @@ public class OkApacheClientTest {
 
   @Test public void sessionExpired() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(422));
-    server.play();
 
     HttpGet request = new HttpGet(server.getUrl(""/"").toURI());
     HttpResponse response = client.execute(request);
@@ -54,7 +64,6 @@ public class OkApacheClientTest {
   @Test public void headers() throws Exception {
     server.enqueue(new MockResponse().addHeader(""Foo"", ""Bar""));
     server.enqueue(new MockResponse().addHeader(""Foo"", ""Bar"").addHeader(""Foo"", ""Baz""));
-    server.play();
 
     HttpGet request1 = new HttpGet(server.getUrl(""/"").toURI());
     HttpResponse response1 = client.execute(request1);
@@ -72,9 +81,34 @@ public class OkApacheClientTest {
 
   @Test public void noEntity() throws Exception {
     server.enqueue(new MockResponse());
-    server.play();
 
     HttpPost post = new HttpPost(server.getUrl(""/"").toURI());
     client.execute(post);
   }
+
+  @Test public void postByteEntity() throws Exception {
+    server.enqueue(new MockResponse());
+
+    final HttpPost post = new HttpPost(server.getUrl(""/"").toURI());
+    byte[] body = ""Hello, world!"".getBytes(""UTF-8"");
+    post.setEntity(new ByteArrayEntity(body));
+    client.execute(post);
+
+    RecordedRequest request = server.takeRequest();
+    assertTrue(Arrays.equals(body, request.getBody()));
+    assertEquals(request.getHeader(""Content-Length""), ""13"");
+  }
+
+  @Test public void postInputStreamEntity() throws Exception {
+    server.enqueue(new MockResponse());
+
+    final HttpPost post = new HttpPost(server.getUrl(""/"").toURI());
+    byte[] body = ""Hello, world!"".getBytes(""UTF-8"");
+    post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
+    client.execute(post);
+
+    RecordedRequest request = server.takeRequest();
+    assertTrue(Arrays.equals(body, request.getBody()));
+    assertEquals(request.getHeader(""Content-Length""), ""13"");
+  }
 }
"
https://github.com/spring-projects/spring-boot/commit/3eb5c348fb93a416d5dcd0003d3273570a217589,"Align test with Spring MVC's internals once again  <enter> The internals have been updated so that the field that was originally used, interceptors, can be used again. <enter> This reverts commit  <otherCommit_link> . ",https://api.github.com/repos/spring-projects/spring-boot/commits/3eb5c348fb93a416d5dcd0003d3273570a217589,"@@ -148,7 +148,7 @@ public void onDifferentPort() throws Exception {
 		assertContent(""/endpoint"", ports.get().management, ""endpointoutput"");
 		List<?> interceptors = (List<?>) ReflectionTestUtils.getField(
 				this.applicationContext.getBean(EndpointHandlerMapping.class),
-				""handlerInterceptors"");
+				""interceptors"");
 		assertEquals(1, interceptors.size());
 		this.applicationContext.close();
 		assertAllClosed();
"
https://github.com/spring-projects/spring-boot/commit/c25736d84f92e6d9158927b63e690cb5f2bae65e,Add test for nested properties ,https://api.github.com/repos/spring-projects/spring-boot/commits/c25736d84f92e6d9158927b63e690cb5f2bae65e,"@@ -52,6 +52,16 @@ public void testBasicPropertiesBinding() {
 		assertEquals(""foo"", this.context.getBean(TestProperties.class).name);
 	}
 
+	@Test
+	public void testNestedPropertiesBinding() {
+		this.context.register(NestedConfiguration.class);
+		TestUtils.addEnviroment(this.context, ""name:foo"", ""nested.name:bar"");
+		this.context.refresh();
+		assertEquals(1, this.context.getBeanNamesForType(NestedProperties.class).length);
+		assertEquals(""foo"", this.context.getBean(NestedProperties.class).name);
+		assertEquals(""bar"", this.context.getBean(NestedProperties.class).nested.name);
+	}
+
 	@Test
 	public void testBasicPropertiesBindingWithAnnotationOnBaseClass() {
 		this.context.register(DerivedConfiguration.class);
@@ -190,6 +200,11 @@ protected static class TestConfiguration {
 	protected static class DerivedConfiguration {
 	}
 
+	@Configuration
+	@EnableConfigurationProperties(NestedProperties.class)
+	protected static class NestedConfiguration {
+	}
+
 	@Configuration
 	protected static class DefaultConfiguration {
 		@Bean
@@ -225,6 +240,29 @@ public String getName() {
 	protected static class MoreConfiguration {
 	}
 
+	@ConfigurationProperties
+	protected static class NestedProperties {
+		private String name;
+		private Nested nested = new Nested();
+
+		public void setName(String name) {
+			this.name = name;
+		}
+
+		public Nested getNested() {
+			return this.nested;
+		}
+
+		protected static class Nested {
+			private String name;
+
+			public void setName(String name) {
+				this.name = name;
+			}
+
+		}
+	}
+
 	@ConfigurationProperties
 	protected static class BaseProperties {
 		private String name;
"
https://github.com/square/okhttp/commit/353ec0b0cdbf46ddbc2755e482c62ec711badf90,"Fix for SslContextBuilder/MockWebServer disagreeing about localhost  <enter> MockWebServer binds to getByName('localhost'), SslContextBuilder was using InetAddress.getByName(null) (null == any loopback). On Android, null returns IPv6 loopback, which has the name 'ip6-localhost'. ",https://api.github.com/repos/square/okhttp/commits/353ec0b0cdbf46ddbc2755e482c62ec711badf90,"@@ -68,7 +68,7 @@ public SslContextBuilder(String hostName) {
   public static synchronized SSLContext localhost() {
     if (localhost == null) {
       try {
-        localhost = new SslContextBuilder(InetAddress.getByName(null).getHostName()).build();
+        localhost = new SslContextBuilder(InetAddress.getByName(""localhost"").getHostName()).build();
       } catch (GeneralSecurityException e) {
         throw new RuntimeException(e);
       } catch (UnknownHostException e) {
"
https://github.com/apache/dubbo/commit/5a9ea9373084613b6da4bf34861b1b8a013274b5,Polish release notes in CHANGES.md ,https://api.github.com/repos/apache/dubbo/commits/5a9ea9373084613b6da4bf34861b1b8a013274b5,"@@ -1,3 +1,7 @@
+# Release Notes
+
+## 2.6.2
+
 1. Hessian-lite serialization: revert locale serialization for compatibility, #1413
 2. Asset transfer to ASF, includeing pom, license, DISCLAIMER and so on, #1491
 3. Introduce of new dispatcher policy: EagerThreadpool, #1568
@@ -6,4 +10,6 @@
 6. Gaceful shutdown enhancement
    - Remove exporter destroy logic in AnnotationBean.
    - Waiting for registry notification on consumer side by checking channel state.
-7. Simplify consumer/provider side check in RpcContext, #1444.
\ No newline at end of file
+7. Simplify consumer/provider side check in RpcContext, #1444.
+
+Issues and Pull Requests, check [milestone-2.6.2](https://github.com/apache/incubator-dubbo/milestone/15).
\ No newline at end of file
"
https://github.com/apache/dubbo/commit/c21cc05ec9ff4f96f34af9027714bb525cd0edf5,replace ServiceAnnotationBeanPostProcessor log.isInfoEnabled->log.isWarnEnabled ( <pr_link> ) <enter> simplify ExtensionLoader code segment ,https://api.github.com/repos/apache/dubbo/commits/c21cc05ec9ff4f96f34af9027714bb525cd0edf5,"@@ -860,19 +860,8 @@ private String createAdaptiveExtensionClassCode() {
                 String[] value = adaptiveAnnotation.value();
                 // value is not set, use the value generated from class name as the key
                 if (value.length == 0) {
-                    char[] charArray = type.getSimpleName().toCharArray();
-                    StringBuilder sb = new StringBuilder(128);
-                    for (int i = 0; i < charArray.length; i++) {
-                        if (Character.isUpperCase(charArray[i])) {
-                            if (i != 0) {
-                                sb.append(""."");
-                            }
-                            sb.append(Character.toLowerCase(charArray[i]));
-                        } else {
-                            sb.append(charArray[i]);
-                        }
-                    }
-                    value = new String[]{sb.toString()};
+                    String splitName = StringUtils.camelToSplitName(type.getSimpleName(), ""."");
+                    value = new String[]{splitName};
                 }
 
                 boolean hasInvocation = false;
@@ -261,7 +261,7 @@ private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, Bean
         if (scanner.checkCandidate(beanName, serviceBeanDefinition)) { // check duplicated candidate bean
             registry.registerBeanDefinition(beanName, serviceBeanDefinition);
 
-            if (logger.isInfoEnabled()) {
+            if (logger.isWarnEnabled()) {
                 logger.warn(""The BeanDefinition["" + serviceBeanDefinition +
                         ""] of ServiceBean has been registered with name : "" + beanName);
             }
"
https://github.com/square/okhttp/commit/60f5406dcc094d0431420139bd002e8bdd4ea5d5,"Move TLS retries / fallback into Connection.  <enter> API changes: 1) Added: Address.getCertificatePinner() 2) Incompatible API change: Address constructor no longer includes ConnectionSpecs. Removed getConnectionSpecs(). 3) Added: ConnectionSpec.isCompatible(SSLSocket) 4) Added: TlsVersion.javaName() <enter> Implicit / semantic / internal changes: <enter> 1) Connection now handles all attempts to connect via a route (effectively a {proxy, socket address} pair), rather than just one attempt. i.e. Connection now handles all the TLS negotiation fallbacks internally. <enter> 2) Route no longer deals with TLS versions. Individual TLS failures are not counted against a Route. If no connection attempts to a route were successful the failure is counted against the route. <enter> 3) The code makes a distinction between when various IOExceptions occur, with the intention making retries a bit smarter. It is now more obvious which exceptions happen during setup (RequestException), connection (RouteException), HTTP communication and thus which can be retried and whether the request might have been sent. ",https://api.github.com/repos/square/okhttp/commits/60f5406dcc094d0431420139bd002e8bdd4ea5d5,"@@ -38,7 +38,6 @@
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
@@ -681,6 +680,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  // https://github.com/square/okhttp/issues/442
   @Test public void timeoutsNotRetried() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
@@ -851,7 +851,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(request).execute();
       fail();
     } catch (UnknownServiceException expected) {
-      assertTrue(expected.getMessage().contains(""no connection specs""));
+      assertTrue(expected.getMessage().contains(""CLEARTEXT communication not supported""));
     }
   }
 
@@ -1699,21 +1699,6 @@ private Buffer gzip(String data) throws IOException {
     return result;
   }
 
-  private void assertContains(Collection<String> collection, String element) {
-    for (String c : collection) {
-      if (c != null && c.equalsIgnoreCase(element)) return;
-    }
-    fail(""No "" + element + "" in "" + collection);
-  }
-
-  private void assertContainsNoneMatching(List<String> headers, String pattern) {
-    for (String header : headers) {
-      if (header.matches(pattern)) {
-        fail(""Header "" + header + "" matches "" + pattern);
-      }
-    }
-  }
-
   private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
 
     private List<SSLSocket> socketsCreated = new ArrayList<SSLSocket>();
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
@@ -43,6 +44,13 @@
 import static org.junit.Assert.fail;
 
 public final class ConnectionPoolTest {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  private static final List<ConnectionSpec> CONNECTION_SPECS = Util.immutableList(
+      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
+
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
   private static final SSLContext sslContext = SslContextBuilder.localhost();
 
@@ -77,44 +85,39 @@ private void setUp(int poolSize) throws Exception {
     httpServer = new MockWebServer();
     spdyServer.useHttps(sslContext.getSocketFactory(), false);
 
-    List<ConnectionSpec> connectionSpecs = Util.immutableList(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
     httpServer.start();
     httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
         null, null, AuthenticatorAdapter.INSTANCE, null,
-        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), connectionSpecs, proxySelector);
+        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), CONNECTION_SPECS, proxySelector);
     httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
         httpServer.getPort());
 
     spdyServer.start();
     spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
         sslContext.getSocketFactory(), new RecordingHostnameVerifier(), CertificatePinner.DEFAULT,
         AuthenticatorAdapter.INSTANCE, null, Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1),
-        connectionSpecs, proxySelector);
+        CONNECTION_SPECS, proxySelector);
     spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
         spdyServer.getPort());
 
-    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
-        ConnectionSpec.CLEARTEXT);
-    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress,
-        ConnectionSpec.MODERN_TLS);
+    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress);
+    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress);
     pool = new ConnectionPool(poolSize, KEEP_ALIVE_DURATION_MS);
     // Disable the automatic execution of the cleanup.
     cleanupExecutor = new FakeExecutor();
     pool.replaceCleanupExecutorForTests(cleanupExecutor);
     httpA = new Connection(pool, httpRoute);
-    httpA.connect(200, 200, 200, null);
+    httpA.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpB = new Connection(pool, httpRoute);
-    httpB.connect(200, 200, 200, null);
+    httpB.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpC = new Connection(pool, httpRoute);
-    httpC.connect(200, 200, 200, null);
+    httpC.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpD = new Connection(pool, httpRoute);
-    httpD.connect(200, 200, 200, null);
+    httpD.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpE = new Connection(pool, httpRoute);
-    httpE.connect(200, 200, 200, null);
+    httpE.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     spdyA = new Connection(pool, spdyRoute);
-    spdyA.connect(20000, 20000, 2000, null);
+    spdyA.connect(20000, 20000, 2000, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
 
     owner = new Object();
     httpA.setOwner(owner);
@@ -146,9 +149,8 @@ private void resetWithPoolSize(int poolSize) throws Exception {
     Connection connection = pool.get(httpAddress);
     assertNull(connection);
 
-    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
-        ConnectionSpec.CLEARTEXT));
-    connection.connect(200, 200, 200, null);
+    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress));
+    connection.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     connection.setOwner(owner);
     assertEquals(0, pool.getConnectionCount());
 
@@ -15,13 +15,8 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-
 import org.junit.Test;
 
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
 import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
@@ -35,14 +30,6 @@
 
 public final class ConnectionSpecTest {
 
-  private static final Proxy PROXY = Proxy.NO_PROXY;
-  private static final InetSocketAddress INET_SOCKET_ADDRESS =
-      InetSocketAddress.createUnresolved(""host"", 443);
-  private static final Address HTTPS_ADDRESS = new Address(
-      INET_SOCKET_ADDRESS.getHostString(), INET_SOCKET_ADDRESS.getPort(), null, null, null, null,
-      AuthenticatorAdapter.INSTANCE, PROXY, Arrays.asList(Protocol.HTTP_1_1),
-      Arrays.asList(ConnectionSpec.MODERN_TLS), ProxySelector.getDefault());
-
   @Test
   public void cleartextBuilder() throws Exception {
     ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
@@ -89,9 +76,8 @@ public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        false /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, false /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -119,9 +105,8 @@ public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        true /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -153,9 +138,8 @@ public void tls_explicitCiphers() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        true /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -176,6 +160,52 @@ public void tls_stringCiphersAndVersions() throws Exception {
         .build();
   }
 
+  public void tls_missingRequiredCipher() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
+  @Test
+  public void tls_missingTlsVersion() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+
+    socket.setEnabledProtocols(
+        new String[] { TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName });
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledProtocols(new String[] { TlsVersion.TLS_1_1.javaName });
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
   private static Set<String> createSet(String... values) {
     return new LinkedHashSet<String>(Arrays.asList(values));
   }
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.TlsVersion;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ConnectionSpecSelectorTest {
+
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
+      ""Simulated handshake exception"");
+
+  @Test
+  public void nonRetryableIOException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(
+        new IOException(""Non-handshake exception""));
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void nonRetryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    SSLHandshakeException trustIssueException =
+        new SSLHandshakeException(""Certificate handshake exception"");
+    trustIssueException.initCause(new CertificateException());
+    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void retryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+  }
+
+  @Test
+  public void someFallbacksSupported() throws Exception {
+    ConnectionSpec sslV3 =
+        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+            .tlsVersions(TlsVersion.SSL_3_0)
+            .build();
+
+    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
+
+    TlsVersion[] enabledSocketTlsVersions = { TlsVersion.TLS_1_1, TlsVersion.TLS_1_0 };
+    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+
+    // MODERN_TLS is used here.
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+
+    // COMPATIBLE_TLS is used here.
+    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+
+    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertFalse(retry);
+    socket.close();
+
+    // sslV3 is not used because SSLv3 is not enabled on the socket.
+  }
+
+  private static ConnectionSpecSelector createConnectionSpecSelector(
+      ConnectionSpec... connectionSpecs) {
+    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
+  }
+
+  private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
+    SSLSocket socket = (SSLSocket) sslContext.getSocketFactory().createSocket();
+    socket.setEnabledProtocols(javaNames(tlsVersions));
+    return socket;
+  }
+
+  private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
+    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
+    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
+    assertEquals(expected, actual);
+  }
+
+  private static String[] javaNames(TlsVersion... tlsVersions) {
+    String[] protocols = new String[tlsVersions.length];
+    for (int i = 0; i < tlsVersions.length; i++) {
+      protocols[i] = tlsVersions[i].javaName();
+    }
+    return protocols;
+  }
+}
@@ -28,7 +28,6 @@
 import com.squareup.okhttp.internal.RouteDatabase;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
@@ -41,7 +40,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
 import org.junit.Before;
 import org.junit.Test;
@@ -114,8 +112,7 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -135,8 +132,7 @@ public final class RouteSelectorTest {
     Route route = routeSelector.next();
     routeDatabase.failed(route);
     routeSelector = RouteSelector.get(address, httpRequest, client);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     assertFalse(routeSelector.hasNext());
     try {
       routeSelector.next();
@@ -153,10 +149,8 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
@@ -171,10 +165,8 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -190,8 +182,7 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -203,10 +194,8 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -224,25 +213,20 @@ public final class RouteSelectorTest {
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0], proxyBPort);
     dns.assertRequests(proxyBHost);
 
     // Finally try the only IP address of the origin server.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -258,8 +242,7 @@ public final class RouteSelectorTest {
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -276,8 +259,7 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
@@ -291,44 +273,17 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
   }
 
-  // https://github.com/square/okhttp/issues/442
-  @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeSelector.connectFailed(route, new IOException(""Non SSL exception""));
-    assertEquals(2, routeDatabase.failedRoutesCount());
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void sslErrorAddsOnlyFailedConfigurationToFailedRoute() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeSelector.connectFailed(route, new SSLHandshakeException(""SSL exception""));
-    assertTrue(routeDatabase.failedRoutesCount() == 1);
-    assertTrue(routeSelector.hasNext());
-  }
-
   @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
@@ -337,39 +292,21 @@ public final class RouteSelectorTest {
 
     // Proxy A
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
 
     // Proxy B
     dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0], proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
-        proxyBPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
-        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1], proxyBPort);
 
     // Origin
     dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
   }
@@ -379,7 +316,8 @@ public final class RouteSelectorTest {
     client.setProxy(Proxy.NO_PROXY);
     RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
 
-    dns.inetAddresses = makeFakeAddresses(255, 1);
+    final int numberOfAddresses = 2;
+    dns.inetAddresses = makeFakeAddresses(255, numberOfAddresses);
 
     // Extract the regular sequence of routes from selector.
     List<Route> regularRoutes = new ArrayList<>();
@@ -388,7 +326,7 @@ public final class RouteSelectorTest {
     }
 
     // Check that we do indeed have more than one route.
-    assertTrue(regularRoutes.size() > 1);
+    assertEquals(numberOfAddresses, regularRoutes.size());
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
@@ -422,13 +360,12 @@ public final class RouteSelectorTest {
     assertEquals(""127.0.0.1"", RouteSelector.getHostString(socketAddress));
   }
 
-  private void assertRoute(Route route, Address address, Proxy proxy,
-      InetAddress socketAddress, int socketPort, ConnectionSpec connectionSpec) {
+  private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
+      int socketPort) {
     assertEquals(address, route.getAddress());
     assertEquals(proxy, route.getProxy());
     assertEquals(socketAddress, route.getSocketAddress().getAddress());
     assertEquals(socketPort, route.getSocketAddress().getPort());
-    assertEquals(connectionSpec, route.getConnectionSpec());
   }
 
   /** Returns an address that's without an SSL socket factory or hostname verifier. */
@@ -613,6 +613,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     RecordedRequest request = server.takeRequest();
     assertEquals(""GET /foo HTTP/1.1"", request.getRequestLine());
+    assertEquals(TlsVersion.TLS_1_0, request.getTlsVersion());
   }
 
   /**
@@ -27,11 +27,13 @@
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RequestException;
 import com.squareup.okhttp.internal.http.RetryableSink;
 import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.FileNotFoundException;
@@ -432,7 +434,25 @@ private boolean execute(boolean readResponse) throws IOException {
       }
 
       return true;
+    } catch (RequestException e) {
+      // An attempt to interpret a request failed.
+      IOException toThrow = e.getCause();
+      httpEngineFailure = toThrow;
+      throw toThrow;
+    } catch (RouteException e) {
+      // The attempt to connect via a route failed. The request will not have been sent.
+      HttpEngine retryEngine = httpEngine.recover(e);
+      if (retryEngine != null) {
+        httpEngine = retryEngine;
+        return false;
+      }
+
+      // Give up; recovery is not possible.
+      IOException toThrow = e.getLastConnectException();
+      httpEngineFailure = toThrow;
+      throw toThrow;
     } catch (IOException e) {
+      // An attempt to communicate with a server failed. The request may have been sent.
       HttpEngine retryEngine = httpEngine.recover(e);
       if (retryEngine != null) {
         httpEngine = retryEngine;
@@ -139,6 +139,13 @@ public ProxySelector getProxySelector() {
     return proxySelector;
   }
 
+  /**
+   * Returns this address's certificate pinner. Only used for secure connections.
+   */
+  public CertificatePinner getCertificatePinner() {
+    return certificatePinner;
+  }
+
   @Override public boolean equals(Object other) {
     if (other instanceof Address) {
       Address that = (Address) other;
@@ -16,7 +16,9 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RequestException;
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.ProtocolException;
@@ -270,7 +272,20 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
       try {
         engine.sendRequest();
         engine.readResponse();
+      } catch (RequestException e) {
+        // The attempt to interpret the request failed. Give up.
+        throw e.getCause();
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        HttpEngine retryEngine = engine.recover(e);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
+        // Give up; recovery is not possible.
+        throw e.getLastConnectException();
       } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
         HttpEngine retryEngine = engine.recover(e, null);
         if (retryEngine != null) {
           engine = retryEngine;
@@ -16,30 +16,18 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
-import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RouteException;
+import com.squareup.okhttp.internal.http.SocketConnector;
 import com.squareup.okhttp.internal.http.SpdyTransport;
 import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
-import java.net.Proxy;
 import java.net.Socket;
-import java.net.URL;
-import java.security.cert.X509Certificate;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-import okio.Source;
-
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import java.net.UnknownServiceException;
+import java.util.List;
 
 /**
  * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be
@@ -142,23 +130,42 @@ void closeIfOwnedBy(Object owner) throws IOException {
     socket.close();
   }
 
-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)
-      throws IOException {
+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,
+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
     if (connected) throw new IllegalStateException(""already connected"");
 
-    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {
-      socket = route.address.socketFactory.createSocket();
+    SocketConnector socketConnector = new SocketConnector(this, pool);
+    SocketConnector.ConnectedSocket connectedSocket;
+    if (route.address.getSslSocketFactory() != null) {
+      // https:// communication
+      connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,
+          request, route, connectionSpecs, connectionRetryEnabled);
     } else {
-      socket = new Socket(route.proxy);
+      // http:// communication.
+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+        throw new RouteException(
+            new UnknownServiceException(
+                ""CLEARTEXT communication not supported: "" + connectionSpecs));
+      }
+      connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);
     }
 
-    socket.setSoTimeout(readTimeout);
-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
+    socket = connectedSocket.socket;
+    handshake = connectedSocket.handshake;
+    protocol = connectedSocket.alpnProtocol == null
+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;
 
-    if (route.address.sslSocketFactory != null) {
-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
+    try {
+      if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.
+        spdyConnection = new SpdyConnection.Builder(route.address.uriHost, true, socket)
+            .protocol(protocol).build();
+        spdyConnection.sendConnectionPreface();
+      } else {
+        httpConnection = new HttpConnection(pool, this, socket);
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
     }
     connected = true;
   }
@@ -167,13 +174,14 @@ void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunn
    * Connects this connection if it isn't already. This creates tunnels, shares
    * the connection with the connection pool, and configures timeouts.
    */
-  void connectAndSetOwner(OkHttpClient client, Object owner, Request request) throws IOException {
+  void connectAndSetOwner(OkHttpClient client, Object owner, Request request)
+      throws RouteException {
     setOwner(owner);
 
     if (!isConnected()) {
-      Request tunnelRequest = tunnelRequest(request);
-      connect(client.getConnectTimeout(), client.getReadTimeout(),
-          client.getWriteTimeout(), tunnelRequest);
+      List<ConnectionSpec> connectionSpecs = route.address.getConnectionSpecs();
+      connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
+          request, connectionSpecs, client.getRetryOnConnectionFailure());
       if (isSpdy()) {
         client.getConnectionPool().share(this);
       }
@@ -183,97 +191,6 @@ void connectAndSetOwner(OkHttpClient client, Object owner, Request request) thro
     setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
   }
 
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
-   * no tunnel is necessary. Everything in the tunnel request is sent
-   * unencrypted to the proxy server, so tunnels include only the minimum set of
-   * headers. This avoids sending potentially sensitive data like HTTP cookies
-   * to the proxy unencrypted.
-   */
-  private Request tunnelRequest(Request request) throws IOException {
-    if (!route.requiresTunnel()) return null;
-
-    String host = request.url().getHost();
-    int port = getEffectivePort(request.url());
-    String authority = (port == getDefaultPort(""https"")) ? host : (host + "":"" + port);
-    Request.Builder result = new Request.Builder()
-        .url(new URL(""https"", host, port, ""/""))
-        .header(""Host"", authority)
-        .header(""Proxy-Connection"", ""Keep-Alive""); // For HTTP/1.0 proxies like Squid.
-
-    // Copy over the User-Agent header if it exists.
-    String userAgent = request.header(""User-Agent"");
-    if (userAgent != null) {
-      result.header(""User-Agent"", userAgent);
-    }
-
-    // Copy over the Proxy-Authorization header if it exists.
-    String proxyAuthorization = request.header(""Proxy-Authorization"");
-    if (proxyAuthorization != null) {
-      result.header(""Proxy-Authorization"", proxyAuthorization);
-    }
-
-    return result.build();
-  }
-
-  /**
-   * Create an {@code SSLSocket} and perform the TLS handshake and certificate
-   * validation.
-   */
-  private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeout)
-      throws IOException {
-    Platform platform = Platform.get();
-
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    if (tunnelRequest != null) {
-      makeTunnel(tunnelRequest, readTimeout, writeTimeout);
-    }
-
-    // Create the wrapper over connected socket.
-    socket = route.address.sslSocketFactory
-        .createSocket(socket, route.address.uriHost, route.address.uriPort, true /* autoClose */);
-    SSLSocket sslSocket = (SSLSocket) socket;
-
-    // Configure the socket's ciphers, TLS versions, and extensions.
-    route.connectionSpec.apply(sslSocket, route);
-
-    try {
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
-
-      String maybeProtocol;
-      if (route.connectionSpec.supportsTlsExtensions()
-          && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
-        protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
-      }
-    } finally {
-      platform.afterHandshake(sslSocket);
-    }
-
-    handshake = Handshake.get(sslSocket.getSession());
-
-    // Verify that the socket's certificates are acceptable for the target host.
-    if (!route.address.hostnameVerifier.verify(route.address.uriHost, sslSocket.getSession())) {
-      X509Certificate cert = (X509Certificate) sslSocket.getSession().getPeerCertificates()[0];
-      throw new SSLPeerUnverifiedException(""Hostname "" + route.address.uriHost + "" not verified:""
-          + ""\n    certificate: "" + CertificatePinner.pin(cert)
-          + ""\n    DN: "" + cert.getSubjectDN().getName()
-          + ""\n    subjectAltNames: "" + OkHostnameVerifier.allSubjectAltNames(cert));
-    }
-
-    // Check that the certificate pinner is satisfied by the certificates presented.
-    route.address.certificatePinner.check(route.address.uriHost, handshake.peerCertificates());
-
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
-      sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
-          .protocol(protocol).build();
-      spdyConnection.sendConnectionPreface();
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
-    }
-  }
-
   /** Returns true if {@link #connect} has been attempted on this connection. */
   boolean isConnected() {
     return connected;
@@ -361,12 +278,17 @@ void setProtocol(Protocol protocol) {
     this.protocol = protocol;
   }
 
-  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) throws IOException {
+  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis)
+      throws RouteException {
     if (!connected) throw new IllegalStateException(""setTimeouts - not connected"");
 
     // Don't set timeouts on shared SPDY connections.
     if (httpConnection != null) {
-      socket.setSoTimeout(readTimeoutMillis);
+      try {
+        socket.setSoTimeout(readTimeoutMillis);
+      } catch (IOException e) {
+        throw new RouteException(e);
+      }
       httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
     }
   }
@@ -383,55 +305,6 @@ int recycleCount() {
     return recycleCount;
   }
 
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-   * CONNECT request to create the proxy connection. This may need to be
-   * retried if the proxy requires authorization.
-   */
-  private void makeTunnel(Request request, int readTimeout, int writeTimeout)
-      throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
-    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
-    URL url = request.url();
-    String requestLine = ""CONNECT "" + url.getHost() + "":"" + url.getPort() + "" HTTP/1.1"";
-    while (true) {
-      tunnelConnection.writeRequest(request.headers(), requestLine);
-      tunnelConnection.flush();
-      Response response = tunnelConnection.readResponse().request(request).build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = OkHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
-          // happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just that
-          // it will almost certainly fail because the proxy has sent unexpected data.
-          if (tunnelConnection.bufferSize() > 0) {
-            throw new IOException(""TLS tunnel buffered too many bytes!"");
-          }
-          return;
-
-        case HTTP_PROXY_AUTH:
-          request = OkHeaders.processAuthHeader(
-              route.address.authenticator, response, route.proxy);
-          if (request != null) continue;
-          throw new IOException(""Failed to authenticate with proxy"");
-
-        default:
-          throw new IOException(
-              ""Unexpected response code for CONNECT: "" + response.code());
-      }
-    }
-  }
-
   @Override public String toString() {
     return ""Connection{""
         + route.address.uriHost + "":"" + route.address.uriPort
@@ -15,44 +15,45 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.util.Arrays;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 
 /**
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
- * https:} URLs, this includes the TLS version and ciphers to use when negotiating a secure
+ * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
  * connection.
  */
 public final class ConnectionSpec {
 
+  // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+  // All of these suites are available on Android 5.0; earlier releases support a subset of
+  // these suites. https://github.com/square/okhttp/issues/330
+  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+
+      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+      // continue to include them until better suites are commonly available. For example, none
+      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+  };
+
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(
-          // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
-          // All of these suites are available on Android 5.0; earlier releases support a subset of
-          // these suites. https://github.com/square/okhttp/issues/330
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
-
-          // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
-          // continue to include them until better suites are commonly available. For example, none
-          // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA
-      )
+      .cipherSuites(APPROVED_CIPHER_SUITES)
       .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
@@ -91,8 +92,8 @@ public boolean isTls() {
   }
 
   /**
-   * Return the cipher suites to use with the connection. This method can return {@code null} if the
-   * ciphers enabled by default should be used.
+   * Returns the cipher suites to use for a connection. This method can return {@code null} if the
+   * cipher suites enabled by default should be used.
    */
   public List<CipherSuite> cipherSuites() {
     if (cipherSuites == null) {
@@ -117,22 +118,40 @@ public boolean supportsTlsExtensions() {
     return supportsTlsExtensions;
   }
 
-  /** Applies this spec to {@code sslSocket} for {@code route}. */
-  void apply(SSLSocket sslSocket, Route route) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket);
+  /** Applies this spec to {@code sslSocket}. */
+  void apply(SSLSocket sslSocket, boolean isFallback) {
+    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
 
     sslSocket.setEnabledProtocols(specToApply.tlsVersions);
 
     String[] cipherSuitesToEnable = specToApply.cipherSuites;
-    if (route.shouldSendTlsFallbackIndicator) {
+    // null means ""use default set"".
+    if (cipherSuitesToEnable != null) {
+      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+    }
+  }
+
+  /**
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by
+   * {@code sslSocket}.
+   */
+  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+    String[] cipherSuitesToEnable = null;
+    if (cipherSuites != null) {
+      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
+      cipherSuitesToEnable =
+          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+    }
+
+    if (isFallback) {
       // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
       // the SCSV cipher is added to signal that a protocol fallback has taken place.
       final String fallbackScsv = ""TLS_FALLBACK_SCSV"";
       boolean socketSupportsFallbackScsv =
           Arrays.asList(sslSocket.getSupportedCipherSuites()).contains(fallbackScsv);
 
       if (socketSupportsFallbackScsv) {
-        // Add the SCSV cipher to the set of enabled ciphers iff it is supported.
+        // Add the SCSV cipher to the set of enabled cipher suites iff it is supported.
         String[] oldEnabledCipherSuites = cipherSuitesToEnable != null
             ? cipherSuitesToEnable
             : sslSocket.getEnabledCipherSuites();
@@ -143,35 +162,71 @@ void apply(SSLSocket sslSocket, Route route) {
         cipherSuitesToEnable = newEnabledCipherSuites;
       }
     }
-    // null means ""use default set"".
-    if (cipherSuitesToEnable != null) {
-      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+
+    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
+    String[] protocolsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
+    return new Builder(this)
+        .cipherSuites(cipherSuitesToEnable)
+        .tlsVersions(protocolsToEnable)
+        .build();
+  }
+
+  /**
+   * Returns {@code true} if the socket, as currently configured, supports this ConnectionSpec.
+   * In order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   *
+   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+   * must have at least one cipher suite enabled.
+   *
+   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+   * socket's enabled protocols.
+   */
+  public boolean isCompatible(SSLSocket socket) {
+    if (!tls) {
+      return false;
+    }
+
+    String[] enabledProtocols = socket.getEnabledProtocols();
+    boolean requiredProtocolsEnabled = nonEmptyIntersection(tlsVersions, enabledProtocols);
+    if (!requiredProtocolsEnabled) {
+      return false;
     }
 
-    Platform platform = Platform.get();
-    if (specToApply.supportsTlsExtensions) {
-      platform.configureTlsExtensions(sslSocket, route.address.uriHost, route.address.protocols);
+    boolean requiredCiphersEnabled;
+    if (cipherSuites == null) {
+      requiredCiphersEnabled = socket.getEnabledCipherSuites().length > 0;
+    } else {
+      String[] enabledCipherSuites = socket.getEnabledCipherSuites();
+      requiredCiphersEnabled = nonEmptyIntersection(cipherSuites, enabledCipherSuites);
     }
+    return requiredCiphersEnabled;
   }
 
   /**
-   * Returns a copy of this that omits cipher suites and TLS versions not
-   * enabled by {@code sslSocket}.
+   * An N*M intersection that terminates if any intersection is found. The sizes of both
+   * arguments are assumed to be so small, and the likelihood of an intersection so great, that it
+   * is not worth the CPU cost of sorting or the memory cost of hashing.
    */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
-    String[] cipherSuitesToEnable = null;
-    if (cipherSuites != null) {
-      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
-      cipherSuitesToEnable =
-          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+  private static boolean nonEmptyIntersection(String[] a, String[] b) {
+    if (a == null || b == null || a.length == 0 || b.length == 0) {
+      return false;
+    }
+    for (String toFind : a) {
+      if (contains(b, toFind)) {
+        return true;
+      }
     }
+    return false;
+  }
 
-    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
-    String[] tlsVersionsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
-    return new Builder(this)
-        .cipherSuites(cipherSuitesToEnable)
-        .tlsVersions(tlsVersionsToEnable)
-        .build();
+  private static <T> boolean contains(T[] array, T value) {
+    for (T arrayValue : array) {
+      if (Util.equal(value, arrayValue)) {
+        return true;
+      }
+    }
+    return false;
   }
 
   @Override public boolean equals(Object other) {
@@ -257,6 +312,9 @@ public Builder cipherSuites(String... cipherSuites) {
 
     public Builder tlsVersions(TlsVersion... tlsVersions) {
       if (!tls) throw new IllegalStateException(""no TLS versions for cleartext connections"");
+      if (tlsVersions.length == 0) {
+        throw new IllegalArgumentException(""At least one TlsVersion is required"");
+      }
 
       // Convert enums to the string names Java wants. This makes a defensive copy!
       String[] strings = new String[tlsVersions.length];
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
@@ -36,6 +37,7 @@
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
 /**
@@ -116,7 +118,7 @@ public class OkHttpClient implements Cloneable {
       }
 
       @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
-          HttpEngine owner, Request request) throws IOException {
+          HttpEngine owner, Request request) throws RouteException {
         connection.connectAndSetOwner(client, owner, request);
       }
 
@@ -136,6 +138,11 @@ public void callEnqueue(Call call, Callback responseCallback, boolean forWebSock
       @Override public void connectionSetOwner(Connection connection, Object owner) {
         connection.setOwner(owner);
       }
+
+      @Override
+      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+        tlsConfiguration.apply(sslSocket, isFallback);
+      }
     };
   }
 
@@ -28,26 +28,15 @@
  *   <li><strong>IP address:</strong> whether connecting directly to an origin
  *       server or a proxy, opening a socket requires an IP address. The DNS
  *       server may return multiple IP addresses to attempt.
- *   <li><strong>TLS configuration:</strong> which cipher suites and TLS
- *       versions to attempt with the HTTPS connection.
  * </ul>
  * Each route is a specific selection of these options.
  */
 public final class Route {
   final Address address;
   final Proxy proxy;
   final InetSocketAddress inetSocketAddress;
-  final ConnectionSpec connectionSpec;
-  final boolean shouldSendTlsFallbackIndicator;
 
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec) {
-    this(address, proxy, inetSocketAddress, connectionSpec,
-        false /* shouldSendTlsFallbackIndicator */);
-  }
-
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec, boolean shouldSendTlsFallbackIndicator) {
+  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
     if (address == null) {
       throw new NullPointerException(""address == null"");
     }
@@ -57,14 +46,9 @@ public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
     if (inetSocketAddress == null) {
       throw new NullPointerException(""inetSocketAddress == null"");
     }
-    if (connectionSpec == null) {
-      throw new NullPointerException(""connectionConfiguration == null"");
-    }
     this.address = address;
     this.proxy = proxy;
     this.inetSocketAddress = inetSocketAddress;
-    this.connectionSpec = connectionSpec;
-    this.shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator;
   }
 
   public Address getAddress() {
@@ -86,14 +70,6 @@ public InetSocketAddress getSocketAddress() {
     return inetSocketAddress;
   }
 
-  public ConnectionSpec getConnectionSpec() {
-    return connectionSpec;
-  }
-
-  public boolean getShouldSendTlsFallbackIndicator() {
-    return shouldSendTlsFallbackIndicator;
-  }
-
   /**
    * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
    * href=""http://www.ietf.org/rfc/rfc2817.txt"">RFC 2817, Section 5.2</a>.
@@ -107,9 +83,7 @@ public boolean requiresTunnel() {
       Route other = (Route) obj;
       return address.equals(other.address)
           && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress)
-          && connectionSpec.equals(other.connectionSpec)
-          && shouldSendTlsFallbackIndicator == other.shouldSendTlsFallbackIndicator;
+          && inetSocketAddress.equals(other.inetSocketAddress);
     }
     return false;
   }
@@ -119,8 +93,6 @@ public boolean requiresTunnel() {
     result = 31 * result + address.hashCode();
     result = 31 * result + proxy.hashCode();
     result = 31 * result + inetSocketAddress.hashCode();
-    result = 31 * result + connectionSpec.hashCode();
-    result = 31 * result + (shouldSendTlsFallbackIndicator ? 1 : 0);
     return result;
   }
 }
@@ -43,4 +43,8 @@ public static TlsVersion forJavaName(String javaName) {
     }
     throw new IllegalArgumentException(""Unexpected TLS version: "" + javaName);
   }
+
+  public String javaName() {
+    return javaName;
+  }
 }
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.ConnectionSpec;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.ProtocolException;
+import java.net.UnknownServiceException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+
+/**
+ * Handles the connection spec fallback strategy: When a secure socket connection fails
+ * due to a handshake / protocol problem the connection may be retried with different protocols.
+ * Instances are stateful and should be created and used for a single connection attempt.
+ */
+public final class ConnectionSpecSelector {
+
+  private final List<ConnectionSpec> connectionSpecs;
+  private int nextModeIndex;
+  private boolean isFallbackPossible;
+  private boolean isFallback;
+
+  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+    this.nextModeIndex = 0;
+    this.connectionSpecs = connectionSpecs;
+  }
+
+  /**
+   * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
+   * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
+   *
+   * @throws IOException if the socket does not support any of the TLS modes available
+   */
+  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+    ConnectionSpec tlsConfiguration = null;
+    for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
+      ConnectionSpec connectionSpec = connectionSpecs.get(i);
+      if (connectionSpec.isCompatible(sslSocket)) {
+        tlsConfiguration = connectionSpec;
+        nextModeIndex = i + 1;
+        break;
+      }
+    }
+
+    if (tlsConfiguration == null) {
+      // This may be the first time a connection has been attempted and the socket does not support
+      // any the required protocols, or it may be a retry (but this socket supports fewer
+      // protocols than was suggested by a prior socket).
+      throw new UnknownServiceException(
+          ""Unable to find acceptable protocols. isFallback="" + isFallback
+              + "", modes="" + connectionSpecs
+              + "", supported protocols="" + Arrays.toString(sslSocket.getEnabledProtocols()));
+    }
+
+    isFallbackPossible = isFallbackPossible(sslSocket);
+
+    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+
+    return tlsConfiguration;
+  }
+
+  /**
+   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to
+   * try, if any.
+   *
+   * @return {@code true} if the connection should be retried using
+   *     {@link #configureSecureSocket(SSLSocket)} or {@code false} if not
+   */
+  public boolean connectionFailed(IOException e) {
+    // Any future attempt to connect using this strategy will be a fallback attempt.
+    isFallback = true;
+
+    // TODO(nfuller): This is the same logic as in HttpEngine.
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout, don't recover.
+    if (e instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different connection spec.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+    // TODO(nfuller): End of common code.
+
+
+    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
+    // retry those when we probably should not.
+    return ((e instanceof SSLHandshakeException || e instanceof SSLProtocolException))
+        && isFallbackPossible;
+  }
+
+  /**
+   * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
+   * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
+   * same capabilities as the supplied socket.
+   */
+  private boolean isFallbackPossible(SSLSocket socket) {
+    for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
+      if (connectionSpecs.get(i).isCompatible(socket)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
@@ -19,14 +19,17 @@
 import com.squareup.okhttp.Callback;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
 import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
 
 /**
  * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
@@ -35,6 +38,12 @@
  */
 public abstract class Internal {
   public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  public static void initializeInstanceForTests() {
+    // Needed in tests to ensure that the instance is actually pointing to something.
+    new OkHttpClient();
+  }
+
   public static Internal instance;
 
   public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
@@ -67,7 +76,10 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
   public abstract void setNetwork(OkHttpClient client, Network network);
 
   public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
-      HttpEngine owner, Request request) throws IOException;
+      HttpEngine owner, Request request) throws RouteException;
+
+  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
+      boolean isFallback);
 
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
@@ -22,9 +22,8 @@
 /**
  * A blacklist of failed routes to avoid when creating a new connection to a
  * target address. This is used so that OkHttp can learn from its mistakes: if
- * there was a failure attempting to connect to a specific IP address, proxy
- * server or TLS mode, that failure is remembered and alternate routes are
- * preferred.
+ * there was a failure attempting to connect to a specific IP address or proxy
+ * server, that failure is remembered and alternate routes are preferred.
  */
 public final class RouteDatabase {
   private final Set<Route> failedRoutes = new LinkedHashSet<>();
@@ -210,8 +210,15 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * Figures out what the response source will be, and opens a socket to that
    * source if necessary. Prepares the request headers and gets ready to start
    * writing the request body if it exists.
+   *
+   * @throws RequestException if there was a problem with request setup. Unrecoverable.
+   * @throws RouteException if the was a problem during connection via a specific route. Sometimes
+   *     recoverable. See {@link #recover(RouteException)}.
+   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
+   *     {@link #recover(IOException)}.
+   *
    */
-  public void sendRequest() throws IOException {
+  public void sendRequest() throws RequestException, RouteException, IOException {
     if (cacheStrategy != null) return; // Already sent.
     if (transport != null) throw new IllegalStateException();
 
@@ -308,12 +315,16 @@ private static Response stripBody(Response response) {
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  private void connect() throws IOException {
+  private void connect() throws RequestException, RouteException {
     if (connection != null) throw new IllegalStateException();
 
     if (routeSelector == null) {
       address = createAddress(client, networkRequest);
-      routeSelector = RouteSelector.get(address, networkRequest, client);
+      try {
+        routeSelector = RouteSelector.get(address, networkRequest, client);
+      } catch (IOException e) {
+        throw new RequestException(e);
+      }
     }
 
     connection = nextConnection();
@@ -325,24 +336,29 @@ private void connect() throws IOException {
    *
    * @throws java.util.NoSuchElementException if there are no more routes to attempt.
    */
-  private Connection nextConnection() throws IOException {
+  private Connection nextConnection() throws RouteException {
     Connection connection = createNextConnection();
     Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
     return connection;
   }
 
-  private Connection createNextConnection() throws IOException {
+  private Connection createNextConnection() throws RouteException {
     ConnectionPool pool = client.getConnectionPool();
 
     // Always prefer pooled connections over new connections.
     for (Connection pooled; (pooled = pool.get(address)) != null; ) {
       if (networkRequest.method().equals(""GET"") || Internal.instance.isReadable(pooled)) {
         return pooled;
       }
-      pooled.getSocket().close();
+      closeQuietly(pooled.getSocket());
+    }
+
+    try {
+      Route route = routeSelector.next();
+      return new Connection(pool, route);
+    } catch (IOException e) {
+      throw new RouteException(e);
     }
-    Route route = routeSelector.next();
-    return new Connection(pool, route);
   }
 
   /**
@@ -393,8 +409,75 @@ public Connection getConnection() {
   }
 
   /**
-   * Report and attempt to recover from {@code e}. Returns a new HTTP engine
-   * that should be used for the retry if {@code e} is recoverable, or null if
+   * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
+   * that should be used for the retry if there are other routes to try, or null if
+   * there are no more routes to try.
+   */
+  public HttpEngine recover(RouteException e) {
+    if (routeSelector != null && connection != null) {
+      connectFailed(routeSelector, e.getLastConnectException());
+    }
+
+    if (routeSelector == null && connection == null // No connection.
+        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+        || !isRecoverable(e)) {
+      return null;
+    }
+
+    Connection connection = close();
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
+  }
+
+  private boolean isRecoverable(RouteException e) {
+    // If the application has opted-out of recovery, don't recover.
+    if (!client.getRetryOnConnectionFailure()) {
+      return false;
+    }
+
+    // Problems with a route may mean the connection can be retried with a new route, or may
+    // indicate a client-side or server-side issue that should not be retried. To tell, we must look
+    // at the cause.
+
+    IOException ioe = e.getLastConnectException();
+
+    // TODO(nfuller): This is the same logic as in ConnectionSpecSelector
+    // If there was a protocol problem, don't recover.
+    if (ioe instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout, don't recover.
+    if (ioe instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (ioe instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (ioe.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (ioe instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+    // TODO(nfuller): End of common code.
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  /**
+   * Report and attempt to recover from a failure to communicate with a server. Returns a new
+   * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
    * the failure is permanent. Requests with a body can only be recovered if the
    * body is buffered.
    */
@@ -435,13 +518,6 @@ private boolean isRecoverable(IOException e) {
       return false;
     }
 
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server-initiated exception.
-    if (e instanceof SSLPeerUnverifiedException
-        || (e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException)) {
-      return false;
-    }
-
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
       return false;
@@ -1050,10 +1126,10 @@ && getEffectivePort(url) == getEffectivePort(followUp)
   }
 
   private static Address createAddress(OkHttpClient client, Request request)
-      throws UnknownHostException {
+      throws RequestException {
     String uriHost = request.url().getHost();
     if (uriHost == null || uriHost.length() == 0) {
-      throw new UnknownHostException(request.url().toString());
+      throw new RequestException(new UnknownHostException(request.url().toString()));
     }
 
     SSLSocketFactory sslSocketFactory = null;
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+
+/**
+ * Indicates a problem with interpreting a request. It may indicate there was a problem with the
+ * request itself, or the environment being used to interpret the request (network failure, etc.).
+ */
+public final class RequestException extends Exception {
+
+  public RequestException(IOException cause) {
+    super(cause);
+  }
+
+  @Override
+  public IOException getCause() {
+    return (IOException) super.getCause();
+  }
+}
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
+ * have been made with alternative protocols, none of which were successful.
+ */
+public final class RouteException extends Exception {
+
+  private final List<IOException> connectExceptions = new ArrayList<IOException>();
+
+  public RouteException(IOException cause) {
+    super(cause);
+    connectExceptions.add(cause);
+  }
+
+  public IOException getLastConnectException() {
+    return connectExceptions.get(connectExceptions.size() - 1);
+  }
+
+  public void addConnectException(IOException e) {
+    connectExceptions.add(e);
+  }
+}
@@ -16,7 +16,6 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
-import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Route;
@@ -30,13 +29,10 @@
 import java.net.SocketAddress;
 import java.net.SocketException;
 import java.net.URI;
-import java.net.UnknownServiceException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -51,12 +47,10 @@ public final class RouteSelector {
   private final Network network;
   private final OkHttpClient client;
   private final RouteDatabase routeDatabase;
-  private final Request request;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
   private InetSocketAddress lastInetSocketAddress;
-  private ConnectionSpec lastSpec;
 
   /* State for negotiating the next proxy to use. */
   private List<Proxy> proxies = Collections.emptyList();
@@ -66,59 +60,48 @@ public final class RouteSelector {
   private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
   private int nextInetSocketAddressIndex;
 
-  /* Specs to attempt with the connection. */
-  private List<ConnectionSpec> connectionSpecs = Collections.emptyList();
-  private int nextSpecIndex;
-
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  private RouteSelector(Address address, URI uri, OkHttpClient client, Request request) {
+  private RouteSelector(Address address, URI uri, OkHttpClient client) {
     this.address = address;
     this.uri = uri;
     this.client = client;
     this.routeDatabase = Internal.instance.routeDatabase(client);
     this.network = Internal.instance.network(client);
-    this.request = request;
 
     resetNextProxy(uri, address.getProxy());
   }
 
   public static RouteSelector get(Address address, Request request, OkHttpClient client)
       throws IOException {
-    return new RouteSelector(address, request.uri(), client, request);
+    return new RouteSelector(address, request.uri(), client);
   }
 
   /**
    * Returns true if there's another route to attempt. Every address has at
    * least one route.
    */
   public boolean hasNext() {
-    return hasNextConnectionSpec()
-        || hasNextInetSocketAddress()
+    return hasNextInetSocketAddress()
         || hasNextProxy()
         || hasNextPostponed();
   }
 
   public Route next() throws IOException {
     // Compute the next route to attempt.
-    if (!hasNextConnectionSpec()) {
-      if (!hasNextInetSocketAddress()) {
-        if (!hasNextProxy()) {
-          if (!hasNextPostponed()) {
-            throw new NoSuchElementException();
-          }
-          return nextPostponed();
+    if (!hasNextInetSocketAddress()) {
+      if (!hasNextProxy()) {
+        if (!hasNextPostponed()) {
+          throw new NoSuchElementException();
         }
-        lastProxy = nextProxy();
+        return nextPostponed();
       }
-      lastInetSocketAddress = nextInetSocketAddress();
+      lastProxy = nextProxy();
     }
-    lastSpec = nextConnectionSpec();
+    lastInetSocketAddress = nextInetSocketAddress();
 
-    final boolean shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator(lastSpec);
-    Route route = new Route(address, lastProxy, lastInetSocketAddress, lastSpec,
-        shouldSendTlsFallbackIndicator);
+    Route route = new Route(address, lastProxy, lastInetSocketAddress);
     if (routeDatabase.shouldPostpone(route)) {
       postponedRoutes.add(route);
       // We will only recurse in order to skip previously failed routes. They will be tried last.
@@ -128,11 +111,6 @@ public Route next() throws IOException {
     return route;
   }
 
-  private boolean shouldSendTlsFallbackIndicator(ConnectionSpec connectionSpec) {
-    return connectionSpec != connectionSpecs.get(0)
-        && connectionSpec.isTls();
-  }
-
   /**
    * Clients should invoke this method when they encounter a connectivity
    * failure on a connection returned by this route selector.
@@ -144,20 +122,6 @@ public void connectFailed(Route failedRoute, IOException failure) {
     }
 
     routeDatabase.failed(failedRoute);
-
-    // If the previously returned route's problem was not related to the connection's spec, and the
-    // next route only changes that, we shouldn't even attempt it. This suppresses it in both this
-    // selector and also in the route database.
-    if (!(failure instanceof SSLHandshakeException) && !(failure instanceof SSLProtocolException)) {
-      while (nextSpecIndex < connectionSpecs.size()) {
-        ConnectionSpec connectionSpec = connectionSpecs.get(nextSpecIndex++);
-        final boolean shouldSendTlsFallbackIndicator =
-            shouldSendTlsFallbackIndicator(connectionSpec);
-        Route toSuppress = new Route(address, lastProxy, lastInetSocketAddress, connectionSpec,
-            shouldSendTlsFallbackIndicator);
-        routeDatabase.failed(toSuppress);
-      }
-    }
   }
 
   /** Prepares the proxy servers to try. */
@@ -224,6 +188,7 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
       inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
     }
+
     nextInetSocketAddressIndex = 0;
   }
 
@@ -256,42 +221,7 @@ private InetSocketAddress nextInetSocketAddress() throws IOException {
       throw new SocketException(""No route to "" + address.getUriHost()
           + ""; exhausted inet socket addresses: "" + inetSocketAddresses);
     }
-    InetSocketAddress result = inetSocketAddresses.get(nextInetSocketAddressIndex++);
-    resetConnectionSpecs();
-    return result;
-  }
-
-  /** Prepares the connection specs to attempt. */
-  private void resetConnectionSpecs() {
-    connectionSpecs = new ArrayList<>();
-    List<ConnectionSpec> specs = address.getConnectionSpecs();
-    for (int i = 0, size = specs.size(); i < size; i++) {
-      ConnectionSpec spec = specs.get(i);
-      if (request.isHttps() == spec.isTls()) {
-        connectionSpecs.add(spec);
-      }
-    }
-    nextSpecIndex = 0;
-  }
-
-  /** Returns true if there's another connection spec to try. */
-  private boolean hasNextConnectionSpec() {
-    return nextSpecIndex < connectionSpecs.size();
-  }
-
-  /** Returns the next connection spec to try. */
-  private ConnectionSpec nextConnectionSpec() throws IOException {
-    if (connectionSpecs.isEmpty()) {
-      throw new UnknownServiceException(""No route to ""
-          + ((uri.getScheme() != null) ? (uri.getScheme() + ""://"") : ""//"") + address.getUriHost()
-          + ""; no connection specs"");
-    }
-    if (!hasNextConnectionSpec()) {
-      throw new SocketException(""No route to ""
-          + ((uri.getScheme() != null) ? (uri.getScheme() + ""://"") : ""//"") + address.getUriHost()
-          + ""; exhausted connection specs: "" + connectionSpecs);
-    }
-    return connectionSpecs.get(nextSpecIndex++);
+    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
   }
 
   /** Returns true if there is another postponed route to try. */
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Address;
+import com.squareup.okhttp.CertificatePinner;
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.Route;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.ConnectionSpecSelector;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.Socket;
+import java.net.URL;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+import okio.Source;
+
+import static com.squareup.okhttp.internal.Util.closeQuietly;
+import static com.squareup.okhttp.internal.Util.getDefaultPort;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+
+/**
+ * Helper that can establish a socket connection to a {@link com.squareup.okhttp.Route} using the
+ * specified {@link ConnectionSpec} set. A {@link SocketConnector} can be used multiple times.
+ */
+public class SocketConnector {
+  private final Connection connection;
+  private final ConnectionPool connectionPool;
+
+  public SocketConnector(Connection connection, ConnectionPool connectionPool) {
+    this.connection = connection;
+    this.connectionPool = connectionPool;
+  }
+
+  public ConnectedSocket connectCleartext(int connectTimeout, int readTimeout, Route route)
+      throws RouteException {
+    Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
+    return new ConnectedSocket(route, socket);
+  }
+
+  public ConnectedSocket connectTls(int connectTimeout, int readTimeout,
+      int writeTimeout, Request request, Route route, List<ConnectionSpec> connectionSpecs,
+      boolean connectionRetryEnabled) throws RouteException {
+
+    Address address = route.getAddress();
+    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+    RouteException routeException = null;
+    do {
+      Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
+      if (route.requiresTunnel()) {
+        createTunnel(readTimeout, writeTimeout, request, route, socket);
+      }
+
+      SSLSocket sslSocket = null;
+      try {
+        SSLSocketFactory sslSocketFactory = address.getSslSocketFactory();
+
+        // Create the wrapper over the connected socket.
+        sslSocket = (SSLSocket) sslSocketFactory
+            .createSocket(socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
+
+        // Configure the socket's ciphers, TLS versions, and extensions.
+        ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+        Platform platform = Platform.get();
+        Handshake handshake = null;
+        Protocol alpnProtocol = null;
+        try {
+          if (connectionSpec.supportsTlsExtensions()) {
+            platform.configureTlsExtensions(
+                sslSocket, address.getUriHost(), address.getProtocols());
+          }
+          // Force handshake. This can throw!
+          sslSocket.startHandshake();
+
+          handshake = Handshake.get(sslSocket.getSession());
+
+          String maybeProtocol;
+          if (connectionSpec.supportsTlsExtensions()
+              && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
+            alpnProtocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
+          }
+        } finally {
+          platform.afterHandshake(sslSocket);
+        }
+
+        // Verify that the socket's certificates are acceptable for the target host.
+        if (!address.getHostnameVerifier().verify(address.getUriHost(), sslSocket.getSession())) {
+          X509Certificate cert = (X509Certificate) sslSocket.getSession()
+              .getPeerCertificates()[0];
+          throw new SSLPeerUnverifiedException(
+              ""Hostname "" + address.getUriHost() + "" not verified:""
+              + ""\n    certificate: "" + CertificatePinner.pin(cert)
+              + ""\n    DN: "" + cert.getSubjectDN().getName()
+              + ""\n    subjectAltNames: "" + OkHostnameVerifier.allSubjectAltNames(cert));
+        }
+
+        // Check that the certificate pinner is satisfied by the certificates presented.
+        address.getCertificatePinner().check(address.getUriHost(), handshake.peerCertificates());
+
+        return new ConnectedSocket(route, sslSocket, alpnProtocol, handshake);
+      } catch (IOException e) {
+        boolean canRetry = connectionRetryEnabled && connectionSpecSelector.connectionFailed(e);
+        closeQuietly(sslSocket);
+        closeQuietly(socket);
+        if (routeException == null) {
+          routeException = new RouteException(e);
+        } else {
+          routeException.addConnectException(e);
+        }
+        if (!canRetry) {
+          throw routeException;
+        }
+      }
+    } while (true);
+  }
+
+  private Socket connectRawSocket(int soTimeout, int connectTimeout, Route route)
+      throws RouteException {
+    Platform platform = Platform.get();
+    try {
+      Proxy proxy = route.getProxy();
+      Address address = route.getAddress();
+      Socket socket;
+      if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP) {
+        socket = address.getSocketFactory().createSocket();
+      } else {
+        socket = new Socket(proxy);
+      }
+      socket.setSoTimeout(soTimeout);
+      platform.connectSocket(socket, route.getSocketAddress(), connectTimeout);
+
+      return socket;
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
+   * CONNECT request to create the proxy connection. This may need to be
+   * retried if the proxy requires authorization.
+   */
+  private void createTunnel(int readTimeout, int writeTimeout, Request request, Route route,
+      Socket socket) throws RouteException {
+    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+    try {
+      Request tunnelRequest = createTunnelRequest(request);
+      HttpConnection tunnelConnection = new HttpConnection(connectionPool, connection, socket);
+      tunnelConnection.setTimeouts(readTimeout, writeTimeout);
+      URL url = tunnelRequest.url();
+      String requestLine = ""CONNECT "" + url.getHost() + "":"" + url.getPort() + "" HTTP/1.1"";
+      while (true) {
+        tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+        tunnelConnection.flush();
+        Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+        // The response body from a CONNECT should be empty, but if it is not then we should consume
+        // it before proceeding.
+        long contentLength = OkHeaders.contentLength(response);
+        if (contentLength == -1L) {
+          contentLength = 0L;
+        }
+        Source body = tunnelConnection.newFixedLengthSource(contentLength);
+        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+        body.close();
+
+        switch (response.code()) {
+          case HTTP_OK:
+            // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+            // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+            // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+            // that it will almost certainly fail because the proxy has sent unexpected data.
+            if (tunnelConnection.bufferSize() > 0) {
+              throw new IOException(""TLS tunnel buffered too many bytes!"");
+            }
+            return;
+
+          case HTTP_PROXY_AUTH:
+            tunnelRequest = OkHeaders.processAuthHeader(
+                route.getAddress().getAuthenticator(), response, route.getProxy());
+            if (tunnelRequest != null) continue;
+            throw new IOException(""Failed to authenticate with proxy"");
+
+          default:
+            throw new IOException(
+                ""Unexpected response code for CONNECT: "" + response.code());
+        }
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
+   * no tunnel is necessary. Everything in the tunnel request is sent
+   * unencrypted to the proxy server, so tunnels include only the minimum set of
+   * headers. This avoids sending potentially sensitive data like HTTP cookies
+   * to the proxy unencrypted.
+   */
+  private Request createTunnelRequest(Request request) throws IOException {
+    String host = request.url().getHost();
+    int port = getEffectivePort(request.url());
+    String authority = (port == getDefaultPort(""https"")) ? host : (host + "":"" + port);
+    Request.Builder result = new Request.Builder()
+        .url(new URL(""https"", host, port, ""/""))
+        .header(""Host"", authority)
+        .header(""Proxy-Connection"", ""Keep-Alive""); // For HTTP/1.0 proxies like Squid.
+
+    // Copy over the User-Agent header if it exists.
+    String userAgent = request.header(""User-Agent"");
+    if (userAgent != null) {
+      result.header(""User-Agent"", userAgent);
+    }
+
+    // Copy over the Proxy-Authorization header if it exists.
+    String proxyAuthorization = request.header(""Proxy-Authorization"");
+    if (proxyAuthorization != null) {
+      result.header(""Proxy-Authorization"", proxyAuthorization);
+    }
+
+    return result.build();
+  }
+
+  /**
+   * A connected socket with metadata.
+   */
+  public static class ConnectedSocket {
+    public final Route route;
+    public final Socket socket;
+    public final Protocol alpnProtocol;
+    public final Handshake handshake;
+
+    /** A connected plain / raw (i.e. unencrypted communication) socket. */
+    public ConnectedSocket(Route route, Socket socket) {
+      this.route = route;
+      this.socket = socket;
+      alpnProtocol = null;
+      handshake = null;
+    }
+
+    /** A connected {@link SSLSocket}. */
+    public ConnectedSocket(Route route, SSLSocket socket, Protocol alpnProtocol,
+        Handshake handshake) {
+      this.route = route;
+      this.socket = socket;
+      this.alpnProtocol = alpnProtocol;
+      this.handshake = handshake;
+    }
+  }
+}
"
https://github.com/square/retrofit/commit/778a67e3c27226aecf5292ba4c3785a5d3c53067,Update README.md,https://api.github.com/repos/square/retrofit/commits/778a67e3c27226aecf5292ba4c3785a5d3c53067,"@@ -21,7 +21,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jaxb:latest.version'
+implementation 'com.squareup.retrofit2:converter-jaxb:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
"
https://github.com/apache/dubbo/commit/6140bc2a653cc3066d15ceeff5a3f06962fb32ad,"Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated. ",https://api.github.com/repos/apache/dubbo/commits/6140bc2a653cc3066d15ceeff5a3f06962fb32ad,"@@ -505,8 +505,6 @@ && isPrimitive(method.getReturnType())) {
                     }
                 }
             } catch (Exception e) {
-                System.out.println(this.getClass().getName());
-                System.out.println(method.getName());
                 throw new IllegalStateException(e.getMessage(), e);
             }
         }
@@ -56,8 +56,6 @@ public void init() {
         /**
          * Instead of using Dubbo's configuration, I would suggest use the original configuration method Apollo provides.
          */
-//        String configEnv = env.getCompositeConf().getString(ENV_KEY);
-//        String configCluster = env.getCompositeConf().getString(CLUSTER_KEY);
         String configEnv = url.getParameter(Constants.CONFIG_ENV_KEY);
         String configAddr = url.getBackupAddress();
         String configCluster = url.getParameter(Constants.CONFIG_CLUSTER_KEY);
@@ -39,6 +39,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
@@ -59,7 +60,7 @@ public class ZooKeeperConfigurationSource implements WatchedConfigurationSource,
     // The final root path would be: /configRootPath/""config""
     private final String configRootPath;
     private final TreeCache treeCache;
-    private boolean connected = false;
+    private CountDownLatch initializedLatch = new CountDownLatch(1);
 
     private final Charset charset = Charset.forName(""UTF-8"");
 
@@ -96,7 +97,7 @@ public ZooKeeperConfigurationSource(String connectString, int sessionTimeout, in
                 new ExponentialBackoffRetry(1000, 3));
         client.start();
         try {
-            connected = client.blockUntilConnected(connectTimeout, TimeUnit.MILLISECONDS);
+            boolean connected = client.blockUntilConnected(connectTimeout, TimeUnit.MILLISECONDS);
             if (!connected) {
                 boolean check = Boolean.parseBoolean(System.getProperty(ARCHAIUS_CONFIG_CHECK_KEY, ""false""));
                 if (check) {
@@ -138,8 +139,8 @@ public void childEvent(CuratorFramework aClient, TreeCacheEvent event)
 
                 TreeCacheEvent.Type type = event.getType();
                 ChildData data = event.getData();
-                if (type == TreeCacheEvent.Type.INITIALIZED || type == TreeCacheEvent.Type.CONNECTION_RECONNECTED) {
-                    connected = true;
+                if (type == TreeCacheEvent.Type.INITIALIZED) {
+                    initializedLatch.countDown();
                 }
 
                 // TODO, ignore other event types
@@ -202,9 +203,10 @@ public Map<String, Object> getCurrentData() throws Exception {
 
         Map<String, Object> all = new HashMap<>();
 
-        if (!connected) {
-            logger.warn(""ConfigCenter is not connected yet, zookeeper does't support local snapshot, so there's no backup data to use!"");
-            return all;
+        try {
+            initializedLatch.await();
+        } catch (InterruptedException e) {
+            logger.error(""Being interrupted unexpectedly when waiting zookeeper to initialize, the config data may not ready yet, be careful!"");
         }
 
         Map<String, ChildData> dataMap = treeCache.getCurrentChildren(configRootPath);
@@ -257,8 +259,4 @@ public void close() {
             logger.error(""IOException should not have been thrown."", exc);
         }
     }
-
-    public boolean isConnected() {
-        return connected;
-    }
 }
"
https://github.com/spring-projects/spring-boot/commit/deef784403419ed57cb733089c0326d8b0781dd2,"Blitz some more special characters from the metric names  <enter> When MVC path matchers are used as metric keys, they can still contain invalid characters and patterns (like asterisks). This change removes some more special characters and also tidies up the names a bit so no key part starts or ends with '-' (which is ugly). <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/deef784403419ed57cb733089c0326d8b0781dd2,"@@ -101,7 +101,7 @@ protected void doFilterInternal(HttpServletRequest request,
 					// not convertible
 				}
 				if (bestMatchingPattern != null) {
-					suffix = bestMatchingPattern.toString().replaceAll(""[{}]"", ""-"");
+					suffix = fixSpecialCharacters(bestMatchingPattern.toString());
 				}
 				else if (httpStatus.is4xxClientError()) {
 					suffix = UNKNOWN_PATH_SUFFIX;
@@ -114,6 +114,20 @@ else if (httpStatus.is4xxClientError()) {
 			}
 		}
 
+		private String fixSpecialCharacters(String value) {
+			String result = value.replaceAll(""[{}]"", ""-"");
+			result = result.replace(""**"", ""-star-star-"");
+			result = result.replace(""*"", ""-star-"");
+			result = result.replace(""/-"", ""/"");
+			if (result.endsWith(""-"")) {
+				result = result.substring(0, result.length() - 1);
+			}
+			if (result.startsWith(""-"")) {
+				result = result.substring(1);
+			}
+			return result;
+		}
+
 		private int getStatus(HttpServletResponse response) {
 			try {
 				return response.getStatus();
@@ -89,9 +89,9 @@ public void recordsHttpInteractionsWithTemplateVariable() throws Exception {
 		mvc.perform(get(""/templateVarTest/foo"")).andExpect(status().isOk());
 
 		verify(context.getBean(CounterService.class)).increment(
-				""status.200.templateVarTest.-someVariable-"");
+				""status.200.templateVarTest.someVariable"");
 		verify(context.getBean(GaugeService.class)).submit(
-				eq(""response.templateVarTest.-someVariable-""), anyDouble());
+				eq(""response.templateVarTest.someVariable""), anyDouble());
 		context.close();
 	}
 
@@ -106,9 +106,9 @@ public void recordsKnown404HttpInteractionsAsSingleMetricWithPathAndTemplateVari
 		mvc.perform(get(""/knownPath/foo"")).andExpect(status().isNotFound());
 
 		verify(context.getBean(CounterService.class)).increment(
-				""status.404.knownPath.-someVariable-"");
+				""status.404.knownPath.someVariable"");
 		verify(context.getBean(GaugeService.class)).submit(
-				eq(""response.knownPath.-someVariable-""), anyDouble());
+				eq(""response.knownPath.someVariable""), anyDouble());
 		context.close();
 	}
 
"
https://github.com/square/okhttp/commit/82f773376e19bb7e10916627349fad06e45f90cb,Add HTTP/2 and TLSv1.3 columns to our security providers doc ,https://api.github.com/repos/square/okhttp/commits/82f773376e19bb7e10916627349fad06e45f90cb,"@@ -4,12 +4,24 @@ Security Providers
 
 ## Provider Status
 
-| Provider            | Issues                                                | Link                                                        | Usage Guidance |
-| ------------------- | ----------------------------------------------------- | ----------------------------------------------------------- | -------------- |
-| Bouncy Castle       | [#5698](https://github.com/square/okhttp/issues/5698) | https://www.bouncycastle.org/java.html                      | Clean-Room JSSE implementation |
-| Conscrypt - Android | ✅                                                    |  https://www.conscrypt.org/                                 | TLS 1.3 via BoringSSL. Activated if Conscrypt is first registered provider. |
-| Conscrypt - OpenJDK | ✅                                                    | https://www.conscrypt.org/                                  | TLS 1.3 via BoringSSL. Activated if Conscrypt is first registered provider. |
-| OpenJSSE            | ✅ Missing HTTP/2                                     | https://github.com/openjsse/openjsse                        | Supports TLS 1.3 on Java SE 8 |
-| Corretto            | [#5592](https://github.com/square/okhttp/issues/5592) | https://github.com/corretto/amazon-corretto-crypto-provider | Amazon high-performance cryptographic implementations backed by OpenSSL |
+| Provider         | HTTP/2  | TLSv1.3      | Powered By      | Notes                                                        |
+| :--------------- | :------ | :----------- | :-------------- | :----------------------------------------------------------- |
+| JVM default      | Java 9+ | Java 11+     | [OpenJDK]       |                                                              |
+| Android default  | ✅      | Android 10+  | [BoringSSL]     |                                                              |
+| [Bouncy Castle]  | ✅      |              | [Bouncy Castle] | [Tracking bug.][bug5698]                                     |
+| [Conscrypt]      | ✅      | ✅           | [BoringSSL]     | Activated if Conscrypt is first registered provider.         |
+| [OpenJSSE]       |         | ✅           | [OpenJDK]       | OpenJDK backport.                                            |
+| [Corretto]       | ✅      | ✅           | [OpenSSL]       | Amazon's high-performance provider. [Tracking bug.][bug5592] |
 
+All providers support HTTP/1.1 and TLSv1.2.
 
+
+[BoringSSL]: https://boringssl.googlesource.com/boringssl/
+[Bouncy Castle]: https://www.bouncycastle.org/java.html
+[Conscrypt]: https://www.conscrypt.org/
+[Corretto]: https://github.com/corretto/amazon-corretto-crypto-provider
+[OpenJDK]: https://openjdk.java.net/groups/security/
+[OpenJSSE]: https://github.com/openjsse/openjsse
+[OpenSSL]: https://www.openssl.org/
+[bug5592]: https://github.com/square/okhttp/issues/5592
+[bug5698]: https://github.com/square/okhttp/issues/5698
"
https://github.com/junit-team/junit4/commit/4411c102d489c2272d7e38606e912a54be4defa8,"Restore folder `javadoc/latest` for Javadoc.  <enter> This folder has been used for many years. There are links to Javadoc at that folder (e.g.  http://stackoverflow.com/questions/156503/how-do-you-assert-that-a-certain-exception-is-thrown-in-junit-4-tests/2935935#2935935  ). Restoring the folder `javadoc/latest` will hopefully restore the Javadoc pages in Google Search, too. ",https://api.github.com/repos/junit-team/junit4/commits/4411c102d489c2272d7e38606e912a54be4defa8,"@@ -383,6 +383,7 @@
                 <artifactId>maven-javadoc-plugin</artifactId>
                 <version>2.9.1</version>
                 <configuration>
+                    <destDir>javadoc/latest</destDir>
                     <stylesheetfile>${basedir}/src/main/javadoc/stylesheet.css</stylesheetfile>
                     <show>protected</show>
                     <author>false</author>
@@ -88,7 +88,7 @@
             <li><a href=""https://github.com/junit-team/junit/wiki/Maintainer-documentation"">Maintainer Documentation</a></li>
             <li><a href=""https://github.com/junit-team/junit/wiki/I-want-to-help%21"">I want to help!</a></li>
             <li><a href=""http://stackoverflow.com/questions/tagged/junit"">Latest JUnit Questions on StackOverflow</a></li>
-            <li><a href=""./apidocs/"">JavaDocs</a></li>
+            <li><a href=""javadoc/latest/index.html"">JavaDocs</a></li>
             <li><a href=""./faq.html"">Frequently asked questions</a></li>
             <li><a href=""https://github.com/junit-team/junit/wiki"">Wiki</a></li>
           </ul>
"
https://github.com/square/okhttp/commit/6a79c3223c5ff2d556bbab8eb9909fffc4ca4387,Update README.md -> Mockito moved to Github ,https://api.github.com/repos/square/okhttp/commits/6a79c3223c5ff2d556bbab8eb9909fffc4ca4387,"@@ -19,7 +19,7 @@ awkward-to-reproduce situations like 500 errors or slow-loading responses.
 ### Example
 
 Use MockWebServer the same way that you use mocking frameworks like
-[Mockito](https://code.google.com/p/mockito/):
+[Mockito](https://github.com/mockito/mockito):
 
 1. Script the mocks.
 2. Run application code.
"
https://github.com/apache/dubbo/commit/635bc7983287d47d1d2c637a85fe21aabacdcd27,Remove the shutdown logic from spring bean destroy to avoid competition. ,https://api.github.com/repos/apache/dubbo/commits/635bc7983287d47d1d2c637a85fe21aabacdcd27,"@@ -16,10 +16,16 @@
  */
 package com.alibaba.dubbo.config.spring;
 
-import com.alibaba.dubbo.config.*;
+import com.alibaba.dubbo.config.ApplicationConfig;
+import com.alibaba.dubbo.config.ConsumerConfig;
+import com.alibaba.dubbo.config.ModuleConfig;
+import com.alibaba.dubbo.config.MonitorConfig;
+import com.alibaba.dubbo.config.ReferenceConfig;
+import com.alibaba.dubbo.config.RegistryConfig;
 import com.alibaba.dubbo.config.annotation.Reference;
 import com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory;
 import com.alibaba.dubbo.config.support.Parameter;
+
 import org.springframework.beans.factory.BeanFactoryUtils;
 import org.springframework.beans.factory.DisposableBean;
 import org.springframework.beans.factory.FactoryBean;
@@ -167,4 +173,8 @@ public void afterPropertiesSet() throws Exception {
         }
     }
 
+    @Override
+    public void destroy() {
+        // do nothing
+    }
 }
\ No newline at end of file
@@ -16,9 +16,16 @@
  */
 package com.alibaba.dubbo.config.spring;
 
-import com.alibaba.dubbo.config.*;
+import com.alibaba.dubbo.config.ApplicationConfig;
+import com.alibaba.dubbo.config.ModuleConfig;
+import com.alibaba.dubbo.config.MonitorConfig;
+import com.alibaba.dubbo.config.ProtocolConfig;
+import com.alibaba.dubbo.config.ProviderConfig;
+import com.alibaba.dubbo.config.RegistryConfig;
+import com.alibaba.dubbo.config.ServiceConfig;
 import com.alibaba.dubbo.config.annotation.Service;
 import com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory;
+
 import org.springframework.beans.factory.BeanFactoryUtils;
 import org.springframework.beans.factory.BeanNameAware;
 import org.springframework.beans.factory.DisposableBean;
@@ -255,7 +262,9 @@ && getInterface() != null && getInterface().length() > 0
     }
 
     public void destroy() throws Exception {
-        unexport();
+        // This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.
+        // We will guarantee dubbo related resources being released with dubbo shutdown hook.
+        //unexport();
     }
 
 }
\ No newline at end of file
@@ -21,6 +21,8 @@
 import com.alibaba.dubbo.common.extension.ExtensionLoader;
 import com.alibaba.dubbo.common.logger.Logger;
 import com.alibaba.dubbo.common.logger.LoggerFactory;
+import com.alibaba.dubbo.common.utils.ConfigUtils;
+import com.alibaba.dubbo.common.utils.NamedThreadFactory;
 import com.alibaba.dubbo.common.utils.StringUtils;
 import com.alibaba.dubbo.common.utils.UrlUtils;
 import com.alibaba.dubbo.registry.NotifyListener;
@@ -42,6 +44,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
 import static com.alibaba.dubbo.common.Constants.ACCEPT_FOREIGN_IP;
 import static com.alibaba.dubbo.common.Constants.QOS_ENABLE;
@@ -147,30 +151,7 @@ public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcExceptio
         overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
         registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
         //Ensure that a new exporter instance is returned every time export
-        return new Exporter<T>() {
-            public Invoker<T> getInvoker() {
-                return exporter.getInvoker();
-            }
-
-            public void unexport() {
-                try {
-                    exporter.unexport();
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-                try {
-                    registry.unregister(registedProviderUrl);
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-                try {
-                    overrideListeners.remove(overrideSubscribeUrl);
-                    registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-            }
-        };
+        return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);
     }
 
     @SuppressWarnings(""unchecked"")
@@ -471,4 +452,56 @@ public void unexport() {
             exporter.unexport();
         }
     }
+
+    static private class DestroyableExporter<T> implements Exporter<T> {
+
+        public static final ExecutorService executor = Executors.newSingleThreadExecutor(new NamedThreadFactory(""Exporter-Unexport"", true));
+
+        private Exporter<T> exporter;
+        private Invoker<T> originInvoker;
+        private URL subscribeUrl;
+        private URL registerUrl;
+
+        public DestroyableExporter(Exporter<T> exporter, Invoker<T> originInvoker, URL subscribeUrl, URL registerUrl) {
+            this.exporter = exporter;
+            this.originInvoker = originInvoker;
+            this.subscribeUrl = subscribeUrl;
+            this.registerUrl = registerUrl;
+        }
+
+        public Invoker<T> getInvoker() {
+            return exporter.getInvoker();
+        }
+
+        public void unexport() {
+            Registry registry = RegistryProtocol.INSTANCE.getRegistry(originInvoker);
+            try {
+                registry.unregister(registerUrl);
+            } catch (Throwable t) {
+                logger.warn(t.getMessage(), t);
+            }
+            try {
+                NotifyListener listener = RegistryProtocol.INSTANCE.overrideListeners.remove(subscribeUrl);
+                registry.unsubscribe(subscribeUrl, listener);
+            } catch (Throwable t) {
+                logger.warn(t.getMessage(), t);
+            }
+
+            executor.submit(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        int timeout = ConfigUtils.getServerShutdownTimeout();
+                        if (timeout > 0) {
+                            logger.info(""Waiting "" + timeout + ""ms for registry to notify all consumers before unexport. Usually, this is called when you use dubbo API"");
+                            Thread.sleep(timeout);
+                        }
+                        exporter.unexport();
+                    } catch (Throwable t) {
+                        logger.warn(t.getMessage(), t);
+                    }
+                }
+            });
+        }
+    }
 }
\ No newline at end of file
@@ -113,7 +113,9 @@ public void testNotifyOverride() throws Exception {
         assertEquals(""y"", exporter.getInvoker().getUrl().getParameter(""x""));
 
         exporter.unexport();
-        assertEquals(false, exporter.getInvoker().isAvailable());
+//        int timeout = ConfigUtils.getServerShutdownTimeout();
+//        Thread.sleep(timeout + 1000);
+//        assertEquals(false, exporter.getInvoker().isAvailable());
         destroyRegistryProtocol();
 
     }
"
https://github.com/junit-team/junit4/commit/87245d66c7a17b27478da3bf7030e1b2dc86da55,Added script for uploading docs ,https://api.github.com/repos/junit-team/junit4/commits/87245d66c7a17b27478da3bf7030e1b2dc86da55,"@@ -124,5 +124,6 @@
 			<fileset dir=""${dist}"" includes=""*.jar"" />
 			<fileset file=""${zipfile}"" />
 		</ftp>
+		<echo message=""To upload docs, use build/upload_docs.sh"" />
 	</target>
 </project>
@@ -0,0 +1 @@
+scp -r ../doc/* dsaff@shell.sourceforge.net:/home/groups/j/ju/junit/htdocs/doc
\ No newline at end of file
"
https://github.com/junit-team/junit4/commit/4cb9a65f450efa5f2a42128856c7b56e6d283386,"Fixed a bug in Theories classes with constructor parameters, where the method parameters and constructor parameters were switched ",https://api.github.com/repos/junit-team/junit4/commits/4cb9a65f450efa5f2a42128856c7b56e6d283386,"@@ -9,7 +9,7 @@ private Version() {
 	}
 
 	public static String id() {
-		return ""4.5-SNAPSHOT-20070904-1400"";
+		return ""4.5-SNAPSHOT-20071012-1919"";
 	}
 	
 	public static void main(String[] args) {
@@ -8,7 +8,6 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.List;
 
 
@@ -23,7 +22,7 @@ public static ArrayList<ParameterSignature> signatures(Method method) {
 	}
 
 
-	public static Collection<? extends ParameterSignature> signatures(
+	public static List<ParameterSignature> signatures(
 			Constructor<?> constructor) {
 		// TODO: (Oct 12, 2007 12:33:06 PM) handle DUP above
 		ArrayList<ParameterSignature> sigs= new ArrayList<ParameterSignature>();
@@ -93,12 +93,60 @@ protected void collectInitializationErrors(
 						// do nothing
 					}
 					
+					@Override
+					public Statement chain(TestMethod method) {
+						// TODO: (Oct 12, 2007 2:00:52 PM) Name this Link
+						final Statement link= super.chain(method);
+						return new Statement() {
+						
+							@Override
+							public void evaluate() throws Throwable {
+								try {
+									link.evaluate();
+									successes++;
+								} catch (AssumptionViolatedException e) {
+									// TODO: (Oct 12, 2007 2:07:01 PM) DUP? even correct?
+									// do nothing
+								} catch (Throwable e) {
+									 // TODO: (Oct 12, 2007 2:04:01 PM) nullsOk as argument to Assignments constructor
+
+										reportParameterizedError(e, complete.getAllArguments(nullsOk()));
+									}
+								// TODO Auto-generated method stub
+						
+							}
+						
+						};
+					}
+					
 					@Override
 					protected Statement invoke(TestMethod method, Object test) {
 						// TODO: (Oct 12, 2007 12:07:28 PM) push method in
 						return methodCompletesWithParameters(complete, test);
 					}
 					
+					@Override
+					protected Statement ignoreViolatedAssumptions(final Statement next) {
+						// TODO: (Oct 12, 2007 2:15:02 PM) name this
+
+						return new Statement() {
+						
+							@Override
+							public void evaluate() throws Throwable {
+								try {
+									next.evaluate();						
+								} catch (AssumptionViolatedException e) {
+									// TODO: (Oct 12, 2007 2:19:52 PM) This feels hacky
+
+									successes--;
+									handleAssumptionViolation(e);
+									// TODO: (Oct 12, 2007 2:15:44 PM) Can I remove other calls?
+
+								}
+							}
+						};
+					}
+					
 					@Override
 					public Object createTest() throws Exception {
 						// TODO: (Oct 12, 2007 12:31:12 PM) DUP
@@ -132,14 +180,11 @@ public void evaluate() throws Throwable {
 		private void invokeWithActualParameters(Object target,
 				Assignments complete) throws Throwable {
 			final Object[] values= complete.getMethodArguments(nullsOk(), target);
-			try {
+//			try {
 				fTestMethod.invokeExplosively(target, values);
-				successes++;
-			} catch (AssumptionViolatedException e) {
-				handleAssumptionViolation(e);
-			} catch (Throwable e) {
-				reportParameterizedError(e, values);
-			}
+//			} catch (AssumptionViolatedException e) {
+//				handleAssumptionViolation(e);
+//			}
 		}
 
 		protected void handleAssumptionViolation(AssumptionViolatedException e) {
@@ -32,8 +32,8 @@ public Assignments(List<PotentialAssignment> assigned,
 
 	public static Assignments allUnassigned(Method testMethod,
 			Class<?> testClass) {
-		ArrayList<ParameterSignature> signatures= ParameterSignature.signatures(testMethod);
-		signatures.addAll(ParameterSignature.signatures(testClass.getConstructors()[0]));
+		List<ParameterSignature> signatures= ParameterSignature.signatures(testClass.getConstructors()[0]);
+		signatures.addAll(ParameterSignature.signatures(testMethod));
 		return new Assignments(new ArrayList<PotentialAssignment>(),
 				signatures, testClass);
 	}
@@ -57,9 +57,10 @@ public Assignments assignNext(PotentialAssignment source) {
 	public Object[] getActualValues(boolean nullsOk, int start, int stop) throws CouldNotGenerateValueException {
 		Object[] values= new Object[stop - start];
 		for (int i= start; i < stop; i++) {
-			values[i]= fAssigned.get(i).getValue();
-			if (values[i] == null && !nullsOk)
+			Object value= fAssigned.get(i).getValue();
+			if (value == null && !nullsOk)
 				throw new CouldNotGenerateValueException();
+			values[i - start]= value;
 		}
 		return values;
 	}
@@ -110,4 +111,8 @@ public Object[] getMethodArguments(boolean nullsOk, Object target) throws CouldN
 		return getActualValues(nullsOk, getOnlyConstructor()
 				.getParameterTypes().length, fAssigned.size());
 	}
+
+	public Object[] getAllArguments(boolean nullsOk) throws CouldNotGenerateValueException {
+		return getActualValues(nullsOk, 0, fAssigned.size());
+	}
 }
\ No newline at end of file
@@ -8,7 +8,6 @@
 import org.junit.internal.runners.model.MultipleFailureException;
 import org.junit.internal.runners.model.TestElement;
 import org.junit.internal.runners.model.TestMethod;
-import org.junit.runner.notification.StoppedByUserException;
 
 public class RunAfters extends Statement {
 	private final Statement fNext;
@@ -28,8 +27,6 @@ public void evaluate() throws Throwable {
 		MultipleFailureException errors= new MultipleFailureException();
 		try {
 			fNext.evaluate();
-		} catch (StoppedByUserException e) {
-			throw e; // TODO this is ugly. if we can eliminate pleaseStop(), we can remove it
 		} catch (Throwable e) {
 			errors.add(e);
 		} finally {
@@ -8,9 +8,12 @@ public class MultipleFailureException extends Exception {
 	
 	private List<Throwable> fErrors = new ArrayList<Throwable>();
 	
-	public void assertEmpty() throws MultipleFailureException {
-		if (!fErrors.isEmpty())
-			throw this;
+	public void assertEmpty() throws Throwable {
+		if (fErrors.isEmpty())
+			return;
+		if (fErrors.size() == 1)
+			throw fErrors.get(0);
+		throw this;
 	}
 
 	public void add(Throwable e) {
@@ -13,7 +13,7 @@ public void runBefores(Object target) throws Throwable {
 				before.invokeExplosively(target);
 	}
 
-	public void runAfters(Object target) throws MultipleFailureException {
+	public void runAfters(Object target) throws Throwable {
 		MultipleFailureException errors= new MultipleFailureException();
 		
 		List<TestMethod> afters= getAfters();
@@ -12,13 +12,15 @@
 import org.junit.tests.experimental.theories.runner.WithDataPointFields;
 import org.junit.tests.experimental.theories.runner.WithDataPointMethod;
 import org.junit.tests.experimental.theories.runner.WithExtendedParameterSources;
+import org.junit.tests.experimental.theories.runner.WithOnlyTestAnnotations;
 
 @RunWith(Suite.class)
 @SuiteClasses( { ParameterizedAssertionErrorTest.class,
 		WithDataPointFields.class, PrintableResultTest.class,
 		ResultMatchersTest.class, WithDataPointMethod.class,
 		ParameterSignatureTest.class, WhenNoParametersMatch.class,
-		WithExtendedParameterSources.class, StubbedTheoriesTest.class })
+		WithExtendedParameterSources.class, StubbedTheoriesTest.class, 
+		WithOnlyTestAnnotations.class })
 public class ExperimentalTests {
 
 }
@@ -222,4 +222,53 @@ public void haveAPostiveSquare() {
 	public void honorConstructorAssumptions() {
 		assertThat(testResult(PositiveIntsWithNegativeField.class), isSuccessful());
 	}
+	
+	@RunWith(Theories.class)
+	public static class PositiveIntsWithMethodParams {
+		@DataPoint
+		public static final int ONE= 1;
+
+		private int x;
+
+		public PositiveIntsWithMethodParams(int x) {
+			assumeTrue(x > 0);
+			this.x= x;
+		}
+
+		@Theory
+		public void haveAPostiveSquare(int y) {
+			assumeTrue(y > 0);
+			assertTrue(x * y > 0);
+		}
+	}
+	
+	// TODO: (Oct 12, 2007 2:26:22 PM) Just run enclosed?
+
+	
+	@Test public void passParametersToBothConstructorAndMethod() {
+		assertThat(testResult(PositiveIntsWithMethodParams.class), isSuccessful());	
+	}
+	
+	@RunWith(Theories.class)
+	public static class DifferentTypesInConstructor {
+		@DataPoint
+		public static final int ONE= 1;
+
+		@DataPoint public static final String A = ""A"";
+		
+		public DifferentTypesInConstructor(int x) {
+		}
+
+		@Theory
+		public void yesIndeed(String a) {
+		}
+	}
+	
+	
+	@Test public void differentTypesForConstructorAndMethodOk() {
+		assertThat(testResult(DifferentTypesInConstructor.class), isSuccessful());	
+	}
+	
+	// TODO: (Oct 12, 2007 2:24:55 PM) Complex
+
 }
\ No newline at end of file
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertThat;
 import static org.junit.experimental.results.PrintableResult.testResult;
 import static org.junit.experimental.results.ResultMatchers.failureCountIs;
+import static org.junit.experimental.results.ResultMatchers.isSuccessful;
 import org.junit.Test;
 import org.junit.experimental.theories.Theories;
 import org.junit.runner.RunWith;
@@ -22,6 +23,19 @@ public void honorExpected() throws Exception {
 		assertThat(testResult(HonorExpectedException.class).getFailures()
 				.size(), is(1));
 	}
+	
+	@RunWith(Theories.class)
+	public static class HonorExpectedExceptionPasses {
+		@Test(expected= NullPointerException.class)
+		public void shouldThrow() {
+			throw new NullPointerException();
+		}
+	}
+
+	@Test
+	public void honorExpectedPassing() throws Exception {
+		assertThat(testResult(HonorExpectedExceptionPasses.class), isSuccessful());
+	}
 
 	@RunWith(Theories.class)
 	public static class HonorTimeout {
"
https://github.com/junit-team/junit4/commit/9ee381470d56efa800420e5e22721e402aca01c2,"Remove fast-tests maven target.  <enter> Many of our tests store data in static fields, so the tests cannot be run in parallel. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/junit-team/junit4/commits/9ee381470d56efa800420e5e22721e402aca01c2,"@@ -558,19 +558,5 @@
                 </plugins>
             </reporting>
         </profile>
-        <profile>
-            <id>fast-tests</id>
-            <build>
-                <plugins>
-                    <plugin>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <parallel>classes</parallel>
-                            <threadCountClasses>2</threadCountClasses>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
     </profiles>
 </project>
"
https://github.com/square/retrofit/commit/580d31ae906ac28f608427d4c4d2318a0e8b658a,Rename main class to Retrofit. ,https://api.github.com/repos/square/retrofit/commits/580d31ae906ac28f608427d4c4d2318a0e8b658a,"@@ -47,12 +47,12 @@ interface Service {
   private Service service;
 
   @Before public void setUp() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .callAdapterFactory(ObservableCallAdapterFactory.create())
         .build();
-    service = ra.create(Service.class);
+    service = retrofit.create(Service.class);
   }
 
   @Test public void bodySuccess200() {
@@ -4,11 +4,11 @@ Retrofit Converters
 Retrofit ships with a default converter for JSON that uses Gson but the library is content-format
 agnostic. The child modules contained herein are additional converters for other popular formats.
 
-To use, supply an instance of your desired converter when building your `RestAdapter` instance.
+To use, supply an instance of your desired converter when building your `Retrofit` instance.
 
 ```java
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setEndpoint(""https://api.example.com"")
-    .setConverter(new ProtoConverter())
+Retrofit retrofit = new Retrofit.Builder()
+    .endpoint(""https://api.example.com"")
+    .converter(new ProtoConverter())
     .build();
 ```
@@ -18,7 +18,7 @@
 /**
  * An exception used to trigger the simulation of an HTTP error for mock services.
  *
- * @see MockRestAdapter
+ * @see MockRetrofit
  */
 public class MockHttpException extends RuntimeException {
   /** Create a new {@link MockHttpException} for HTTP 301 Moved Permanently. */
@@ -38,15 +38,15 @@
  * </pre>
  * Given a {@link RestAdapter} an instance of this class can be created by calling {@link #from}.
  * <pre>
- *   MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
+ *   MockRetrofit mockRetrofit = MockRetrofit.from(restAdapter);
  * </pre>
  * Instances of this class should be used as a singleton so that the behavior of every mock service
  * is consistent.
  * <p>
  * Rather than using the {@code MockUserService} directly, pass it through
  * {@link #create(Class, Object) the create method}.
  * <pre>
- *   UserService service = mockRestAdapter.create(UserService.class, new MockUserService());
+ *   UserService service = mockRetrofit.create(UserService.class, new MockUserService());
  * </pre>
  * The returned {@code UserService} instance will now behave like it is happening over the network
  * while allowing the mock implementation to be written synchronously.
@@ -55,18 +55,18 @@
  * {@link MockHttpException}. This should be done for both synchronous and asynchronous methods.
  * Do not call the {@link Callback#failure(RetrofitError) failure()} method of a callback.
  */
-public final class MockRestAdapter {
+public final class MockRetrofit {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PCT = 40; // Network delay varies by ±40%.
   private static final int DEFAULT_ERROR_PCT = 3; // 3% of network calls will fail.
   private static final int ERROR_DELAY_FACTOR = 3; // Network errors will be scaled by this value.
 
   /**
-   * Create a new {@link MockRestAdapter} which will act as a factory for mock services. Some of
+   * Create a new {@link MockRetrofit} which will act as a factory for mock services. Some of
    * the configuration of the supplied {@link RestAdapter} will be used generating mock behavior.
    */
-  public static MockRestAdapter from(RestAdapter restAdapter, Executor executor) {
-    return new MockRestAdapter(restAdapter, executor);
+  public static MockRetrofit from(RestAdapter restAdapter, Executor executor) {
+    return new MockRetrofit(restAdapter, executor);
   }
 
   private final RestAdapter restAdapter;
@@ -77,7 +77,7 @@ public static MockRestAdapter from(RestAdapter restAdapter, Executor executor) {
   private int variancePct = DEFAULT_VARIANCE_PCT;
   private int errorPct = DEFAULT_ERROR_PCT;
 
-  private MockRestAdapter(RestAdapter restAdapter, Executor executor) {
+  private MockRetrofit(RestAdapter restAdapter, Executor executor) {
     this.restAdapter = restAdapter;
     this.executor = executor;
   }
@@ -27,7 +27,7 @@
 import static org.mockito.Mockito.verifyZeroInteractions;
 import static retrofit.Utils.SynchronousExecutor;
 
-public class MockRestAdapterTest {
+public class MockRetrofitTest {
   interface SyncExample {
     @GET(""/"") Object doStuff();
   }
@@ -48,7 +48,7 @@ interface ObservableExample {
 
   private Executor httpExecutor;
   private Executor callbackExecutor;
-  private MockRestAdapter mockRestAdapter;
+  private MockRetrofit mockRetrofit;
   private Throwable nextError;
 
   @Before public void setUp() throws IOException {
@@ -70,21 +70,21 @@ interface ObservableExample {
         })
         .build();
 
-    mockRestAdapter = MockRestAdapter.from(restAdapter, httpExecutor);
+    mockRetrofit = MockRetrofit.from(restAdapter, httpExecutor);
 
     // Seed the random with a value so the tests are deterministic.
-    mockRestAdapter.random.setSeed(2847);
+    mockRetrofit.random.setSeed(2847);
   }
 
   @Test public void delayRestrictsRange() {
     try {
-      mockRestAdapter.setDelay(-1);
+      mockRetrofit.setDelay(-1);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Delay must be positive value."");
     }
     try {
-      mockRestAdapter.setDelay(Long.MAX_VALUE);
+      mockRetrofit.setDelay(Long.MAX_VALUE);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageStartingWith(""Delay value too large."");
@@ -93,13 +93,13 @@ interface ObservableExample {
 
   @Test public void varianceRestrictsRange() {
     try {
-      mockRestAdapter.setVariancePercentage(-13);
+      mockRetrofit.setVariancePercentage(-13);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Variance percentage must be between 0 and 100."");
     }
     try {
-      mockRestAdapter.setVariancePercentage(174);
+      mockRetrofit.setVariancePercentage(174);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Variance percentage must be between 0 and 100."");
@@ -108,48 +108,48 @@ interface ObservableExample {
 
   @Test public void errorRestrictsRange() {
     try {
-      mockRestAdapter.setErrorPercentage(-13);
+      mockRetrofit.setErrorPercentage(-13);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Error percentage must be between 0 and 100."");
     }
     try {
-      mockRestAdapter.setErrorPercentage(174);
+      mockRetrofit.setErrorPercentage(174);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Error percentage must be between 0 and 100."");
     }
   }
 
   @Test public void errorPercentageIsAccurate() {
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setErrorPercentage(0);
     for (int i = 0; i < 10000; i++) {
-      assertThat(mockRestAdapter.calculateIsFailure()).isFalse();
+      assertThat(mockRetrofit.calculateIsFailure()).isFalse();
     }
 
-    mockRestAdapter.setErrorPercentage(3);
+    mockRetrofit.setErrorPercentage(3);
     int failures = 0;
     for (int i = 0; i < 100000; i++) {
-      if (mockRestAdapter.calculateIsFailure()) {
+      if (mockRetrofit.calculateIsFailure()) {
         failures += 1;
       }
     }
     assertThat(failures).isEqualTo(2964); // ~3% of 100k
   }
 
   @Test public void delayVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
+    mockRetrofit.setDelay(2000);
 
-    mockRestAdapter.setVariancePercentage(0);
+    mockRetrofit.setVariancePercentage(0);
     for (int i = 0; i < 100000; i++) {
-      assertThat(mockRestAdapter.calculateDelayForCall()).isEqualTo(2000);
+      assertThat(mockRetrofit.calculateDelayForCall()).isEqualTo(2000);
     }
 
-    mockRestAdapter.setVariancePercentage(40);
+    mockRetrofit.setVariancePercentage(40);
     int lowerBound = Integer.MAX_VALUE;
     int upperBound = Integer.MIN_VALUE;
     for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForCall();
+      int delay = mockRetrofit.calculateDelayForCall();
       if (delay > upperBound) {
         upperBound = delay;
       }
@@ -162,12 +162,12 @@ interface ObservableExample {
   }
 
   @Test public void errorVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
+    mockRetrofit.setDelay(2000);
 
     int lowerBound = Integer.MAX_VALUE;
     int upperBound = Integer.MIN_VALUE;
     for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForError();
+      int delay = mockRetrofit.calculateDelayForError();
       if (delay > upperBound) {
         upperBound = delay;
       }
@@ -180,16 +180,16 @@ interface ObservableExample {
   }
 
   @Test public void syncFailureTriggersNetworkError() {
-    mockRestAdapter.setErrorPercentage(100);
-    mockRestAdapter.setDelay(1);
+    mockRetrofit.setErrorPercentage(100);
+    mockRetrofit.setDelay(1);
 
     class MockSyncExample implements SyncExample {
       @Override public Object doStuff() {
         throw new AssertionError();
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     try {
       mockService.doStuff();
@@ -201,16 +201,16 @@ class MockSyncExample implements SyncExample {
   }
 
   @Test public void asyncFailureTriggersNetworkError() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setErrorPercentage(100);
+    mockRetrofit.setDelay(1);
+    mockRetrofit.setErrorPercentage(100);
 
     class MockAsyncExample implements AsyncExample {
       @Override public void doStuff(Callback<String> cb) {
         throw new AssertionError();
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
     mockService.doStuff(new Callback<String>() {
@@ -232,9 +232,9 @@ class MockAsyncExample implements AsyncExample {
   }
 
   @Test public void syncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     final AtomicBoolean called = new AtomicBoolean();
     final Object expected = new Object();
@@ -245,7 +245,7 @@ class MockSyncExample implements SyncExample {
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     long startNanos = System.nanoTime();
     Object actual = mockService.doStuff();
@@ -257,9 +257,9 @@ class MockSyncExample implements SyncExample {
   }
 
   @Test public void asyncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Hi"");
@@ -270,7 +270,7 @@ class MockAsyncExample implements AsyncExample {
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -294,9 +294,9 @@ class MockAsyncExample implements AsyncExample {
   }
 
   @Test public void observableApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Hello"");
@@ -308,7 +308,7 @@ class MockObservableExample implements ObservableExample {
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -336,9 +336,9 @@ class MockObservableExample implements ObservableExample {
 
 
   @Test public void syncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Hello"");
@@ -349,7 +349,7 @@ class MockSyncExample implements SyncExample {
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     long startNanos = System.nanoTime();
     try {
@@ -367,9 +367,9 @@ class MockSyncExample implements SyncExample {
   }
 
   @Test public void asyncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Greetings"");
@@ -380,7 +380,7 @@ class MockAsyncExample implements AsyncExample {
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -409,9 +409,9 @@ class MockAsyncExample implements AsyncExample {
   }
 
   @Test public void observableHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Hi"");
@@ -423,7 +423,7 @@ class MockObservableExample implements ObservableExample {
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -453,9 +453,9 @@ class MockObservableExample implements ObservableExample {
   }
 
   @Test public void nullBodyIsAllowedOnHttpException() throws Exception {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
       @Override public Observable<String> doStuff() {
@@ -464,7 +464,7 @@ class MockObservableExample implements ObservableExample {
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -494,17 +494,17 @@ class MockObservableExample implements ObservableExample {
   }
 
   @Test public void syncErrorUsesErrorHandler() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockSyncExample implements SyncExample {
       @Override public Object doStuff() {
         throw MockHttpException.newNotFound(new Object());
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
     nextError = new IllegalArgumentException(""Test"");
 
     try {
@@ -516,17 +516,17 @@ class MockSyncExample implements SyncExample {
   }
 
   @Test public void asyncErrorUsesErrorHandler() throws InterruptedException {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockAsyncExample implements AsyncExample {
       @Override public void doStuff(Callback<String> cb) {
         throw MockHttpException.newNotFound(new Object());
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
     nextError = new IllegalArgumentException(""Test"");
 
     final CountDownLatch latch = new CountDownLatch(1);
@@ -544,9 +544,9 @@ class MockAsyncExample implements AsyncExample {
   }
 
   @Test public void observableErrorUsesErrorHandler() throws InterruptedException {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
       @Override public Observable<String> doStuff() {
@@ -555,7 +555,7 @@ class MockObservableExample implements ObservableExample {
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
     nextError = new IllegalArgumentException(""Test"");
 
     final CountDownLatch latch = new CountDownLatch(1);
@@ -573,9 +573,9 @@ class MockObservableExample implements ObservableExample {
   }
 
   @Test public void asyncCanUseCallbackSubtype() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(1);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockAsyncCallbackSubtypeExample implements AsyncCallbackSubtypeExample {
       @Override public void doStuff(Foo foo) {
@@ -584,7 +584,7 @@ class MockAsyncCallbackSubtypeExample implements AsyncCallbackSubtypeExample {
     }
 
     AsyncCallbackSubtypeExample mockService =
-        mockRestAdapter.create(AsyncCallbackSubtypeExample.class,
+        mockRetrofit.create(AsyncCallbackSubtypeExample.class,
             new MockAsyncCallbackSubtypeExample());
 
     final AtomicReference<String> actual = new AtomicReference<>();
@@ -19,7 +19,7 @@
  * Communicates responses from a server or offline requests. One and only one method will be
  * invoked in response to a given request.
  * <p>
- * Callback methods are executed using the {@link RestAdapter} callback executor. When none is
+ * Callback methods are executed using the {@link Retrofit} callback executor. When none is
  * specified, the following defaults are used:
  * <ul>
  * <li>Android: Callbacks are executed on the application's main (UI) thread.</li>
@@ -233,7 +233,7 @@ private void parseResponseType() {
       throw methodError(""Method response type is ""
           + responseType
           + "" but no converter registered. ""
-          + ""Either add a converter to the RestAdapter or use ResponseBody."");
+          + ""Either add a converter to the Retrofit instance or use ResponseBody."");
     }
 
     this.adapter = adapter;
@@ -295,7 +295,7 @@ private void parseParameters() {
               throw parameterError(i, ""@Part parameter is ""
                   + methodParameterType
                   + "" but no converter registered. ""
-                  + ""Either add a converter to the RestAdapter or use RequestBody."");
+                  + ""Either add a converter to the Retrofit instance or use RequestBody."");
             }
 
             gotPart = true;
@@ -321,7 +321,7 @@ private void parseParameters() {
               throw parameterError(i, ""@Body parameter is ""
                   + methodParameterType
                   + "" but no converter registered. ""
-                  + ""Either add a converter to the RestAdapter or use RequestBody."");
+                  + ""Either add a converter to the Retrofit instance or use RequestBody."");
             }
 
             requestType = methodParameterType;
@@ -84,14 +84,14 @@
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
  */
-public final class RestAdapter {
+public final class Retrofit {
   private final Map<Method, MethodInfo> methodInfoCache = new LinkedHashMap<>();
   private final OkHttpClient client;
   private final Endpoint endpoint;
   private final Converter converter;
   private final CallAdapter.Factory adapterFactory;
 
-  private RestAdapter(OkHttpClient client, Endpoint endpoint, Converter converter,
+  private Retrofit(OkHttpClient client, Endpoint endpoint, Converter converter,
       CallAdapter.Factory adapterFactory) {
     this.client = client;
     this.endpoint = endpoint;
@@ -160,7 +160,7 @@ public CallAdapter.Factory callAdapterFactory() {
   }
 
   /**
-   * Build a new {@link RestAdapter}.
+   * Build a new {@link Retrofit}.
    * <p>
    * Calling {@link #endpoint} is required before calling {@link #build()}. All other methods
    * are optional.
@@ -202,8 +202,8 @@ public Builder callAdapterFactory(CallAdapter.Factory adapterFactory) {
       return this;
     }
 
-    /** Create the {@link RestAdapter} instances. */
-    public RestAdapter build() {
+    /** Create the {@link Retrofit} instances. */
+    public Retrofit build() {
       checkNotNull(endpoint, ""Endpoint required."");
 
       // Set any platform-appropriate defaults for unspecified components.
@@ -214,7 +214,7 @@ public RestAdapter build() {
         adapterFactory = Platform.get().defaultCallAdapterFactory();
       }
 
-      return new RestAdapter(client, endpoint, converter, adapterFactory);
+      return new Retrofit(client, endpoint, converter, adapterFactory);
     }
   }
 }
@@ -19,14 +19,15 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import retrofit.Converter;
+import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
- * body). The object will be serialized using the {@link retrofit.RestAdapter RestAdapter}'s
+ * body). The object will be serialized using the {@link Retrofit Retrofit} instance
  * {@link Converter Converter} and the result will be set directly as the
  * request body.
  * <p>
@@ -46,11 +46,11 @@ interface Service {
   }
 
   @Test public void http200Sync() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -60,11 +60,11 @@ interface Service {
   }
 
   @Test public void http200Async() throws InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -88,11 +88,11 @@ interface Service {
   }
 
   @Test public void http404Sync() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
@@ -103,11 +103,11 @@ interface Service {
   }
 
   @Test public void http404Async() throws InterruptedException, IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
@@ -132,11 +132,11 @@ interface Service {
   }
 
   @Test public void transportProblemSync() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
 
@@ -149,11 +149,11 @@ interface Service {
   }
 
   @Test public void transportProblemAsync() throws InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
 
@@ -176,15 +176,15 @@ interface Service {
   }
 
   @Test public void conversionProblemOutgoingSync() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter() {
           @Override public RequestBody toBody(Object object, Type type) {
             throw new UnsupportedOperationException(""I am broken!"");
           }
         })
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     Call<String> call = example.postMethod(""Hi"");
     try {
@@ -196,15 +196,15 @@ interface Service {
   }
 
   @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter() {
           @Override public RequestBody toBody(Object object, Type type) {
             throw new UnsupportedOperationException(""I am broken!"");
           }
         })
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
@@ -225,15 +225,15 @@ interface Service {
   }
 
   @Test public void conversionProblemIncomingSync() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter() {
           @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
             throw new UnsupportedOperationException(""I am broken!"");
           }
         })
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -247,15 +247,15 @@ interface Service {
   }
 
   @Test public void conversionProblemIncomingAsync() throws InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter() {
           @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
             throw new UnsupportedOperationException(""I am broken!"");
           }
         })
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -279,11 +279,11 @@ interface Service {
 
   @Test public void http204SkipsConverter() throws IOException {
     Converter converter = spy(new StringConverter());
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(converter)
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setStatus(""HTTP/1.1 204 Nothin""));
 
@@ -295,11 +295,11 @@ interface Service {
 
   @Test public void http205SkipsConverter() throws IOException {
     Converter converter = spy(new StringConverter());
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(converter)
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setStatus(""HTTP/1.1 205 Nothin""));
 
@@ -310,11 +310,11 @@ interface Service {
   }
 
   @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi"").removeHeader(""Content-Type""));
 
@@ -23,7 +23,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-public final class RestAdapterTest {
+public final class RetrofitTest {
   @Rule public final MockWebServerRule server = new MockWebServerRule();
 
   interface CallMethod {
@@ -50,33 +50,33 @@ interface Unresolvable {
 
   @SuppressWarnings(""EqualsBetweenInconvertibleTypes"") // We are explicitly testing this behavior.
   @Test public void objectMethodsStillWork() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
 
     assertThat(example.hashCode()).isNotZero();
     assertThat(example.equals(this)).isFalse();
     assertThat(example.toString()).isNotEmpty();
   }
 
   @Test public void interfaceWithExtendIsNotSupported() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
     try {
-      ra.create(Extending.class);
+      retrofit.create(Extending.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Interface definitions must not extend other interfaces."");
     }
   }
 
   @Test public void callReturnTypeAdapterAddedByDefault() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
     assertThat(example.allowed()).isNotNull();
   }
 
@@ -102,11 +102,11 @@ class MyCallAdapterFactory implements CallAdapter.Factory {
       }
     }
 
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .callAdapterFactory(new MyCallAdapterFactory())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
     assertThat(example.allowed()).isNotNull();
     assertThat(factoryCalled.get()).isTrue();
     assertThat(adapterCalled.get()).isTrue();
@@ -130,20 +130,20 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
       }
     }
 
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .callAdapterFactory(new GreetingCallAdapterFactory())
         .build();
-    StringService example = ra.create(StringService.class);
+    StringService example = retrofit.create(StringService.class);
     assertThat(example.get()).isEqualTo(""Hi!"");
   }
 
   @Test public void customReturnTypeAdapterMissingThrows() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    FutureMethod example = ra.create(FutureMethod.class);
+    FutureMethod example = retrofit.create(FutureMethod.class);
     try {
       example.method();
       fail();
@@ -153,25 +153,25 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
   }
 
   @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
     try {
       example.disallowed(""Hi!"");
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
           ""CallMethod.disallowed: @Body parameter is class java.lang.String but no converter registered. ""
-              + ""Either add a converter to the RestAdapter or use RequestBody. (parameter #1)"");
+              + ""Either add a converter to the Retrofit instance or use RequestBody. (parameter #1)"");
     }
   }
 
   @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -181,15 +181,15 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
           ""CallMethod.disallowed: Method response type is class java.lang.String but no converter registered. ""
-              + ""Either add a converter to the RestAdapter or use ResponseBody."");
+              + ""Either add a converter to the Retrofit instance or use ResponseBody."");
     }
   }
 
   @Test public void requestBodyOutgoingAllowed() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -198,10 +198,10 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
   }
 
   @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -213,11 +213,11 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
   }
 
   @Test public void unresolvableTypeThrows() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Unresolvable example = ra.create(Unresolvable.class);
+    Unresolvable example = retrofit.create(Unresolvable.class);
 
     try {
       example.typeVariable();
@@ -26,7 +26,7 @@
 import retrofit.CallAdapter;
 import retrofit.Callback;
 import retrofit.Response;
-import retrofit.RestAdapter;
+import retrofit.Retrofit;
 import retrofit.http.GET;
 
 /**
@@ -95,12 +95,12 @@ static class Ip {
   }
 
   public static void main(String... args) {
-    RestAdapter restAdapter = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(""http://httpbin.org"")
         .callAdapterFactory(new ListenableFutureCallAdapterFactory())
         .build();
 
-    HttpBinService service = restAdapter.create(HttpBinService.class);
+    HttpBinService service = retrofit.create(HttpBinService.class);
     final ListenableFuture<Ip> ip = service.getIp();
     ip.addListener(new Runnable() {
       @Override public void run() {
@@ -18,7 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import retrofit.Call;
-import retrofit.RestAdapter;
+import retrofit.Retrofit;
 import retrofit.http.GET;
 import retrofit.http.Path;
 
@@ -44,12 +44,12 @@ Call<List<Contributor>> contributors(
 
   public static void main(String... args) throws IOException {
     // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(API_URL)
         .build();
 
     // Create an instance of our GitHub API interface.
-    GitHub github = restAdapter.create(GitHub.class);
+    GitHub github = retrofit.create(GitHub.class);
 
     // Create a call instance for looking up Retrofit contributors.
     Call<List<Contributor>> call = github.contributors(""square"", ""retrofit"");
@@ -9,11 +9,11 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executors;
-import retrofit.MockRestAdapter;
-import retrofit.RestAdapter;
+import retrofit.MockRetrofit;
+import retrofit.Retrofit;
 
 /**
- * An example of using {@link MockRestAdapter} to create a mock service implementation with
+ * An example of using {@link MockRetrofit} to create a mock service implementation with
  * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
  */
 public final class SimpleMockService {
@@ -61,18 +61,17 @@ public void addContributor(String owner, String repo, String name, int contribut
 
   public static void main(String... args) {
     // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(SimpleService.API_URL)
         .build();
 
     // Wrap our REST adapter to allow mock implementations and fake network delay.
-    MockRestAdapter mockRestAdapter =
-        MockRestAdapter.from(restAdapter, Executors.newSingleThreadExecutor());
+    MockRetrofit mockRetrofit = MockRetrofit.from(retrofit, Executors.newSingleThreadExecutor());
 
     // Instantiate a mock object so we can interact with it later.
     MockGitHub mockGitHub = new MockGitHub();
     // Use the mock REST adapter and our mock object to create the API interface.
-    GitHub gitHub = mockRestAdapter.create(GitHub.class, mockGitHub);
+    GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
     // Query for some contributors for a few repositories.
     printContributors(gitHub, ""square"", ""retrofit"");
@@ -48,12 +48,12 @@ <h3 id=""introduction"">Introduction</h3>
   @GET(""/users/{user}/repos"")
   List&lt;Repo> listRepos(@Path(""user"") String user);
 }</pre>
-            <p>The <code>RestAdapter</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-            <pre class=""prettyprint"">RestAdapter restAdapter = new RestAdapter.Builder()
+            <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+            <pre class=""prettyprint"">Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint(""https://api.github.com"")
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
             <p>Each call on the generated <code>GitHubService</code> makes an HTTP request to the remote webserver.</p>
             <pre class=""prettyprint"">List&lt;Repo> repos = service.listRepos(""octocat"");</pre>
             <p>Use annotations to describe the HTTP request:</p>
@@ -88,7 +88,7 @@ <h4>Request Body</h4>
             <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
             <pre class=""prettyprint"">@POST(""/users/new"")
 void createUser(@Body User user, Callback&lt;User> cb);</pre>
-            <p>The object will also be converted using the <code>RestAdapter</code>'s converter.</p>
+            <p>The object will also be converted using the <code>Retrofit</code>'s converter.</p>
 
             <h4>Form Encoded and Multipart</h4>
             <p>Methods can also be declared to send form-encoded and multipart data.</p>
@@ -100,7 +100,7 @@ <h4>Form Encoded and Multipart</h4>
             <pre class=""prettyprint"">@Multipart
 @PUT(""/user/photo"")
 User updateUser(@Part(""photo"") TypedFile photo, @Part(""description"") TypedString description);</pre>
-            <p>Multipart parts use the <code>RestAdapter</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
+            <p>Multipart parts use the <code>Retrofit</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
 
             <h4>Header Manipulation</h4>
             <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
@@ -125,7 +125,7 @@ <h4>Header Manipulation</h4>
   }
 };
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
   .setEndpoint(""https://api.github.com"")
   .setRequestInterceptor(requestInterceptor)
   .build();</pre>
@@ -146,7 +146,7 @@ <h4>Synchronous vs. Asynchronous vs. Observable</h4>
             <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
 
             <h4>Response Object Type</h4>
-            <p>HTTP responses are automatically converted to a specified type using the <code>RestAdapter</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
+            <p>HTTP responses are automatically converted to a specified type using the <code>Retrofit</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
             <pre class=""prettyprint"">@GET(""/users/list"")
 List&lt;User> userList();
 
@@ -165,11 +165,11 @@ <h4>Response Object Type</h4>
 @GET(""/users/list"")
 Observable&lt;Response> userList();</pre>
 
-            <h3 id=""restadapter-configuration"">RestAdapter Configuration</h3>
-            <p><code>RestAdapter</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+            <h3 id=""restadapter-configuration"">Retrofit Configuration</h3>
+            <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
 
             <h4>JSON Conversion</h4>
-            <p>Retrofit uses <a href=""https://code.google.com/p/google-gson/"">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>RestAdapter</code>. Refer to the <a href=""https://sites.google.com/site/gson/gson-user-guide"">Gson documentation</a> for more details on customization.</p>
+            <p>Retrofit uses <a href=""https://code.google.com/p/google-gson/"">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>Retrofit</code>. Refer to the <a href=""https://sites.google.com/site/gson/gson-user-guide"">Gson documentation</a> for more details on customization.</p>
             <h4>Custom Gson Converter Example</h4>
             <p>The following code creates a new <code>Gson</code> instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the <code>Date</code> class. This <code>DateTypeAdapter</code> will be used anytime Gson encounters a <code>Date</code> field.</p>
             <p>The <code>gson</code> instance is passed as a parameter to <code>GsonConverter</code>, which is a wrapper class for converting types.</p>
@@ -178,22 +178,22 @@ <h4>Custom Gson Converter Example</h4>
     .registerTypeAdapter(Date.class, new DateTypeAdapter())
     .create();
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint(""https://api.github.com"")
     .setConverter(new GsonConverter(gson))
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>RestAdapter</code>.</p>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
+            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>Retrofit</code>.</p>
             <h4>Content format Agnostic</h4>
             <p>In addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using <a href=""http://simple.sourceforge.net/"">Simple</a>) and Protocol Buffers (using <a href=""https://code.google.com/p/protobuf/"">protobuf</a> or <a href=""https://github.com/square/wire"">Wire</a>). Please see the <a href=""https://github.com/square/retrofit/tree/master/retrofit-converters"">retrofit-converters</a> directory for the full listing of converters.</p>
             <p>The following code shows how to use <code>SimpleXMLConverter</code> to communicate with an API that uses XML</p>
-            <pre class=""prettyprint"">RestAdapter restAdapter = new RestAdapter.Builder()
+            <pre class=""prettyprint"">Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint(""https://api.soundcloud.com"")
     .setConverter(new SimpleXMLConverter())
     .build();
 
-SoundCloudService service = restAdapter.create(SoundCloudService.class);</pre>
+SoundCloudService service = retrofit.create(SoundCloudService.class);</pre>
             <h4>Custom Converters</h4>
             <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href=""https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java""><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
             <h4>Custom Error Handling</h4>
@@ -209,21 +209,21 @@ <h4>Custom Error Handling</h4>
   }
 }
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint(""https://api.github.com"")
     .setErrorHandler(new MyErrorHandler())
     .build();</pre>
             <p>Note that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied <code>RetrofitError</code> as the cause to any new exceptions you throw.</p>
 
             <h4>Logging</h4>
-            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>RestAdapter</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
+            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>Retrofit</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
             <p>The following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.</p>
             <pre class=""prettyprint"">
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setLogLevel(RestAdapter.LogLevel.FULL)
+Retrofit retrofit = new Retrofit.Builder()
+    .setLogLevel(Retrofit.LogLevel.FULL)
     .setEndpoint(""https://api.github.com"")
     .build();</pre>
-            <p>This logging can be added or changed at any point in the <code>RestAdapter</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
+            <p>This logging can be added or changed at any point in the <code>Retrofit</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
 
             <h3 id=""download"">Download</h3>
             <p><a href=""https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST"" class=""dl version-href"">&darr; <span class=""version-tag"">Latest</span> JAR</a></p>
@@ -286,7 +286,7 @@ <h3 id=""license"">License</h3>
               <ul class=""nav nav-tabs nav-stacked primary"">
                 <li><a href=""#introduction"">Introduction</a></li>
                 <li><a href=""#api-declaration"">API Declaration</a></li>
-                <li><a href=""#restadapter-configuration"">RestAdapter Configuration</a></li>
+                <li><a href=""#restadapter-configuration"">Retrofit Configuration</a></li>
                 <li><a href=""#download"">Download</a></li>
                 <li><a href=""#contributing"">Contributing</a></li>
                 <li><a href=""#license"">License</a></li>
"
https://github.com/junit-team/junit4/commit/467c3f8efe1a87e3029df282e4df60ad98bc4142,Deprecate Assert#assertThat  <enter> The method 'assertThat' is used for writing assertions with Hamcrest. Hamcrest is an independent assertion library and contains an own 'assertThat' method in the class 'org.hamcrest.MatcherAssert'. It is available both in the old Hamcrest 1.3 release and in the current Hamcrest 2.1. Therefore the JUnit team recommends to use Hamcrest's own 'assertThat' directly. ,https://api.github.com/repos/junit-team/junit4/commits/467c3f8efe1a87e3029df282e4df60ad98bc4142,"@@ -923,8 +923,9 @@ public static void assertEquals(Object[] expecteds, Object[] actuals) {
      * @param matcher an expression, built of {@link Matcher}s, specifying allowed
      * values
      * @see org.hamcrest.CoreMatchers
-     * @see org.hamcrest.MatcherAssert
+     * @deprecated use {@code org.hamcrest.MatcherAssert.assertThat()}
      */
+    @Deprecated
     public static <T> void assertThat(T actual, Matcher<? super T> matcher) {
         assertThat("""", actual, matcher);
     }
@@ -955,8 +956,9 @@ public static <T> void assertThat(T actual, Matcher<? super T> matcher) {
      * @param matcher an expression, built of {@link Matcher}s, specifying allowed
      * values
      * @see org.hamcrest.CoreMatchers
-     * @see org.hamcrest.MatcherAssert
+     * @deprecated use {@code org.hamcrest.MatcherAssert.assertThat()}
      */
+    @Deprecated
     public static <T> void assertThat(String reason, T actual,
             Matcher<? super T> matcher) {
         MatcherAssert.assertThat(reason, actual, matcher);
"
https://github.com/apache/dubbo/commit/9ca9bb04b926ba33c6755aff8373314e60f2be89,Fix typo <issue_link> ,https://api.github.com/repos/apache/dubbo/commits/9ca9bb04b926ba33c6755aff8373314e60f2be89,"@@ -304,7 +304,7 @@ private void init() {
         appendParameters(map, module);
         appendParameters(map, consumer, Constants.DEFAULT_KEY);
         appendParameters(map, this);
-        String prifix = StringUtils.getServiceKey(map);
+        String prefix = StringUtils.getServiceKey(map);
         if (methods != null && methods.size() > 0) {
             for (MethodConfig method : methods) {
                 appendParameters(map, method, method.getName());
@@ -315,7 +315,7 @@ private void init() {
                         map.put(method.getName() + "".retries"", ""0"");
                     }
                 }
-                appendAttributes(attributes, method, prifix + ""."" + method.getName());
+                appendAttributes(attributes, method, prefix + ""."" + method.getName());
                 checkAndConvertImplicitConfig(method, map, attributes);
             }
         }
@@ -473,7 +473,7 @@ public void setInterface(Class<?> interfaceClass) {
             throw new IllegalStateException(""The interface class "" + interfaceClass + "" is not a interface!"");
         }
         this.interfaceClass = interfaceClass;
-        setInterface(interfaceClass == null ? (String) null : interfaceClass.getName());
+        setInterface(interfaceClass == null ? null : interfaceClass.getName());
     }
 
     public void setInterface(String interfaceName) {
"
https://github.com/spring-projects/spring-boot/commit/3d437711363ade1717a7e11b7b781d240bad4983,"Register an AuthenticationManager in security autoconfig  <enter> This is quite a big step, but I think it helps a lot. Since Spring Boot always creates an AuthenticationManager if it doesn't find one already registered, it makes sense to also make it into a  @bean . Spring Security does not register its AuthenticationManager by default though, so we have to do that for it if the user has created one with an  @Autowired  AuthenticationManagerBuilder, but not registered it as a  @bean . <enter> Having the  @bean  (marked  @primary  to prevent issues with  @Autowired ) makes it easier to reason about what Spring Boot has done for you, and easier to default in simple use cases to the boot-created AuthenticationManager. For example, if I want an OAuth2 Authorization Server with password grant, it makes total sense for the AuthenticationManager for users to be the same as the  @primary  one. Now it is easy to set that up (just  @autowire  it). ",https://api.github.com/repos/spring-projects/spring-boot/commits/3d437711363ade1717a7e11b7b781d240bad4983,"@@ -40,10 +40,19 @@ public abstract class SpringBootCondition implements Condition {
 	@Override
 	public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
 		String classOrMethodName = getClassOrMethodName(metadata);
-		ConditionOutcome outcome = getMatchOutcome(context, metadata);
-		logOutcome(classOrMethodName, outcome);
-		recordEvaluation(context, classOrMethodName, outcome);
-		return outcome.isMatch();
+		try {
+			ConditionOutcome outcome = getMatchOutcome(context, metadata);
+			logOutcome(classOrMethodName, outcome);
+			recordEvaluation(context, classOrMethodName, outcome);
+			return outcome.isMatch();
+		}
+		catch (NoClassDefFoundError e) {
+			throw new IllegalStateException(
+					""Could not evaluate condition owing to internal class not found. ""
+							+ ""This can happen if you are @ComponentScanning a springframework package ""
+							+ ""(e.g. if you put a @ComponentScan in the default package by mistake)"",
+					e);
+		}
 	}
 
 	private static String getClassOrMethodName(AnnotatedTypeMetadata metadata) {
@@ -26,7 +26,12 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.security.SecurityProperties.User;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Lazy;
+import org.springframework.context.annotation.Primary;
+import org.springframework.context.annotation.Scope;
+import org.springframework.context.annotation.ScopedProxyMode;
 import org.springframework.core.Ordered;
 import org.springframework.core.annotation.Order;
 import org.springframework.security.authentication.AuthenticationManager;
@@ -60,9 +65,25 @@ public class AuthenticationManagerConfiguration extends
 	@Autowired
 	private SecurityProperties security;
 
+	private BootDefaultingAuthenticationConfigurerAdapter configurer = new BootDefaultingAuthenticationConfigurerAdapter();
+
 	@Override
 	public void init(AuthenticationManagerBuilder auth) throws Exception {
-		auth.apply(new BootDefaultingAuthenticationConfigurerAdapter());
+		auth.apply(this.configurer);
+	}
+
+	@Bean
+	// avoid issues with scopedTarget (SPR-11548)
+	@Primary
+	public AuthenticationManager authenticationManager() {
+		return lazyAuthenticationManager();
+	}
+
+	@Bean
+	@Lazy
+	@Scope(proxyMode = ScopedProxyMode.INTERFACES)
+	protected AuthenticationManager lazyAuthenticationManager() {
+		return this.configurer.getAuthenticationManagerBuilder().getOrBuild();
 	}
 
 	/**
@@ -92,9 +113,16 @@ public void init(AuthenticationManagerBuilder auth) throws Exception {
 	private class BootDefaultingAuthenticationConfigurerAdapter extends
 			GlobalAuthenticationConfigurerAdapter {
 
+		private AuthenticationManagerBuilder defaultAuth;
+
+		public AuthenticationManagerBuilder getAuthenticationManagerBuilder() {
+			return this.defaultAuth;
+		}
+
 		@Override
 		public void configure(AuthenticationManagerBuilder auth) throws Exception {
 			if (auth.isConfigured()) {
+				this.defaultAuth = auth;
 				return;
 			}
 
@@ -104,12 +132,12 @@ public void configure(AuthenticationManagerBuilder auth) throws Exception {
 						+ user.getPassword() + ""\n\n"");
 			}
 
-			AuthenticationManagerBuilder defaultAuth = new AuthenticationManagerBuilder(
+			this.defaultAuth = new AuthenticationManagerBuilder(
 					AuthenticationManagerConfiguration.this.objectPostProcessor);
 
 			Set<String> roles = new LinkedHashSet<String>(user.getRole());
 
-			AuthenticationManager parent = defaultAuth.inMemoryAuthentication()
+			AuthenticationManager parent = this.defaultAuth.inMemoryAuthentication()
 					.withUser(user.getName()).password(user.getPassword())
 					.roles(roles.toArray(new String[roles.size()])).and().and().build();
 
@@ -19,15 +19,11 @@
 import java.util.List;
 
 import org.junit.Test;
-import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
 import org.springframework.boot.autoconfigure.TestAutoConfigurationPackage;
 import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
-import org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer;
 import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
 import org.springframework.boot.autoconfigure.orm.jpa.test.City;
-import org.springframework.boot.context.event.ApplicationPreparedEvent;
-import org.springframework.boot.logging.LoggingApplicationListener;
 import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -60,7 +56,7 @@ public void testWebConfiguration() throws Exception {
 		this.context.setServletContext(new MockServletContext());
 		this.context.register(SecurityAutoConfiguration.class,
 				PropertyPlaceholderAutoConfiguration.class);
-		debugRefresh(this.context);
+		this.context.refresh();
 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class));
 		// 4 for static resources and one for the rest
 		List<SecurityFilterChain> filterChains = this.context.getBean(
@@ -93,6 +89,16 @@ public void testDisableBasicAuthOnApplicationPaths() throws Exception {
 		assertEquals(0, this.context.getBeanNamesForType(FilterChainProxy.class).length);
 	}
 
+	@Test
+	public void testAuthenticationManagerCreated() throws Exception {
+		this.context = new AnnotationConfigWebApplicationContext();
+		this.context.setServletContext(new MockServletContext());
+		this.context.register(SecurityAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
+		this.context.refresh();
+		assertNotNull(this.context.getBean(AuthenticationManager.class));
+	}
+
 	@Test
 	public void testOverrideAuthenticationManager() throws Exception {
 		this.context = new AnnotationConfigWebApplicationContext();
@@ -118,18 +124,6 @@ public void testJpaCoexistsHappily() throws Exception {
 		assertNotNull(this.context.getBean(JpaTransactionManager.class));
 	}
 
-	private static AnnotationConfigWebApplicationContext debugRefresh(
-			AnnotationConfigWebApplicationContext context) {
-		EnvironmentTestUtils.addEnvironment(context, ""debug:true"");
-		LoggingApplicationListener logging = new LoggingApplicationListener();
-		logging.onApplicationEvent(new ApplicationPreparedEvent(new SpringApplication(),
-				new String[0], context));
-		AutoConfigurationReportLoggingInitializer initializer = new AutoConfigurationReportLoggingInitializer();
-		initializer.initialize(context);
-		context.refresh();
-		return context;
-	}
-
 	@Configuration
 	@TestAutoConfigurationPackage(City.class)
 	protected static class EntityConfiguration {
"
https://github.com/junit-team/junit4/commit/41092ce4e01cc57d8aa1911e2f1169e0f355b1ae,Move TestClassTest to package org.junit.runners.model.  <enter> It is common to add tests to the same package as the class under test. ,https://api.github.com/repos/junit-team/junit4/commits/41092ce4e01cc57d8aa1911e2f1169e0f355b1ae,"@@ -1,4 +1,4 @@
-package org.junit.tests.running.classes;
+package org.junit.runners.model;
 
 import static org.hamcrest.CoreMatchers.hasItem;
 import static org.hamcrest.CoreMatchers.is;
@@ -11,9 +11,6 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.rules.TestRule;
-import org.junit.runners.model.FrameworkField;
-import org.junit.runners.model.FrameworkMethod;
-import org.junit.runners.model.TestClass;
 
 public class TestClassTest {
 
@@ -17,6 +17,7 @@
 import org.junit.runners.Suite.SuiteClasses;
 import org.junit.runners.model.FrameworkFieldTest;
 import org.junit.runners.model.FrameworkMethodTest;
+import org.junit.runners.model.TestClassTest;
 import org.junit.tests.assertion.AssertionTest;
 import org.junit.tests.assertion.ComparisonFailureTest;
 import org.junit.tests.assertion.MultipleFailureExceptionTest;
@@ -85,7 +86,6 @@
 import org.junit.tests.running.classes.ParentRunnerTest;
 import org.junit.tests.running.classes.RunWithTest;
 import org.junit.tests.running.classes.SuiteTest;
-import org.junit.tests.running.classes.TestClassTest;
 import org.junit.tests.running.classes.UseSuiteAsASuperclassTest;
 import org.junit.tests.running.core.CommandLineTest;
 import org.junit.tests.running.core.JUnitCoreReturnsCorrectExitCodeTest;
"
https://github.com/square/retrofit/commit/704c484b56b0cf2d1f26f4315b3569c08e5cdc6a,Prepare version 2.8.1 ,https://api.github.com/repos/square/retrofit/commits/704c484b56b0cf2d1f26f4315b3569c08e5cdc6a,"@@ -1,6 +1,13 @@
 Change Log
 ==========
 
+Version 2.8.1 *(2020-03-25)*
+----------------------------
+
+ * Fix: Do not access `MethodHandles.Lookup` on Android API 24 and 25. The class is only available
+   on Android API 26 and higher.
+
+
 Version 2.8.0 *(2020-03-23)*
 ----------------------------
 
@@ -9,7 +9,7 @@ For more information please see [the website][1].
 Download
 --------
 
-Download [the latest JAR][2] or grab from Maven central at the coordinates `com.squareup.retrofit2:retrofit:2.8.0`.
+Download [the latest JAR][2] or grab from Maven central at the coordinates `com.squareup.retrofit2:retrofit:2.8.1`.
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
"
https://github.com/junit-team/junit4/commit/3e08f69912d69189e895c279b1bece0c7c0840f4,"Create a class TestWithParameters.  <enter> This class keeps the data together that are needed for creating a runner for a single data set of a parameterized test. This makes it also clear, that the computation of the name is not the responsibility of the runner but of the Parameterized class. ",https://api.github.com/repos/junit-team/junit4/commits/3e08f69912d69189e895c279b1bece0c7c0840f4,"@@ -18,6 +18,8 @@
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.Statement;
+import org.junit.runners.model.TestClass;
+import org.junit.runners.parameterized.TestWithParameters;
 
 /**
  * The custom runner <code>Parameterized</code> implements parameterized tests.
@@ -188,11 +190,21 @@ protected class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {
 
         private final String fName;
 
+        /**
+         * @deprecated please use
+         *             {@code TestClassRunnerForParameters(TestWithParameters)}
+         */
+        @Deprecated
         protected TestClassRunnerForParameters(Class<?> type, String pattern, int index, Object[] parameters) throws InitializationError {
-            super(type);
+            this(createTestWithParameters(new TestClass(type), pattern, index,
+                    parameters));
+        }
 
-            fParameters = parameters;
-            fName = nameFor(pattern, index, parameters);
+        protected TestClassRunnerForParameters(TestWithParameters test)
+                throws InitializationError {
+            super(test.getTestClass().getJavaClass());
+            fParameters = test.getParameters().toArray();
+            fName = test.getName();
         }
 
         @Override
@@ -231,12 +243,6 @@ private Object createTestUsingFieldInjection() throws Exception {
             return testClassInstance;
         }
 
-        protected String nameFor(String pattern, int index, Object[] parameters) {
-            String finalPattern = pattern.replaceAll(""\\{index\\}"", Integer.toString(index));
-            String name = MessageFormat.format(finalPattern, parameters);
-            return ""["" + name + ""]"";
-        }
-
         @Override
         protected String getName() {
             return fName;
@@ -319,11 +325,14 @@ private Runner createRunnerWithNotNormalizedParameters(String pattern,
             throws InitializationError {
         Object[] parameters= (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter
             : new Object[] { parametersOrSingleParameter };
-        return createRunner(pattern, index, parameters);
+        TestWithParameters test = createTestWithParameters(getTestClass(),
+                pattern, index, parameters);
+        return createRunnerForTest(test);
     }
 
-    protected Runner createRunner(String pattern, int index, Object[] parameters) throws InitializationError {
-        return new TestClassRunnerForParameters(getTestClass().getJavaClass(), pattern, index, parameters);
+    protected Runner createRunnerForTest(TestWithParameters test)
+            throws InitializationError {
+        return new TestClassRunnerForParameters(test);
     }
 
     @SuppressWarnings(""unchecked"")
@@ -381,4 +390,13 @@ private List<FrameworkField> getAnnotatedFieldsByParameter() {
     private boolean fieldsAreAnnotated() {
         return !getAnnotatedFieldsByParameter().isEmpty();
     }
-}
\ No newline at end of file
+
+    private static TestWithParameters createTestWithParameters(
+            TestClass testClass, String pattern, int index, Object[] parameters) {
+        String finalPattern = pattern.replaceAll(""\\{index\\}"",
+                Integer.toString(index));
+        String name = MessageFormat.format(finalPattern, parameters);
+        return new TestWithParameters(""["" + name + ""]"", testClass,
+                Arrays.asList(parameters));
+    }
+}
@@ -252,6 +252,26 @@ public boolean isANonStaticInnerClass() {
         return fClass.isMemberClass() && !isStatic(fClass.getModifiers());
     }
 
+    @Override
+    public int hashCode() {
+        return (fClass == null) ? 0 : fClass.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        TestClass other = (TestClass) obj;
+        return fClass == other.fClass;
+    }
+
     /**
      * Compares two fields by its name.
      */
@@ -0,0 +1,82 @@
+package org.junit.runners.parameterized;
+
+import static java.util.Collections.unmodifiableList;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.runners.model.TestClass;
+
+/**
+ * A {@code TestWithParameters} keeps the data together that are needed for
+ * creating a runner for a single data set of a parameterized test. It has a
+ * name, the test class and a list of parameters.
+ * 
+ * @since 4.12
+ */
+public class TestWithParameters {
+    private final String fName;
+
+    private final TestClass fTestClass;
+
+    private final List<Object> fParameters;
+
+    public TestWithParameters(String name, TestClass testClass,
+            List<Object> parameters) {
+        notNull(name, ""The name is missing."");
+        notNull(testClass, ""The test class is missing."");
+        notNull(parameters, ""The parameters are missing."");
+        fName = name;
+        fTestClass = testClass;
+        fParameters = unmodifiableList(new ArrayList<Object>(parameters));
+    }
+
+    public String getName() {
+        return fName;
+    }
+
+    public TestClass getTestClass() {
+        return fTestClass;
+    }
+
+    public List<Object> getParameters() {
+        return fParameters;
+    }
+
+    @Override
+    public int hashCode() {
+        int prime = 14747;
+        int result = prime + fName.hashCode();
+        result = prime * result + fTestClass.hashCode();
+        return prime * result + fParameters.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        TestWithParameters other = (TestWithParameters) obj;
+        return fName.equals(other.fName)
+                && fParameters.equals(other.fParameters)
+                && fTestClass.equals(other.fTestClass);
+    }
+
+    @Override
+    public String toString() {
+        return fTestClass.getName() + "" '"" + fName + ""' with parameters ""
+                + fParameters;
+    }
+
+    private static void notNull(Object value, String message) {
+        if (value == null) {
+            throw new NullPointerException(message);
+        }
+    }
+}
@@ -2,7 +2,10 @@
 
 import static org.hamcrest.CoreMatchers.hasItem;
 import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
 
 import java.util.List;
 
@@ -147,4 +150,55 @@ public void annotatedMethodValues() {
     	assertThat(values, hasItem(""jupiter""));
     	assertThat(values.size(), is(1));
     }
+
+    @Test
+    public void isEqualToTestClassThatWrapsSameJavaClass() {
+        TestClass testClass = new TestClass(DummyClass.class);
+        TestClass testClassThatWrapsSameJavaClass = new TestClass(
+                DummyClass.class);
+        assertTrue(testClass.equals(testClassThatWrapsSameJavaClass));
+    }
+
+    @Test
+    public void isEqualToTestClassThatWrapsNoJavaClassToo() {
+        TestClass testClass = new TestClass(null);
+        TestClass testClassThatWrapsNoJavaClassToo = new TestClass(null);
+        assertTrue(testClass.equals(testClassThatWrapsNoJavaClassToo));
+    }
+
+    @Test
+    public void isNotEqualToTestClassThatWrapsADifferentJavaClass() {
+        TestClass testClass = new TestClass(DummyClass.class);
+        TestClass testClassThatWrapsADifferentJavaClass = new TestClass(
+                AnotherDummyClass.class);
+        assertFalse(testClass.equals(testClassThatWrapsADifferentJavaClass));
+    }
+
+    @Test
+    public void isNotEqualToNull() {
+        TestClass testClass = new TestClass(DummyClass.class);
+        assertFalse(testClass.equals(null));
+    }
+
+    private static class DummyClass {
+    }
+
+    private static class AnotherDummyClass {
+    }
+
+    @Test
+    public void hasSameHashCodeAsTestClassThatWrapsSameJavaClass() {
+        TestClass testClass = new TestClass(DummyClass.class);
+        TestClass testClassThatWrapsSameJavaClass = new TestClass(
+                DummyClass.class);
+        assertEquals(testClass.hashCode(),
+                testClassThatWrapsSameJavaClass.hashCode());
+    }
+
+    @Test
+    public void hasHashCodeWithoutJavaClass() {
+        TestClass testClass = new TestClass(null);
+        testClass.hashCode();
+        // everything is fine if no exception is thrown.
+    }
 }
@@ -0,0 +1,137 @@
+package org.junit.runners.parameterized;
+
+import static java.util.Arrays.asList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.rules.ExpectedException.none;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runners.model.TestClass;
+
+public class TestWithParametersTest {
+    private static final String DUMMY_NAME = ""dummy name"";
+
+    private static final TestClass DUMMY_TEST_CLASS = new TestClass(
+            DummyClass.class);
+
+    private static final List<Object> DUMMY_PARAMETERS = Arrays
+            .<Object> asList(""a"", ""b"");
+
+    @Rule
+    public final ExpectedException thrown = none();
+
+    @Test
+    public void cannotBeCreatedWithoutAName() {
+        thrown.expect(NullPointerException.class);
+        thrown.expectMessage(""The name is missing."");
+        new TestWithParameters(null, DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+    }
+
+    @Test
+    public void cannotBeCreatedWithoutTestClass() {
+        thrown.expect(NullPointerException.class);
+        thrown.expectMessage(""The test class is missing."");
+        new TestWithParameters(DUMMY_NAME, null, DUMMY_PARAMETERS);
+    }
+
+    @Test
+    public void cannotBeCreatedWithoutParameters() {
+        thrown.expect(NullPointerException.class);
+        thrown.expectMessage(""The parameters are missing."");
+        new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS,
+                (List<Object>) null);
+    }
+
+    @Test
+    public void doesNotAllowToModifyProvidedParameters() {
+        TestWithParameters test = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        thrown.expect(UnsupportedOperationException.class);
+        test.getParameters().set(0, ""another parameter"");
+    }
+
+    @Test
+    public void doesNotConsiderParametersWhichChangedAfterTestInstantiation() {
+        List<Object> parameters = Arrays.<Object> asList(""dummy parameter"");
+        TestWithParameters test = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, parameters);
+        parameters.set(0, ""another parameter"");
+        assertEquals(asList(""dummy parameter""), test.getParameters());
+    }
+
+    @Test
+    public void isEqualToTestWithSameNameAndTestClassAndParameters() {
+        TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME,
+                new TestClass(DummyClass.class), Arrays.<Object> asList(""a"",
+                        ""b""));
+        TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME,
+                new TestClass(DummyClass.class), Arrays.<Object> asList(""a"",
+                        ""b""));
+        assertEquals(firstTest, secondTest);
+    }
+
+    @Test
+    public void isNotEqualToTestWithDifferentName() {
+        TestWithParameters firstTest = new TestWithParameters(""name"",
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        TestWithParameters secondTest = new TestWithParameters(""another name"",
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        assertNotEquals(firstTest, secondTest);
+    }
+
+    @Test
+    public void isNotEqualToTestWithDifferentTestClass() {
+        TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME,
+                new TestClass(DummyClass.class), DUMMY_PARAMETERS);
+        TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME,
+                new TestClass(AnotherDummyClass.class), DUMMY_PARAMETERS);
+        assertNotEquals(firstTest, secondTest);
+    }
+
+    @Test
+    public void isNotEqualToTestWithDifferentParameters() {
+        TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, Arrays.<Object> asList(""a""));
+        TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, Arrays.<Object> asList(""b""));
+        assertNotEquals(firstTest, secondTest);
+    }
+
+    @Test
+    public void isNotEqualToObjectWithDifferentClass() {
+        TestWithParameters test = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        assertNotEquals(test, new Integer(3));
+    }
+
+    @Test
+    public void hasSameHashCodeAsEqualTest() {
+        TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        assertEquals(firstTest.hashCode(), secondTest.hashCode());
+    }
+
+    @Test
+    public void hasMeaningfulToString() {
+        TestWithParameters test = new TestWithParameters(""name"", new TestClass(
+                DummyClass.class), Arrays.<Object> asList(""first parameter"",
+                ""second parameter""));
+        assertEquals(
+                ""Wrong toString()."",
+                ""org.junit.runners.parameterized.TestWithParametersTest$DummyClass 'name' with parameters [first parameter, second parameter]"",
+                test.toString());
+    }
+
+    private static class DummyClass {
+    }
+
+    private static class AnotherDummyClass {
+    }
+}
@@ -18,6 +18,7 @@
 import org.junit.runners.model.FrameworkFieldTest;
 import org.junit.runners.model.FrameworkMethodTest;
 import org.junit.runners.model.TestClassTest;
+import org.junit.runners.parameterized.TestWithParametersTest;
 import org.junit.tests.assertion.AssertionTest;
 import org.junit.tests.assertion.ComparisonFailureTest;
 import org.junit.tests.assertion.MultipleFailureExceptionTest;
@@ -202,7 +203,8 @@
         FrameworkFieldTest.class,
         FrameworkMethodTest.class,
         FailOnTimeoutTest.class,
-        JUnitCoreTest.class
+        JUnitCoreTest.class,
+        TestWithParametersTest.class
 })
 public class AllTests {
     public static Test suite() {
"
https://github.com/junit-team/junit4/commit/5e4f8e7fb82919d992887fca1741bb04ef1c8f4a,New Suite implementation makes ClassesRequest crazy simple ,https://api.github.com/repos/junit-team/junit4/commits/5e4f8e7fb82919d992887fca1741bb04ef1c8f4a,"@@ -1,28 +1,21 @@
 package org.junit.internal.requests;
 
-import org.junit.internal.runners.InitializationError;
 import org.junit.runner.Request;
 import org.junit.runner.Runner;
 import org.junit.runners.Suite;
 
 public class ClassesRequest extends Request {
+	// TODO: (Dec 13, 2007 2:29:43 AM) how useful are requests anymore?
+
 	private final Class<?>[] fClasses;
-	private final String fName;
 	
-	public ClassesRequest(String name, Class<?>... classes) {
+	public ClassesRequest(Class<?>... classes) {
 		fClasses= classes;
-		fName= name;
 	}
 
 	/** @inheritDoc */
 	@Override 
 	public Runner getRunner() {
-		try {
-			return new Suite(fName, fClasses);
-		} catch (InitializationError e) {
-			// TODO: (Dec 10, 2007 9:13:13 PM) untested
-
-			return Request.errorReport(null, e).getRunner();
-		}
+		return new Suite(fClasses);
 	}
 }
\ No newline at end of file
@@ -53,7 +53,7 @@ public static Request aClass(Class<?> clazz) {
 	 * @return a <code>Request</code> that will cause all tests in the classes to be run
 	 */
 	public static Request classes(String collectionName, Class<?>... classes) {
-		return new ClassesRequest(collectionName, classes);
+		return new ClassesRequest(classes);
 	}
 
 	public static Request errorReport(Class<?> klass, Throwable cause) {
"
https://github.com/apache/dubbo/commit/4a8da59573cb0f1d793809439abb2f2162f2d80f,"Proofread README.md file with multiple fixes ( <pr_link> )  <enter> Fixed typo, grammatical, punctuations, and semantic coherence to improve readability and content quality. <enter> Signed-off-by: Aditya Kumar Roy <akroy@umass.edu> ",https://api.github.com/repos/apache/dubbo/commits/4a8da59573cb0f1d793809439abb2f2162f2d80f,"@@ -10,9 +10,9 @@
 [![](https://img.shields.io/twitter/follow/ApacheDubbo.svg?label=Follow&style=social&logoWidth=0)](https://twitter.com/intent/follow?screen_name=ApacheDubbo)
 [![Gitter](https://badges.gitter.im/alibaba/dubbo.svg)](https://gitter.im/alibaba/dubbo?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)
 
-Apache Dubbo is a high-performance, Java based open source RPC framework. Please visit [official site](http://dubbo.apache.org) for quick start and documentations, as well as [Wiki](https://github.com/apache/dubbo/wiki) for news, FAQ, and release notes.
+Apache Dubbo is a high-performance, Java-based open-source RPC framework. Please visit [official site](http://dubbo.apache.org) for quick start and documentations, as well as the [wiki](https://github.com/apache/dubbo/wiki) for news, FAQ, and release notes.
 
-We are now collecting dubbo user info in order to help us to improve Dubbo better, pls. kindly help us by providing yours on [issue#1012: Wanted: who's using dubbo](https://github.com/apache/dubbo/issues/1012), thanks :)
+We are now collecting Dubbo user info to help us to improve Dubbo further. Kindly support us by supplementing your information on [issue#1012: Wanted: who's using dubbo](https://github.com/apache/dubbo/issues/1012), thanks :)
 
 ## Architecture
 
@@ -29,14 +29,14 @@ We are now collecting dubbo user info in order to help us to improve Dubbo bette
 
 ## Getting started
 
-The following code snippet comes from [Dubbo Samples](https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-api). You may clone the sample project and step into `dubbo-samples-api` sub directory before read on.
+The following code snippet comes from [Dubbo Samples](https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-api). You may clone the sample project and step into the `dubbo-samples-api` subdirectory before proceeding.
 
 ```bash
 # git clone https://github.com/apache/dubbo-samples.git
 # cd dubbo-samples/java/dubbo-samples-api
 ```
 
-There's a [README](https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-api/README.md) file under `dubbo-samples-api` directory. Read it and try this sample out by following the instructions.
+There's a [README](https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-api/README.md) file under `dubbo-samples-api` directory. We recommend referencing the samples in that directory by following the below-mentioned instructions: 
 
 ### Maven dependency
 
@@ -128,7 +128,7 @@ public class Application {
 # mvn -Djava.net.preferIPv4Stack=true -Dexec.mainClass=org.apache.dubbo.samples.provider.Application exec:java
 ```
 
-### Call remote service in consumer
+### Call remote service in the consumer
 
 ```java
 package org.apache.dubbo.samples.client;
@@ -174,7 +174,7 @@ The consumer will print out `hi, dubbo` on the screen.
 
 ## Building
 
-If you want to try out the cutting-edge features, you can build with the following commands. (Java 1.8 is required to build the master branch)
+If you want to try out the cutting-edge features, you can build with the following commands. (Java 1.8 is needed to build the master branch)
 
 ```
   mvn clean install
@@ -195,18 +195,18 @@ See [CONTRIBUTING](https://github.com/apache/dubbo/blob/master/CONTRIBUTING.md)
 
 ### How can I contribute?
 
-* Take a look at issues with tag called [`Good first issue`](https://github.com/apache/dubbo/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) or [`Help wanted`](https://github.com/apache/dubbo/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22).
-* Join the discussion on mailing list, subscription [guide](https://github.com/apache/dubbo/wiki/Mailing-list-subscription-guide).
+* Take a look at issues with tags marked [`Good first issue`](https://github.com/apache/dubbo/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) or [`Help wanted`](https://github.com/apache/dubbo/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22).
+* Join the discussion on the mailing list, subscription [guide](https://github.com/apache/dubbo/wiki/Mailing-list-subscription-guide).
 * Answer questions on [issues](https://github.com/apache/dubbo/issues).
-* Fix bugs reported on [issues](https://github.com/apache/dubbo/issues), and send us pull request.
+* Fix bugs reported on [issues](https://github.com/apache/dubbo/issues), and send us a pull request.
 * Review the existing [pull request](https://github.com/apache/dubbo/pulls).
 * Improve the [website](https://github.com/apache/dubbo-website), typically we need
   * blog post
   * translation on documentation
-  * use cases about how Dubbo is being used in enterprise system.
+  * use cases around the integration of Dubbo in enterprise systems.
 * Improve the [dubbo-admin/dubbo-monitor](https://github.com/apache/dubbo-admin).
 * Contribute to the projects listed in [ecosystem](https://github.com/dubbo).
-* Any form of contribution that is not mentioned above.
+* Other forms of contribution not explicitly enumerated above.
 * If you would like to contribute, please send an email to dev@dubbo.apache.org to let us know!
 
 ## Reporting bugs
@@ -215,7 +215,7 @@ Please follow the [template](https://github.com/apache/dubbo/issues/new?template
 
 ## Reporting a security vulnerability
 
-Please report security vulnerability to [us](mailto:security@dubbo.apache.org) privately.
+Please report security vulnerabilities to [us](mailto:security@dubbo.apache.org) privately.
 
 ## Dubbo ecosystem
 
@@ -236,4 +236,4 @@ Please report security vulnerability to [us](mailto:security@dubbo.apache.org) p
 
 ## License
 
-Apache Dubbo is under the Apache 2.0 license. See the [LICENSE](https://github.com/apache/dubbo/blob/master/LICENSE) file for details.
+Apache Dubbo software is licenced under the Apache License Version 2.0. See the [LICENSE](https://github.com/apache/dubbo/blob/master/LICENSE) file for details.
"
https://github.com/apache/dubbo/commit/6912d9a14fe2c35dee306da9a8e953ba29d736da,Upgrade tomcat version to 8.5.31. ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/6912d9a14fe2c35dee306da9a8e953ba29d736da,"@@ -99,7 +99,7 @@
 
         <rs_api_version>2.0</rs_api_version>
         <resteasy_version>3.0.19.Final</resteasy_version>
-        <tomcat_embed_version>8.0.11</tomcat_embed_version>
+        <tomcat_embed_version>8.5.31</tomcat_embed_version>
         <!-- Log libs -->
         <slf4j_version>1.7.25</slf4j_version>
         <jcl_version>1.2</jcl_version>
@@ -49,10 +49,6 @@
             <groupId>org.apache.tomcat.embed</groupId>
             <artifactId>tomcat-embed-core</artifactId>
         </dependency>
-        <dependency>
-            <groupId>org.apache.tomcat.embed</groupId>
-            <artifactId>tomcat-embed-logging-juli</artifactId>
-        </dependency>
         <dependency>
             <groupId>org.apache.httpcomponents</groupId>
             <artifactId>fluent-hc</artifactId>
"
https://github.com/apache/dubbo/commit/f490df87de45b57be8c224581a8a1a7dd9a20946,"keep demo simple, and switch to use zookeeper as registry center ( <pr_link> )  <enter> * keep demo simple, and switch to use zookeeper as registry center <enter> * remove comment ",https://api.github.com/repos/apache/dubbo/commits/f490df87de45b57be8c224581a8a1a7dd9a20946,"@@ -19,15 +19,14 @@
 
 package org.apache.dubbo.demo.consumer.comp;
 
-import org.apache.dubbo.config.annotation.Method;
 import org.apache.dubbo.config.annotation.Reference;
 import org.apache.dubbo.demo.DemoService;
 
 import org.springframework.stereotype.Component;
 
 @Component(""demoServiceComponent"")
 public class DemoServiceComponent implements DemoService {
-    @Reference(timeout = 100,methods = @Method(timeout = 500,name = ""sayHello""))
+    @Reference
     private DemoService demoService;
 
     @Override
@@ -27,10 +27,6 @@
 import org.springframework.context.annotation.PropertySource;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) throws Exception {
         AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class);
         context.start();
@@ -18,25 +18,19 @@
  */
 package org.apache.dubbo.demo.provider;
 
-import org.apache.dubbo.config.annotation.Method;
 import org.apache.dubbo.config.annotation.Service;
 import org.apache.dubbo.demo.DemoService;
 import org.apache.dubbo.rpc.RpcContext;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-@Service(timeout = 100,methods = @Method(timeout = 1000,name = ""sayHello""))
+@Service
 public class DemoServiceImpl implements DemoService {
     private static final Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);
 
     @Override
     public String sayHello(String name) {
-        try {
-            Thread.sleep(2000);
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
         logger.info(""Hello "" + name + "", request from consumer: "" + RpcContext.getContext().getRemoteAddress());
         return ""Hello "" + name + "", response from provider: "" + RpcContext.getContext().getLocalAddress();
     }
@@ -24,14 +24,10 @@
 import org.apache.dubbo.demo.DemoService;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) {
         ReferenceConfig<DemoService> reference = new ReferenceConfig<>();
         reference.setApplication(new ApplicationConfig(""dubbo-demo-api-consumer""));
-        reference.setRegistry(new RegistryConfig(""multicast://224.5.6.7:1234""));
+        reference.setRegistry(new RegistryConfig(""zookeeper://127.0.0.1:2181""));
         reference.setInterface(DemoService.class);
         DemoService service = reference.get();
         String message = service.sayHello(""dubbo"");
@@ -24,14 +24,10 @@
 import org.apache.dubbo.demo.DemoService;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) throws Exception {
         ServiceConfig<DemoServiceImpl> service = new ServiceConfig<>();
         service.setApplication(new ApplicationConfig(""dubbo-demo-api-provider""));
-        service.setRegistry(new RegistryConfig(""multicast://224.5.6.7:1234""));
+        service.setRegistry(new RegistryConfig(""zookeeper://127.0.0.1:2181""));
         service.setInterface(DemoService.class);
         service.setRef(new DemoServiceImpl());
         service.export();
@@ -21,10 +21,6 @@
 import org.springframework.context.support.ClassPathXmlApplicationContext;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) {
         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(""spring/dubbo-consumer.xml"");
         context.start();
@@ -23,10 +23,8 @@
 
     <dubbo:application name=""demo-consumer""/>
 
-    <dubbo:registry address=""multicast://224.5.6.7:1234""/>
+    <dubbo:registry address=""zookeeper://127.0.0.1:2181""/>
 
-    <!-- generate proxy for the remote service, then demoService can be used in the same way as the
-    local regular interface -->
     <dubbo:reference id=""demoService"" check=""false"" interface=""org.apache.dubbo.demo.DemoService""/>
 
 </beans>
@@ -19,10 +19,6 @@
 import org.springframework.context.support.ClassPathXmlApplicationContext;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) throws Exception {
         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(""spring/dubbo-provider.xml"");
         context.start();
@@ -21,18 +21,14 @@
        xsi:schemaLocation=""http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
        http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"">
 
-    <!-- provider's application name, used for tracing dependency relationship -->
     <dubbo:application name=""demo-provider""/>
 
-    <dubbo:registry address=""multicast://224.5.6.7:1234"" />
+    <dubbo:registry address=""zookeeper://127.0.0.1:2181""/>
 
-    <!-- use dubbo protocol to export service on port 20880 -->
     <dubbo:protocol name=""dubbo""/>
 
-    <!-- service implementation, as same as regular local bean -->
     <bean id=""demoService"" class=""org.apache.dubbo.demo.provider.DemoServiceImpl""/>
 
-    <!-- declare the service interface to be exported -->
     <dubbo:service interface=""org.apache.dubbo.demo.DemoService"" ref=""demoService""/>
 
 </beans>
"
https://github.com/spring-projects/spring-boot/commit/0515ca0dd02fec54d438d45afbf95db1b5f41353,Auto configure micrometer cache metrics  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/0515ca0dd02fec54d438d45afbf95db1b5f41353,"@@ -27,6 +27,7 @@
 
 import org.springframework.beans.factory.ObjectProvider;
 import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnEnabledEndpoint;
+import org.springframework.boot.actuate.autoconfigure.metrics.cache.CacheMetricsConfiguration;
 import org.springframework.boot.actuate.autoconfigure.metrics.export.MetricsExporter;
 import org.springframework.boot.actuate.autoconfigure.metrics.export.atlas.AtlasExportConfiguration;
 import org.springframework.boot.actuate.autoconfigure.metrics.export.datadog.DatadogExportConfiguration;
@@ -45,6 +46,7 @@
 import org.springframework.boot.actuate.metrics.integration.SpringIntegrationMetrics;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
+import org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
@@ -68,12 +70,13 @@
 @EnableConfigurationProperties(MetricsProperties.class)
 @Import({ MeterBindersConfiguration.class, WebMvcMetricsConfiguration.class,
 		WebFluxMetricsConfiguration.class, RestTemplateMetricsConfiguration.class,
-		DataSourcePoolMetricsConfiguration.class, AtlasExportConfiguration.class,
-		DatadogExportConfiguration.class, GangliaExportConfiguration.class,
-		GraphiteExportConfiguration.class, InfluxExportConfiguration.class,
-		JmxExportConfiguration.class, PrometheusExportConfiguration.class,
-		SimpleExportConfiguration.class, StatsdExportConfiguration.class })
-@AutoConfigureAfter(DataSourceAutoConfiguration.class)
+		CacheMetricsConfiguration.class, DataSourcePoolMetricsConfiguration.class,
+		AtlasExportConfiguration.class, DatadogExportConfiguration.class,
+		GangliaExportConfiguration.class, GraphiteExportConfiguration.class,
+		InfluxExportConfiguration.class, JmxExportConfiguration.class,
+		PrometheusExportConfiguration.class, SimpleExportConfiguration.class,
+		StatsdExportConfiguration.class })
+@AutoConfigureAfter({ CacheAutoConfiguration.class, DataSourceAutoConfiguration.class })
 public class MetricsAutoConfiguration {
 
 	@Bean
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import com.hazelcast.core.Hazelcast;
+import com.hazelcast.spring.cache.HazelcastCache;
+import io.micrometer.core.instrument.binder.MeterBinder;
+import net.sf.ehcache.Ehcache;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider;
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.cache.caffeine.CaffeineCache;
+import org.springframework.cache.ehcache.EhCacheCache;
+import org.springframework.cache.jcache.JCacheCache;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+/**
+ * {@link Configuration Auto-configuration} for {@link CacheMeterBinderProvider} beans.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ * @see CacheMeterBinderProviders
+ */
+@Configuration
+@ConditionalOnClass(MeterBinder.class)
+class CacheMeterBinderProvidersConfiguration {
+
+	@Configuration
+	@ConditionalOnClass({ CaffeineCache.class, com.github.benmanes.caffeine.cache.Cache.class })
+	static class CaffeineCacheMeterBinderProviderConfiguration {
+
+		@Bean
+		public CacheMeterBinderProvider caffeineCacheMeterBinderProvider() {
+			return new CacheMeterBinderProviders.CaffeineCacheMeterBinderProvider();
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnClass({ EhCacheCache.class, Ehcache.class })
+	static class EhCache2CacheMeterBinderProviderConfiguration {
+
+		@Bean
+		public CacheMeterBinderProvider ehCache2CacheMeterBinderProvider() {
+			return new CacheMeterBinderProviders.EhCache2CacheMeterBinderProvider();
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnClass({ HazelcastCache.class, Hazelcast.class })
+	static class HazelcastCacheMeterBinderProviderConfiguration {
+
+		@Bean
+		public CacheMeterBinderProvider hazelcastCacheMeterBinderProvider() {
+			return new CacheMeterBinderProviders.HazelcastCacheMeterBinderProvider();
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnClass({ JCacheCache.class, javax.cache.CacheManager.class })
+	static class JCacheCacheMeterBinderProviderConfiguration {
+
+		@Bean
+		public CacheMeterBinderProvider jCacheCacheMeterBinderProvider() {
+			return new CacheMeterBinderProviders.JCacheCacheMeterBinderProvider();
+		}
+
+	}
+
+}
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.cache.Cache;
+import org.springframework.cache.CacheManager;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Import;
+
+/**
+ * Configure metrics for all available {@link Cache caches}.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+@Configuration
+@ConditionalOnBean(CacheManager.class)
+@ConditionalOnProperty(value = ""management.metrics.cache.instrument-cache"", matchIfMissing = true)
+@EnableConfigurationProperties(CacheMetricsProperties.class)
+@Import({ CacheMeterBinderProvidersConfiguration.class, CacheMetricsRegistrarConfiguration.class })
+public class CacheMetricsConfiguration {
+
+}
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+/**
+ * Configuration properties for Cache-based metrics.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+@ConfigurationProperties(""management.metrics.cache"")
+public class CacheMetricsProperties {
+
+	/**
+	 * Name of the metric for cache usage.
+	 */
+	private String cacheMetricName = ""cache"";
+
+	public String getCacheMetricName() {
+		return this.cacheMetricName;
+	}
+
+	public void setCacheMetricName(String cacheMetricName) {
+		this.cacheMetricName = cacheMetricName;
+	}
+
+}
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.Tag;
+import io.micrometer.core.instrument.Tags;
+import io.micrometer.core.instrument.binder.MeterBinder;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider;
+import org.springframework.cache.Cache;
+
+/**
+ * Register supported {@link Cache} to a {@link MeterRegistry}.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+public class CacheMetricsRegistrar {
+
+	private final MeterRegistry registry;
+
+	private final String metricName;
+
+	private final Collection<CacheMeterBinderProvider> cacheMeterBinderProviders;
+
+	/**
+	 * Creates a new registrar.
+	 * @param registry the {@link MeterRegistry} to use
+	 * @param metricName the name of the metric
+	 * @param binderProviders the {@link CacheMeterBinderProvider} instances that should
+	 * be used to detect compatible caches
+	 */
+	public CacheMetricsRegistrar(MeterRegistry registry, String metricName,
+			Collection<CacheMeterBinderProvider> binderProviders) {
+		this.registry = registry;
+		this.metricName = metricName;
+		this.cacheMeterBinderProviders = binderProviders;
+	}
+
+	/**
+	 * Attempt to bind the specified {@link Cache} to the registry. Return {@code true}
+	 * if the cache is supported and was bound to the registry, {@code false} otherwise.
+	 * @param cache the cache to handle
+	 * @param tags the tags to associate with the metrics of that cache
+	 * @return {@code true} if the {@code cache} is supported and was registered
+	 */
+	public boolean bindCacheToRegistry(Cache cache, Tag... tags) {
+		List<Tag> allTags = new ArrayList(Arrays.asList(tags));
+		MeterBinder meterBinder = getMeterBinder(cache, allTags);
+		if (meterBinder != null) {
+			meterBinder.bindTo(this.registry);
+			return true;
+		}
+		return false;
+	}
+
+	private MeterBinder getMeterBinder(Cache cache, List<Tag> tags) {
+		tags.addAll(getAdditionalTags(cache));
+		for (CacheMeterBinderProvider binderProvider : this.cacheMeterBinderProviders) {
+			MeterBinder meterBinder = binderProvider.getMeterBinder(cache,
+					this.metricName, tags);
+			if (meterBinder != null) {
+				return meterBinder;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Return additional {@link Tag tags} to be associated with the given {@link Cache}.
+	 * @param cache the cache
+	 * @return a list of additional tags to associate to that {@code cache}.
+	 */
+	protected List<Tag> getAdditionalTags(Cache cache) {
+		return Tags.zip(""name"", cache.getName());
+	}
+
+}
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import java.util.Collection;
+import java.util.Map;
+
+import javax.annotation.PostConstruct;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.Tag;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.cache.Cache;
+import org.springframework.cache.CacheManager;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.util.StringUtils;
+
+/**
+ * Configure a {@link CacheMetricsRegistrar} and register all available
+ * {@link Cache caches}.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+@Configuration
+@ConditionalOnBean(CacheMeterBinderProvider.class)
+class CacheMetricsRegistrarConfiguration {
+
+	private static final String CACHE_MANAGER_SUFFIX = ""cacheManager"";
+
+	private final MeterRegistry registry;
+
+	private final CacheMetricsProperties properties;
+
+	private final Collection<CacheMeterBinderProvider> cacheMeterBinderProviders;
+
+	private final Map<String, CacheManager> cacheManagers;
+
+	CacheMetricsRegistrarConfiguration(MeterRegistry registry,
+			CacheMetricsProperties properties,
+			Collection<CacheMeterBinderProvider> cacheMeterBinderProviders,
+			Map<String, CacheManager> cacheManagers) {
+		this.registry = registry;
+		this.cacheMeterBinderProviders = cacheMeterBinderProviders;
+		this.properties = properties;
+		this.cacheManagers = cacheManagers;
+	}
+
+	@Bean
+	public CacheMetricsRegistrar cacheMetricsRegistrar() {
+		return new CacheMetricsRegistrar(this.registry,
+				this.properties.getCacheMetricName(), this.cacheMeterBinderProviders);
+	}
+
+	@PostConstruct
+	public void bindCachesToRegistry() {
+		this.cacheManagers.forEach((beanName, cacheManager) -> cacheManager.getCacheNames()
+				.forEach((cacheName) ->
+						bindCacheToRegistry(beanName, cacheManager.getCache(cacheName))));
+	}
+
+	private void bindCacheToRegistry(String beanName, Cache cache) {
+		Tag cacheManagerTag = Tag.of(""cacheManager"", getCacheManagerName(beanName));
+		cacheMetricsRegistrar().bindCacheToRegistry(cache, cacheManagerTag);
+	}
+
+	/**
+	 * Get the name of a {@link CacheManager} based on its {@code beanName}.
+	 * @param beanName the name of the {@link CacheManager} bean
+	 * @return a name for the given cache manager
+	 */
+	private String getCacheManagerName(String beanName) {
+		if (beanName.length() > CACHE_MANAGER_SUFFIX.length()
+				&& StringUtils.endsWithIgnoreCase(beanName, CACHE_MANAGER_SUFFIX)) {
+			return beanName.substring(0,
+					beanName.length() - CACHE_MANAGER_SUFFIX.length());
+		}
+		return beanName;
+	}
+
+}
@@ -215,6 +215,12 @@
       ""description"": ""Whether to enable uptime metrics."",
       ""defaultValue"": true
     },
+    {
+      ""name"": ""management.metrics.cache.instrument-cache"",
+      ""type"": ""java.lang.Boolean"",
+      ""description"": ""Instrument all available caches."",
+      ""defaultValue"": true
+    },
     {
       ""name"": ""management.metrics.export.jmx.enabled"",
       ""type"": ""java.lang.Boolean"",
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
+import org.junit.Test;
+
+import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
+import org.springframework.boot.autoconfigure.AutoConfigurations;
+import org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration;
+import org.springframework.boot.test.context.runner.ApplicationContextRunner;
+import org.springframework.cache.annotation.EnableCaching;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link CacheMetricsConfiguration}.
+ *
+ * @author Stephane Nicoll
+ */
+public class CacheMetricsConfigurationTests {
+
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
+			.withUserConfiguration(RegistryConfiguration.class)
+			.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class))
+			.withPropertyValues(""management.metrics.use-global-registry=false"");
+
+	@Test
+	public void autoConfiguredCacheManagerIsInstrumented() {
+		this.contextRunner
+				.withConfiguration(
+						AutoConfigurations.of(CacheAutoConfiguration.class))
+				.withPropertyValues(""spring.cache.type=caffeine"",
+						""spring.cache.cache-names=cache1,cache2"")
+				.run((context) -> {
+					MeterRegistry registry = context.getBean(MeterRegistry.class);
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache1"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isPresent();
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache2"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isPresent();
+				});
+	}
+
+	@Test
+	public void autoConfiguredCacheManagerWithCustomMetricName() {
+		this.contextRunner
+				.withConfiguration(
+						AutoConfigurations.of(CacheAutoConfiguration.class))
+				.withPropertyValues(
+						""management.metrics.cache.cache-metric-name=custom.name"",
+						""spring.cache.type=caffeine"", ""spring.cache.cache-names=cache1"")
+				.run((context) -> {
+					MeterRegistry registry = context.getBean(MeterRegistry.class);
+					assertThat(registry.find(""custom.name.requests"")
+							.tags(""name"", ""cache1"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isPresent();
+				});
+	}
+
+	@Test
+	public void autoConfiguredNonSupportedCacheManagerIsIgnored() {
+		this.contextRunner
+				.withConfiguration(
+						AutoConfigurations.of(CacheAutoConfiguration.class))
+				.withPropertyValues(""spring.cache.type=simple"",
+						""spring.cache.cache-names=cache1,cache2"")
+				.run((context) -> {
+					MeterRegistry registry = context.getBean(MeterRegistry.class);
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache1"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isNotPresent();
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache2"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isNotPresent();
+				});
+	}
+
+	@Test
+	public void cacheInstrumentationCanBeDisabled() {
+		this.contextRunner
+				.withConfiguration(
+						AutoConfigurations.of(CacheAutoConfiguration.class))
+				.withPropertyValues(""management.metrics.cache.instrument-cache=false"",
+						""spring.cache.type=caffeine"", ""spring.cache.cache-names=cache1"")
+				.run((context) -> {
+					MeterRegistry registry = context.getBean(MeterRegistry.class);
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache1"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isNotPresent();
+				});
+	}
+
+
+	@Configuration
+	@EnableCaching
+	static class RegistryConfiguration {
+
+		@Bean
+		public MeterRegistry meterRegistry() {
+			return new SimpleMeterRegistry();
+		}
+
+	}
+
+}
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import java.util.Collections;
+
+import com.github.benmanes.caffeine.cache.Caffeine;
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
+import org.junit.Test;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders;
+import org.springframework.cache.caffeine.CaffeineCache;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link CacheMetricsRegistrar}.
+ *
+ * @author Stephane Nicoll
+ */
+public class CacheMetricsRegistrarTests {
+
+	private final MeterRegistry meterRegistry = new SimpleMeterRegistry();
+
+	@Test
+	public void bindToSupportedCache() {
+		CacheMetricsRegistrar registrar = new CacheMetricsRegistrar(this.meterRegistry,
+				""root"", Collections.singleton(
+				new CacheMeterBinderProviders.CaffeineCacheMeterBinderProvider()));
+		assertThat(registrar.bindCacheToRegistry(
+				new CaffeineCache(""test"", Caffeine.newBuilder().build()))).isTrue();
+		assertThat(this.meterRegistry.find(""root.requests"")
+				.tags(""name"", ""test"").meter()).isPresent();
+	}
+
+	@Test
+	public void bindToUnsupportedCache() {
+		CacheMetricsRegistrar registrar = new CacheMetricsRegistrar(this.meterRegistry,
+				""root"", Collections.EMPTY_LIST);
+		assertThat(registrar.bindCacheToRegistry(
+				new CaffeineCache(""test"", Caffeine.newBuilder().build()))).isFalse();
+		assertThat(this.meterRegistry.find(""root.requests"")
+				.tags(""name"", ""test"").meter()).isNotPresent();
+	}
+
+}
@@ -26,6 +26,16 @@
 			<artifactId>jackson-databind</artifactId>
 			<optional>true</optional>
 		</dependency>
+		<dependency>
+			<groupId>com.hazelcast</groupId>
+			<artifactId>hazelcast</artifactId>
+			<optional>true</optional>
+		</dependency>
+		<dependency>
+			<groupId>com.hazelcast</groupId>
+			<artifactId>hazelcast-spring</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>com.sun.mail</groupId>
 			<artifactId>javax.mail</artifactId>
@@ -56,11 +66,21 @@
 			<artifactId>jest</artifactId>
 			<optional>true</optional>
 		</dependency>
+		<dependency>
+			<groupId>javax.cache</groupId>
+			<artifactId>cache-api</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>javax.jms</groupId>
 			<artifactId>javax.jms-api</artifactId>
 			<optional>true</optional>
 		</dependency>
+		<dependency>
+			<groupId>net.sf.ehcache</groupId>
+			<artifactId>ehcache</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>org.apache.tomcat.embed</groupId>
 			<artifactId>tomcat-embed-core</artifactId>
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.metrics.cache;
+
+import io.micrometer.core.instrument.Tag;
+import io.micrometer.core.instrument.binder.MeterBinder;
+
+import org.springframework.cache.Cache;
+
+/**
+ * Provide a {@link MeterBinder} based on a {@link Cache}.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+public interface CacheMeterBinderProvider {
+
+	/**
+	 * Return the {@link MeterBinder} managing the specified {@link Cache} or {@code null}
+	 * if the specified {@link Cache} is not supported.
+	 * @param cache the cache to instrument
+	 * @param name the name prefix of the metrics
+	 * @param tags tags to apply to all recorded metrics
+	 * @return a {@link MeterBinder} handling the specified {@link Cache} or {@code null}
+	 */
+	MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags);
+
+}
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.metrics.cache;
+
+import com.hazelcast.core.IMap;
+import com.hazelcast.spring.cache.HazelcastCache;
+import io.micrometer.core.instrument.Tag;
+import io.micrometer.core.instrument.binder.MeterBinder;
+import io.micrometer.core.instrument.binder.cache.CaffeineCacheMetrics;
+import io.micrometer.core.instrument.binder.cache.EhCache2Metrics;
+import io.micrometer.core.instrument.binder.cache.HazelcastCacheMetrics;
+import io.micrometer.core.instrument.binder.cache.JCacheMetrics;
+
+import org.springframework.cache.Cache;
+import org.springframework.cache.caffeine.CaffeineCache;
+import org.springframework.cache.ehcache.EhCacheCache;
+import org.springframework.cache.jcache.JCacheCache;
+
+/**
+ * Common {@link CacheMeterBinderProvider} implementations.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+public abstract class CacheMeterBinderProviders {
+
+	/**
+	 * {@link CacheMeterBinderProvider} implementation for Caffeine.
+	 */
+	public static class CaffeineCacheMeterBinderProvider
+			implements CacheMeterBinderProvider {
+
+		@Override
+		public MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags) {
+			if (cache instanceof CaffeineCache) {
+				return new CaffeineCacheMetrics(
+						((CaffeineCache) cache).getNativeCache(), tags, name);
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * {@link CacheMeterBinderProvider} implementation for EhCache2.
+	 */
+	public static class EhCache2CacheMeterBinderProvider
+			implements CacheMeterBinderProvider {
+
+		@Override
+		public MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags) {
+			if (cache instanceof EhCacheCache) {
+				return new EhCache2Metrics(((EhCacheCache) cache).getNativeCache(),
+						name, tags);
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * {@link CacheMeterBinderProvider} implementation for Hazelcast.
+	 */
+	public static class HazelcastCacheMeterBinderProvider
+			implements CacheMeterBinderProvider {
+
+		@Override
+		public MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags) {
+			if (cache instanceof HazelcastCache) {
+				IMap<Object, Object> nativeCache = (IMap<Object, Object>) ((HazelcastCache) cache).getNativeCache();
+				return new HazelcastCacheMetrics(nativeCache, name, tags);
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * {@link CacheMeterBinderProvider} implementation for JCache.
+	 */
+	public static class JCacheCacheMeterBinderProvider
+			implements CacheMeterBinderProvider {
+		@Override
+		public MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags) {
+			if (cache instanceof JCacheCache) {
+				return new JCacheMetrics(((JCacheCache) cache).getNativeCache(),
+						name, tags);
+			}
+			return null;
+		}
+	}
+
+}
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.metrics.cache;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Collections;
+
+import com.github.benmanes.caffeine.cache.Caffeine;
+import com.hazelcast.core.IMap;
+import com.hazelcast.spring.cache.HazelcastCache;
+import io.micrometer.core.instrument.binder.MeterBinder;
+import io.micrometer.core.instrument.binder.cache.CaffeineCacheMetrics;
+import io.micrometer.core.instrument.binder.cache.EhCache2Metrics;
+import io.micrometer.core.instrument.binder.cache.HazelcastCacheMetrics;
+import io.micrometer.core.instrument.binder.cache.JCacheMetrics;
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.config.CacheConfiguration;
+import net.sf.ehcache.config.Configuration;
+import org.junit.Test;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders.CaffeineCacheMeterBinderProvider;
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders.EhCache2CacheMeterBinderProvider;
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders.HazelcastCacheMeterBinderProvider;
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders.JCacheCacheMeterBinderProvider;
+import org.springframework.cache.caffeine.CaffeineCache;
+import org.springframework.cache.concurrent.ConcurrentMapCache;
+import org.springframework.cache.ehcache.EhCacheCache;
+import org.springframework.cache.jcache.JCacheCache;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+
+/**
+ * Tests for {@link CacheMeterBinderProviders}.
+ *
+ * @author Stephane Nicoll
+ */
+public class CacheMeterBinderProvidersTests {
+
+	@Test
+	public void caffeineCacheProvider() {
+		CaffeineCache cache = new CaffeineCache(""test"", Caffeine.newBuilder().build());
+		MeterBinder meterBinder = new CaffeineCacheMeterBinderProvider().getMeterBinder(
+				cache, ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isInstanceOf(CaffeineCacheMetrics.class);
+	}
+
+	@Test
+	public void caffeineCacheProviderWithUnsupportedCache() {
+		MeterBinder meterBinder = new CaffeineCacheMeterBinderProvider().getMeterBinder(
+				new ConcurrentMapCache(""test""), ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isNull();
+	}
+
+	@Test
+	public void ehCache2CacheProvider() {
+		CacheManager cacheManager = new CacheManager(
+				new Configuration().name(""EhCacheCacheTests"").defaultCache(
+						new CacheConfiguration(""default"", 100)));
+		try {
+			Cache nativeCache = new Cache(
+					new CacheConfiguration(""test"", 100));
+			cacheManager.addCache(nativeCache);
+			EhCacheCache cache = new EhCacheCache(nativeCache);
+			MeterBinder meterBinder = new EhCache2CacheMeterBinderProvider().getMeterBinder(
+					cache, ""test"", Collections.EMPTY_LIST);
+			assertThat(meterBinder).isInstanceOf(EhCache2Metrics.class);
+		}
+		finally {
+			cacheManager.shutdown();
+		}
+	}
+
+	@Test
+	public void ehCache2CacheProviderWithUnsupportedCache() {
+		MeterBinder meterBinder = new EhCache2CacheMeterBinderProvider().getMeterBinder(
+				new ConcurrentMapCache(""test""), ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isNull();
+	}
+
+	@Test
+	public void hazelcastCacheProvider() {
+		IMap<Object, Object> nativeCache = mock(IMap.class);
+		given(nativeCache.getName()).willReturn(""test"");
+		HazelcastCache cache = new HazelcastCache(nativeCache);
+		MeterBinder meterBinder = new HazelcastCacheMeterBinderProvider().getMeterBinder(
+				cache, ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isInstanceOf(HazelcastCacheMetrics.class);
+	}
+
+	@Test
+	public void hazelcastCacheProviderWithUnsupportedCache() {
+		MeterBinder meterBinder = new HazelcastCacheMeterBinderProvider().getMeterBinder(
+				new ConcurrentMapCache(""test""), ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isNull();
+	}
+
+	@Test
+	public void jCacheCacheProvider() throws URISyntaxException {
+		javax.cache.CacheManager cacheManager = mock(javax.cache.CacheManager.class);
+		given(cacheManager.getURI()).willReturn(new URI(""/test""));
+		javax.cache.Cache<Object, Object> nativeCache = mock(javax.cache.Cache.class);
+		given(nativeCache.getCacheManager()).willReturn(cacheManager);
+		given(nativeCache.getName()).willReturn(""test"");
+		JCacheCache cache = new JCacheCache(nativeCache);
+		MeterBinder meterBinder = new JCacheCacheMeterBinderProvider().getMeterBinder(
+				cache, ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isInstanceOf(JCacheMetrics.class);
+	}
+
+	@Test
+	public void jCacheCacheWithUnsupportedCache() {
+		MeterBinder meterBinder = new JCacheCacheMeterBinderProvider().getMeterBinder(
+				new ConcurrentMapCache(""test""), ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isNull();
+	}
+
+}
@@ -1256,6 +1256,8 @@ content into your application. Rather, pick only the properties that you need.
 	management.metrics.binders.logback.enabled=true # Whether to enable Logback metrics.
 	management.metrics.binders.processor.enabled=true # Whether to enable processor metrics.
 	management.metrics.binders.uptime.enabled=true # Whether to enable uptime metrics.
+	management.metrics.cache.cache-metric-name=cache # Name of the metric for cache usage.
+	management.metrics.cache.instrument-cache=true # Instrument all available caches.
 	management.metrics.export.atlas.batch-size= # Number of measurements per request to use for the backend. If more measurements are found, then multiple requests will be made.
 	management.metrics.export.atlas.config-refresh-frequency= # Frequency for refreshing config settings from the LWC service.
 	management.metrics.export.atlas.config-time-to-live= # Time to live for subscriptions from the LWC service.
@@ -1017,6 +1017,30 @@ following information:
 
 
 
+[[production-ready-metrics-cache]]
+=== Cache metrics
+Auto-configuration will enable the instrumentation of all available ``Cache``s on startup
+with a metric named `cache`. The prefix can be customized by using the
+`management.metrics.cache.cache-metric-name` property. Cache instrumentation is specific
+to each cache library, refer to https://micrometer.io/docs[the micrometer documentation]
+for more details.
+
+The following cache libraries are supported:
+
+* Caffeine
+* EhCache 2
+* Hazelcast
+* Any compliant JCache (JSR-107) implementation
+
+Metrics will also be tagged by the name of the `CacheManager` computed based on the bean
+name.
+
+NOTE: Only caches that are available on startup are bound to the registry. For caches
+created on-the-fly or programmatically after the startup phase, an explicit registration
+is required. A `CacheMetricsRegistrar` bean is made available to make that process easier.
+
+
+
 [[production-ready-metrics-jdbc]]
 === DataSource metrics
 Auto-configuration will enable the instrumentation of all available ``DataSource``s with a
"
https://github.com/spring-projects/spring-boot/commit/0741c90489c94c7a15a415013301f40f93caae05,Avoid blocking on a Mono indefinitely  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/0741c90489c94c7a15a415013301f40f93caae05,"@@ -16,6 +16,8 @@
 
 package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
 
+import java.time.Duration;
+
 import org.junit.Test;
 
 import org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration;
@@ -63,7 +65,8 @@ public void healthDetailsAlwaysPresent() {
 		this.contextRunner.run((context) -> {
 			CloudFoundryReactiveHealthEndpointWebExtension extension = context
 					.getBean(CloudFoundryReactiveHealthEndpointWebExtension.class);
-			assertThat(extension.health().block().getBody().getDetails()).isNotEmpty();
+			assertThat(extension.health().block(Duration.ofSeconds(30)).getBody()
+					.getDetails()).isNotEmpty();
 		});
 	}
 
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
 
+import java.time.Duration;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
@@ -201,16 +202,17 @@ public void cloudFoundryPathsIgnoredBySpringSecurity() {
 					Boolean cfRequestMatches = filters.get(0)
 							.matches(MockServerWebExchange.from(MockServerHttpRequest
 									.get(""/cloudfoundryapplication/my-path"").build()))
-							.block();
+							.block(Duration.ofSeconds(30));
 					Boolean otherRequestMatches = filters.get(0)
 							.matches(MockServerWebExchange.from(MockServerHttpRequest
 									.get(""/some-other-path"").build()))
-							.block();
+							.block(Duration.ofSeconds(30));
 					assertThat(cfRequestMatches).isTrue();
 					assertThat(otherRequestMatches).isFalse();
-					otherRequestMatches = filters.get(1).matches(MockServerWebExchange
-							.from(MockServerHttpRequest.get(""/some-other-path"").build()))
-							.block();
+					otherRequestMatches = filters.get(1)
+							.matches(MockServerWebExchange.from(MockServerHttpRequest
+									.get(""/some-other-path"").build()))
+							.block(Duration.ofSeconds(30));
 					assertThat(otherRequestMatches).isTrue();
 				});
 
@@ -314,7 +316,7 @@ public void skipSslValidation() {
 					WebClient webClient = (WebClient) ReflectionTestUtils
 							.getField(interceptorSecurityService, ""webClient"");
 					webClient.get().uri(""https://self-signed.badssl.com/"").exchange()
-							.block();
+							.block(Duration.ofSeconds(30));
 				});
 	}
 
@@ -337,7 +339,7 @@ public void sslValidationNotSkippedByDefault() {
 							.getField(interceptorSecurityService, ""webClient"");
 					this.thrown.expectCause(instanceOf(SSLException.class));
 					webClient.get().uri(""https://self-signed.badssl.com/"").exchange()
-							.block();
+							.block(Duration.ofSeconds(30));
 				});
 	}
 
@@ -17,6 +17,7 @@
 package org.springframework.boot.actuate.autoconfigure.health;
 
 import java.security.Principal;
+import java.time.Duration;
 
 import org.junit.Test;
 import reactor.core.publisher.Mono;
@@ -97,8 +98,8 @@ public void regularAndReactiveHealthIndicatorsMatch() {
 					SecurityContext securityContext = mock(SecurityContext.class);
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
-					Health extensionHealth = extension.health(securityContext).block()
-							.getBody();
+					Health extensionHealth = extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody();
 					assertThat(endpointHealth.getDetails())
 							.containsOnlyKeys(""application"", ""first"", ""second"");
 					assertThat(extensionHealth.getDetails())
@@ -111,8 +112,8 @@ public void unauthenticatedUsersAreNotShownDetailsByDefault() {
 		this.contextRunner.run((context) -> {
 			ReactiveHealthEndpointWebExtension extension = context
 					.getBean(ReactiveHealthEndpointWebExtension.class);
-			assertThat(extension.health(mock(SecurityContext.class)).block().getBody()
-					.getDetails()).isEmpty();
+			assertThat(extension.health(mock(SecurityContext.class))
+					.block(Duration.ofSeconds(30)).getBody().getDetails()).isEmpty();
 		});
 	}
 
@@ -123,8 +124,8 @@ public void authenticatedUsersAreNotShownDetailsByDefault() {
 					.getBean(ReactiveHealthEndpointWebExtension.class);
 			SecurityContext securityContext = mock(SecurityContext.class);
 			given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
-			assertThat(extension.health(securityContext).block().getBody().getDetails())
-					.isEmpty();
+			assertThat(extension.health(securityContext).block(Duration.ofSeconds(30))
+					.getBody().getDetails()).isEmpty();
 		});
 	}
 
@@ -139,8 +140,9 @@ public void authenticatedUsersWhenAuthorizedCanBeShownDetails() {
 					SecurityContext securityContext = mock(SecurityContext.class);
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isNotEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isNotEmpty();
 				});
 	}
 
@@ -151,8 +153,8 @@ public void unauthenticatedUsersCanBeShownDetails() {
 				.run((context) -> {
 					ReactiveHealthEndpointWebExtension extension = context
 							.getBean(ReactiveHealthEndpointWebExtension.class);
-					assertThat(extension.health(null).block().getBody().getDetails())
-							.isNotEmpty();
+					assertThat(extension.health(null).block(Duration.ofSeconds(30))
+							.getBody().getDetails()).isNotEmpty();
 				});
 	}
 
@@ -164,8 +166,9 @@ public void detailsCanBeHiddenFromAuthenticatedUsers() {
 					ReactiveHealthEndpointWebExtension extension = context
 							.getBean(ReactiveHealthEndpointWebExtension.class);
 					SecurityContext securityContext = mock(SecurityContext.class);
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isEmpty();
 				});
 	}
 
@@ -180,8 +183,9 @@ public void detailsCanBeHiddenFromUnauthorizedUsers() {
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
 					given(securityContext.isUserInRole(""ACTUATOR"")).willReturn(false);
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isEmpty();
 				});
 	}
 
@@ -196,8 +200,9 @@ public void detailsCanBeShownToAuthorizedUsers() {
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
 					given(securityContext.isUserInRole(""ACTUATOR"")).willReturn(true);
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isNotEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isNotEmpty();
 				});
 	}
 
@@ -212,8 +217,9 @@ public void roleCanBeCustomized() {
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
 					given(securityContext.isUserInRole(""ADMIN"")).willReturn(true);
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isNotEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isNotEmpty();
 				});
 	}
 
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.actuate.autoconfigure.security.reactive;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -250,8 +251,8 @@ void matches(String path) {
 		}
 
 		private void matches(ServerWebExchange exchange) {
-			assertThat(this.matcher.matches(exchange).block().isMatch())
-					.as(""Matches "" + getRequestPath(exchange)).isTrue();
+			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30))
+					.isMatch()).as(""Matches "" + getRequestPath(exchange)).isTrue();
 		}
 
 		void doesNotMatch(String path) {
@@ -262,8 +263,9 @@ void doesNotMatch(String path) {
 		}
 
 		private void doesNotMatch(ServerWebExchange exchange) {
-			assertThat(this.matcher.matches(exchange).block().isMatch())
-					.as(""Does not match "" + getRequestPath(exchange)).isFalse();
+			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30))
+					.isMatch()).as(""Does not match "" + getRequestPath(exchange))
+							.isFalse();
 		}
 
 		private TestHttpWebHandlerAdapter webHandler() {
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.actuate.endpoint.web.reactive;
 
+import java.time.Duration;
 import java.util.Arrays;
 
 import org.junit.Rule;
@@ -99,7 +100,8 @@ public void mappingNarrowedToMethod() throws Exception {
 
 	private Object getHandler(ControllerEndpointHandlerMapping mapping, HttpMethod method,
 			String requestURI) {
-		return mapping.getHandler(exchange(method, requestURI)).block();
+		return mapping.getHandler(exchange(method, requestURI))
+				.block(Duration.ofSeconds(30));
 	}
 
 	private ControllerEndpointHandlerMapping createMapping(String prefix,
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.actuate.metrics.web.reactive.server;
 
+import java.time.Duration;
+
 import io.micrometer.core.instrument.MockClock;
 import io.micrometer.core.instrument.simple.SimpleConfig;
 import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
@@ -58,7 +60,7 @@ public void filterAddsTagsToRegistry() {
 		this.webFilter
 				.filter(exchange,
 						(serverWebExchange) -> exchange.getResponse().setComplete())
-				.block();
+				.block(Duration.ofSeconds(30));
 		assertMetricsContainsTag(""uri"", ""/projects/{project}"");
 		assertMetricsContainsTag(""status"", ""200"");
 	}
@@ -74,7 +76,7 @@ public void filterAddsTagsToRegistryForExceptions() {
 				.onErrorResume((t) -> {
 					exchange.getResponse().setStatusCodeValue(500);
 					return exchange.getResponse().setComplete();
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertMetricsContainsTag(""uri"", ""/projects/{project}"");
 		assertMetricsContainsTag(""status"", ""500"");
 		assertMetricsContainsTag(""exception"", ""IllegalStateException"");
@@ -91,7 +93,7 @@ public void filterAddsNonEmptyTagsToRegistryForAnonymousExceptions() {
 				.onErrorResume((t) -> {
 					exchange.getResponse().setStatusCodeValue(500);
 					return exchange.getResponse().setComplete();
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertMetricsContainsTag(""uri"", ""/projects/{project}"");
 		assertMetricsContainsTag(""status"", ""500"");
 		assertMetricsContainsTag(""exception"", anonymous.getClass().getName());
@@ -105,7 +107,7 @@ public void filterAddsTagsToRegistryForExceptionsAndCommittedResponse() {
 			exchange.getResponse().setStatusCodeValue(500);
 			return exchange.getResponse().setComplete()
 					.then(Mono.error(new IllegalStateException(""test error"")));
-		}).onErrorResume((t) -> Mono.empty()).block();
+		}).onErrorResume((t) -> Mono.empty()).block(Duration.ofSeconds(30));
 		assertMetricsContainsTag(""uri"", ""/projects/{project}"");
 		assertMetricsContainsTag(""status"", ""500"");
 	}
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.security.Principal;
+import java.time.Duration;
 import java.util.EnumSet;
 
 import javax.servlet.ServletException;
@@ -68,7 +69,7 @@ public Mono<Void> filter(ServerWebExchange exchange) {
 						return Mono.empty();
 					}
 
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertThat(this.repository.findAll()).hasSize(1);
 	}
 
@@ -82,11 +83,12 @@ public void filterCapturesSessionIdWhenSessionIsUsed()
 
 					@Override
 					public Mono<Void> filter(ServerWebExchange exchange) {
-						exchange.getSession().block().getAttributes().put(""a"", ""alpha"");
+						exchange.getSession().block(Duration.ofSeconds(30))
+								.getAttributes().put(""a"", ""alpha"");
 						return Mono.empty();
 					}
 
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertThat(this.repository.findAll()).hasSize(1);
 		Session session = this.repository.findAll().get(0).getSession();
 		assertThat(session).isNotNull();
@@ -103,11 +105,11 @@ public void filterDoesNotCaptureIdOfUnusedSession()
 
 					@Override
 					public Mono<Void> filter(ServerWebExchange exchange) {
-						exchange.getSession().block();
+						exchange.getSession().block(Duration.ofSeconds(30));
 						return Mono.empty();
 					}
 
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertThat(this.repository.findAll()).hasSize(1);
 		Session session = this.repository.findAll().get(0).getSession();
 		assertThat(session).isNull();
@@ -129,11 +131,12 @@ public Mono<Principal> getPrincipal() {
 
 			@Override
 			public Mono<Void> filter(ServerWebExchange exchange) {
-				exchange.getSession().block().getAttributes().put(""a"", ""alpha"");
+				exchange.getSession().block(Duration.ofSeconds(30)).getAttributes()
+						.put(""a"", ""alpha"");
 				return Mono.empty();
 			}
 
-		}).block();
+		}).block(Duration.ofSeconds(30));
 		assertThat(this.repository.findAll()).hasSize(1);
 		org.springframework.boot.actuate.trace.http.HttpTrace.Principal tracedPrincipal = this.repository
 				.findAll().get(0).getPrincipal();
@@ -155,7 +158,7 @@ public Mono<Void> filter(ServerWebExchange exchange) {
 							return Mono.error(new RuntimeException());
 						}
 
-					}).block();
+					}).block(Duration.ofSeconds(30));
 			fail();
 		}
 		catch (Exception ex) {
@@ -17,6 +17,7 @@
 package org.springframework.boot.autoconfigure.freemarker;
 
 import java.io.StringWriter;
+import java.time.Duration;
 import java.util.Locale;
 
 import org.junit.Test;
@@ -60,7 +61,8 @@ public void defaultConfiguration() {
 	public void defaultViewResolution() {
 		this.contextRunner.run((context) -> {
 			MockServerWebExchange exchange = render(context, ""home"");
-			String result = exchange.getResponse().getBodyAsString().block();
+			String result = exchange.getResponse().getBodyAsString()
+					.block(Duration.ofSeconds(30));
 			assertThat(result).contains(""home"");
 			assertThat(exchange.getResponse().getHeaders().getContentType())
 					.isEqualTo(MediaType.TEXT_HTML);
@@ -72,7 +74,8 @@ public void customPrefix() {
 		this.contextRunner.withPropertyValues(""spring.freemarker.prefix:prefix/"")
 				.run((context) -> {
 					MockServerWebExchange exchange = render(context, ""prefixed"");
-					String result = exchange.getResponse().getBodyAsString().block();
+					String result = exchange.getResponse().getBodyAsString()
+							.block(Duration.ofSeconds(30));
 					assertThat(result).contains(""prefixed"");
 				});
 	}
@@ -82,7 +85,8 @@ public void customSuffix() {
 		this.contextRunner.withPropertyValues(""spring.freemarker.suffix:.freemarker"")
 				.run((context) -> {
 					MockServerWebExchange exchange = render(context, ""suffixed"");
-					String result = exchange.getResponse().getBodyAsString().block();
+					String result = exchange.getResponse().getBodyAsString()
+							.block(Duration.ofSeconds(30));
 					assertThat(result).contains(""suffixed"");
 				});
 	}
@@ -93,7 +97,8 @@ public void customTemplateLoaderPath() {
 				""spring.freemarker.templateLoaderPath:classpath:/custom-templates/"")
 				.run((context) -> {
 					MockServerWebExchange exchange = render(context, ""custom"");
-					String result = exchange.getResponse().getBodyAsString().block();
+					String result = exchange.getResponse().getBodyAsString()
+							.block(Duration.ofSeconds(30));
 					assertThat(result).contains(""custom"");
 				});
 	}
@@ -128,7 +133,8 @@ private MockServerWebExchange render(ApplicationContext context, String viewName
 		Mono<View> view = resolver.resolveViewName(viewName, Locale.UK);
 		MockServerWebExchange exchange = MockServerWebExchange
 				.from(MockServerHttpRequest.get(""/path""));
-		view.flatMap((v) -> v.render(null, MediaType.TEXT_HTML, exchange)).block();
+		view.flatMap((v) -> v.render(null, MediaType.TEXT_HTML, exchange))
+				.block(Duration.ofSeconds(30));
 		return exchange;
 	}
 
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.autoconfigure.security.reactive;
 
+import java.time.Duration;
+
 import org.junit.Test;
 import reactor.core.publisher.Mono;
 
@@ -55,8 +57,8 @@ public void configuresADefaultUser() {
 				.run((context) -> {
 					ReactiveUserDetailsService userDetailsService = context
 							.getBean(ReactiveUserDetailsService.class);
-					assertThat(userDetailsService.findByUsername(""user"").block())
-							.isNotNull();
+					assertThat(userDetailsService.findByUsername(""user"")
+							.block(Duration.ofSeconds(30))).isNotNull();
 				});
 	}
 
@@ -67,12 +69,12 @@ public void doesNotConfigureDefaultUserIfUserDetailsServiceAvailable() {
 				.run((context) -> {
 					ReactiveUserDetailsService userDetailsService = context
 							.getBean(ReactiveUserDetailsService.class);
-					assertThat(userDetailsService.findByUsername(""user"").block())
-							.isNull();
-					assertThat(userDetailsService.findByUsername(""foo"").block())
-							.isNotNull();
-					assertThat(userDetailsService.findByUsername(""admin"").block())
-							.isNotNull();
+					assertThat(userDetailsService.findByUsername(""user"")
+							.block(Duration.ofSeconds(30))).isNull();
+					assertThat(userDetailsService.findByUsername(""foo"")
+							.block(Duration.ofSeconds(30))).isNotNull();
+					assertThat(userDetailsService.findByUsername(""admin"")
+							.block(Duration.ofSeconds(30))).isNotNull();
 				});
 	}
 
@@ -93,8 +95,8 @@ public void userDetailsServiceWhenPasswordEncoderAbsentAndDefaultPassword() {
 				.run(((context) -> {
 					MapReactiveUserDetailsService userDetailsService = context
 							.getBean(MapReactiveUserDetailsService.class);
-					String password = userDetailsService.findByUsername(""user"").block()
-							.getPassword();
+					String password = userDetailsService.findByUsername(""user"")
+							.block(Duration.ofSeconds(30)).getPassword();
 					assertThat(password).startsWith(""{noop}"");
 				}));
 	}
@@ -122,8 +124,8 @@ private void testPasswordEncoding(Class<?> configClass, String providedPassword,
 				.run(((context) -> {
 					MapReactiveUserDetailsService userDetailsService = context
 							.getBean(MapReactiveUserDetailsService.class);
-					String password = userDetailsService.findByUsername(""user"").block()
-							.getPassword();
+					String password = userDetailsService.findByUsername(""user"")
+							.block(Duration.ofSeconds(30)).getPassword();
 					assertThat(password).isEqualTo(expectedPassword);
 				}));
 	}
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.autoconfigure.security.reactive;
 
+import java.time.Duration;
+
 import org.assertj.core.api.AssertDelegateTarget;
 import org.junit.Rule;
 import org.junit.Test;
@@ -116,8 +118,8 @@ void matches(String path) {
 		}
 
 		private void matches(ServerWebExchange exchange) {
-			assertThat(this.matcher.matches(exchange).block().isMatch())
-					.as(""Matches "" + getRequestPath(exchange)).isTrue();
+			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30))
+					.isMatch()).as(""Matches "" + getRequestPath(exchange)).isTrue();
 		}
 
 		void doesNotMatch(String path) {
@@ -128,8 +130,9 @@ void doesNotMatch(String path) {
 		}
 
 		private void doesNotMatch(ServerWebExchange exchange) {
-			assertThat(this.matcher.matches(exchange).block().isMatch())
-					.as(""Does not match "" + getRequestPath(exchange)).isFalse();
+			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30))
+					.isMatch()).as(""Does not match "" + getRequestPath(exchange))
+							.isFalse();
 		}
 
 		private TestHttpWebHandlerAdapter webHandler() {
@@ -17,6 +17,7 @@
 package org.springframework.boot.autoconfigure.web.reactive.function.client;
 
 import java.net.URI;
+import java.time.Duration;
 
 import org.junit.Test;
 import reactor.core.publisher.Mono;
@@ -108,8 +109,10 @@ public void shouldGetPrototypeScopedBean() {
 					secondBuilder.clientConnector(secondConnector)
 							.baseUrl(""http://second.example.org"");
 					assertThat(firstBuilder).isNotEqualTo(secondBuilder);
-					firstBuilder.build().get().uri(""/foo"").exchange().block();
-					secondBuilder.build().get().uri(""/foo"").exchange().block();
+					firstBuilder.build().get().uri(""/foo"").exchange()
+							.block(Duration.ofSeconds(30));
+					secondBuilder.build().get().uri(""/foo"").exchange()
+							.block(Duration.ofSeconds(30));
 					verify(firstConnector).connect(eq(HttpMethod.GET),
 							eq(URI.create(""http://first.example.org/foo"")), any());
 					verify(secondConnector).connect(eq(HttpMethod.GET),
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.test.autoconfigure.data.mongo;
 
+import java.time.Duration;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -44,10 +46,11 @@ public class DataMongoTestReactiveIntegrationTests {
 	public void testRepository() {
 		ExampleDocument exampleDocument = new ExampleDocument();
 		exampleDocument.setText(""Look, new @DataMongoTest!"");
-		exampleDocument = this.exampleRepository.save(exampleDocument).block();
+		exampleDocument = this.exampleRepository.save(exampleDocument)
+				.block(Duration.ofSeconds(30));
 		assertThat(exampleDocument.getId()).isNotNull();
-		assertThat(this.mongoTemplate.collectionExists(""exampleDocuments"").block())
-				.isTrue();
+		assertThat(this.mongoTemplate.collectionExists(""exampleDocuments"")
+				.block(Duration.ofSeconds(30))).isTrue();
 	}
 
 }
@@ -19,6 +19,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.URISyntaxException;
+import java.time.Duration;
 import java.util.Arrays;
 
 import io.undertow.Undertow;
@@ -114,7 +115,7 @@ private void testAccessLog(String prefix, String suffix, String expectedFile)
 		Mono<String> result = client.post().uri(""/test"").contentType(MediaType.TEXT_PLAIN)
 				.body(BodyInserters.fromObject(""Hello World"")).exchange()
 				.flatMap((response) -> response.bodyToMono(String.class));
-		assertThat(result.block()).isEqualTo(""Hello World"");
+		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(""Hello World"");
 		File accessLog = new File(accessLogDirectory, expectedFile);
 		awaitFile(accessLog);
 		assertThat(accessLogDirectory.listFiles()).contains(accessLog);
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.web.reactive.result.view;
 
+import java.time.Duration;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -46,12 +48,15 @@ public void init() {
 
 	@Test
 	public void resolveNonExistent() {
-		assertThat(this.resolver.resolveViewName(""bar"", null).block()).isNull();
+		assertThat(
+				this.resolver.resolveViewName(""bar"", null).block(Duration.ofSeconds(30)))
+						.isNull();
 	}
 
 	@Test
 	public void resolveExisting() {
-		assertThat(this.resolver.resolveViewName(""template"", null).block()).isNotNull();
+		assertThat(this.resolver.resolveViewName(""template"", null)
+				.block(Duration.ofSeconds(30))).isNotNull();
 	}
 
 }
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package org.springframework.boot.web.reactive.result.view;
 
 import java.nio.charset.StandardCharsets;
+import java.time.Duration;
 import java.util.Collections;
 
 import com.samskivert.mustache.Mustache;
@@ -59,9 +60,9 @@ public void viewResolvesHandlebars() {
 		view.setCharset(StandardCharsets.UTF_8.displayName());
 		view.setApplicationContext(this.context);
 		view.render(Collections.singletonMap(""World"", ""Spring""), MediaType.TEXT_HTML,
-				this.exchange).block();
-		assertThat(this.exchange.getResponse().getBodyAsString().block())
-				.isEqualTo(""Hello Spring"");
+				this.exchange).block(Duration.ofSeconds(30));
+		assertThat(this.exchange.getResponse().getBodyAsString()
+				.block(Duration.ofSeconds(30))).isEqualTo(""Hello Spring"");
 	}
 
 }
@@ -102,7 +102,7 @@ public void specificPort() {
 				.contentType(MediaType.TEXT_PLAIN)
 				.body(BodyInserters.fromObject(""Hello World"")).exchange()
 				.flatMap((response) -> response.bodyToMono(String.class));
-		assertThat(result.block()).isEqualTo(""Hello World"");
+		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(""Hello World"");
 		assertThat(this.webServer.getPort()).isEqualTo(specificPort);
 	}
 
@@ -131,7 +131,7 @@ protected final void testBasicSslWithKeyStore(String keyStore, String keyPasswor
 		Mono<String> result = client.post().uri(""/test"").contentType(MediaType.TEXT_PLAIN)
 				.body(BodyInserters.fromObject(""Hello World"")).exchange()
 				.flatMap((response) -> response.bodyToMono(String.class));
-		assertThat(result.block()).isEqualTo(""Hello World"");
+		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(""Hello World"");
 	}
 
 	protected ReactorClientHttpConnector buildTrustAllSslConnector() {
@@ -187,7 +187,7 @@ protected void testClientAuthSuccess(Ssl sslConfiguration,
 		Mono<String> result = client.post().uri(""/test"").contentType(MediaType.TEXT_PLAIN)
 				.body(BodyInserters.fromObject(""Hello World"")).exchange()
 				.flatMap((response) -> response.bodyToMono(String.class));
-		assertThat(result.block()).isEqualTo(""Hello World"");
+		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(""Hello World"");
 	}
 
 	@Test
@@ -245,15 +245,15 @@ protected WebClient.Builder getWebClient(
 	public void compressionOfResponseToGetRequest() {
 		WebClient client = prepareCompressionTest();
 		ResponseEntity<Void> response = client.get().exchange()
-				.flatMap((res) -> res.toEntity(Void.class)).block();
+				.flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30));
 		assertResponseIsCompressed(response);
 	}
 
 	@Test
 	public void compressionOfResponseToPostRequest() {
 		WebClient client = prepareCompressionTest();
 		ResponseEntity<Void> response = client.post().exchange()
-				.flatMap((res) -> res.toEntity(Void.class)).block();
+				.flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30));
 		assertResponseIsCompressed(response);
 	}
 
@@ -264,7 +264,7 @@ public void noCompressionForSmallResponse() {
 		compression.setMinResponseSize(3001);
 		WebClient client = prepareCompressionTest(compression);
 		ResponseEntity<Void> response = client.get().exchange()
-				.flatMap((res) -> res.toEntity(Void.class)).block();
+				.flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30));
 		assertResponseIsNotCompressed(response);
 	}
 
@@ -274,7 +274,7 @@ public void noCompressionForMimeType() {
 		compression.setMimeTypes(new String[] { ""application/json"" });
 		WebClient client = prepareCompressionTest(compression);
 		ResponseEntity<Void> response = client.get().exchange()
-				.flatMap((res) -> res.toEntity(Void.class)).block();
+				.flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30));
 		assertResponseIsNotCompressed(response);
 	}
 
@@ -285,7 +285,8 @@ public void noCompressionForUserAgent() {
 		compression.setExcludedUserAgents(new String[] { ""testUserAgent"" });
 		WebClient client = prepareCompressionTest(compression);
 		ResponseEntity<Void> response = client.get().header(""User-Agent"", ""testUserAgent"")
-				.exchange().flatMap((res) -> res.toEntity(Void.class)).block();
+				.exchange().flatMap((res) -> res.toEntity(Void.class))
+				.block(Duration.ofSeconds(30));
 		assertResponseIsNotCompressed(response);
 	}
 
@@ -16,6 +16,7 @@
 
 package sample.session;
 
+import java.time.Duration;
 import java.util.Base64;
 
 import org.junit.Test;
@@ -52,17 +53,19 @@ public void userDefinedMappingsSecureByDefault() throws Exception {
 		WebClient webClient = this.webClientBuilder
 				.baseUrl(""http://localhost:"" + this.port + ""/"").build();
 		ClientResponse response = webClient.get().header(""Authorization"", getBasicAuth())
-				.exchange().block();
+				.exchange().block(Duration.ofSeconds(30));
 		assertThat(response.statusCode()).isEqualTo(HttpStatus.OK);
 		ResponseCookie sessionCookie = response.cookies().getFirst(""SESSION"");
-		String sessionId = response.bodyToMono(String.class).block();
+		String sessionId = response.bodyToMono(String.class)
+				.block(Duration.ofSeconds(30));
 		response = webClient.get().cookie(""SESSION"", sessionCookie.getValue()).exchange()
-				.block();
+				.block(Duration.ofSeconds(30));
 		assertThat(response.statusCode()).isEqualTo(HttpStatus.OK);
-		assertThat(response.bodyToMono(String.class).block()).isEqualTo(sessionId);
+		assertThat(response.bodyToMono(String.class).block(Duration.ofSeconds(30)))
+				.isEqualTo(sessionId);
 		Thread.sleep(2000);
 		response = webClient.get().cookie(""SESSION"", sessionCookie.getValue()).exchange()
-				.block();
+				.block(Duration.ofSeconds(30));
 		assertThat(response.statusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
 	}
 
"
https://github.com/spring-projects/spring-boot/commit/0a55e3e7365a44d2b1986954912f938be5a77398,Polish 'Clarify edge case docs on ConditionalOnClass'  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/0a55e3e7365a44d2b1986954912f938be5a77398,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2015 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -36,14 +36,11 @@
 public @interface ConditionalOnClass {
 
 	/**
-	 * <p>
-	 * The classes that must be present. Since this annotation parsed by loading class
-	 * bytecode it is safe to specify classes here that may ultimately not be on the
+	 * The classes that must be present. Since this annotation is parsed by loading class
+	 * bytecode, it is safe to specify classes here that may ultimately not be on the
 	 * classpath, only if this annotation is directly on the affected component and
-	 * <b>not</b> if this annotation is used as a composed, meta-annotation. If this
-	 * is used as a meta annotation and the given class is not available at runtime
-	 * then this {@link @Conditional} will effectively be ignored. In order to use
-	 * this annotation as a meta-annotation, only use the {@link #name} attribute.
+	 * <b>not</b> if this annotation is used as a composed, meta-annotation. In order to
+	 * use this annotation as a meta-annotation, only use the {@link #name} attribute.
 	 * @return the classes that must be present
 	 */
 	Class<?>[] value() default {};
@@ -5839,16 +5839,18 @@ code by annotating `@Configuration` classes or individual `@Bean` methods.
 [[boot-features-class-conditions]]
 ==== Class conditions
 The `@ConditionalOnClass` and `@ConditionalOnMissingClass` annotations allows
-configuration to be included based on the presence or absence of specific classes.
-If you are using the `@ConditionalOnClass` annotation directly on the class you are conditionally
-registering, you can actually use the `value` attribute to refer to the real class,
-even though that class might not actually appear on the running application classpath.
-This is due to the fact that annotation metadata directly on a class is parsed
-using http://asm.ow2.org/[ASM]. You can also use the `name` attribute if you prefer to
-specify the class name using a `String` value, which is required if you are using
-`@ConditionalOnClass` or `@ConditionalOnMissingClass` as apart of a meta-annotation to
-compose your own composed annotations or in an `@Bean` method as neither of these cases
-are handled by ASM.
+configuration to be included based on the presence or absence of specific classes. Due to
+the fact that annotation metadata is parsed using http://asm.ow2.org/[ASM] you can
+actually use the `value` attribute to refer to the real class, even though that class
+might not actually appear on the running application classpath. You can also use the
+`name` attribute if you prefer to specify the class name using a `String` value.
+
+[TIP]
+====
+If you are using `@ConditionalOnClass` or `@ConditionalOnMissingClass` as apart of a
+meta-annotation to compose your own composed annotations you must use `name` as referring
+to the class in such a case is not handled.
+====
 
 
 
"
https://github.com/spring-projects/spring-boot/commit/0f9e8315bca4e3c8be824c2c1a1b7ec6defdc734,Replace use of deprecated Reactor MonoProcessor in tests  <enter> Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/0f9e8315bca4e3c8be824c2c1a1b7ec6defdc734,"@@ -45,7 +45,6 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Mono;
-import reactor.core.publisher.MonoProcessor;
 import reactor.core.publisher.Sinks;
 import reactor.netty.NettyPipeline;
 import reactor.netty.http.client.HttpClient;
@@ -499,7 +498,7 @@ public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response)
 
 	protected static class BlockingHandler implements HttpHandler {
 
-		private final BlockingQueue<MonoProcessor<Void>> processors = new ArrayBlockingQueue<>(10);
+		private final BlockingQueue<Sinks.Empty<Void>> processors = new ArrayBlockingQueue<>(10);
 
 		private volatile boolean blocking = true;
 
@@ -510,17 +509,17 @@ public BlockingHandler() {
 		@Override
 		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
 			if (this.blocking) {
-				Sinks.One<Void> completion = Sinks.one();
-				this.processors.add(MonoProcessor.fromSink(completion));
+				Sinks.Empty<Void> completion = Sinks.empty();
+				this.processors.add(completion);
 				return completion.asMono().then(Mono.empty());
 			}
 			return Mono.empty();
 		}
 
 		public void completeOne() {
 			try {
-				MonoProcessor<Void> processor = this.processors.take();
-				processor.onComplete();
+				Sinks.Empty<Void> processor = this.processors.take();
+				processor.tryEmitEmpty();
 			}
 			catch (InterruptedException ex) {
 				Thread.currentThread().interrupt();
@@ -535,7 +534,7 @@ public void awaitQueue() throws InterruptedException {
 
 		public void stopBlocking() {
 			this.blocking = false;
-			this.processors.forEach(MonoProcessor::onComplete);
+			this.processors.forEach(Sinks.Empty::tryEmitEmpty);
 		}
 
 	}
"
https://github.com/spring-projects/spring-boot/commit/11b7fd832d15856244bcaf3b1ec031e9eb1b6dc6,"Report non-matching outer class conditions  <enter> Update ConditionEvaluationReport so that, whenever a negative outcome is added for a source, any existing outcomes for inner classes of that source are updated with a non-matching outcome that indicates that the outer configuration did not match. <enter> Conditions are evaluated in two phases; PARSE_CONFIGURATION first and REGISTER_BEAN second. If a parent class’s conditions match in PARSE_CONFIGURATION then its inner classes will have their PARSE_CONFIGURATION conditions evaluated. If they all match, the inner class will be reported as a positive match in the auto-configuration report even if the outer class does not match as a result of the subsequent evaluation of a REGISTER_BEAN condition. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/11b7fd832d15856244bcaf3b1ec031e9eb1b6dc6,"@@ -20,13 +20,16 @@
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
 
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
 import org.springframework.context.annotation.Condition;
+import org.springframework.context.annotation.ConditionContext;
+import org.springframework.core.type.AnnotatedTypeMetadata;
 import org.springframework.util.Assert;
 import org.springframework.util.ObjectUtils;
 
@@ -36,13 +39,18 @@
  * @author Greg Turnquist
  * @author Dave Syer
  * @author Phillip Webb
+ * @author Andy Wilkinson
  */
 public class ConditionEvaluationReport {
 
 	private static final String BEAN_NAME = ""autoConfigurationReport"";
 
+	private static final AncestorsMatchedCondition ANCESTOR_CONDITION = new AncestorsMatchedCondition();
+
 	private final SortedMap<String, ConditionAndOutcomes> outcomes = new TreeMap<String, ConditionAndOutcomes>();
 
+	private boolean addedAncestorOutcomes;
+
 	private ConditionEvaluationReport parent;
 
 	/**
@@ -67,16 +75,36 @@ public void recordConditionEvaluation(String source, Condition condition,
 			this.outcomes.put(source, new ConditionAndOutcomes());
 		}
 		this.outcomes.get(source).add(condition, outcome);
+		this.addedAncestorOutcomes = false;
 	}
 
 	/**
 	 * Returns condition outcomes from this report, grouped by the source.
 	 * @return the condition outcomes
 	 */
 	public Map<String, ConditionAndOutcomes> getConditionAndOutcomesBySource() {
+		if (!this.addedAncestorOutcomes) {
+			for (Map.Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {
+				if (!entry.getValue().isFullMatch()) {
+					addNoMatchOutcomeToAncestors(entry.getKey());
+				}
+			}
+			this.addedAncestorOutcomes = true;
+		}
 		return Collections.unmodifiableMap(this.outcomes);
 	}
 
+	private void addNoMatchOutcomeToAncestors(String source) {
+		String prefix = source + ""$"";
+		for (Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {
+			if (entry.getKey().startsWith(prefix)) {
+				ConditionOutcome outcome = new ConditionOutcome(false, ""Ancestor '""
+						+ source + ""' did not match"");
+				entry.getValue().add(ANCESTOR_CONDITION, outcome);
+			}
+		}
+	}
+
 	/**
 	 * The parent report (from a parent BeanFactory if there is one).
 	 * @return the parent report (or null if there isn't one)
@@ -186,6 +214,20 @@ public boolean equals(Object obj) {
 		public int hashCode() {
 			return this.condition.getClass().hashCode() * 31 + this.outcome.hashCode();
 		}
+
+		@Override
+		public String toString() {
+			return this.condition.getClass() + "" "" + this.outcome;
+		}
+	}
+
+	private static class AncestorsMatchedCondition implements Condition {
+
+		@Override
+		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
+			throw new UnsupportedOperationException();
+		}
+
 	}
 
 }
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2013 the original author or authors.
+ * Copyright 2012-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -26,16 +26,23 @@
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.springframework.beans.factory.annotation.Configurable;
 import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
 import org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.ConditionAndOutcome;
 import org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.ConditionAndOutcomes;
 import org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration;
 import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;
+import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Condition;
+import org.springframework.context.annotation.ConditionContext;
+import org.springframework.context.annotation.Conditional;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.ConfigurationCondition;
 import org.springframework.context.annotation.Import;
+import org.springframework.core.type.AnnotatedTypeMetadata;
+import org.springframework.util.ClassUtils;
 
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.equalTo;
@@ -51,7 +58,7 @@
  * @author Greg Turnquist
  * @author Phillip Webb
  */
-public class AutoConfigurationReportTests {
+public class ConditionEvaluationReportTests {
 
 	private DefaultListableBeanFactory beanFactory;
 
@@ -225,6 +232,23 @@ public void duplicateOutcomes() {
 		context.close();
 	}
 
+	@Test
+	public void negativeOuterPositiveInnerBean() throws Exception {
+		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
+		EnvironmentTestUtils.addEnvironment(context, ""test.present=true"");
+		context.register(NegativeOuterConfig.class);
+		context.refresh();
+		ConditionEvaluationReport report = ConditionEvaluationReport.get(context
+				.getBeanFactory());
+		Map<String, ConditionAndOutcomes> sourceOutcomes = report
+				.getConditionAndOutcomesBySource();
+		assertThat(context.containsBean(""negativeOuterPositiveInnerBean""), equalTo(false));
+		String negativeConfig = NegativeOuterConfig.class.getName();
+		assertThat(sourceOutcomes.get(negativeConfig).isFullMatch(), equalTo(false));
+		String positiveConfig = NegativeOuterConfig.PositiveInnerConfig.class.getName();
+		assertThat(sourceOutcomes.get(positiveConfig).isFullMatch(), equalTo(false));
+	}
+
 	private int getNumberOfOutcomes(ConditionAndOutcomes outcomes) {
 		Iterator<ConditionAndOutcome> iterator = outcomes.iterator();
 		int numberOfOutcomesAdded = 0;
@@ -235,16 +259,89 @@ private int getNumberOfOutcomes(ConditionAndOutcomes outcomes) {
 		return numberOfOutcomesAdded;
 	}
 
-	@Configurable
+	@Configuration
 	@Import(WebMvcAutoConfiguration.class)
 	static class Config {
 
 	}
 
-	@Configurable
+	@Configuration
 	@Import(MultipartAutoConfiguration.class)
 	static class DuplicateConfig {
 
 	}
 
+	@Configuration
+	@Conditional({ ConditionEvaluationReportTests.MatchParseCondition.class,
+			ConditionEvaluationReportTests.NoMatchBeanCondition.class })
+	public static class NegativeOuterConfig {
+
+		@Configuration
+		@Conditional({ ConditionEvaluationReportTests.MatchParseCondition.class })
+		public static class PositiveInnerConfig {
+
+			@Bean
+			public String negativeOuterPositiveInnerBean() {
+				return ""negativeOuterPositiveInnerBean"";
+			}
+
+		}
+	}
+
+	static class TestMatchCondition extends SpringBootCondition implements
+			ConfigurationCondition {
+
+		private final ConfigurationPhase phase;
+		private final boolean match;
+
+		public TestMatchCondition(ConfigurationPhase phase, boolean match) {
+			this.phase = phase;
+			this.match = match;
+		}
+
+		@Override
+		public ConfigurationPhase getConfigurationPhase() {
+			return this.phase;
+		}
+
+		@Override
+		public ConditionOutcome getMatchOutcome(ConditionContext context,
+				AnnotatedTypeMetadata metadata) {
+			return new ConditionOutcome(this.match, ClassUtils.getShortName(getClass()));
+		}
+
+	}
+
+	static class MatchParseCondition extends TestMatchCondition {
+
+		public MatchParseCondition() {
+			super(ConfigurationPhase.PARSE_CONFIGURATION, true);
+		}
+
+	}
+
+	static class MatchBeanCondition extends TestMatchCondition {
+
+		public MatchBeanCondition() {
+			super(ConfigurationPhase.REGISTER_BEAN, true);
+		}
+
+	}
+
+	static class NoMatchParseCondition extends TestMatchCondition {
+
+		public NoMatchParseCondition() {
+			super(ConfigurationPhase.PARSE_CONFIGURATION, false);
+		}
+
+	}
+
+	static class NoMatchBeanCondition extends TestMatchCondition {
+
+		public NoMatchBeanCondition() {
+			super(ConfigurationPhase.REGISTER_BEAN, false);
+		}
+
+	}
+
 }
"
https://github.com/spring-projects/spring-boot/commit/14bd404b71fcb967d4af282e839a763112ecd40c,Document AWS Elastic Beanstalk deployment  <enter> Update the reference documentation to include details of Amazon Elastic Beanstalk. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/14bd404b71fcb967d4af282e839a763112ecd40c,"@@ -294,6 +294,88 @@ run the app.
 
 
 
+[[cloud-deployment-aws]]
+=== Amazon Web Services (AWS)
+Amazon Web Services offers multiple ways to install Spring Boot based applications, either
+as traditional web applications (war) or as executable jar files with an embedded web
+server. Options include :
+
+* AWS Elastic Beanstalk
+* AWS Code Deploy
+* AWS OPS Works
+* AWS Cloud Formation
+* AWS Container Registry
+
+Each has different features and pricing model, here we will describe only the simplest
+option : AWS Elastic Beanstalk.
+
+
+
+==== AWS Elastic Beanstalk
+As described in the official http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html[Elastic
+Beanstalk Java guide], there are two main options to deploy a Java application; You can
+either us the ""`Tomcat Platform`"" or the ""`Java SE platform`"".
+
+
+
+===== Using the Tomcat platform
+This option applies to Spring Boot projects producing a war file. There is no any special
+configuration required, just follow the official guide.
+
+
+
+===== Using the Java SE platform
+This option applies to Spring Boot projects producing a jar file and running an embedded
+web container. Elastic Beanstalk environments run an nginx instance on port 80 to proxy
+the actual application, running on port 5000. To configure it, add the following to your
+`application.properties`:
+
+[indent=0]
+----
+	server.port=5000
+----
+
+
+
+===== Best practices
+
+====== Uploading binaries instead of sources
+By default Elastic Beanstalk uploads sources and compile them in AWS. To upload the
+binaries instead, add the following to your `.elasticbeanstalk/config.yml` file:
+
+
+
+[source,xml,indent=0,subs=""verbatim,quotes,attributes""]
+----
+	deploy:
+		artifact: target/demo-0.0.1-SNAPSHOT.jar
+----
+
+
+
+====== Reduce costs by setting the environment type
+By default an Elastic Beanstalk environment is load balanced. The load balancer has a cost
+perspective, to avoid it, set the environment type to ""`Single instance`"" as described
+http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity[in the Amazon documentation].
+Single instance environments can be created using the CLI as well using the following
+command:
+
+[indent=0]
+----
+	eb create -s
+----
+
+
+
+==== Summary
+This is one of the easiest way to get to AWS, but there are more things
+to cover, e.g.: how to integrate Elastic Beanstalk into any CI / CD tool, using the
+Elastic Beanstalk maven plugin instead of the CLI, etc. There is a
+https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/[blog]
+covering these topics more in detail.
+
+
+
 [[cloud-deployment-boxfuse]]
 === Boxfuse and Amazon Web Services
 https://boxfuse.com/[Boxfuse] works by turning your Spring Boot executable jar or war
"
https://github.com/spring-projects/spring-boot/commit/1c0bcc13cfa3aa00a8fea96e2ecb2e1867859a96,Set UserDetailsService in default AuthenticationManagerBuilder  <enter> Only affects the default AuthenticationManagerBuilder (so when users are not overriding the default global user details). Makes the UserDetailsService effectively available as it would be if we used AuthenticationManagerBuilder.inMemoryAuthentication() as a shared object in the HttpSecurity. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/1c0bcc13cfa3aa00a8fea96e2ecb2e1867859a96,"@@ -16,6 +16,7 @@
 
 package org.springframework.boot.autoconfigure.security;
 
+import java.lang.reflect.Field;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
@@ -46,6 +47,7 @@
 import org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;
 import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer;
 import org.springframework.stereotype.Component;
+import org.springframework.util.ReflectionUtils;
 
 /**
  * Configuration for a Spring Security in-memory {@link AuthenticationManager}. Can be
@@ -171,9 +173,21 @@ public void configure(AuthenticationManagerBuilder auth) throws Exception {
 			Set<String> roles = new LinkedHashSet<String>(user.getRole());
 			withUser(user.getName()).password(user.getPassword()).roles(
 					roles.toArray(new String[roles.size()]));
+			setField(auth, ""defaultUserDetailsService"", getUserDetailsService());
 			super.configure(auth);
 		}
 
+		private void setField(Object target, String name, Object value) {
+			try {
+				Field field = ReflectionUtils.findField(target.getClass(), name);
+				ReflectionUtils.makeAccessible(field);
+				ReflectionUtils.setField(field, target, value);
+			}
+			catch (Exception e) {
+				logger.info(""Could not set "" + name);
+			}
+		}
+
 	}
 
 	/**
@@ -49,6 +49,7 @@
 import org.springframework.security.core.Authentication;
 import org.springframework.security.core.AuthenticationException;
 import org.springframework.security.core.authority.AuthorityUtils;
+import org.springframework.security.core.userdetails.UserDetailsService;
 import org.springframework.security.web.FilterChainProxy;
 import org.springframework.security.web.SecurityFilterChain;
 import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
@@ -190,6 +191,19 @@ public void testOverrideAuthenticationManager() throws Exception {
 				this.context.getBean(AuthenticationManager.class));
 	}
 
+	@Test
+	public void testDefaultAuthenticationManagerMakesUserDetailsAvailable()
+			throws Exception {
+		this.context = new AnnotationConfigWebApplicationContext();
+		this.context.setServletContext(new MockServletContext());
+		this.context.register(UserDetailsSecurityCustomizer.class,
+				SecurityAutoConfiguration.class, ServerPropertiesAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
+		this.context.refresh();
+		assertNotNull(this.context.getBean(UserDetailsSecurityCustomizer.class)
+				.getUserDetails().loadUserByUsername(""user""));
+	}
+
 	@Test
 	public void testOverrideAuthenticationManagerAndInjectIntoSecurityFilter()
 			throws Exception {
@@ -380,4 +394,21 @@ public void init(AuthenticationManagerBuilder auth) throws Exception {
 
 	}
 
+	@Configuration
+	protected static class UserDetailsSecurityCustomizer extends
+			WebSecurityConfigurerAdapter {
+
+		private UserDetailsService userDetails;
+
+		@Override
+		protected void configure(HttpSecurity http) throws Exception {
+			this.userDetails = http.getSharedObject(UserDetailsService.class);
+		}
+
+		public UserDetailsService getUserDetails() {
+			return this.userDetails;
+		}
+
+	}
+
 }
"
https://github.com/spring-projects/spring-boot/commit/56ded38f5d6b6cc1d3e7a6bd6d131a7dac33b0c9,Generate default values from Duration and Period .ZERO  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/56ded38f5d6b6cc1d3e7a6bd6d131a7dac33b0c9,"@@ -98,6 +98,8 @@ private static class FieldCollector implements TreeVisitor {
 			values.put(""StandardCharsets.UTF_8"", ""UTF-8"");
 			values.put(""StandardCharsets.UTF_16"", ""UTF-16"");
 			values.put(""StandardCharsets.US_ASCII"", ""US-ASCII"");
+			values.put(""Duration.ZERO"", 0);
+			values.put(""Period.ZERO"", 0);
 			WELL_KNOWN_STATIC_FINALS = Collections.unmodifiableMap(values);
 		}
 
@@ -94,6 +94,7 @@ void getFieldValues() throws Exception {
 		assertThat(values.get(""durationMinutes"")).isEqualTo(""30m"");
 		assertThat(values.get(""durationHours"")).isEqualTo(""40h"");
 		assertThat(values.get(""durationDays"")).isEqualTo(""50d"");
+		assertThat(values.get(""durationZero"")).isEqualTo(0);
 		assertThat(values.get(""dataSizeNone"")).isNull();
 		assertThat(values.get(""dataSizeBytes"")).isEqualTo(""5B"");
 		assertThat(values.get(""dataSizeKilobytes"")).isEqualTo(""10KB"");
@@ -105,6 +106,7 @@ void getFieldValues() throws Exception {
 		assertThat(values.get(""periodWeeks"")).isEqualTo(""2w"");
 		assertThat(values.get(""periodMonths"")).isEqualTo(""10m"");
 		assertThat(values.get(""periodYears"")).isEqualTo(""15y"");
+		assertThat(values.get(""periodZero"")).isEqualTo(0);
 	}
 
 	@SupportedAnnotationTypes({ ""org.springframework.boot.configurationsample.ConfigurationProperties"" })
@@ -125,6 +125,8 @@ public class FieldValues {
 
 	private Duration durationDays = Duration.ofDays(50);
 
+	private Duration durationZero = Duration.ZERO;
+
 	private DataSize dataSizeNone;
 
 	private DataSize dataSizeBytes = DataSize.ofBytes(5);
@@ -147,4 +149,6 @@ public class FieldValues {
 
 	private Period periodYears = Period.ofYears(15);
 
+	private Period periodZero = Period.ZERO;
+
 }
"
https://github.com/spring-projects/spring-boot/commit/8014b21ad96cf109735e092bb1d4e1c251634064,Upgrade to Maven Enforcer Plugin 3.0.0-M2  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/8014b21ad96cf109735e092bb1d4e1c251634064,"@@ -193,7 +193,7 @@
 		<maven-compiler-plugin.version>3.7.0</maven-compiler-plugin.version>
 		<maven-dependency-plugin.version>3.0.2</maven-dependency-plugin.version>
 		<maven-deploy-plugin.version>2.8.2</maven-deploy-plugin.version>
-		<maven-enforcer-plugin.version>3.0.0-M1</maven-enforcer-plugin.version>
+		<maven-enforcer-plugin.version>3.0.0-M2</maven-enforcer-plugin.version>
 		<maven-failsafe-plugin.version>2.22.0</maven-failsafe-plugin.version>
 		<maven-install-plugin.version>2.5.2</maven-install-plugin.version>
 		<maven-invoker-plugin.version>3.1.0</maven-invoker-plugin.version>
"
https://github.com/spring-projects/spring-boot/commit/e28b98c59d43190b5ca8ea3ae4deac50c9737766,Remove multi config runApplication extension  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/e28b98c59d43190b5ca8ea3ae4deac50c9737766,"@@ -42,16 +42,3 @@ inline fun <reified T : Any> runApplication(vararg args: String): ConfigurableAp
  */
 inline fun <reified T : Any> runApplication(vararg args: String, init: SpringApplication.() -> Unit): ConfigurableApplicationContext =
 		SpringApplication(T::class.java).apply(init).run(*args)
-
-
-/**
- * Top level function acting as a Kotlin shortcut allowing to write
- * `runApplication(arrayOf(FooApplication::class, FooConfiguration::class), arg1, arg2) { // Optional SpringApplication customization ... }`
- * instead of instantiating `SpringApplication` class, customize it and then invoking
- * `run(arrayOf(arg1, arg2))`.`
- *
- * @author Sebastien Deleuze
- * @since 2.0.0
- */
-fun runApplication(primarySources: Array<KClass<*>>, vararg args: String, init: SpringApplication.() -> Unit = {}): ConfigurableApplicationContext =
-		SpringApplication(*primarySources.map { it.java }.toTypedArray()).apply(init).run(*args)
@@ -70,42 +70,6 @@ class SpringApplicationExtensionsTests {
 		assertEquals(environment, context.environment)
 	}
 
-	@Test
-	fun `Kotlin runApplication(array of KClass) top level function`() {
-		val context = runApplication(arrayOf(ExampleConfig::class, ExampleWebConfig::class))
-		assertNotNull(context)
-	}
-
-	@Test
-	fun `Kotlin runApplication(array of KClass) top level function with a custom environment`() {
-		val environment = StandardEnvironment()
-		val context = runApplication(arrayOf(ExampleConfig::class, ExampleWebConfig::class)) {
-			setEnvironment(environment)
-		}
-		assertNotNull(context)
-		assertEquals(environment, context.environment)
-	}
-
-	@Test
-	fun `Kotlin runApplication(array of KClass, arg1, arg2) top level function`() {
-		val context = runApplication(arrayOf(ExampleConfig::class, ExampleWebConfig::class), ""--debug"", ""spring"", ""boot"")
-		val args = context.getBean<ApplicationArguments>()
-		assertArrayEquals(arrayOf(""spring"", ""boot""), args.nonOptionArgs.toTypedArray())
-		assertTrue(args.containsOption(""debug""))
-	}
-
-	@Test
-	fun `Kotlin runApplication(array of KClass, arg1, arg2) top level function with a custom environment`() {
-		val environment = StandardEnvironment()
-		val context = runApplication(arrayOf(ExampleConfig::class, ExampleWebConfig::class), ""--debug"", ""spring"", ""boot"") {
-			setEnvironment(environment)
-		}
-		val args = context.getBean<ApplicationArguments>()
-		assertArrayEquals(arrayOf(""spring"", ""boot""), args.nonOptionArgs.toTypedArray())
-		assertTrue(args.containsOption(""debug""))
-		assertEquals(environment, context.environment)
-	}
-
 
 	@Configuration
 	internal open class ExampleConfig
"
https://github.com/spring-projects/spring-boot/commit/e2cb7a75458d83c1358faf9e19194b9ab8fe0454,Align default scopes for Google with changes in Spring Security 5.0.1  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/e2cb7a75458d83c1358faf9e19194b9ab8fe0454,"@@ -119,8 +119,7 @@ public void getClientRegistrationsWhenUsingCommonProviderShouldAdapt() {
 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE);
 		assertThat(adapted.getRedirectUriTemplate())
 				.isEqualTo(""{baseUrl}/login/oauth2/code/{registrationId}"");
-		assertThat(adapted.getScopes()).containsExactly(""openid"", ""profile"", ""email"",
-				""address"", ""phone"");
+		assertThat(adapted.getScopes()).containsExactly(""openid"", ""profile"", ""email"");
 		assertThat(adapted.getClientName()).isEqualTo(""Google"");
 	}
 
@@ -203,8 +202,7 @@ public void getClientRegistrationsWhenProviderNotSpecifiedShouldUseRegistrationI
 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE);
 		assertThat(adapted.getRedirectUriTemplate())
 				.isEqualTo(""{baseUrl}/login/oauth2/code/{registrationId}"");
-		assertThat(adapted.getScopes()).containsExactly(""openid"", ""profile"", ""email"",
-				""address"", ""phone"");
+		assertThat(adapted.getScopes()).containsExactly(""openid"", ""profile"", ""email"");
 		assertThat(adapted.getClientName()).isEqualTo(""Google"");
 	}
 
"
https://github.com/spring-projects/spring-boot/commit/e79ef9b73baca23e11db3c60fd3af2ca3a3dfb70,Add option to exclude devtools from fat jar  <enter> Add an `excludeDevtools` property to both the Maven and Gradle plugin that removes `org.springframework.boot:spring-boot-devtools` (if necessary) when repackaging the application. <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/e79ef9b73baca23e11db3c60fd3af2ca3a3dfb70,"@@ -395,6 +395,10 @@ want the other Boot features but not this one)
 |`embeddedLaunchScriptProperties`
 |Additional properties that to be expanded in the launch script. The default script
  supports a `mode` property which can contain the values `auto`, `service` or `run`.
+
+|`excludeDevtools`
+|Boolean flag to indicate if the devtools jar should be excluded from the repackaged
+archives. Defaults to `false`.
 |===
 
 
@@ -844,6 +844,10 @@ applied to other modules using your project. Gradle does not support `optional`
 dependencies out-of-the-box so you may want to have a look to the
 {propdeps-plugin}[`propdeps-plugin`] in the meantime.
 
+TIP: If you want to ensure that devtools is never included in a production build, you can
+use set the `excludeDevtools` build property to completely remove the JAR. The property is
+supported with both the Maven and Gradle plugins.
+
 
 
 [[using-boot-devtools-property-defaults]]
@@ -47,19 +47,24 @@ public static void createProject() throws IOException {
 	}
 
 	@Test
-	public void repackagingEnabled() {
+	public void repackagingEnabled() throws IOException {
 		project.newBuild().forTasks(""clean"", ""build"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"").run();
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=false"")
+				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
-		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
+		File repackageFile = new File(buildLibs, ""repackage.jar"");
+		assertTrue(repackageFile.exists());
 		assertTrue(new File(buildLibs, ""repackage.jar.original"").exists());
 		assertFalse(new File(buildLibs, ""repackage-sources.jar.original"").exists());
+		assertTrue(isDevToolsJarIncluded(repackageFile));
 	}
 
 	@Test
 	public void repackagingDisabled() {
 		project.newBuild().forTasks(""clean"", ""build"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"")
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"",
+						""-PexcludeDevtools=false"")
 				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
@@ -70,7 +75,8 @@ public void repackagingDisabled() {
 	@Test
 	public void repackagingDisabledWithCustomRepackagedJar() {
 		project.newBuild().forTasks(""clean"", ""build"", ""customRepackagedJar"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"")
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"",
+						""-PexcludeDevtools=false"")
 				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
@@ -84,7 +90,8 @@ public void repackagingDisabledWithCustomRepackagedJar() {
 	public void repackagingDisabledWithCustomRepackagedJarUsingStringJarTaskReference() {
 		project.newBuild()
 				.forTasks(""clean"", ""build"", ""customRepackagedJarWithStringReference"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"")
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"",
+						""-PexcludeDevtools=false"")
 				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
@@ -97,7 +104,9 @@ public void repackagingDisabledWithCustomRepackagedJarUsingStringJarTaskReferenc
 	@Test
 	public void repackagingEnabledWithCustomRepackagedJar() {
 		project.newBuild().forTasks(""clean"", ""build"", ""customRepackagedJar"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"").run();
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=false"")
+				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
 		assertTrue(new File(buildLibs, ""repackage.jar.original"").exists());
@@ -110,7 +119,9 @@ public void repackagingEnabledWithCustomRepackagedJar() {
 	public void repackagingEnableWithCustomRepackagedJarUsingStringJarTaskReference() {
 		project.newBuild()
 				.forTasks(""clean"", ""build"", ""customRepackagedJarWithStringReference"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"").run();
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=false"")
+				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
 		assertTrue(new File(buildLibs, ""repackage.jar.original"").exists());
@@ -124,10 +135,38 @@ public void repackageWithFileDependency() throws Exception {
 		FileCopyUtils.copy(new File(""src/test/resources/foo.jar""),
 				new File(""target/repackage/foo.jar""));
 		project.newBuild().forTasks(""clean"", ""build"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"").run();
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=false"")
+				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		JarFile jarFile = new JarFile(new File(buildLibs, ""repackage.jar""));
 		assertThat(jarFile.getEntry(""lib/foo.jar""), notNullValue());
 		jarFile.close();
 	}
+
+	@Test
+	public void repackagingEnabledExcludeDevtools() throws IOException {
+		project.newBuild().forTasks(""clean"", ""build"")
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=true"")
+				.run();
+		File buildLibs = new File(""target/repackage/build/libs"");
+		File repackageFile = new File(buildLibs, ""repackage.jar"");
+		assertTrue(repackageFile.exists());
+		assertTrue(new File(buildLibs, ""repackage.jar.original"").exists());
+		assertFalse(new File(buildLibs, ""repackage-sources.jar.original"").exists());
+		assertFalse(isDevToolsJarIncluded(repackageFile));
+	}
+
+	private boolean isDevToolsJarIncluded(File repackageFile) throws IOException {
+		JarFile jarFile = new JarFile(repackageFile);
+		try {
+			String name = ""lib/spring-boot-devtools-"" + BOOT_VERSION + "".jar"";
+			return jarFile.getEntry(name) != null;
+		}
+		finally {
+			jarFile.close();
+		}
+	}
+
 }
@@ -18,11 +18,13 @@ apply plugin: 'java'
 dependencies {
 	compile 'org.springframework.boot:spring-boot-starter-freemarker'
 	compile 'org.springframework.boot:spring-boot-starter-web'
+	compile 'org.springframework.boot:spring-boot-devtools'
 	compile files(""foo.jar"")
 }
 
 springBoot {
 	mainClass = 'foo.bar.Baz'
+	excludeDevtools = Boolean.valueOf(project.excludeDevtools)
 }
 
 bootRepackage.enabled = Boolean.valueOf(project.repackage)
@@ -38,6 +38,7 @@
  *
  * @author Phillip Webb
  * @author Dave Syer
+ * @author Stephane Nicoll
  */
 public class SpringBootPluginExtension {
 
@@ -87,6 +88,11 @@ public class SpringBootPluginExtension {
 	 */
 	Set<String> requiresUnpack;
 
+	/**
+	 * Whether Spring Boot Devtools should be excluded from the fat jar.
+	 */
+	boolean excludeDevtools = false;
+
 	/**
 	 * Location of an agent jar to attach to the VM when running the application with
 	 * runJar task.
@@ -186,6 +192,14 @@ public void setRequiresUnpack(Set<String> requiresUnpack) {
 		this.requiresUnpack = requiresUnpack;
 	}
 
+	public boolean isExcludeDevtools() {
+		return this.excludeDevtools;
+	}
+
+	public void setExcludeDevtools(boolean excludeDevtools) {
+		this.excludeDevtools = excludeDevtools;
+	}
+
 	public File getAgent() {
 		return this.agent;
 	}
@@ -155,12 +155,26 @@ private void libraries(Set<GradleLibrary> libraries, LibraryCallback callback)
 		if (libraries != null) {
 			Set<String> duplicates = getDuplicates(libraries);
 			for (GradleLibrary library : libraries) {
-				library.setIncludeGroupName(duplicates.contains(library.getName()));
-				callback.library(library);
+				if (!isExcluded(library)) {
+					library.setIncludeGroupName(duplicates.contains(library.getName()));
+					callback.library(library);
+				}
 			}
 		}
 	}
 
+	private boolean isExcluded(GradleLibrary library) {
+		if (this.extension.isExcludeDevtools() && isDevToolsJar(library)) {
+			return true;
+		}
+		return false;
+	}
+
+	private boolean isDevToolsJar(GradleLibrary library) {
+		return ""org.springframework.boot"".equals(library.getGroup())
+				&& library.getName().startsWith(""spring-boot-devtools"");
+	}
+
 	private Set<String> getDuplicates(Set<GradleLibrary> libraries) {
 		Set<String> duplicates = new HashSet<String>();
 		Set<String> seen = new HashSet<String>();
@@ -187,6 +201,10 @@ public void setIncludeGroupName(boolean includeGroupName) {
 			this.includeGroupName = includeGroupName;
 		}
 
+		public String getGroup() {
+			return this.group;
+		}
+
 		@Override
 		public String getName() {
 			String name = super.getName();
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2014 the original author or authors.
+ * Copyright 2012-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.maven;
 
+import java.util.Arrays;
 import java.util.List;
 
 import org.apache.maven.artifact.Artifact;
@@ -29,6 +30,10 @@
  */
 public class ExcludeFilter extends DependencyFilter {
 
+	public ExcludeFilter(Exclude... excludes) {
+		this(Arrays.asList(excludes));
+	}
+
 	public ExcludeFilter(List<Exclude> excludes) {
 		super(excludes);
 	}
@@ -35,6 +35,7 @@
 import org.apache.maven.plugins.annotations.ResolutionScope;
 import org.apache.maven.project.MavenProject;
 import org.apache.maven.project.MavenProjectHelper;
+import org.apache.maven.shared.artifact.filter.collection.ArtifactsFilter;
 import org.springframework.boot.loader.tools.DefaultLaunchScript;
 import org.springframework.boot.loader.tools.LaunchScript;
 import org.springframework.boot.loader.tools.Layout;
@@ -153,6 +154,13 @@ public class RepackageMojo extends AbstractDependencyFilterMojo {
 	@Parameter
 	private Properties embeddedLaunchScriptProperties;
 
+	/**
+	 * Exclude Spring Boot devtools.
+	 * @since 1.3
+	 */
+	@Parameter(defaultValue = ""false"")
+	private boolean excludeDevtools;
+
 	@Override
 	public void execute() throws MojoExecutionException, MojoFailureException {
 		if (this.project.getPackaging().equals(""pom"")) {
@@ -190,7 +198,7 @@ protected String findMainMethod(JarFile source) throws IOException {
 		}
 
 		Set<Artifact> artifacts = filterDependencies(this.project.getArtifacts(),
-				getFilters());
+				getFilters(getAdditionalFilters()));
 
 		Libraries libraries = new ArtifactsLibraries(artifacts, this.requiresUnpack,
 				getLog());
@@ -213,6 +221,17 @@ else if (!source.equals(target)) {
 		}
 	}
 
+	private ArtifactsFilter[] getAdditionalFilters() {
+		if (this.excludeDevtools) {
+			Exclude exclude = new Exclude();
+			exclude.setGroupId(""org.springframework.boot"");
+			exclude.setArtifactId(""spring-boot-devtools"");
+			ExcludeFilter filter = new ExcludeFilter(exclude);
+			return new ArtifactsFilter[] { filter };
+		}
+		return new ArtifactsFilter[] {};
+	}
+
 	private File getTargetFile() {
 		String classifier = (this.classifier == null ? """" : this.classifier.trim());
 		if (classifier.length() > 0 && !classifier.startsWith(""-"")) {
"
https://github.com/spring-projects/spring-boot/commit/f0c53726420e84267ba9ccff1640ed0bdf7f5fd7,Align with Spring Framework 5's new Commons Logging adapter  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/f0c53726420e84267ba9ccff1640ed0bdf7f5fd7,"@@ -16,27 +16,22 @@
 
 package org.springframework.boot.autoconfigure.logging;
 
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogConfigurationException;
-import org.apache.commons.logging.LogFactory;
-import org.apache.commons.logging.impl.LogFactoryImpl;
-import org.apache.commons.logging.impl.NoOpLog;
-import org.junit.After;
-import org.junit.Before;
+
+import ch.qos.logback.classic.Level;
+import ch.qos.logback.classic.Logger;
+import ch.qos.logback.classic.LoggerContext;
+import org.junit.Rule;
 import org.junit.Test;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
+import org.slf4j.impl.StaticLoggerBinder;
 
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport;
 import org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration;
 import org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration;
 import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
 import org.springframework.boot.context.event.ApplicationFailedEvent;
+import org.springframework.boot.testutil.InternalOutputCapture;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -47,10 +42,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willAnswer;
-import static org.mockito.Mockito.mock;
 
 /**
  * Tests for {@link AutoConfigurationReportLoggingInitializer}.
@@ -60,66 +51,21 @@
  */
 public class AutoConfigurationReportLoggingInitializerTests {
 
-	private static ThreadLocal<Log> logThreadLocal = new ThreadLocal<>();
-
-	private Log log;
-
-	private AutoConfigurationReportLoggingInitializer initializer;
-
-	protected List<String> debugLog = new ArrayList<>();
-
-	protected List<String> infoLog = new ArrayList<>();
-
-	@Before
-	public void setup() {
-		setupLogging(true, true);
-	}
-
-	private void setupLogging(boolean debug, boolean info) {
-		this.log = mock(Log.class);
-		logThreadLocal.set(this.log);
-
-		given(this.log.isDebugEnabled()).willReturn(debug);
-		willAnswer(new Answer<Object>() {
-
-			@Override
-			public Object answer(InvocationOnMock invocation) throws Throwable {
-				return AutoConfigurationReportLoggingInitializerTests.this.debugLog
-						.add(String.valueOf(invocation.getArguments()[0]));
-			}
-
-		}).given(this.log).debug(any());
-
-		given(this.log.isInfoEnabled()).willReturn(info);
-		willAnswer(new Answer<Object>() {
+	@Rule
+	public InternalOutputCapture outputCapture = new InternalOutputCapture();
 
-			@Override
-			public Object answer(InvocationOnMock invocation) throws Throwable {
-				return AutoConfigurationReportLoggingInitializerTests.this.infoLog
-						.add(String.valueOf(invocation.getArguments()[0]));
-			}
-
-		}).given(this.log).info(any());
-
-		LogFactory.releaseAll();
-		System.setProperty(LogFactory.FACTORY_PROPERTY, MockLogFactory.class.getName());
-		this.initializer = new AutoConfigurationReportLoggingInitializer();
-	}
-
-	@After
-	public void cleanup() {
-		System.clearProperty(LogFactory.FACTORY_PROPERTY);
-		LogFactory.releaseAll();
-	}
+	private AutoConfigurationReportLoggingInitializer initializer = new AutoConfigurationReportLoggingInitializer();
 
 	@Test
 	public void logsDebugOnContextRefresh() {
 		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
 		this.initializer.initialize(context);
 		context.register(Config.class);
 		context.refresh();
-		this.initializer.onApplicationEvent(new ContextRefreshedEvent(context));
-		assertThat(this.debugLog.size()).isNotEqualTo(0);
+		withDebugLogging(() -> {
+			this.initializer.onApplicationEvent(new ContextRefreshedEvent(context));
+		});
+		assertThat(this.outputCapture.toString()).contains(""AUTO-CONFIGURATION REPORT"");
 	}
 
 	@Test
@@ -132,16 +78,16 @@ public void logsDebugOnError() {
 			fail(""Did not error"");
 		}
 		catch (Exception ex) {
-			this.initializer.onApplicationEvent(new ApplicationFailedEvent(
-					new SpringApplication(), new String[0], context, ex));
+			withDebugLogging(() -> {
+				this.initializer.onApplicationEvent(new ApplicationFailedEvent(
+						new SpringApplication(), new String[0], context, ex));
+			});
 		}
-		assertThat(this.debugLog.size()).isNotEqualTo(0);
-		assertThat(this.infoLog.size()).isEqualTo(0);
+		assertThat(this.outputCapture.toString()).contains(""AUTO-CONFIGURATION REPORT"");
 	}
 
 	@Test
 	public void logsInfoOnErrorIfDebugDisabled() {
-		setupLogging(false, true);
 		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
 		this.initializer.initialize(context);
 		context.register(ErrorConfig.class);
@@ -153,8 +99,9 @@ public void logsInfoOnErrorIfDebugDisabled() {
 			this.initializer.onApplicationEvent(new ApplicationFailedEvent(
 					new SpringApplication(), new String[0], context, ex));
 		}
-		assertThat(this.debugLog.size()).isEqualTo(0);
-		assertThat(this.infoLog.size()).isNotEqualTo(0);
+		assertThat(this.outputCapture.toString()).contains(""Error starting""
+				+ "" ApplicationContext. To display the auto-configuration report re-run""
+				+ "" your application with 'debug' enabled."");
 	}
 
 	@Test
@@ -165,13 +112,10 @@ public void logsOutput() throws Exception {
 		ConditionEvaluationReport.get(context.getBeanFactory())
 				.recordExclusions(Arrays.asList(""com.foo.Bar""));
 		context.refresh();
-		this.initializer.onApplicationEvent(new ContextRefreshedEvent(context));
-		for (String message : this.debugLog) {
-			System.out.println(message);
-		}
-		// Just basic sanity check, test is for visual inspection
-		String l = this.debugLog.get(0);
-		assertThat(l)
+		withDebugLogging(() -> {
+			this.initializer.onApplicationEvent(new ContextRefreshedEvent(context));
+		});
+		assertThat(this.outputCapture.toString())
 				.contains(""not a servlet web application (OnWebApplicationCondition)"");
 	}
 
@@ -199,20 +143,23 @@ public void noErrorIfNotInitialized() throws Exception {
 		this.initializer
 				.onApplicationEvent(new ApplicationFailedEvent(new SpringApplication(),
 						new String[0], null, new RuntimeException(""Planned"")));
-		assertThat(this.infoLog.get(0))
+		assertThat(this.outputCapture.toString())
 				.contains(""Unable to provide auto-configuration report"");
 	}
 
-	public static class MockLogFactory extends LogFactoryImpl {
-
-		@Override
-		public Log getInstance(String name) throws LogConfigurationException {
-			if (AutoConfigurationReportLoggingInitializer.class.getName().equals(name)) {
-				return logThreadLocal.get();
-			}
-			return new NoOpLog();
+	private void withDebugLogging(Runnable runnable) {
+		LoggerContext context = (LoggerContext) StaticLoggerBinder.getSingleton()
+				.getLoggerFactory();
+		Logger logger = context
+				.getLogger(AutoConfigurationReportLoggingInitializer.class);
+		Level currentLevel = logger.getLevel();
+		logger.setLevel(Level.DEBUG);
+		try {
+			runnable.run();
+		}
+		finally {
+			logger.setLevel(currentLevel);
 		}
-
 	}
 
 	@Configuration
@@ -155,8 +155,10 @@ protected String[] getSources(String... args) {
 		return sources;
 	}
 
-	public String getOutput() {
-		return this.outputCapture.toString();
+	private String getOutput() {
+		String output = this.outputCapture.toString();
+		this.outputCapture.reset();
+		return output;
 	}
 
 	@Override
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -33,20 +33,17 @@ public class DirectorySourcesIntegrationTests {
 
 	@Test
 	public void runDirectory() throws Exception {
-		this.cli.run(""code"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""code"")).contains(""Hello World"");
 	}
 
 	@Test
 	public void runDirectoryRecursive() throws Exception {
-		this.cli.run("""");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run("""")).contains(""Hello World"");
 	}
 
 	@Test
 	public void runPathPattern() throws Exception {
-		this.cli.run(""**/*.groovy"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""**/*.groovy"")).contains(""Hello World"");
 	}
 
 }
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -47,14 +47,12 @@ public void grabAntBuilder() throws Exception {
 	// this will fail
 	@Test
 	public void securityDependencies() throws Exception {
-		this.cli.run(""secure.groovy"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""secure.groovy"")).contains(""Hello World"");
 	}
 
 	@Test
 	public void dataJpaDependencies() throws Exception {
-		this.cli.run(""data-jpa.groovy"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""data-jpa.groovy"")).contains(""Hello World"");
 	}
 
 	@Test
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -59,6 +59,7 @@ public void bannerAndLoggingIsOutputByDefault() throws Exception {
 
 	@Test
 	public void quietModeSuppressesAllCliOutput() throws Exception {
+		this.cli.run(""quiet.groovy"");
 		String output = this.cli.run(""quiet.groovy"", ""-q"");
 		assertThat(output).isEqualTo(""Ssshh"");
 	}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -159,8 +159,7 @@ public void deviceSample() throws Exception {
 
 	@Test
 	public void caching() throws Exception {
-		this.cli.run(""caching.groovy"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""caching.groovy"")).contains(""Hello World"");
 	}
 
 }
@@ -105,10 +105,10 @@ public void resolveArtifactWithDependencies() throws Exception {
 	@Test
 	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
 	public void resolveShorthandArtifactWithDependencies() throws Exception {
-		List<File> resolved = this.resolver.resolve(Arrays.asList(""spring-core""));
+		List<File> resolved = this.resolver.resolve(Arrays.asList(""spring-beans""));
 		assertThat(resolved).hasSize(2);
-		assertThat(getNames(resolved)).has((Condition) Matched.by(
-				hasItems(startsWith(""commons-logging-""), startsWith(""spring-core-""))));
+		assertThat(getNames(resolved)).has((Condition) Matched
+				.by(hasItems(startsWith(""spring-core-""), startsWith(""spring-beans-""))));
 	}
 
 	@Test
@@ -66,8 +66,8 @@ private AetherGrapeEngine createGrapeEngine(
 	public void dependencyResolution() {
 		Map<String, Object> args = new HashMap<>();
 		createGrapeEngine(this.springMilestones).grab(args,
-				createDependency(""org.springframework"", ""spring-jdbc"", ""3.2.4.RELEASE""));
-		assertThat(this.groovyClassLoader.getURLs()).hasSize(5);
+				createDependency(""org.springframework"", ""spring-jdbc"", null));
+		assertThat(this.groovyClassLoader.getURLs()).hasSize(4);
 	}
 
 	@Test
@@ -153,10 +153,10 @@ public void dependencyResolutionWithCustomClassLoader() {
 		args.put(""classLoader"", customClassLoader);
 
 		createGrapeEngine(this.springMilestones).grab(args,
-				createDependency(""org.springframework"", ""spring-jdbc"", ""3.2.4.RELEASE""));
+				createDependency(""org.springframework"", ""spring-jdbc"", null));
 
 		assertThat(this.groovyClassLoader.getURLs().length).isEqualTo(0);
-		assertThat(customClassLoader.getURLs().length).isEqualTo(5);
+		assertThat(customClassLoader.getURLs().length).isEqualTo(4);
 	}
 
 	@Test
@@ -30,6 +30,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-cassandra</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 </project>
@@ -26,6 +26,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-couchbase</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 	<build>
@@ -26,6 +26,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-elasticsearch</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 	<build>
@@ -54,6 +54,10 @@
 					<groupId>org.aspectj</groupId>
 					<artifactId>aspectjrt</artifactId>
 				</exclusion>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
 			</exclusions>
 		</dependency>
 		<dependency>
@@ -26,6 +26,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-ldap</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 	<build>
@@ -31,6 +31,10 @@
 					<groupId>org.mongodb</groupId>
 					<artifactId>mongo-java-driver</artifactId>
 				</exclusion>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
 			</exclusions>
 		</dependency>
 		<dependency>
@@ -35,6 +35,10 @@
 					<groupId>org.mongodb</groupId>
 					<artifactId>mongo-java-driver</artifactId>
 				</exclusion>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
 			</exclusions>
 		</dependency>
 	</dependencies>
@@ -25,6 +25,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-neo4j</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 </project>
@@ -26,6 +26,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-redis</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 		<dependency>
 			<groupId>redis.clients</groupId>
@@ -38,6 +38,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-rest-webmvc</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 	<build>
@@ -31,11 +31,21 @@
 					<groupId>log4j</groupId>
 					<artifactId>log4j</artifactId>
 				</exclusion>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
 			</exclusions>
 		</dependency>
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-solr</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 		<dependency>
 			 <groupId>org.apache.httpcomponents</groupId>
@@ -31,10 +31,6 @@
 			<groupId>org.apache.logging.log4j</groupId>
 			<artifactId>log4j-core</artifactId>
 		</dependency>
-		<dependency>
-			<groupId>org.slf4j</groupId>
-			<artifactId>jcl-over-slf4j</artifactId>
-		</dependency>
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>jul-to-slf4j</artifactId>
@@ -22,10 +22,6 @@
 			<groupId>ch.qos.logback</groupId>
 			<artifactId>logback-classic</artifactId>
 		</dependency>
-		<dependency>
-			<groupId>org.slf4j</groupId>
-			<artifactId>jcl-over-slf4j</artifactId>
-		</dependency>
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>jul-to-slf4j</artifactId>
@@ -238,7 +238,7 @@ public void enableBannerInLogViaProperty() throws Exception {
 		application.setWebApplicationType(WebApplicationType.NONE);
 		this.context = application.run(""--spring.main.banner-mode=log"");
 		verify(application, atLeastOnce()).setBannerMode(Banner.Mode.LOG);
-		assertThat(this.output.toString()).contains(""o.s.boot.SpringApplication"");
+		assertThat(this.output.toString()).contains(""o.s.b.SpringApplication"");
 	}
 
 	@Test
@@ -28,16 +28,15 @@
 import java.util.Map;
 import java.util.Properties;
 
-import ch.qos.logback.classic.BasicConfigurator;
-import ch.qos.logback.classic.Logger;
-import ch.qos.logback.classic.LoggerContext;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.config.LoggerConfig;
 import org.assertj.core.api.Condition;
 import org.junit.After;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
-import org.slf4j.LoggerFactory;
 
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.WebApplicationType;
@@ -90,14 +89,6 @@ public class ConfigFileApplicationListenerTests {
 
 	private ConfigurableApplicationContext context;
 
-	@Before
-	public void resetLogging() {
-		LoggerContext loggerContext = ((Logger) LoggerFactory.getLogger(getClass()))
-				.getLoggerContext();
-		loggerContext.reset();
-		new BasicConfigurator().configure(loggerContext);
-	}
-
 	@After
 	public void cleanUp() {
 		if (this.context != null) {
@@ -442,7 +433,9 @@ private void validateProfilePrecedence(String... profiles) {
 		ApplicationPreparedEvent event = new ApplicationPreparedEvent(
 				new SpringApplication(), new String[0],
 				new AnnotationConfigApplicationContext());
-		this.initializer.onApplicationEvent(event);
+		withDebugLogging(() -> {
+			this.initializer.onApplicationEvent(event);
+		});
 		String log = this.out.toString();
 
 		// First make sure that each profile got processed only once
@@ -463,6 +456,23 @@ private void validateProfilePrecedence(String... profiles) {
 		}
 	}
 
+	private void withDebugLogging(Runnable runnable) {
+		LoggerContext loggingContext = (LoggerContext) LogManager.getContext(true);
+		org.apache.logging.log4j.core.config.Configuration configuration = loggingContext
+				.getConfiguration();
+		configuration.addLogger(ConfigFileApplicationListener.class.getName(),
+				new LoggerConfig(ConfigFileApplicationListener.class.getName(),
+						Level.DEBUG, true));
+		loggingContext.updateLoggers();
+		try {
+			runnable.run();
+		}
+		finally {
+			configuration.removeLogger(ConfigFileApplicationListener.class.getName());
+			loggingContext.updateLoggers();
+		}
+	}
+
 	private String createLogForProfile(String profile) {
 		String suffix = profile != null ? ""-"" + profile : """";
 		String string = "".properties)"";
@@ -34,12 +34,15 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
 import org.slf4j.bridge.SLF4JBridgeHandler;
 
 import org.springframework.boot.ApplicationPid;
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.context.event.ApplicationFailedEvent;
 import org.springframework.boot.context.event.ApplicationStartingEvent;
+import org.springframework.boot.junit.runner.classpath.ClassPathExclusions;
+import org.springframework.boot.junit.runner.classpath.ModifiedClassPathRunner;
 import org.springframework.boot.logging.AbstractLoggingSystem;
 import org.springframework.boot.logging.LogFile;
 import org.springframework.boot.logging.LogLevel;
@@ -61,14 +64,17 @@
 import static org.hamcrest.Matchers.not;
 
 /**
- * Tests for {@link LoggingApplicationListener}.
+ * Tests for {@link LoggingApplicationListener} with Logback.
  *
  * @author Dave Syer
  * @author Phillip Webb
  * @author Andy Wilkinson
  * @author Stephane Nicoll
  * @author Ben Hale
  */
+
+@RunWith(ModifiedClassPathRunner.class)
+@ClassPathExclusions(""log4j*.jar"")
 public class LoggingApplicationListenerTests {
 
 	private static final String[] NO_ARGS = {};
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -23,8 +23,8 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.logging.Level;
+import java.util.logging.Logger;
 
-import org.apache.commons.logging.impl.Jdk14Logger;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -64,15 +64,15 @@ public boolean accept(File pathname) {
 	@Rule
 	public InternalOutputCapture output = new InternalOutputCapture();
 
-	private Jdk14Logger logger;
+	private Logger logger;
 
 	private Locale defaultLocale;
 
 	@Before
 	public void init() throws SecurityException, IOException {
 		this.defaultLocale = Locale.getDefault();
 		Locale.setDefault(Locale.ENGLISH);
-		this.logger = new Jdk14Logger(getClass().getName());
+		this.logger = Logger.getLogger(getClass().getName());
 	}
 
 	@After
@@ -82,7 +82,7 @@ public void clearLocale() {
 
 	@After
 	public void resetLogger() {
-		this.logger.getLogger().setLevel(Level.OFF);
+		this.logger.setLevel(Level.OFF);
 	}
 
 	@Test
@@ -161,9 +161,9 @@ public void getSupportedLevels() {
 	public void setLevel() throws Exception {
 		this.loggingSystem.beforeInitialize();
 		this.loggingSystem.initialize(null, null, null);
-		this.logger.debug(""Hello"");
+		this.logger.fine(""Hello"");
 		this.loggingSystem.setLogLevel(""org.springframework.boot"", LogLevel.DEBUG);
-		this.logger.debug(""Hello"");
+		this.logger.fine(""Hello"");
 		assertThat(StringUtils.countOccurrencesOf(this.output.toString(), ""Hello""))
 				.isEqualTo(1);
 	}
@@ -0,0 +1,17 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<Configuration status=""warn"" name=""test"" packages="""">
+	<Properties>
+		<Property name=""LOG_EXCEPTION_CONVERSION_WORD"">%xwEx</Property>
+		<Property name=""LOG_LEVEL_PATTERN"">%5p</Property>
+	</Properties>
+	<Appenders>
+		<Console name=""STDOUT"" target=""SYSTEM_OUT"" follow=""true"">
+			<PatternLayout pattern=""%clr{%d{yyyy-MM-dd HH:mm:ss.SSS}}{faint} %clr{${LOG_LEVEL_PATTERN}} %clr{${sys:PID}}{magenta} %clr{---}{faint} %clr{[%15.15t]}{faint} %clr{%-40.40c{1.}}{cyan} %clr{:}{faint} %m%n${sys:LOG_EXCEPTION_CONVERSION_WORD}""/>
+		</Console>
+	</Appenders>
+	<Loggers>
+		<Root level=""info"">
+			<AppenderRef ref=""STDOUT""/>
+		</Root>
+	</Loggers>
+</Configuration>
"
https://github.com/spring-projects/spring-boot/commit/f9094143d72a99bb52ad6414568ee2c93611115c,Remove undefined FILE appender from basic log4j config  <enter> Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/f9094143d72a99bb52ad6414568ee2c93611115c,"@@ -1,4 +1,4 @@
-log4j.rootCategory=INFO, CONSOLE, FILE
+log4j.rootCategory=INFO, CONSOLE
 
 PID=????
 LOG_PATTERN=[%d{yyyy-MM-dd HH:mm:ss.SSS}] boot%X{context} - ${PID} %5p [%t] --- %c{1}: %m%n
"
https://github.com/square/okhttp/commit/067aa1f4495f9c93bafca183a6d655fa81b139d6,Throw UnknownHostException again from HttpURLConnection  <enter> This is to address issue  <issue_link> . ,https://api.github.com/repos/square/okhttp/commits/067aa1f4495f9c93bafca183a6d655fa81b139d6,"@@ -17,8 +17,10 @@
 
 import com.squareup.okhttp.UrlComponentEncodingTester.Component;
 import com.squareup.okhttp.UrlComponentEncodingTester.Encoding;
+import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
@@ -949,6 +951,27 @@ public final class HttpUrlTest {
     assertEquals(null, HttpUrl.get(uri));
   }
 
+  @Test public void fromJavaNetUrl_checked() throws Exception {
+    HttpUrl httpUrl = HttpUrl.getChecked(""http://username:password@host/path?query#fragment"");
+    assertEquals(""http://username:password@host/path?query#fragment"", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
+    try {
+      HttpUrl.getChecked(""mailto:user@example.com"");
+      fail();
+    } catch (MalformedURLException e) {
+    }
+  }
+
+  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
+    try {
+      HttpUrl.getChecked(""http://hostw ithspace/"");
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   @Test public void composeQueryWithComponents() throws Exception {
     HttpUrl base = HttpUrl.parse(""http://host/"");
     HttpUrl url = base.newBuilder().addQueryParameter(""a+=& b"", ""c+=& d"").build();
@@ -3178,6 +3178,37 @@ private void zeroLengthPayload(String method)
     assertContent(""abc"", client.open(server.getUrl(""/"")));
   }
 
+  @Test public void urlWithSpaceInHost() throws Exception {
+    URLConnection urlConnection = client.open(new URL(""http://and roid.com/""));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
+    server.enqueue(new MockResponse());
+    URLConnection urlConnection =
+        client.open(new URL(""http://and roid.com/""), server.toProxyAddress());
+
+    try {
+      // This test is to check that a NullPointerException is not thrown.
+      urlConnection.getInputStream();
+      fail(); // the RI makes a bogus proxy request for ""GET http://and roid.com/ HTTP/1.1""
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlHostWithNul() throws Exception {
+    URLConnection urlConnection = client.open(new URL(""http://host\u0000/""));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
   public Buffer gzip(String data) throws IOException {
     Buffer result = new Buffer();
@@ -46,10 +46,12 @@
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.Permission;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -321,14 +323,16 @@ private void initHttpEngine() throws IOException {
     }
   }
 
-  private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableSink requestBody, Response priorResponse) {
+  private HttpEngine newHttpEngine(String method, Connection connection, RetryableSink requestBody,
+      Response priorResponse) throws MalformedURLException, UnknownHostException {
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(method)
         ? EMPTY_REQUEST_BODY
         : null;
+    URL url = getURL();
+    HttpUrl httpUrl = Internal.instance.getHttpUrlChecked(url.toString());
     Request.Builder builder = new Request.Builder()
-        .url(getURL())
+        .url(httpUrl)
         .method(method, placeholderBody);
     Headers headers = requestHeaders.build();
     for (int i = 0, size = headers.size(); i < size; i++) {
@@ -561,7 +561,9 @@ public String fragment() {
 
   /** Returns the URL that would be retrieved by following {@code link} from this URL. */
   public HttpUrl resolve(String link) {
-    return new Builder().parse(this, link);
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(this, link);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
   }
 
   public Builder newBuilder() {
@@ -584,11 +586,13 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns a new {@code OkUrl} representing {@code url} if it is a well-formed HTTP or HTTPS URL,
-   * or null if it isn't.
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or null if it isn't.
    */
   public static HttpUrl parse(String url) {
-    return new Builder().parse(null, url);
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
   }
 
   /**
@@ -599,6 +603,29 @@ public static HttpUrl get(URL url) {
     return parse(url.toString());
   }
 
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or throws an exception if it isn't.
+   *
+   * @throws MalformedURLException if there was a non-host related URL issue
+   * @throws UnknownHostException if the host was invalid
+   */
+  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    switch (result) {
+      case SUCCESS:
+        return builder.build();
+      case INVALID_HOST:
+        throw new UnknownHostException(""Invalid host: "" + url);
+      case UNSUPPORTED_SCHEME:
+      case MISSING_SCHEME:
+      case INVALID_PORT:
+      default:
+        throw new MalformedURLException(""Invalid URL: "" + result + "" for "" + url);
+    }
+  }
+
   public static HttpUrl get(URI uri) {
     return parse(uri.toString());
   }
@@ -883,7 +910,15 @@ public HttpUrl build() {
       return result.toString();
     }
 
-    HttpUrl parse(HttpUrl base, String input) {
+    enum ParseResult {
+      SUCCESS,
+      MISSING_SCHEME,
+      UNSUPPORTED_SCHEME,
+      INVALID_PORT,
+      INVALID_HOST,
+    }
+
+    ParseResult parse(HttpUrl base, String input) {
       int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
       int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
 
@@ -897,12 +932,12 @@ HttpUrl parse(HttpUrl base, String input) {
           this.scheme = ""http"";
           pos += ""http:"".length();
         } else {
-          return null; // Not an HTTP scheme.
+          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
         }
       } else if (base != null) {
         this.scheme = base.scheme;
       } else {
-        return null; // No scheme.
+        return ParseResult.MISSING_SCHEME; // No scheme.
       }
 
       // Authority.
@@ -960,12 +995,12 @@ HttpUrl parse(HttpUrl base, String input) {
               if (portColonOffset + 1 < componentDelimiterOffset) {
                 this.host = canonicalizeHost(input, pos, portColonOffset);
                 this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (this.port == -1) return null; // Invalid port.
+                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
               } else {
                 this.host = canonicalizeHost(input, pos, portColonOffset);
                 this.port = defaultPort(this.scheme);
               }
-              if (this.host == null) return null; // Invalid host.
+              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
               pos = componentDelimiterOffset;
               break authority;
           }
@@ -1002,7 +1037,7 @@ HttpUrl parse(HttpUrl base, String input) {
             input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false);
       }
 
-      return build();
+      return ParseResult.SUCCESS;
     }
 
     private void resolvePath(String input, int pos, int limit) {
@@ -27,9 +27,11 @@
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
 import java.net.CookieHandler;
+import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.URLConnection;
+import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
@@ -157,6 +159,11 @@ public void callEnqueue(Call call, Callback responseCallback, boolean forWebSock
       public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
         tlsConfiguration.apply(sslSocket, isFallback);
       }
+
+      @Override public HttpUrl getHttpUrlChecked(String url)
+          throws MalformedURLException, UnknownHostException {
+        return HttpUrl.getChecked(url);
+      }
     };
   }
 
@@ -21,13 +21,16 @@
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.UnknownHostException;
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import okio.BufferedSink;
@@ -85,6 +88,9 @@ public abstract void connectAndSetOwner(OkHttpClient client, Connection connecti
   public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
       boolean isFallback);
 
+  public abstract HttpUrl getHttpUrlChecked(String url)
+      throws MalformedURLException, UnknownHostException;
+
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
   public abstract void callEngineReleaseConnection(Call call) throws IOException;
"
https://github.com/square/okhttp/commit/5373160d20aa3f6036ff5ebc91137888c4abffbe,"Whole operation timeouts  <enter> Strictly-speaking this change is backwards-incompatible because it adds a new method to the Call interface. The method returns the call's timeout. <enter> The trickiest part of this is signaling the end of the call, which occurs after the last byte is consumed of the last follow up request, or when the call fails. Fortunately this is made easier by borrowing the sites used by EventListener, which already plots out where calls end. <enter>  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/5373160d20aa3f6036ff5ebc91137888c4abffbe,"@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpURLConnection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSink;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WholeOperationTimeoutTest {
+  /** A large response body. Smaller bodies might successfully read after the socket is closed! */
+  private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client = defaultClient();
+
+  @Test public void timeoutWritingRequest() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutWritingRequestWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutProcessing() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutProcessingWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutReadingResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(500);
+    try {
+      response.body().source().readUtf8();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutReadingResponseWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          Thread.sleep(500);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        try {
+          response.body().source().readUtf8();
+          fail();
+        } catch (IOException e) {
+          exceptionRef.set(e);
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/b"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/c"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/d"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/e"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/f"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url(""/a""))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void noTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(250, TimeUnit.MILLISECONDS)
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .post(sleepingRequestBody(250))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(250);
+    response.body().source().readUtf8();
+    response.close();
+    assertFalse(call.isCanceled());
+  }
+
+  private RequestBody sleepingRequestBody(final int sleepMillis) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse(""text/plain"");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        try {
+          sink.writeUtf8(""abc"");
+          sink.flush();
+          Thread.sleep(sleepMillis);
+          sink.writeUtf8(""def"");
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    };
+  }
+}
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import okio.Timeout;
 
 /**
  * A call is a request that has been prepared for execution. A call can be canceled. As this object
@@ -80,6 +81,12 @@ public interface Call extends Cloneable {
 
   boolean isCanceled();
 
+  /**
+   * Returns a timeout that applies to the entire call: writing the request, server processing,
+   * and reading the response.
+   */
+  Timeout timeout();
+
   /**
    * Create a new, identical call to this one which can be enqueued or executed even if this call
    * has already been.
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.Socket;
@@ -37,11 +38,11 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.platform.Platform;
+import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
@@ -187,6 +188,10 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         return ((RealCall) call).streamAllocation();
       }
 
+      @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
+        return ((RealCall) call).timeoutExit(e);
+      }
+
       @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
         return RealCall.newRealCall(client, originalRequest, true);
       }
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -28,12 +29,15 @@
 import okhttp3.internal.http.RealInterceptorChain;
 import okhttp3.internal.http.RetryAndFollowUpInterceptor;
 import okhttp3.internal.platform.Platform;
+import okio.AsyncTimeout;
+import okio.Timeout;
 
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+  final AsyncTimeout timeout;
 
   /**
    * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
@@ -53,6 +57,11 @@ private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSoc
     this.originalRequest = originalRequest;
     this.forWebSocket = forWebSocket;
     this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
+    this.timeout = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        cancel();
+      }
+    };
   }
 
   static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
@@ -72,20 +81,32 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       executed = true;
     }
     captureCallStackTrace();
+    timeout.enter();
     eventListener.callStart(this);
     try {
       client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException(""Canceled"");
       return result;
     } catch (IOException e) {
+      e = timeoutExit(e);
       eventListener.callFailed(this, e);
       throw e;
     } finally {
       client.dispatcher().finished(this);
     }
   }
 
+  @Nullable IOException timeoutExit(@Nullable IOException cause) {
+    if (!timeout.exit()) return cause;
+
+    InterruptedIOException e = new InterruptedIOException(""timeout"");
+    if (cause != null) {
+      e.initCause(cause);
+    }
+    return e;
+  }
+
   private void captureCallStackTrace() {
     Object callStackTrace = Platform.get().getStackTraceForCloseable(""response.body().close()"");
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
@@ -105,6 +126,10 @@ private void captureCallStackTrace() {
     retryAndFollowUpInterceptor.cancel();
   }
 
+  @Override public Timeout timeout() {
+    return timeout;
+  }
+
   @Override public synchronized boolean isExecuted() {
     return executed;
   }
@@ -144,6 +169,7 @@ RealCall get() {
 
     @Override protected void execute() {
       boolean signalledCallback = false;
+      timeout.enter();
       try {
         Response response = getResponseWithInterceptorChain();
         if (retryAndFollowUpInterceptor.isCanceled()) {
@@ -154,6 +180,7 @@ RealCall get() {
           responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
+        e = timeoutExit(e);
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, ""Callback failure for "" + toLoggableString(), e);
@@ -15,7 +15,9 @@
  */
 package okhttp3.internal;
 
+import java.io.IOException;
 import java.net.Socket;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
@@ -73,5 +75,7 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
 
   public abstract StreamAllocation streamAllocation(Call call);
 
+  public abstract @Nullable IOException timeoutExit(Call call, @Nullable IOException e);
+
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 }
@@ -317,8 +317,10 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead
     }
 
     if (e != null) {
+      e = Internal.instance.timeoutExit(call, e);
       eventListener.callFailed(call, e);
     } else if (callEnd) {
+      Internal.instance.timeoutExit(call, null);
       eventListener.callEnd(call);
     }
   }
@@ -351,6 +353,7 @@ public void release() {
     }
     closeQuietly(socket);
     if (releasedConnection != null) {
+      Internal.instance.timeoutExit(call, null);
       eventListener.connectionReleased(call, releasedConnection);
       eventListener.callEnd(call);
     }
"
https://github.com/square/okhttp/commit/ff959f8fd550b8f55a47038ea4235b1b2ed2eaa8,Android Additional Tests ( <pr_link> ) ,https://api.github.com/repos/square/okhttp/commits/ff959f8fd550b8f55a47038ea4235b1b2ed2eaa8,"@@ -31,6 +31,10 @@ repositories {
   }
 }
 
+def isIDE = properties.containsKey('android.injected.invoked.from.ide') ||
+        (System.getenv(""XPC_SERVICE_NAME"") ?: """").contains(""intellij"") ||
+        System.getenv(""IDEA_INITIAL_DIRECTORY"") != null
+
 android {
   compileOptions {
     sourceCompatibility JavaVersion.VERSION_1_8
@@ -60,6 +64,17 @@ android {
             'notPackage': 'org.bouncycastle'
     ])
   }
+
+  if (!isIDE) {
+    sourceSets {
+      named(""androidTest"") {
+        it.java.srcDirs += project.file(""../okhttp-brotli/src/test/java"")
+        it.java.srcDirs += project.file(""../okhttp-dnsoverhttps/src/test/java"")
+        it.java.srcDirs += project.file(""../okhttp-logging-interceptor/src/test/java"")
+        it.java.srcDirs += project.file(""../okhttp-sse/src/test/java"")
+      }
+    }
+  }
 }
 
 dependencies {
@@ -77,10 +92,12 @@ dependencies {
   androidTestImplementation ""org.bouncycastle:bctls-jdk15to18:${versions.bouncycastle}""
   androidTestImplementation ""org.conscrypt:conscrypt-android:2.5.1""
   androidTestImplementation project(':mockwebserver-junit5')
-  androidTestImplementation project(':okhttp-tls')
+  androidTestImplementation project(':okhttp-brotli')
   androidTestImplementation project(':okhttp-dnsoverhttps')
   androidTestImplementation project(':okhttp-logging-interceptor')
+  androidTestImplementation project(':okhttp-sse')
   androidTestImplementation project(':okhttp-testing-support')
+  androidTestImplementation project(':okhttp-tls')
   androidTestImplementation 'androidx.test.ext:junit:1.1.2'
   androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
   androidTestImplementation 'org.apache.httpcomponents.client5:httpclient5:5.0'
@@ -331,6 +331,7 @@ class OkHttpTest(val server: MockWebServer) {
   }
 
   @Test
+  @Disabled(""cleartext required for additional okhttp wide tests"")
   fun testHttpRequestBlocked() {
     assumeTrue(Build.VERSION.SDK_INT >= 23)
 
@@ -671,6 +672,7 @@ class OkHttpTest(val server: MockWebServer) {
   }
 
   @Test
+  @Disabled(""TODO: currently logging okhttp3.internal.concurrent.TaskRunner, okhttp3.internal.http2.Http2"")
   fun testLoggingLevels() {
     enableTls()
 
@@ -1,4 +1,6 @@
 <manifest xmlns:android=""http://schemas.android.com/apk/res/android""
     package=""okhttp.android.test"">
+  <application
+      android:usesCleartextTraffic=""true"" />
   <uses-permission android:name=""android.permission.INTERNET"" />
 </manifest>
@@ -15,7 +15,7 @@ dependencies {
 
   testImplementation project(':okhttp-testing-support')
   testImplementation project(':mockwebserver-deprecated')
-  testRuntimeOnly project(':mockwebserver-junit5')
+  testImplementation project(':mockwebserver-junit5')
   testImplementation deps.conscrypt
   testImplementation deps.junit
   testImplementation deps.assertj
@@ -26,6 +26,7 @@
 import mockwebserver3.MockResponse;
 import mockwebserver3.MockWebServer;
 import mockwebserver3.RecordedRequest;
+import mockwebserver3.junit5.internal.MockWebServerExtension;
 import okhttp3.Cache;
 import okhttp3.Dns;
 import okhttp3.HttpUrl;
@@ -36,13 +37,15 @@
 import okio.ByteString;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+@ExtendWith(MockWebServerExtension.class)
 public class DnsOverHttpsTest {
   @RegisterExtension public final PlatformRule platform = new PlatformRule();
 
@@ -17,7 +17,7 @@ dependencies {
   testCompileOnly deps.jsr305
   testImplementation deps.junit
   testImplementation project(':mockwebserver')
-  testRuntimeOnly project(':mockwebserver-junit5')
+  testImplementation project(':mockwebserver-junit5')
   testImplementation project(':okhttp-testing-support')
   testImplementation project(':okhttp-tls')
   testImplementation deps.assertj
@@ -22,6 +22,7 @@
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 import javax.net.ssl.HostnameVerifier;
+import mockwebserver3.junit5.internal.MockWebServerExtension;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
@@ -42,6 +43,7 @@
 import okio.ByteString;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import static okhttp3.tls.internal.TlsUtil.localhost;
@@ -50,6 +52,7 @@
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeThat;
 
+@ExtendWith(MockWebServerExtension.class)
 public final class HttpLoggingInterceptorTest {
   private static final MediaType PLAIN = MediaType.get(""text/plain; charset=utf-8"");
 
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.net.UnknownHostException;
+import mockwebserver3.junit5.internal.MockWebServerExtension;
 import okhttp3.Call;
 import okhttp3.EventListener;
 import okhttp3.HttpUrl;
@@ -33,6 +34,7 @@
 import okhttp3.tls.HandshakeCertificates;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import static java.util.Arrays.asList;
@@ -42,6 +44,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+@ExtendWith(MockWebServerExtension.class)
 public final class LoggingEventListenerTest {
   private static final MediaType PLAIN = MediaType.get(""text/plain"");
 
@@ -98,7 +101,7 @@ public void get() throws Exception {
         .assertLogMatch(
             ""responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url=""
                 + url
-                + ""}"")
+                + ""\\}"")
         .assertLogMatch(""responseBodyStart"")
         .assertLogMatch(""responseBodyEnd: byteCount=6"")
         .assertLogMatch(""connectionReleased"")
@@ -135,7 +138,7 @@ public void post() throws IOException {
         .assertLogMatch(
             ""responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url=""
                 + url
-                + ""}"")
+                + ""\\}"")
         .assertLogMatch(""responseBodyStart"")
         .assertLogMatch(""responseBodyEnd: byteCount=0"")
         .assertLogMatch(""connectionReleased"")
@@ -177,12 +180,12 @@ public void secureGet() throws Exception {
                 + url.host()
                 + "":\\d+, proxy=DIRECT hostAddress=""
                 + url.host()
-                + ""/.+ cipherSuite=.+ protocol=h2}"")
+                + ""/.+ cipherSuite=.+ protocol=h2\\}"")
         .assertLogMatch(""requestHeadersStart"")
         .assertLogMatch(""requestHeadersEnd"")
         .assertLogMatch(""responseHeadersStart"")
         .assertLogMatch(
-            ""responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url="" + url + ""}"")
+            ""responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url="" + url + ""\\}"")
         .assertLogMatch(""responseBodyStart"")
         .assertLogMatch(""responseBodyEnd: byteCount=0"")
         .assertLogMatch(""connectionReleased"")
@@ -257,10 +260,10 @@ public void testCacheEvents() {
     listener.satisfactionFailure(call, response);
 
     logRecorder
-        .assertLogMatch(""cacheConditionalHit: Response\\{protocol=h2, code=200, message=, url="" + url + ""}"")
-        .assertLogMatch(""cacheHit: Response\\{protocol=h2, code=200, message=, url="" + url + ""}"")
+        .assertLogMatch(""cacheConditionalHit: Response\\{protocol=h2, code=200, message=, url="" + url + ""\\}"")
+        .assertLogMatch(""cacheHit: Response\\{protocol=h2, code=200, message=, url="" + url + ""\\}"")
         .assertLogMatch(""cacheMiss"")
-        .assertLogMatch(""satisfactionFailure: Response\\{protocol=h2, code=200, message=, url="" + url + ""}"")
+        .assertLogMatch(""satisfactionFailure: Response\\{protocol=h2, code=200, message=, url="" + url + ""\\}"")
         .assertNoMoreLogs();
   }
 
@@ -16,7 +16,7 @@ dependencies {
 
   testImplementation project(':okhttp-testing-support')
   testImplementation project(':mockwebserver')
-  testRuntimeOnly project(':mockwebserver-junit5')
+  testImplementation project(':mockwebserver-junit5')
   testImplementation deps.junit
   testImplementation deps.assertj
   testCompileOnly deps.jsr305
@@ -19,6 +19,7 @@
 import javax.annotation.Nullable;
 import mockwebserver3.MockResponse;
 import mockwebserver3.MockWebServer;
+import mockwebserver3.junit5.internal.MockWebServerExtension;
 import okhttp3.OkHttpClient;
 import okhttp3.OkHttpClientTestRule;
 import okhttp3.Request;
@@ -28,10 +29,12 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+@ExtendWith(MockWebServerExtension.class)
 public final class EventSourceHttpTest {
   @RegisterExtension public final PlatformRule platform = new PlatformRule();
 
"
