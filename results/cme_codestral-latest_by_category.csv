url,message,api_url,diff,c_why_in,c_why_in_expl,c_why_mw,c_why_mw_expl,c_why_di,c_why_di_expl,c_why_ir,c_why_ir_expl,c_why_do,c_why_do_expl,c_what_sc,c_what_sc_expl,c_what_dip,c_what_dip_expl,c_what_if,c_what_if_expl,c_what_mw,c_what_mw_expl
https://github.com/junit-team/junit4/commit/3171c4b29cb207e71fc2f752f0fbcb235bc8e784,"Relicense JUnit from CPL to EPL  <enter> EPL is the successor version of the CPL this makes re-licensing possible without seeking the approval of all contributors. <enter> CPL is actively hurting JUnit adaptation, it the following cases the deciding factor against JUnit was CPL. In both cases EPL would have been fine. * Netbeans can't ship JUnit [4] * OpenJDK uses TestNG instead of JUnit [5] <enter> Mike Milinkovich from the Eclipse Foundation wrote [1] <enter> > Back in 2009, the CPL was superseded by the EPL. This means that the > EPL is the successor version of the CPL. It also means that using the > CPL is the licensing equivalent of using deprecated code. > > Because the EPL is the successor version to the CPL, the 'new version > re-licensing' clause in Section 7 of the CPL applies. In other words, > you can re-license your project without seeking the approval of all > of your contributors. > The CPL and EPL basically differ by about one sentence, which you can > see here. The difference relates to the scope of patent licenses > terminated should someone sue another party for patent infringement. > This is the kind of stuff that lawyers love, but most developers > don't really care about. <enter> On the migration from CPL to EPL Mike Milinkovich wrote [2] <enter> > There was a two step process that was followed to make this happen. > First, following the terms of the CPL, IBM assigned the > responsibility to serve as the Agreement Steward of the CPL to the > Eclipse Foundation. Second, the Eclipse Foundation officially > recognized the EPL 1.0 as the new version of the CPL 1.0. In OSI > license terminology, the EPL now supersedes the CPL. > > A quick read of the two licenses will quickly show that they are very > very close. Other than their names and (previously) their Agreement > Stewards, the only substantive difference is the breadth of the > patent license termination in the event of a patent law suit. (See > the second paragraph of Section 7.) For more information on the > relationship between the CPL and the EPL see the EPL FAQ. <enter> You can find more information about the difference at [3]. <enter> The new `LICENSE.txt` is based on a plain text version of the EPL with formatted so that the diff is a clean as possible. <enter> I'll submit another pull request for the gh-pages branch. <enter>  [1]  http://mmilinkov.wordpress.com/2013/02/13/jruby-moves-to-the-epl/   [2]  http://mmilinkov.wordpress.com/2009/04/16/one-small-step-towards-reducing-license-proliferation/   [3]  http://www.eclipse.org/legal/eplfaq.php#EPLDIFFER   [4]  https://netbeans.org/community/releases/70/relnotes.html#deprecated   [5]  http://openjdk.java.net/jtreg/build.html ",https://api.github.com/repos/junit-team/junit4/commits/3171c4b29cb207e71fc2f752f0fbcb235bc8e784,"@@ -1,8 +1,8 @@
 JUnit
 
-Common Public License - v 1.0
+Eclipse Public License - v 1.0
 
-THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS COMMON PUBLIC
+THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC
 LICENSE (""AGREEMENT""). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM
 CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 
@@ -173,11 +173,7 @@ terms of this Agreement, and without further action by the parties hereto, such
 provision shall be reformed to the minimum extent necessary to make such
 provision valid and enforceable.
 
-If Recipient institutes patent litigation against a Contributor with respect to
-a patent applicable to software (including a cross-claim or counterclaim in a
-lawsuit), then any patent licenses granted by that Contributor to such
-Recipient under this Agreement shall terminate as of the date such litigation
-is filed. In addition, if Recipient institutes patent litigation against any
+If Recipient institutes patent litigation against any
 entity (including a cross-claim or counterclaim in a lawsuit) alleging that the
 Program itself (excluding combinations of the Program with other software or
 hardware) infringes such Recipient's patent(s), then such Recipient's rights
@@ -198,7 +194,7 @@ order to avoid inconsistency the Agreement is copyrighted and may only be
 modified in the following manner. The Agreement Steward reserves the right to
 publish new versions (including revisions) of this Agreement from time to time.
 No one other than the Agreement Steward has the right to modify this Agreement.
-IBM is the initial Agreement Steward. IBM may assign the responsibility to
+The Eclipse Foundation is the initial Agreement Steward. The Eclipse Foundation may assign the responsibility to
 serve as the Agreement Steward to a suitable separate entity. Each new version
 of the Agreement will be given a distinguishing version number. The Program
 (including Contributions) may always be distributed subject to the version of
@@ -16,7 +16,7 @@
   <property name=""testsrc"" location=""src/test/java"" />
   <property name=""testbin"" location=""${target}/test/java"" />
   <property name=""unjarred"" 
-            value=""**/*.jar, ${testfiles}, doc/**, README.md, .classpath, .project, cpl-v10.html"" />
+            value=""**/*.jar, ${testfiles}, doc/**, README.md, .classpath, .project, epl-v10.html"" />
 
   <property name=""binjar"" value=""junit-${version}.jar"" />
   <property name=""srcjar"" value=""junit-${version}-src.jar"" />
@@ -170,7 +170,7 @@
     </copy>
     <copy file=""README.md"" tofile=""${dist}/README.md"" />
     <copy file=""BUILDING"" tofile=""${dist}/BUILDING"" />
-    <copy file=""cpl-v10.html"" tofile=""${dist}/cpl-v10.html"" />
+    <copy file=""epl-v10.html"" tofile=""${dist}/epl-v10.html"" />
     <copy file=""build.xml"" tofile=""${dist}/build.xml"" />
   </target>
 
@@ -34,8 +34,8 @@
     </mailingLists>
     <licenses>
         <license>
-            <name>Common Public License Version 1.0</name>
-            <url>http://www.opensource.org/licenses/cpl1.0.txt</url>
+            <name>Eclipse Public License Version 1.0</name>
+            <url>http://opensource.org/licenses/eclipse-1.0.txt</url>
         </license>
     </licenses>
     <scm>
@@ -26,8 +26,8 @@
     </mailingLists>
     <licenses>
         <license>
-            <name>Common Public License Version 1.0</name>
-            <url>http://www.opensource.org/licenses/cpl1.0.txt</url>
+            <name>Eclipse Public License Version 1.0</name>
+            <url>http://opensource.org/licenses/eclipse-1.0.txt</url>
         </license>
     </licenses>
     <scm>
@@ -1,125 +0,0 @@
-<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0//EN"">
-<HTML>
-<HEAD>
-<TITLE>Common Public License - v 1.0</TITLE>
-<meta http-equiv=""Content-Type"" content=""text/html; charset=iso-8859-1"">
-</HEAD>
-
-<BODY BGCOLOR=""#FFFFFF"" VLINK=""#800000"">
-
-
-<P ALIGN=""CENTER""><B>Common Public License - v 1.0</B>
-<P><B></B><FONT SIZE=""3""></FONT>
-<P><FONT SIZE=""3""></FONT><FONT SIZE=""2"">THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS COMMON PUBLIC LICENSE (""AGREEMENT"").  ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""><B>1.  DEFINITIONS</B></FONT>
-<P><FONT SIZE=""2"">""Contribution"" means:</FONT>
-
-<UL><FONT SIZE=""2"">a) in the case of the initial Contributor, the initial code and documentation distributed under this Agreement, and<BR CLEAR=""LEFT"">
-b) in the case of each subsequent Contributor:</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">i)	 	changes to the Program, and</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">ii)		additions to the Program;</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">where such changes and/or additions to the Program originate from and are distributed by that particular Contributor.  </FONT><FONT SIZE=""2"">A Contribution 'originates' from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf.  </FONT><FONT SIZE=""2"">Contributions do not include additions to the Program which:  (i) are separate modules of software distributed in conjunction with the Program under their own license agreement, and (ii) are not derivative works of the Program.  </FONT></UL>
-
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">""Contributor"" means any person or entity that distributes the Program.</FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">""Licensed Patents "" mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone or when combined with the Program.  </FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"">""Program"" means the Contributions distributed in accordance with this Agreement.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">""Recipient"" means anyone who receives the Program under this Agreement, including all Contributors.</FONT>
-<P><FONT SIZE=""2""><B></B></FONT>
-<P><FONT SIZE=""2""><B>2.  GRANT OF RIGHTS</B></FONT>
-
-<UL><FONT SIZE=""2""></FONT><FONT SIZE=""2"">a)	</FONT><FONT SIZE=""2"">Subject to the terms of this Agreement, each Contributor hereby grants</FONT><FONT SIZE=""2""> Recipient a non-exclusive, worldwide, royalty-free copyright license to</FONT><FONT SIZE=""2"" COLOR=""#FF0000""> </FONT><FONT SIZE=""2"">reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense the Contribution of such Contributor, if any, and such derivative works, in source code and object code form.</FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT><FONT SIZE=""2"">b) 	Subject to the terms of this Agreement, each Contributor hereby grants </FONT><FONT SIZE=""2"">Recipient a non-exclusive, worldwide,</FONT><FONT SIZE=""2"" COLOR=""#008000""> </FONT><FONT SIZE=""2"">royalty-free patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in source code and object code form.  This patent license shall apply to the combination of the Contribution and the Program if, at the time the Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents.  The patent license shall not apply to any other combinations which include the Contribution.  No hardware per se is licensed hereunder.   </FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT></UL>
-
-
-<UL><FONT SIZE=""2"">c)	Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity.  Each Contributor disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise.  As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other intellectual property rights needed, if any.  For example, if a third party patent license is required to allow Recipient to distribute the Program, it is Recipient's responsibility to acquire that license before distributing the Program.</FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT></UL>
-
-
-<UL><FONT SIZE=""2"">d)	Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright license set forth in this Agreement. </FONT></UL>
-
-
-<UL><FONT SIZE=""2""></FONT></UL>
-
-<P><FONT SIZE=""2""><B>3.  REQUIREMENTS</B></FONT>
-<P><FONT SIZE=""2""><B></B>A Contributor may choose to distribute the Program in object code form under its own license agreement, provided that:</FONT>
-
-<UL><FONT SIZE=""2"">a)	it complies with the terms and conditions of this Agreement; and</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">b)	its license agreement:</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">i)	effectively disclaims</FONT><FONT SIZE=""2""> on behalf of all Contributors all warranties and conditions, express and implied, including warranties or conditions of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose; </FONT></UL>
-
-
-<UL><FONT SIZE=""2"">ii) 	effectively excludes on behalf of all Contributors all liability for damages, including direct, indirect, special, incidental and consequential damages, such as lost profits; </FONT></UL>
-
-
-<UL><FONT SIZE=""2"">iii)</FONT><FONT SIZE=""2"">	states that any provisions which differ from this Agreement are offered by that Contributor alone and not by any other party; and</FONT></UL>
-
-
-<UL><FONT SIZE=""2"">iv)	states that source code for the Program is available from such Contributor, and informs licensees how to obtain it in a reasonable manner on or through a medium customarily used for software exchange.</FONT><FONT SIZE=""2"" COLOR=""#0000FF""> </FONT><FONT SIZE=""2"" COLOR=""#FF0000""></FONT></UL>
-
-
-<UL><FONT SIZE=""2"" COLOR=""#FF0000""></FONT><FONT SIZE=""2""></FONT></UL>
-
-<P><FONT SIZE=""2"">When the Program is made available in source code form:</FONT>
-
-<UL><FONT SIZE=""2"">a)	it must be made available under this Agreement; and </FONT></UL>
-
-
-<UL><FONT SIZE=""2"">b)	a copy of this Agreement must be included with each copy of the Program.  </FONT></UL>
-
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"" COLOR=""#0000FF""><STRIKE></STRIKE></FONT>
-<P><FONT SIZE=""2"" COLOR=""#0000FF""><STRIKE></STRIKE></FONT><FONT SIZE=""2"">Contributors may not remove or alter any copyright notices contained within the Program.  </FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">Each Contributor must identify itself as the originator of its Contribution, if any, in a manner that reasonably allows subsequent Recipients to identify the originator of the Contribution.  </FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""><B>4.  COMMERCIAL DISTRIBUTION</B></FONT>
-<P><FONT SIZE=""2"">Commercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like.  While this license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering should do so in a manner which does not create potential liability for other Contributors.   Therefore, if a Contributor includes the Program in a commercial product offering, such Contributor (""Commercial Contributor"") hereby agrees to defend and indemnify every other Contributor (""Indemnified Contributor"") against any losses, damages and costs (collectively ""Losses"") arising from claims, lawsuits and other legal actions brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in connection with its distribution of the Program in a commercial product offering.  The obligations in this section do not apply to any claims or Losses relating to any actual or alleged intellectual property infringement.  In order to qualify, an Indemnified Contributor must: a) promptly notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the Commercial Contributor in, the defense and any related settlement negotiations.  The Indemnified Contributor may participate in any such claim at its own expense.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">For example, a Contributor might include the Program in a commercial product offering, Product X.  That Contributor is then a Commercial Contributor.  If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims and warranties are such Commercial Contributor's responsibility alone.  Under this section, the Commercial Contributor would have to defend claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay any damages as a result, the Commercial Contributor must pay those damages.</FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"" COLOR=""#0000FF""></FONT>
-<P><FONT SIZE=""2"" COLOR=""#0000FF""></FONT><FONT SIZE=""2""><B>5.  NO WARRANTY</B></FONT>
-<P><FONT SIZE=""2"">EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is</FONT><FONT SIZE=""2""> solely responsible for determining the appropriateness of using and distributing </FONT><FONT SIZE=""2"">the Program</FONT><FONT SIZE=""2""> and assumes all risks associated with its exercise of rights under this Agreement</FONT><FONT SIZE=""2"">, including but not limited to the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, </FONT><FONT SIZE=""2"">programs or equipment, and unavailability or interruption of operations</FONT><FONT SIZE=""2"">.  </FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""><B>6.  DISCLAIMER OF LIABILITY</B></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"">EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES </FONT><FONT SIZE=""2"">(INCLUDING WITHOUT LIMITATION LOST PROFITS),</FONT><FONT SIZE=""2""> HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""><B>7.  GENERAL</B></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"">If any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">If Recipient institutes patent litigation against a Contributor with respect to a patent applicable to software (including a cross-claim or counterclaim in a lawsuit), then any patent licenses granted by that Contributor to such Recipient under this Agreement shall terminate as of the date such litigation is filed.  In addition, if Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's rights granted under Section 2(b) shall terminate as of the date such litigation is filed. </FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">All Recipient's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance.  If all Recipient's rights under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable.  However, Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.  </FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2"">Everyone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted  and may only be modified in the following manner. The Agreement Steward reserves the right to </FONT><FONT SIZE=""2"">publish new versions (including revisions) of this Agreement from time to </FONT><FONT SIZE=""2"">time. No one other than the Agreement Steward has the right to modify this Agreement. IBM is the initial Agreement Steward.   IBM may assign the responsibility to serve as the Agreement Steward to a suitable separate entity.  </FONT><FONT SIZE=""2"">Each new version of the Agreement will be given a distinguishing version number.  The Program (including Contributions) may always be distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is published, Contributor may elect to distribute the Program (including its Contributions) under the new </FONT><FONT SIZE=""2"">version.  </FONT><FONT SIZE=""2"">Except as expressly stated in Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to the intellectual property of any Contributor under this Agreement, whether expressly, </FONT><FONT SIZE=""2"">by implication, estoppel or otherwise</FONT><FONT SIZE=""2"">.</FONT><FONT SIZE=""2"">  All rights in the Program not expressly granted under this Agreement are reserved.</FONT>
-<P><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2"">This Agreement is governed by the laws of the State of New York and the intellectual property laws of the United States of America. No party to this Agreement will bring a legal action under this Agreement more than one year after the cause of action arose.  Each party waives its rights to a jury trial in any resulting litigation.</FONT>
-<P><FONT SIZE=""2""></FONT><FONT SIZE=""2""></FONT>
-<P><FONT SIZE=""2""></FONT>
-
-</BODY>
-
-</HTML>
\ No newline at end of file
@@ -422,9 +422,9 @@ <h1>
     <p>
       JUnit is <a href=""http://www.opensource.org/"">Open Source
       Software</a>, released
-      under <a
-      href=""http://oss.software.ibm.com/developerworks/oss/license-cpl.html"">IBM's
-      Common Public License Version 0.5</a> and hosted
+      under the <a
+      href=""http://opensource.org/licenses/eclipse-1.0.html"">
+      Eclipse Public License Version 1.0</a> and hosted
       on <a
       href=""http://sourceforge.net/projects/junit/"">SourceForge</a>.
     </p>
@@ -56,7 +56,7 @@ <h2>
 
 <br><a href=""README.html"">Release notes</a>
 <br>&nbsp;&nbsp;&nbsp; Latest JUnit release notes
-<br><a href=""cpl-v10.html"">License</a>
+<br><a href=""epl-v10.html"">License</a>
 <br>&nbsp;&nbsp;&nbsp; The terms of the common public license used for JUnit.<br>
 </blockquote>
 The following documents still describe JUnit 3.8.
@@ -0,0 +1,261 @@
+<?xml version=""1.0"" encoding=""ISO-8859-1"" ?>
+<!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">
+<html xmlns=""http://www.w3.org/1999/xhtml"">
+
+<head>
+<meta http-equiv=""Content-Type"" content=""text/html; charset=ISO-8859-1"" />
+<title>Eclipse Public License - Version 1.0</title>
+<style type=""text/css"">
+  body {
+    size: 8.5in 11.0in;
+    margin: 0.25in 0.5in 0.25in 0.5in;
+    tab-interval: 0.5in;
+    }
+  p {  	
+    margin-left: auto;
+    margin-top:  0.5em;
+    margin-bottom: 0.5em;
+    }
+  p.list {
+  	margin-left: 0.5in;
+    margin-top:  0.05em;
+    margin-bottom: 0.05em;
+    }
+  </style>
+
+</head>
+
+<body lang=""EN-US"">
+
+<h2>Eclipse Public License - v 1.0</h2>
+
+<p>THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE
+PUBLIC LICENSE (&quot;AGREEMENT&quot;). ANY USE, REPRODUCTION OR
+DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS
+AGREEMENT.</p>
+
+<p><b>1. DEFINITIONS</b></p>
+
+<p>&quot;Contribution&quot; means:</p>
+
+<p class=""list"">a) in the case of the initial Contributor, the initial
+code and documentation distributed under this Agreement, and</p>
+<p class=""list"">b) in the case of each subsequent Contributor:</p>
+<p class=""list"">i) changes to the Program, and</p>
+<p class=""list"">ii) additions to the Program;</p>
+<p class=""list"">where such changes and/or additions to the Program
+originate from and are distributed by that particular Contributor. A
+Contribution 'originates' from a Contributor if it was added to the
+Program by such Contributor itself or anyone acting on such
+Contributor's behalf. Contributions do not include additions to the
+Program which: (i) are separate modules of software distributed in
+conjunction with the Program under their own license agreement, and (ii)
+are not derivative works of the Program.</p>
+
+<p>&quot;Contributor&quot; means any person or entity that distributes
+the Program.</p>
+
+<p>&quot;Licensed Patents&quot; mean patent claims licensable by a
+Contributor which are necessarily infringed by the use or sale of its
+Contribution alone or when combined with the Program.</p>
+
+<p>&quot;Program&quot; means the Contributions distributed in accordance
+with this Agreement.</p>
+
+<p>&quot;Recipient&quot; means anyone who receives the Program under
+this Agreement, including all Contributors.</p>
+
+<p><b>2. GRANT OF RIGHTS</b></p>
+
+<p class=""list"">a) Subject to the terms of this Agreement, each
+Contributor hereby grants Recipient a non-exclusive, worldwide,
+royalty-free copyright license to reproduce, prepare derivative works
+of, publicly display, publicly perform, distribute and sublicense the
+Contribution of such Contributor, if any, and such derivative works, in
+source code and object code form.</p>
+
+<p class=""list"">b) Subject to the terms of this Agreement, each
+Contributor hereby grants Recipient a non-exclusive, worldwide,
+royalty-free patent license under Licensed Patents to make, use, sell,
+offer to sell, import and otherwise transfer the Contribution of such
+Contributor, if any, in source code and object code form. This patent
+license shall apply to the combination of the Contribution and the
+Program if, at the time the Contribution is added by the Contributor,
+such addition of the Contribution causes such combination to be covered
+by the Licensed Patents. The patent license shall not apply to any other
+combinations which include the Contribution. No hardware per se is
+licensed hereunder.</p>
+
+<p class=""list"">c) Recipient understands that although each Contributor
+grants the licenses to its Contributions set forth herein, no assurances
+are provided by any Contributor that the Program does not infringe the
+patent or other intellectual property rights of any other entity. Each
+Contributor disclaims any liability to Recipient for claims brought by
+any other entity based on infringement of intellectual property rights
+or otherwise. As a condition to exercising the rights and licenses
+granted hereunder, each Recipient hereby assumes sole responsibility to
+secure any other intellectual property rights needed, if any. For
+example, if a third party patent license is required to allow Recipient
+to distribute the Program, it is Recipient's responsibility to acquire
+that license before distributing the Program.</p>
+
+<p class=""list"">d) Each Contributor represents that to its knowledge it
+has sufficient copyright rights in its Contribution, if any, to grant
+the copyright license set forth in this Agreement.</p>
+
+<p><b>3. REQUIREMENTS</b></p>
+
+<p>A Contributor may choose to distribute the Program in object code
+form under its own license agreement, provided that:</p>
+
+<p class=""list"">a) it complies with the terms and conditions of this
+Agreement; and</p>
+
+<p class=""list"">b) its license agreement:</p>
+
+<p class=""list"">i) effectively disclaims on behalf of all Contributors
+all warranties and conditions, express and implied, including warranties
+or conditions of title and non-infringement, and implied warranties or
+conditions of merchantability and fitness for a particular purpose;</p>
+
+<p class=""list"">ii) effectively excludes on behalf of all Contributors
+all liability for damages, including direct, indirect, special,
+incidental and consequential damages, such as lost profits;</p>
+
+<p class=""list"">iii) states that any provisions which differ from this
+Agreement are offered by that Contributor alone and not by any other
+party; and</p>
+
+<p class=""list"">iv) states that source code for the Program is available
+from such Contributor, and informs licensees how to obtain it in a
+reasonable manner on or through a medium customarily used for software
+exchange.</p>
+
+<p>When the Program is made available in source code form:</p>
+
+<p class=""list"">a) it must be made available under this Agreement; and</p>
+
+<p class=""list"">b) a copy of this Agreement must be included with each
+copy of the Program.</p>
+
+<p>Contributors may not remove or alter any copyright notices contained
+within the Program.</p>
+
+<p>Each Contributor must identify itself as the originator of its
+Contribution, if any, in a manner that reasonably allows subsequent
+Recipients to identify the originator of the Contribution.</p>
+
+<p><b>4. COMMERCIAL DISTRIBUTION</b></p>
+
+<p>Commercial distributors of software may accept certain
+responsibilities with respect to end users, business partners and the
+like. While this license is intended to facilitate the commercial use of
+the Program, the Contributor who includes the Program in a commercial
+product offering should do so in a manner which does not create
+potential liability for other Contributors. Therefore, if a Contributor
+includes the Program in a commercial product offering, such Contributor
+(&quot;Commercial Contributor&quot;) hereby agrees to defend and
+indemnify every other Contributor (&quot;Indemnified Contributor&quot;)
+against any losses, damages and costs (collectively &quot;Losses&quot;)
+arising from claims, lawsuits and other legal actions brought by a third
+party against the Indemnified Contributor to the extent caused by the
+acts or omissions of such Commercial Contributor in connection with its
+distribution of the Program in a commercial product offering. The
+obligations in this section do not apply to any claims or Losses
+relating to any actual or alleged intellectual property infringement. In
+order to qualify, an Indemnified Contributor must: a) promptly notify
+the Commercial Contributor in writing of such claim, and b) allow the
+Commercial Contributor to control, and cooperate with the Commercial
+Contributor in, the defense and any related settlement negotiations. The
+Indemnified Contributor may participate in any such claim at its own
+expense.</p>
+
+<p>For example, a Contributor might include the Program in a commercial
+product offering, Product X. That Contributor is then a Commercial
+Contributor. If that Commercial Contributor then makes performance
+claims, or offers warranties related to Product X, those performance
+claims and warranties are such Commercial Contributor's responsibility
+alone. Under this section, the Commercial Contributor would have to
+defend claims against the other Contributors related to those
+performance claims and warranties, and if a court requires any other
+Contributor to pay any damages as a result, the Commercial Contributor
+must pay those damages.</p>
+
+<p><b>5. NO WARRANTY</b></p>
+
+<p>EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS
+PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS
+OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION,
+ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY
+OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely
+responsible for determining the appropriateness of using and
+distributing the Program and assumes all risks associated with its
+exercise of rights under this Agreement , including but not limited to
+the risks and costs of program errors, compliance with applicable laws,
+damage to or loss of data, programs or equipment, and unavailability or
+interruption of operations.</p>
+
+<p><b>6. DISCLAIMER OF LIABILITY</b></p>
+
+<p>EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT
+NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING
+WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR
+DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>
+
+<p><b>7. GENERAL</b></p>
+
+<p>If any provision of this Agreement is invalid or unenforceable under
+applicable law, it shall not affect the validity or enforceability of
+the remainder of the terms of this Agreement, and without further action
+by the parties hereto, such provision shall be reformed to the minimum
+extent necessary to make such provision valid and enforceable.</p>
+
+<p>If Recipient institutes patent litigation against any entity
+(including a cross-claim or counterclaim in a lawsuit) alleging that the
+Program itself (excluding combinations of the Program with other
+software or hardware) infringes such Recipient's patent(s), then such
+Recipient's rights granted under Section 2(b) shall terminate as of the
+date such litigation is filed.</p>
+
+<p>All Recipient's rights under this Agreement shall terminate if it
+fails to comply with any of the material terms or conditions of this
+Agreement and does not cure such failure in a reasonable period of time
+after becoming aware of such noncompliance. If all Recipient's rights
+under this Agreement terminate, Recipient agrees to cease use and
+distribution of the Program as soon as reasonably practicable. However,
+Recipient's obligations under this Agreement and any licenses granted by
+Recipient relating to the Program shall continue and survive.</p>
+
+<p>Everyone is permitted to copy and distribute copies of this
+Agreement, but in order to avoid inconsistency the Agreement is
+copyrighted and may only be modified in the following manner. The
+Agreement Steward reserves the right to publish new versions (including
+revisions) of this Agreement from time to time. No one other than the
+Agreement Steward has the right to modify this Agreement. The Eclipse
+Foundation is the initial Agreement Steward. The Eclipse Foundation may
+assign the responsibility to serve as the Agreement Steward to a
+suitable separate entity. Each new version of the Agreement will be
+given a distinguishing version number. The Program (including
+Contributions) may always be distributed subject to the version of the
+Agreement under which it was received. In addition, after a new version
+of the Agreement is published, Contributor may elect to distribute the
+Program (including its Contributions) under the new version. Except as
+expressly stated in Sections 2(a) and 2(b) above, Recipient receives no
+rights or licenses to the intellectual property of any Contributor under
+this Agreement, whether expressly, by implication, estoppel or
+otherwise. All rights in the Program not expressly granted under this
+Agreement are reserved.</p>
+
+<p>This Agreement is governed by the laws of the State of New York and
+the intellectual property laws of the United States of America. No party
+to this Agreement will bring a legal action under this Agreement more
+than one year after the cause of action arose. Each party waives its
+rights to a jury trial in any resulting litigation.</p>
+
+</body>
+
+</html>
\ No newline at end of file
@@ -16,8 +16,8 @@
     </organization>
     <licenses>
         <license>
-            <name>Common Public License Version 1.0</name>
-            <url>http://www.opensource.org/licenses/cpl1.0.txt</url>
+            <name>Eclipse Public License 1.0</name>
+            <url>http://opensource.org/licenses/eclipse-1.0.txt</url>
             <distribution>repo</distribution>
         </license>
     </licenses>
",True,"The commit message explains the necessity of the changes by referencing the difference between the Common Public License (CPL) and the Eclipse Public License (EPL). The message states that the CPL is actively hurting JUnit adaptation, and that the EPL would have been fine in cases where the CPL was problematic. Additionally, the message mentions that the EPL is the successor version of the CPL, which means that re-licensing is possible without seeking the approval of all contributors.",True,"The commit message clearly explains the reason for the change from CPL to EPL. It mentions that the CPL is actively hurting JUnit adaptation in certain cases, and EPL would have been fine. The message also provides references to external sources that explain the differences between the two licenses and why the change is necessary.",True,"The commit message explains the motivation for the code change by mentioning that the CPL is actively hurting JUnit adaptation in certain cases, and the EPL is a suitable alternative. It also provides links to articles and resources that support this explanation.",True,"The commit message describes the necessity of changes by explaining that the license of JUnit is being changed from CPL to EPL. This is done because the CPL is actively hurting JUnit adaptation in certain cases, such as when Netbeans can't ship JUnit or when OpenJDK uses TestNG instead of JUnit. The EPL is the successor version of the CPL, which makes re-licensing possible without seeking the approval of all contributors.",True,The commit message directly mentions the change from the Common Public License (CPL) to the Eclipse Public License (EPL) as a result of the CPL being actively hurting JUnit adaptation. This clearly describes the objective of the change by directly mentioning the defects it fixes (CPL being a hurdle for JUnit adaptation) and the improvements it makes (switching to EPL).,True,"The commit message clearly describes the change from CPL to EPL, which is a significant change in the licensing of the JUnit project. The message explains why the change is being made, citing the advantages of EPL over CPL and providing examples of projects that have been hindered by CPL. The message also provides references to further information about the EPL and the relationship between CPL and EPL. Additionally, the code diff shows the changes made to the LICENSE.txt file, which is a key component of the change.",True,"The commit message explains that the license of the JUnit project is being changed from the Common Public License (CPL) to the Eclipse Public License (EPL). This change is justified by the fact that the EPL is the successor version of the CPL, which means that using the CPL is the licensing equivalent of using deprecated code. The message also mentions that the EPL and CPL differ by about one sentence, which relates to the scope of patent licenses terminated in the event of a patent law suit. This explains the technical principle underpinning the changes, which is the need to update the project's license to a more modern and widely-used one.",True,"The commit message clearly states that the license of JUnit is being changed from CPL to EPL. This change is also reflected in the code diff, where the license text in various files and documents is being updated to reflect the new EPL license. The commit message also provides a brief explanation of why the license change is being made, citing reasons such as the EPL being the successor version of the CPL and the CPL being actively hurting JUnit adaptation in certain cases. Therefore, the commit message effectively describes the changes made to the code and the new behavior introduced by the license change.",False,"The commit message provides a clear explanation of the reason for the change, which is to relicense JUnit from CPL to EPL. The explanation includes the reasons why this change is beneficial, such as the EPL being the successor version of the CPL and not having the same patent license termination issues as the CPL. The explanation also mentions specific cases where the CPL was a hindrance to JUnit adaptation, such as Netbeans not being able to ship JUnit and OpenJDK using TestNG instead of JUnit. The commit message also provides references to support its claims."
https://github.com/spring-projects/spring-boot/commit/6c8f8c9d827a5340f9e6493c14d8c252d1f0d52a,"Better diagnotics when ESCF subclass breaks with custom management port  <enter> When a custom management.port is used, the child context is configured with an EmbeddedServletContainerFactory bean that has the same class as the parent context’s EmbeddedServletContainerFactory bean. This ensures that the child context uses the same type of embedded container as its parent when there are multiple embedded containers on the classpath. It also causes a failure when the custom EmbeddedServletContainerFactory subclass cannot be instantiated, for example because it’s an anonymous inner-class. <enter> This commit improves the diagnostics so that we fail fast with an information exception message when we detect that the embedded servlet container factory bean’s class cannot be instantiated. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/6c8f8c9d827a5340f9e6493c14d8c252d1f0d52a,"@@ -17,6 +17,7 @@
 package org.springframework.boot.actuate.autoconfigure;
 
 import java.io.IOException;
+import java.lang.reflect.Modifier;
 
 import javax.servlet.FilterChain;
 import javax.servlet.Servlet;
@@ -28,6 +29,7 @@
 import org.apache.commons.logging.LogFactory;
 
 import org.springframework.beans.BeansException;
+import org.springframework.beans.FatalBeanException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
@@ -188,20 +190,38 @@ private void createChildManagementContext() {
 	private void registerEmbeddedServletContainerFactory(
 			AnnotationConfigEmbeddedWebApplicationContext childContext) {
 		try {
-			EmbeddedServletContainerFactory servletContainerFactory = this.applicationContext
-					.getBean(EmbeddedServletContainerFactory.class);
 			ConfigurableListableBeanFactory beanFactory = childContext.getBeanFactory();
 			if (beanFactory instanceof BeanDefinitionRegistry) {
 				BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
 				registry.registerBeanDefinition(""embeddedServletContainerFactory"",
-						new RootBeanDefinition(servletContainerFactory.getClass()));
+						new RootBeanDefinition(
+								determineEmbeddedServletContainerFactoryClass()));
 			}
 		}
 		catch (NoSuchBeanDefinitionException ex) {
 			// Ignore and assume auto-configuration
 		}
 	}
 
+	private Class<?> determineEmbeddedServletContainerFactoryClass()
+			throws NoSuchBeanDefinitionException {
+		Class<?> servletContainerFactoryClass = this.applicationContext
+				.getBean(EmbeddedServletContainerFactory.class).getClass();
+		if (cannotBeInstantiated(servletContainerFactoryClass)) {
+			throw new FatalBeanException(""EmbeddedServletContainerFactory implementation ""
+					+ servletContainerFactoryClass.getName() + "" cannot be instantiated. ""
+					+ ""To allow a separate management port to be used, a top-level class ""
+					+ ""or static inner class should be used instead"");
+		}
+		return servletContainerFactoryClass;
+	}
+
+	private boolean cannotBeInstantiated(Class<?> clazz) {
+		return clazz.isLocalClass()
+				|| (clazz.isMemberClass() && !Modifier.isStatic(clazz.getModifiers()))
+				|| clazz.isAnonymousClass();
+	}
+
 	/**
 	 * Add an alias for 'local.management.port' that actually resolves using
 	 * 'local.server.port'.
",True,"The commit message explains the necessity of changes by referencing a convention. It mentions that when a custom management.port is used, the child context is configured with an EmbeddedServletContainerFactory bean that has the same class as the parent context’s EmbeddedServletContainerFactory bean. This is done to ensure that the child context uses the same type of embedded container as its parent when there are multiple embedded containers on the classpath. The commit also improves the diagnostics so that we fail fast with an information exception message when we detect that the embedded servlet container factory bean’s class cannot be instantiated. This is done to address the issue where the custom EmbeddedServletContainerFactory subclass cannot be instantiated, for example because it’s an anonymous inner-class. This is a clear reference to a convention or standard (using top-level or static inner classes instead of anonymous inner classes) that the commit is addressing to improve the functionality.",True,"The commit message explains the necessity of changes by stating that it improves diagnostics when a custom EmbeddedServletContainerFactory subclass cannot be instantiated. This is not a common sense or easy to infer change, but rather a specific improvement to handle a specific edge case. The code diff supports this explanation by adding new methods to determine the EmbeddedServletContainerFactory class and check if it can be instantiated, and throwing a FatalBeanException with an informative message if it cannot.",True,"The commit message explains the motivation for the code change by describing the error scenario when a custom management.port is used and the child context is configured with an EmbeddedServletContainerFactory bean that has the same class as the parent context’s EmbeddedServletContainerFactory bean. This can cause a failure when the custom EmbeddedServletContainerFactory subclass cannot be instantiated, for example because it’s an anonymous inner-class. The commit message then explains that the changes improve the diagnostics so that we fail fast with an information exception message when we detect that the embedded servlet container factory bean’s class cannot be instantiated. This directly elaborates the motivation of the code change and describes the shortcoming of the previous implementation.",True,"The commit message describes the necessity of changes by mentioning the problem that occurs when a custom EmbeddedServletContainerFactory subclass cannot be instantiated, especially when it's an anonymous inner-class. This issue is caused by the requirement of using a separate management port, which leads to the need for the child context to use the same type of embedded container as its parent. The changes made in the code diff are to improve the diagnostics so that the application fails fast with an informative exception message when this issue is detected.",True,"The commit message directly mentions the improvement it makes to the code by stating that it 'improves the diagnostics so that we fail fast with an information exception message when we detect that the embedded servlet container factory bean’s class cannot be instantiated.' This change is made to address the issue where a custom EmbeddedServletContainerFactory subclass cannot be instantiated, which is explicitly mentioned in the commit message.",True,"The commit message describes the changes made to the code by summarizing the key components of the change. It mentions the addition of a new method 'determineEmbeddedServletContainerFactoryClass()' which checks if the EmbeddedServletContainerFactory class can be instantiated. If not, it throws a FatalBeanException with an informative error message. This is a clear summary of the changes made in the code diff.",True,"The commit message explains that the changes are made to improve diagnostics when a custom EmbeddedServletContainerFactory subclass cannot be instantiated. This is due to the limitations of anonymous inner-classes, local classes, and non-static inner classes. The code diff supports this explanation by adding a new method 'determineEmbeddedServletContainerFactoryClass()' that checks if the class is a local class, non-static inner class, or anonymous inner class and throws a FatalBeanException if it is. This is a clear expression of the technical principle that non-top-level or non-static inner classes cannot be instantiated in certain scenarios.",True,"The commit message describes the changes made to the code in a functional perspective. It explains that the commit improves diagnostics when a custom management port is used and the child context's EmbeddedServletContainerFactory bean cannot be instantiated. This is due to the addition of a new method, determineEmbeddedServletContainerFactoryClass(), which checks if the class can be instantiated and throws a FatalBeanException with an informative message if it cannot. This new behavior is described in the commit message, making it a summary of the changes.",False,"The commit message does not lack an explanation. It clearly explains the reason for the commit, which is to improve diagnostics when the embedded servlet container factory bean's class cannot be instantiated. This is not a trivial change, as it involves adding new methods and classes, and modifying existing ones. The change is not simply a cosmetic one, but rather a functional improvement to the codebase."
https://github.com/spring-projects/spring-boot/commit/6dc14af92dbfa7b5281072d9fdde241ce0da3679,"Update view of bean types when an override is detected  <enter> Previously, when a bean was overridden and its type changes, BeanTypeRegistry could be left with a stale view of the bean's type. This would lead to incorrect bean condition evaluation as conditions would match or not match based on the bean's old type. <enter> This commit updates the type registry to refresh its view of a bean's type when its definition changes. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/6dc14af92dbfa7b5281072d9fdde241ce0da3679,"@@ -76,7 +76,7 @@ final class BeanTypeRegistry implements SmartInitializingSingleton {
 
 	private final Map<String, Class<?>> beanTypes = new HashMap<String, Class<?>>();
 
-	private int lastBeanDefinitionCount = 0;
+	private final Map<String, RootBeanDefinition> beanDefinitions = new HashMap<String, RootBeanDefinition>();
 
 	private BeanTypeRegistry(DefaultListableBeanFactory beanFactory) {
 		this.beanFactory = beanFactory;
@@ -146,7 +146,7 @@ Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {
 	public void afterSingletonsInstantiated() {
 		// We're done at this point, free up some memory
 		this.beanTypes.clear();
-		this.lastBeanDefinitionCount = 0;
+		this.beanDefinitions.clear();
 	}
 
 	private void addBeanType(String name) {
@@ -159,10 +159,23 @@ else if (!this.beanFactory.isAlias(name)) {
 	}
 
 	private void addBeanTypeForNonAliasDefinition(String name) {
+		addBeanTypeForNonAliasDefinition(name, getBeanDefinition(name));
+	}
+
+	private RootBeanDefinition getBeanDefinition(String name) {
+		try {
+			return (RootBeanDefinition) this.beanFactory.getMergedBeanDefinition(name);
+		}
+		catch (BeanDefinitionStoreException ex) {
+			logIgnoredError(""unresolvable metadata in bean definition"", name, ex);
+			return null;
+		}
+	}
+
+	private void addBeanTypeForNonAliasDefinition(String name,
+			RootBeanDefinition beanDefinition) {
 		try {
 			String factoryName = BeanFactory.FACTORY_BEAN_PREFIX + name;
-			RootBeanDefinition beanDefinition = (RootBeanDefinition) this.beanFactory
-					.getMergedBeanDefinition(name);
 			if (!beanDefinition.isAbstract()
 					&& !requiresEagerInit(beanDefinition.getFactoryBeanName())) {
 				if (this.beanFactory.isFactoryBean(factoryName)) {
@@ -176,15 +189,12 @@ private void addBeanTypeForNonAliasDefinition(String name) {
 					this.beanTypes.put(name, this.beanFactory.getType(name));
 				}
 			}
+			this.beanDefinitions.put(name, beanDefinition);
 		}
 		catch (CannotLoadBeanClassException ex) {
 			// Probably contains a placeholder
 			logIgnoredError(""bean class loading failure for bean"", name, ex);
 		}
-		catch (BeanDefinitionStoreException ex) {
-			// Probably contains a placeholder
-			logIgnoredError(""unresolvable metadata in bean definition"", name, ex);
-		}
 	}
 
 	private void logIgnoredError(String message, String name, Exception ex) {
@@ -199,15 +209,24 @@ private boolean requiresEagerInit(String factoryBeanName) {
 	}
 
 	private void updateTypesIfNecessary() {
-		if (this.lastBeanDefinitionCount != this.beanFactory.getBeanDefinitionCount()) {
-			Iterator<String> names = this.beanFactory.getBeanNamesIterator();
-			while (names.hasNext()) {
-				String name = names.next();
-				if (!this.beanTypes.containsKey(name)) {
-					addBeanType(name);
+		Iterator<String> names = this.beanFactory.getBeanNamesIterator();
+		while (names.hasNext()) {
+			String name = names.next();
+			if (!this.beanTypes.containsKey(name)) {
+				addBeanType(name);
+			}
+			else {
+				if (!this.beanFactory.isAlias(name)
+						&& !this.beanFactory.containsSingleton(name)) {
+					RootBeanDefinition beanDefinition = getBeanDefinition(name);
+					RootBeanDefinition existingDefinition = this.beanDefinitions.put(name,
+							beanDefinition);
+					if (existingDefinition != null
+							&& !beanDefinition.equals(existingDefinition)) {
+						addBeanTypeForNonAliasDefinition(name, beanDefinition);
+					}
 				}
 			}
-			this.lastBeanDefinitionCount = this.beanFactory.getBeanDefinitionCount();
 		}
 	}
 
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -139,6 +139,16 @@ public void beanProducedByFactoryBeanIsConsideredWhenMatchingOnAnnotation() {
 		assertThat(this.context.getBeansOfType(ExampleBean.class)).hasSize(1);
 	}
 
+	@Test
+	public void conditionEvaluationConsidersChangeInTypeWhenBeanIsOverridden() {
+		this.context.register(OriginalDefinition.class, OverridingDefinition.class,
+				ConsumingConfiguration.class);
+		this.context.refresh();
+		assertThat(this.context.containsBean(""testBean"")).isTrue();
+		assertThat(this.context.getBean(Integer.class)).isEqualTo(1);
+		assertThat(this.context.getBeansOfType(ConsumingConfiguration.class)).isEmpty();
+	}
+
 	@Configuration
 	@ConditionalOnBean(name = ""foo"")
 	protected static class OnBeanNameConfiguration {
@@ -311,4 +321,35 @@ public String toString() {
 
 	}
 
+	@Configuration
+	public static class OriginalDefinition {
+
+		@Bean
+		public String testBean() {
+			return ""test"";
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnBean(String.class)
+	public static class OverridingDefinition {
+
+		@Bean
+		public Integer testBean() {
+			return 1;
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnBean(String.class)
+	public static class ConsumingConfiguration {
+
+		ConsumingConfiguration(String testBean) {
+
+		}
+
+	}
+
 }
",True,"The commit message refers to the necessity of changes by referencing a problem in prior commits. It mentions that 'when a bean was overridden and its type changes, BeanTypeRegistry could be left with a stale view of the bean's type. This would lead to incorrect bean condition evaluation.' The commit then goes on to explain that it updates the type registry to refresh its view of a bean's type when its definition changes. This directly addresses the issue mentioned in the message.",True,"The commit message explains the necessity of changes by stating that 'when a bean was overridden and its type changes, BeanTypeRegistry could be left with a stale view of the bean's type. This would lead to incorrect bean condition evaluation.' This is a clear explanation of why the changes were made, and it is not common sense or easy to infer from the code diff.",True,"The commit message clearly explains the problem that was occurring when a bean was overridden and its type changed. It mentions that the BeanTypeRegistry could be left with a stale view of the bean's type, which would lead to incorrect bean condition evaluation. The commit message also explains how the issue is resolved by updating the type registry to refresh its view of a bean's type when its definition changes.",True,The commit message 'Update view of bean types when an override is detected' indicates that the developer made changes to handle a situation where a bean was overridden and its type changed. This could lead to incorrect bean condition evaluation as conditions would match or not match based on the bean's old type. The code diff supports this by showing changes to the BeanTypeRegistry to refresh its view of a bean's type when its definition changes.,True,"The commit message directly mentions the issue it fixes: 'Previously, when a bean was overridden and its type changes, BeanTypeRegistry could be left with a stale view of the bean's type. This would lead to incorrect bean condition evaluation.' The message also describes the improvement made: 'This commit updates the type registry to refresh its view of a bean's type when its definition changes.'",True,"The commit message 'Update view of bean types when an override is detected' accurately summarizes the changes made in the code diff. It highlights the issue of stale views in the bean type registry when a bean is overridden and its type changes. The message also explains that the commit updates the type registry to refresh its view of a bean's type when its definition changes, which is reflected in the code diff where the `lastBeanDefinitionCount` variable is replaced with a `beanDefinitions` map, and the `updateTypesIfNecessary` method is updated to compare the existing bean definition with the new one and update the bean type if they differ.",True,"The commit message explains that the changes are made to update the type registry's view of a bean's type when its definition changes. This is a technical principle that ensures the system's correctness and reliability, especially when dealing with bean overrides and type changes.",True,"The commit message accurately describes the changes made to the code. It explains that the commit updates the type registry to refresh its view of a bean's type when its definition changes. This is particularly relevant when a bean is overridden and its type changes, as the previous implementation could lead to incorrect bean condition evaluation. The code diff supports this explanation by showing the addition of a new map to store bean definitions and the modification of the updateTypesIfNecessary method to compare the existing bean definition with the new one and update the bean type if they differ.",False,"The commit message explains the reason for the change clearly. It mentions that previously, when a bean was overridden and its type changed, the BeanTypeRegistry could be left with a stale view of the bean's type. This would lead to incorrect bean condition evaluation. The commit updates the type registry to refresh its view of a bean's type when its definition changes. This is a significant change that requires an explanation in the commit message."
https://github.com/square/okhttp/commit/868ee844458eda9ee7b1b6f9a5238b7c3f84c0e4,"Drop our one remaining DSS cipher suite.  <enter> Tracking Chrome and Firefox, which have also dropped this cipher suite. <enter> This is the only cipher suite change since the last update. See our cipher suites spreadsheet for a comparison:  https://goo.gl/dWXbi0  <enter>  Closes   <issue_link> ",https://api.github.com/repos/square/okhttp/commits/868ee844458eda9ee7b1b6f9a5238b7c3f84c0e4,"@@ -37,7 +37,7 @@
  */
 public final class ConnectionSpec {
 
-  // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+  // This is a subset of the cipher suites supported in Chrome 46, current as of 2015-11-05.
   // All of these suites are available on Android 5.0; earlier releases support a subset of
   // these suites. https://github.com/square/okhttp/issues/330
   private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
@@ -53,7 +53,6 @@ public final class ConnectionSpec {
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
",True,"The commit message refers to the necessity of changes by mentioning that the cipher suite is being dropped because Chrome and Firefox have also dropped this cipher suite. This is a reference to a convention or standard (the cipher suites supported by Chrome and Firefox) that the commit is following. Additionally, the commit message mentions that this is the only cipher suite change since the last update, which could be seen as an improvement or modification based on prior commits.",True,"The commit message 'Drop our one remaining DSS cipher suite' clearly describes the necessity of the change without providing a detailed rationale. The change is made to align with Chrome and Firefox, which have also dropped this cipher suite. The code diff shows that the only change made is the removal of 'TLS_DHE_DSS_WITH_AES_128_CBC_SHA' from the list of approved cipher suites. This is a common practice to improve security and align with industry standards, and the reason for the change is easily inferred from the commit message and the code diff.",True,"The commit message explains the motivation for the code change by mentioning that the DSS cipher suite is being dropped because Chrome and Firefox have also dropped this cipher suite. This implies that the previous implementation may have been insecure or outdated, and the change is being made to align with modern security standards and practices.",True,"The commit message indicates that the change is made to drop a cipher suite due to the change in Chrome and Firefox, which suggests that the change is a response to a requirement or problem. Specifically, it mentions that the change is made to track Chrome and Firefox, which have also dropped this cipher suite. This implies that the change is made to ensure the software is up-to-date and secure, addressing a problem in the maintenance process of the software.",True,"The commit message directly mentions the change by stating 'Drop our one remaining DSS cipher suite' and 'This is the only cipher suite change since the last update'. This clearly indicates that the change is being made to address a security vulnerability or deprecation, as the cipher suite is being dropped due to its presence in Chrome and Firefox as well. The code diff also supports this by removing a specific cipher suite from the approved list.",True,"The commit message 'Drop our one remaining DSS cipher suite' directly references the change made in the diff, which is the removal of the 'TLS_DHE_DSS_WITH_AES_128_CBC_SHA' cipher suite. This clearly summarizes the key component of the change, which is the modification of the approved cipher suites.",True,"The commit message explains that the change is being made to drop a specific cipher suite (TLS_DHE_DSS_WITH_AES_128_CBC_SHA) from the approved list. This is done to align with the practices of Chrome and Firefox, which have also dropped this cipher suite. The decision is based on the technical principle of security, specifically, the removal of weak or outdated cipher suites to enhance the security of the system.",True,"The commit message expresses a change in the cipher suites used in the code. It mentions that the code is dropping one remaining DSS cipher suite, which is specifically mentioned in the code diff as 'TLS_DHE_DSS_WITH_AES_128_CBC_SHA'. This change is described as an update to the approved cipher suites, which is a functional change that affects the security and compatibility of the code. The message also introduces new behavior by specifying that the updated cipher suites are aligned with Chrome and Firefox, which implies that the code is now more compatible with these browsers.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Drop our one remaining DSS cipher suite. Tracking Chrome and Firefox, which have also dropped this cipher suite.' This is a significant change, not just a minor one like removing a space, and it requires an explanation. The code diff also supports this explanation, as it shows the removal of a specific cipher suite."
https://github.com/spring-projects/spring-boot/commit/e233ea7f546fcbc5fccf972bc70c26373103444c,Fix undertow access_log file name  <enter> Undertow 1.3.2 changed the default access log file suffix from '.log' to just 'log'. Thus we need to adapt the file name pattern to include the missing dot. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/e233ea7f546fcbc5fccf972bc70c26373103444c,"@@ -384,7 +384,7 @@ private AccessLogHandler createAccessLogHandler(HttpHandler handler) {
 		try {
 			createAccessLogDirectoryIfNecessary();
 			AccessLogReceiver accessLogReceiver = new DefaultAccessLogReceiver(
-					createWorker(), this.accessLogDirectory, ""access_log"");
+					createWorker(), this.accessLogDirectory, ""access_log."");
 			String formatString = (this.accessLogPattern != null) ? this.accessLogPattern
 					: ""common"";
 			return new AccessLogHandler(handler, accessLogReceiver, formatString,
",True,The commit message refers to a change in Undertow 1.3.2 that changed the default access log file suffix from '.log' to just 'log'. This change necessitates an adaptation in the code to include the missing dot in the file name pattern. This is a clear reference to a convention or standard (the default file naming convention in Undertow 1.3.2) that the commit is addressing.,True,"The commit message 'Fix undertow access_log file name' clearly explains the necessity of the changes. The change is made to adapt the file name pattern to include the missing dot in the default access log file suffix, which was changed from '.log' to just 'log' in Undertow 1.3.2. This is a necessary change to ensure the application continues to function correctly with the updated version of Undertow.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that Undertow 1.3.2 changed the default access log file suffix from '.log' to just 'log', which caused a problem with the existing file name pattern. The message also references the pull request that addresses this issue, further clarifying the context of the change.",True,"The commit message 'Fix undertow access_log file name' indicates that the changes were made due to a problem in the software maintenance process. The problem is that Undertow 1.3.2 changed the default access log file suffix from '.log' to just 'log', which caused the existing file name pattern to be incorrect. This shows that the changes were made to adapt to an external change (the API change of Undertow) and not due to user requirements.",True,"The commit message directly mentions the defect it fixes, which is the change in Undertow 1.3.2 that altered the default access log file suffix. The message states that the change is needed to adapt the file name pattern to include the missing dot. This clearly describes the objective of the change and the improvement it makes to the code.",True,"The commit message 'Fix undertow access_log file name' accurately summarizes the change made in the code diff. Specifically, it points out the issue with the default access log file suffix in Undertow 1.3.2 and the need to adapt the file name pattern to include the missing dot. The diff also supports this explanation by showing the exact line of code that was changed.",False,The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on the issue with the log file name and the need to adapt the file name pattern to include the missing dot. It does not explain why this change is necessary or what principle it is based on.,True,"The commit message 'Fix undertow access_log file name' clearly describes the change in the code. It explains that the default access log file suffix in Undertow 1.3.2 was changed from '.log' to just 'log'. This change is reflected in the code diff where the 'access_log' string is changed to 'access_log.'. This change ensures that the file name pattern includes the missing dot, which is a functional change that fixes the issue.",False,"The commit message does provide an explanation for the change. It mentions that Undertow 1.3.2 changed the default access log file suffix from '.log' to just 'log'. This change requires adapting the file name pattern to include the missing dot. The explanation is clear and specific, so there is no need to infer the reason from the code diff."
https://github.com/spring-projects/spring-boot/commit/247c596f8ceb657800e86d0ca59d4816aa67026b,Remove duplicate console appender from Actuator sample's logback config  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/247c596f8ceb657800e86d0ca59d4816aa67026b,"@@ -1,7 +1,6 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 <configuration>
 	<include resource=""org/springframework/boot/logging/logback/base.xml"" />
-	<include resource=""org/springframework/boot/logging/logback/console-appender.xml"" />
 	<root level=""INFO"">
 		<appender-ref ref=""CONSOLE"" />
 	</root>
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that a duplicate console appender is being removed from the Actuator sample's logback config, but it does not explain why this is necessary or beneficial.",True,"The commit message 'Remove duplicate console appender from Actuator sample's logback config' clearly explains the reason for the change. The duplicate console appender was causing unnecessary logging, which is a common issue that can be inferred from the change in the code diff.",True,"The commit message 'Remove duplicate console appender from Actuator sample's logback config' does describe the necessity of changes. It mentions that there is a 'duplicate console appender' in the 'logback config' of the 'Actuator sample' which is causing the issue. The message also refers to the issue it closes, which further elaborates the motivation of the code change.",True,"The commit message 'Remove duplicate console appender from Actuator sample's logback config' indicates that the developer is addressing a problem in the software maintenance process. The problem is the presence of a duplicate console appender in the logback configuration, which is causing unnecessary output. This is a common issue that can lead to performance degradation and confusion in the logs. By removing the duplicate appender, the developer is improving the efficiency and clarity of the logging process.",True,"The commit message 'Remove duplicate console appender from Actuator sample's logback config' directly mentions the change that is being made to the code, which is removing a duplicate console appender. This change will improve the efficiency of the code by reducing redundancy and potentially improving performance.",True,"The commit message 'Remove duplicate console appender from Actuator sample's logback config' accurately summarizes the change made in the diff. It clearly states that a console appender was removed from the logback configuration, which is the key component of the change.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that a duplicate console appender is being removed from the logback configuration. While this is a logical change, it does not necessarily involve a deeper technical principle such as optimization, security, or performance enhancement.",True,"The commit message 'Remove duplicate console appender from Actuator sample's logback config' accurately summarizes the code changes. It explains that a console appender, which is used for logging, was removed from the logback configuration file. This change does not introduce new behaviors, but rather optimizes the existing configuration by eliminating redundancy. Therefore, it does not introduce new functionalities.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Remove duplicate console appender from Actuator sample's logback config'. Even though the change is small and simple, the message provides a clear explanation of what was done and why."
https://github.com/junit-team/junit4/commit/591fcae09c6470a03ade7d608773f8f633409bc2,Added more Javadoc to Assert for messages and when they are displayed.  <enter> Put versiontag back into Version. ,https://api.github.com/repos/junit-team/junit4/commits/591fcae09c6470a03ade7d608773f8f633409bc2,"@@ -1,7 +1,7 @@
 package junit.framework;
 
 /**
- * A set of assert methods.
+ * A set of assert methods.  Messages are only displayed when an assert fails.
  */
 
 public class Assert {
@@ -59,20 +59,20 @@ static public void assertFalse(boolean condition) {
 		assertFalse(null, condition);
 	}
 	/**
-	 * Fails a test with the given message. 
+	 * Fails a test with the given message.
 	 */
 	static public void fail(String message) {
 		throw new AssertionFailedError(message);
 	}
 	/**
-	 * Fails a test with no message. 
+	 * Fails a test with no message.
 	 */
 	static public void fail() {
 		fail(null);
 	}
 	/**
 	 * Asserts that two objects are equal. If they are not
-	 * an AssertionFailedError is thrown.
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, Object expected, Object actual) {
 		if (expected == null && actual == null)
@@ -89,7 +89,8 @@ static public void assertEquals(Object expected, Object actual) {
 	    assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two doubles are equal concerning a delta. If the expected
+	 * Asserts that two doubles are equal concerning a delta.  If they are not
+	 * an AssertionFailedError is thrown with the given message.  If the expected
 	 * value is infinity then the delta value is ignored.
 	 */
 	static public void assertEquals(String message, double expected, double actual, double delta) {
@@ -109,7 +110,8 @@ static public void assertEquals(double expected, double actual, double delta) {
 	    assertEquals(null, expected, actual, delta);
 	}
 	/**
-	 * Asserts that two floats are equal concerning a delta. If the expected
+	 * Asserts that two floats are equal concerning a delta. If they are not
+	 * an AssertionFailedError is thrown with the given message.  If the expected
 	 * value is infinity then the delta value is ignored.
 	 */
 	static public void assertEquals(String message, float expected, float actual, float delta) {
@@ -129,7 +131,8 @@ static public void assertEquals(float expected, float actual, float delta) {
 		assertEquals(null, expected, actual, delta);
 	}
 	/**
-	 * Asserts that two longs are equal.
+	 * Asserts that two longs are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, long expected, long actual) {
 	    assertEquals(message, new Long(expected), new Long(actual));
@@ -141,7 +144,8 @@ static public void assertEquals(long expected, long actual) {
 	    assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two booleans are equal.
+	 * Asserts that two booleans are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, boolean expected, boolean actual) {
     		assertEquals(message, new Boolean(expected), new Boolean(actual));
@@ -153,7 +157,8 @@ static public void assertEquals(boolean expected, boolean actual) {
 		assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two bytes are equal.
+	 * Asserts that two bytes are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
   	static public void assertEquals(String message, byte expected, byte actual) {
 		assertEquals(message, new Byte(expected), new Byte(actual));
@@ -165,7 +170,8 @@ static public void assertEquals(byte expected, byte actual) {
 		assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two chars are equal.
+	 * Asserts that two chars are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
   	static public void assertEquals(String message, char expected, char actual) {
     		assertEquals(message, new Character(expected), new Character(actual));
@@ -177,7 +183,8 @@ static public void assertEquals(char expected, char actual) {
 		assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two shorts are equal.
+	 * Asserts that two shorts are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, short expected, short actual) {
     		assertEquals(message, new Short(expected), new Short(actual));
@@ -189,7 +196,8 @@ static public void assertEquals(short expected, short actual) {
 		assertEquals(null, expected, actual);
 	}
 	/**
-	 * Asserts that two ints are equal.
+	 * Asserts that two ints are equal. If they are not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
   	static public void assertEquals(String message, int expected, int actual) {
 		assertEquals(message, new Integer(expected), new Integer(actual));
@@ -207,10 +215,11 @@ static public void assertNotNull(Object object) {
 		assertNotNull(null, object);
 	}
 	/**
-	 * Asserts that an object isn't null.
+	 * Asserts that an object isn't null. If it is
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertNotNull(String message, Object object) {
-		assertTrue(message, object != null); 
+		assertTrue(message, object != null);
 	}
 	/**
 	 * Asserts that an object is null.
@@ -219,14 +228,15 @@ static public void assertNull(Object object) {
 		assertNull(null, object);
 	}
 	/**
-	 * Asserts that an object is null.
+	 * Asserts that an object is null.  If it is not
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertNull(String message, Object object) {
-		assertTrue(message, object == null); 
+		assertTrue(message, object == null);
 	}
 	/**
 	 * Asserts that two objects refer to the same object. If they are not
-	 * an AssertionFailedError is thrown.
+	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertSame(String message, Object expected, Object actual) {
 		if (expected == actual)
@@ -242,7 +252,7 @@ static public void assertSame(Object expected, Object actual) {
 	}
  	/**
  	 * Asserts that two objects refer to the same object. If they are not
- 	 * an AssertionFailedError is thrown.
+ 	 * an AssertionFailedError is thrown with the given message.
  	 */
 	static public void assertNotSame(String message, Object expected, Object actual) {
 		if (expected == actual)
@@ -255,7 +265,7 @@ static public void assertNotSame(String message, Object expected, Object actual)
 	static public void assertNotSame(Object expected, Object actual) {
 		assertNotSame(null, expected, actual);
 	}
- 	
+
 	static private void failSame(String message, Object expected, Object actual) {
 		String formatted= """";
  		if (message != null)
@@ -1,14 +1,14 @@
-package junit.runner;   
-    
-/**   
- * This class defines the current version of JUnit   
- */   
-public class Version {   
-	private Version() {   
-		// don't instantiate   
-	}   
+package junit.runner;
 
-	public static String id() {   
-		return ""3.7"";   
-	}   
-} 
+/**
+ * This class defines the current version of JUnit
+ */
+public class Version {
+	private Version() {
+		// don't instantiate
+	}
+
+	public static String id() {
+		return ""@version@"";
+	}
+}
",True,"The commit message refers to the necessity of changes by mentioning the addition of more Javadoc to Assert for messages and when they are displayed. This explains why the commit is modifying the Assert class to include more detailed documentation. Additionally, the commit message mentions the reintroduction of the version tag into the Version class, which could be seen as an improvement over a prior commit that removed it.",True,"The commit message explains the necessity of changes by mentioning that it is adding more Javadoc to the Assert class for messages and when they are displayed. This is not a trivial change and it improves the documentation of the code. Additionally, the commit message mentions that it is putting the version tag back into the Version class, which could be a necessary change if the version management system was accidentally removed or modified.",True,"The commit message explains the motivation for the changes by mentioning that it is adding more Javadoc to the Assert class to specify when messages are displayed. Additionally, the code diff shows that the assertEquals, assertFalse, fail, assertTrue, and assertNull methods now throw AssertionFailedError with a given message when the assertion fails, which is described in the updated Javadoc. This provides more clarity about the error scenario and the shortcoming of the previous implementation.",True,"The commit message 'Added more Javadoc to Assert for messages and when they are displayed. Put versiontag back into Version.' indicates that the changes were made to improve the documentation (Javadoc) and to update the version tag in the Version class. This could be due to the need for better software documentation for users or developers, or it could be a change to reflect the current version of the software. However, the message does not explicitly state that the changes were made due to a problem in the process of software maintenance, such as out-of-date code or a change in the runtime or development environment.",True,"The commit message mentions the addition of more Javadoc to the Assert class, specifically mentioning that messages are only displayed when an assert fails. This indicates that the change is improving the code by providing more clarity and useful information when tests fail.",True,"The commit message 'Added more Javadoc to Assert for messages and when they are displayed. Put versiontag back into Version.' accurately summarizes the changes made in the code diff. It mentions the addition of more Javadoc to the Assert class, which is true based on the diff. Additionally, it mentions the restoration of the versiontag in the Version class, which is also true based on the diff. The message contrasts the before and after state of the Version class by mentioning that the versiontag was put back into it.",True,"The commit message explains that the changes are adding more clarity to the Assert class by providing messages when assertions fail. This is a technical principle underpinning the changes, as it improves the usability and debuggability of the code.",True,"The commit message 'Added more Javadoc to Assert for messages and when they are displayed. Put versiontag back into Version.' does describe a summary of what changes by explaining the code changes from a functional perspective. It mentions the addition of more Javadoc to the Assert class, which provides more detailed explanations of the methods and when messages are displayed. It also mentions the reintroduction of the version tag into the Version class. This commit message effectively describes the new behaviors introduced, such as the ability to display more detailed messages when assertions fail and the ability to retrieve the current version of JUnit.",False,"The commit message does not lack an explanation. It explicitly mentions adding more Javadoc to Assert for messages and when they are displayed. Additionally, it mentions putting the version tag back into Version. These changes are not trivial and require an explanation to understand their purpose and impact."
https://github.com/junit-team/junit4/commit/870289f3272917f312de6902b8b6bdc43552d4b7,Simplify Filter implementation for backward compatibility ,https://api.github.com/repos/junit-team/junit4/commits/870289f3272917f312de6902b8b6bdc43552d4b7,"@@ -28,7 +28,7 @@ public JUnit4TestAdapter(final Class<?> newTestClass,
 			JUnit4TestAdapterCache cache) {
 		fCache = cache;
 		fNewTestClass = newTestClass;
-		fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();
+		fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();
 	}
 
 	public int countTestCases() {
@@ -50,20 +50,21 @@ public Class<?> getTestClass() {
 	}
 	
 	public Description getDescription() {
-		Description description= fRunner.getDescription();		
-		return removeIgnored(description);
+		return fRunner.getDescription();
 	}
 
-	private Description removeIgnored(Description description) {
-		if (isIgnored(description))
-			return Description.EMPTY;
-		Description result = description.childlessCopy();
-		for (Description each : description.getChildren()) {
-			Description child= removeIgnored(each);
-			if (! child.isEmpty())
-				result.addChild(child);
-		}
-		return result;
+	private Filter removeIgnored() {
+		return new Filter() {			
+			@Override
+			public boolean shouldRun(Description description) {
+				return !isIgnored(description);
+			}
+			
+			@Override
+			public String describe() {
+				return ""not ignored"";
+			}
+		};
 	}
 
 	private boolean isIgnored(Description description) {
@@ -13,6 +13,7 @@
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Request;
 import org.junit.runner.Result;
+import org.junit.runner.Runner;
 
 public class SuiteMethodTest {
 	public static boolean wasRun;
@@ -21,94 +22,108 @@ static public class OldTest extends TestCase {
 		public OldTest(String name) {
 			super(name);
 		}
-		
+
 		public static junit.framework.Test suite() {
 			TestSuite result= new TestSuite();
 			result.addTest(new OldTest(""notObviouslyATest""));
 			return result;
 		}
-		
+
 		public void notObviouslyATest() {
 			wasRun= true;
 		}
 	}
-	
-	@Test public void makeSureSuiteIsCalled() {
+
+	@Test
+	public void makeSureSuiteIsCalled() {
 		wasRun= false;
 		JUnitCore.runClasses(OldTest.class);
 		assertTrue(wasRun);
 	}
-	
+
 	static public class NewTest {
-		@Test public void sample() {
+		@Test
+		public void sample() {
 			wasRun= true;
 		}
 
 		public static junit.framework.Test suite() {
 			return new JUnit4TestAdapter(NewTest.class);
 		}
 	}
-	
-	@Test public void makeSureSuiteWorksWithJUnit4Classes() {
+
+	@Test
+	public void makeSureSuiteWorksWithJUnit4Classes() {
 		wasRun= false;
 		JUnitCore.runClasses(NewTest.class);
 		assertTrue(wasRun);
 	}
-	
 
 	public static class CompatibilityTest {
-		@Ignore	@Test
+		@Ignore
+		@Test
 		public void ignored() {
 		}
-		
+
 		public static junit.framework.Test suite() {
 			return new JUnit4TestAdapter(CompatibilityTest.class);
 		}
 	}
-	
-	@Test public void descriptionAndRunNotificationsAreConsistent() {
+
+	// when executing as JUnit 3, ignored tests are stripped out before execution
+	@Test
+	public void descriptionAndRunNotificationsAreConsistent() {
 		Result result= JUnitCore.runClasses(CompatibilityTest.class);
 		assertEquals(0, result.getIgnoreCount());
-		
-		Description description= Request.aClass(CompatibilityTest.class).getRunner().getDescription();
-		assertEquals(0, description.getChildren().size());
+
+		Runner runner= Request.aClass(CompatibilityTest.class).getRunner();
+		Description description= runner.getDescription();
+		assertEquals(1, description.getChildren().size());
+		assertEquals(""initializationError"", description.getChildren().get(0)
+				.getMethodName());
 	}
-	
+
 	static public class NewTestSuiteFails {
-		@Test public void sample() {
+		@Test
+		public void sample() {
 			wasRun= true;
 		}
-		
+
 		public static junit.framework.Test suite() {
 			fail(""called with JUnit 4 runner"");
 			return null;
 		}
 	}
-	
-	@Test public void suiteIsUsedWithJUnit4Classes() {
+
+	@Test
+	public void suiteIsUsedWithJUnit4Classes() {
 		wasRun= false;
 		Result result= JUnitCore.runClasses(NewTestSuiteFails.class);
 		assertEquals(1, result.getFailureCount());
 		assertFalse(wasRun);
 	}
-	
+
 	static public class NewTestSuiteNotUsed {
 		private static boolean wasIgnoredRun;
-		
-		@Test public void sample() {
+
+		@Test
+		public void sample() {
 			wasRun= true;
 		}
-		
-		@Ignore @Test public void ignore() {
+
+		@Ignore
+		@Test
+		public void ignore() {
 			wasIgnoredRun= true;
 		}
-		
+
 		public static junit.framework.Test suite() {
 			return new JUnit4TestAdapter(NewTestSuiteNotUsed.class);
 		}
 	}
-	
-	@Test public void makeSureSuiteNotUsedWithJUnit4Classes2() {
+
+	@Test
+	public void makeSureSuiteNotUsedWithJUnit4Classes2() {
 		wasRun= false;
 		NewTestSuiteNotUsed.wasIgnoredRun= false;
 		Result res= JUnitCore.runClasses(NewTestSuiteNotUsed.class);
",True,"The commit message 'Simplify Filter implementation for backward compatibility' refers to the necessity of changes by mentioning 'backward compatibility'. The code diff shows that the filter implementation has been changed to improve backward compatibility. Specifically, the filter 'removeIgnored()' is now used to get the runner, which will exclude ignored tests when running as JUnit 3. This change ensures that the code works correctly with both JUnit 3 and JUnit 4, improving compatibility with prior versions.",True,"The commit message 'Simplify Filter implementation for backward compatibility' does not explicitly state the reason for the changes. However, the code diff shows that the changes are made to the Filter implementation, which is likely done to improve backward compatibility. This is a common reason for changes, especially in software development, and it can be inferred from the context of the commit message and the code diff.",True,"The commit message 'Simplify Filter implementation for backward compatibility' does contain an expression that describes the necessity of changes. The code diff shows that the filterWith(removeIgnored()) method is added to the fRunner object. This change is likely made to improve backward compatibility, as it allows the code to handle ignored tests in a way that is compatible with both JUnit 3 and JUnit 4. This is mentioned in the descriptionAndRunNotificationsAreConsistent test, which checks that ignored tests are stripped out before execution when running as JUnit 3.",True,"The commit message 'Simplify Filter implementation for backward compatibility' indicates that the changes were made to ensure the code remains compatible with older versions or dependencies. This suggests that the source of the requirements was the need to maintain backward compatibility, which is a common issue in software maintenance.",True,"The commit message 'Simplify Filter implementation for backward compatibility' directly mentions the improvement it makes to the code, which is simplifying the Filter implementation to ensure backward compatibility.",True,"The commit message 'Simplify Filter implementation for backward compatibility' accurately summarizes the changes made in the code diff. Specifically, it highlights the modification of the Filter implementation, which was previously a method that removed ignored tests, but has now been replaced with a Filter object that checks if a test should run based on whether it is ignored or not. This change simplifies the implementation and ensures backward compatibility.",True,"The commit message 'Simplify Filter implementation for backward compatibility' describes the technical principle underpinning the changes, which is the use of a Filter to remove ignored tests. This is evident in the code diff where the `removeIgnored()` method is used to filter out ignored tests.",True,"The commit message 'Simplify Filter implementation for backward compatibility' accurately describes the changes made in the code diff. The changes involve replacing a recursive function 'removeIgnored' with a filter 'removeIgnored' that checks if a test is ignored. This change simplifies the code and introduces new behavior where ignored tests are filtered out before execution, ensuring backward compatibility.",False,"The commit message explains the reason for the change as 'Simplify Filter implementation for backward compatibility'. This is not easily inferred from the code diff, as the change involves replacing a method call with a filter, which is a more complex operation. Additionally, the change introduces a new Filter interface and its implementation, which is not a simple modification."
https://github.com/square/retrofit/commit/c0cc4cb5bbf688a11dda5531f009300b20005e61,RxJava 1.0.14 with an important Android fix.  <enter> Just in case someone is relying on the transitive dependency. ,https://api.github.com/repos/square/retrofit/commits/c0cc4cb5bbf688a11dda5531f009300b20005e61,"@@ -54,7 +54,7 @@
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.13</rxjava.version>
+    <rxjava.version>1.0.14</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.3.1</gson.version>
",True,"The commit message refers to an important Android fix in RxJava 1.0.14, which is a version update. The message also mentions that the change is made 'just in case someone is relying on the transitive dependency'. This suggests that there might have been a problem with the previous version (1.0.13) that this update addresses, thereby explaining the necessity of the changes.",False,"The commit message does not explicitly describe the necessity of the changes. While it mentions an 'important Android fix', it does not provide any details about what the fix is or why it is important. The diff only shows a version update of RxJava from 1.0.13 to 1.0.14, but the message does not explain why this update is necessary. Therefore, the commit message does not contain an expression that clearly explains the necessity of the changes.",False,"The commit message does not explicitly describe the necessity of the changes. It only mentions that there is an important Android fix in RxJava 1.0.14 and that the change is made just in case someone is relying on the transitive dependency. However, it does not elaborate on the specific error scenario, issue report, or shortcoming of the previous implementation that necessitated the change.",True,"The commit message mentions 'an important Android fix' in RxJava 1.0.14. This indicates that there was a problem in the previous version of RxJava that was causing issues on Android, and the update to version 1.0.14 is intended to fix this problem. This is an example of the necessity of changes due to problems in the software maintenance process.",True,"The commit message mentions an 'important Android fix' which directly refers to the change made in the code diff, where the version of RxJava is updated from 1.0.13 to 1.0.14. This suggests that the update is likely to address a bug or issue that was present in the previous version, specifically on Android.",True,"The commit message 'RxJava 1.0.14 with an important Android fix' does describe a summary of the changes by pointing out the key component of the change, which is the update of RxJava version from 1.0.13 to 1.0.14. The message also mentions the importance of the fix for Android, which could be inferred from the code diff. Therefore, the commit message does a good job of summarizing the changes made in the code.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions that a new version of RxJava is being used, which is a library update, not a change in the underlying technical principle.",True,"The commit message 'RxJava 1.0.14 with an important Android fix' clearly describes the changes made in the code diff. It mentions that the version of RxJava has been updated from 1.0.13 to 1.0.14, which implies a change in the codebase. Furthermore, it mentions an 'important Android fix', which suggests that the update addresses a specific issue related to Android. This indicates that the update introduces new behavior or fixes a bug, thereby changing the functional perspective of the code.",False,"The commit message does not explicitly state the reason for the change, but it does mention an 'important Android fix'. While the change itself is small and simple, the mention of an 'important Android fix' suggests that there might be a specific issue that the update addresses. Therefore, the commit message could be considered lacking an explicit explanation of the reason for the change."
https://github.com/apache/dubbo/commit/e8d85386bc7869d3a6e5b27c12ec7784c74bc2d6,Format code ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/e8d85386bc7869d3a6e5b27c12ec7784c74bc2d6,"@@ -36,7 +36,7 @@
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
     public static final String NAME = ""roundrobin"";
     
-    private static int RECYCLE_PERIOD = 60000;
+    private static final int RECYCLE_PERIOD = 60000;
     
     protected static class WeightedRoundRobin {
         private int weight;
@@ -47,7 +47,7 @@ public class ConditionRouter extends AbstractRouter {
     public static final String NAME = ""condition"";
 
     private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class);
-    protected static Pattern ROUTE_PATTERN = Pattern.compile(""([&!=,]*)\\s*([^&!=,\\s]+)"");
+    protected static final Pattern ROUTE_PATTERN = Pattern.compile(""([&!=,]*)\\s*([^&!=,\\s]+)"");
     protected Map<String, MatchPair> whenCondition;
     protected Map<String, MatchPair> thenCondition;
 
@@ -156,9 +156,9 @@ private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,
         if ((selected != null && selected.contains(invoker))
                 || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
             try {
-                Invoker<T> rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
-                if (rinvoker != null) {
-                    invoker = rinvoker;
+                Invoker<T> rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
+                if (rInvoker != null) {
+                    invoker = rInvoker;
                 } else {
                     //Check the index of current selected invoker, if it's not the last one, choose the one at index+1.
                     int index = invokers.indexOf(invoker);
@@ -43,7 +43,7 @@ public class QosProcessHandler extends ByteToMessageDecoder {
     // true means to accept foreign IP
     private boolean acceptForeignIp;
 
-    public static String prompt = ""dubbo>"";
+    public static final String prompt = ""dubbo>"";
 
     public QosProcessHandler(String welcome, boolean acceptForeignIp) {
         this.welcome = welcome;
@@ -44,9 +44,9 @@ public class HeaderExchangeHandler implements ChannelHandlerDelegate {
 
     protected static final Logger logger = LoggerFactory.getLogger(HeaderExchangeHandler.class);
 
-    public static String KEY_READ_TIMESTAMP = HeartbeatHandler.KEY_READ_TIMESTAMP;
+    public static final String KEY_READ_TIMESTAMP = HeartbeatHandler.KEY_READ_TIMESTAMP;
 
-    public static String KEY_WRITE_TIMESTAMP = HeartbeatHandler.KEY_WRITE_TIMESTAMP;
+    public static final String KEY_WRITE_TIMESTAMP = HeartbeatHandler.KEY_WRITE_TIMESTAMP;
 
     private final ExchangeHandler handler;
 
@@ -31,9 +31,9 @@ public class HeartbeatHandler extends AbstractChannelHandlerDelegate {
 
     private static final Logger logger = LoggerFactory.getLogger(HeartbeatHandler.class);
 
-    public static String KEY_READ_TIMESTAMP = ""READ_TIMESTAMP"";
+    public static final String KEY_READ_TIMESTAMP = ""READ_TIMESTAMP"";
 
-    public static String KEY_WRITE_TIMESTAMP = ""WRITE_TIMESTAMP"";
+    public static final String KEY_WRITE_TIMESTAMP = ""WRITE_TIMESTAMP"";
 
     public HeartbeatHandler(ChannelHandler handler) {
         super(handler);
",True,"The commit message 'Format code' does not explicitly describe the necessity of changes, but the code diff shows that the changes are related to code formatting. Specifically, the changes include adding 'final' modifiers to variables that are not reassigned, which is a common convention in Java to improve code readability and maintainability.",True,"The commit message 'Format code' does not provide a clear rationale for the changes made. However, the changes in the diff are mostly related to code formatting, such as adding 'final' modifiers to variables and methods, which is a common practice to improve code readability and maintainability. Therefore, it can be inferred that the commit was made to improve the code formatting, which is a common sense change that does not require a detailed explanation in the commit message.",False,"The commit message 'Format code' does not provide any context or explanation about the necessity of the changes. It only mentions formatting the code, which does not necessarily imply a functional change or error resolution. The code diff shows changes such as adding 'final' modifiers to variables and methods, which are more about code style and optimization rather than addressing a specific issue or error.",True,"The commit message 'Format code' does not explicitly describe the necessity of changes. However, the code diff indicates that the developer is changing the code to make it more consistent and adhere to a coding standard. This could be a requirement for better software maintenance, as it improves the readability and maintainability of the code.",False,"The commit message 'Format code' does not directly mention any defects it fixes or improvements it makes to the code. It only mentions the formatting of the code, which is a stylistic change and does not necessarily indicate a functional change.",True,"The commit message 'Format code' does not directly describe the changes made in the code diff. However, the diff shows modifications such as changing a variable from being non-final to final, which could be considered a formatting change. Additionally, the diff shows the renaming of a pattern variable, but the commit message does not explicitly mention this. Therefore, while the commit message does not perfectly summarize the changes, it does hint at some formatting changes being made.",True,"The commit message does not explicitly state the technical principle, but the changes in the code diff suggest that the principle of 'Improving Code Readability and Maintainability' is being followed. Specifically, the changes are introducing 'final' keywords to variables that are not intended to be modified after initialization, which is a common practice to improve code clarity and prevent potential bugs.",True,"The commit message 'Format code' does not explicitly describe the changes made to the code from a functional perspective or introduce new behaviors. However, the code diff indicates that some variables have been changed from being non-final to final, which is a formatting change that does not affect the functional behavior of the code. Therefore, the commit message does not contain an expression that describes a summary of the changes.",True,"The commit message only mentions formatting the code, but the code diff shows that the change is the addition of the 'final' keyword to two variables. This is a small and simple change that doesn't require an explanation in the commit message."
https://github.com/square/okhttp/commit/6cf56de5d0701ff26aa6043c552e17c4665c1287,"Return HttpResponseCache to previous (e.g. KitKat) behavior  <enter> This change required to handle this Android scenario: <enter> When this version of OkHttp is packaged into Android in a future release (in com.android.okhttp...) there is a possibility that an older version of OkHttp bundled with application (in com.squareup.okhttp...) will pick up the newer HttpResponseCache via ResponseCache.getDefault(). It will attempt to use the get() / put() methods. Commit  <otherCommit_link>  was intended to restore HttpResponseCache get() and put() and avoid the UnsupportedOperationException that would be thrown. <enter> Unfortunately, it didn't quite do it: <enter> In KitKat and older versions OkHttp, in HttpResponseCache the behavior was to ignore any calls to put(URI, URLConnection) including any HttpURLConnection/HttpsURLConnection that wasn't its own (i.e. only ones from com.android.okhttp would be cached). The previous fix to HttpResponseCache re-introduced get()/put() but didn't implement the necessary instanceof checks. <enter> Jesse also informs me that coexistance with other implementations of HttpURLConnection is not required (since OkHttp replaces the HTTP implementation on the desktop). I have also since discovered that HttpResponseCache didn't implement the cache-control logic required to follow the letter of the Java API anyway, which means that HttpResponseCache is not suitable for use in cases where the Http(s)URLConnection implementation expects a fully compliant implementation. <enter> Also addressed nits from  <otherCommit_link> . ",https://api.github.com/repos/square/okhttp/commits/6cf56de5d0701ff26aa6043c552e17c4665c1287,"@@ -53,6 +53,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
@@ -1861,28 +1862,60 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals(""foo"", connection.getHeaderField(""etag""));
   }
 
-  // For compatibility with Java HttpURLConnections, and when Android-bundled and and older
-  // app-bundled OkHttp library are in use at the same time in an Android app, the HttpResponseCache
-  // must behave as a working, Java compliant, ResponseCache.
-  @Test public void testHttpResponseCacheIsValidResponseCache() throws Exception {
+  // Older versions of OkHttp use ResponseCache.get() and ResponseCache.put(). For compatibility
+  // with Android apps when the Android-bundled and and an older app-bundled OkHttp library are in
+  // use at the same time the HttpResponseCache must behave as it always used to. That's not the
+  // same as a fully API-compliant {@link ResponseCache}: That means that the cache
+  // doesn't throw an exception from get() or put() and also does not cache requests/responses from
+  // anything other than the variant of OkHttp that it comes with. It does still return values from
+  // get() and it is not expected to implement any cache-control logic.
+  @Test public void testHttpResponseCacheBackwardsCompatible() throws Exception {
     assertSame(cache, ResponseCache.getDefault());
+    assertEquals(0, cache.getRequestCount());
 
     String body = ""Body"";
-    server.enqueue(new MockResponse().setBody(body));
+    server.enqueue(new MockResponse()
+        .addHeader(""Last-Modified: "" + formatDate(-1, TimeUnit.HOURS))
+        .addHeader(""Expires: "" + formatDate(1, TimeUnit.HOURS))
+        .setBody(body));
     server.play();
 
-    // Use a standard Java HttpURLConnection, which will pick up the default ResponseCache.
     URL url = server.getUrl(""/"");
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    assertEquals(body, readAscii(connection));
-    connection.disconnect();
 
-    // Next request should be cached.
-    HttpURLConnection connection2 = (HttpURLConnection) url.openConnection();
-    assertEquals(body, readAscii(connection2));
-    connection2.disconnect();
+    // Here we use a HttpURLConnection from URL to represent a non-OkHttp HttpURLConnection. In
+    // Android this would be com.android.okhttp.internal.http.HttpURLConnectionImpl. In tests this
+    // is some other implementation.
+    HttpURLConnection javaConnection = (HttpURLConnection) url.openConnection();
+    assertFalse(""This test relies on url.openConnection() not returning an OkHttp connection"",
+        javaConnection instanceof HttpURLConnectionImpl);
+    javaConnection.disconnect();
+
+    // This should simply be discarded. It doesn't matter the connection is not useful.
+    cache.put(url.toURI(), javaConnection);
+
+    // Confirm the initial cache state.
+    assertNull(cache.get(url.toURI(), ""GET"", new HashMap<String, List<String>>()));
+
+    // Now cache a response
+    HttpURLConnection okHttpConnection = openConnection(url);
+    assertEquals(body, readAscii(okHttpConnection));
+    okHttpConnection.disconnect();
 
     assertEquals(1, server.getRequestCount());
+    assertEquals(0, cache.getHitCount());
+
+    // OkHttp should now find the result cached.
+    HttpURLConnection okHttpConnection2 = openConnection(url);
+    assertEquals(body, readAscii(okHttpConnection2));
+    okHttpConnection2.disconnect();
+
+    assertEquals(1, server.getRequestCount());
+    assertEquals(1, cache.getHitCount());
+
+    // Confirm the unfortunate get() behavior.
+    assertNotNull(cache.get(url.toURI(), ""GET"", new HashMap<String, List<String>>()));
+    // Only OkHttp makes the necessary callbacks to increment the cache stats.
+    assertEquals(1, cache.getHitCount());
   }
 
   private void writeFile(File directory, String file, String content) throws IOException {
@@ -49,7 +49,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -432,9 +432,9 @@ public Principal getLocalPrincipal() {
     // Check retrieval using a Map.
     Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
     assertEquals(Arrays.asList(statusLine), responseHeaders.get(null));
-    assertEquals(newSet(""c"", ""e""), new HashSet<String>(responseHeaders.get(""A"")));
+    assertEquals(newSet(""c"", ""e""), newSet(responseHeaders.get(""A"")));
     // OkHttp supports case-insensitive matching here. The RI does not.
-    assertEquals(newSet(""c"", ""e""), new HashSet<String>(responseHeaders.get(""a"")));
+    assertEquals(newSet(""c"", ""e""), newSet(responseHeaders.get(""a"")));
 
     // Check the Map iterator contains the expected mappings.
     assertHeadersContainsMapping(responseHeaders, null, statusLine);
@@ -485,7 +485,7 @@ private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnect
   private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
       String... expectedValues) {
     assertTrue(headers.containsKey(expectedKey));
-    assertEquals(newSet(expectedValues), new HashSet<String>(headers.get(expectedKey)));
+    assertEquals(newSet(expectedValues), newSet(headers.get(expectedKey)));
   }
 
   @Test public void createJavaUrlConnection_accessibleRequestInfo_GET() throws Exception {
@@ -717,8 +717,12 @@ private static X509Certificate certificate(String certificate) {
     }
   }
 
-  private static Set<String> newSet(String... elements) {
-    return new HashSet<String>(Arrays.asList(elements));
+  private static <T> Set<T> newSet(T... elements) {
+    return newSet(Arrays.asList(elements));
+  }
+
+  private static <T> Set<T> newSet(List<T> elements) {
+    return new LinkedHashSet<T>(elements);
   }
 
   private static Request createArbitraryOkRequest() {
@@ -55,8 +55,8 @@
  * <ul>
  *   <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
  *   classes are called correctly by OkHttp.</li>
- *   <li>{@link JavaApiConverterTest} for tests that check Java API classes <-> OkHttp conversion logic.
- *   </li>
+ *   <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
+ *   logic. </li>
  * </ul>
  */
 public class ResponseCacheAdapterTest {
@@ -19,6 +19,8 @@
 import com.squareup.okhttp.internal.DiskLruCache;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpMethod;
+import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
 import com.squareup.okhttp.internal.http.JavaApiConverter;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
@@ -53,6 +55,18 @@
  * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
  * saving time and bandwidth.
  *
+ * <p>This cache extends {@link ResponseCache} but is only intended for use
+ * with OkHttp and is not a general-purpose implementation: The
+ * {@link ResponseCache} API requires that the subclass handles cache-control
+ * logic as well as storage. In OkHttp the {@link HttpResponseCache} only
+ * handles cursory cache-control logic.
+ *
+ * <p>To maintain support for previous releases the {@link HttpResponseCache}
+ * will disregard any {@link #put(java.net.URI, java.net.URLConnection)}
+ * calls with a URLConnection that is not from OkHttp. It will, however,
+ * return cached data for any calls to {@link #get(java.net.URI, String,
+ * java.util.Map)}.
+ *
  * <h3>Cache Optimization</h3>
  * To measure cache effectiveness, this class tracks three statistics:
  * <ul>
@@ -168,9 +182,17 @@ private static String urlToKey(Request requst) {
   }
 
   @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    if (!isCacheableConnection(urlConnection)) {
+      return null;
+    }
     return put(JavaApiConverter.createOkResponse(uri, urlConnection));
   }
 
+  private static boolean isCacheableConnection(URLConnection httpConnection) {
+    return (httpConnection instanceof HttpURLConnectionImpl)
+        || (httpConnection instanceof HttpsURLConnectionImpl);
+  }
+
   @Override public CacheRequest put(Response response) throws IOException {
     String requestMethod = response.request().method();
 
@@ -52,10 +52,6 @@ private JavaApiConverter() {
   /**
    * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection}
    * to supply the data. The URLConnection is assumed to already be connected.
-   *
-   * <p>Note: Because this method is used by HttpResponseCache, this class is intended for use with
-   * any Java-API compliant HttpURLConnection / HttpsURLConnection and not just ones implemented by
-   * OkHttp.
    */
   public static Response createOkResponse(URI uri, URLConnection urlConnection) throws IOException {
     HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
",True,The commit message refers to a convention regarding the behavior of HttpResponseCache in older versions of OkHttp and Android. It explains why the commit restores the previous behavior of HttpResponseCache: to maintain compatibility with older versions of OkHttp and Android when both are used in the same application.,True,"The commit message explains the necessity of changes by stating that the changes are required to handle a specific Android scenario. The scenario involves the coexistence of different versions of OkHttp in an Android application, which can lead to unexpected behavior with the HttpResponseCache. The commit message explains that the changes are necessary to restore the previous behavior of HttpResponseCache and avoid throwing an UnsupportedOperationException.",True,"The commit message directly elaborates the motivation of the code change by describing the error scenario and the shortcoming of the previous implementation. It mentions that the previous implementation of HttpResponseCache re-introduced get()/put() but didn't implement the necessary instanceof checks, which caused it to not behave as expected when used with other implementations of HttpURLConnection. The commit message also mentions that the change is required to handle a specific Android scenario where an older version of OkHttp bundled with an application could pick up the newer HttpResponseCache and attempt to use the get() / put() methods, which would throw an UnsupportedOperationException.",True,"The commit message describes the necessity of changes by mentioning the need for compatibility with Android scenarios where an older version of OkHttp bundled with an application may pick up the newer HttpResponseCache. This is required to avoid UnsupportedOperationException and to maintain the previous behavior of ignoring calls to put(URI, URLConnection) from anything other than the variant of OkHttp that it comes with.",True,"The commit message directly mentions the objective of the change by stating that it is required to handle a specific Android scenario where an older version of OkHttp bundled with an application will pick up the newer HttpResponseCache via ResponseCache.getDefault(). This will attempt to use the get() / put() methods, which were intended to be restored in a previous commit, but didn't quite do it. The commit message explains that the change is necessary to restore the previous behavior of HttpResponseCache in KitKat and older versions of OkHttp, where it would ignore any calls to put(URI, URLConnection) from anything other than com.android.okhttp.",True,"The commit message describes the changes made to the HttpResponseCache class, which is used to cache HTTP and HTTPS responses. The message explains that the changes were made to restore the behavior of the HttpResponseCache class to its previous state, where it ignored calls to put(URI, URLConnection) from any URLConnection that was not its own. The message also mentions that the changes did not fully implement the necessary instanceof checks, which caused the HttpResponseCache to behave differently than a fully API-compliant ResponseCache. The message contrasts the previous behavior of the HttpResponseCache class with its new behavior, and explains why the changes were necessary.",True,"The commit message explains that the changes are made to ensure compatibility with older versions of OkHttp and Android. It mentions that the HttpResponseCache must behave as it always used to, which means that it doesn't cache requests/responses from anything other than the variant of OkHttp that it comes with. This is a technical principle that underpins the changes, as it ensures that the cache is used correctly and efficiently.",True,"The commit message expresses a change in behavior and describes the new behavior introduced. It explains that the change is required to handle a specific Android scenario where an older version of OkHttp bundled with an application will attempt to use the get() and put() methods of HttpResponseCache, which were removed in a previous commit. The commit message explains that the change restores the previous behavior of HttpResponseCache, which ignored calls to put(URI, URLConnection) from anything other than the variant of OkHttp that it comes with. It also mentions that the change does not implement full cache-control logic, as required by the Java API, and that HttpResponseCache is not suitable for use in cases where the Http(s)URLConnection implementation expects a fully compliant implementation.",False,"The commit message explains the reason for the commit in detail. It mentions that the change is required to handle a specific Android scenario, and it explains the issue that was introduced in a previous commit. The message also mentions that the change is not a full API-compliant implementation of ResponseCache, and it explains the limitations of the new implementation. Therefore, the commit message does not lack an explanation of the reason for the commit."
https://github.com/square/okhttp/commit/137e7de0454f10160370f105ac7d9d2fc5403c84,"New API, HandshakeCertificates.addPlatformTrustedCertificates()  <enter> Also rename HeldCertificate.Builder.issuedBy() to signedBy(). 'Issued' is the word used by certificates; 'signed' is the word used by cryptographers. I prefer 'signed'. ",https://api.github.com/repos/square/okhttp/commits/137e7de0454f10160370f105ac7d9d2fc5403c84,"@@ -530,7 +530,7 @@ private List<String> headersToList(MockResponse response) {
         .certificateAuthority(0)
         .build();
     HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .issuedBy(serverCa)
+        .signedBy(serverCa)
         .addSubjectAlternativeName(server.getHostName())
         .build();
     HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
@@ -543,7 +543,7 @@ private List<String> headersToList(MockResponse response) {
     server.requestClientAuth();
 
     HeldCertificate clientCertificate = new HeldCertificate.Builder()
-        .issuedBy(clientCa)
+        .signedBy(clientCa)
         .build();
     HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()
         .addTrustedCertificate(serverCa.certificate())
@@ -77,11 +77,11 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
@@ -94,11 +94,11 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
@@ -112,15 +112,15 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
         .serialNumber(4L)
-        .issuedBy(certB)
+        .signedBy(certB)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
@@ -134,15 +134,15 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
         .serialNumber(4L)
-        .issuedBy(certB)
+        .signedBy(certB)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
@@ -156,11 +156,11 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
     HeldCertificate certUnnecessary = new HeldCertificate.Builder()
         .serialNumber(4L)
@@ -177,15 +177,15 @@ public final class CertificateChainCleanerTest {
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
         .serialNumber(2L)
-        .issuedBy(selfSigned)
+        .signedBy(selfSigned)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber(3L)
-        .issuedBy(trusted)
+        .signedBy(trusted)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber(4L)
-        .issuedBy(certA)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(
@@ -203,15 +203,15 @@ public final class CertificateChainCleanerTest {
         .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .issuedBy(unknownSigner)
+        .signedBy(unknownSigner)
         .serialNumber(2L)
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(trusted)
+        .signedBy(trusted)
         .serialNumber(3L)
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
+        .signedBy(intermediateCa)
         .serialNumber(4L)
         .build();
 
@@ -256,7 +256,7 @@ private List<HeldCertificate> chainOfLength(int length) {
     List<HeldCertificate> result = new ArrayList<>();
     for (int i = 1; i <= length; i++) {
       result.add(0, new HeldCertificate.Builder()
-          .issuedBy(!result.isEmpty() ? result.get(0) : null)
+          .signedBy(!result.isEmpty() ? result.get(0) : null)
           .serialNumber(i)
           .build());
     }
@@ -56,7 +56,7 @@ public final class ConnectionCoalescingTest {
         .commonName(""root"")
         .build();
     certificate = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .serialNumber(2L)
         .commonName(server.getHostName())
         .addSubjectAlternativeName(server.getHostName())
@@ -61,13 +61,13 @@ public final class CertificatePinnerChainValidationTest {
         .commonName(""root"")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""intermediate_ca"")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
+        .signedBy(intermediateCa)
         .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
@@ -118,13 +118,13 @@ public final class CertificatePinnerChainValidationTest {
         .commonName(""root"")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""intermediate_ca"")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
+        .signedBy(intermediateCa)
         .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
@@ -184,13 +184,13 @@ public final class CertificatePinnerChainValidationTest {
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""good_intermediate_ca"")
         .build();
     HeldCertificate goodCertificate = new HeldCertificate.Builder()
-        .issuedBy(goodIntermediateCa)
+        .signedBy(goodIntermediateCa)
         .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
@@ -212,14 +212,14 @@ public final class CertificatePinnerChainValidationTest {
     // trusted good certificate above. The attack is that by including the good certificate in the
     // chain, we may trick the certificate pinner into accepting the rouge certificate.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(4L)
         .commonName(""bad_intermediate_ca"")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
         .serialNumber(5L)
-        .issuedBy(compromisedIntermediateCa)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
@@ -264,7 +264,7 @@ public final class CertificatePinnerChainValidationTest {
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
+        .signedBy(rootCa)
         .certificateAuthority(0)
         .serialNumber(3L)
         .commonName(""intermediate_ca"")
@@ -288,14 +288,14 @@ public final class CertificatePinnerChainValidationTest {
     // serves the good CAs certificate in the chain, which means the certificate pinner sees a
     // different set of certificates than the SSL verifier.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(compromisedRootCa)
+        .signedBy(compromisedRootCa)
         .certificateAuthority(0)
         .serialNumber(4L)
         .commonName(""intermediate_ca"")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
         .serialNumber(5L)
-        .issuedBy(compromisedIntermediateCa)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
@@ -67,15 +67,15 @@ public void setUp() {
         .addSubjectAlternativeName(""root_ca.com"")
         .build();
     serverIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
+        .signedBy(serverRootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""intermediate_ca"")
         .addSubjectAlternativeName(""intermediate_ca.com"")
         .build();
 
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
+        .signedBy(serverIntermediateCa)
         .serialNumber(3L)
         .commonName(""Local Host"")
         .addSubjectAlternativeName(server.getHostName())
@@ -88,15 +88,15 @@ public void setUp() {
         .addSubjectAlternativeName(""root_ca.com"")
         .build();
     clientIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
+        .signedBy(serverRootCa)
         .certificateAuthority(0)
         .serialNumber(2L)
         .commonName(""intermediate_ca"")
         .addSubjectAlternativeName(""intermediate_ca.com"")
         .build();
 
     clientCert = new HeldCertificate.Builder()
-        .issuedBy(clientIntermediateCa)
+        .signedBy(clientIntermediateCa)
         .serialNumber(4L)
         .commonName(""Jethro Willis"")
         .addSubjectAlternativeName(""jethrowillis.com"")
@@ -188,7 +188,7 @@ public void setUp() {
 
   @Test public void commonNameIsNotTrusted() throws Exception {
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
+        .signedBy(serverIntermediateCa)
         .serialNumber(3L)
         .commonName(server.getHostName())
         .addSubjectAlternativeName(""different-host.com"")
@@ -20,13 +20,16 @@
 import java.security.SecureRandom;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509KeyManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
 
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
@@ -137,6 +140,24 @@ public Builder addTrustedCertificate(X509Certificate certificate) {
       return this;
     }
 
+    /**
+     * Add all of the host platform's trusted root certificates. This set varies by platform
+     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
+     * customizations.
+     *
+     * <p>Most TLS clients that connect to hosts on the public Internet should call this method.
+     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
+     *
+     * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root
+     * certificates. Applications that connect to a known set of servers may be able to mitigate
+     * this problem with {@linkplain CertificatePinner certificate pinning}.
+     */
+    public Builder addPlatformTrustedCertificates() {
+      X509TrustManager platformTrustManager = Util.platformTrustManager();
+      Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers());
+      return this;
+    }
+
     public HandshakeCertificates build() {
       try {
         X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates);
@@ -208,7 +208,7 @@ public static final class Builder {
     private final List<String> altNames = new ArrayList<>();
     private BigInteger serialNumber;
     private KeyPair keyPair;
-    private HeldCertificate issuedBy;
+    private HeldCertificate signedBy;
     private int maxIntermediateCas = -1;
     private String keyAlgorithm;
     private int keySize;
@@ -298,11 +298,11 @@ public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {
     }
 
     /**
-     * Set the certificate that will sign this certificate. If unset the certificate will be
+     * Set the certificate that will issue this certificate. If unset the certificate will be
      * self-signed.
      */
-    public Builder issuedBy(HeldCertificate issuedBy) {
-      this.issuedBy = issuedBy;
+    public Builder signedBy(HeldCertificate signedBy) {
+      this.signedBy = signedBy;
       return this;
     }
 
@@ -357,9 +357,9 @@ public HeldCertificate build() {
       // Subject, public & private keys for this certificate's signer. It may be self signed!
       KeyPair signedByKeyPair;
       X500Principal signedByPrincipal;
-      if (issuedBy != null) {
-        signedByKeyPair = issuedBy.keyPair;
-        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
+      if (signedBy != null) {
+        signedByKeyPair = signedBy.keyPair;
+        signedByPrincipal = signedBy.certificate.getSubjectX500Principal();
       } else {
         signedByKeyPair = heldKeyPair;
         signedByPrincipal = subject;
@@ -21,7 +21,10 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.security.PrivateKey;
+import java.security.cert.X509Certificate;
 import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -37,6 +40,7 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public final class HandshakeCertificatesTest {
   private ExecutorService executorService;
@@ -57,21 +61,21 @@ public final class HandshakeCertificatesTest {
         .build();
     HeldCertificate clientIntermediate = new HeldCertificate.Builder()
         .certificateAuthority(0)
-        .issuedBy(clientRoot)
+        .signedBy(clientRoot)
         .build();
     HeldCertificate clientCertificate = new HeldCertificate.Builder()
-        .issuedBy(clientIntermediate)
+        .signedBy(clientIntermediate)
         .build();
 
     HeldCertificate serverRoot = new HeldCertificate.Builder()
         .certificateAuthority(1)
         .build();
     HeldCertificate serverIntermediate = new HeldCertificate.Builder()
         .certificateAuthority(0)
-        .issuedBy(serverRoot)
+        .signedBy(serverRoot)
         .build();
     HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediate)
+        .signedBy(serverIntermediate)
         .build();
 
     HandshakeCertificates server = new HandshakeCertificates.Builder()
@@ -108,10 +112,10 @@ public final class HandshakeCertificatesTest {
         .build();
     HeldCertificate intermediate = new HeldCertificate.Builder()
         .certificateAuthority(0)
-        .issuedBy(root)
+        .signedBy(root)
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediate)
+        .signedBy(intermediate)
         .build();
 
     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
@@ -123,6 +127,20 @@ public final class HandshakeCertificatesTest {
         Arrays.asList(handshakeCertificates.keyManager().getCertificateChain(""private"")));
   }
 
+  @Test public void platformTrustedCertificates() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addPlatformTrustedCertificates()
+        .build();
+    Set<String> names = new LinkedHashSet<>();
+    for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {
+      // Abbreviate a long name like ""CN=Entrust Root Certification Authority - G2, OU=...""
+      String name = certificate.getSubjectDN().getName();
+      names.add(name.substring(0, name.indexOf("" "")));
+    }
+    // It's safe to assume all platforms will have a major Internet certificate issuer.
+    assertTrue(names.toString(), names.contains(""CN=Entrust""));
+  }
+
   private InetSocketAddress startTlsServer() throws IOException {
     ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
     serverSocket = serverSocketFactory.createServerSocket();
@@ -202,7 +202,7 @@ public final class HeldCertificateTest {
     HeldCertificate leaf = new HeldCertificate.Builder()
         .certificateAuthority(0)
         .ecdsa256()
-        .issuedBy(root)
+        .signedBy(root)
         .build();
 
     assertEquals(""SHA256WITHRSA"", root.certificate().getSigAlgName());
@@ -217,7 +217,7 @@ public final class HeldCertificateTest {
     HeldCertificate leaf = new HeldCertificate.Builder()
         .certificateAuthority(0)
         .rsa2048()
-        .issuedBy(root)
+        .signedBy(root)
         .build();
 
     assertEquals(""SHA256WITHECDSA"", root.certificate().getSigAlgName());
@@ -19,9 +19,7 @@
 import java.net.ProxySelector;
 import java.net.Socket;
 import java.security.GeneralSecurityException;
-import java.security.KeyStore;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
@@ -34,7 +32,6 @@
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
@@ -248,8 +245,8 @@ public OkHttpClient() {
       this.sslSocketFactory = builder.sslSocketFactory;
       this.certificateChainCleaner = builder.certificateChainCleaner;
     } else {
-      X509TrustManager trustManager = systemDefaultTrustManager();
-      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      X509TrustManager trustManager = Util.platformTrustManager();
+      this.sslSocketFactory = newSslSocketFactory(trustManager);
       this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
     }
 
@@ -280,23 +277,7 @@ public OkHttpClient() {
     }
   }
 
-  private X509TrustManager systemDefaultTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException(""Unexpected default trust managers:""
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw assertionError(""No System TLS"", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
     try {
       SSLContext sslContext = Platform.get().getSSLContext();
       sslContext.init(null, new TrustManager[] { trustManager }, null);
@@ -26,6 +26,8 @@
 import java.net.Socket;
 import java.net.UnknownHostException;
 import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -37,6 +39,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.HttpUrl;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -642,4 +647,20 @@ private static String inet6AddressToAscii(byte[] address) {
     }
     return result.readUtf8();
   }
+
+  public static X509TrustManager platformTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException(""Unexpected default trust managers:""
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw assertionError(""No System TLS"", e); // The system has no TLS. Just give up.
+    }
+  }
 }
",True,The commit message refers to a convention regarding the naming of methods. The method 'issuedBy' is replaced with 'signedBy' to better reflect the cryptographic concept. This change is made to align with the terminology used by cryptographers.,True,The commit message explains the necessity of changes by referring to the difference in terminology used by certificates and cryptographers. The method name is changed from 'issuedBy' to 'signedBy' to align with the more common term used in cryptography.,True,"The commit message explains the motivation for the change by stating that 'issued' is the word used by certificates, while 'signed' is the word used by cryptographers. The author prefers 'signed' and thus made the change.",True,"The commit message mentions the need for a new API, HandshakeCertificates.addPlatformTrustedCertificates(), which suggests that the developer is addressing a requirement for more secure connections by including platform-trusted certificates. Additionally, the message mentions the renaming of 'issuedBy()' to 'signedBy()', which could be done to better align the terminology with that used by cryptographers, indicating a potential improvement in code clarity and accuracy.",True,"The commit message mentions the change of the method name from 'issuedBy' to 'signedBy' which directly relates to the improvement made in the code. This change is likely to make the code more accurate and clear, as 'signed' is the term used by cryptographers to describe the process of creating a certificate.",True,"The commit message describes the changes made to the codebase by summarizing the addition of a new API and the renaming of a method. The renaming of the method from 'issuedBy' to 'signedBy' is explicitly mentioned, contrasting the before and after. This allows for a clear understanding of the changes made to the codebase.",True,The commit message explains that the method 'issuedBy' is being renamed to 'signedBy' because the term 'signed' is more commonly used in cryptography to describe the process of a certificate being issued by a certificate authority.,True,"The commit message describes the changes made to the codebase. It mentions the addition of a new API, HandshakeCertificates.addPlatformTrustedCertificates(), which is a function that adds all of the host platform's trusted root certificates to the set of trusted certificates. This is a significant change that introduces new behavior to the codebase. Additionally, the message mentions a renaming of HeldCertificate.Builder.issuedBy() to signedBy(), which is a functional change that affects the code's behavior. The renaming is explained as a preference for the term 'signed' over 'issued' by cryptographers.",False,"The commit message does not lack an explanation. While the change is simple and could be inferred, the author explicitly explains the reason for the change: 'Issued' is the word used by certificates, but 'signed' is the word used by cryptographers. The author prefers 'signed'."
https://github.com/spring-projects/spring-boot/commit/4d172ca7429bfc15692ce7f1247beeb355faa924,"Remove duplicate resources from classpath  <enter> We had been making a special case for logback.xml anyway, so extending that to simply deleting recursively all of src/main/resources (or equivalent) from target/classes (or equivalent) seems like it's perfectly justifiable. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/4d172ca7429bfc15692ce7f1247beeb355faa924,"@@ -52,8 +52,7 @@ public void runApp() {
 			SourceDirectorySet resources = main.getResources();
 			allResources.addAll(resources.getSrcDirs());
 			outputs = main.getOutput().getResourcesDir();
-		}
-		else {
+		} else {
 			outputs = null;
 		}
 
@@ -80,11 +79,16 @@ public String call() throws Exception {
 					getLogger().info(""Found main: "" + mainClass);
 				}
 				if (outputs != null) {
-					// Special case: this file causes logback to worry that it has been
-					// configured twice, so remove it from the target directory...
-					File logback = new File(outputs, ""logback.xml"");
-					if (logback.exists()) {
-						logback.delete();
+					// remove duplicates from resources and build
+					for (File directory : allResources) {
+						if (directory.isDirectory()) {
+							for (String name : directory.list()) {
+								File file = new File(outputs, name);
+								if (file.exists() && file.canWrite()) {
+									getProject().delete(file);
+								}
+							}
+						}
 					}
 				}
 				exec.exec();
@@ -100,8 +104,7 @@ private String findMainClass(SourceSet main) {
 		getLogger().info(""Looking for main in: "" + main.getOutput().getClassesDir());
 		try {
 			return MainClassFinder.findMainClass(main.getOutput().getClassesDir());
-		}
-		catch (IOException ex) {
+		} catch (IOException ex) {
 			throw new IllegalStateException(""Cannot find main class"", ex);
 		}
 	}
@@ -37,6 +37,7 @@
 import org.apache.maven.plugins.annotations.Parameter;
 import org.apache.maven.plugins.annotations.ResolutionScope;
 import org.apache.maven.project.MavenProject;
+import org.codehaus.plexus.util.FileUtils;
 import org.springframework.boot.loader.tools.AgentAttacher;
 import org.springframework.boot.loader.tools.MainClassFinder;
 
@@ -62,10 +63,7 @@ public class RunMojo extends AbstractMojo {
 
 	/**
 	 * Add maven resources to the classpath directly, this allows live in-place editing or
-	 * resources. Since resources will be added directly, and via the target/classes
-	 * folder they will appear twice if ClassLoader.getResources() is called. In practice
-	 * however most applications call ClassLoader.getResource() which will always return
-	 * the first resource.
+	 * resources.
 	 */
 	@Parameter(property = ""run.addResources"", defaultValue = ""true"")
 	private boolean addResources;
@@ -185,6 +183,9 @@ private URL[] getClassPathUrls() throws MojoExecutionException {
 		catch (MalformedURLException ex) {
 			throw new MojoExecutionException(""Unable to build classpath"", ex);
 		}
+		catch (IOException ex) {
+			throw new MojoExecutionException(""Unable to build classpath"", ex);
+		}
 	}
 
 	private void addUserDefinedFolders(List<URL> urls) throws MalformedURLException {
@@ -195,16 +196,25 @@ private void addUserDefinedFolders(List<URL> urls) throws MalformedURLException
 		}
 	}
 
-	private void addResources(List<URL> urls) throws MalformedURLException {
+	private void addResources(List<URL> urls) throws MalformedURLException, IOException {
 		if (this.addResources) {
 			for (Resource resource : this.project.getResources()) {
-				urls.add(new File(resource.getDirectory()).toURI().toURL());
-			}
-			// Special case: this file causes logback to worry that it has been configured
-			// twice, so remove it from the target directory...
-			File logback = new File(this.classesDirectory, ""logback.xml"");
-			if (logback.exists() && logback.canWrite()) {
-				logback.delete();
+				File directory = new File(resource.getDirectory());
+				urls.add(directory.toURI().toURL());
+				if (directory.isDirectory()) {
+					// Remove duplicates from the target directory...
+					for (String name : directory.list()) {
+						File file = new File(this.classesDirectory, name);
+						if (file.exists() && file.canWrite()) {
+							if (file.isDirectory()) {
+								FileUtils.deleteDirectory(file);
+							}
+							else {
+								file.delete();
+							}
+						}
+					}
+				}
 			}
 		}
 	}
",True,"The commit message explains the necessity of changes by referencing a convention. The commit message mentions that there was a special case for 'logback.xml' which caused it to be removed from the target directory. Now, the commit extends this special case to delete recursively all of 'src/main/resources' (or equivalent) from 'target/classes' (or equivalent). This is justified as it will prevent duplicate resources from being added to the classpath, which could cause issues.",True,The commit message 'Remove duplicate resources from classpath' clearly explains the necessity of the changes. The code diff shows that the commit is removing duplicate resources from the classpath to prevent any confusion or errors that might arise from having the same resources appearing twice. This is a common issue and the commit message provides a clear explanation of the problem and the solution.,True,"The commit message explains the motivation for the code change by mentioning that there was a special case for logback.xml that caused issues. It also mentions that extending this to delete all resources from the classpath is justifiable. Additionally, the code diff shows that the commit removes the special case for logback.xml and instead deletes all resources from the classpath to prevent duplicates.",True,"The commit message 'Remove duplicate resources from classpath' indicates that the developer made changes to address a problem in the software maintenance process. The problem is the presence of duplicate resources in the classpath, which can cause issues with the application's behavior. The code diff supports this explanation by showing that the developer removed special handling for 'logback.xml' and instead implemented a more general solution to delete duplicate resources from the target directory.",True,"The commit message directly mentions the objective of the change by stating that it removes duplicate resources from the classpath. This is a clear reference to the improvement made to the code, which is to ensure that resources are not duplicated in the classpath, thereby potentially causing issues with resource loading.",True,"The commit message 'Remove duplicate resources from classpath' accurately summarizes the changes made in the code diff. The diff shows that the code has been modified to remove duplicate resources from the classpath, which is a key component of the change. The message also contrasts the before and after situation by mentioning the removal of duplicate resources.",True,The commit message explains that the changes are made to remove duplicate resources from the classpath. This is done by deleting all resources from the source directory (src/main/resources or equivalent) from the target directory (target/classes or equivalent). This is based on the principle of ensuring that resources are not duplicated in the classpath to avoid confusion and potential issues.,True,"The commit message 'Remove duplicate resources from classpath' accurately describes the functional change made in the code. The code changes involve removing duplicate resources from the classpath, which is a clear and concise summary of the changes. The message also explains that this change is made to avoid a special case for 'logback.xml' and extends it to deleting recursively all of 'src/main/resources' from 'target/classes'. This explains the new behavior introduced by the changes, which is to ensure that there are no duplicate resources in the classpath.",False,"The commit message does not explicitly explain the reason for removing duplicate resources from the classpath. While the code diff makes it clear that this is being done to avoid logback configuration issues, the commit message could have been more explicit about this."
https://github.com/spring-projects/spring-boot/commit/b39ecdf0060189367e396f0dcc455760006f2659,Rename preferred-mapper property so its clear it only applies to JSON  <enter> preferred-mapper has been renamed to preferred-json-mapper to make it clear that it only affects the JSON mapper and that the XML mapper that will be used (if any) is unaffected <enter> See  <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/b39ecdf0060189367e396f0dcc455760006f2659,"@@ -52,7 +52,7 @@
 		GsonHttpMessageConvertersConfiguration.class })
 public class HttpMessageConvertersAutoConfiguration {
 
-	static final String PREFERRED_MAPPER_PROPERTY = ""spring.http.converters.preferred-mapper"";
+	static final String PREFERRED_MAPPER_PROPERTY = ""spring.http.converters.preferred-json-mapper"";
 
 	@Autowired(required = false)
 	private final List<HttpMessageConverter<?>> converters = Collections.emptyList();
@@ -148,7 +148,7 @@ public void gsonCanBePreferredWhenBothGsonAndJacksonAreAvailable() {
 				JacksonAutoConfiguration.class,
 				HttpMessageConvertersAutoConfiguration.class);
 		EnvironmentTestUtils.addEnvironment(this.context,
-				""spring.http.converters.preferred-mapper:gson"");
+				""spring.http.converters.preferred-json-mapper:gson"");
 		this.context.refresh();
 		assertConverterBeanExists(GsonHttpMessageConverter.class,
 				""gsonHttpMessageConverter"");
",True,The commit message refers to a convention regarding the naming of properties. It explains that 'preferred-mapper' has been renamed to 'preferred-json-mapper' to make it clear that it only affects the JSON mapper. This is done to avoid confusion as there might be an XML mapper used as well. The code diff also supports this explanation by showing the exact change in the property name.,True,"The commit message clearly states that the change is made to 'preferred-mapper' property to 'preferred-json-mapper' to make it clear that it only affects the JSON mapper and not the XML mapper. This is done to avoid any confusion or misinterpretation about the scope of the change. The code diff also supports this explanation by showing the exact line where the property name is changed. Therefore, the commit message does not need to provide a rationale as it is easy to infer the necessity of the change from the message and the code diff.",True,"The commit message directly elaborates the motivation of the code change by explaining that the 'preferred-mapper' property is being renamed to 'preferred-json-mapper' to make it clear that it only affects the JSON mapper. This is done to avoid confusion as the previous name could imply that it affects all mappers, not just the JSON one. The message also mentions the issue report for further context.",True,"The commit message indicates that the change was made to clarify the property name, making it clear that it only applies to JSON. This suggests that the change was made to address a user requirement or a problem in the software maintenance process, specifically to avoid confusion about the scope of the property.",True,"The commit message directly mentions the change made to the code, which is the renaming of the 'preferred-mapper' property to 'preferred-json-mapper'. This change is made to clarify that the property only applies to the JSON mapper, not the XML mapper. This explicitly describes the improvement made to the code, which is to make the configuration more clear and specific.",True,"The commit message accurately summarizes the change by explicitly stating that the 'preferred-mapper' property has been renamed to 'preferred-json-mapper' to clarify that it only affects the JSON mapper. This is also supported by the code diff, which shows the exact line where this renaming has occurred.",True,"The commit message explains that the 'preferred-mapper' property has been renamed to 'preferred-json-mapper' to clarify that it only affects the JSON mapper. This implies that the changes are made to ensure the separation of concerns principle, which is a technical principle that each module, class, or function should have responsibility over a single part of the functionality provided by the software, and that it should encapsulate that part.",True,"The commit message accurately summarizes the code changes by explaining that the 'preferred-mapper' property has been renamed to 'preferred-json-mapper' to clarify that it only applies to JSON. This is further supported by the code diff, which shows the exact change in the variable name. Additionally, the commit message mentions that the change only affects the JSON mapper, leaving the XML mapper unaffected, which is also reflected in the code diff.",False,"The commit message does not just rename a variable or property, it also explains the reason for the change. The message clarifies that the renamed property only applies to JSON, which is not immediately obvious from the code diff. Therefore, the commit message does not lack an explanation."
https://github.com/square/retrofit/commit/ebc0128add0d416a846ff661888910d16751dd34,Clean out Java 8 READMEs to further discourage use ,https://api.github.com/repos/square/retrofit/commits/ebc0128add0d416a846ff661888910d16751dd34,"@@ -1,54 +1,10 @@
-Java8 Adapter
-==============
+Java 8 Adapter (Deprecated)
+===========================
 
-An `Adapter` for adapting [Java8][1] `CompletableFuture`.
-
-
-Deprecated – Included by default in Retrofit
----------------------------------------
-
-
-Usage
------
-
-Add `Java8CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
-```java
-Retrofit retrofit = new Retrofit.Builder()
-    .baseUrl(""https://example.com/"")
-    .addCallAdapterFactory(Java8CallAdapterFactory.create())
-    .build();
-```
-
-Your service methods can now use `CompletableFuture` as their return type.
-```java
-interface MyService {
-  @GET(""/user"")
-  CompletableFuture<User> getUser();
-}
-```
-
-
-Download
---------
-
-Download [the latest JAR][2] or grab via [Maven][3]:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>adapter-java8</artifactId>
-  <version>latest.version</version>
-</dependency>
-```
-or [Gradle][3]:
-```groovy
-implementation 'com.squareup.retrofit2:adapter-java8:latest.version'
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+A call adapter [Java 8's `CompletableFuture`][1].
 
+This adapter is no longer needed. Support for `CompletableFuture` is built-in to Retrofit and now
+works without configuration.
 
 
  [1]: http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html
- [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-java8&v=LATEST
- [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-java8%22
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
@@ -1,34 +1,8 @@
-Java 8 Converter
-================
+Java 8 Converter (Deprecated)
+=============================
 
 A `Converter` which supports Java 8's `Optional<T>` by delegating to other converters for `T`
 and then wrapping it into `Optional`.
 
-
-Deprecated – Included by default in Retrofit
----------------------------------------
-
-
-Download
---------
-
-Download [the latest JAR][1] or grab via [Maven][2]:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>converter-java8</artifactId>
-  <version>latest.version</version>
-</dependency>
-```
-or [Gradle][2]:
-```groovy
-implementation 'com.squareup.retrofit2:converter-java8:latest.version'
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
-
-
-
- [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-java8&v=LATEST
- [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-java8%22
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+This converter is no longer needed. Support for `Optional` is built-in to Retrofit and now works
+without configuration.
",True,"The commit message refers to the deprecation of Java 8 features in Retrofit, explaining that the changes are made to further discourage the use of these features as they are now included by default in Retrofit.",True,"The commit message 'Clean out Java 8 READMEs to further discourage use' clearly explains the necessity of changes. The changes are made to deprecate the use of Java 8 Adapter and Converter in Retrofit, as these are now included by default and no longer needed. This is a common practice in software development to simplify the codebase and improve usability.",True,The commit message explains the motivation for the changes by mentioning that the Java 8 Adapter and Converter are no longer needed because support for CompletableFuture and Optional is built-in to Retrofit and now works without configuration.,True,"The commit message 'Clean out Java 8 READMEs to further discourage use' and the code diff indicate that the changes are made due to the need to deprecate the use of Java 8 features in the project. This is likely due to the changes in the Java ecosystem or the built-in support for these features in Retrofit, which makes the Java 8 adapter and converter no longer necessary.",True,The commit message 'Clean out Java 8 READMEs to further discourage use' directly mentions the change that is made to the code. It states that the Java 8 Adapter and Converter are no longer needed as their functionalities are now built-in to Retrofit. This implies that the change is made to improve the code and make it simpler to use.,True,"The commit message 'Clean out Java 8 READMEs to further discourage use' accurately summarizes the changes made in the diff. It highlights the deprecation of the Java 8 Adapter and Converter, which are no longer needed due to built-in support in Retrofit. This is a clear and concise summary of the changes, pointing out the key components of the change and contrasting the before and after situation.",True,"The commit message explains that the changes are being made to discourage the use of Java 8 features in Retrofit, as these features are now built-in and do not require additional configuration. This highlights the technical principle of simplification and reduction of unnecessary complexity.",True,"The commit message expresses that certain features related to Java 8 are being deprecated and removed. It specifically mentions the Java 8 Adapter and Converter, which were used for adapting Java 8's CompletableFuture and Optional<T>. The message clearly states that these features are no longer needed as support for CompletableFuture and Optional is now built-in to Retrofit, eliminating the need for external configuration.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Clean out Java 8 READMEs to further discourage use'. This is because the Java 8 features are now included by default in Retrofit, making the Java 8 adapter and converter obsolete."
https://github.com/spring-projects/spring-boot/commit/f8a53cf775b03c9258b42be194e05e0ee1779f35,Update actuator security documentation  <enter> Update documentation to align with the new role based method. <enter> See  <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/f8a53cf775b03c9258b42be194e05e0ee1779f35,"@@ -536,11 +536,32 @@ all enabled endpoints to be exposed over HTTP. The default convention is to use
 
 
 [[production-ready-sensitive-endpoints]]
-=== Securing sensitive endpoints
-If you add '`Spring Security`' to your project, all sensitive endpoints exposed over HTTP
-will be protected. By default '`basic`' authentication will be used with the username
-`user` and a generated password (which is printed on the console when the application
-starts).
+=== Accessing sensitive endpoints
+By default all sensitive HTTP endpoints are secured such that only users that have an
+`ACTUATOR` role may access them. Security is enforced using the standard
+`HttpServletRequest.isUserInRole` method.
+
+TIP: Use the `management.security.roles` property if you want something different to
+`ACTUATOR`.
+
+If you are deploying applications behind a firewall, you may prefer that all your actuator
+endpoints can be accessed without requiring authentication. You can do this by changing
+the `management.security.enabled` property:
+
+.application.properties
+[source,properties,indent=0]
+----
+	management.security.enabled=false
+----
+
+NOTE: By default, actuator endpoints are exposed on the same port that serves regular
+HTTP traffic. Take care not to accidentally expose sensitive information if you change
+the `management.security.enabled` property.
+
+If you're deploying applications publicly, you may want to add '`Spring Security`' to
+handle user authentication. When '`Spring Security`' is added, by default '`basic`'
+authentication will be used with the username `user` and a generated password (which is
+printed on the console when the application starts).
 
 TIP: Generated passwords are logged as the application starts. Search for '`Using default
 security password`'.
@@ -556,10 +577,6 @@ in your `application.properties`:
 	management.security.roles=SUPERUSER
 ----
 
-TIP: If you don't use Spring Security and your HTTP endpoints are exposed publicly,
-you should carefully consider which endpoints you enable. See
-<<production-ready-customizing-endpoints>> for details of how you can set
-`endpoints.enabled` to `false` then ""`opt-in`"" only specific endpoints.
 
 
 [[production-ready-customizing-management-server-context-path]]
",True,"The commit message refers to the new role-based method for securing sensitive endpoints, which is different from the previous convention of using 'Spring Security' with basic authentication. This change is likely necessary to align with updated security standards or improvements in prior commits.",True,"The commit message 'Update actuator security documentation' does not explicitly state the necessity of the changes, but it is easy to infer from the code diff that the documentation is being updated to align with the new role-based method. This is a common practice in software development to ensure that the documentation accurately reflects the current state of the codebase. Therefore, the commit message does not require a rationale beyond the standard practice of updating documentation to match code changes.",True,"The commit message 'Update actuator security documentation' does describe the necessity of changes by elaborating the motivation of a code change. It mentions that the documentation is being updated to align with the new role-based method, which is likely a change made in the codebase. This implies that the previous implementation had a different method of securing sensitive endpoints, and the new implementation requires updating the documentation to reflect this change.",True,"The commit message 'Update actuator security documentation' and the code diff indicate that the changes were made to align the documentation with the new role-based method. This suggests that the changes were made due to a requirement or problem, specifically the need to update the documentation to reflect a change in the security method used by the actuator.",True,"The commit message 'Update actuator security documentation' directly mentions the change made to the documentation, which is to align it with the new role-based method. This indicates that the change is likely an improvement to the code, as it updates the documentation to reflect a new feature or method in the codebase.",True,"The commit message 'Update actuator security documentation' accurately summarizes the key components of the change, which is the update of the documentation to align with the new role-based method. The diff shows that the section 'Securing sensitive endpoints' has been renamed to 'Accessing sensitive endpoints' and the content has been significantly updated to reflect the new role-based security method. Additionally, new sections have been added to discuss the management.security.enabled property and the use of Spring Security for user authentication. Therefore, the commit message effectively describes the changes made in the code diff.",True,"The commit message explains that the documentation has been updated to align with the new role-based method for securing sensitive endpoints. The code diff shows that the default role for accessing sensitive endpoints has been changed from 'user' to 'ACTUATOR'. This change is based on the technical principle of role-based access control, which is a common method for securing resources in a system.",True,"The commit message 'Update actuator security documentation' accurately describes the changes made in the code diff. The changes involve updating the documentation to align with the new role-based method for securing sensitive endpoints. The new documentation explains that by default, all sensitive HTTP endpoints are secured such that only users that have an 'ACTUATOR' role may access them. This is a new behavior introduced by the changes, as the previous documentation mentioned using 'Spring Security' with a default username and password for authentication.",False,"The commit message does not lack an explanation. It explicitly mentions the reason for the commit as 'Update documentation to align with the new role based method'. The code diff also supports this explanation by showing changes in the documentation related to securing sensitive endpoints, including the introduction of a new role-based method and the removal of a reference to Spring Security's default username and password."
https://github.com/junit-team/junit4/commit/fa35d6d84a0b2c59254cb479633d0e20bc6e12e9,"Delete .cvsignore files, because we're using Git now. ",https://api.github.com/repos/junit-team/junit4/commits/fa35d6d84a0b2c59254cb479633d0e20bc6e12e9,"@@ -1,10 +0,0 @@
-bin
-junit4.1
-junit*-SNAPSHOT-*
-target
-reports
-buildfile
-java.hprof.txt
-junit4.5-RC1
-junit4.*
-*.ser
@@ -1,4 +0,0 @@
-Changes
-java.hprof.txt
-historical_javadoc
-compare_with_44.sh
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that the .cvsignore files are being deleted because the project has switched from CVS to Git.",True,"The commit message 'Delete .cvsignore files, because we're using Git now.' clearly explains the necessity of the changes. It's common sense that when switching from CVS to Git, the .cvsignore files are no longer needed. The diff also supports this explanation, showing the deletion of these files.",False,"The commit message does not explicitly describe the necessity of changes. It only states that the .cvsignore files are being deleted because the project has switched to using Git. However, it does not elaborate on any errors, issues, or shortcomings that the previous version control system (CVS) may have caused.",True,"The commit message 'Delete .cvsignore files, because we're using Git now.' indicates that the developer is making changes due to a process change in the software development environment. The use of CVS is being replaced with Git, which is a common requirement in modern software development practices.",True,"The commit message directly mentions the change, which is deleting .cvsignore files because the project has switched to using Git. This change improves the code by simplifying the version control process and making it more compatible with the new system.",True,"The commit message 'Delete .cvsignore files, because we're using Git now.' accurately summarizes the changes made in the diff. It clearly states that the .cvsignore files are being deleted due to the switch from CVS to Git. The diff also supports this by showing the deletion of these files.",False,The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that the .cvsignore files are being deleted because the project has switched from using CVS to Git. There is no mention of any underlying technical principle or concept that the changes are based on.,True,"The commit message 'Delete .cvsignore files, because we're using Git now.' accurately summarizes the changes made in the code diff. The code diff shows the removal of several files and directories that were previously used in a CVS version control system. The commit message correctly explains that these files are no longer needed because the project has switched to using Git for version control. This change does not introduce any new behaviors or functionalities, but it does remove unnecessary files, which can be considered a change in the project's structure and configuration.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit, which is that the project has switched from using CVS to Git, and as a result, the .cvsignore files are no longer needed."
https://github.com/spring-projects/spring-boot/commit/ee4205a0498440f3003ace8c5ccf36cbe74eab00,Remove unnecessary logging by start-docker script ,https://api.github.com/repos/spring-projects/spring-boot/commits/ee4205a0498440f3003ace8c5ccf36cbe74eab00,"@@ -10,7 +10,7 @@ caches:
 run:
   path: bash
   args:
-    - -exc
+    - -ec
     - |
       source /docker-lib.sh
       start_docker
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the removal of unnecessary logging. It simply states the change that was made without providing a reason for the change.",True,"The commit message 'Remove unnecessary logging by start-docker script' clearly explains the reason for the changes made in the code diff. The message states that the logging in the start-docker script is unnecessary, which is a common reason for removing logging statements. This explanation is sufficient without providing a detailed rationale, as it is easy to infer that unnecessary logging can cause performance issues and clutter the logs.",False,"The commit message does not explicitly describe the necessity of changes. It only states that unnecessary logging is being removed by the start-docker script. However, the code diff does not provide any context about why this logging was considered unnecessary or what potential problems it could have caused. Therefore, the commit message does not directly elaborate the motivation of the code change.",True,"The commit message 'Remove unnecessary logging by start-docker script' indicates that the changes were made to improve the efficiency and performance of the software. The removal of unnecessary logging can potentially reduce the amount of data written to logs, which can save disk space and improve the overall performance of the software. This can be considered as a requirement to improve the software maintenance process, as outdated or unnecessary code can lead to inefficiencies and performance issues.",False,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only states that the change is to remove unnecessary logging by the start-docker script. While this can be interpreted as an improvement, it does not explicitly state the defect or issue that the logging was causing.",True,"The commit message 'Remove unnecessary logging by start-docker script' accurately summarizes the change in the diff. It clearly states that the change is to remove unnecessary logging from the start-docker script. The diff also supports this by showing a modification in the arguments passed to the bash command, specifically changing '-exc' to '-ec'. This change likely disables the logging feature in the script.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions the removal of unnecessary logging, which is more about code cleanliness and performance optimization rather than a fundamental technical principle.",False,"The commit message only mentions the removal of unnecessary logging, but it does not describe the functional changes or new behaviors introduced by the code changes.",True,"The commit message clearly states that the change was made to remove unnecessary logging by the start-docker script. The code diff also supports this explanation, as it shows a simple removal of the '-xc' argument from the 'bash' command, which is likely used for enabling verbose logging. Therefore, there was no need for an additional explanation of the change."
https://github.com/apache/dubbo/commit/9897aa3d7273e3eb96910cfdc09709a77cae50b0,"remove appConfigs cache to support one service/reference registered more than one time (if users don't explicitly add id, cache can not work properly) ",https://api.github.com/repos/apache/dubbo/commits/9897aa3d7273e3eb96910cfdc09709a77cae50b0,"@@ -35,7 +35,6 @@ public class Environment {
     private Map<String, EnvironmentConfiguration> environmentConfigs = new ConcurrentHashMap<>();
     private Map<String, InmemoryConfiguration> externalConfigs = new ConcurrentHashMap<>();
     private Map<String, InmemoryConfiguration> appExternalConfigs = new ConcurrentHashMap<>();
-    private Map<String, InmemoryConfiguration> appConfigs = new ConcurrentHashMap<>();
 
     private Map<String, String> externalConfigurationMap = new HashMap<>();
     private Map<String, String> appExternalConfigurationMap = new HashMap<>();
@@ -79,10 +78,6 @@ public EnvironmentConfiguration getEnvironmentConfig(String prefix, String id) {
         return environmentConfigs.computeIfAbsent(toKey(prefix, id), k -> new EnvironmentConfiguration(prefix, id));
     }
 
-    public InmemoryConfiguration getAppConfig(String prefix, String id) {
-        return appConfigs.get(toKey(prefix, id));
-    }
-
     public void setExternalConfigMap(Map<String, String> externalConfiguration) {
         this.externalConfigurationMap = externalConfiguration;
     }
@@ -99,14 +94,6 @@ public Map<String, String> getAppExternalConfigurationMap() {
         return appExternalConfigurationMap;
     }
 
-    public void addAppConfig(String prefix, String id, Map<String, String> properties) {
-        appConfigs.computeIfAbsent(toKey(prefix, id), k -> {
-            InmemoryConfiguration configuration = new InmemoryConfiguration(prefix, id);
-            configuration.addProperties(properties);
-            return configuration;
-        });
-    }
-
     public void updateExternalConfigurationMap(Map<String, String> externalMap) {
         this.externalConfigurationMap.putAll(externalMap);
     }
@@ -124,27 +111,13 @@ public void updateAppExternalConfigurationMap(Map<String, String> externalMap) {
      * @param id
      * @return
      */
-    public Configuration getConfiguration(String prefix, String id) {
+    public CompositeConfiguration getConfiguration(String prefix, String id) {
         CompositeConfiguration compositeConfiguration = new CompositeConfiguration();
-        InmemoryConfiguration appConfig = this.getAppConfig(prefix, id);
         // Config center has the highest priority
-        if (!configCenterFirst) {
-            compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));
-            if (appConfig != null) {
-                compositeConfiguration.addConfiguration(appConfig);
-            }
-            compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));
-            compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));
-            compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));
-        } else {
-            compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));
-            compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));
-            compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));
-            if (appConfig != null) {
-                compositeConfiguration.addConfiguration(appConfig);
-            }
-            compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));
-        }
+        compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));
+        compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));
+        compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));
+        compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));
         return compositeConfiguration;
     }
 
@@ -18,8 +18,9 @@
 
 import org.apache.dubbo.common.Constants;
 import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.config.Configuration;
+import org.apache.dubbo.common.config.CompositeConfiguration;
 import org.apache.dubbo.common.config.Environment;
+import org.apache.dubbo.common.config.InmemoryConfiguration;
 import org.apache.dubbo.common.extension.ExtensionLoader;
 import org.apache.dubbo.common.logger.Logger;
 import org.apache.dubbo.common.logger.LoggerFactory;
@@ -536,9 +537,16 @@ public void setPrefix(String prefix) {
      */
     public void refresh() {
         try {
-            Environment env = Environment.getInstance();
-            env.addAppConfig(getPrefix(), getId(), getMetaData());
-            Configuration configuration = env.getConfiguration(getPrefix(), getId());
+            CompositeConfiguration compositeConfiguration = Environment.getInstance().getConfiguration(getPrefix(), getId());
+            InmemoryConfiguration configuration = new InmemoryConfiguration(getPrefix(), getId());
+            configuration.addProperties(getMetaData());
+            if (Environment.getInstance().isConfigCenterFirst()) {
+                // The sequence would be: SystemConfiguration -> ExternalConfiguration -> AppExternalConfiguration -> AbstractConfig -> PropertiesConfiguration
+                compositeConfiguration.addConfiguration(3,configuration);
+            } else {
+                // The sequence would be: SystemConfiguration -> AbstractConfig -> ExternalConfiguration -> AppExternalConfiguration -> PropertiesConfiguration
+                compositeConfiguration.addConfiguration(1, configuration);
+            }
 
             // loop methods, get override value and set the new value back to method
             Method[] methods = getClass().getMethods();
",True,"The commit message refers to the necessity of changes by mentioning that the appConfigs cache is being removed to support one service/reference registered more than one time. This is because if users don't explicitly add an id, the cache can't work properly. This is a clear reference to a problem in prior commits and the need for a change to fix it.",True,"The commit message clearly explains the necessity of the changes by stating that the appConfigs cache needs to be removed to support one service/reference registered more than one time. This is because if users don't explicitly add an id, the cache can't work properly. This is a valid reason for the removal of the appConfigs cache, as it ensures the correct functioning of the system.",True,The commit message directly elaborates the motivation of the code change by mentioning the issue that arises when the cache can't work properly due to users not explicitly adding an id. This clearly indicates the necessity of the changes made in the code diff.,True,"The commit message 'remove appConfigs cache to support one service/reference registered more than one time (if users don't explicitly add id, cache can not work properly)' indicates that the change was made to address a problem in the software maintenance process. The problem is that the appConfigs cache was not functioning properly when a service/reference was registered more than once without an explicit id. This issue could have been caused by outdated code or changes in the runtime or development environment.",True,"The commit message directly mentions the issue it fixes, which is the problem with the appConfigs cache not working properly when users don't explicitly add an id. This is a clear indication of the objective of the change, which is to improve the functionality of the code.",True,"The commit message 'remove appConfigs cache to support one service/reference registered more than one time' accurately summarizes the key change, which is the removal of the appConfigs cache. This change is reflected in the diff by removing the lines of code that declare and use the appConfigs map. The commit message also explains the reason for the change, which is to support multiple registrations of a service/reference without explicitly adding an id, as the cache could not work properly in that scenario.",True,"The commit message explains that the removal of the appConfigs cache is necessary to support the scenario where one service/reference is registered more than once. This is because the cache can't work properly if users don't explicitly add an id. This highlights the importance of unique identification in a caching system, which is a fundamental principle in computer science.",True,"The commit message expresses a change in the codebase that removes the 'appConfigs' cache. This is done to support a scenario where one service/reference is registered more than once. The message explains that if users don't explicitly add an id, the cache can't work properly. This change introduces new behavior where the 'getConfiguration' method now only uses other configurations (SystemConfig, AppExternalConfig, ExternalConfig, PropertiesConfig) instead of the removed AppConfig.",False,"The commit message explains the reason for the change, which is to support one service/reference registered more than one time. This is not something that can be easily inferred from the code diff, as the removal of the appConfigs cache affects the functionality of the system."
https://github.com/junit-team/junit4/commit/2b6fa701e84625c511b03079296774cc0904ef1a,"Bug: ParentRunner lost test Class from a separate class loader ( <pr_link> )  <enter> * Bug: ParentRunner lost test Class from a separate class loader <enter> When junit.jar located in one ClassLoader but runing tests in another ParentRunner can lost information about run class. For example if use @ClassRule and request test class(org.junit.runner.Description#getTestClass) we can get null, because ParentRunner instead of set Class as is to Description tranform it to class name string, as result org.junit.runner.Description#getTestClass execute Class.forName and can't find test class. <enter> Spring-test fail with exception if we try use SpringClassRule <enter> ``` java.lang.NullPointerException  at org.springframework.test.context.junit4.rules.SpringClassRule.validateSpringMethodRuleConfiguration(SpringClassRule.java:186)  at org.springframework.test.context.junit4.rules.SpringClassRule.apply(SpringClassRule.java:134)  at org.junit.rules.RunRules.applyAll(RunRules.java:26)  at org.junit.rules.RunRules.<init>(RunRules.java:15)  at org.junit.runners.ParentRunner.withClassRules(ParentRunner.java:245)  at org.junit.runners.ParentRunner.classBlock(ParentRunner.java:194)  at org.junit.runners.ParentRunner.run(ParentRunner.java:362)  at org.junit.runner.JUnitCore.run(JUnitCore.java:137) ``` <enter> As solution, now ParentRunner create Descriptor with explicit specify Class, name and uses annotations. <enter> * Restore backward compatibility with sub class of ParentRunner that override getName method * Add ParentRunnerClassLoaderTest to AllClassesTests suite ",https://api.github.com/repos/junit-team/junit4/commits/2b6fa701e84625c511b03079296774cc0904ef1a,"@@ -124,6 +124,17 @@ public static Description createSuiteDescription(Class<?> testClass) {
         return new Description(testClass, testClass.getName(), testClass.getAnnotations());
     }
 
+    /**
+     * Create a <code>Description</code> named after <code>testClass</code>
+     *
+     * @param testClass A not null {@link Class} containing tests
+     * @param annotations meta-data about the test, for downstream interpreters
+     * @return a <code>Description</code> of <code>testClass</code>
+     */
+    public static Description createSuiteDescription(Class<?> testClass, Annotation... annotations) {
+        return new Description(testClass, testClass.getName(), annotations);
+    }
+
     /**
      * Describes a Runner which runs no tests
      */
@@ -347,8 +347,16 @@ protected Annotation[] getRunnerAnnotations() {
 
     @Override
     public Description getDescription() {
-        Description description = Description.createSuiteDescription(getName(),
-                getRunnerAnnotations());
+        Class<?> clazz = getTestClass().getJavaClass();
+        Description description;
+        // if subclass overrides `getName()` then we should use it
+        // to maintain backwards compatibility with JUnit 4.12
+        if (clazz == null || !clazz.getName().equals(getName())) {
+            description = Description.createSuiteDescription(getName(), getRunnerAnnotations());
+        } else {
+            description = Description.createSuiteDescription(clazz, getRunnerAnnotations());
+        }
+
         for (T child : getFilteredChildren()) {
             description.addChild(describeChild(child));
         }
@@ -3,6 +3,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Suite;
 import org.junit.runners.Suite.SuiteClasses;
+import org.junit.tests.running.classes.parent.ParentRunnerClassLoaderTest;
 
 @RunWith(Suite.class)
 @SuiteClasses({
@@ -13,6 +14,7 @@
         ParameterizedTestTest.class,
         ParentRunnerFilteringTest.class,
         ParentRunnerTest.class,
+        ParentRunnerClassLoaderTest.class,
         RunWithTest.class,
         SuiteTest.class,
         UseSuiteAsASuperclassTest.class
@@ -0,0 +1,96 @@
+package org.junit.tests.running.classes.parent;
+
+
+import org.junit.Test;
+import org.junit.runner.Description;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.BlockJUnit4ClassRunner;
+import org.junit.runners.ParentRunner;
+import org.junit.runners.model.FrameworkMethod;
+import org.junit.runners.model.InitializationError;
+
+import java.lang.reflect.Field;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public class ParentRunnerClassLoaderTest {
+    @Test
+    public void testClassRuleAccessToClassInAnotherClassLoader() throws Exception {
+        Class<?> testClassWithOwnClassLoader = wrapToClassLoader(TestWithClassRule.class);
+
+        runTestWithParentRunner(testClassWithOwnClassLoader);
+
+        Field fieldWithReference = testClassWithOwnClassLoader.getDeclaredField(""applyTestClass"");
+        Class<?> usedClass = (Class<?>) fieldWithReference.get(null);
+
+        assertEquals(""JUnitRunner can be located in own classLoader, so, "" +
+                        ""Class.forName org.junit.runner.Description.getTestClass can not see "" +
+                        ""in current classloader by execute Class.forName"",
+                testClassWithOwnClassLoader, usedClass
+        );
+    }
+
+    @Test
+    public void testDescriptionContainCorrectTestClass() throws Exception {
+        Class<?> testClassWithOwnClassLoader = wrapToClassLoader(TestWithClassRule.class);
+        ParentRunner<?> runner = new BlockJUnit4ClassRunner(testClassWithOwnClassLoader);
+
+        Description description = runner.getDescription();
+        assertEquals(""ParentRunner accept already instantiate Class<?> with tests, if we lost it instance, and will "" +
+                ""use Class.forName we can not find test class again, because tests can be "" +
+                ""located in different ClassLoader"",
+                description.getTestClass(), testClassWithOwnClassLoader
+        );
+    }
+
+    @Test
+    public void testBackwardCompatibilityWithOverrideGetName() throws Exception {
+        final Class<TestWithClassRule> originalTestClass = TestWithClassRule.class;
+        final Class<?> waitClass = ParentRunnerClassLoaderTest.class;
+
+        ParentRunner<FrameworkMethod> subParentRunner = new BlockJUnit4ClassRunner(originalTestClass) {
+            @Override
+            protected String getName() {
+                return waitClass.getName();
+            }
+        };
+
+        Description description = subParentRunner.getDescription();
+        Class<?> result = description.getTestClass();
+
+        assertEquals(""Subclass of ParentRunner can override getName method and specify another test class for run, "" +
+                ""we should  maintain backwards compatibility with JUnit 4.12"",
+                waitClass, result
+        );
+    }
+
+    private void runTestWithParentRunner(Class<?> testClass) throws InitializationError {
+        ParentRunner<?> runner = new BlockJUnit4ClassRunner(testClass);
+        runner.run(new RunNotifier());
+    }
+
+    private Class<?> wrapToClassLoader(Class<?> sourceClass) throws ClassNotFoundException {
+        URL classpath = sourceClass.getProtectionDomain().getCodeSource().getLocation();
+        VisibleClassLoader loader = new VisibleClassLoader(new URL[]{classpath}, this.getClass().getClassLoader());
+        Class<?> testClassWithOwnClassLoader = loader.findClass(sourceClass.getName());
+
+        assert testClassWithOwnClassLoader != sourceClass;
+
+        return testClassWithOwnClassLoader;
+    }
+
+
+    private static class VisibleClassLoader extends URLClassLoader {
+        public VisibleClassLoader(URL[] urls, ClassLoader parent) {
+            super(urls, parent);
+        }
+
+        @Override // just making public
+        public Class<?> findClass(String name) throws ClassNotFoundException {
+            return super.findClass(name);
+        }
+    }
+}
@@ -0,0 +1,42 @@
+package org.junit.tests.running.classes.parent;
+
+import org.junit.Assert;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.lang.reflect.Field;
+
+/**
+ * Test class for validate run tests that was load in own ClassLoader
+ */
+public class TestWithClassRule {
+    public static Class<?> applyTestClass;
+
+    @ClassRule
+    public static TestRule rule = new CustomRule();
+
+    @Test
+    public void testClassRuleExecuted() throws Exception {
+        Assert.assertNotNull(""Description should contain reference to TestClass"", applyTestClass);
+    }
+
+    public static final class CustomRule implements TestRule {
+
+        public Statement apply(final Statement base, final Description description) {
+            return new Statement() {
+                @Override
+                public void evaluate() throws Throwable {
+                    Class<?> testClass = description.getTestClass();
+                    if(testClass != null) {
+                        Field field = testClass.getDeclaredField(""applyTestClass"");
+                        field.set(null, description.getTestClass());
+                    }
+                    base.evaluate();
+                }
+            };
+        }
+    }
+}
",True,"The commit message refers to a bug where the ParentRunner lost the test Class from a separate class loader. This is explained by the code diff, which shows that the ParentRunner is now created with an explicit specify Class, name, and uses annotations. This change is likely to improve the functionality of the ParentRunner when tests are located in a different ClassLoader.",True,"The commit message explains the necessity of changes by describing the bug that was causing the loss of test Class from a separate class loader. This is not a common sense or easy to infer change, as it requires modifying the code to handle the specific situation where the junit.jar is located in one ClassLoader but running tests in another.",True,"The commit message clearly explains the problem scenario: 'When junit.jar located in one ClassLoader but running tests in another ParentRunner can lose information about the run class.' It also mentions the issue report (<pr_link>), the error scenario (NullPointerException), and the shortcoming of the previous implementation ('ParentRunner instead of set Class as is to Description tranform it to class name string'). The solution is also explained, stating that now ParentRunner creates a Descriptor with explicit specify Class, name, and uses annotations.",True,"The commit message describes the problem that the ParentRunner was losing the test Class from a separate class loader. This issue was causing the Spring-test to fail with a NullPointerException. The commit message also mentions that the solution involves creating a Description with an explicit specify Class, name, and using annotations. This indicates that the change was made to address a software maintenance problem, specifically out-of-date code that was causing runtime errors.",True,"The commit message directly mentions the defect it fixes, which is the issue where the ParentRunner lost the test Class from a separate class loader. This caused problems when using @ClassRule and requesting the test class, leading to a NullPointerException. The commit message also explains the solution, which is to create a Description with an explicit specify Class, name, and use annotations.",True,"The commit message does a good job of summarizing the changes. It mentions the bug that was fixed, which is about the ParentRunner losing the test Class from a separate class loader. It then explains how the issue was resolved by creating a Description with an explicit specify Class, name, and using annotations. Additionally, it mentions the addition of a new test class (ParentRunnerClassLoaderTest) to the AllClassesTests suite, which is a key component of the change.",True,"The commit message explains that the issue arises when the junit.jar is located in one ClassLoader but the tests are running in another. This causes the ParentRunner to lose information about the running class, which can lead to null values when trying to retrieve the test class. The solution involves creating a Description with an explicit specify of the Class, name, and annotations to maintain the reference to the test class.",True,"The commit message clearly explains the problem and the solution. It mentions that the ParentRunner was losing the test Class from a separate class loader, which could lead to a NullPointerException when trying to use a SpringClassRule. The solution was to modify the ParentRunner to create a Description with an explicit specify Class, name, and annotations. This change ensures that the test Class is not lost and can be correctly accessed, even if it is located in a different ClassLoader.",False,The commit message does not lack an explanation. It clearly states the issue with the ParentRunner losing the test Class from a separate class loader and the solution that was implemented. The code diff also supports this explanation by showing the changes made to the createSuiteDescription method to ensure that the test Class is explicitly specified.
https://github.com/square/okhttp/commit/0685dfaa7ff71a8f16b1b71f417b08eff13ec55f,Move TLSv1 and TLSv1.1 to COMPATIBLE_TLS.  <enter> We no longer connect to TLSv1.0 or TLSv1.1 servers out-of-the-box; instead it is necessary to enable COMPATIBLE_TLS in the OkHttpClient configuration. <enter> This is in the path to later removing these TLS versions completely; that is scheduled for March 2020 by some browsers. <enter>  <issue_link> ,https://api.github.com/repos/square/okhttp/commits/0685dfaa7ff71a8f16b1b71f417b08eff13ec55f,"@@ -75,7 +75,8 @@ public void nonRetryableSSLHandshakeException() throws Exception {
   public void retryableSSLHandshakeException() throws Exception {
     ConnectionSpecSelector connectionSpecSelector =
         createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    SSLSocket socket = createSocketWithEnabledProtocols(
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
     connectionSpecSelector.configureSecureSocket(socket);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
@@ -85,20 +86,21 @@ public void retryableSSLHandshakeException() throws Exception {
 
   @Test
   public void someFallbacksSupported() throws Exception {
-    ConnectionSpec sslV3 =
-        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-            .tlsVersions(TlsVersion.SSL_3_0)
-            .build();
+    ConnectionSpec sslV3 = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .tlsVersions(TlsVersion.SSL_3_0)
+        .build();
 
     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
 
-    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
+    TlsVersion[] enabledSocketTlsVersions = {
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0
+    };
     SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
 
     // MODERN_TLS is used here.
     connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
     assertTrue(retry);
@@ -107,7 +109,7 @@ public void someFallbacksSupported() throws Exception {
     // COMPATIBLE_TLS is used here.
     socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
     connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
 
     retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
     assertFalse(retry);
@@ -37,6 +37,12 @@
  *
  * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
  * defer all feature selection to the underlying SSL socket.
+ *
+ * <p>The configuration of each spec changes with each OkHttp release. This is annoying: upgrading
+ * your OkHttp library can break connectivity to certain web servers! But it’s a necessary annoyance
+ * because the TLS ecosystem is dynamic and staying up to date is necessary to stay secure. See
+ * <a href=""https://github.com/square/okhttp/wiki/TLS-Configuration-History"">OkHttp's TLS
+ * Configuration History</a> to track these changes.
  */
 public final class ConnectionSpec {
 
@@ -87,24 +93,31 @@ public final class ConnectionSpec {
       CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
   };
 
-  /** A secure TLS connection assuming a modern client platform and server. */
+  /** A secure TLS connection that requires a recent client platform and a recent server. */
   public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
       .cipherSuites(RESTRICTED_CIPHER_SUITES)
       .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
       .supportsTlsExtensions(true)
       .build();
 
-  /** A modern TLS connection with extensions like SNI and ALPN available. */
+  /**
+   * A modern TLS configuration that works on most client platforms and can connect to most servers.
+   * This is OkHttp's default configuration.
+   */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
       .supportsTlsExtensions(true)
       .build();
 
-  /** A backwards-compatible fallback connection for interop with obsolete servers. */
+  /**
+   * A backwards-compatible fallback configuration that works on obsolete client platforms and can
+   * connect to obsolete servers. When possible, prefer to upgrade your client platform or server
+   * rather than using this configuration.
+   */
   public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
 
@@ -328,6 +341,11 @@ public Builder tlsVersions(String... tlsVersions) {
       return this;
     }
 
+    /**
+     * @deprecated since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.
+     *     In a future release setting this to true will be unnecessary and setting it to false will
+     *     have no effect.
+     */
     public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
       if (!tls) throw new IllegalStateException(""no TLS extensions for cleartext connections"");
       this.supportsTlsExtensions = supportsTlsExtensions;
",True,"The commit message refers to the necessity of changes by referencing standards and improvements in prior commits. It mentions that TLSv1.0 and TLSv1.1 servers are no longer connected to out-of-the-box, and it is necessary to enable COMPATIBLE_TLS in the OkHttpClient configuration. This is done to prepare for the later removal of these TLS versions completely, which is scheduled for March 2020 by some browsers. The message also explains that the configuration of each spec changes with each OkHttp release to stay up to date and secure, which is a necessary annoyance but important for security.",True,The commit message explains the necessity of changes by stating that TLSv1.0 and TLSv1.1 are no longer connected to out-of-the-box and it is necessary to enable COMPATIBLE_TLS in the OkHttpClient configuration. This is done to prepare for the later removal of these TLS versions. The message also mentions that this change is in line with some browsers' plan to remove these TLS versions in March 2020. The code diff supports this explanation by modifying the enabled TLS versions in the SSLSocket and ConnectionSpec objects.,True,"The commit message explains the motivation for the change by mentioning that the project no longer connects to TLSv1.0 or TLSv1.1 servers out-of-the-box and that it is necessary to enable COMPATIBLE_TLS in the OkHttpClient configuration. This is done to prepare for the later removal of these TLS versions completely, which is scheduled for March 2020 by some browsers. The message also mentions the issue link, which could provide more context about the change.",True,"The commit message describes the necessity of changes by mentioning that the project no longer connects to TLSv1.0 or TLSv1.1 servers out-of-the-box and that it is necessary to enable COMPATIBLE_TLS in the OkHttpClient configuration. This is due to the scheduled removal of these TLS versions by some browsers in March 2020. Additionally, the code diff shows that the TLS versions enabled for the SSL socket are being updated to include TLSv1.2, which further supports the necessity of the changes.",True,"The commit message directly mentions the objective of the change by stating that it is moving TLSv1 and TLSv1.1 to COMPATIBLE_TLS. This is done to allow connections to TLSv1.0 or TLSv1.1 servers out-of-the-box, but only if COMPATIBLE_TLS is enabled in the OkHttpClient configuration. This change is made to prepare for the later removal of these TLS versions, which is scheduled for March 2020 by some browsers. The code diff also supports this explanation by modifying the enabled TLS versions in various parts of the code.",True,"The commit message accurately summarizes the changes made in the diff. It mentions moving TLSv1 and TLSv1.1 to COMPATIBLE_TLS, which is reflected in the code diff. Additionally, the message explains the reasoning behind the change, which is to prepare for the removal of these TLS versions in the future. This contrasts the before and after state of the TLS versions supported.",True,"The commit message explains that the change is being made to support older TLS versions (TLSv1.0 and TLSv1.1) by moving them to COMPATIBLE_TLS. This is done to maintain compatibility with older servers that still use these versions, while also preparing for their eventual removal in March 2020. This is a technical principle underpinning the changes, as it involves managing the security and compatibility of network protocols.",True,"The commit message describes the changes made to the code in a functional perspective. It explains that the TLS versions 1.0 and 1.1 are being moved from their previous configuration to the COMPATIBLE_TLS configuration. This change is made to prepare for the eventual removal of these TLS versions, which is scheduled for March 2020 by some browsers. The message also mentions that this change may affect the connectivity to certain web servers, but it's necessary for staying secure in the dynamic TLS ecosystem. The code changes reflect this by modifying the enabled TLS versions in various parts of the codebase.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'We no longer connect to TLSv1.0 or TLSv1.1 servers out-of-the-box; instead it is necessary to enable COMPATIBLE_TLS in the OkHttpClient configuration.' This is because the TLS versions are being moved to a less secure configuration, and the change is not trivial or easily inferred from the code diff."
https://github.com/square/retrofit/commit/2d6b02f7cf59235358ef4d574930ce7545ce8619,RxJava 1.0.  <enter> (cherry picked from commit  <otherCommit_link> ) <enter> Conflicts:  <tab> pom.xml ,https://api.github.com/repos/square/retrofit/commits/2d6b02f7cf59235358ef4d574930ce7545ce8619,"@@ -51,7 +51,7 @@
     <android.platform>16</android.platform>
     <gson.version>2.3</gson.version>
     <okhttp.version>2.0.0</okhttp.version>
-    <rxjava.version>1.0.0-rc.4</rxjava.version>
+    <rxjava.version>1.0.0</rxjava.version>
     <appengine.version>1.9.12</appengine.version>
 
     <!-- Converter Dependencies -->
",True,"The commit message refers to the necessity of changes by mentioning that it is cherry-picking a commit that updates the RxJava version from 1.0.0-rc.4 to 1.0.0. This could be an improvement over the previous version, as the release version (1.0.0) may have bug fixes or new features that were not present in the release candidate version (1.0.0-rc.4). Additionally, the mention of conflicts with the pom.xml file suggests that the change may have been necessary to resolve issues or dependencies.",True,"The commit message does not provide a rationale for the change, but it is easy to infer the necessity of the change from the diff. The change is updating the version of RxJava from 1.0.0-rc.4 to 1.0.0. This is likely a version update to fix a bug or add a new feature, as version updates often include such changes. The message does not explicitly state this, but it is a common practice to update dependencies to their stable versions when they are released.",False,"The commit message does not explicitly describe the necessity of the changes. It only mentions that the RxJava version is being updated from 1.0.0-rc.4 to 1.0.0, but it does not elaborate on any errors, issues, or shortcomings in the previous implementation that necessitated this change.",True,"The commit message indicates that the change is being made to update the RxJava version from 1.0.0-rc.4 to 1.0.0. This could be due to the need to use the stable version of RxJava instead of the release candidate version, which could be a requirement for software development to ensure the project is using up-to-date and stable libraries. Additionally, the mention of conflicts in the pom.xml file suggests that there may have been issues with the previous version of RxJava, which necessitated the update.",False,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only mentions the version change of RxJava from 1.0.0-rc.4 to 1.0.0. However, the code diff indicates that the change is a version update, not a fix for a defect or an improvement to the code.",True,The commit message does a good job of summarizing the change. It specifically mentions 'RxJava 1.0' and contrasts the previous version '1.0.0-rc.4' with the new version '1.0.0'. This clearly indicates that the change is an update to the RxJava version.,False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions that the RxJava version is being updated from 1.0.0-rc.4 to 1.0.0. However, it does not explain why this change was made or what impact it might have on the codebase.",True,"The commit message does not explicitly describe the changes from a functional perspective, but the code diff indicates that the version of RxJava has been updated from 1.0.0-rc.4 to 1.0.0. This change could potentially introduce new behaviors or fix bugs, but without more context, it's difficult to say for certain. However, the mention of RxJava and the version change suggests that the commit may have introduced new functionality or fixed issues related to this library.",True,"The commit message only mentions that the RxJava version has been changed from 1.0.0-rc.4 to 1.0.0. This is a small and simple change, and the reason for the change can be easily inferred from the version number. The version number change from a release candidate (rc.4) to the final release (1.0.0) suggests that the change was made to update to the stable version of RxJava. Therefore, there was no need for an explicit explanation of the change in the commit message."
https://github.com/square/okhttp/commit/6651a9c15e06e8d1829aa00f970998be2f33b225,Change MediaType's failure mode to not crash on charset problems.  <enter> As-is it throws unchecked exceptions on unexpected charsets. This is a problem because it can cause a misbehaving webserver to crash the client. <enter> I don't expect this to break existing clients; returning 'null' has always been a possibility; it's just returned in more cases. ,https://api.github.com/repos/square/okhttp/commits/6651a9c15e06e8d1829aa00f970998be2f33b225,"@@ -18,7 +18,6 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
@@ -241,15 +240,7 @@ public Level getLevel() {
         Charset charset = UTF8;
         MediaType contentType = responseBody.contentType();
         if (contentType != null) {
-          try {
-            charset = contentType.charset(UTF8);
-          } catch (UnsupportedCharsetException e) {
-            logger.log("""");
-            logger.log(""Couldn't decode the response body; charset is likely malformed."");
-            logger.log(""<-- END HTTP"");
-
-            return response;
-          }
+          charset = contentType.charset(UTF8);
         }
 
         if (!isPlaintext(buffer)) {
@@ -563,7 +563,7 @@ private void bodyGetNoBody(int code) throws IOException {
 
     server.enqueue(new MockResponse()
         .setHeader(""Content-Type"", ""text/html; charset=0"")
-        .setBody(""Ignore This""));
+        .setBody(""Body with unknown charset""));
     Response response = client.newCall(request().build()).execute();
     response.body().close();
 
@@ -578,8 +578,8 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual(""Content-Type: text/html; charset=0"")
         .assertLogMatch(""Content-Length: \\d+"")
         .assertLogMatch("""")
-        .assertLogEqual(""Couldn't decode the response body; charset is likely malformed."")
-        .assertLogEqual(""<-- END HTTP"")
+        .assertLogEqual(""Body with unknown charset"")
+        .assertLogEqual(""<-- END HTTP (25-byte body)"")
         .assertNoMoreLogs();
 
     applicationLogs
@@ -589,8 +589,8 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual(""Content-Type: text/html; charset=0"")
         .assertLogMatch(""Content-Length: \\d+"")
         .assertLogEqual("""")
-        .assertLogEqual(""Couldn't decode the response body; charset is likely malformed."")
-        .assertLogEqual(""<-- END HTTP"")
+        .assertLogEqual(""Body with unknown charset"")
+        .assertLogEqual(""<-- END HTTP (25-byte body)"")
         .assertNoMoreLogs();
   }
 
@@ -17,15 +17,12 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
-import java.nio.charset.IllegalCharsetNameException;
-import java.nio.charset.UnsupportedCharsetException;
 import okhttp3.internal.Util;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 /**
  * Test MediaType API and parsing.
@@ -123,29 +120,17 @@ public class MediaTypeTest {
   }
 
   @Test public void testMultipleCharsets() {
-    try {
-      MediaType.parse(""text/plain; charset=utf-8; charset=utf-16"");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
+    assertNull(MediaType.parse(""text/plain; charset=utf-8; charset=utf-16""));
   }
 
   @Test public void testIllegalCharsetName() {
     MediaType mediaType = MediaType.parse(""text/plain; charset=\""!@#$%^&*()\"""");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testUnsupportedCharset() {
     MediaType mediaType = MediaType.parse(""text/plain; charset=utf-wtf"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (UnsupportedCharsetException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   /**
@@ -159,20 +144,12 @@ public class MediaTypeTest {
 
   @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
     MediaType mediaType = MediaType.parse(""text/plain;charset=\""'utf-8'\"""");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
     MediaType mediaType = MediaType.parse(""text/plain;charset=\""'\"""");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testDefaultCharset() throws Exception {
@@ -189,7 +166,7 @@ public class MediaTypeTest {
     MediaType mediaType = MediaType.parse(""text/plain;"");
     assertEquals(""text"", mediaType.type());
     assertEquals(""plain"", mediaType.subtype());
-    assertEquals(null, mediaType.charset());
+    assertNull(mediaType.charset());
     assertEquals(""text/plain;"", mediaType.toString());
   }
 
@@ -73,7 +73,7 @@ public static MediaType parse(String string) {
         charsetParameter = parameter.group(3);
       }
       if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        throw new IllegalArgumentException(""Multiple different charsets: "" + string);
+        return null; // Multiple different charsets!
       }
       charset = charsetParameter;
     }
@@ -100,15 +100,19 @@ public String subtype() {
    * Returns the charset of this media type, or null if this media type doesn't specify a charset.
    */
   public Charset charset() {
-    return charset != null ? Charset.forName(charset) : null;
+    return charset(null);
   }
 
   /**
-   * Returns the charset of this media type, or {@code defaultValue} if this media type doesn't
-   * specify a charset.
+   * Returns the charset of this media type, or {@code defaultValue} if either this media type
+   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
    */
   public Charset charset(Charset defaultValue) {
-    return charset != null ? Charset.forName(charset) : defaultValue;
+    try {
+      return charset != null ? Charset.forName(charset) : defaultValue;
+    } catch (IllegalArgumentException e) {
+      return defaultValue; // This charset is invalid or unsupported. Give up.
+    }
   }
 
   /**
",True,"The commit message refers to a convention regarding the handling of unexpected charsets. It explains that the current behavior of throwing unchecked exceptions on unexpected charsets can cause a misbehaving webserver to crash the client. The commit changes the failure mode to not crash on charset problems, which is an improvement over the prior behavior.",True,The commit message explains the necessity of changes by stating that the current behavior of throwing unchecked exceptions on unexpected charsets can cause a misbehaving webserver to crash the client. This is a valid reason to change the behavior of the code.,True,The commit message directly elaborates the motivation of the code change by describing the error scenario ('it throws unchecked exceptions on unexpected charsets') and the issue it causes ('which can cause a misbehaving webserver to crash the client'). This clearly explains the necessity of the changes and the potential benefits.,True,"The commit message indicates that the developer changed the failure mode of MediaType to not crash on charset problems. This is done to prevent a misbehaving webserver from crashing the client. This change is necessary to address the problem of unexpected charsets causing unchecked exceptions, which can lead to client crashes.",True,The commit message directly mentions the defect it fixes by stating that it changes the failure mode of MediaType to not crash on charset problems. This is an improvement to the code as it prevents the client from crashing due to a misbehaving webserver.,True,"The commit message 'Change MediaType's failure mode to not crash on charset problems' accurately summarizes the changes made in the diff. It highlights the key component of the change, which is modifying the failure mode of MediaType to handle charset problems without causing a crash. The message also contrasts the before and after scenario by mentioning the previous behavior of throwing unchecked exceptions on unexpected charsets.",True,"The commit message explains that the code changes the failure mode of MediaType to not crash on charset problems. This is a technical principle underpinning the changes, as it improves the robustness of the system by handling unexpected charsets without causing a crash.",True,"The commit message expresses a change in behavior and describes the impact of the change. It mentions that the failure mode of MediaType is being changed to not crash on charset problems. This is a significant change as it can prevent a misbehaving webserver from crashing the client. The code diff supports this by removing the try-catch block that handles UnsupportedCharsetException and instead returning 'null' when an unexpected charset is encountered. This change is expected not to break existing clients as returning 'null' has always been a possibility, it's just returned in more cases now.",False,"The commit message explains the reason for the change: it changes the failure mode of MediaType to not crash on charset problems. This is a significant change that could have unintended consequences if not properly explained. The code diff shows that the UnsupportedCharsetException is caught and handled differently, but the commit message provides additional context about the potential impact on misbehaving webservers and existing clients."
https://github.com/spring-projects/spring-boot/commit/3d27391d47910f73c1e889b76030a53038a38f25,Allow StringSequence.isEmpty() to be compatible with JDK 15  <enter> JDK 15 introduces isEmpty() on CharSequence which clashes with the one declared in StringSequence because it is not public. <enter> See  <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/3d27391d47910f73c1e889b76030a53038a38f25,"@@ -72,7 +72,11 @@ public StringSequence subSequence(int start, int end) {
 		return new StringSequence(this.source, subSequenceStart, subSequenceEnd);
 	}
 
-	boolean isEmpty() {
+	/**
+	 * Returns {@code true} if the sequence is empty. Public to be compatible with JDK 15.
+	 * @return {@code true} if {@link #length()} is {@code 0}, otherwise {@code false}
+	 */
+	public boolean isEmpty() {
 		return length() == 0;
 	}
 
@@ -46,4 +46,5 @@
 	<suppress files=""[\\/]src[\\/]intTest[\\/]java[\\/]"" checks=""SpringJavadoc"" message=""\@since"" />
 	<suppress files=""LinuxDomainSocket"" checks=""FinalClass"" message=""SockaddrUn"" />
 	<suppress files=""BsdDomainSocket"" checks=""FinalClass"" message=""SockaddrUn"" />
+	<suppress files=""StringSequence"" checks=""SpringMethodVisibility"" />
 </suppressions>
",True,"The commit message refers to a convention (JDK 15 introducing isEmpty() on CharSequence) that necessitates the changes. The message explains that the change is made to make StringSequence.isEmpty() compatible with JDK 15, which introduces a public isEmpty() method on CharSequence. This is done to avoid a clash between the two methods. The code diff also supports this explanation by adding a Javadoc comment to the isEmpty() method and making it public.",True,"The commit message explains the necessity of changes by stating that JDK 15 introduces isEmpty() on CharSequence which clashes with the one declared in StringSequence because it is not public. This is not a common sense or easy to infer change, as it is a specific compatibility issue with a new version of Java. The code diff also shows that the method is being made public to resolve this issue.",True,"The commit message explains the motivation for the code change by mentioning that JDK 15 introduces an isEmpty() method on CharSequence, which clashes with the one declared in StringSequence because it is not public. This creates a compatibility issue, so the change is made to make StringSequence.isEmpty() public to be compatible with JDK 15.",True,"The commit message 'Allow StringSequence.isEmpty() to be compatible with JDK 15' indicates that the changes were made to accommodate the new isEmpty() method introduced in JDK 15. This change was necessary to ensure compatibility with the updated Java Development Kit version. The message does not explicitly mention user requirements or problems in the software maintenance process, but it does highlight a change in the development environment (JDK version) that required code modifications.",True,"The commit message directly mentions the change is to make StringSequence.isEmpty() compatible with JDK 15, which is an improvement to the code. The message also explains the reason for the change, which is to avoid a clash with the isEmpty() method introduced in JDK 15.",True,"The commit message 'Allow StringSequence.isEmpty() to be compatible with JDK 15' accurately summarizes the key change in the diff, which is the modification of the 'isEmpty()' method to be public and compatible with JDK 15. The message also provides a brief explanation of the reason for the change, which is to avoid a clash with the new 'isEmpty()' method introduced in JDK 15. The message does not explicitly contrast the before and after state of the method, but it implicitly does so by mentioning the change in visibility from private to public.",True,"The commit message explains that the changes are made to allow the StringSequence.isEmpty() method to be compatible with JDK 15. The JDK 15 version of isEmpty() is declared on CharSequence, but it's not public, which causes a clash with the one declared in StringSequence. To resolve this, the method is made public in the code diff. This change is based on the principle of maintaining compatibility with newer versions of the Java Development Kit.",True,"The commit message 'Allow StringSequence.isEmpty() to be compatible with JDK 15' does express a change in behavior. It explains that the method isEmpty() is being modified to be public, which is not its original visibility, to be compatible with JDK 15. This change introduces new behavior as it allows the method to be accessed from outside the class, which was not possible before. The code diff also supports this explanation by showing the addition of the 'public' keyword to the method declaration.",False,"The commit message does not lack an explanation. It clearly states that JDK 15 introduces an isEmpty() method on CharSequence, which clashes with the one declared in StringSequence because it is not public. The commit message explains the reason for the change and the need for making the isEmpty() method public to be compatible with JDK 15."
https://github.com/square/okhttp/commit/c6c7ce7dadf2ccaa04122f57a278a4a96d1f5c50,"DiskLruCache snapshot() method removing entries that are being cached (<pr_link> ) <enter> Fixed a bug I found. When using DiskLruCache, hasNext() method of Iterator<Snapshot> returned by snapshot() method iterates through lruEntries, however if entry is not completed yet, it is removed (together with dirtyFiles) as cleanFiles don't exist yet - during saving response to disk. This caused sometimes file not being cached at all. ",https://api.github.com/repos/square/okhttp/commits/c6c7ce7dadf2ccaa04122f57a278a4a96d1f5c50,"@@ -706,6 +706,8 @@ class DiskLruCache internal constructor(
 
           while (delegate.hasNext()) {
             val entry = delegate.next()
+            if (entry == null || !entry.readable) continue // Entry during edit
+
             val snapshot = entry.snapshot() ?: continue
             // Evicted since we copied the entries.
             nextSnapshot = snapshot
@@ -1643,6 +1643,25 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertAbsent(""k1"");
   }
 
+  @Test public void dontRemoveUnfinishedEntryWhenCreatingSnapshot() throws Exception {
+    DiskLruCache.Editor creator = cache.edit(""k1"");
+    setString(creator, 0, ""ABC"");
+    setString(creator, 1, ""DE"");
+
+    assertThat(creator.newSource(0)).isNull();
+    assertThat(creator.newSource(1)).isNull();
+
+    Iterator<DiskLruCache.Snapshot> snapshotWhileEditing = cache.snapshots();
+    assertThat(snapshotWhileEditing.hasNext()).isFalse(); // entry still is being created/edited
+    creator.commit();
+
+    Iterator<DiskLruCache.Snapshot> snapshotAfterCommit = cache.snapshots();
+
+    assertThat(snapshotAfterCommit.hasNext())
+        .withFailMessage(""Entry has been removed during creation."")
+        .isTrue();
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
",True,"The commit message refers to a bug that was found and fixed. It explains that the bug caused the 'snapshot()' method to remove entries that were being cached, which could lead to files not being cached at all. This is a clear reference to a problem that was identified and resolved, making the changes necessary.",True,"The commit message explains the necessity of the changes by describing a bug that was found in the DiskLruCache snapshot() method. The bug caused entries that were being cached to be removed, which resulted in files not being cached at all. The commit message also provides a clear explanation of the bug and how it was fixed.",True,"The commit message directly elaborates the motivation of the code change by describing the error scenario. It mentions that the 'snapshot()' method of DiskLruCache was returning entries that were being cached, which could cause a file not being cached at all if the entry was not completed yet. This is a clear explanation of the problem and the necessity of the changes.",True,"The commit message indicates that the developer fixed a bug in the DiskLruCache class. The bug was causing entries that were being cached to be removed prematurely, which resulted in files not being cached at all. This is a problem in the process of software maintenance, specifically a bug that was causing incorrect behavior.",True,"The commit message directly mentions the bug it fixes, which is 'When using DiskLruCache, hasNext() method of Iterator<Snapshot> returned by snapshot() method iterates through lruEntries, however if entry is not completed yet, it is removed... This caused sometimes file not being cached at all.' This clearly describes the issue and the change made to fix it.",True,The commit message accurately summarizes the changes made in the code diff. It mentions the 'snapshot()' method of 'DiskLruCache' and how it was modified to prevent the removal of entries that are being cached. This is consistent with the added lines in the diff that check if an entry is readable before proceeding with the snapshot operation.,True,"The commit message explains the technical principle underpinning the changes by describing the issue with the DiskLruCache snapshot() method. It explains that the method was removing entries that were being cached, which caused files not to be cached at all. The explanation highlights the issue with incomplete entries being removed during the saving process, which is a clear technical principle.",True,"The commit message accurately describes the code changes by explaining the functional perspective. It mentions that the 'snapshot()' method was modified to prevent entries that are being cached from being removed. This change was made to fix a bug where the 'hasNext()' method of the Iterator<Snapshot> returned by the 'snapshot()' method would sometimes iterate through 'lruEntries', and if an entry was not completed yet, it was removed. This caused the file not to be cached at all. The code diff provided supports this explanation by showing the addition of a check to continue if the entry is null or not readable, which corresponds to the entry being in the process of being edited.",False,"The commit message does explain the reason for the change, which is to fix a bug in the DiskLruCache snapshot() method. The bug caused entries that were being cached to be removed prematurely, which resulted in files not being cached at all. The code diff supports this explanation by showing the changes made to the snapshot() method to handle this case."
https://github.com/spring-projects/spring-boot/commit/3a8a1272855a82c1d454920b423c49ced826428a,Implement simpler exclusion logic for Gradle  <enter> Simplify the exclusion logic used in Gradle by implementing implicit exclusions rather than trying to detect transitive excludes. <enter> This commit reverts much of the code originally included to  fix   <issue_link>  which adds far too much complexity to the build and still doesn't solve the underlying issue. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/3a8a1272855a82c1d454920b423c49ced826428a,"@@ -105,12 +105,8 @@
 				<skipTests>true</skipTests>
 			</properties>
 			<modules>
-				<module>spring-boot-dependencies</module>
 				<module>spring-boot-versions</module>
 				<module>spring-boot-parent</module>
-				<module>spring-boot</module>
-				<module>spring-boot-autoconfigure</module>
-				<module>spring-boot-actuator</module>
 				<module>spring-boot-starters</module>
 				<module>spring-boot-tools</module>
 			</modules>
@@ -1,4 +1,5 @@
-<?xml version=""1.0"" encoding=""UTF-8""?><project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
 	<groupId>org.springframework.boot</groupId>
 	<artifactId>spring-boot-dependencies</artifactId>
@@ -1283,4 +1284,4 @@
 			</plugins>
 		</pluginManagement>
 	</build>
-</project>
\ No newline at end of file
+</project>
@@ -296,8 +296,7 @@ which does not have an `exclusion` element.
 
 To ensure that correct exclusions are actually applied, the Spring Boot Gradle plugin will
 automatically add exclusion rules. All exclusions defined in the
-`spring-boot-dependencies` POM and the ``starter'' POMs will be added (both direct and
-transitive exclusions).
+`spring-boot-dependencies` POM and implicit rules for the ``starter'' POMs will be added.
 
 If you don't want exclusion rules automatically applied you can use the following
 configuration:
@@ -37,7 +37,7 @@
 /**
  * Tests for war packaging with Gradle to ensure that only the Servlet container and its
  * dependencies are packaged in WEB-INF/lib-provided
- *
+ * 
  * @author Andy Wilkinson
  */
 public class WarPackagingTests {
@@ -54,6 +54,7 @@ public class WarPackagingTests {
 			Arrays.asList(WEB_INF_LIB_PROVIDED_PREFIX + ""spring-boot-starter-jetty-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-util-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-xml-"",
+					WEB_INF_LIB_PROVIDED_PREFIX + ""javax.servlet-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-continuation-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-io-"",
 					WEB_INF_LIB_PROVIDED_PREFIX + ""jetty-http-"",
@@ -20,7 +20,6 @@
 		<main.basedir>${basedir}/..</main.basedir>
 	</properties>
 	<modules>
-		<!-- If you add a starter remember to also add a dependency in spring-boot-versions -->
 		<module>spring-boot-starter</module>
 		<module>spring-boot-starter-amqp</module>
 		<module>spring-boot-starter-aop</module>
@@ -30,7 +30,7 @@
 				<artifactId>maven-dependency-plugin</artifactId>
 				<executions>
 					<execution>
-						<id>copy-resources</id>
+						<id>copy-effective-pom</id>
 						<phase>generate-resources</phase>
 						<goals>
 							<goal>copy</goal>
@@ -46,15 +46,6 @@
 									<outputDirectory>${generated.pom.dir}</outputDirectory>
 									<destFileName>effective-pom.xml</destFileName>
 								</artifactItem>
-								<artifactItem>
-									<groupId>org.springframework.boot</groupId>
-									<artifactId>spring-boot-versions</artifactId>
-									<version>${project.version}</version>
-									<type>dependency-tree</type>
-									<overWrite>true</overWrite>
-									<outputDirectory>${generated.pom.dir}</outputDirectory>
-									<destFileName>dependency-tree.txt</destFileName>
-								</artifactItem>
 							</artifactItems>
 						</configuration>
 					</execution>
@@ -1,131 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import org.springframework.boot.dependency.tools.Dependency.Exclusion;
-import org.springframework.boot.dependency.tools.Dependency.ExclusionType;
-
-/**
- * {@link Dependencies} to extend an existing {@link Dependencies} instance with
- * transitive {@link Exclusion}s located from a {@link DependencyTree}.
- * 
- * @author Phillip Webb
- * @since 1.1.0
- */
-class DependenciesWithTransitiveExclusions extends AbstractDependencies {
-
-	public DependenciesWithTransitiveExclusions(Dependencies dependencies,
-			DependencyTree tree) {
-		DependencyBuilder builder = new DependencyBuilder(dependencies);
-		builder.addTransitiveExcludes(tree);
-		builder.finish();
-	}
-
-	/**
-	 * Builder used to collect the transitive exclusions.
-	 */
-	private class DependencyBuilder {
-
-		private Map<ArtifactAndGroupId, DependencyAndTransitiveExclusions> dependencies;
-
-		public DependencyBuilder(Dependencies dependencies) {
-			this.dependencies = new LinkedHashMap<ArtifactAndGroupId, DependencyAndTransitiveExclusions>();
-			for (Dependency dependency : dependencies) {
-				this.dependencies.put(new ArtifactAndGroupId(dependency),
-						new DependencyAndTransitiveExclusions(dependency));
-			}
-		}
-
-		public void addTransitiveExcludes(DependencyTree tree) {
-			for (DependencyNode node : tree) {
-				DependencyAndTransitiveExclusions dependency = this.dependencies
-						.get(asArtifactAndGroupId(node));
-				if (dependency != null) {
-					for (DependencyNode child : node) {
-						addTransitiveExcludes(dependency, child);
-					}
-				}
-			}
-		}
-
-		private void addTransitiveExcludes(DependencyAndTransitiveExclusions dependency,
-				DependencyNode node) {
-			DependencyAndTransitiveExclusions exclusions = this.dependencies
-					.get(asArtifactAndGroupId(node));
-			if (exclusions != null) {
-				dependency.addTransitiveExclusions(exclusions.getSourceDependency());
-			}
-			for (DependencyNode child : node) {
-				addTransitiveExcludes(dependency, child);
-			}
-		}
-
-		private ArtifactAndGroupId asArtifactAndGroupId(DependencyNode node) {
-			return new ArtifactAndGroupId(node.getGroupId(), node.getArtifactId());
-		}
-
-		public void finish() {
-			for (Map.Entry<ArtifactAndGroupId, DependencyAndTransitiveExclusions> entry : this.dependencies
-					.entrySet()) {
-				add(entry.getKey(), entry.getValue().createNewDependency());
-			}
-		}
-
-	}
-
-	/**
-	 * Holds a {@link Dependency} with additional transitive {@link Exclusion}s.
-	 */
-	private static class DependencyAndTransitiveExclusions {
-
-		private Dependency dependency;
-
-		private Set<Exclusion> transitiveExclusions = new LinkedHashSet<Exclusion>();
-
-		public DependencyAndTransitiveExclusions(Dependency dependency) {
-			this.dependency = dependency;
-		}
-
-		public Dependency getSourceDependency() {
-			return this.dependency;
-		}
-
-		public void addTransitiveExclusions(Dependency dependency) {
-			for (Exclusion exclusion : dependency.getExclusions()) {
-				this.transitiveExclusions.add(new Exclusion(exclusion.getGroupId(),
-						exclusion.getArtifactId(), ExclusionType.TRANSITIVE));
-			}
-		}
-
-		public Dependency createNewDependency() {
-			Set<Exclusion> exclusions = new LinkedHashSet<Dependency.Exclusion>();
-			exclusions.addAll(this.dependency.getExclusions());
-			exclusions.addAll(this.transitiveExclusions);
-			return new Dependency(this.dependency.getGroupId(),
-					this.dependency.getArtifactId(), this.dependency.getVersion(),
-					new ArrayList<Exclusion>(exclusions));
-		}
-
-	}
-
-}
@@ -137,15 +137,11 @@ public static final class Exclusion {
 
 		private final String artifactId;
 
-		private final ExclusionType type;
-
-		Exclusion(String groupId, String artifactId, ExclusionType type) {
+		Exclusion(String groupId, String artifactId) {
 			Assert.notNull(groupId, ""GroupId must not be null"");
 			Assert.notNull(groupId, ""ArtifactId must not be null"");
-			Assert.notNull(type, ""Type must not be null"");
 			this.groupId = groupId;
 			this.artifactId = artifactId;
-			this.type = type;
 		}
 
 		/**
@@ -162,10 +158,6 @@ public String getGroupId() {
 			return this.groupId;
 		}
 
-		public ExclusionType getType() {
-			return this.type;
-		}
-
 		@Override
 		public String toString() {
 			return this.groupId + "":"" + this.artifactId;
@@ -196,22 +188,4 @@ public boolean equals(Object obj) {
 
 	}
 
-	public static enum ExclusionType {
-
-		/**
-		 * An exclusion that was specified directly on the dependency.
-		 */
-		DIRECT,
-
-		/**
-		 * An exclusion that is was specified on a dependency of this dependency. For
-		 * example if {@literal commons-logging} is directly excluded from
-		 * {@literal spring-core} then it is also transitive exclude on
-		 * {@literal spring-context} (since {@literal spring-context} depends on
-		 * {@literal spring-core}).
-		 */
-		TRANSITIVE
-
-	}
-
 }
@@ -1,82 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * A single node in a {@link DependencyTree}.
- * 
- * @author Phillip Webb
- * @see DependencyTree
- * @since 1.1.0
- */
-class DependencyNode implements Iterable<DependencyNode> {
-
-	private final String groupId;
-
-	private final String artifactId;
-
-	private final String version;
-
-	private List<DependencyNode> dependencies;
-
-	DependencyNode(String groupId, String artifactId, String version) {
-		this.groupId = groupId;
-		this.artifactId = artifactId;
-		this.version = version;
-		this.dependencies = new ArrayList<DependencyNode>();
-	}
-
-	@Override
-	public Iterator<DependencyNode> iterator() {
-		return getDependencies().iterator();
-	}
-
-	public String getGroupId() {
-		return this.groupId;
-	}
-
-	public String getArtifactId() {
-		return this.artifactId;
-	}
-
-	public String getVersion() {
-		return this.version;
-	}
-
-	public List<DependencyNode> getDependencies() {
-		return Collections.unmodifiableList(this.dependencies);
-	}
-
-	@Override
-	public String toString() {
-		return this.groupId + "":"" + this.artifactId + "":"" + this.version;
-	}
-
-	void addDependency(DependencyNode node) {
-		this.dependencies.add(node);
-	}
-
-	DependencyNode getLastDependency() {
-		return this.dependencies.get(this.dependencies.size() - 1);
-	}
-
-}
@@ -1,159 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.ArrayDeque;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Dependency tree information that can be loaded from the output of
- * {@literal mvn dependency:tree}.
- * 
- * @author Phillip Webb
- * @since 1.1.0
- * @see DependencyNode
- */
-class DependencyTree implements Iterable<DependencyNode> {
-
-	private final DependencyNode root;
-
-	/**
-	 * Create a new {@link DependencyTree} instance for the given input stream.
-	 * @param inputStream input stream containing content from
-	 * {@literal mvn dependency:tree} (the stream will be closed).
-	 */
-	public DependencyTree(InputStream inputStream) {
-		try {
-			this.root = parse(inputStream);
-		}
-		catch (IOException ex) {
-			throw new IllegalStateException(ex);
-		}
-	}
-
-	private DependencyNode parse(InputStream inputStream) throws IOException {
-		try {
-			BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-			Parser parser = new Parser();
-			String line;
-			while ((line = reader.readLine()) != null) {
-				parser.append(line);
-			}
-			return parser.getRoot();
-		}
-		finally {
-			inputStream.close();
-		}
-	}
-
-	@Override
-	public Iterator<DependencyNode> iterator() {
-		return getDependencies().iterator();
-	}
-
-	/**
-	 * @return the root node for the tree.
-	 */
-	public DependencyNode getRoot() {
-		return this.root;
-	}
-
-	/**
-	 * @return the dependencies of the root node.
-	 */
-	public List<DependencyNode> getDependencies() {
-		return this.root.getDependencies();
-	}
-
-	/**
-	 * Return the node at the specified index.
-	 * @param index the index (multiple indexes can be used to traverse the tree)
-	 * @return the node at the specified index
-	 */
-	public DependencyNode get(int... index) {
-		DependencyNode rtn = this.root;
-		for (int i : index) {
-			rtn = rtn.getDependencies().get(i);
-		}
-		return rtn;
-	}
-
-	private static class Parser {
-
-		private static final int INDENT = 3;
-
-		private static final Set<Character> PREFIX_CHARS = new HashSet<Character>(
-				Arrays.asList(' ', '+', '-', '\\', '|'));
-
-		private static final Pattern LINE_PATTERN = Pattern
-				.compile(""[(]?([^:]*):([^:]*):([^:]*):([^:\\s]*)"");
-
-		private Deque<DependencyNode> stack = new ArrayDeque<DependencyNode>();
-
-		public void append(String line) {
-			int depth = getDepth(line);
-			String data = line.substring(depth * INDENT);
-			if (depth == 0) {
-				this.stack.push(createNode(data));
-			}
-			else {
-				while (depth < this.stack.size()) {
-					this.stack.pop();
-				}
-				if (depth > this.stack.size()) {
-					this.stack.push(this.stack.peek().getLastDependency());
-				}
-				this.stack.peek().addDependency(createNode(data));
-			}
-		}
-
-		private int getDepth(String line) {
-			for (int i = 0; i < line.length(); i++) {
-				if (!Parser.PREFIX_CHARS.contains(line.charAt(i))) {
-					return i / INDENT;
-				}
-			}
-			return 0;
-		}
-
-		private DependencyNode createNode(String line) {
-			Matcher matcher = LINE_PATTERN.matcher(line);
-			if (!matcher.find()) {
-				throw new IllegalStateException(""Unable to parese line "" + line);
-			}
-			return new DependencyNode(matcher.group(1), matcher.group(2),
-					matcher.group(4));
-		}
-
-		public DependencyNode getRoot() {
-			return this.stack.getLast();
-		}
-
-	}
-
-}
@@ -57,11 +57,7 @@ private void addAll(Dependencies dependencies) {
 
 	private static Dependencies getSpringBootDependencies() {
 		if (springBootDependencies == null) {
-			Dependencies dependencies = new PomDependencies(
-					getResource(""effective-pom.xml""));
-			DependencyTree tree = new DependencyTree(getResource(""dependency-tree.txt""));
-			dependencies = new DependenciesWithTransitiveExclusions(dependencies, tree);
-			springBootDependencies = dependencies;
+			springBootDependencies = new PomDependencies(getResource(""effective-pom.xml""));
 		}
 		return springBootDependencies;
 	}
@@ -25,7 +25,6 @@
 import javax.xml.parsers.DocumentBuilderFactory;
 
 import org.springframework.boot.dependency.tools.Dependency.Exclusion;
-import org.springframework.boot.dependency.tools.Dependency.ExclusionType;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
@@ -119,7 +118,7 @@ private List<Exclusion> createExclusions(Node item) {
 	private Exclusion createExclusion(Element element) {
 		String groupId = getTextContent(element, ""groupId"");
 		String artifactId = getTextContent(element, ""artifactId"");
-		return new Exclusion(groupId, artifactId, ExclusionType.DIRECT);
+		return new Exclusion(groupId, artifactId);
 	}
 
 	private String getTextContent(Element element, String tagName) {
@@ -1,50 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import org.junit.Test;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.assertThat;
-
-/**
- * Tests for {@link DependenciesWithTransitiveExclusions}.
- * 
- * @author Phillip Webb
- */
-public class DependenciesWithTransitiveExclusionsTests {
-
-	@Test
-	public void findsTransitiveExclusions() throws Exception {
-		Dependencies source = new PomDependencies(getClass().getResourceAsStream(
-				""test-effective-pom.xml""));
-		DependencyTree tree = new DependencyTree(getClass().getResourceAsStream(
-				""test-effective-pom-dependency-tree.txt""));
-		DependenciesWithTransitiveExclusions dependencies = new DependenciesWithTransitiveExclusions(
-				source, tree);
-		assertExcludes(dependencies, ""sample01"", ""[org.exclude:exclude01]"");
-		assertExcludes(source, ""sample02"", ""[]"");
-		assertExcludes(dependencies, ""sample02"", ""[org.exclude:exclude01]"");
-	}
-
-	private void assertExcludes(Dependencies dependencies, String artifactId,
-			String expected) {
-		Dependency dependency = dependencies.find(""org.sample"", artifactId);
-		assertThat(dependency.getExclusions().toString(), equalTo(expected));
-	}
-
-}
@@ -1,44 +0,0 @@
-/*
- * Copyright 2012-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.dependency.tools;
-
-import org.junit.Test;
-import org.springframework.boot.dependency.tools.DependencyTree;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.assertThat;
-
-/**
- * Tests for {@link DependencyTree}.
- * 
- * @author Phillip Webb
- */
-public class DependencyTreeTests {
-
-	@Test
-	public void parse() throws Exception {
-		DependencyTree tree = new DependencyTree(getClass().getResourceAsStream(
-				""sample-dependency-tree.txt""));
-		assertThat(tree.getRoot().toString(), equalTo(""org.springframework.boot:""
-				+ ""spring-boot-versions-dependency-tree:1.1.0.BUILD-SNAPSHOT""));
-		assertThat(tree.getDependencies().size(), equalTo(204));
-		assertThat(tree.get(0, 1).toString(), equalTo(""org.slf4j:slf4j-api:1.7.6""));
-		assertThat(tree.get(203).toString(), equalTo(""org.springframework.security:""
-				+ ""spring-security-web:3.2.4.RELEASE""));
-	}
-
-}
@@ -1,1087 +0,0 @@
-org.springframework.boot:spring-boot-versions-dependency-tree:pom:1.1.0.BUILD-SNAPSHOT
-+- ch.qos.logback:logback-classic:jar:1.1.2:compile
-|  +- ch.qos.logback:logback-core:jar:1.1.2:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.6:compile - omitted for conflict with 1.7.7)
-+- com.codahale.metrics:metrics-graphite:jar:3.0.2:compile
-|  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-+- com.codahale.metrics:metrics-ganglia:jar:3.0.2:compile
-|  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  +- info.ganglia.gmetric4j:gmetric4j:jar:1.0.3:compile
-|  |  \- org.acplt:oncrpc:jar:1.0.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-+- com.codahale.metrics:metrics-core:jar:3.0.2:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-+- com.codahale.metrics:metrics-servlets:jar:3.0.2:compile
-|  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  +- com.codahale.metrics:metrics-healthchecks:jar:3.0.2:compile
-|  |  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- com.codahale.metrics:metrics-json:jar:3.0.2:compile
-|  |  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  |  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.2.2:compile - omitted for duplicate)
-|  |  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- com.codahale.metrics:metrics-jvm:jar:3.0.2:compile
-|  |  +- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  |  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.2.2:compile - omitted for conflict with 2.3.3)
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-+- org.codehaus.janino:janino:jar:2.6.1:compile
-|  \- org.codehaus.janino:commons-compiler:jar:2.6.1:compile
-+- com.fasterxml.jackson.core:jackson-annotations:jar:2.3.3:compile
-+- com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile
-+- com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.0:compile - omitted for conflict with 2.3.3)
-|  \- (com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile - omitted for duplicate)
-+- com.fasterxml.jackson.datatype:jackson-datatype-joda:jar:2.3.3:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.0:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile - omitted for duplicate)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile - omitted for duplicate)
-|  \- (joda-time:joda-time:jar:2.1:compile - omitted for conflict with 2.3)
-+- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.3.3:compile
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile - omitted for duplicate)
-|  \- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile - omitted for duplicate)
-+- com.gemstone.gemfire:gemfire:jar:7.0.2:compile
-|  \- (antlr:antlr:jar:2.7.7:compile - scope updated from runtime; omitted for duplicate)
-+- com.h2database:h2:jar:1.3.175:compile
-+- com.zaxxer:HikariCP:jar:1.3.8:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  \- (org.javassist:javassist:jar:3.18.1-GA:compile - omitted for duplicate)
-+- commons-beanutils:commons-beanutils:jar:1.9.2:compile
-|  \- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-+- commons-collections:commons-collections:jar:3.2.1:compile
-+- commons-dbcp:commons-dbcp:jar:1.4:compile
-|  \- (commons-pool:commons-pool:jar:1.5.4:compile - omitted for conflict with 1.6)
-+- commons-digester:commons-digester:jar:2.1:compile
-|  \- (commons-beanutils:commons-beanutils:jar:1.8.3:compile - omitted for conflict with 1.9.2)
-+- commons-pool:commons-pool:jar:1.6:compile
-+- javax.jms:jms-api:jar:1.1-rev-1:compile
-+- javax.servlet:javax.servlet-api:jar:3.0.1:compile
-+- javax.servlet:jstl:jar:1.2:compile
-+- joda-time:joda-time:jar:2.3:compile
-+- junit:junit:jar:4.11:compile
-|  \- (org.hamcrest:hamcrest-core:jar:1.3:compile - omitted for duplicate)
-+- log4j:log4j:jar:1.2.17:compile
-+- mysql:mysql-connector-java:jar:5.1.30:compile
-+- nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect:jar:1.2.4:compile
-|  \- (org.thymeleaf:thymeleaf:jar:2.1.2.RELEASE:compile - omitted for conflict with 2.1.3.RELEASE)
-+- org.apache.activemq:activemq-client:jar:5.9.1:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- org.apache.geronimo.specs:geronimo-jms_1.1_spec:jar:1.1.1:compile
-|  +- org.fusesource.hawtbuf:hawtbuf:jar:1.9:compile
-|  \- org.apache.geronimo.specs:geronimo-j2ee-management_1.1_spec:jar:1.0.1:compile
-+- org.apache.activemq:activemq-broker:jar:5.9.1:compile
-|  +- (org.apache.activemq:activemq-client:jar:5.9.1:compile - omitted for duplicate)
-|  \- org.apache.activemq:activemq-openwire-legacy:jar:5.9.1:compile
-|     \- (org.apache.activemq:activemq-client:jar:5.9.1:compile - omitted for duplicate)
-+- org.apache.activemq:activemq-pool:jar:5.9.1:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- org.apache.activemq:activemq-jms-pool:jar:5.9.1:compile
-|  |  +- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  |  +- (org.apache.geronimo.specs:geronimo-jms_1.1_spec:jar:1.1.1:compile - omitted for duplicate)
-|  |  +- (org.apache.geronimo.specs:geronimo-jta_1.0.1B_spec:jar:1.0.1:compile - omitted for duplicate)
-|  |  \- (commons-pool:commons-pool:jar:1.6:compile - omitted for duplicate)
-|  +- (org.apache.activemq:activemq-client:jar:5.9.1:compile - omitted for duplicate)
-|  +- org.apache.geronimo.specs:geronimo-jta_1.0.1B_spec:jar:1.0.1:compile
-|  \- (commons-pool:commons-pool:jar:1.6:compile - omitted for duplicate)
-+- org.apache.commons:commons-pool2:jar:2.2:compile
-+- org.apache.httpcomponents:httpclient:jar:4.3.3:compile
-|  +- org.apache.httpcomponents:httpcore:jar:4.3.2:compile
-|  +- commons-logging:commons-logging:jar:1.1.3:compile
-|  \- commons-codec:commons-codec:jar:1.6:compile
-+- org.apache.httpcomponents:httpmime:jar:4.3.3:compile
-|  \- (org.apache.httpcomponents:httpclient:jar:4.3.3:compile - omitted for duplicate)
-+- org.apache.httpcomponents:httpasyncclient:jar:4.0.1:compile
-|  +- (org.apache.httpcomponents:httpcore:jar:4.3.2:compile - omitted for duplicate)
-|  +- org.apache.httpcomponents:httpcore-nio:jar:4.3.2:compile
-|  |  \- (org.apache.httpcomponents:httpcore:jar:4.3.2:compile - omitted for duplicate)
-|  +- (org.apache.httpcomponents:httpclient:jar:4.3.2:compile - omitted for conflict with 4.3.3)
-|  \- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)
-+- org.apache.tomcat.embed:tomcat-embed-core:jar:7.0.54:compile
-+- org.apache.tomcat.embed:tomcat-embed-el:jar:7.0.54:compile
-+- org.apache.tomcat.embed:tomcat-embed-logging-juli:jar:7.0.54:compile
-+- org.apache.tomcat.embed:tomcat-embed-jasper:jar:7.0.54:compile
-|  +- (org.apache.tomcat.embed:tomcat-embed-core:jar:7.0.54:compile - omitted for duplicate)
-|  +- (org.apache.tomcat.embed:tomcat-embed-el:jar:7.0.54:compile - omitted for duplicate)
-|  \- org.eclipse.jdt.core.compiler:ecj:jar:P20140317-1600:compile
-+- org.apache.tomcat.embed:tomcat-embed-websocket:jar:7.0.54:compile
-|  \- (org.apache.tomcat.embed:tomcat-embed-core:jar:7.0.54:compile - omitted for duplicate)
-+- org.apache.tomcat:tomcat-jdbc:jar:7.0.54:compile
-|  \- org.apache.tomcat:tomcat-juli:jar:7.0.54:compile
-+- org.apache.tomcat:tomcat-jsp-api:jar:7.0.54:compile
-|  +- org.apache.tomcat:tomcat-el-api:jar:7.0.54:compile
-|  \- org.apache.tomcat:tomcat-servlet-api:jar:7.0.54:compile
-+- org.apache.velocity:velocity:jar:1.7:compile
-|  +- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-|  \- commons-lang:commons-lang:jar:2.4:compile
-+- org.apache.velocity:velocity-tools:jar:2.0:compile
-|  +- (commons-beanutils:commons-beanutils:jar:1.7.0:compile - omitted for conflict with 1.9.2)
-|  +- (commons-digester:commons-digester:jar:1.8:compile - omitted for conflict with 2.1)
-|  +- commons-chain:commons-chain:jar:1.1:compile
-|  |  +- (commons-beanutils:commons-beanutils:jar:1.7.0:compile - omitted for conflict with 1.9.2)
-|  |  +- (commons-digester:commons-digester:jar:1.6:compile - omitted for conflict with 2.1)
-|  |  \- (commons-logging:commons-logging:jar:1.0.3:compile - omitted for conflict with 1.1.3)
-|  +- (commons-collections:commons-collections:jar:3.2:compile - omitted for conflict with 3.2.1)
-|  +- (commons-logging:commons-logging:jar:1.1:compile - omitted for conflict with 1.1.3)
-|  +- commons-validator:commons-validator:jar:1.3.1:compile
-|  |  +- (commons-beanutils:commons-beanutils:jar:1.7.0:compile - omitted for conflict with 1.9.2)
-|  |  +- (commons-digester:commons-digester:jar:1.6:compile - omitted for conflict with 2.1)
-|  |  \- (commons-logging:commons-logging:jar:1.0.4:compile - omitted for conflict with 1.1.3)
-|  +- dom4j:dom4j:jar:1.1:compile
-|  +- oro:oro:jar:2.0.8:compile
-|  +- sslext:sslext:jar:1.2-0:compile
-|  +- org.apache.struts:struts-core:jar:1.3.8:compile
-|  |  +- antlr:antlr:jar:2.7.7:compile
-|  |  +- (commons-beanutils:commons-beanutils:jar:1.7.0:compile - omitted for conflict with 1.9.2)
-|  |  +- (commons-chain:commons-chain:jar:1.1:compile - omitted for duplicate)
-|  |  +- (commons-digester:commons-digester:jar:1.8:compile - omitted for conflict with 2.1)
-|  |  +- (commons-logging:commons-logging:jar:1.0.4:compile - omitted for conflict with 1.1.3)
-|  |  +- (commons-validator:commons-validator:jar:1.3.1:compile - omitted for duplicate)
-|  |  \- (oro:oro:jar:2.0.8:compile - omitted for duplicate)
-|  +- org.apache.struts:struts-taglib:jar:1.3.8:compile
-|  |  \- (org.apache.struts:struts-core:jar:1.3.8:compile - omitted for duplicate)
-|  +- org.apache.struts:struts-tiles:jar:1.3.8:compile
-|  |  \- (org.apache.struts:struts-core:jar:1.3.8:compile - omitted for duplicate)
-|  \- (org.apache.velocity:velocity:jar:1.6.2:compile - omitted for conflict with 1.7)
-+- org.aspectj:aspectjrt:jar:1.8.0:compile
-+- org.aspectj:aspectjtools:jar:1.8.0:compile
-+- org.aspectj:aspectjweaver:jar:1.8.0:compile
-+- org.codehaus.groovy:groovy:jar:2.3.2:compile
-+- org.codehaus.groovy:groovy-all:jar:2.3.2:compile
-+- org.codehaus.groovy:groovy-ant:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-groovydoc:jar:2.3.2:compile - omitted for duplicate)
-|  +- org.apache.ant:ant-antlr:jar:1.9.3:runtime
-|  +- org.apache.ant:ant:jar:1.9.3:compile
-|  |  \- org.apache.ant:ant-launcher:jar:1.9.3:compile
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.apache.ant:ant-launcher:jar:1.9.3:compile - scope updated from runtime; omitted for duplicate)
-|  \- org.apache.ant:ant-junit:jar:1.9.3:runtime
-|     \- (org.apache.ant:ant:jar:1.9.3:runtime - omitted for duplicate)
-+- org.codehaus.groovy:groovy-bsf:jar:2.3.2:compile
-|  +- (commons-logging:commons-logging:jar:1.1.1:compile - omitted for conflict with 1.1.3)
-|  +- bsf:bsf:jar:2.4.0:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-console:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-swing:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.codehaus.groovy:groovy-templates:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-docgenerator:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-templates:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  \- com.thoughtworks.qdox:qdox:jar:1.12.1:compile
-+- org.codehaus.groovy:groovy-groovydoc:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-templates:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-groovysh:jar:2.3.2:compile
-|  +- jline:jline:jar:2.11:compile
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy-console:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-jmx:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-json:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-jsr223:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-nio:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-servlet:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-xml:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.codehaus.groovy:groovy-templates:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-sql:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-swing:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-templates:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy-xml:jar:2.3.2:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-test:jar:2.3.2:compile
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  \- (junit:junit:jar:4.11:compile - omitted for duplicate)
-+- org.codehaus.groovy:groovy-testng:jar:2.3.2:compile
-|  +- com.beust:jcommander:jar:1.35:compile
-|  +- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-|  \- org.testng:testng:jar:6.8.8:runtime
-+- org.codehaus.groovy:groovy-xml:jar:2.3.2:compile
-|  \- (org.codehaus.groovy:groovy:jar:2.3.2:compile - omitted for duplicate)
-+- org.crashub:crash.cli:jar:1.3.0-cr4:compile
-+- org.crashub:crash.connectors.ssh:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  +- org.apache.sshd:sshd-core:jar:0.11.0:compile
-|  |  \- (org.apache.mina:mina-core:jar:2.0.7:compile - omitted for duplicate)
-|  +- org.apache.sshd:sshd-pam:jar:0.11.0:compile
-|  |  +- (org.apache.sshd:sshd-core:jar:0.11.0:compile - omitted for duplicate)
-|  |  \- net.sf.jpam:jpam:jar:1.1:compile
-|  |     \- (commons-logging:commons-logging:jar:1.0.4:compile - omitted for conflict with 1.1.3)
-|  +- org.bouncycastle:bcprov-jdk15on:jar:1.49:compile
-|  +- org.bouncycastle:bcpkix-jdk15on:jar:1.49:compile
-|  |  \- (org.bouncycastle:bcprov-jdk15on:jar:1.49:compile - omitted for duplicate)
-|  \- org.apache.mina:mina-core:jar:2.0.7:compile
-|     \- (org.slf4j:slf4j-api:jar:1.6.6:compile - omitted for conflict with 1.7.6)
-+- org.crashub:crash.connectors.telnet:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  \- net.wimpi:telnetd-x:jar:2.1.1:compile
-|     +- (log4j:log4j:jar:1.2.9:compile - omitted for conflict with 1.2.17)
-|     \- (commons-logging:commons-logging:jar:1.1:compile - omitted for conflict with 1.1.3)
-+- org.crashub:crash.embed.spring:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:3.1.1.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-web:jar:3.1.1.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.1.1.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-beans:jar:3.1.1.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.crashub:crash.plugins.cron:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  \- it.sauronsoftware.cron4j:cron4j:jar:2.2.5:compile
-+- org.crashub:crash.plugins.mail:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.shell:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  \- javax.mail:mail:jar:1.4:compile
-|     \- javax.activation:activation:jar:1.1:compile
-+- org.crashub:crash.shell:jar:1.3.0-cr4:compile
-|  +- (org.crashub:crash.cli:jar:1.3.0-cr4:compile - omitted for duplicate)
-|  \- (org.codehaus.groovy:groovy-all:jar:1.8.9:compile - omitted for conflict with 2.3.2)
-+- org.eclipse.jetty:jetty-annotations:jar:8.1.15.v20140411:compile
-|  +- org.eclipse.jetty:jetty-plus:jar:8.1.15.v20140411:compile
-|  |  +- org.eclipse.jetty.orbit:javax.transaction:jar:1.1.1.v201105210645:compile
-|  |  +- (org.eclipse.jetty:jetty-webapp:jar:8.1.15.v20140411:compile - omitted for duplicate)
-|  |  \- org.eclipse.jetty:jetty-jndi:jar:8.1.15.v20140411:compile
-|  |     +- org.eclipse.jetty:jetty-server:jar:8.1.15.v20140411:compile
-|  |     |  +- (org.eclipse.jetty.orbit:javax.servlet:jar:3.0.0.v201112011016:compile - omitted for duplicate)
-|  |     |  +- org.eclipse.jetty:jetty-continuation:jar:8.1.15.v20140411:compile
-|  |     |  \- org.eclipse.jetty:jetty-http:jar:8.1.15.v20140411:compile
-|  |     |     \- org.eclipse.jetty:jetty-io:jar:8.1.15.v20140411:compile
-|  |     |        \- (org.eclipse.jetty:jetty-util:jar:8.1.15.v20140411:compile - omitted for duplicate)
-|  |     \- org.eclipse.jetty.orbit:javax.mail.glassfish:jar:1.4.1.v201005082020:compile
-|  |        \- org.eclipse.jetty.orbit:javax.activation:jar:1.1.0.v201105071233:compile
-|  +- (org.eclipse.jetty:jetty-webapp:jar:8.1.15.v20140411:compile - omitted for duplicate)
-|  +- org.eclipse.jetty.orbit:javax.annotation:jar:1.1.0.v201108011116:compile
-|  \- org.eclipse.jetty.orbit:org.objectweb.asm:jar:3.1.0.v200803061910:compile
-+- org.eclipse.jetty:jetty-jsp:jar:8.1.15.v20140411:compile
-|  +- (org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.2.0.v201112011158:compile - omitted for duplicate)
-|  +- org.eclipse.jetty.orbit:org.apache.jasper.glassfish:jar:2.2.2.v201112011158:compile
-|  |  \- (org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.2.0.v201112011158:compile - omitted for duplicate)
-|  +- org.eclipse.jetty.orbit:javax.servlet.jsp.jstl:jar:1.2.0.v201105211821:compile
-|  |  \- (org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.1.0.v201105211820:compile - omitted for conflict with 2.2.0.v201112011158)
-|  +- org.eclipse.jetty.orbit:org.apache.taglibs.standard.glassfish:jar:1.2.0.v201112081803:compile
-|  |  \- (org.eclipse.jetty.orbit:javax.servlet.jsp.jstl:jar:1.2.0.v201105211821:compile - omitted for duplicate)
-|  +- org.eclipse.jetty.orbit:javax.el:jar:2.2.0.v201108011116:compile
-|  +- org.eclipse.jetty.orbit:com.sun.el:jar:2.2.0.v201108011116:compile
-|  \- org.eclipse.jetty.orbit:org.eclipse.jdt.core:jar:3.7.1:compile
-+- org.eclipse.jetty:jetty-webapp:jar:8.1.15.v20140411:compile
-|  +- org.eclipse.jetty:jetty-xml:jar:8.1.15.v20140411:compile
-|  |  \- (org.eclipse.jetty:jetty-util:jar:8.1.15.v20140411:compile - omitted for duplicate)
-|  \- org.eclipse.jetty:jetty-servlet:jar:8.1.15.v20140411:compile
-|     \- org.eclipse.jetty:jetty-security:jar:8.1.15.v20140411:compile
-|        \- (org.eclipse.jetty:jetty-server:jar:8.1.15.v20140411:compile - omitted for duplicate)
-+- org.eclipse.jetty:jetty-util:jar:8.1.15.v20140411:compile
-+- org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.2.0.v201112011158:compile
-|  \- org.eclipse.jetty.orbit:javax.servlet:jar:3.0.0.v201112011016:compile
-+- org.freemarker:freemarker:jar:2.3.20:compile
-+- org.flywaydb:flyway-core:jar:3.0:compile
-+- org.hamcrest:hamcrest-core:jar:1.3:compile
-+- org.hamcrest:hamcrest-library:jar:1.3:compile
-|  \- (org.hamcrest:hamcrest-core:jar:1.3:compile - omitted for duplicate)
-+- org.hibernate:hibernate-entitymanager:jar:4.3.1.Final:compile
-|  +- org.jboss.logging:jboss-logging:jar:3.1.3.GA:compile
-|  +- org.jboss.logging:jboss-logging-annotations:jar:1.2.0.Beta1:compile
-|  +- org.hibernate:hibernate-core:jar:4.3.1.Final:compile
-|  |  +- (org.jboss.logging:jboss-logging:jar:3.1.3.GA:compile - omitted for duplicate)
-|  |  +- (org.jboss.logging:jboss-logging-annotations:jar:1.2.0.Beta1:compile - omitted for duplicate)
-|  |  +- (org.jboss.spec.javax.transaction:jboss-transaction-api_1.2_spec:jar:1.0.0.Final:compile - omitted for duplicate)
-|  |  +- (dom4j:dom4j:jar:1.6.1:compile - omitted for conflict with 1.1)
-|  |  +- (org.hibernate.common:hibernate-commons-annotations:jar:4.0.4.Final:compile - omitted for duplicate)
-|  |  +- (org.hibernate.javax.persistence:hibernate-jpa-2.1-api:jar:1.0.0.Final:compile - omitted for duplicate)
-|  |  +- (org.javassist:javassist:jar:3.18.1-GA:compile - omitted for duplicate)
-|  |  +- (antlr:antlr:jar:2.7.7:compile - omitted for duplicate)
-|  |  \- org.jboss:jandex:jar:1.1.0.Final:compile
-|  +- (dom4j:dom4j:jar:1.6.1:compile - omitted for conflict with 1.1)
-|  +- org.hibernate.common:hibernate-commons-annotations:jar:4.0.4.Final:compile
-|  |  +- (org.jboss.logging:jboss-logging:jar:3.1.3.GA:compile - omitted for duplicate)
-|  |  \- (org.jboss.logging:jboss-logging-annotations:jar:1.2.0.Beta1:compile - omitted for duplicate)
-|  +- org.hibernate.javax.persistence:hibernate-jpa-2.1-api:jar:1.0.0.Final:compile
-|  +- org.jboss.spec.javax.transaction:jboss-transaction-api_1.2_spec:jar:1.0.0.Final:compile
-|  \- (org.javassist:javassist:jar:3.18.1-GA:compile - omitted for duplicate)
-+- org.hibernate:hibernate-validator:jar:5.0.3.Final:compile
-|  +- javax.validation:validation-api:jar:1.1.0.Final:compile
-|  +- (org.jboss.logging:jboss-logging:jar:3.1.1.GA:compile - omitted for conflict with 3.1.3.GA)
-|  \- com.fasterxml:classmate:jar:1.0.0:compile
-+- org.hibernate.javax.persistence:hibernate-jpa-2.0-api:jar:1.0.1.Final:compile
-+- org.hornetq:hornetq-jms-server:jar:2.4.1.Final:compile
-|  +- org.hornetq:hornetq-core-client:jar:2.4.1.Final:compile
-|  |  +- org.jgroups:jgroups:jar:3.3.4.Final:compile
-|  |  +- org.hornetq:hornetq-commons:jar:2.4.1.Final:compile
-|  |  |  +- (org.jboss.logging:jboss-logging:jar:3.1.0.GA:compile - omitted for conflict with 3.1.3.GA)
-|  |  |  \- (io.netty:netty-all:jar:4.0.13.Final:compile - omitted for duplicate)
-|  |  +- org.hornetq:hornetq-journal:jar:2.4.1.Final:compile
-|  |  |  +- (org.jboss.logging:jboss-logging:jar:3.1.0.GA:compile - omitted for conflict with 3.1.3.GA)
-|  |  |  +- (org.hornetq:hornetq-commons:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  |  \- org.hornetq:hornetq-native:jar:2.4.1.Final:compile
-|  |  |     \- (org.hornetq:hornetq-commons:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  \- (io.netty:netty-all:jar:4.0.13.Final:compile - omitted for conflict with 4.0.19.Final)
-|  +- (org.hornetq:hornetq-jms-client:jar:2.4.1.Final:compile - omitted for duplicate)
-|  +- org.hornetq:hornetq-server:jar:2.4.1.Final:compile
-|  |  +- (org.jboss.logging:jboss-logging:jar:3.1.0.GA:compile - omitted for conflict with 3.1.3.GA)
-|  |  +- (org.hornetq:hornetq-commons:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  +- (org.hornetq:hornetq-journal:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  +- (org.hornetq:hornetq-core-client:jar:2.4.1.Final:compile - omitted for duplicate)
-|  |  \- (io.netty:netty-all:jar:4.0.13.Final:compile - omitted for duplicate)
-|  +- org.jboss.spec.javax.jms:jboss-jms-api_2.0_spec:jar:1.0.0.Final:compile
-|  +- org.jboss.spec.javax.transaction:jboss-transaction-api_1.1_spec:jar:1.0.0.Final:compile
-|  +- org.jboss:jboss-transaction-spi:jar:7.0.0.Final:compile
-|  |  +- org.jboss.spec.javax.resource:jboss-connector-api_1.5_spec:jar:1.0.0.Final:compile
-|  |  |  \- (org.jboss.spec.javax.transaction:jboss-transaction-api_1.1_spec:jar:1.0.0.Final:compile - omitted for duplicate)
-|  |  \- (org.jboss.spec.javax.transaction:jboss-transaction-api_1.1_spec:jar:1.0.1.Beta1:compile - omitted for conflict with 1.0.0.Final)
-|  \- org.jboss.naming:jnpserver:jar:5.0.3.GA:compile
-|     \- org.jboss:jboss-common-core:jar:2.2.10.GA:compile
-+- org.hornetq:hornetq-jms-client:jar:2.4.1.Final:compile
-|  +- (org.hornetq:hornetq-core-client:jar:2.4.1.Final:compile - omitted for duplicate)
-|  +- (org.jboss.spec.javax.jms:jboss-jms-api_2.0_spec:jar:1.0.0.Final:compile - omitted for duplicate)
-|  \- javax.inject:javax.inject:jar:1:compile
-+- org.hsqldb:hsqldb:jar:2.3.2:compile
-+- org.javassist:javassist:jar:3.18.1-GA:compile
-+- org.jolokia:jolokia-core:jar:1.2.1:compile
-|  \- com.googlecode.json-simple:json-simple:jar:1.1:compile
-+- org.liquibase:liquibase-core:jar:3.0.8:compile
-|  \- (org.yaml:snakeyaml:jar:1.13:compile - omitted for duplicate)
-+- org.mongodb:mongo-java-driver:jar:2.12.1:compile
-+- org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile
-|  +- com.goldmansachs:gs-collections:jar:5.0.0:compile
-|  |  \- com.goldmansachs:gs-collections-api:jar:5.0.0:compile
-|  +- com.lmax:disruptor:jar:3.2.1:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor:reactor-groovy:jar:1.1.2.RELEASE:compile
-|  +- (org.codehaus.groovy:groovy-all:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.projectreactor:reactor-groovy-extensions:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor:reactor-groovy-extensions:jar:1.1.2.RELEASE:compile
-|  +- (org.codehaus.groovy:groovy-all:jar:2.3.2:compile - omitted for duplicate)
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor:reactor-logback:jar:1.1.2.RELEASE:compile
-|  +- (ch.qos.logback:logback-classic:jar:1.1.2:compile - omitted for duplicate)
-|  +- commons-cli:commons-cli:jar:1.2:compile
-|  +- net.openhft:chronicle:jar:2.0.3:compile
-|  |  +- net.openhft:lang:jar:6.1.4:compile
-|  |  |  \- (org.kohsuke.jetbrains:annotations:jar:9.0:compile - omitted for duplicate)
-|  |  \- org.kohsuke.jetbrains:annotations:jar:9.0:compile
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor:reactor-net:jar:1.1.2.RELEASE:compile
-|  +- io.netty:netty-all:jar:4.0.19.Final:compile
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.projectreactor.spring:reactor-spring-core:jar:1.1.2.RELEASE:compile
-|  +- (org.projectreactor:reactor-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-|  +- (org.springframework:spring-beans:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-context:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-core:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (org.springframework:spring-expression:jar:4.0.3.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.projectreactor.spring:reactor-spring-context:jar:1.1.2.RELEASE:compile
-|  +- com.jayway.jsonpath:json-path:jar:0.9.0:compile
-|  |  +- net.minidev:json-smart:jar:1.2:compile
-|  |  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.6)
-|  +- (org.projectreactor.spring:reactor-spring-core:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-|  \- (org.springframework:spring-context-support:jar:4.0.3.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.projectreactor.spring:reactor-spring-messaging:jar:1.1.2.RELEASE:compile
-|  +- (org.projectreactor.spring:reactor-spring-context:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.projectreactor:reactor-net:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-|  \- (org.springframework:spring-messaging:jar:4.0.3.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.projectreactor.spring:reactor-spring-webmvc:jar:1.1.2.RELEASE:compile
-|  +- (org.projectreactor.spring:reactor-spring-context:jar:1.1.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-|  \- (org.springframework:spring-webmvc:jar:4.0.3.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.mockito:mockito-core:jar:1.9.5:compile
-|  +- (org.hamcrest:hamcrest-core:jar:1.1:compile - omitted for conflict with 1.3)
-|  \- org.objenesis:objenesis:jar:1.0:compile
-+- org.slf4j:jcl-over-slf4j:jar:1.7.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.slf4j:log4j-over-slf4j:jar:1.7.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for conflict with 1.7.6)
-+- org.slf4j:slf4j-api:jar:1.7.7:compile
-+- org.slf4j:jul-to-slf4j:jar:1.7.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-+- org.slf4j:slf4j-jdk14:jar:1.7.7:compile
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-+- org.slf4j:slf4j-log4j12:jar:1.7.7:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (log4j:log4j:jar:1.2.17:compile - omitted for duplicate)
-+- org.apache.solr:solr-solrj:jar:4.7.2:compile
-|  +- commons-io:commons-io:jar:2.1:compile
-|  +- (log4j:log4j:jar:1.2.16:compile - omitted for conflict with 1.2.17)
-|  +- (org.apache.httpcomponents:httpclient:jar:4.3.1:compile - omitted for conflict with 4.3.3)
-|  +- (org.apache.httpcomponents:httpcore:jar:4.3:compile - omitted for conflict with 4.3.2)
-|  +- (org.apache.httpcomponents:httpmime:jar:4.3.1:compile - omitted for conflict with 4.3.3)
-|  +- org.apache.zookeeper:zookeeper:jar:3.4.5:compile
-|  +- org.codehaus.woodstox:wstx-asl:jar:3.2.7:compile
-|  +- org.noggit:noggit:jar:0.5:compile
-|  \- (org.slf4j:slf4j-api:jar:1.6.6:compile - omitted for conflict with 1.7.7)
-+- org.spockframework:spock-core:jar:0.7-groovy-2.0:compile
-|  +- junit:junit-dep:jar:4.10:compile
-|  |  \- (org.hamcrest:hamcrest-core:jar:1.1:compile - omitted for conflict with 1.3)
-|  \- (org.hamcrest:hamcrest-core:jar:1.3:compile - omitted for duplicate)
-+- org.springframework:spring-core:jar:4.0.5.RELEASE:compile
-|  \- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)
-+- org.springframework:springloaded:jar:1.2.0.RELEASE:compile
-+- org.springframework.amqp:spring-amqp:jar:1.3.4.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.amqp:spring-erlang:jar:1.3.4.RELEASE:compile
-|  +- org.erlang.otp:jinterface:jar:1.5.6:compile
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (commons-io:commons-io:jar:2.4:compile - omitted for conflict with 2.1)
-+- org.springframework.amqp:spring-rabbit:jar:1.3.4.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- org.springframework.retry:spring-retry:jar:1.1.0.RELEASE:compile
-|  |  \- (org.springframework:spring-context:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework.amqp:spring-amqp:jar:1.3.4.RELEASE:compile - omitted for duplicate)
-|  \- com.rabbitmq:amqp-client:jar:3.3.1:compile
-+- org.springframework.batch:spring-batch-core:jar:3.0.0.RELEASE:compile
-|  +- com.ibm.jbatch:com.ibm.jbatch-tck-spi:jar:1.0:compile
-|  |  \- javax.batch:javax.batch-api:jar:1.0:compile
-|  +- com.thoughtworks.xstream:xstream:jar:1.4.7:compile
-|  |  +- xmlpull:xmlpull:jar:1.1.3.1:compile
-|  |  \- xpp3:xpp3_min:jar:1.1.4c:compile
-|  +- org.codehaus.jettison:jettison:jar:1.2:compile
-|  +- (org.springframework.batch:spring-batch-infrastructure:jar:3.0.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework.batch:spring-batch-infrastructure:jar:3.0.0.RELEASE:compile
-|  +- (org.springframework.retry:spring-retry:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework.batch:spring-batch-integration:jar:3.0.0.RELEASE:compile
-|  +- (org.springframework.batch:spring-batch-core:jar:3.0.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.1.RELEASE:compile - omitted for conflict with 4.0.2.RELEASE)
-|  +- (org.springframework.retry:spring-retry:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-messaging:jar:4.0.5.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework.batch:spring-batch-test:jar:3.0.0.RELEASE:compile
-|  +- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-|  +- (commons-io:commons-io:jar:2.4:compile - omitted for conflict with 2.1)
-|  +- (junit:junit:jar:4.10:compile - omitted for conflict with 4.11)
-|  +- org.hamcrest:hamcrest-all:jar:1.3:compile
-|  +- (org.springframework.batch:spring-batch-core:jar:3.0.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-jdbc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-test:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework.hateoas:spring-hateoas:jar:0.12.0.RELEASE:compile
-|  +- (org.springframework:spring-aop:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-web:jar:3.2.9.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework:spring-webmvc:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-|  +- (org.objenesis:objenesis:jar:2.1:compile - omitted for conflict with 1.0)
-|  \- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-http:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-webmvc:jar:4.0.5.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-|  +- net.java.dev.rome:rome-fetcher:jar:1.0.0:compile
-|  |  +- jdom:jdom:jar:1.0:compile
-|  |  +- xerces:xercesImpl:jar:2.4.0:compile
-|  |  +- (net.java.dev.rome:rome:jar:1.0.0:compile - omitted for duplicate)
-|  |  +- commons-httpclient:commons-httpclient:jar:3.0.1:compile
-|  |  |  +- (commons-logging:commons-logging:jar:1.0.3:compile - omitted for conflict with 1.1.3)
-|  |  |  \- (commons-codec:commons-codec:jar:1.2:compile - omitted for conflict with 1.6)
-|  |  +- (commons-logging:commons-logging:jar:1.0.4:compile - omitted for conflict with 1.1.3)
-|  |  \- commons-logging:commons-logging-api:jar:1.0.4:compile
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for conflict with 4.0.1.RELEASE)
-+- org.springframework.mobile:spring-mobile-device:jar:1.1.2.RELEASE:compile
-|  +- (org.springframework:spring-webmvc:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-|  \- (org.springframework:spring-web:jar:3.2.9.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-+- org.springframework.security:spring-security-jwt:jar:1.0.2.RELEASE:compile
-|  +- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile
-|  |  \- (org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile - omitted for conflict with 1.9.12)
-|  \- (org.bouncycastle:bcpkix-jdk15on:jar:1.47:compile - omitted for conflict with 1.49)
-+- org.springframework.social:spring-social-config:jar:1.1.0.RELEASE:compile
-|  +- (org.springframework.social:spring-social-web:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile
-|  \- (org.springframework:spring-web:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-+- org.springframework.social:spring-social-security:jar:1.1.0.RELEASE:compile
-|  +- (org.springframework.social:spring-social-web:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-web:jar:3.2.3.RELEASE:compile - omitted for conflict with 3.2.4.RELEASE)
-|  +- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-web:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (org.springframework:spring-webmvc:jar:4.0.3.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-web:jar:1.1.0.RELEASE:compile
-|  +- (javax.inject:javax.inject:jar:1:compile - omitted for duplicate)
-|  +- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-web:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (org.springframework:spring-webmvc:jar:4.0.3.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-facebook:jar:1.1.1.RELEASE:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (org.springframework.social:spring-social-config:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  \- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-facebook-web:jar:1.1.1.RELEASE:compile
-|  +- (org.springframework:spring-web:jar:4.0.3.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  +- (org.springframework.social:spring-social-facebook:jar:1.1.1.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-webmvc:jar:4.0.3.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-twitter:jar:1.1.0.RELEASE:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (org.springframework.security:spring-security-crypto:jar:3.2.3.RELEASE:compile - omitted for conflict with 3.2.4.RELEASE)
-|  +- (org.springframework.social:spring-social-config:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  \- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.social:spring-social-linkedin:jar:1.0.1.RELEASE:compile
-|  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (org.springframework.social:spring-social-core:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.social:spring-social-config:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-+- org.thymeleaf:thymeleaf:jar:2.1.3.RELEASE:compile
-|  +- ognl:ognl:jar:3.0.6:compile
-|  +- (org.javassist:javassist:jar:3.16.1-GA:compile - omitted for conflict with 3.18.1-GA)
-|  +- org.unbescape:unbescape:jar:1.0:compile
-|  \- (org.slf4j:slf4j-api:jar:1.6.1:compile - omitted for conflict with 1.7.7)
-+- org.thymeleaf.extras:thymeleaf-extras-springsecurity3:jar:2.1.1.RELEASE:compile
-|  +- (org.thymeleaf:thymeleaf:jar:2.1.2.RELEASE:compile - omitted for conflict with 2.1.3.RELEASE)
-|  \- (org.slf4j:slf4j-api:jar:1.6.1:compile - omitted for conflict with 1.7.7)
-+- org.thymeleaf:thymeleaf-spring4:jar:2.1.3.RELEASE:compile
-|  +- (org.thymeleaf:thymeleaf:jar:2.1.3.RELEASE:compile - omitted for duplicate)
-|  \- (org.slf4j:slf4j-api:jar:1.6.1:compile - omitted for conflict with 1.7.7)
-+- org.yaml:snakeyaml:jar:1.13:compile
-+- redis.clients:jedis:jar:2.4.1:compile
-|  \- (org.apache.commons:commons-pool2:jar:2.0:compile - omitted for conflict with 2.2)
-+- org.springframework:spring-aop:jar:4.0.5.RELEASE:compile
-|  +- aopalliance:aopalliance:jar:1.0:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.1.1.RELEASE)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-aspects:jar:4.0.5.RELEASE:compile
-|  \- (org.aspectj:aspectjweaver:jar:1.7.4:compile - omitted for conflict with 1.8.0)
-+- org.springframework:spring-beans:jar:4.0.5.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-context:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-expression:jar:4.0.5.RELEASE:compile - omitted for conflict with 4.0.3.RELEASE)
-+- org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-expression:jar:4.0.5.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-instrument:jar:4.0.5.RELEASE:compile
-+- org.springframework:spring-instrument-tomcat:jar:4.0.5.RELEASE:compile
-+- org.springframework:spring-jdbc:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework:spring-jms:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework:spring-messaging:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-orm:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-jdbc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for conflict with 3.2.8.RELEASE)
-+- org.springframework:spring-oxm:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-test:jar:4.0.5.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-tx:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-web:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-webmvc:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-expression:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-web:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-webmvc-portlet:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-beans:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-web:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-webmvc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework:spring-websocket:jar:4.0.5.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-core:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-web:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework.data:spring-data-cassandra:jar:1.0.0.RELEASE:compile
-|  +- org.springframework.data:spring-cql:jar:1.0.0.RELEASE:compile
-|  |  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework:spring-expression:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  |  +- (com.datastax.cassandra:cassandra-driver-dse:jar:2.0.2:compile - omitted for duplicate)
-|  |  +- org.apache.cassandra:cassandra-all:jar:2.0.6:compile
-|  |  |  +- org.xerial.snappy:snappy-java:jar:1.0.5:compile
-|  |  |  +- net.jpountz.lz4:lz4:jar:1.2.0:compile
-|  |  |  +- com.ning:compress-lzf:jar:0.8.4:compile
-|  |  |  +- (commons-cli:commons-cli:jar:1.1:compile - omitted for conflict with 1.2)
-|  |  |  +- (commons-codec:commons-codec:jar:1.2:compile - omitted for conflict with 1.6)
-|  |  |  +- (org.apache.commons:commons-lang3:jar:3.1:compile - omitted for duplicate)
-|  |  |  +- (com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:jar:1.3:compile - omitted for conflict with 1.3.1)
-|  |  |  +- org.antlr:antlr:jar:3.2:compile
-|  |  |  |  \- org.antlr:antlr-runtime:jar:3.2:compile
-|  |  |  |     \- org.antlr:stringtemplate:jar:3.2:compile
-|  |  |  |        \- (antlr:antlr:jar:2.7.7:compile - omitted for duplicate)
-|  |  |  +- (org.slf4j:slf4j-api:jar:1.7.2:compile - omitted for conflict with 1.7.7)
-|  |  |  +- (org.codehaus.jackson:jackson-core-asl:jar:1.9.2:compile - omitted for conflict with 1.9.13)
-|  |  |  +- (org.codehaus.jackson:jackson-mapper-asl:jar:1.9.2:compile - omitted for conflict with 1.9.13)
-|  |  |  +- (jline:jline:jar:1.0:compile - omitted for conflict with 2.11)
-|  |  |  +- (com.googlecode.json-simple:json-simple:jar:1.1:compile - omitted for duplicate)
-|  |  |  +- com.github.stephenc.high-scale-lib:high-scale-lib:jar:1.1.2:compile
-|  |  |  +- (org.yaml:snakeyaml:jar:1.11:compile - omitted for conflict with 1.13)
-|  |  |  +- edu.stanford.ppl:snaptree:jar:0.1:compile
-|  |  |  +- org.mindrot:jbcrypt:jar:0.3m:compile
-|  |  |  +- com.yammer.metrics:metrics-core:jar:2.2.0:compile
-|  |  |  |  \- (org.slf4j:slf4j-api:jar:1.7.2:compile - omitted for conflict with 1.7.7)
-|  |  |  +- com.addthis.metrics:reporter-config:jar:2.1.0:compile
-|  |  |  |  +- (org.slf4j:slf4j-api:jar:1.7.2:compile - omitted for conflict with 1.7.7)
-|  |  |  |  +- (org.yaml:snakeyaml:jar:1.12:compile - omitted for conflict with 1.13)
-|  |  |  |  +- (org.hibernate:hibernate-validator:jar:4.3.0.Final:compile - omitted for conflict with 5.0.3.Final)
-|  |  |  |  \- (com.yammer.metrics:metrics-core:jar:2.2.0:compile - omitted for duplicate)
-|  |  |  +- com.thinkaurelius.thrift:thrift-server:jar:0.3.3:compile
-|  |  |  |  +- (com.lmax:disruptor:jar:3.0.1:compile - omitted for conflict with 3.2.1)
-|  |  |  |  +- (org.apache.thrift:libthrift:jar:0.9.1:compile - omitted for duplicate)
-|  |  |  |  +- (org.slf4j:slf4j-api:jar:1.6.1:compile - omitted for conflict with 1.7.7)
-|  |  |  |  \- (junit:junit:jar:4.8.1:compile - omitted for conflict with 4.11)
-|  |  |  +- net.sf.supercsv:super-csv:jar:2.1.0:compile
-|  |  |  +- (log4j:log4j:jar:1.2.16:compile - omitted for conflict with 1.2.17)
-|  |  |  +- org.apache.thrift:libthrift:jar:0.9.1:compile
-|  |  |  |  +- (org.slf4j:slf4j-api:jar:1.5.8:compile - omitted for conflict with 1.7.7)
-|  |  |  |  +- (org.apache.commons:commons-lang3:jar:3.1:compile - omitted for duplicate)
-|  |  |  |  +- (org.apache.httpcomponents:httpclient:jar:4.2.5:compile - omitted for conflict with 4.3.3)
-|  |  |  |  \- (org.apache.httpcomponents:httpcore:jar:4.2.4:compile - omitted for conflict with 4.3.2)
-|  |  |  +- org.apache.cassandra:cassandra-thrift:jar:2.0.6:compile
-|  |  |  |  +- (org.apache.commons:commons-lang3:jar:3.1:compile - omitted for duplicate)
-|  |  |  |  +- (org.slf4j:slf4j-api:jar:1.7.2:compile - omitted for conflict with 1.7.7)
-|  |  |  |  \- (org.apache.thrift:libthrift:jar:0.9.1:compile - omitted for duplicate)
-|  |  |  +- com.github.stephenc:jamm:jar:0.2.5:compile
-|  |  |  \- (io.netty:netty:jar:3.6.6.Final:compile - omitted for conflict with 3.5.5.Final)
-|  |  +- (com.google.guava:guava:jar:15.0:compile - omitted for conflict with 16.0.1)
-|  |  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  |  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-|  +- (org.springframework:spring-expression:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- com.datastax.cassandra:cassandra-driver-dse:jar:2.0.2:compile
-|  |  \- com.datastax.cassandra:cassandra-driver-core:jar:2.0.2:compile
-|  |     +- (io.netty:netty:jar:3.9.0.Final:compile - omitted for conflict with 3.6.6.Final)
-|  |     \- (com.codahale.metrics:metrics-core:jar:3.0.2:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-couchbase:jar:1.1.0.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-web:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- com.couchbase.client:couchbase-client:jar:1.4.1:compile
-|  |  +- io.netty:netty:jar:3.5.5.Final:compile
-|  |  +- (org.codehaus.jettison:jettison:jar:1.1:compile - omitted for conflict with 1.2)
-|  |  +- (commons-codec:commons-codec:jar:1.5:compile - omitted for conflict with 1.6)
-|  |  +- net.spy:spymemcached:jar:2.11.2:compile
-|  |  +- (org.apache.httpcomponents:httpcore:jar:4.3:compile - omitted for conflict with 4.3.2)
-|  |  \- (org.apache.httpcomponents:httpcore-nio:jar:4.3:compile - omitted for conflict with 4.3.2)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.2:compile - omitted for conflict with 2.3.3)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-elasticsearch:jar:1.0.0.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- (commons-lang:commons-lang:jar:2.6:compile - omitted for conflict with 2.4)
-|  +- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-|  +- (joda-time:joda-time:jar:2.3:compile - omitted for duplicate)
-|  +- org.elasticsearch:elasticsearch:jar:1.1.1:compile
-|  |  +- org.apache.lucene:lucene-core:jar:4.7.2:compile
-|  |  +- org.apache.lucene:lucene-analyzers-common:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-codecs:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-queries:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-memory:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-highlighter:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  +- (org.apache.lucene:lucene-memory:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-queryparser:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  +- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-sandbox:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-sandbox:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-suggest:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-analyzers-common:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  +- (org.apache.lucene:lucene-misc:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-misc:jar:4.7.2:compile
-|  |  |  \- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-join:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-grouping:jar:4.7.2:compile - omitted for duplicate)
-|  |  +- org.apache.lucene:lucene-grouping:jar:4.7.2:compile
-|  |  |  +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |  \- org.apache.lucene:lucene-spatial:jar:4.7.2:compile
-|  |     +- (org.apache.lucene:lucene-core:jar:4.7.2:compile - omitted for duplicate)
-|  |     +- (org.apache.lucene:lucene-queries:jar:4.7.2:compile - omitted for duplicate)
-|  |     \- com.spatial4j:spatial4j:jar:0.4.1:compile
-|  +- (com.fasterxml.jackson.core:jackson-core:jar:2.3.3:compile - omitted for duplicate)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-gemfire:jar:1.4.0.RELEASE:compile
-|  +- (antlr:antlr:jar:2.7.7:compile - scope updated from runtime; omitted for duplicate)
-|  +- (org.slf4j:jcl-over-slf4j:jar:1.7.6:compile - omitted for conflict with 1.7.7)
-|  +- (org.aspectj:aspectjweaver:jar:1.7.4:compile - omitted for conflict with 1.8.0)
-|  +- (org.slf4j:slf4j-api:jar:1.7.6:compile - omitted for conflict with 1.7.7)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- (com.gemstone.gemfire:gemfire:jar:7.0.2:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.codehaus.jackson:jackson-mapper-asl:jar:1.9.12:compile - omitted for conflict with 1.9.13)
-|  +- (org.springframework:spring-aop:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context-support:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- org.codehaus.jackson:jackson-core-asl:jar:1.9.12:compile
-+- org.springframework.data:spring-data-jpa:jar:1.6.0.RELEASE:compile
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-orm:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-aop:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.aspectj:aspectjrt:jar:1.8.0:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-mongodb:jar:1.5.0.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-expression:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.mongodb:mongo-java-driver:jar:2.12.1:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-neo4j:jar:3.1.0.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-aspects:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-expression:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.aspectj:aspectjrt:jar:1.8.0:compile - omitted for duplicate)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- org.neo4j:neo4j-cypher-dsl:jar:2.0.1:compile
-|  +- org.neo4j:neo4j:jar:2.0.3:compile
-|  |  +- org.neo4j:neo4j-kernel:jar:2.0.3:compile
-|  |  |  \- org.apache.geronimo.specs:geronimo-jta_1.1_spec:jar:1.1.1:compile
-|  |  +- org.neo4j:neo4j-lucene-index:jar:2.0.3:compile
-|  |  |  +- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  \- (org.apache.lucene:lucene-core:jar:3.6.2:compile - omitted for conflict with 4.7.2)
-|  |  +- org.neo4j:neo4j-graph-algo:jar:2.0.3:compile
-|  |  |  \- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-udc:jar:2.0.3:compile
-|  |  |  \- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-graph-matching:jar:2.0.3:compile
-|  |  |  \- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- (org.neo4j:neo4j-cypher:jar:2.0.3:compile - omitted for duplicate)
-|  |  \- org.neo4j:neo4j-jmx:jar:2.0.3:compile
-|  +- org.neo4j:neo4j-cypher:jar:2.0.3:compile
-|  |  +- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- (org.neo4j:neo4j-lucene-index:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- (org.neo4j:neo4j-graph-matching:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- (org.neo4j:neo4j-graph-algo:jar:2.0.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-cypher-commons:jar:2.0.3:compile
-|  |  |  +- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  +- (com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:jar:1.3.1:compile - omitted for conflict with 1.3)
-|  |  |  \- (org.scala-lang:scala-library:jar:2.10.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-cypher-compiler-1.9:jar:2.0.3:compile
-|  |  |  +- (org.neo4j:neo4j-kernel:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  +- (org.neo4j:neo4j-lucene-index:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  +- (org.neo4j:neo4j-graph-matching:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  +- (org.neo4j:neo4j-graph-algo:jar:2.0.3:compile - omitted for duplicate)
-|  |  |  \- (org.scala-lang:scala-library:jar:2.10.3:compile - omitted for duplicate)
-|  |  +- org.neo4j:neo4j-cypher-compiler-2.0:jar:2.0.3:compile
-|  |  |  +- org.parboiled:parboiled-scala_2.10:jar:1.1.6:compile
-|  |  |  |  \- org.parboiled:parboiled-core:jar:1.1.6:compile
-|  |  |  +- net.sf.opencsv:opencsv:jar:2.0:compile
-|  |  |  \- (org.scala-lang:scala-library:jar:2.10.3:compile - omitted for duplicate)
-|  |  +- com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:jar:1.3.1:compile
-|  |  \- org.scala-lang:scala-library:jar:2.10.3:compile
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-redis:jar:1.3.0.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-aop:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context-support:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.slf4j:slf4j-api:jar:1.7.5:compile - omitted for conflict with 1.7.7)
-+- org.springframework.data:spring-data-rest-webmvc:jar:2.1.0.RELEASE:compile
-|  +- org.springframework.data:spring-data-rest-core:jar:2.1.0.RELEASE:compile
-|  |  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  +- (org.springframework.hateoas:spring-hateoas:jar:0.12.0.RELEASE:compile - omitted for duplicate)
-|  |  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  |  +- org.springframework.plugin:spring-plugin-core:jar:1.1.0.RELEASE:compile
-|  |  |  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  |  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  |  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  |  |  \- (org.slf4j:slf4j-api:jar:1.7.6:compile - omitted for conflict with 1.7.7)
-|  |  +- org.atteo:evo-inflector:jar:1.1:compile
-|  |  +- (com.fasterxml.jackson.core:jackson-annotations:jar:2.3.3:compile - omitted for duplicate)
-|  |  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  |  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-|  +- (org.springframework:spring-webmvc:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (com.fasterxml.jackson.core:jackson-databind:jar:2.3.3:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.data:spring-data-solr:jar:1.2.0.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-tx:jar:3.2.9.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework.data:spring-data-commons:jar:1.8.0.RELEASE:compile - omitted for duplicate)
-|  +- org.apache.commons:commons-lang3:jar:3.1:compile
-|  +- (commons-collections:commons-collections:jar:3.2.1:compile - omitted for duplicate)
-|  +- (org.apache.httpcomponents:httpclient:jar:4.2.2:compile - omitted for conflict with 4.3.3)
-|  +- (org.apache.httpcomponents:httpmime:jar:4.2.2:compile - omitted for conflict with 4.3.3)
-|  +- org.apache.httpcomponents:httpclient-cache:jar:4.2.2:compile
-|  |  \- (org.apache.httpcomponents:httpclient:jar:4.2.2:compile - omitted for conflict with 4.3.3)
-|  +- (org.apache.solr:solr-solrj:jar:4.7.2:compile - omitted for duplicate)
-|  +- (org.slf4j:slf4j-api:jar:1.7.7:compile - omitted for duplicate)
-|  \- (org.slf4j:jcl-over-slf4j:jar:1.7.7:runtime - omitted for duplicate)
-+- org.springframework.integration:spring-integration-amqp:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.amqp:spring-rabbit:jar:1.3.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for conflict with 4.0.1.RELEASE)
-+- org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.retry:spring-retry:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-messaging:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-event:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-feed:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (net.java.dev.rome:rome-fetcher:jar:1.0.0:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- net.java.dev.rome:rome:jar:1.0.0:compile
-|     \- (jdom:jdom:jar:1.0:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-file:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (commons-io:commons-io:jar:2.4:compile - omitted for conflict with 2.1)
-+- org.springframework.integration:spring-integration-ftp:jar:4.0.2.RELEASE:compile
-|  +- commons-net:commons-net:jar:3.3:compile
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-file:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-gemfire:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.data:spring-data-gemfire:jar:1.4.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-groovy:jar:4.0.2.RELEASE:compile
-|  +- (org.codehaus.groovy:groovy-all:jar:2.3.1:compile - omitted for conflict with 2.3.2)
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-scripting:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-ip:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-jdbc:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-jdbc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- com.google.guava:guava:jar:16.0.1:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-jms:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-jms:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-jmx:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-jpa:jar:4.0.2.RELEASE:compile
-|  +- org.eclipse.persistence:javax.persistence:jar:2.0.0:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-orm:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-mail:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-mongodb:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.data:spring-data-mongodb:jar:1.5.0.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-mqtt:jar:4.0.2.RELEASE:compile
-|  +- org.eclipse.paho:mqtt-client:jar:0.4.0:compile
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-redis:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.data:spring-data-redis:jar:1.3.0.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-rmi:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-scripting:jar:4.0.2.RELEASE:compile
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-security:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.security:spring-security-config:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-tx:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-sftp:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.integration:spring-integration-stream:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-file:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- com.jcraft:jsch:jar:0.1.51:compile
-+- org.springframework.integration:spring-integration-stream:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-syslog:jar:4.0.2.RELEASE:compile
-|  \- (org.springframework.integration:spring-integration-ip:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-test:jar:4.0.2.RELEASE:compile
-|  +- (org.mockito:mockito-core:jar:1.9.5:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-test:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (junit:junit:jar:4.11:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- (org.hamcrest:hamcrest-all:jar:1.3:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-twitter:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework.social:spring-social-twitter:jar:1.1.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-web:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-ws:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-webmvc:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-oxm:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- org.springframework.ws:spring-ws-core:jar:2.2.0.RELEASE:compile
-|  |  +- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)
-|  |  \- (org.springframework.ws:spring-xml:jar:2.2.0.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-expression:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  \- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-xml:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-oxm:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-context:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  \- org.springframework.ws:spring-xml:jar:2.2.0.RELEASE:compile
-|     \- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)
-+- org.springframework.integration:spring-integration-xmpp:jar:4.0.2.RELEASE:compile
-|  +- (org.springframework:spring-context-support:jar:4.0.5.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.integration:spring-integration-core:jar:4.0.2.RELEASE:compile - omitted for duplicate)
-|  +- org.igniterealtime.smack:smack:jar:3.2.1:compile
-|  \- org.igniterealtime.smack:smackx:jar:3.2.1:compile
-+- org.springframework.security:spring-security-acl:jar:3.2.4.RELEASE:compile
-|  +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-jdbc:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-tx:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-aspects:jar:3.2.4.RELEASE:compile
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-cas:jar:3.2.4.RELEASE:compile
-|  +- org.jasig.cas.client:cas-client-core:jar:3.2.1:compile
-|  |  \- (commons-logging:commons-logging:jar:1.1:compile - omitted for conflict with 1.1.3)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-web:jar:3.2.4.RELEASE:compile - omitted for conflict with 3.2.3.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-config:jar:3.2.4.RELEASE:compile
-|  +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile
-|  +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-expression:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-crypto:jar:3.2.4.RELEASE:compile
-|  \- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-ldap:jar:3.2.4.RELEASE:compile
-|  +- org.springframework.ldap:spring-ldap-core:jar:1.3.2.RELEASE:compile
-|  |  \- (commons-lang:commons-lang:jar:2.4:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-tx:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-openid:jar:3.2.4.RELEASE:compile
-|  +- com.google.inject:guice:jar:2.0:compile
-|  |  \- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- org.openid4java:openid4java-nodeps:jar:0.9.6:compile
-|  |  +- (commons-logging:commons-logging:jar:1.1.1:compile - omitted for conflict with 1.1.3)
-|  |  \- net.jcip:jcip-annotations:jar:1.0:compile
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-web:jar:3.2.4.RELEASE:compile - omitted for conflict with 3.2.3.RELEASE)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- net.sourceforge.nekohtml:nekohtml:jar:1.9.20:runtime
-|  |  \- (xerces:xercesImpl:jar:2.10.0:runtime - omitted for conflict with 2.4.0)
-|  \- (org.apache.httpcomponents:httpclient:jar:4.2.3:runtime - omitted for conflict with 4.3.3)
-+- org.springframework.security:spring-security-remoting:jar:3.2.4.RELEASE:compile
-|  +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-+- org.springframework.security:spring-security-taglibs:jar:3.2.4.RELEASE:compile
-|  +- (org.springframework.security:spring-security-acl:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-|  +- (org.springframework.security:spring-security-web:jar:3.2.4.RELEASE:compile - omitted for conflict with 3.2.3.RELEASE)
-|  +- (org.springframework:spring-aop:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  +- (org.springframework:spring-expression:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-|  \- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-\- org.springframework.security:spring-security-web:jar:3.2.4.RELEASE:compile
-   +- (aopalliance:aopalliance:jar:1.0:compile - omitted for duplicate)
-   +- (org.springframework.security:spring-security-core:jar:3.2.4.RELEASE:compile - omitted for duplicate)
-   +- (org.springframework:spring-beans:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-   +- (org.springframework:spring-context:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-   +- (org.springframework:spring-core:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-   +- (org.springframework:spring-expression:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
-   \- (org.springframework:spring-web:jar:3.2.8.RELEASE:compile - omitted for conflict with 4.0.5.RELEASE)
@@ -1,5 +0,0 @@
-org.sample:sample:pom:1.0.0.BUILD-SNAPSHOT
-+- org.sample:sample01:jar:1.0.0:compile
-+- org.sample:sample02:jar:1.0.0:compile
-|  +- (org.sample:sample01:jar:1.0.0:compile - omitted for duplicate)
-\- org.springframework.boot:spring-boot:jar:1.0.0.BUILD-SNAPSHOT:compile
@@ -2,8 +2,6 @@
 <project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
 	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
-	<groupId>org.sample</groupId>
-	<artifactId>sample</artifactId>
 	<version>1.0.0.BUILD-SNAPSHOT</version>
 	<properties>
 		<sample.version>1.0.0</sample.version>
@@ -47,17 +47,19 @@ public ApplyExcludeRules(Project project) {
 	@Override
 	public void execute(Configuration configuration) {
 		if (!VersionManagedDependencies.CONFIGURATION.equals(configuration.getName())) {
-			configuration.getIncoming().beforeResolve(new Action<ResolvableDependencies>() {
-				@Override
-				public void execute(ResolvableDependencies resolvableDependencies) {
-					resolvableDependencies.getDependencies().all(new Action<Dependency>() {
+			configuration.getIncoming().beforeResolve(
+					new Action<ResolvableDependencies>() {
 						@Override
-						public void execute(Dependency dependency) {
-							applyExcludeRules(dependency);
+						public void execute(ResolvableDependencies resolvableDependencies) {
+							resolvableDependencies.getDependencies().all(
+									new Action<Dependency>() {
+										@Override
+										public void execute(Dependency dependency) {
+											applyExcludeRules(dependency);
+										}
+									});
 						}
 					});
-				}
-			});
 		}
 	}
 
@@ -73,13 +75,10 @@ private void applyExcludeRules(ModuleDependency dependency) {
 		org.springframework.boot.dependency.tools.Dependency managedDependency = managedDependencies
 				.find(dependency.getGroup(), dependency.getName());
 		if (managedDependency != null) {
-			if (managedDependency.getExclusions().isEmpty()) {
-				logger.debug(""No exclusions rules applied for managed dependency ""
-						+ dependency);
-			}
 			for (Exclusion exclusion : managedDependency.getExclusions()) {
 				addExcludeRule(dependency, exclusion);
 			}
+			addImplicitExcludeRules(dependency);
 		}
 		else {
 			logger.debug(""No exclusions rules applied for non-managed dependency ""
@@ -94,4 +93,21 @@ private void addExcludeRule(ModuleDependency dependency, Exclusion exclusion) {
 		dependency.getExcludeRules().add(rule);
 	}
 
+	private void addImplicitExcludeRules(ModuleDependency dependency) {
+		if (isStarter(dependency)) {
+			logger.info(""Adding implicit managed exclusion rules to starter ""
+					+ dependency);
+			dependency.getExcludeRules().add(
+					new DefaultExcludeRule(""commons-logging"", ""commons-logging""));
+			dependency.getExcludeRules().add(
+					new DefaultExcludeRule(""commons-logging"", ""commons-logging-api""));
+		}
+	}
+
+	private boolean isStarter(ModuleDependency dependency) {
+		return (dependency.getGroup() != null
+				&& dependency.getGroup().equals(""org.springframework.boot"") && dependency
+				.getName().startsWith(""spring-boot-starter""));
+	}
+
 }
@@ -27,7 +27,6 @@
 		</resources>
 		<plugins>
 			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
 				<artifactId>maven-help-plugin</artifactId>
 				<executions>
 					<execution>
@@ -42,49 +41,6 @@
 					</execution>
 				</executions>
 			</plugin>
-			<plugin>
-				<groupId>org.codehaus.gmavenplus</groupId>
-				<artifactId>gmavenplus-plugin</artifactId>
-				<executions>
-					<execution>
-						<goals>
-							<goal>execute</goal>
-						</goals>
-						<phase>generate-resources</phase>
-					</execution>
-				</executions>
-				<configuration>
-					<scripts>
-						<script>file:///${project.basedir}/src/main/groovy/generateDependencyTreePom.groovy</script>
-					</scripts>
-				</configuration>
-				<dependencies>
-					<dependency>
-						<groupId>org.codehaus.groovy</groupId>
-						<artifactId>groovy-all</artifactId>
-						<version>${groovy.version}</version>
-					</dependency>
-				</dependencies>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-invoker-plugin</artifactId>
-				<executions>
-					<execution>
-						<id>generate-dependency-tree</id>
-						<phase>generate-resources</phase>
-						<goals>
-							<goal>run</goal>
-						</goals>
-						<configuration>
-							<cloneProjectsTo>${project.build.directory}/invoker</cloneProjectsTo>
-							<settingsFile>src/dependency-tree/settings.xml</settingsFile>
-							<streamLogs>true</streamLogs>
-							<pom>${basedir}/src/dependency-tree/pom.xml</pom>
-						</configuration>
-					</execution>
-				</executions>
-			</plugin>
 			<plugin>
 				<groupId>org.codehaus.mojo</groupId>
 				<artifactId>xml-maven-plugin</artifactId>
@@ -131,149 +87,11 @@
 									<file>${project.build.directory}/effective-pom/spring-boot-versions.xml</file>
 									<type>effective-pom</type>
 								</artifact>
-								<artifact>
-									<file>${project.build.directory}/dependency-tree/dependency-tree.txt </file>
-									<type>dependency-tree</type>
-								</artifact>
 							</artifacts>
 						</configuration>
 					</execution>
 				</executions>
 			</plugin>
 		</plugins>
 	</build>
-	<dependencies>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-actuator</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-amqp</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-aop</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-batch</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-elasticsearch</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-gemfire</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-jpa</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-mongodb</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-rest</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-solr</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-freemarker</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-groovy-templates</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-hornetq</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-integration</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-jdbc</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-jetty</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-log4j</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-logging</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-mobile</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-redis</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-remote-shell</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-security</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-social-facebook</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-social-linkedin</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-social-twitter</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-test</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-thymeleaf</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-tomcat</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-velocity</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-web</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-websocket</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-ws</artifactId>
-		</dependency>
-	</dependencies>
 </project>
@@ -1,40 +0,0 @@
-<?xml version=""1.0"" encoding=""UTF-8""?>
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
-	<modelVersion>4.0.0</modelVersion>
-	<parent>
-		<groupId>org.springframework.boot</groupId>
-		<artifactId>spring-boot-versions</artifactId>
-		<version>@project.version@</version>
-		<relativePath>../../target/dependency-tree</relativePath>
-	</parent>
-	<artifactId>spring-boot-versions-dependency-tree</artifactId>
-	<packaging>pom</packaging>
-	<build>
-		<plugins>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-dependency-plugin</artifactId>
-				<executions>
-					<execution>
-						<id>write-dependencies-tree</id>
-						<phase>generate-resources</phase>
-						<goals>
-							<goal>tree</goal>
-						</goals>
-						<configuration>
-							<outputFile>@project.build.directory@/dependency-tree/dependency-tree.txt</outputFile>
-							<verbose>true</verbose>
-						</configuration>
-					</execution>
-				</executions>
-			</plugin>
-		</plugins>
-	</build>
-	<repositories>
-		<repository>
-			<id>spring-ext</id>
-			<url>http://repo.spring.io/ext-release-local/</url>
-		</repository>
-	</repositories>
-</project>
@@ -1,34 +0,0 @@
-// Generate a POM from the effective-pom that can be used to build a complete dependency tree
-
-import groovy.util.*
-import groovy.xml.*
-
-def effectivePom = new XmlSlurper().parse(
-	new File(project.build.directory, 'effective-pom/spring-boot-versions.xml'))
-
-effectivePom.dependencyManagement.dependencies.dependency.findAll{ it.groupId != ""org.springframework.boot"" }.each {
-	effectivePom.dependencies.appendNode( it )
-}
-
-// effectivePom.appendNode(effectivePom.dependencyManagement.dependencies)
-effectivePom.parent.replaceNode {}
-effectivePom.dependencyManagement.replaceNode {}
-effectivePom.build.replaceNode {}
-effectivePom.properties.replaceNode {}
-effectivePom.repositories.replaceNode {}
-effectivePom.pluginRepositories.replaceNode {}
-effectivePom.reporting.replaceNode {}
-
-out = new StreamingMarkupBuilder()
-String xmlResult = out.bind {
-	mkp.declareNamespace("""": ""http://maven.apache.org/POM/4.0.0"")
-	mkp.yield effectivePom
-}
-
-
-def outputDir = new File(project.build.directory, 'dependency-tree');
-outputDir.mkdirs();
-XmlUtil.serialize(xmlResult, new FileWriter(new File(outputDir, 'pom.xml')))
-
-
-
",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51311 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51337 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51299 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51318 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51288 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51303 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51278 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51286 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 51288 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}"
https://github.com/spring-projects/spring-boot/commit/c4f756daee43f89e0ba832ceac17bac216fc899b,"Fix MavenSettings’ handling of profiles activated by a file  <enter> Previously, MavenSettings used a FileProfileActivator with no PathTransformer. If a settings.xml file contains a file-activated profile this would result in an NPE within Maven. This was made worse by the NPE not being included in the resulting failure message which hampered diagnosis of the problem. <enter> This commit updates MavenSettings to configure its FileProfileActivator with a PathTransformer. It also improves the failure message that’s created from any problems that are reported by Maven while determining the active profiles to include a problem’s exception if it has one. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/c4f756daee43f89e0ba832ceac17bac216fc899b,"@@ -16,8 +16,11 @@
 
 package org.springframework.boot.cli.compiler.maven;
 
+import java.io.BufferedReader;
 import java.io.File;
+import java.io.IOException;
 import java.io.PrintWriter;
+import java.io.StringReader;
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -29,6 +32,7 @@
 import org.apache.maven.model.ActivationProperty;
 import org.apache.maven.model.building.ModelProblemCollector;
 import org.apache.maven.model.building.ModelProblemCollectorRequest;
+import org.apache.maven.model.path.DefaultPathTranslator;
 import org.apache.maven.model.profile.DefaultProfileSelector;
 import org.apache.maven.model.profile.ProfileActivationContext;
 import org.apache.maven.model.profile.activation.FileProfileActivator;
@@ -147,15 +151,47 @@ private String createFailureMessage(
 		PrintWriter printer = new PrintWriter(message);
 		printer.println(""Failed to determine active profiles:"");
 		for (ModelProblemCollectorRequest problem : problemCollector.getProblems()) {
-			printer.println(
-					""    "" + problem.getMessage() + "" at "" + problem.getLocation());
+			printer.println(""    "" + problem.getMessage() + (problem.getLocation() != null
+					? "" at "" + problem.getLocation() : """"));
+			if (problem.getException() != null) {
+				printer.println(indentStackTrace(problem.getException(), ""        ""));
+			}
 		}
 		return message.toString();
 	}
 
+	private String indentStackTrace(Exception ex, String indent) {
+		return indentLines(printStackTrace(ex), indent);
+	}
+
+	private String printStackTrace(Exception ex) {
+		StringWriter stackTrace = new StringWriter();
+		PrintWriter printer = new PrintWriter(stackTrace);
+		ex.printStackTrace(printer);
+		return stackTrace.toString();
+	}
+
+	private String indentLines(String input, String indent) {
+		StringWriter indented = new StringWriter();
+		PrintWriter writer = new PrintWriter(indented);
+		String line;
+		BufferedReader reader = new BufferedReader(new StringReader(input));
+		try {
+			while ((line = reader.readLine()) != null) {
+				writer.println(indent + line);
+			}
+		}
+		catch (IOException ex) {
+			return input;
+		}
+		return indented.toString();
+	}
+
 	private DefaultProfileSelector createProfileSelector() {
 		DefaultProfileSelector selector = new DefaultProfileSelector();
-		selector.addProfileActivator(new FileProfileActivator());
+
+		selector.addProfileActivator(new FileProfileActivator()
+				.setPathTranslator(new DefaultPathTranslator()));
 		selector.addProfileActivator(new JdkVersionProfileActivator());
 		selector.addProfileActivator(new PropertyProfileActivator());
 		selector.addProfileActivator(new OperatingSystemProfileActivator());
@@ -28,4 +28,21 @@
 		</proxy>
 	</proxies>
 
-</settings>
\ No newline at end of file
+	<profiles>
+		<profile>
+    		<id>test-profile</id>
+    		<activation>
+	        	<file>
+	            	<exists>${user.home}/.m2/some_file</exists>
+	        	</file>
+    		</activation>
+	    	<repositories>
+	        	<repository>
+	            	<id>example-repository</id>
+	            	<url>http://repo.example.com</url>
+	        	</repository>
+	    	</repositories>
+		</profile>
+	</profiles>
+
+</settings>
",True,"The commit message refers to a convention in Maven settings.xml files where profiles can be activated by the presence of a file. The commit message explains that previously, if a settings.xml file contained a file-activated profile, it would result in an NPE within Maven. This was made worse by the NPE not being included in the resulting failure message, which hampered diagnosis of the problem. The commit message then explains that the commit updates MavenSettings to configure its FileProfileActivator with a PathTransformer and improves the failure message to include a problem's exception if it has one. This addresses the issue and improves the diagnostic capabilities of the system.",True,"The commit message explains the necessity of changes by stating that 'MavenSettings used a FileProfileActivator with no PathTransformer. If a settings.xml file contains a file-activated profile this would result in an NPE within Maven.' This is not a common sense or easy to infer change, as it involves modifying the code to handle a specific case in the Maven settings file that could cause a NullPointerException.",True,"The commit message clearly explains the problem scenario: 'Previously, MavenSettings used a FileProfileActivator with no PathTransformer. If a settings.xml file contains a file-activated profile this would result in an NPE within Maven.' It also mentions that the failure message was not helpful in diagnosing the problem. The commit message then explains how the changes address these issues, mentioning that the FileProfileActivator is now configured with a PathTransformer and that the failure message will include the exception if one is present.",True,The commit message indicates that the changes were made to address a problem in the software maintenance process. The problem is described as 'MavenSettings used a FileProfileActivator with no PathTransformer. If a settings.xml file contains a file-activated profile this would result in an NPE within Maven.' This is a clear indication of a problem in the software that needs to be fixed.,True,"The commit message directly mentions the defect it fixes, which is the NullPointerException (NPE) that occurred when MavenSettings used a FileProfileActivator with no PathTransformer and a settings.xml file contained a file-activated profile. The message also mentions the improvement made to the code, which is the addition of a PathTransformer to the FileProfileActivator and the inclusion of a problem's exception in the resulting failure message.",True,"The commit message accurately summarizes the changes made to the code. It mentions the issue of MavenSettings handling of profiles activated by a file, which previously resulted in an NPE. The commit message then explains that the issue was addressed by configuring the FileProfileActivator with a PathTransformer and improving the failure message to include the exception if one is present. This is consistent with the changes made in the diff, which include adding imports for handling file I/O and modifying the createFailureMessage method to include the exception in the failure message. The diff also shows the addition of a new profile in the settings.xml file that is activated by a file, which is also mentioned in the commit message.",True,"The commit message explains that the changes were made to handle profiles activated by a file in MavenSettings. This is a technical principle underpinning the changes, as it improves the handling of file-activated profiles to prevent NullPointerExceptions (NPEs) and provides better failure messages for diagnosis.",True,"The commit message describes the changes made to the MavenSettings class in the code diff. It explains that the previous implementation of MavenSettings used a FileProfileActivator without a PathTransformer, which could lead to an NPE when a settings.xml file contained a file-activated profile. The commit message also mentions that this issue was made worse by the lack of an exception in the resulting failure message, which hampered diagnosis. The commit itself adds a PathTransformer to the FileProfileActivator and improves the failure message to include the exception if one is present. This change introduces new behavior that improves the handling of profiles activated by a file in MavenSettings and makes it easier to diagnose problems.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Fix MavenSettings’ handling of profiles activated by a file'. The commit message explains that previously, MavenSettings used a FileProfileActivator with no PathTransformer, which could lead to an NPE and a less helpful failure message. The commit message then explains how the issue was addressed by configuring the FileProfileActivator with a PathTransformer and improving the failure message to include the exception if one is present."
https://github.com/spring-projects/spring-boot/commit/32b32b714275d0efaa1f5afba10e88e09101f224,Notify the use of logback specific system property  <enter> Logback documentation explains how to initialize the logging system and namely how the `logback.configurationFile` system property can be used to specify the configuration file to use. <enter> Spring Boot has an abstraction on top of that. A user can define the `logging.path` property regardless of the logging infrastructure it is using. <enter> Users following the logback documentation can be confused at first so we're not logging a warning when we found out that the logback specific property has been specified. <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/32b32b714275d0efaa1f5afba10e88e09101f224,"@@ -1019,6 +1019,9 @@ NOTE: The logging system is initialized early in the application lifecycle and a
 logging properties will not be found in property files loaded via `@PropertySource`
 annotations.
 
+TIP: Logging properties are independent of the actual logging infrastructure. As a
+result, specific configuration keys (such as `logback.configurationFile` for Logback)
+are not managed by spring Boot.
 
 
 [[boot-features-custom-log-levels]]
@@ -56,6 +56,8 @@
  */
 public class LogbackLoggingSystem extends Slf4JLoggingSystem {
 
+	private static final String CONFIGURATION_FILE_PROPERTY = ""logback.configurationFile"";
+
 	private static final Map<LogLevel, Level> LEVELS;
 
 	static {
@@ -102,6 +104,11 @@ public void initialize(LoggingInitializationContext initializationContext,
 			String configLocation, LogFile logFile) {
 		getLogger(null).getLoggerContext().getTurboFilterList().remove(FILTER);
 		super.initialize(initializationContext, configLocation, logFile);
+		if (StringUtils.hasText(System.getProperty(CONFIGURATION_FILE_PROPERTY))) {
+			getLogger(LogbackLoggingSystem.class.getName()).warn(
+					""Ignoring '""+CONFIGURATION_FILE_PROPERTY+""' system property. "" +
+							""Please use 'logging.path' instead."");
+		}
 	}
 
 	@Override
@@ -141,6 +141,21 @@ public void testNonDefaultConfigLocation() throws Exception {
 		assertFalse(new File(tmpDir() + ""/tmp.log"").exists());
 	}
 
+	@Test
+	public void testLogbackSpecificSystemProperty() throws Exception {
+		System.setProperty(""logback.configurationFile"", ""/foo/my-file.xml"");
+		try {
+			this.loggingSystem.beforeInitialize();
+			this.loggingSystem.initialize(this.initializationContext, null, null);
+			String output = this.output.toString().trim();
+			assertTrue(""Wrong output:\n"" + output, output.contains(""Ignoring "" +
+					""'logback.configurationFile' system property. Please use 'logging.path' instead.""));
+		}
+		finally {
+			System.clearProperty(""logback.configurationFile"");
+		}
+	}
+
 	@Test(expected = IllegalStateException.class)
 	public void testNonexistentConfigLocation() throws Exception {
 		this.loggingSystem.beforeInitialize();
",True,"The commit message explains the necessity of changes by referencing a convention from the logback documentation. It mentions that the `logback.configurationFile` system property is specific to logback and not managed by Spring Boot. The commit message also explains that users following the logback documentation might be confused by this property, so the warning is being suppressed to avoid confusion.",True,"The commit message explains that the change is made to address a common source of confusion for users who are following the logback documentation. It mentions that the logback specific property has been specified, and the change is to prevent logging a warning in this situation. This clearly describes the necessity of the changes without providing a detailed rationale, as it is common sense that users following the logback documentation might be confused by the warning.",True,"The commit message explains the motivation for the code change by mentioning that users following the logback documentation might be confused if they use the logback specific property 'logback.configurationFile'. The message also explains that Spring Boot has an abstraction on top of that, and a user can define the 'logging.path' property instead. This clarifies the issue and the solution, making it clear that the change is necessary to avoid confusion and to align with Spring Boot's abstraction.",True,"The commit message indicates that the changes were made to address a user confusion. Specifically, it mentions that users following the logback documentation can be confused at first when they use the 'logback.configurationFile' system property. This suggests that the source of the requirements is the need to improve the user experience and address potential confusion or problems in the process of software maintenance.",True,"The commit message directly mentions the issue it fixes, which is the confusion that users following the logback documentation might have when they use the `logback.configurationFile` system property. The change made in the code is to not log a warning when this specific property is found, as it is not managed by Spring Boot and can be confusing for users.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions the addition of a check for the 'logback.configurationFile' system property, which is not managed by Spring Boot. This change is also explained in the context of the logging system and its initialization. The message also contrasts the use of 'logback.configurationFile' with the recommended 'logging.path' property, which aligns with the code changes.",True,"The commit message explains that the changes are made to handle the use of a logback specific system property ('logback.configurationFile'). It mentions that Spring Boot has an abstraction on top of that, and users can define the 'logging.path' property instead. This explains the technical principle underpinning the changes, which is to provide a more universal and less confusing logging configuration mechanism that is not tied to a specific logging infrastructure.",True,"The commit message expresses a change in behavior and explains the code changes from a functional perspective. It mentions that the commit is about handling the 'logback.configurationFile' system property, which is specific to Logback. Previously, the application would not log a warning when this property was used, but now it does. This is a new behavior introduced by the changes in the code diff, which adds a check for the 'logback.configurationFile' property and logs a warning if it is set. This change is likely to help users who are following the Logback documentation and might be confused by the specific property. The message also explains that this change is related to an issue that has been closed.",False,"The commit message explains the reason for the change, which is to prevent confusion for users who follow the logback documentation. The change is not as simple as removing a space, but rather adding a warning message to the code when a specific logback system property is used. This change is not immediately obvious from the code diff, as it involves adding a new condition and a warning message."
https://github.com/spring-projects/spring-boot/commit/e5a253e68951dcf975b9844b3b39afac2222b503,"Improve diagnostics when OnBeanCondition type deduction fails  <enter> When @ConditionalOnBean or @ConditionalOnMissingBean are used on a  @bean  method, they will, in the absence of any other configuration, attempt to deduce the bean's type by examining the method's return type. This deduction can fail. See  <issue_link> ,  <issue_link> , and  <issue_link>  for some examples of possible failure causes. Previously, this failure was only logged as a debug message leaving the user with a misleading message suggesting that the @ConditionalOnBean or @ConditionalOnMissingBean annotation was not configured correctly. <enter> This commit improves the diagnostics by mention the possibility of type deduction in the exception message and including the exception that caused deduction to fail as the cause. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/e5a253e68951dcf975b9844b3b39afac2222b503,"@@ -267,18 +267,32 @@ private static class BeanSearchSpec {
 			collect(attributes, ""annotation"", this.annotations);
 			collect(attributes, ""ignored"", this.ignoredTypes);
 			collect(attributes, ""ignoredType"", this.ignoredTypes);
-			if (this.types.isEmpty() && this.names.isEmpty()) {
-				addDeducedBeanType(context, metadata, this.types);
-			}
 			this.strategy = (SearchStrategy) metadata
 					.getAnnotationAttributes(annotationType.getName()).get(""search"");
-			validate();
+			BeanTypeDeductionException deductionException = null;
+			try {
+				if (this.types.isEmpty() && this.names.isEmpty()) {
+					addDeducedBeanType(context, metadata, this.types);
+				}
+			}
+			catch (BeanTypeDeductionException ex) {
+				deductionException = ex;
+			}
+			validate(deductionException);
 		}
 
-		protected void validate() {
-			Assert.isTrue(hasAtLeastOne(this.types, this.names, this.annotations),
-					annotationName() + "" annotations must ""
-							+ ""specify at least one bean (type, name or annotation)"");
+		protected void validate(BeanTypeDeductionException ex) {
+			if (!hasAtLeastOne(this.types, this.names, this.annotations)) {
+				String message = annotationName()
+						+ "" did not specify a bean using type, name or annotation"";
+				if (ex == null) {
+					throw new IllegalStateException(message);
+				}
+				else {
+					throw new IllegalStateException(message + "" and the attempt to deduce""
+							+ "" the bean's type failed"", ex);
+				}
+			}
 		}
 
 		private boolean hasAtLeastOne(List<?>... lists) {
@@ -337,12 +351,9 @@ public void doWith(Method method)
 				});
 			}
 			catch (Throwable ex) {
-				// swallow exception and continue
-				if (logger.isDebugEnabled()) {
-					logger.debug(""Unable to deduce bean type for ""
-							+ methodMetadata.getDeclaringClassName() + "".""
-							+ methodMetadata.getMethodName(), ex);
-				}
+				throw new BeanTypeDeductionException(
+						methodMetadata.getDeclaringClassName(),
+						methodMetadata.getMethodName(), ex);
 			}
 		}
 
@@ -404,11 +415,20 @@ protected void collect(MultiValueMap<String, Object> attributes, String key,
 		}
 
 		@Override
-		protected void validate() {
+		protected void validate(BeanTypeDeductionException ex) {
 			Assert.isTrue(getTypes().size() == 1, annotationName() + "" annotations must ""
 					+ ""specify only one type (got "" + getTypes() + "")"");
+		}
+	}
+
+	static final class BeanTypeDeductionException extends RuntimeException {
 
+		private BeanTypeDeductionException(String className, String beanMethodName,
+				Throwable cause) {
+			super(""Failed to deduce bean type for "" + className + ""."" + beanMethodName,
+					cause);
 		}
+
 	}
 
 }
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2012-2016 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.condition;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.springframework.boot.autoconfigure.condition.OnBeanCondition.BeanTypeDeductionException;
+import org.springframework.boot.testutil.ClassPathExclusions;
+import org.springframework.boot.testutil.FilteredClassPathRunner;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Import;
+import org.springframework.context.annotation.ImportSelector;
+import org.springframework.core.type.AnnotationMetadata;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for {@link OnBeanCondition} when deduction of the bean's type fails
+ *
+ * @author Andy Wilkinson
+ */
+@RunWith(FilteredClassPathRunner.class)
+@ClassPathExclusions(""jackson-core-*.jar"")
+public class OnBeanConditionTypeDeductionFailureTests {
+
+	@Test
+	public void conditionalOnMissingBeanWithDeducedTypeThatIsPartiallyMissingFromClassPath() {
+		try {
+			new AnnotationConfigApplicationContext(ImportingConfiguration.class).close();
+			fail(""Context refresh was successful"");
+		}
+		catch (Exception ex) {
+			ex.printStackTrace();
+			Throwable beanTypeDeductionException = findBeanTypeDeductionException(ex);
+			assertThat(beanTypeDeductionException)
+					.hasMessage(""Failed to deduce bean type for ""
+							+ OnMissingBeanConfiguration.class.getName()
+							+ "".objectMapper"");
+			assertThat(beanTypeDeductionException)
+					.hasCauseInstanceOf(NoClassDefFoundError.class);
+		}
+	}
+
+	private Throwable findBeanTypeDeductionException(Throwable ex) {
+		Throwable candidate = ex;
+		while (candidate != null) {
+			if (candidate instanceof BeanTypeDeductionException) {
+				return candidate;
+			}
+			candidate = candidate.getCause();
+		}
+		return null;
+	}
+
+	@Configuration
+	@Import(OnMissingBeanImportSelector.class)
+	static class ImportingConfiguration {
+
+	}
+
+	@Configuration
+	static class OnMissingBeanConfiguration {
+
+		@Bean
+		@ConditionalOnMissingBean
+		public ObjectMapper objectMapper() {
+			return new ObjectMapper();
+		}
+
+	}
+
+	static class OnMissingBeanImportSelector implements ImportSelector {
+
+		@Override
+		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
+			return new String[] { OnMissingBeanConfiguration.class.getName() };
+		}
+
+	}
+
+}
",True,"The commit message refers to a convention regarding the handling of type deduction failures in @ConditionalOnBean and @ConditionalOnMissingBean annotations. Previously, these failures were only logged as debug messages, leaving the user with a misleading message. This commit improves the diagnostics by mentioning the possibility of type deduction in the exception message and including the exception that caused deduction to fail as the cause. This makes it clearer to the user that the issue is related to type deduction, not the configuration of the annotation.",True,"The commit message explains that the changes are made to improve diagnostics when OnBeanCondition type deduction fails. This is not a trivial or common sense change, as it involves modifying the exception message and handling to provide more specific and helpful information to the user. The code diff also supports this explanation by showing the addition of a new BeanTypeDeductionException and modifications to the validate method to include this exception in the error message.",True,The commit message directly elaborates the motivation of the code change by mentioning the issue report and the error scenario where the @ConditionalOnBean or @ConditionalOnMissingBean annotation was not configured correctly due to type deduction failure. The message also explains how the diagnostics have been improved by including the exception that caused deduction to fail as the cause.,True,"The commit message indicates that the changes are made to improve diagnostics when the type deduction fails for @ConditionalOnBean or @ConditionalOnMissingBean annotations. This is a clear indication of a problem in the software maintenance process, specifically the need to improve error handling and diagnostics to provide more useful information to the user.",True,"The commit message directly mentions the improvement made to the diagnostics when OnBeanCondition type deduction fails. It explains that previously, this failure was only logged as a debug message, leaving the user with a misleading message. However, the commit improves the diagnostics by mentioning the possibility of type deduction in the exception message and including the exception that caused deduction to fail as the cause. This makes it clearer to the user what went wrong and how to fix it.",True,"The commit message does a good job of summarizing the changes. It mentions the improvement in diagnostics when OnBeanCondition type deduction fails, which is a clear reference to the code diff. The message also explains that the previous failure was only logged as a debug message, contrasting the before and after situation. Additionally, the message mentions the inclusion of the exception that caused deduction to fail as the cause, which is another reference to the code diff.",True,"The commit message explains that when using @ConditionalOnBean or @ConditionalOnMissingBean on a @bean method, the bean's type is attempted to be deduced from the method's return type. This deduction can fail, and the commit improves the diagnostics by mentioning the possibility of type deduction failure in the exception message and including the exception that caused deduction to fail as the cause. This highlights the technical principle underpinning the changes, which is the importance of handling and communicating errors that occur during bean type deduction.",True,"The commit message does describe a summary of the changes by explaining the code changes from a functional perspective and describing the new behaviors introduced. The message mentions that the commit improves diagnostics when OnBeanCondition type deduction fails, which is a change in the codebase. It explains that previously, this failure was only logged as a debug message, but now it throws an exception that includes the exception that caused deduction to fail as the cause. This change improves the diagnostics by providing more information to the user about the failure.",False,"The commit message does not explicitly state the reason for the change, but it is not easily inferred from the code diff. The change is not just a simple modification like removing a space, but rather a significant improvement to the diagnostics when OnBeanCondition type deduction fails. The commit adds error handling for type deduction failures and includes the exception that caused deduction to fail as the cause of the new exception. This makes it clearer what went wrong and provides more useful information to the user."
https://github.com/junit-team/junit4/commit/3189af007b26d74ca459f823d57ef77b9c1697b8,Remove redundant field fCause ,https://api.github.com/repos/junit-team/junit4/commits/3189af007b26d74ca459f823d57ef77b9c1697b8,"@@ -16,7 +16,6 @@ public class ArrayComparisonFailure extends AssertionError {
 
     private List<Integer> fIndices = new ArrayList<Integer>();
     private final String fMessage;
-    private final AssertionError fCause;
 
     /**
      * Construct a new <code>ArrayComparisonFailure</code> with an error text and the array's
@@ -28,7 +27,7 @@ public class ArrayComparisonFailure extends AssertionError {
      */
     public ArrayComparisonFailure(String message, AssertionError cause, int index) {
         fMessage = message;
-        fCause = cause;
+        initCause(cause);
         addDimension(index);
     }
 
@@ -49,7 +48,7 @@ public String getMessage() {
             sb.append(""]"");
         }
         sb.append(""; "");
-        sb.append(fCause.getMessage());
+        sb.append(getCause().getMessage());
         return sb.toString();
     }
 
",False,"The commit message 'Remove redundant field fCause' does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that the field is redundant, but it does not explain why it was removed or how it affects the functionality or structure of the code.",True,"The commit message 'Remove redundant field fCause' clearly describes the necessity of the changes. The code diff shows that the field fCause is no longer needed because its functionality is replaced by the initCause method. This is a common refactoring to simplify code and improve its maintainability. Therefore, the commit message does not require a rationale beyond the changes themselves.",False,"The commit message 'Remove redundant field fCause' does not explicitly describe the necessity of the changes. It only states that the field is redundant, but it does not elaborate on why the field was considered redundant or what problem it was causing. The code diff shows that the field fCause is removed and replaced with the use of initCause(cause), which is a standard way to set the cause of an exception in Java. However, the commit message does not explain why this change was necessary or what issue the previous implementation had that required this change.",True,"The commit message 'Remove redundant field fCause' indicates that the field 'fCause' was removed because it was no longer needed. This could be due to a change in the codebase where the functionality provided by 'fCause' was replaced by another method or feature. In this case, the removal of 'fCause' could be seen as a necessity to simplify the code and improve its maintainability, which can be considered as a problem in the process of software maintenance.",True,"The commit message 'Remove redundant field fCause' directly mentions the change that is being made to the code, which is the removal of a field that was found to be redundant. This implies that the change is being made to improve the code by simplifying it and potentially reducing memory usage.",True,The commit message 'Remove redundant field fCause' accurately summarizes the change in the code diff. It clearly states that a field 'fCause' is being removed from the class 'ArrayComparisonFailure'. The diff also supports this by showing the removal of the private field 'fCause' and its corresponding usage in the constructor and the 'getMessage' method.,False,"The commit message 'Remove redundant field fCause' does not explicitly describe a technical principle underpinning the changes. The code diff shows that the field fCause is removed and replaced with the use of the initCause() method, which is a common way to set the cause of an exception in Java. However, the commit message does not explain why this change was made or what technical principle it is based on.",True,"The commit message 'Remove redundant field fCause' accurately summarizes the code changes. The code diff shows that the field 'fCause' is removed from the class 'ArrayComparisonFailure'. Additionally, the constructor and the 'getMessage' method are modified to use 'initCause' and 'getCause' methods respectively, which suggests that the behavior of the class is not changed, but the code is refactored to use a more appropriate way to handle exceptions.",False,"The commit message does not explicitly explain the reason for the removal of the redundant field fCause. While the change is small and simple, it's still beneficial to include an explanation in the commit message. This is because the removal of the field also involves changing the constructor and the getMessage() method to use the initCause() and getCause() methods, respectively. These changes might not be immediately obvious to someone reviewing the code diff, so it's helpful to have a brief explanation in the commit message."
https://github.com/square/okhttp/commit/30ecba897fb624df201f0a014b54a604418a0e73,Use Request and Response types in OkResponseCache.  <enter> This breaks support for java.net.ResponseCache implementations. That's good. That API is akward and can't support important features like conditional GETs and hit tracking. ,https://api.github.com/repos/square/okhttp/commits/30ecba897fb624df201f0a014b54a604418a0e73,"@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal;
 
+import java.io.ByteArrayInputStream;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
@@ -44,9 +45,7 @@
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
-
-  /** A cheap and type-safe constant for the ISO-8859-1 Charset. */
-  public static final Charset ISO_8859_1 = Charset.forName(""ISO-8859-1"");
+  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
 
   /** A cheap and type-safe constant for the US-ASCII Charset. */
   public static final Charset US_ASCII = Charset.forName(""US-ASCII"");
@@ -79,7 +79,7 @@ static class RealResponseBody extends Response.Body {
       return responseHeaders.getContentLength();
     }
 
-    @Override public InputStream byteStream() throws IOException {
+    @Override public InputStream byteStream() {
       return in;
     }
   }
@@ -21,7 +21,7 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ class Failure {
+public final class Failure {
   private final Request request;
   private final Throwable exception;
 
@@ -20,9 +20,6 @@
 import com.squareup.okhttp.internal.DiskLruCache;
 import com.squareup.okhttp.internal.StrictLineReader;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
 import com.squareup.okhttp.internal.http.RawHeaders;
 import com.squareup.okhttp.internal.http.ResponseHeaders;
 import java.io.BufferedWriter;
@@ -37,12 +34,9 @@
 import java.io.Writer;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
-import java.net.HttpURLConnection;
 import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
 import java.net.URI;
 import java.net.URLConnection;
-import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
 import java.security.cert.CertificateException;
@@ -51,7 +45,6 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import javax.net.ssl.SSLPeerUnverifiedException;
 
 import static com.squareup.okhttp.internal.Util.US_ASCII;
 import static com.squareup.okhttp.internal.Util.UTF_8;
@@ -113,7 +106,7 @@
  *         connection.addRequestProperty(""Cache-Control"", ""max-stale="" + maxStale);
  * }</pre>
  */
-public final class HttpResponseCache extends ResponseCache {
+public final class HttpResponseCache extends ResponseCache implements OkResponseCache {
   // TODO: add APIs to iterate the cache?
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
@@ -129,51 +122,25 @@ public final class HttpResponseCache extends ResponseCache {
   private int hitCount;
   private int requestCount;
 
-  /**
-   * Although this class only exposes the limited ResponseCache API, it
-   * implements the full OkResponseCache interface. This field is used as a
-   * package private handle to the complete implementation. It delegates to
-   * public and private members of this type.
-   */
-  final OkResponseCache okResponseCache = new OkResponseCache() {
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      return HttpResponseCache.this.get(uri, requestMethod, requestHeaders);
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return HttpResponseCache.this.put(uri, connection);
-    }
-
-    @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-      HttpResponseCache.this.maybeRemove(requestMethod, uri);
-    }
-
-    @Override public void update(
-        CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException {
-      HttpResponseCache.this.update(conditionalCacheHit, connection);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      HttpResponseCache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(ResponseSource source) {
-      HttpResponseCache.this.trackResponse(source);
-    }
-  };
-
   public HttpResponseCache(File directory, long maxSize) throws IOException {
     cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
-  private String uriToKey(URI uri) {
-    return Util.hash(uri.toString());
+  @Override public CacheResponse get(URI uri, String s, Map<String, List<String>> stringListMap)
+      throws IOException {
+    throw new UnsupportedOperationException(""This is not a general purpose response cache."");
   }
 
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) {
-    String key = uriToKey(uri);
+  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    throw new UnsupportedOperationException(""This is not a general purpose response cache."");
+  }
+
+  private static String urlToKey(Request requst) {
+    return Util.hash(requst.urlString());
+  }
+
+  @Override public Response get(Request request) {
+    String key = urlToKey(request);
     DiskLruCache.Snapshot snapshot;
     Entry entry;
     try {
@@ -187,25 +154,18 @@ private String uriToKey(URI uri) {
       return null;
     }
 
-    if (!entry.matches(uri, requestMethod, requestHeaders)) {
+    if (!entry.matches(request)) {
       snapshot.close();
       return null;
     }
 
-    return entry.isHttps()
-        ? new EntrySecureCacheResponse(entry, snapshot)
-        : new EntryCacheResponse(entry, snapshot);
+    return entry.response(request, snapshot);
   }
 
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    if (!(urlConnection instanceof HttpURLConnection)) {
-      return null;
-    }
-
-    HttpURLConnection httpConnection = (HttpURLConnection) urlConnection;
-    String requestMethod = httpConnection.getRequestMethod();
+  @Override public CacheRequest put(Response response) throws IOException {
+    String requestMethod = response.request().method();
 
-    if (maybeRemove(requestMethod, uri)) {
+    if (maybeRemove(response.request())) {
       return null;
     }
     if (!requestMethod.equals(""GET"")) {
@@ -215,23 +175,15 @@ private String uriToKey(URI uri) {
       return null;
     }
 
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    if (httpEngine == null) {
-      // Don't cache unless the HTTP implementation is ours.
+    ResponseHeaders responseHeaders = new ResponseHeaders(null, response.rawHeaders());
+    if (responseHeaders.hasVaryAll()) {
       return null;
     }
 
-    ResponseHeaders response = httpEngine.getResponseHeaders();
-    if (response.hasVaryAll()) {
-      return null;
-    }
-
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
+    Entry entry = new Entry(response);
     DiskLruCache.Editor editor = null;
     try {
-      editor = cache.edit(uriToKey(uri));
+      editor = cache.edit(urlToKey(response.request()));
       if (editor == null) {
         return null;
       }
@@ -243,15 +195,11 @@ private String uriToKey(URI uri) {
     }
   }
 
-  /**
-   * Returns true if the supplied {@code requestMethod} potentially invalidates an entry in the
-   * cache.
-   */
-  private boolean maybeRemove(String requestMethod, URI uri) {
-    if (requestMethod.equals(""POST"") || requestMethod.equals(""PUT"") || requestMethod.equals(
-        ""DELETE"")) {
+  @Override public boolean maybeRemove(Request request) {
+    String method = request.method();
+    if (method.equals(""POST"") || method.equals(""PUT"") || method.equals(""DELETE"")) {
       try {
-        cache.remove(uriToKey(uri));
+        cache.remove(urlToKey(request));
       } catch (IOException ignored) {
         // The cache cannot be written.
       }
@@ -260,20 +208,12 @@ private boolean maybeRemove(String requestMethod, URI uri) {
     return false;
   }
 
-  private void update(CacheResponse conditionalCacheHit, HttpURLConnection httpConnection)
-      throws IOException {
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    URI uri = httpEngine.getUri();
-    ResponseHeaders response = httpEngine.getResponseHeaders();
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
-    DiskLruCache.Snapshot snapshot = (conditionalCacheHit instanceof EntryCacheResponse)
-        ? ((EntryCacheResponse) conditionalCacheHit).snapshot
-        : ((EntrySecureCacheResponse) conditionalCacheHit).snapshot;
+  @Override public void update(Response cached, Response network) {
+    Entry entry = new Entry(network);
+    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
     DiskLruCache.Editor editor = null;
     try {
-      editor = snapshot.edit(); // returns null if snapshot is not current
+      editor = snapshot.edit(); // Returns null if snapshot is not current.
       if (editor != null) {
         entry.writeTo(editor);
         editor.commit();
@@ -293,16 +233,6 @@ private void abortQuietly(DiskLruCache.Editor editor) {
     }
   }
 
-  private HttpEngine getHttpEngine(URLConnection httpConnection) {
-    if (httpConnection instanceof HttpURLConnectionImpl) {
-      return ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
-    } else if (httpConnection instanceof HttpsURLConnectionImpl) {
-      return ((HttpsURLConnectionImpl) httpConnection).getHttpEngine();
-    } else {
-      return null;
-    }
-  }
-
   /**
    * Closes the cache and deletes all of its stored values. This will delete
    * all files in the cache directory including files that weren't created by
@@ -344,7 +274,7 @@ public boolean isClosed() {
     return cache.isClosed();
   }
 
-  private synchronized void trackResponse(ResponseSource source) {
+  @Override public synchronized void trackResponse(ResponseSource source) {
     requestCount++;
 
     switch (source) {
@@ -358,7 +288,7 @@ private synchronized void trackResponse(ResponseSource source) {
     }
   }
 
-  private synchronized void trackConditionalCacheHit() {
+  @Override public synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
@@ -425,7 +355,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
   }
 
   private static final class Entry {
-    private final String uri;
+    private final String url;
     private final RawHeaders varyHeaders;
     private final String requestMethod;
     private final RawHeaders responseHeaders;
@@ -483,7 +413,7 @@ private static final class Entry {
     public Entry(InputStream in) throws IOException {
       try {
         StrictLineReader reader = new StrictLineReader(in, US_ASCII);
-        uri = reader.readLine();
+        url = reader.readLine();
         requestMethod = reader.readLine();
         varyHeaders = new RawHeaders();
         int varyRequestHeaderLineCount = reader.readInt();
@@ -515,26 +445,20 @@ public Entry(InputStream in) throws IOException {
       }
     }
 
-    public Entry(URI uri, RawHeaders varyHeaders, HttpURLConnection httpConnection)
-        throws IOException {
-      this.uri = uri.toString();
-      this.varyHeaders = varyHeaders;
-      this.requestMethod = httpConnection.getRequestMethod();
-      this.responseHeaders = RawHeaders.fromMultimap(httpConnection.getHeaderFields(), true);
-      this.handshake = getHttpEngine(httpConnection).getHandshake();
-    }
-
-    private HttpEngine getHttpEngine(HttpURLConnection httpConnection) {
-      return httpConnection instanceof HttpsURLConnectionImpl
-          ? ((HttpsURLConnectionImpl) httpConnection).getHttpEngine()
-          : ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
+    public Entry(Response response) {
+      this.url = response.request().urlString();
+      this.varyHeaders = response.request().rawHeaders().getAll(
+          new ResponseHeaders(null, response.rawHeaders()).getVaryFields());
+      this.requestMethod = response.request().method();
+      this.responseHeaders = response.rawHeaders();
+      this.handshake = response.handshake();
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
       OutputStream out = editor.newOutputStream(ENTRY_METADATA);
       Writer writer = new BufferedWriter(new OutputStreamWriter(out, UTF_8));
 
-      writer.write(uri + '\n');
+      writer.write(url + '\n');
       writer.write(requestMethod + '\n');
       writer.write(Integer.toString(varyHeaders.length()) + '\n');
       for (int i = 0; i < varyHeaders.length(); i++) {
@@ -557,7 +481,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
     }
 
     private boolean isHttps() {
-      return uri.startsWith(""https://"");
+      return url.startsWith(""https://"");
     }
 
     private List<Certificate> readCertificateList(StrictLineReader reader) throws IOException {
@@ -591,90 +515,62 @@ private void writeCertArray(Writer writer, List<Certificate> certificates) throw
       }
     }
 
-    public boolean matches(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) {
-      return this.uri.equals(uri.toString())
-          && this.requestMethod.equals(requestMethod)
-          && new ResponseHeaders(uri, responseHeaders).varyMatches(varyHeaders.toMultimap(false),
-          requestHeaders);
-    }
-  }
-
-  /**
-   * Returns an input stream that reads the body of a snapshot, closing the
-   * snapshot when the stream is closed.
-   */
-  private static InputStream newBodyInputStream(final DiskLruCache.Snapshot snapshot) {
-    return new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
-      @Override public void close() throws IOException {
-        snapshot.close();
-        super.close();
-      }
-    };
-  }
-
-  static class EntryCacheResponse extends CacheResponse {
-    private final Entry entry;
-    private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
-
-    public EntryCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
-      this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
-    }
-
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
+    public boolean matches(Request request) {
+      return url.equals(request.urlString())
+          && requestMethod.equals(request.method())
+          && new ResponseHeaders(null, responseHeaders).varyMatches(varyHeaders, request);
     }
 
-    @Override public InputStream getBody() {
-      return in;
+    public Response response(Request request, DiskLruCache.Snapshot snapshot) {
+      String contentType = responseHeaders.get(""Content-Type"");
+      String contentLength = responseHeaders.get(""Content-Length"");
+      return new Response.Builder(request, responseHeaders.getResponseCode())
+          .rawHeaders(responseHeaders)
+          .body(new CacheResponseBody(snapshot, contentType, contentLength))
+          .handshake(handshake)
+          .build();
     }
   }
 
-  static class EntrySecureCacheResponse extends SecureCacheResponse {
-    private final Entry entry;
+  private static class CacheResponseBody extends Response.Body {
     private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
+    private final InputStream bodyIn;
+    private final String contentType;
+    private final String contentLength;
 
-    public EntrySecureCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
+    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+        String contentType, String contentLength) {
       this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
-    }
-
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
-    }
-
-    @Override public InputStream getBody() {
-      return in;
-    }
+      this.contentType = contentType;
+      this.contentLength = contentLength;
 
-    @Override public String getCipherSuite() {
-      return entry.handshake.cipherSuite();
+      // This input stream closes the snapshot when the stream is closed.
+      this.bodyIn = new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
+        @Override public void close() throws IOException {
+          snapshot.close();
+          super.close();
+        }
+      };
     }
 
-    @Override public List<Certificate> getServerCertificateChain()
-        throws SSLPeerUnverifiedException {
-      if (entry.handshake.peerCertificates().isEmpty()) throw new SSLPeerUnverifiedException(null);
-      return entry.handshake.peerCertificates();
+    @Override public boolean ready() throws IOException {
+      return true;
     }
 
-    @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-      if (entry.handshake.peerCertificates().isEmpty()) throw new SSLPeerUnverifiedException(null);
-      return entry.handshake.peerPrincipal();
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
     }
 
-    @Override public List<Certificate> getLocalCertificateChain() {
-      return !entry.handshake.localCertificates().isEmpty()
-          ? entry.handshake.localCertificates()
-          : null;
+    @Override public long contentLength() {
+      try {
+        return contentLength != null ? Long.parseLong(contentLength) : -1;
+      } catch (NumberFormatException e) {
+        return -1;
+      }
     }
 
-    @Override public Principal getLocalPrincipal() {
-      return entry.handshake.localPrincipal();
+    @Override public InputStream byteStream() {
+      return bodyIn;
     }
   }
 }
@@ -22,7 +22,6 @@
 import com.squareup.okhttp.internal.http.Policy;
 import com.squareup.okhttp.internal.http.RawHeaders;
 import java.io.IOException;
-import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.URL;
@@ -61,11 +60,7 @@ public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
   }
 
   @Override public boolean getUseCaches() {
-    return false; // TODO.
-  }
-
-  @Override public HttpURLConnection getHttpConnectionToCache() {
-    return null;
+    return true;
   }
 
   @Override public URL getURL() {
@@ -19,7 +19,6 @@
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.OkResponseCacheAdapter;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.net.CookieHandler;
 import java.net.HttpURLConnection;
@@ -48,7 +47,7 @@ public final class OkHttpClient implements URLStreamHandlerFactory {
   private List<String> transports;
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
-  private ResponseCache responseCache;
+  private OkResponseCache responseCache;
   private SSLSocketFactory sslSocketFactory;
   private HostnameVerifier hostnameVerifier;
   private OkAuthenticator authenticator;
@@ -169,24 +168,40 @@ public CookieHandler getCookieHandler() {
    *
    * <p>If unset, the {@link ResponseCache#getDefault() system-wide default}
    * response cache will be used.
+   *
+   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
+   *     is broken for many reasons: URI instead of URL, no conditional updates,
+   *     no invalidation, and no mechanism for tracking hit rates. Use
+   *     {@link #setOkResponseCache} instead.
    */
+  @Deprecated
   public OkHttpClient setResponseCache(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-    return this;
+    if (responseCache instanceof OkResponseCache) {
+      return setOkResponseCache((OkResponseCache) responseCache);
+    }
+    throw new UnsupportedOperationException(""OkHttp 2 dropped support for java.net.ResponseCache. ""
+        + ""Use setOkResponseCache() instead."");
   }
 
+  /**
+   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
+   *     is broken for many reasons: URI instead of URL, no conditional updates,
+   *     no invalidation, and no mechanism for tracking hit rates. Use
+   *     {@link #setOkResponseCache} instead.
+   */
+  @Deprecated
   public ResponseCache getResponseCache() {
-    return responseCache;
+    throw new UnsupportedOperationException(""OkHttp 2 dropped support for java.net.ResponseCache. ""
+        + ""Use setOkResponseCache() instead."");
+  }
+
+  public OkHttpClient setOkResponseCache(OkResponseCache responseCache) {
+    this.responseCache = responseCache;
+    return this;
   }
 
   public OkResponseCache getOkResponseCache() {
-    if (responseCache instanceof HttpResponseCache) {
-      return ((HttpResponseCache) responseCache).okResponseCache;
-    } else if (responseCache != null) {
-      return new OkResponseCacheAdapter(responseCache);
-    } else {
-      return null;
-    }
+    return responseCache;
   }
 
   /**
@@ -319,19 +334,24 @@ public List<String> getTransports() {
 
   /**
    * Schedules {@code request} to be executed.
+   *
+   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
+   * This method is in beta. APIs are subject to change!
    */
-  /* OkHttp 2.0: public */ void enqueue(Request request, Response.Receiver responseReceiver) {
-    // Create the HttpURLConnection immediately so the enqueued job gets the current settings of
-    // this client. Otherwise changes to this client (socket factory, redirect policy, etc.) may
-    // incorrectly be reflected in the request when it is dispatched later.
+  public void enqueue(Request request, Response.Receiver responseReceiver) {
+    // Copy this client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is dispatched.
     dispatcher.enqueue(copyWithDefaults(), request, responseReceiver);
   }
 
   /**
    * Cancels all scheduled tasks tagged with {@code tag}. Requests that are already
    * in flight might not be canceled.
+   *
+   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
+   * This method is in beta. APIs are subject to change!
    */
-  /* OkHttp 2.0: public */ void cancel(Object tag) {
+  public void cancel(Object tag) {
     dispatcher.cancel(tag);
   }
 
@@ -358,7 +378,9 @@ private OkHttpClient copyWithDefaults() {
     result.proxy = proxy;
     result.proxySelector = proxySelector != null ? proxySelector : ProxySelector.getDefault();
     result.cookieHandler = cookieHandler != null ? cookieHandler : CookieHandler.getDefault();
-    result.responseCache = responseCache != null ? responseCache : ResponseCache.getDefault();
+    result.responseCache = responseCache != null
+        ? responseCache
+        : toOkResponseCacheOrNull(ResponseCache.getDefault());
     result.sslSocketFactory = sslSocketFactory != null
         ? sslSocketFactory
         : HttpsURLConnection.getDefaultSSLSocketFactory();
@@ -376,6 +398,10 @@ private OkHttpClient copyWithDefaults() {
     return result;
   }
 
+  private OkResponseCache toOkResponseCacheOrNull(ResponseCache cache) {
+    return cache instanceof OkResponseCache ? ((OkResponseCache) cache) : null;
+  }
+
   /**
    * Creates a URLStreamHandler as a {@link URL#setURLStreamHandlerFactory}.
    *
@@ -17,12 +17,6 @@
 
 import java.io.IOException;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
 
 /**
  * An extended response cache API. Unlike {@link java.net.ResponseCache}, this
@@ -32,21 +26,25 @@
  * This class is in beta. APIs are subject to change!
  */
 public interface OkResponseCache {
-  CacheResponse get(URI uri, String requestMethod, Map<String, List<String>> requestHeaders)
-      throws IOException;
+  Response get(Request request) throws IOException;
 
-  CacheRequest put(URI uri, URLConnection urlConnection) throws IOException;
+  CacheRequest put(Response response) throws IOException;
 
-  /** Remove any cache entries for the supplied {@code uri} if the request method invalidates. */
-  void maybeRemove(String requestMethod, URI uri) throws IOException;
+  /**
+   * Remove any cache entries for the supplied {@code uri}. Returns true if the
+   * supplied {@code requestMethod} potentially invalidates an entry in the
+   * cache.
+   */
+  // TODO: this shouldn't return a boolean.
+  boolean maybeRemove(Request request) throws IOException;
 
   /**
    * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code httpConnection}. The cached response body is
-   * not updated. If the stored response has changed since {@code
-   * conditionalCacheHit} was returned, this does nothing.
+   * with the headers from {@code network}. The cached response body is not
+   * updated. If the stored response has changed since {@code cached} was
+   * returned, this does nothing.
    */
-  void update(CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException;
+  void update(Response cached, Response network) throws IOException;
 
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
@@ -35,7 +35,7 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Request {
+public final class Request {
   private final URL url;
   private final String method;
   private final RawHeaders headers;
@@ -237,7 +237,8 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
-    Builder rawHeaders(RawHeaders rawHeaders) {
+    // TODO: this shouldn't be public.
+    public Builder rawHeaders(RawHeaders rawHeaders) {
       headers = new RawHeaders(rawHeaders);
       return this;
     }
@@ -18,6 +18,7 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.RawHeaders;
 import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -36,7 +37,7 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Response {
+public final class Response {
   private final Request request;
   private final int code;
   private final Handshake handshake;
@@ -106,7 +107,8 @@ public String headerName(int index) {
     return headers.getFieldName(index);
   }
 
-  RawHeaders rawHeaders() {
+  // TODO: this shouldn't be public.
+  public RawHeaders rawHeaders() {
     return new RawHeaders(headers);
   }
 
@@ -128,7 +130,7 @@ public Response redirectedBy() {
     return redirectedBy;
   }
 
-  public abstract static class Body {
+  public abstract static class Body implements Closeable {
     /** Multiple calls to {@link #charStream()} must return the same instance. */
     private Reader reader;
 
@@ -154,7 +156,7 @@ public abstract static class Body {
      */
     public abstract long contentLength();
 
-    public abstract InputStream byteStream() throws IOException;
+    public abstract InputStream byteStream();
 
     public final byte[] bytes() throws IOException {
       long contentLength = contentLength();
@@ -181,7 +183,7 @@ public final byte[] bytes() throws IOException {
      * of the Content-Type header. If that header is either absent or lacks a
      * charset, this will attempt to decode the response body as UTF-8.
      */
-    public final Reader charStream() throws IOException {
+    public final Reader charStream() {
       if (reader == null) {
         reader = new InputStreamReader(byteStream(), charset());
       }
@@ -201,6 +203,10 @@ private Charset charset() {
       MediaType contentType = contentType();
       return contentType != null ? contentType.charset(UTF_8) : UTF_8;
     }
+
+    @Override public void close() throws IOException {
+      byteStream().close();
+    }
   }
 
   public interface Receiver {
@@ -282,7 +288,8 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
-    Builder rawHeaders(RawHeaders rawHeaders) {
+    // TODO: this shouldn't be public.
+    public Builder rawHeaders(RawHeaders rawHeaders) {
       headers = new RawHeaders(rawHeaders);
       return this;
     }
@@ -46,7 +46,7 @@ abstract class AbstractHttpInputStream extends InputStream {
 
     OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
 
-    // some apps return a null body; for compatibility we treat that like a null cache request
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
     if (cacheBody == null) {
       cacheRequest = null;
     }
@@ -20,37 +20,33 @@
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.TunnelRequest;
 import com.squareup.okhttp.internal.Dns;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.CookieHandler;
-import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.UnknownHostException;
-import java.util.Collections;
 import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
-import static com.squareup.okhttp.internal.Util.EMPTY_BYTE_ARRAY;
+import static com.squareup.okhttp.internal.Util.EMPTY_INPUT_STREAM;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -82,16 +78,21 @@
  * implementation type of its HttpEngine.
  */
 public class HttpEngine {
-  private static final CacheResponse GATEWAY_TIMEOUT_RESPONSE = new CacheResponse() {
-    @Override public Map<String, List<String>> getHeaders() throws IOException {
-      Map<String, List<String>> result = new HashMap<String, List<String>>();
-      result.put(null, Collections.singletonList(""HTTP/1.1 504 Gateway Timeout""));
-      return result;
+  private static final Response.Body EMPTY_BODY = new Response.Body() {
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
+    @Override public MediaType contentType() {
+      return null;
+    }
+    @Override public long contentLength() {
+      return 0;
     }
-    @Override public InputStream getBody() throws IOException {
-      return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
+    @Override public InputStream byteStream() {
+      return EMPTY_INPUT_STREAM;
     }
   };
+
   public static final int HTTP_CONTINUE = 100;
 
   protected final Policy policy;
@@ -111,15 +112,9 @@ public class HttpEngine {
   private InputStream responseTransferIn;
   private InputStream responseBodyIn;
 
-  private CacheResponse cacheResponse;
-  private CacheRequest cacheRequest;
-
   /** The time when the request headers were written, or -1 if they haven't been written yet. */
   long sentRequestMillis = -1;
 
-  /** Whether the connection has been established. */
-  boolean connected;
-
   /**
    * True if this client added an ""Accept-Encoding: gzip"" header field and is
    * therefore responsible for also decompressing the transfer stream.
@@ -133,12 +128,16 @@ public class HttpEngine {
   /** Null until a response is received from the network or the cache. */
   ResponseHeaders responseHeaders;
 
-  // The cache response currently being validated on a conditional get. Null
-  // if the cached response doesn't exist or doesn't need validation. If the
-  // conditional get succeeds, these will be used for the response headers and
-  // body. If it fails, these be closed and set to null.
-  private ResponseHeaders cachedResponseHeaders;
-  private InputStream cachedResponseBody;
+  /**
+   * The cache response currently being validated on a conditional get. Null
+   * if the cached response doesn't exist or doesn't need validation. If the
+   * conditional get succeeds, these will be used for the response. If it fails,
+   * it will be set to null.
+   */
+  private Response validatingResponse;
+
+  /** The cache request currently being populated from a network response. */
+  private CacheRequest cacheRequest;
 
   /**
    * True if the socket connection should be released to the connection pool
@@ -173,11 +172,8 @@ public HttpEngine(OkHttpClient client, Policy policy, String method, RawHeaders
 
     this.requestHeaders = new RequestHeaders(uri, new RawHeaders(requestHeaders));
 
-    if (connection != null) {
-      connected = true;
-      if (connection.getSocket() instanceof SSLSocket) {
-        handshake = Handshake.get(((SSLSocket) connection.getSocket()).getSession());
-      }
+    if (connection != null && connection.getSocket() instanceof SSLSocket) {
+      handshake = Handshake.get(((SSLSocket) connection.getSocket()).getSession());
     }
   }
 
@@ -204,16 +200,21 @@ public final void sendRequest() throws IOException {
 
     // The raw response source may require the network, but the request
     // headers may forbid network use. In that case, dispose of the network
-    // response and use a GATEWAY_TIMEOUT response instead, as specified
+    // response and use a gateway timeout response instead, as specified
     // by http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
     if (requestHeaders.isOnlyIfCached() && responseSource.requiresConnection()) {
       if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-        Util.closeQuietly(cachedResponseBody);
+        Util.closeQuietly(validatingResponse.body());
       }
       this.responseSource = ResponseSource.CACHE;
-      this.cacheResponse = GATEWAY_TIMEOUT_RESPONSE;
-      RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(cacheResponse.getHeaders(), true);
-      setResponse(new ResponseHeaders(uri, rawResponseHeaders), cacheResponse.getBody());
+
+      RawHeaders gatewayTimeoutHeaders = new RawHeaders();
+      gatewayTimeoutHeaders.setStatusLine(""HTTP/1.1 504 Gateway Timeout"");
+      this.validatingResponse = new Response.Builder(request(), 504)
+          .rawHeaders(gatewayTimeoutHeaders)
+          .body(EMPTY_BODY)
+          .build();
+      promoteValidatingResponse(new ResponseHeaders(uri, gatewayTimeoutHeaders));
     }
 
     if (responseSource.requiresConnection()) {
@@ -235,35 +236,52 @@ private void initResponseSource() throws IOException {
     OkResponseCache responseCache = client.getOkResponseCache();
     if (responseCache == null) return;
 
-    CacheResponse candidate = responseCache.get(
-        uri, method, requestHeaders.getHeaders().toMultimap(false));
+    Response candidate = responseCache.get(request());
     if (candidate == null) return;
 
-    Map<String, List<String>> responseHeadersMap = candidate.getHeaders();
-    cachedResponseBody = candidate.getBody();
-    if (!acceptCacheResponseType(candidate)
-        || responseHeadersMap == null
-        || cachedResponseBody == null) {
-      Util.closeQuietly(cachedResponseBody);
+    if (!acceptCacheResponseType(candidate)) {
+      Util.closeQuietly(candidate.body());
       return;
     }
 
-    RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(responseHeadersMap, true);
-    cachedResponseHeaders = new ResponseHeaders(uri, rawResponseHeaders);
+    ResponseHeaders cachedResponseHeaders = new ResponseHeaders(uri, candidate.rawHeaders());
     long now = System.currentTimeMillis();
     this.responseSource = cachedResponseHeaders.chooseResponseSource(now, requestHeaders);
     if (responseSource == ResponseSource.CACHE) {
-      this.cacheResponse = candidate;
-      setResponse(cachedResponseHeaders, cachedResponseBody);
+      this.validatingResponse = candidate;
+      promoteValidatingResponse(cachedResponseHeaders);
     } else if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      this.cacheResponse = candidate;
+      this.validatingResponse = candidate;
     } else if (responseSource == ResponseSource.NETWORK) {
-      Util.closeQuietly(cachedResponseBody);
+      Util.closeQuietly(candidate.body());
     } else {
       throw new AssertionError();
     }
   }
 
+  private Request request() {
+    // This doesn't have a body. When we're sending requests to the cache, we don't need it.
+    return new Request.Builder(policy.getURL())
+        .method(method, null)
+        .rawHeaders(requestHeaders.getHeaders())
+        .build();
+  }
+
+  private Response response() {
+    RawHeaders rawHeaders = responseHeaders.getHeaders();
+
+    // Use an unreadable response body when offering the response to the cache. The cache isn't
+    // allowed to consume the response body bytes!
+    Response.Body body = new UnreadableResponseBody(responseHeaders.getContentType(),
+        responseHeaders.getContentLength());
+
+    return new Response.Builder(request(), rawHeaders.getResponseCode())
+        .body(body)
+        .rawHeaders(rawHeaders)
+        .handshake(handshake)
+        .build();
+  }
+
   private void sendSocketRequest() throws IOException {
     if (connection == null) {
       connect();
@@ -322,12 +340,11 @@ protected final void connect() throws IOException {
    * Called after a socket connection has been created or retrieved from the
    * pool. Subclasses use this hook to get a reference to the TLS data.
    */
-  protected void connected(Connection connection) {
+  private void connected(Connection connection) {
     if (handshake == null && connection.getSocket() instanceof SSLSocket) {
       handshake = Handshake.get(((SSLSocket) connection.getSocket()).getSession());
     }
     policy.setSelectedProxy(connection.getRoute().getProxy());
-    connected = true;
   }
 
   /**
@@ -341,17 +358,13 @@ public void writingRequestHeaders() {
     sentRequestMillis = System.currentTimeMillis();
   }
 
-  /**
-   * @param body the response body, or null if it doesn't exist or isn't
-   * available.
-   */
-  private void setResponse(ResponseHeaders headers, InputStream body) throws IOException {
-    if (this.responseBodyIn != null) {
-      throw new IllegalStateException();
-    }
-    this.responseHeaders = headers;
-    if (body != null) {
-      initContentStream(body);
+  private void promoteValidatingResponse(ResponseHeaders responseHeaders) throws IOException {
+    if (this.responseBodyIn != null) throw new IllegalStateException();
+
+    this.responseHeaders = responseHeaders;
+    this.handshake = validatingResponse.handshake();
+    if (validatingResponse.body() != null) {
+      initContentStream(validatingResponse.body().byteStream());
     }
   }
 
@@ -396,20 +409,15 @@ public final InputStream getResponseBody() {
     return responseBodyIn;
   }
 
-  public final CacheResponse getCacheResponse() {
-    return cacheResponse;
-  }
-
   public final Connection getConnection() {
     return connection;
   }
 
   /**
-   * Returns true if {@code cacheResponse} is of the right type. This
-   * condition is necessary but not sufficient for the cached response to
-   * be used.
+   * Returns true if {@code response} is of the right type. This condition is
+   * necessary but not sufficient for the cached response to be used.
    */
-  protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
+  protected boolean acceptCacheResponseType(Response response) {
     return true;
   }
 
@@ -419,16 +427,14 @@ private void maybeCache() throws IOException {
     OkResponseCache responseCache = client.getOkResponseCache();
     if (responseCache == null) return;
 
-    HttpURLConnection connectionToCache = policy.getHttpConnectionToCache();
-
     // Should we cache this response for this request?
     if (!responseHeaders.isCacheable(requestHeaders)) {
-      responseCache.maybeRemove(connectionToCache.getRequestMethod(), uri);
+      responseCache.maybeRemove(request());
       return;
     }
 
     // Offer this request to the cache.
-    cacheRequest = responseCache.put(uri, connectionToCache);
+    cacheRequest = responseCache.put(response());
   }
 
   /**
@@ -452,7 +458,9 @@ public final void automaticallyReleaseConnectionToPool() {
    */
   public final void release(boolean streamCanceled) {
     // If the response body comes from the cache, close it.
-    if (responseBodyIn == cachedResponseBody) {
+    if (validatingResponse != null
+        && validatingResponse.body() != null
+        && responseBodyIn == validatingResponse.body().byteStream()) {
       Util.closeQuietly(responseBodyIn);
     }
 
@@ -477,9 +485,9 @@ private void initContentStream(InputStream transferStream) throws IOException {
       // so clients don't double decompress. http://b/3009828
       //
       // Also remove the Content-Length in this case because it contains the
-      // length 528 of the gzipped response. This isn't terribly useful and is
-      // dangerous because 529 clients can query the content length, but not
-      // the content encoding.
+      // length of the gzipped response. This isn't terribly useful and is
+      // dangerous because clients can query the content length, but not the
+      // content encoding.
       responseHeaders.stripContentEncoding();
       responseHeaders.stripContentLength();
       responseBodyIn = new GZIPInputStream(transferStream);
@@ -614,7 +622,6 @@ protected boolean includeAuthorityInRequestLine() {
    * no TLS connection was made.
    */
   public Handshake getHandshake() {
-    // TODO: initialize handshake when populating a response from the cache.
     return handshake;
   }
 
@@ -672,23 +679,26 @@ public final void readResponse() throws IOException {
     responseHeaders.setResponseSource(responseSource);
 
     if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      if (cachedResponseHeaders.validate(responseHeaders)) {
+      ResponseHeaders validatingResponseHeaders = new ResponseHeaders(
+          uri, validatingResponse.rawHeaders());
+
+      if (validatingResponseHeaders.validate(responseHeaders)) {
         release(false);
-        ResponseHeaders combinedHeaders = cachedResponseHeaders.combine(responseHeaders);
-        this.responseHeaders = combinedHeaders;
+        responseHeaders = validatingResponseHeaders.combine(responseHeaders);
+        handshake = validatingResponse.handshake();
 
-        // Update the cache after applying the combined headers but before initializing the content
-        // stream, otherwise the Content-Encoding header (if present) will be stripped from the
-        // combined headers and not end up in the cache file if transparent gzip compression is
-        // turned on.
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
         OkResponseCache responseCache = client.getOkResponseCache();
         responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, policy.getHttpConnectionToCache());
+        responseCache.update(validatingResponse, response());
 
-        initContentStream(cachedResponseBody);
+        if (validatingResponse.body() != null) {
+          initContentStream(validatingResponse.body().byteStream());
+        }
         return;
       } else {
-        Util.closeQuietly(cachedResponseBody);
+        Util.closeQuietly(validatingResponse.body());
       }
     }
 
@@ -709,4 +719,30 @@ public void receiveHeaders(RawHeaders headers) throws IOException {
       cookieHandler.put(uri, headers.toMultimap(true));
     }
   }
+
+  static class UnreadableResponseBody extends Response.Body {
+    private final String contentType;
+    private final long contentLength;
+
+    public UnreadableResponseBody(String contentType, long contentLength) {
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+    }
+
+    @Override public boolean ready() throws IOException {
+      throw new IllegalStateException(""It is an error to read this response body at this time."");
+    }
+
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
+    }
+
+    @Override public long contentLength() {
+      return contentLength;
+    }
+
+    @Override public InputStream byteStream() {
+      throw new IllegalStateException(""It is an error to read this response body at this time."");
+    }
+  }
 }
@@ -266,10 +266,6 @@ private void initHttpEngine() throws IOException {
     }
   }
 
-  @Override public HttpURLConnection getHttpConnectionToCache() {
-    return this;
-  }
-
   private HttpEngine newHttpEngine(String method, RawHeaders requestHeaders,
       Connection connection, RetryableOutputStream requestBody) throws IOException {
     if (url.getProtocol().equals(""http"")) {
@@ -18,10 +18,9 @@
 
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.TunnelRequest;
 import java.io.IOException;
-import java.net.CacheResponse;
-import java.net.SecureCacheResponse;
 import java.net.URL;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
@@ -32,12 +31,8 @@ public HttpsEngine(OkHttpClient client, Policy policy, String method, RawHeaders
     super(client, policy, method, requestHeaders, connection, requestBody);
   }
 
-  @Override protected void connected(Connection connection) {
-    super.connected(connection);
-  }
-
-  @Override protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
-    return cacheResponse instanceof SecureCacheResponse;
+  @Override protected boolean acceptCacheResponseType(Response response) {
+    return response.handshake() != null;
   }
 
   @Override protected boolean includeAuthorityInRequestLine() {
@@ -21,9 +21,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.HttpURLConnection;
 import java.net.ProtocolException;
-import java.net.SecureCacheResponse;
 import java.net.URL;
 import java.security.Permission;
 import java.security.Principal;
@@ -37,67 +35,45 @@
 
 public final class HttpsURLConnectionImpl extends HttpsURLConnection {
 
-  /** HttpUrlConnectionDelegate allows reuse of HttpURLConnectionImpl. */
-  private final HttpUrlConnectionDelegate delegate;
+  /** Reuse HttpURLConnectionImpl. */
+  private final HttpURLConnectionImpl delegate;
 
   public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
-    delegate = new HttpUrlConnectionDelegate(url, client);
+    delegate = new HttpURLConnectionImpl(url, client);
   }
 
   @Override public String getCipherSuite() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getCipherSuite();
-    }
     Handshake handshake = handshake();
     return handshake != null ? handshake.cipherSuite() : null;
   }
 
   @Override public Certificate[] getLocalCertificates() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getLocalCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
     Handshake handshake = handshake();
     if (handshake == null) return null;
     List<Certificate> result = handshake.localCertificates();
     return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getServerCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
     Handshake handshake = handshake();
     if (handshake == null) return null;
     List<Certificate> result = handshake.peerCertificates();
     return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) return cacheResponse.getPeerPrincipal();
     Handshake handshake = handshake();
     return handshake != null ? handshake.peerPrincipal() : null;
   }
 
   @Override public Principal getLocalPrincipal() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) return cacheResponse.getLocalPrincipal();
     Handshake handshake = handshake();
     return handshake != null ? handshake.localPrincipal() : null;
   }
 
-  public HttpEngine getHttpEngine() {
-    return delegate.getHttpEngine();
-  }
-
   private Handshake handshake() {
-    if (delegate.httpEngine == null || !delegate.httpEngine.connected) {
+    if (delegate.httpEngine == null) {
       throw new IllegalStateException(""Connection has not yet been established"");
     }
     return delegate.httpEngine.getHandshake();
@@ -324,20 +300,4 @@ private Handshake handshake() {
   @Override public SSLSocketFactory getSSLSocketFactory() {
     return delegate.client.getSslSocketFactory();
   }
-
-  private final class HttpUrlConnectionDelegate extends HttpURLConnectionImpl {
-    private HttpUrlConnectionDelegate(URL url, OkHttpClient client) {
-      super(url, client);
-    }
-
-    @Override public HttpURLConnection getHttpConnectionToCache() {
-      return HttpsURLConnectionImpl.this;
-    }
-
-    public SecureCacheResponse getSecureCacheResponse() {
-      return httpEngine instanceof HttpsEngine
-          ? (SecureCacheResponse) httpEngine.getCacheResponse()
-          : null;
-    }
-  }
 }
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkResponseCache;
-import com.squareup.okhttp.ResponseSource;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-
-public final class OkResponseCacheAdapter implements OkResponseCache {
-  private final ResponseCache responseCache;
-  public OkResponseCacheAdapter(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return responseCache.get(uri, requestMethod, requestHeaders);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    return responseCache.put(uri, urlConnection);
-  }
-
-  @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-  }
-
-  @Override public void update(CacheResponse conditionalCacheHit, HttpURLConnection connection)
-      throws IOException {
-  }
-
-  @Override public void trackConditionalCacheHit() {
-  }
-
-  @Override public void trackResponse(ResponseSource source) {
-  }
-}
@@ -15,17 +15,13 @@
  */
 package com.squareup.okhttp.internal.http;
 
-import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URL;
 
 public interface Policy {
   /** Returns true if HTTP response caches should be used. */
   boolean getUseCaches();
 
-  /** Returns the HttpURLConnection instance to store in the cache. */
-  HttpURLConnection getHttpConnectionToCache();
-
   /** Returns the current destination URL, possibly a redirect. */
   URL getURL();
 
@@ -16,15 +16,14 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Request;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.Platform;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URI;
 import java.util.Collections;
 import java.util.Date;
-import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
@@ -381,12 +380,9 @@ public boolean hasVaryAll() {
    * Returns true if none of the Vary headers on this response have changed
    * between {@code cachedRequest} and {@code newRequest}.
    */
-  public boolean varyMatches(Map<String, List<String>> cachedRequest,
-      Map<String, List<String>> newRequest) {
+  public boolean varyMatches(RawHeaders varyHeaders, Request newRequest) {
     for (String field : varyFields) {
-      if (!equal(cachedRequest.get(field), newRequest.get(field))) {
-        return false;
-      }
+      if (!equal(varyHeaders.values(field), newRequest.headers(field))) return false;
     }
     return true;
   }
@@ -20,11 +20,16 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.File;
+import java.net.HttpURLConnection;
+import java.util.UUID;
 import javax.net.ssl.SSLContext;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 public final class AsyncApiTest {
@@ -33,9 +38,17 @@ public final class AsyncApiTest {
   private RecordingReceiver receiver = new RecordingReceiver();
 
   private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private HttpResponseCache cache;
+
+  @Before public void setUp() throws Exception {
+    String tmp = System.getProperty(""java.io.tmpdir"");
+    File cacheDir = new File(tmp, ""HttpCache-"" + UUID.randomUUID());
+    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
+  }
 
   @After public void tearDown() throws Exception {
     server.shutdown();
+    cache.delete();
   }
 
   @Test public void get() throws Exception {
@@ -91,4 +104,22 @@ public final class AsyncApiTest {
     assertEquals(""3"", recordedRequest.getHeader(""Content-Length""));
     assertEquals(""text/plain; charset=utf-8"", recordedRequest.getHeader(""Content-Type""));
   }
+
+  @Test public void cache() throws Exception {
+    server.enqueue(new MockResponse().setBody(""A"").addHeader(""ETag: v1""));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    Request request1 = new Request.Builder(server.getUrl(""/"")).build();
+    client.enqueue(request1, receiver);
+    receiver.await(request1).assertCode(200).assertBody(""A"");
+    assertNull(server.takeRequest().getHeader(""If-None-Match""));
+
+    Request request2 = new Request.Builder(server.getUrl(""/"")).build();
+    client.enqueue(request2, receiver);
+    receiver.await(request2).assertCode(200).assertBody(""A"");
+    assertEquals(""v1"", server.takeRequest().getHeader(""If-None-Match""));
+  }
 }
@@ -18,6 +18,9 @@
 
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
@@ -51,7 +54,6 @@
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -60,6 +62,7 @@
 import java.util.TimeZone;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.GZIPOutputStream;
@@ -201,11 +204,10 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     // exhaust the content stream
     readAscii(conn);
 
-    CacheResponse cached =
-        cache.get(url.toURI(), ""GET"", Collections.<String, List<String>>emptyMap());
+    Response cached = cache.get(new Request.Builder(url).build());
     if (shouldPut) {
       assertNotNull(Integer.toString(responseCode), cached);
-      cached.getBody().close();
+      cached.body().close();
     } else {
       assertNull(Integer.toString(responseCode), cached);
     }
@@ -220,40 +222,25 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     final String body = ""ABCDE"";
     final AtomicInteger cacheCount = new AtomicInteger();
 
-    server.enqueue(
-        new MockResponse().setStatus(""HTTP/1.1 200 Fantastic"").addHeader(""fgh: ijk"").setBody(body));
-    server.play();
-
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        HttpURLConnection httpConnection = (HttpURLConnection) conn;
-        try {
-          httpConnection.getRequestProperties();
-          fail();
-        } catch (IllegalStateException expected) {
-        }
+    server.enqueue(new MockResponse()
+        .setStatus(""HTTP/1.1 200 Fantastic"")
+        .addHeader(""Content-Type: text/plain"")
+        .addHeader(""fgh: ijk"")
+        .setBody(body));
+    server.play();
+
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public CacheRequest put(Response response) throws IOException {
+        assertEquals(server.getUrl(""/""), response.request().url());
+        assertEquals(200, response.code());
+        assertEquals(body.length(), response.body().contentLength());
+        assertEquals(""text/plain"", response.body().contentType().toString());
+        assertEquals(""ijk"", response.header(""fgh""));
         try {
-          httpConnection.addRequestProperty(""K"", ""V"");
+          response.body().byteStream(); // the RI doesn't forbid this, but it should
           fail();
         } catch (IllegalStateException expected) {
         }
-        assertEquals(""HTTP/1.1 200 Fantastic"", httpConnection.getHeaderField(null));
-        assertEquals(Arrays.asList(""HTTP/1.1 200 Fantastic""),
-            httpConnection.getHeaderFields().get(null));
-        assertEquals(200, httpConnection.getResponseCode());
-        assertEquals(""Fantastic"", httpConnection.getResponseMessage());
-        assertEquals(body.length(), httpConnection.getContentLength());
-        assertEquals(""ijk"", httpConnection.getHeaderField(""fgh""));
-        try {
-          httpConnection.getInputStream(); // the RI doesn't forbid this, but it should
-          fail();
-        } catch (IOException expected) {
-        }
         cacheCount.incrementAndGet();
         return null;
       }
@@ -265,6 +252,32 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     assertEquals(1, cacheCount.get());
   }
 
+  /** Don't explode if the cache returns a null body. http://b/3373699 */
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public CacheRequest put(Response response) throws IOException {
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
+      }
+    });
+
+    server.enqueue(new MockResponse().setBody(""abcdef""));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl(""/""));
+    assertEquals(""abc"", readAscii(connection, 3));
+    connection.getInputStream().close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+  }
+
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
   }
@@ -323,32 +336,32 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody(""ABC""));
     server.play();
 
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl(""/""));
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals(""ABC"", readAscii(connection));
+    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl(""/""));
+    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals(""ABC"", readAscii(c1));
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = connection.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(connection.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(connection.getServerCertificates());
-    Principal peerPrincipal = connection.getPeerPrincipal();
-    Principal localPrincipal = connection.getLocalPrincipal();
-
-    connection = (HttpsURLConnection) client.open(server.getUrl(""/"")); // cached!
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals(""ABC"", readAscii(connection));
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.getUrl(""/"")); // cached!
+    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals(""ABC"", readAscii(c2));
 
     assertEquals(2, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(1, cache.getHitCount());
 
-    assertEquals(suite, connection.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(connection.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(connection.getServerCertificates()));
-    assertEquals(peerPrincipal, connection.getPeerPrincipal());
-    assertEquals(localPrincipal, connection.getLocalPrincipal());
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
   }
 
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
@@ -486,15 +499,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody(""ABC""));
     server.play();
 
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
-        new AtomicReference<Map<String, List<String>>>();
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
+    final AtomicReference<Request> requestRef = new AtomicReference<Request>();
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public Response get(Request request) throws IOException {
+        requestRef.set(request);
         return null;
       }
     });
@@ -503,7 +511,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     URLConnection urlConnection = openConnection(url);
     urlConnection.addRequestProperty(""A"", ""android"");
     readAscii(urlConnection);
-    assertEquals(Arrays.asList(""android""), requestHeadersRef.get().get(""A""));
+    assertEquals(Arrays.asList(""android""), requestRef.get().headers(""A""));
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -1903,7 +1911,8 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
     InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
+        ? connection.getInputStream()
+        : httpConnection.getErrorStream();
     StringBuilder result = new StringBuilder();
     for (int i = 0; i < count; i++) {
       int value = in.read();
@@ -2002,4 +2011,27 @@ private class InsecureResponseCache extends ResponseCache {
       return response;
     }
   }
+
+  static abstract class AbstractOkResponseCache implements OkResponseCache {
+    @Override public Response get(Request request) throws IOException {
+      return null;
+    }
+
+    @Override public CacheRequest put(Response response) throws IOException {
+      return null;
+    }
+
+    @Override public boolean maybeRemove(Request request) throws IOException {
+      return false;
+    }
+
+    @Override public void update(Response cached, Response network) throws IOException {
+    }
+
+    @Override public void trackConditionalCacheHit() {
+    }
+
+    @Override public void trackResponse(ResponseSource source) {
+    }
+  }
 }
@@ -60,7 +60,6 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HttpsURLConnection;
@@ -2113,35 +2112,22 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    client.setResponseCache(new ResponseCache() {
+  @Test public void installDeprecatedJavaNetResponseCache() throws Exception {
+    ResponseCache cache = new ResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         return null;
       }
-
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
+        return null;
       }
-    });
-
-    server.enqueue(new MockResponse().setBody(""abcdef""));
-    server.play();
+    };
 
-    HttpURLConnection connection = client.open(server.getUrl(""/""));
-    InputStream in = connection.getInputStream();
-    assertEquals(""abc"", readAscii(in, 3));
-    in.close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+    try {
+      client.setResponseCache(cache);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
   }
 
   /** http://code.google.com/p/android/issues/detail?id=14562 */
",True,"The commit message refers to the limitations of the java.net.ResponseCache API, which is being replaced by OkHttp's OkResponseCache. The message mentions that the API is broken for many reasons, including URI instead of URL, no conditional updates, no invalidation, and no mechanism for tracking hit rates. The commit also introduces a new OkResponseCache API, which addresses these limitations.",True,"The commit message refers to the use of Request and Response types in OkResponseCache, which is a change that is necessary for the functionality of the code. The message does not provide a rationale for the change, but it is clear that the change is not a trivial one, such as adding test cases, typographic fixes, text file changes, annotations, refactorings, or version management.",True,"The commit message explains that the changes are necessary to use Request and Response types in OkResponseCache, which breaks support for java.net.ResponseCache implementations. This is done because the java.net.ResponseCache API is awkward and can't support important features like conditional GETs and hit tracking.",True,"The commit message mentions that the API for java.net.ResponseCache is broken for many reasons, including not supporting important features like conditional GETs and hit tracking. The commit changes the code to use OkHttp's own OkResponseCache interface instead, which addresses these issues.",True,"The commit message mentions that the change is made to use Request and Response types in OkResponseCache, which implies that the change is improving the code by making it more type-safe and easier to use.",True,"The message expresses the use of OkHttp's custom response cache implementation, which is used instead of the default java.net.ResponseCache. This is done to address issues with the java.net.ResponseCache API, such as its use of URI instead of URL, lack of support for conditional GETs, and lack of a mechanism for tracking hit rates.",False,"The commit message does not explicitly state or describe a technical principle underpinning the changes. It mainly focuses on the functionality and behavior of the code changes, such as using Request and Response types in OkResponseCache, breaking support for java.net.ResponseCache implementations, and handling conditional GETs and hit tracking.",True,"The commit message expresses a change in the usage of ResponseCache and OkResponseCache, stating that OkHttp 2.0 dropped support for java.net.ResponseCache due to its limitations. The code diff supports this by removing the usage of java.net.ResponseCache and replacing it with OkResponseCache.",True,"The commit message explains that the change is being made to use Request and Response types in OkResponseCache, which breaks support for java.net.ResponseCache implementations. This is because the new types provide more functionality and flexibility than the old types, and the old types are not able to support important features like conditional GETs and hit tracking. Therefore, it is clear that the change is necessary and that the commit message provides a sufficient explanation for the change."
https://github.com/junit-team/junit4/commit/435d41f0d45cfdbc1a38e1ad4eb1d5300da533f9,"Use Google's Maven Central mirror <enter>  <enter> We are using Maven 3.1.1 which by default uses HTTP instead of HTTPS for <enter> resolving artifacts from Maven Central. Maven Central recently <enter> discontinued HTTP support. Therefore the build on Travis started <enter> failing. By using an HTTPS mirror of Maven Central the build on Travis <enter> will work again. <enter>  <enter> I chose Google's mirror because Travis uses this mirror by default, too. <enter> I did not upgrade to a new version of Maven because there is no newer <enter> version with Java 5 support and it should be possible to build JUnit 4 <enter> with Java 5 so that we can easily ensure that it works with Java 5.",https://api.github.com/repos/junit-team/junit4/commits/435d41f0d45cfdbc1a38e1ad4eb1d5300da533f9,"@@ -1,4 +1,12 @@
 <settings>
+    <mirrors xmlns=""http://maven.apache.org/SETTINGS/1.1.0"">
+        <mirror>
+            <mirrorOf>central</mirrorOf>
+            <name>GCS Maven Central mirror</name>
+            <url>https://maven-central.storage-download.googleapis.com/maven2/</url>
+            <id>google-maven-central</id>
+        </mirror>
+    </mirrors>
     <servers>
         <server>
             <id>junit-snapshot-repo</id>
",True,"The commit message refers to a convention (using HTTPS for resolving artifacts) and a recent change (Maven Central discontinuing HTTP support) to explain the necessity of the changes. It also mentions that the build on Travis started failing due to this issue and that using Google's Maven Central mirror will make the build on Travis work again. This shows that the commit message is describing the changes in relation to a standard, a recent issue, and the benefits of the changes.",True,"The commit message clearly explains the necessity of the changes by stating that Maven Central recently discontinued HTTP support, which was causing the build on Travis to fail. The commit message also explains the specific change made (using Google's HTTPS mirror of Maven Central) and the reason for this choice (Travis uses this mirror by default). The message does not offer a rationale for not upgrading to a newer version of Maven, but it is easy to infer that this is due to the need for Java 5 support.",True,"The commit message clearly explains the motivation for the code change. It mentions that Maven Central recently discontinued HTTP support, which was causing the build on Travis to fail. The commit message then explains that by using an HTTPS mirror of Maven Central, the build on Travis will work again. This directly elaborates the necessity of the changes by describing the error scenario (the build failing due to HTTP support being discontinued) and the solution (using an HTTPS mirror).",True,"The commit message describes the necessity of changes by mentioning that 'Maven Central recently discontinued HTTP support' and 'the build on Travis started failing'. This indicates that the changes are made to address a problem in the software maintenance process, specifically a runtime environment change that is causing the build to fail.",True,"The commit message directly mentions the issue it fixes, which is the failure of the build on Travis due to Maven Central discontinuing HTTP support. It also explains the improvement made to the code, which is using an HTTPS mirror of Maven Central to ensure the build on Travis works again.",True,"The commit message does a good job of summarizing the changes. It explains why the change is necessary (due to Maven Central discontinuing HTTP support), what the change entails (using Google's Maven Central mirror), and why this specific mirror was chosen (because Travis uses it by default). The message also mentions the potential impact of the change (the build on Travis will work again). The code diff supports this explanation by adding a new section to the settings file that sets up the Google Maven Central mirror.",True,"The commit message explains the technical principle underpinning the changes by stating that Maven Central recently discontinued HTTP support, which caused the build on Travis to fail. The solution proposed is to use an HTTPS mirror of Maven Central, which will allow the build on Travis to work again. This highlights the importance of using secure connections when resolving artifacts from external sources.",True,"The commit message accurately summarizes the changes by explaining that the default Maven Central repository is no longer accessible via HTTP, causing the build to fail on Travis. To resolve this, the commit introduces a new configuration that uses Google's Maven Central mirror, which is accessible via HTTPS. This change ensures that the build on Travis will work again. The message also mentions that the choice of Google's mirror is because Travis uses this mirror by default, which adds context to the decision. The message does not explicitly mention the code changes, but the diff clearly shows the addition of a new mirror configuration in the settings.xml file, which supports the explanation in the commit message.",False,"The commit message does not lack an explanation. It clearly states the reason for the change: Maven Central recently discontinued HTTP support, which was causing the build on Travis to fail. The commit message explains that by using an HTTPS mirror of Maven Central, the build on Travis will work again. This is a significant change that requires an explanation."
https://github.com/apache/dubbo/commit/6764744115bffdcd7cde85112611dade6002fe5c,update version to 2.1.6  <enter> git-svn-id:  http://code.alibabatech.com/svn/dubbo/trunk@1550  1a56cb94-b969-4eaa-88fa-be21384802f2 ,https://api.github.com/repos/apache/dubbo/commits/6764744115bffdcd7cde85112611dade6002fe5c,"@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-cluster-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-cluster-faulttolerant</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-cluster-loadbalance</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-cluster-router</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-common</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-config-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-config-guice</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-config-sca</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-config-spring</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-container-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-container-jetty</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-container-log4j</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-container-spring</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-demo</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-demo-consumer</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-demo-provider</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-filter-cache</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-filter-default</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-filter-validation</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-monitor-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-monitor-default</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-monitor-simple</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-default</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-multicast</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-redis</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-simple</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-registry-zookeeper</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-grizzly</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-http</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-mina</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-netty</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-remoting-p2p</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-api</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-default</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-hessian</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-injvm</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-rpc-rmi</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-test-benchmark</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-test-showcase</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo-test-integration</artifactId>
 	<packaging>jar</packaging>
@@ -19,7 +19,7 @@
 	<parent>
 		<groupId>com.alibaba</groupId>
 		<artifactId>dubbo-parent</artifactId>
-		<version>2.2.0-SNAPSHOT</version>
+		<version>2.1.6</version>
 	</parent>
 	<artifactId>dubbo</artifactId>
 	<packaging>jar</packaging>
@@ -22,7 +22,7 @@
 		<version>1.0</version>
 	</parent>
 	<artifactId>dubbo-parent</artifactId>
-	<version>2.2.0-SNAPSHOT</version>
+	<version>2.1.6</version>
 	<packaging>pom</packaging>
 	<name>${project.artifactId}</name>
 	<description>The parent project of dubbo</description>
",False,"The commit message only mentions updating the version to 2.1.6, but it does not explain why this change is necessary, reference any conventions, standards, improvements in prior commits, or implemented features.",True,"The commit message 'update version to 2.1.6' is a clear and concise description of the changes made in the code diff. It directly states the reason for the change, which is to update the version of the project from 2.2.0-SNAPSHOT to 2.1.6. This is a common practice in version management and does not require further explanation.",False,"The commit message only mentions the version update from 2.2.0-SNAPSHOT to 2.1.6. It does not elaborate on the necessity of the changes, such as describing an error scenario, mentioning an issue report, or discussing the shortcomings of the previous implementation.",True,"The commit message 'update version to 2.1.6' indicates that the change is being made to update the version of the project or its dependencies. This could be due to the need for software development to meet new requirements, such as compatibility with a newer version of a library or framework, or it could be due to a problem in the maintenance process, such as the need to fix a bug or security vulnerability in an outdated version.",False,"The commit message only mentions updating the version to 2.1.6, but it does not explicitly describe the objective of the change, such as fixing a defect or making an improvement to the code.",True,"The commit message 'update version to 2.1.6' clearly describes the change made in the code diff. It accurately summarizes the change by pointing out the key component that was modified, which is the version number in the parent POM files. The message contrasts the before and after state of the version number, making it clear that the version was updated from 2.2.0-SNAPSHOT to 2.1.6.",False,"The commit message 'update version to 2.1.6' does not contain an expression that describes a technical principle underpinning the changes. It simply states that the version of the project is being updated. However, it does not explain why this update was made, what problem it solves, or what new feature it introduces. Therefore, the commit message does not provide a clear explanation of the technical principle underpinning the changes.",True,"The commit message 'update version to 2.1.6' clearly describes the change made in the code diff. It indicates that the version of the project is being updated from 2.2.0-SNAPSHOT to 2.1.6. This change does not introduce any new behaviors or functionalities, but it does indicate a change in the version of the project, which could potentially have implications for compatibility or other non-functional aspects.",True,"The commit message 'update version to 2.1.6' clearly and explicitly states the reason for the commit, which is to update the version of the project. The change in the code diff also supports this explanation. Therefore, there was no need for an additional explanation in the commit message."
https://github.com/square/okhttp/commit/15940665526348d815b26d509ce44c79926c612b,Merge: Fix HttpURLConnection CloseGuard warning due to lack of close on GZIPInputStream <enter> Original AOSP/libcore commit by Brian Carlstrom: java.lang.Throwable: Explicit termination method 'end' not called   at dalvik.system.CloseGuard.open(CloseGuard.java:184)   at java.util.zip.Inflater.<init>(Inflater.java:82)   at java.util.zip.GZIPInputStream.<init>(GZIPInputStream.java:96)   at java.util.zip.GZIPInputStream.<init>(GZIPInputStream.java:81)   at libcore.net.http.HttpEngine.initContentStream(HttpEngine.java:523)   at libcore.net.http.HttpEngine.readResponse(HttpEngine.java:831)   at libcore.net.http.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:274)   at libcore.net.http.HttpURLConnectionImpl.getResponseCode(HttpURLConnectionImpl.java:486)   at ... <enter> Bug: 6602529 Change-Id: I9b49cbca561f8780d08844e566820087fdffc4d7 ,https://api.github.com/repos/square/okhttp/commits/15940665526348d815b26d509ce44c79926c612b,"@@ -35,6 +35,7 @@
 import java.util.List;
 import java.util.Map;
 import libcore.io.Base64;
+import libcore.io.IoUtils;
 import libcore.util.Libcore;
 
 /**
@@ -92,6 +93,14 @@ public HttpURLConnectionImpl(URL url, int port, Proxy proxy) {
     @Override public final void disconnect() {
         // Calling disconnect() before a connection exists should have no effect.
         if (httpEngine != null) {
+            // We close the response body here instead of in
+            // HttpEngine.release because that is called when input
+            // has been completely read from the underlying socket.
+            // However the response body can be a GZIPInputStream that
+            // still has unread data.
+            if (httpEngine.hasResponse()) {
+                IoUtils.closeQuietly(httpEngine.getResponseBody());
+            }
             httpEngine.release(false);
         }
     }
@@ -773,6 +773,50 @@ public void testDisconnectBeforeConnect() throws IOException {
         assertEquals(200, connection.getResponseCode());
     }
 
+//    public void testDisconnectAfterOnlyResponseCodeCausesNoCloseGuardWarning() throws IOException {
+//        CloseGuardGuard guard = new CloseGuardGuard();
+//        try {
+//            server.enqueue(new MockResponse()
+//                    .setBody(gzip(""ABCABCABC"".getBytes(""UTF-8"")))
+//                    .addHeader(""Content-Encoding: gzip""));
+//            server.play();
+//
+//            HttpURLConnection connection = (HttpURLConnection) server.getUrl(""/"").openConnection();
+//            assertEquals(200, connection.getResponseCode());
+//            connection.disconnect();
+//            connection = null;
+//            assertFalse(guard.wasCloseGuardCalled());
+//        } finally {
+//            guard.close();
+//        }
+//    }
+//
+//    public static class CloseGuardGuard implements Closeable, CloseGuard.Reporter  {
+//        private final CloseGuard.Reporter oldReporter = CloseGuard.getReporter();
+//
+//        private AtomicBoolean closeGuardCalled = new AtomicBoolean();
+//
+//        public CloseGuardGuard() {
+//            CloseGuard.setReporter(this);
+//        }
+//
+//        @Override public void report(String message, Throwable allocationSite) {
+//            oldReporter.report(message, allocationSite);
+//            closeGuardCalled.set(true);
+//        }
+//
+//        public boolean wasCloseGuardCalled() {
+//            // FinalizationTester.induceFinalization();
+//            close();
+//            return closeGuardCalled.get();
+//        }
+//
+//        @Override public void close() {
+//            CloseGuard.setReporter(oldReporter);
+//        }
+//
+//    }
+
     public void testDefaultRequestProperty() throws Exception {
         URLConnection.setDefaultRequestProperty(""X-testSetDefaultRequestProperty"", ""A"");
         assertNull(URLConnection.getDefaultRequestProperty(""X-setDefaultRequestProperty""));
",True,"The commit message refers to a warning in the code (HttpURLConnection CloseGuard warning) and mentions that it was fixed due to the lack of close on GZIPInputStream. This indicates that the changes were made to improve the code and address a known issue, which is a clear expression of the necessity of changes.",True,"The commit message refers to a warning in the code that is being fixed. The warning is about not closing a GZIPInputStream, which is a common source of resource leaks. The commit message does not provide a detailed explanation of why this is necessary, but it is a common sense fix to prevent potential issues with resource management.",True,The commit message directly elaborates the motivation of the code change by mentioning the warning caused by the lack of close on GZIPInputStream and the original AOSP/libcore commit that introduced the issue. It also references the bug report (6602529) and the change-id for further reference.,True,"The commit message 'Merge: Fix HttpURLConnection CloseGuard warning due to lack of close on GZIPInputStream' indicates that the changes were made to address a problem in the software maintenance process. The problem is a CloseGuard warning that occurs due to the lack of closing the GZIPInputStream. This issue could potentially lead to resource leaks and other problems, so the changes were made to fix it.",True,"The commit message directly mentions the defect it fixes, which is the 'HttpURLConnection CloseGuard warning' caused by the lack of close on GZIPInputStream. This is clearly stated in the message: 'Fix HttpURLConnection CloseGuard warning due to lack of close on GZIPInputStream'.",True,"The commit message 'Merge: Fix HttpURLConnection CloseGuard warning due to lack of close on GZIPInputStream' accurately summarizes the changes made in the diff. It mentions the issue with the CloseGuard warning caused by not closing the GZIPInputStream and the fix that was merged. Additionally, it mentions the original AOSP/libcore commit by Brian Carlstrom and the bug number it addresses. The diff itself also supports this summary by showing the addition of the IoUtils class and the modification of the disconnect() method to close the response body if it's a GZIPInputStream.",True,"The commit message explains that the changes were made to address a warning from CloseGuard due to the lack of closing the GZIPInputStream. This is a technical principle underpinning the changes, as it highlights the importance of properly closing resources to avoid memory leaks and other issues.",True,"The commit message 'Merge: Fix HttpURLConnection CloseGuard warning due to lack of close on GZIPInputStream' describes the changes made to the code. It explains that the changes were made to fix a warning related to CloseGuard not being called on GZIPInputStream. This is further explained in the code diff where a new import for IoUtils is added and a check is made to close the response body if it has a response. This change introduces new behavior where the response body is closed explicitly, which was not the case before, thus fixing the CloseGuard warning.",False,"The commit message does not explicitly explain the reason for the change, but it does reference a bug (6602529) and an original AOSP/libcore commit. This suggests that the change was made to address a specific issue, rather than a simple typo or formatting error. Additionally, the code diff shows that the change is not just a simple removal or addition, but rather a more complex modification to handle the closing of a GZIPInputStream. Therefore, the commit message could benefit from a more detailed explanation of the problem and the solution."
https://github.com/junit-team/junit4/commit/18b23a7ed22080e7412e24060c66cef7fc3b1b93,Fix <issue_link> - correct link to 4.12 release notes ,https://api.github.com/repos/junit-team/junit4/commits/18b23a7ed22080e7412e24060c66cef7fc3b1b93,"@@ -78,8 +78,7 @@
             <li><a href=""https://github.com/junit-team/junit/wiki/Getting-started"">Getting started</a></li>
             <li>Release Notes
               <ul>
-<li>
-<a href=""https://github.com/junit-team/junit/wiki/4.12-release-notes"">4.12</a> - (unreleased)</li>
+<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.12.md"">4.12</a></li>
 <li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.11.md"">4.11</a></li>
 <li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.10.md"">4.10</a></li>
 <li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.9.1.md"">4.9.1</a></li>
",True,"The commit message refers to the necessity of changes by mentioning the issue link and the correction of the link to the 4.12 release notes. This implies that the previous link was incorrect, which is a common issue that needs to be fixed. The change in the link likely points to the correct location of the release notes, which is an improvement over the previous state.",True,"The commit message 'Fix <issue_link> - correct link to 4.12 release notes' clearly describes the necessity of the changes. The code diff shows that the link to the 4.12 release notes was incorrect, and the commit message explains that the change is to correct this link. This is a common sense change that doesn't require a detailed rationale.",False,"The commit message only mentions the issue link and the change made, which is correcting the link to the 4.12 release notes. It does not elaborate on the necessity of the change, such as describing an error scenario, mentioning an issue report, or explaining a shortcoming of the previous implementation.",True,"The commit message 'Fix <issue_link> - correct link to 4.12 release notes' indicates that the developer made a change to correct an outdated link to the 4.12 release notes. This suggests that the outdated link was causing problems in the process of software maintenance, as it was no longer accurate or functional.",True,"The commit message directly mentions the issue it fixes, which is the incorrect link to the 4.12 release notes. The change made in the diff is also clearly related to this issue, as it updates the link to the correct one.",True,"The commit message 'Fix <issue_link> - correct link to 4.12 release notes' does describe a summary of what changes by pointing out the key component of the change, which is the correction of the link to the 4.12 release notes. The diff also supports this by showing the change in the link.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions correcting a link to the 4.12 release notes. The code diff shows that the link to the 4.12 release notes has been updated, but it does not explain why this change was necessary or what technical principle it follows.",False,"The commit message 'Fix <issue_link> - correct link to 4.12 release notes' does not describe the code changes from a functional perspective. It only mentions correcting a link, but it does not explain what the new behavior is or what the changes in the code do. The code diff shows a change in the link for the 4.12 release notes, but the commit message does not explain this change or its functional impact.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'correct link to 4.12 release notes'. The change in the code diff is not trivial, as it involves updating a URL. While the change itself might be small, the reason for the change is significant, as it ensures that users are directed to the correct release notes."
https://github.com/spring-projects/spring-boot/commit/c3e447c84c8a3d46ef300184787d3c6be8b792fc,"Order char encoding filter so it sets encoding before request is read  <enter> For the character encoding filter to work, it's vital that it sets the request's encoding before any other filters attempt to read the request. This commit updates the order of OrderedCharacterEncodingFilter to be HIGHEST_PRECEDENCE and improves the existing test to check that the ordering is as required. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/c3e447c84c8a3d46ef300184787d3c6be8b792fc,"@@ -27,6 +27,8 @@
 import org.junit.rules.ExpectedException;
 import org.springframework.beans.DirectFieldAccessor;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
+import org.springframework.boot.context.web.OrderedHiddenHttpMethodFilter;
+import org.springframework.boot.context.web.OrderedHttpPutFormContentFilter;
 import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Bean;
@@ -145,8 +147,13 @@ public CharacterEncodingFilter myCharacterEncodingFilter() {
 	static class OrderedConfiguration {
 
 		@Bean
-		public HiddenHttpMethodFilter hiddenHttpMethodFilter() {
-			return new HiddenHttpMethodFilter();
+		public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
+			return new OrderedHiddenHttpMethodFilter();
+		}
+
+		@Bean
+		public OrderedHttpPutFormContentFilter httpPutFormContentFilter() {
+			return new OrderedHttpPutFormContentFilter();
 		}
 
 	}
@@ -16,7 +16,6 @@
 
 package org.springframework.boot.context.web;
 
-import org.springframework.boot.context.embedded.FilterRegistrationBean;
 import org.springframework.core.Ordered;
 import org.springframework.web.filter.CharacterEncodingFilter;
 
@@ -29,7 +28,7 @@
 public class OrderedCharacterEncodingFilter extends CharacterEncodingFilter implements
 		Ordered {
 
-	private int order = FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER - 9800;
+	private int order = Ordered.HIGHEST_PRECEDENCE;
 
 	@Override
 	public int getOrder() {
",True,"The commit message explains the necessity of changes by referencing a convention or standard. It mentions that for the character encoding filter to work, it's vital that it sets the request's encoding before any other filters attempt to read the request. This is a common requirement in web applications to ensure proper handling of character encodings. The commit also improves the existing test to check that the ordering is as required, which further supports the explanation for the changes.",True,"The commit message explains the necessity of the changes by stating that for the character encoding filter to work, it's vital that it sets the request's encoding before any other filters attempt to read the request. This is not a common sense or easy to infer change, but rather a specific requirement of the character encoding filter. The code diff also supports this explanation by showing the change in the order of the filter.",True,"The commit message directly elaborates the motivation of the code change by explaining the error scenario ('For the character encoding filter to work, it's vital that it sets the request's encoding before any other filters attempt to read the request') and mentioning the issue it closes. Additionally, the code diff shows that the order of the filter has been changed to HIGHEST_PRECEDENCE, which aligns with the explanation in the commit message.",True,"The commit message indicates that the changes were made to ensure the character encoding filter sets the request's encoding before any other filters attempt to read the request. This is done to address a problem in the software maintenance process, specifically the need to ensure the correct order of operations to ensure the character encoding filter works as intended.",True,"The commit message directly mentions the defect it fixes by stating that 'For the character encoding filter to work, it's vital that it sets the request's encoding before any other filters attempt to read the request. This commit updates the order of OrderedCharacterEncodingFilter to be HIGHEST_PRECEDENCE.' This clearly indicates that the change is made to improve the functionality of the code by fixing a specific issue.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions the reordering of the character encoding filter to have the highest precedence, which is the key component of the change. Additionally, it mentions the improvement of an existing test to check the ordering, further describing the change. The message does not contrast the before and after explicitly, but the mention of the reordering and the change in the test imply the contrast.",True,"The commit message explains that the character encoding filter needs to set the request's encoding before any other filters attempt to read the request. This is a technical principle that underpins the changes, as it ensures that the character encoding filter is executed first in the filter chain.",True,"The commit message accurately describes the changes made to the code. It explains that the character encoding filter's order has been updated to set the request's encoding before any other filters attempt to read the request. This is confirmed by the code diff, which shows that the order of OrderedCharacterEncodingFilter has been changed to HIGHEST_PRECEDENCE. Additionally, the commit message introduces new behaviors by mentioning that the existing test has been improved to check that the ordering is as required. This suggests that additional tests or modifications have been made to ensure the new behavior is functioning correctly.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'For the character encoding filter to work, it's vital that it sets the request's encoding before any other filters attempt to read the request.' This reason is not easily inferred from the code diff, as the change involves reordering filters and updating a test, not a simple modification like removing a space."
https://github.com/square/okhttp/commit/18f2b5e6e69de28f420298862378abfd243096ce,"Fix source compatibility for some Kotlin callsites. ( <pr_link> )  <enter> We had a problem where boolean vals needed to be reverted back to boolean funs. I'd like to go back to vals later, but supporting existing source patterns is more important. <enter> We also had a problem where single abstract method types (SAM types) could be supplied as lambas when calling into Java but not when calling into Kotlin. <enter> I found these by pointing KotlinSourceCompatibilityTest at the OkHttp <enter> Get there like this:   git co  <otherCommit_link> ^   git co  <otherCommit_link>  okhttp/build.gradle   git co  <otherCommit_link>  build.gradle ",https://api.github.com/repos/square/okhttp/commits/18f2b5e6e69de28f420298862378abfd243096ce,"@@ -183,7 +183,7 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
         logger.log(""--> END ${request.method()}"")
       } else if (bodyHasUnknownEncoding(request.headers())) {
         logger.log(""--> END ${request.method()} (encoded body omitted)"")
-      } else if (requestBody.isDuplex) {
+      } else if (requestBody.isDuplex()) {
         logger.log(""--> END ${request.method()} (duplex request body omitted)"")
       } else {
         val buffer = Buffer()
@@ -115,5 +115,13 @@ interface Authenticator {
         return null
       }
     }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_Authenticator"")
+    inline operator fun invoke(
+      crossinline block: (route: Route?, response: Response) -> Request?
+    ): Authenticator = object: Authenticator {
+      override fun authenticate(route: Route?, response: Response) = block(route, response)
+    }
   }
 }
@@ -74,9 +74,9 @@ interface Call : Cloneable {
    * Returns true if this call has been either [executed][execute] or [enqueued][enqueue]. It is an
    * error to execute a call more than once.
    */
-  val isExecuted: Boolean
+  fun isExecuted(): Boolean
 
-  val isCanceled: Boolean
+  fun isCanceled(): Boolean
 
   /**
    * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
@@ -112,6 +112,11 @@ class Dispatcher constructor() {
     this.idleCallback = idleCallback
   }
 
+  // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+  @JvmName(""-deprecated_setIdleCallback"")
+  inline fun setIdleCallback(crossinline idleCallback: () -> Unit) =
+      setIdleCallback(Runnable { idleCallback() })
+
   internal fun enqueue(call: AsyncCall) {
     synchronized(this) {
       readyAsyncCalls.add(call)
@@ -54,5 +54,13 @@ interface Dns {
         }
       }
     }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_Dns"")
+    inline operator fun invoke(
+      crossinline block: (String) -> List<InetAddress>
+    ): Dns = object : Dns {
+      override fun lookup(hostname: String): List<InetAddress> = block(hostname)
+    }
   }
 }
@@ -346,6 +346,16 @@ abstract class EventListener {
      * from this method.**
      */
     fun create(call: Call): EventListener
+
+    companion object {
+      // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+      @JvmName(""-deprecated_Factory"")
+      inline operator fun invoke(
+        crossinline block: (call: Call) -> EventListener
+      ): Factory = object : Factory {
+        override fun create(call: Call) = block(call)
+      }
+    }
   }
 
   companion object {
@@ -27,6 +27,16 @@ interface Interceptor {
   @Throws(IOException::class)
   fun intercept(chain: Chain): Response
 
+  companion object {
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_Interceptor"")
+    inline operator fun invoke(
+      crossinline block: (chain: Chain) -> Response
+    ): Interceptor = object: Interceptor {
+      override fun intercept(chain: Chain) = block(chain)
+    }
+  }
+
   interface Chain {
     fun request(): Request
 
@@ -755,6 +755,16 @@ open class OkHttpClient internal constructor(
       interceptors += interceptor
     }
 
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_addInterceptor"")
+    inline fun addInterceptor(
+      crossinline interceptor: (chain: Interceptor.Chain) -> Response
+    ) = apply {
+      addInterceptor(object : Interceptor {
+        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
+      })
+    }
+
     /**
      * Returns a modifiable list of interceptors that observe a single network request and response.
      * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for a
@@ -766,6 +776,16 @@ open class OkHttpClient internal constructor(
       networkInterceptors += interceptor
     }
 
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_addNetworkInterceptor"")
+    inline fun addNetworkInterceptor(
+      crossinline interceptor: (chain: Interceptor.Chain) -> Response
+    ) = apply {
+      addInterceptor(object : Interceptor {
+        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
+      })
+    }
+
     /**
      * Configure a single client scoped listener that will receive all analytic events for this
      * client.
@@ -786,6 +806,14 @@ open class OkHttpClient internal constructor(
       this.eventListenerFactory = eventListenerFactory
     }
 
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName(""-deprecated_eventListenerFactory"")
+    inline fun eventListenerFactory(crossinline block: (call: Call) -> EventListener) = apply {
+      eventListenerFactory(object : EventListener.Factory {
+        override fun create(call: Call) = block(call)
+      })
+    }
+
     fun build(): OkHttpClient = OkHttpClient(this)
   }
 
@@ -47,17 +47,18 @@ internal class RealCall private constructor(
   private lateinit var transmitter: Transmitter
 
   // Guarded by this.
-  @get:Synchronized override var isExecuted: Boolean = false
+  var executed: Boolean = false
 
-  override val isCanceled: Boolean
-    get() = transmitter.isCanceled
+  @Synchronized override fun isExecuted(): Boolean = executed
+
+  override fun isCanceled(): Boolean = transmitter.isCanceled
 
   override fun request(): Request = originalRequest
 
   override fun execute(): Response {
     synchronized(this) {
-      check(!isExecuted) { ""Already Executed"" }
-      isExecuted = true
+      check(!executed) { ""Already Executed"" }
+      executed = true
     }
     transmitter.timeoutEnter()
     transmitter.callStart()
@@ -71,8 +72,8 @@ internal class RealCall private constructor(
 
   override fun enqueue(responseCallback: Callback) {
     synchronized(this) {
-      check(!isExecuted) { ""Already Executed"" }
-      isExecuted = true
+      check(!executed) { ""Already Executed"" }
+      executed = true
     }
     transmitter.callStart()
     client.dispatcher().enqueue(AsyncCall(responseCallback))
@@ -153,7 +154,7 @@ internal class RealCall private constructor(
    * sensitive information.
    */
   fun toLoggableString(): String {
-    return ((if (isCanceled) ""canceled "" else """")
+    return ((if (isCanceled()) ""canceled "" else """")
         + (if (forWebSocket) ""web socket"" else ""call"")
         + "" to "" + redactedUrl())
   }
@@ -72,7 +72,7 @@ abstract class RequestBody {
    *
    * [grpc]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
    */
-  open val isDuplex: Boolean = false
+  open fun isDuplex(): Boolean = false
 
   /**
    * Returns true if this body expects at most one call to [writeTo] and can be transmitted
@@ -86,7 +86,7 @@ abstract class RequestBody {
    * (HTTP 401 and 407), or a retryable server failure (HTTP 503 with a `Retry-After: 0`
    * header).
    */
-  open val isOneShot: Boolean = false
+  open fun isOneShot(): Boolean = false
 
   companion object {
 
@@ -62,6 +62,8 @@ import javax.net.ssl.SSLSocketFactory
     ""ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE"",
     ""DEPRECATION"",
     ""RedundantExplicitType"",
+    ""RedundantLambdaArrow"",
+    ""UNUSED_ANONYMOUS_PARAMETER"",
     ""UNUSED_VALUE"",
     ""UNUSED_VARIABLE"",
     ""VARIABLE_WITH_REDUNDANT_INITIALIZER""
@@ -97,9 +99,10 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun authenticator() {
-    val authenticator = object : Authenticator {
+    var authenticator: Authenticator = object : Authenticator {
       override fun authenticate(route: Route?, response: Response): Request? = TODO()
     }
+    authenticator = Authenticator { route: Route?, response: Response -> TODO() }
   }
 
   @Test @Ignore
@@ -160,8 +163,8 @@ class KotlinSourceCompatibilityTest {
       override fun execute(): Response = TODO()
       override fun enqueue(responseCallback: Callback) = TODO()
       override fun cancel() = TODO()
-      override val isExecuted: Boolean get() = TODO()
-      override val isCanceled: Boolean get() = TODO()
+      override fun isExecuted(): Boolean = TODO()
+      override fun isCanceled(): Boolean = TODO()
       override fun timeout(): Timeout = TODO()
       override fun clone(): Call = TODO()
     }
@@ -312,6 +315,7 @@ class KotlinSourceCompatibilityTest {
     dispatcher.setIdleCallback(object : Runnable {
       override fun run() = TODO()
     })
+    dispatcher.setIdleCallback { TODO() }
     val queuedCalls: List<Call> = dispatcher.queuedCalls()
     val runningCalls: List<Call> = dispatcher.runningCalls()
     val queuedCallsCount: Int = dispatcher.queuedCallsCount()
@@ -321,9 +325,11 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun dns() {
-    val dns = object : Dns {
+    var dns: Dns = object : Dns {
       override fun lookup(hostname: String): List<InetAddress> = TODO()
     }
+    dns = Dns { it: String -> TODO() }
+
     val system: Dns = Dns.SYSTEM
   }
 
@@ -381,9 +387,10 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun eventListenerBuilder() {
-    val builder = object : EventListener.Factory {
+    var builder: EventListener.Factory = object : EventListener.Factory {
       override fun create(call: Call): EventListener = TODO()
     }
+    builder = EventListener.Factory { it: Call -> TODO() }
   }
 
   @Test @Ignore
@@ -394,7 +401,7 @@ class KotlinSourceCompatibilityTest {
     val name: String = formBody.name(0)
     val encodedValue: String = formBody.encodedValue(0)
     val value: String = formBody.value(0)
-    val contentType: MediaType = formBody.contentType()
+    val contentType: MediaType? = formBody.contentType()
     val contentLength: Long = formBody.contentLength()
     formBody.writeTo(Buffer())
     val requestBody: RequestBody = formBody
@@ -570,9 +577,10 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun interceptor() {
-    val interceptor = object : Interceptor {
+    var interceptor: Interceptor = object : Interceptor {
       override fun intercept(chain: Interceptor.Chain): Response = TODO()
     }
+    interceptor = Interceptor { it: Interceptor.Chain -> TODO() }
   }
 
   @Test @Ignore
@@ -683,14 +691,17 @@ class KotlinSourceCompatibilityTest {
     builder = builder.addInterceptor(object : Interceptor {
       override fun intercept(chain: Interceptor.Chain): Response = TODO()
     })
+    builder = builder.addInterceptor { it: Interceptor.Chain -> TODO() }
     val networkInterceptors: List<Interceptor> = builder.networkInterceptors()
     builder = builder.addNetworkInterceptor(object : Interceptor {
       override fun intercept(chain: Interceptor.Chain): Response = TODO()
     })
+    builder = builder.addNetworkInterceptor { it: Interceptor.Chain -> TODO() }
     builder = builder.eventListener(EventListener.NONE)
     builder = builder.eventListenerFactory(object : EventListener.Factory {
       override fun create(call: Call): EventListener = TODO()
     })
+    builder = builder.eventListenerFactory { it: Call -> TODO() }
     val client: OkHttpClient = builder.build()
   }
 
@@ -749,8 +760,8 @@ class KotlinSourceCompatibilityTest {
     var requestBody: RequestBody = object : RequestBody() {
       override fun contentType(): MediaType? = TODO()
       override fun contentLength(): Long = TODO()
-      override val isDuplex: Boolean get() = TODO()
-      override val isOneShot: Boolean get() = TODO()
+      override fun isDuplex(): Boolean = TODO()
+      override fun isOneShot(): Boolean = TODO()
       override fun writeTo(sink: BufferedSink) = TODO()
     }
     requestBody = RequestBody.create(null, """")
",True,"The commit message refers to the necessity of changes by mentioning the problem of boolean vals needing to be reverted back to boolean funs and the problem with single abstract method types (SAM types) not being compatible when calling into Kotlin. The commit message also explains that supporting existing source patterns is more important than going back to vals, which implies a decision based on a trade-off between improvements and compatibility.",True,"The commit message 'Fix source compatibility for some Kotlin callsites' does not explicitly state the necessity of the changes, but it does describe the problem and the solution. The problem is that boolean vals needed to be reverted back to boolean funs and single abstract method types (SAM types) could be supplied as lambdas when calling into Java but not when calling into Kotlin. The solution is to modify the code to support existing source patterns. This is a common practice in software development to ensure compatibility and maintainability, so the necessity of the changes is implied.",True,The commit message explains the motivation for the changes by mentioning the problem with boolean vals needing to be reverted back to boolean funs and the issue with single abstract method types (SAM types) not being compatible when calling into Kotlin. This directly elaborates the necessity of the changes and provides context for the code changes.,True,"The commit message 'Fix source compatibility for some Kotlin callsites' indicates that the developer made changes to accommodate the need for source compatibility with Kotlin. Specifically, the commit message mentions that boolean vals needed to be reverted back to boolean funs and that single abstract method types (SAM types) could be supplied as lambas when calling into Java but not when calling into Kotlin. These are both issues related to source compatibility between Kotlin and Java, which is a common requirement in software development.",True,"The commit message directly mentions the problem it fixes, which is the need to revert boolean vals back to boolean funs and the issue with single abstract method types (SAM types) not being compatible between Java and Kotlin calls. This clearly describes the objective of the change and the improvements it makes to the code.",True,"The commit message 'Fix source compatibility for some Kotlin callsites' summarizes the changes made in the code diff. It mentions the issue of boolean vals being reverted back to boolean funs and the problem with single abstract method types (SAM types) not being compatible between Java and Kotlin calls. This is a clear description of the changes made in the code, pointing out the key components of the change and contrasting the before and after.",True,The commit message describes the technical principle underpinning the changes by mentioning the problem with boolean vals needing to be reverted back to boolean funs and the problem with single abstract method types (SAM types) not being compatible between Kotlin and Java calls. This is a common issue in interoperability between Kotlin and Java code.,True,"The commit message describes the changes made to the codebase, specifically mentioning that boolean values were reverted back to boolean functions and single abstract method types (SAM types) could be supplied as lambdas when calling into Java but not when calling into Kotlin. This explains the functional perspective of the code changes and introduces new behaviors.",False,"The commit message explains the reason for the change, which is to fix source compatibility for some Kotlin callsites. The change involves modifying boolean vals to boolean funs and adding lambda conversions for Kotlin callers expecting Java SAM (single-abstract-method). The diff shows that the changes are not trivial and require understanding of Kotlin language features and Java interoperability."
https://github.com/square/okhttp/commit/7a3bb19ea44f6771a20d3f5c323cc8bd15d73a56,"Prevent MockSpdyPeer interfering with Android tests  <enter> On Android we run the OkHttp tests as an instrumented test case. The default UncaughtExceptionHandler on Android will quit the app, causing the current test to fail. <enter> MockSpdyPeer creates a thread that fails for various reasons that are not related to / required for the actual test. Often the exception is thrown during a subsequent test. <enter> This change logs the exception but prevent it from propagating out of the top of the call stack. This decreases overall flakiness. ",https://api.github.com/repos/square/okhttp/commits/7a3bb19ea44f6771a20d3f5c323cc8bd15d73a56,"@@ -122,7 +122,7 @@ public void play() throws IOException {
           readAndWriteFrames();
         } catch (IOException e) {
           Util.closeQuietly(MockSpdyPeer.this);
-          throw new RuntimeException(e);
+          e.printStackTrace();
         }
       }
     });
",True,"The commit message explains the necessity of changes by referencing a problem that occurs on Android tests. It mentions that the default UncaughtExceptionHandler on Android will quit the app, causing the current test to fail. This is a common issue when running instrumented tests on Android. The change made in the code diff is to log the exception but prevent it from propagating out of the top of the call stack. This is done to decrease overall flakiness, which is an improvement in prior commits as it reduces the number of test failures.",True,"The commit message explains the necessity of changes by stating that MockSpdyPeer creates a thread that fails for various reasons that are not related to the actual test. This causes the current test to fail on Android, which is an undesirable outcome. The change logs the exception but prevents it from propagating out of the call stack, which decreases overall flakiness. This is a clear explanation of why the changes were made, and it is not common sense or easy to infer from the code diff.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that on Android, the default UncaughtExceptionHandler will quit the app, causing the current test to fail. This is due to MockSpdyPeer creating a thread that fails for reasons unrelated to the actual test. The commit message then explains that this change logs the exception but prevents it from propagating out of the top of the call stack, which decreases overall flakiness in the tests.",True,"The commit message indicates that the changes were made to prevent a problem in the software testing process. The problem is that MockSpdyPeer was causing Android tests to fail due to an UncaughtExceptionHandler that quits the app. This exception was not related to the actual test and was causing subsequent tests to fail. The change logs the exception but prevents it from propagating out of the call stack, which decreases overall flakiness in the tests.",True,"The commit message directly mentions the issue it fixes, which is 'MockSpdyPeer interfering with Android tests' and the change made, which is 'logging the exception but preventing it from propagating out of the top of the call stack'. This change is expected to decrease overall flakiness, which is an improvement to the code.",True,"The commit message does describe a summary of what changes by pointing out the key components of the change. It explains that the change is made to prevent MockSpdyPeer from interfering with Android tests. It mentions that MockSpdyPeer creates a thread that fails, causing the current test to fail or subsequent tests to fail. The change logs the exception and prevents it from propagating out of the call stack, which is described in the code diff. This change is expected to decrease overall flakiness.",False,"The commit message does not explicitly state a technical principle underpinning the changes. It mainly focuses on the problem of MockSpdyPeer interfering with Android tests and the solution of logging the exception and preventing it from propagating out of the call stack. However, it does not describe a general technical principle that could be applied to other situations.",True,"The commit message does a good job of explaining the code changes from a functional perspective. It mentions that the change is to prevent MockSpdyPeer from interfering with Android tests, which is a clear summary of the problem. It then explains that the default UncaughtExceptionHandler on Android will quit the app, causing the current test to fail. This is a new behavior that the change is addressing. The code diff shows that the IOException is no longer being thrown as a RuntimeException, but instead, the exception is logged using e.printStackTrace(). This change is described in the commit message as preventing the exception from propagating out of the call stack, which will decrease overall flakiness in the tests.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'The default UncaughtExceptionHandler on Android will quit the app, causing the current test to fail. MockSpdyPeer creates a thread that fails for various reasons that are not related to / required for the actual test. Often the exception is thrown during a subsequent test.' The change in the code diff (replacing 'throw new RuntimeException(e);' with 'e.printStackTrace();') is also explained in the context of this issue, stating that it 'logs the exception but prevent it from propagating out of the top of the call stack. This decreases overall flakiness.' Therefore, the commit message does not lack an explanation."
https://github.com/apache/dubbo/commit/203078981bb23517703e7bbb60925b8542bc8983,Ignore testStatusChecker since it is unstable and consider removing it later. ,https://api.github.com/repos/apache/dubbo/commits/203078981bb23517703e7bbb60925b8542bc8983,"@@ -27,6 +27,7 @@
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.util.List;
@@ -123,8 +124,12 @@ public void testLookup() {
         assertThat(lookup.size(), is(1));
     }
 
-
+    @Ignore
     @Test
+    /*
+      This UT is unstable, consider remove it later.
+      @see https://github.com/apache/incubator-dubbo/issues/1787
+     */
     public void testStatusChecker() {
         RegistryStatusChecker registryStatusChecker = new RegistryStatusChecker();
         Status status = registryStatusChecker.check();
",,,True,"The commit message explicitly states the reason for the change, which is that the testStatusChecker is unstable and should be ignored. This is not a common sense or easy to infer change, as it requires specific knowledge about the test's stability. The code diff also supports this explanation by adding the @Ignore annotation to the test method.",,,True,"The commit message 'Ignore testStatusChecker since it is unstable and consider removing it later.' indicates that the changes were made due to the instability of the testStatusChecker, which is a problem in the process of software maintenance. The developer added the @Ignore annotation to temporarily disable the test, and the comment suggests that the test should be removed later due to its instability. This is a clear indication of the need for changes to improve the stability and reliability of the software.",True,"The commit message directly mentions the issue with the testStatusChecker being unstable and suggests removing it later. Additionally, the code diff shows the addition of the @Ignore annotation to the testStatusChecker method, which further supports the message's claim.",True,"The commit message explains the reason for the change, which is to ignore the testStatusChecker test case because it is unstable. The code diff also shows that the @Ignore annotation has been added to the testStatusChecker method, which is a clear indication of the change made. Additionally, the commit message provides a link to an issue tracker where more information about the unstable test case can be found. Therefore, the commit message does contain an expression that describes a summary of the changes made.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It merely states that the test is unstable and suggests removing it later. The code diff, however, shows that the test is being ignored using the @Ignore annotation, which is a common practice to temporarily disable a test, but it does not explain why or what principle is being applied.",,,False,"The commit message does not explicitly explain the reason for ignoring the testStatusChecker. While the code diff shows that the test is being ignored, the message could have provided more context about why the test is unstable or why it is being considered for removal."
https://github.com/square/okhttp/commit/29ab48bf0dfbac1b249f2233de08fa948bad11d8,"Fix a race condition in Connection.isExpired().  <enter> This was causing some SPDY connections to be evicted early, and preventing connection reuse. <enter> The spdyConnectionReuse test becomes flaky with the fix that makes MockWebServer use different sequenceNumbers for different requests on the same socket. With the fix the test is no longer flaky. The old test wasn't good enough to detect what it wanted to detect! <enter> This race has existed in the code since we added more aggressive time-based expiration in January 2013. In my basic tests the race impacted ~20% of connections on a desktop VM. It may have been more on mobile. ",https://api.github.com/repos/square/okhttp/commits/29ab48bf0dfbac1b249f2233de08fa948bad11d8,"@@ -633,6 +633,7 @@ public void run() {
   private class SpdySocketHandler implements IncomingStreamHandler {
     private final Socket socket;
     private final Transport transport;
+    private final AtomicInteger sequenceNumber = new AtomicInteger();
 
     private SpdySocketHandler(Socket socket, Transport transport) {
       this.socket = socket;
@@ -684,7 +685,7 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
       String requestLine = method + ' ' + path + ' ' + version;
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
       return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.size(),
-          bodyOut.toByteArray(), 0, socket);
+          bodyOut.toByteArray(), sequenceNumber.getAndIncrement(), socket);
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
@@ -122,15 +122,18 @@ synchronized SpdyStream removeStream(int streamId) {
   }
 
   private synchronized void setIdle(boolean value) {
-    idleStartTimeNs = value ? System.nanoTime() : 0L;
+    idleStartTimeNs = value ? System.nanoTime() : Long.MAX_VALUE;
   }
 
   /** Returns true if this connection is idle. */
   public synchronized boolean isIdle() {
-    return idleStartTimeNs != 0L;
+    return idleStartTimeNs != Long.MAX_VALUE;
   }
 
-  /** Returns the time in ns when this connection became idle or 0L if connection is not idle. */
+  /**
+   * Returns the time in ns when this connection became idle or Long.MAX_VALUE
+   * if connection is not idle.
+   */
   public synchronized long getIdleStartTimeNs() {
     return idleStartTimeNs;
   }
@@ -244,7 +244,7 @@ public boolean isIdle() {
    * {@code keepAliveDurationNs}.
    */
   public boolean isExpired(long keepAliveDurationNs) {
-    return isIdle() && System.nanoTime() - getIdleStartTimeNs() > keepAliveDurationNs;
+    return getIdleStartTimeNs() < System.nanoTime() - keepAliveDurationNs;
   }
 
   /**
@@ -142,7 +142,7 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(""DEF"", readAscii(connection1.getInputStream(), 3));
     assertEquals(""JKL"", readAscii(connection2.getInputStream(), 3));
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   @Test public void gzippedResponseBody() throws Exception {
",True,"The commit message refers to a race condition that was causing some SPDY connections to be evicted early and preventing connection reuse. This is a clear reference to a problem that existed prior to the commit. The message also mentions that the fix makes the 'spdyConnectionReuse' test no longer flaky, which implies that the previous test was not good enough to detect the issue. Additionally, the message mentions that the race has existed in the code since January 2013, which further explains the necessity of the changes.",True,"The commit message describes the necessity of changes by explaining that the race condition in Connection.isExpired() was causing some SPDY connections to be evicted early and preventing connection reuse. This is not a common sense or easy to infer change, as it requires understanding of the specific issue with SPDY connections and the impact of the race condition.",True,The commit message explains the problem that was causing some SPDY connections to be evicted early and preventing connection reuse. It also mentions that the race condition has existed in the code since January 2013 and it impacted ~20% of connections on a desktop VM. This directly elaborates the motivation of the code change and describes the shortcoming of the previous implementation.,True,"The commit message describes the necessity of changes by mentioning a race condition in the code that was causing some SPDY connections to be evicted early and preventing connection reuse. This indicates a problem in the process of software maintenance, specifically a bug that needed to be fixed.",True,"The commit message directly mentions the defect it fixes, which is a race condition in Connection.isExpired(). This was causing some SPDY connections to be evicted early and preventing connection reuse. The message also mentions that the fix makes the spdyConnectionReuse test no longer flaky, which implies that the change improves the code.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions the fix for a race condition in the 'Connection.isExpired()' method, which was causing some SPDY connections to be evicted early and preventing connection reuse. The message also highlights the addition of a new AtomicInteger variable 'sequenceNumber' to handle different sequence numbers for different requests on the same socket, which was necessary to fix a flaky test. Additionally, the message mentions the change in the 'setIdle' and 'isIdle' methods, which sets the 'idleStartTimeNs' variable to Long.MAX_VALUE when the connection is not idle, contrasting the before and after behavior. Overall, the commit message provides a clear and concise summary of the changes made in the code diff.",True,The commit message explains that the changes were made to fix a race condition in the 'Connection.isExpired()' function. This race condition was causing some SPDY connections to be evicted early and preventing connection reuse. The technical principle underpinning the changes is the use of atomic operations to ensure thread safety and prevent race conditions. This is evident in the addition of the 'AtomicInteger sequenceNumber' variable and its usage in the 'readRequest' function.,True,"The commit message describes the functional change of the code by explaining that it fixes a race condition in the Connection.isExpired() method. This was causing some SPDY connections to be evicted early and preventing connection reuse. The message also mentions that the fix introduces a new behavior where MockWebServer uses different sequenceNumbers for different requests on the same socket, which makes the spdyConnectionReuse test no longer flaky. The message does not explicitly mention JSON, but the code diff does not seem to be related to JSON either.",False,"The commit message does not lack an explanation. It clearly states that the fix is to address a race condition in the Connection.isExpired() method, which was causing some SPDY connections to be evicted early and preventing connection reuse. The message also mentions that the fix has been in place since January 2013 and has impacted around 20% of connections on a desktop VM."
https://github.com/junit-team/junit4/commit/1254795902e56eb545e1fe696827924bc5e82b66,"Mark ThreadGroups created by FailOnTimeout as daemon groups ( <pr_link> )  <enter> Mark ThreadGroup created by FailOnTimeout as a daemon group. <enter> Previously, FailOnTimeout destroyed the ThreadGroup, which could cause race conditions if the ThreadGroup was referenced by other threads. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/junit-team/junit4/commits/1254795902e56eb545e1fe696827924bc5e82b66,"@@ -121,28 +121,21 @@ public void evaluate() throws Throwable {
         CallableStatement callable = new CallableStatement();
         FutureTask<Throwable> task = new FutureTask<Throwable>(callable);
         ThreadGroup threadGroup = new ThreadGroup(""FailOnTimeoutGroup"");
-        Thread thread = new Thread(threadGroup, task, ""Time-limited test"");
-        try {
-            thread.setDaemon(true);
-            thread.start();
-            callable.awaitStarted();
-            Throwable throwable = getResult(task, thread);
-            if (throwable != null) {
-                throw throwable;
-            }
-        } finally {
+        if (!threadGroup.isDaemon()) {
             try {
-                thread.join(1);
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-            }
-            try {
-                threadGroup.destroy();
-            } catch (IllegalThreadStateException e) {
-                // If a thread from the group is still alive, the ThreadGroup cannot be destroyed.
-                // Swallow the exception to keep the same behavior prior to this change.
+                threadGroup.setDaemon(true);
+            } catch (SecurityException e) {
+                // Swallow the exception to keep the same behavior as in JUnit 4.12.
             }
         }
+        Thread thread = new Thread(threadGroup, task, ""Time-limited test"");
+        thread.setDaemon(true);
+        thread.start();
+        callable.awaitStarted();
+        Throwable throwable = getResult(task, thread);
+        if (throwable != null) {
+            throw throwable;
+        }
     }
 
     /**
@@ -14,17 +14,16 @@
 import static org.junit.Assert.fail;
 import static org.junit.internal.runners.statements.FailOnTimeout.builder;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Test;
 import org.junit.function.ThrowingRunnable;
+import org.junit.internal.runners.statements.Fail;
 import org.junit.runners.model.Statement;
 import org.junit.runners.model.TestTimedOutException;
 
+
 /**
  * @author Asaf Ary, Stefan Birkner
  */
@@ -91,20 +90,24 @@ public void throwsExceptionWithTimeoutValueAndTimeUnitSet() {
         assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());
     }
 
-    private ThrowingRunnable evaluateWithException(final Exception exception) {
+    private ThrowingRunnable evaluateWithDelegate(final Statement delegate) {
         return new ThrowingRunnable() {
             public void run() throws Throwable {
-                statement.nextException = exception;
+                statement.nextStatement = delegate;
                 statement.waitDuration = 0;
                 failOnTimeout.evaluate();
             }
         };
     }
 
+    private ThrowingRunnable evaluateWithException(Exception exception) {
+        return evaluateWithDelegate(new Fail(exception));
+    }
+
     private ThrowingRunnable evaluateWithWaitDuration(final long waitDuration) {
         return new ThrowingRunnable() {
             public void run() throws Throwable {
-                statement.nextException = null;
+                statement.nextStatement = null;
                 statement.waitDuration = waitDuration;
                 failOnTimeout.evaluate();
             }
@@ -114,13 +117,13 @@ public void run() throws Throwable {
     private static final class TestStatement extends Statement {
         long waitDuration;
 
-        Exception nextException;
+        Statement nextStatement;
 
         @Override
         public void evaluate() throws Throwable {
             sleep(waitDuration);
-            if (nextException != null) {
-                throw nextException;
+            if (nextStatement != null) {
+                nextStatement.evaluate();
             }
         }
     }
@@ -210,20 +213,22 @@ private void notTheRealCauseOfTheTimeout() {
 
     @Test
     public void threadGroupNotLeaked() throws Throwable {
-        Collection<ThreadGroup> groupsBeforeSet = subGroupsOfCurrentThread();
-        
-        evaluateWithWaitDuration(0);
-        
-        for (ThreadGroup group: subGroupsOfCurrentThread()) {
-            if (!groupsBeforeSet.contains(group) && ""FailOnTimeoutGroup"".equals(group.getName())) {
-                fail(""A 'FailOnTimeoutGroup' thread group remains referenced after the test execution."");
+        final AtomicReference<ThreadGroup> innerThreadGroup = new AtomicReference<ThreadGroup>();
+        final AtomicReference<Thread> innerThread = new AtomicReference<Thread>();
+        ThrowingRunnable runnable = evaluateWithDelegate(new Statement() {
+            @Override
+            public void evaluate() {
+                innerThread.set(currentThread());
+                ThreadGroup group = currentThread().getThreadGroup();
+                innerThreadGroup.set(group);
+                assertTrue(""the 'FailOnTimeoutGroup' thread group should be a daemon thread group"", group.isDaemon());
             }
-        }
-    }
-    
-    private Collection<ThreadGroup> subGroupsOfCurrentThread() {
-        ThreadGroup[] subGroups = new ThreadGroup[256];
-        int numGroups = currentThread().getThreadGroup().enumerate(subGroups);
-        return Arrays.asList(subGroups).subList(0, numGroups);
+        });
+
+        runnable.run();
+
+        assertTrue(""the Statement was never run"", innerThread.get() != null);
+        innerThread.get().join();
+        assertTrue(""the 'FailOnTimeoutGroup' thread group should be destroyed after running the test"", innerThreadGroup.get().isDestroyed());
     }
 }
",True,"The commit message refers to a prior issue where the FailOnTimeout destroyed the ThreadGroup, which could cause race conditions if the ThreadGroup was referenced by other threads. The commit message then explains that it marks the ThreadGroup created by FailOnTimeout as a daemon group to fix this issue, thereby improving the functionality and addressing a potential problem.",True,"The commit message explains the necessity of the changes by mentioning the potential race conditions that could occur if the ThreadGroup was referenced by other threads after it was destroyed. This is not a common sense or easy to infer change, as it involves modifying thread behavior and could have unintended consequences if not handled correctly.",True,"The commit message explains the motivation for the change by mentioning the issue it fixes. It states that previously, the FailOnTimeout destroyed the ThreadGroup, which could cause race conditions if the ThreadGroup was referenced by other threads. The change marks the ThreadGroup created by FailOnTimeout as a daemon group to prevent this issue.",True,"The commit message indicates that the developer made changes to address a problem in the process of software maintenance. The problem is that the ThreadGroup created by FailOnTimeout was not being destroyed, which could cause race conditions if the ThreadGroup was referenced by other threads. The changes made in the code diff are to mark the ThreadGroup as a daemon group, which ensures that it will be destroyed when the main thread exits, addressing the issue.",True,"The commit message directly mentions the issue it fixes, which is the potential race condition caused by the destruction of the ThreadGroup if it was referenced by other threads. The change made to the code is also clearly described in the message, which is marking the ThreadGroup created by FailOnTimeout as a daemon group to prevent this issue.",True,"The commit message 'Mark ThreadGroups created by FailOnTimeout as daemon groups' accurately summarizes the change made in the code diff. The diff shows that the ThreadGroup created by FailOnTimeout is now being marked as a daemon group, which was not the case before. This change is explicitly mentioned in the commit message, making it a summary of the diffs and pointing out the key component of the change.",True,"The commit message explains that the changes are made to prevent race conditions that could occur if the ThreadGroup created by FailOnTimeout was referenced by other threads after it was destroyed. This is achieved by marking the ThreadGroup as a daemon group, which ensures that it will be automatically destroyed when all its non-daemon threads have finished executing.",True,"The commit message 'Mark ThreadGroups created by FailOnTimeout as daemon groups' accurately describes the code changes. The code diff shows that the ThreadGroup created by FailOnTimeout is now being marked as a daemon group. This change prevents the ThreadGroup from causing race conditions if it was referenced by other threads, as previously the ThreadGroup was being destroyed. The commit message clearly explains this new behavior.",False,"The commit message does not lack an explanation. It clearly states that the change is made to prevent race conditions that could occur if the ThreadGroup was referenced by other threads after it was destroyed. This is a significant change that requires explanation, even though the code diff might suggest otherwise."
https://github.com/junit-team/junit4/commit/1ef449139923a22333f262dc8c75fa057903040c,Increase running time of statement. Fixes <issue_link> .  <enter> The time between starting the statement and calling the future is arbitrary. Now the execution time of the statement is very very long. This ensures that the statement is not already finished when the future is called. ,https://api.github.com/repos/junit-team/junit4/commits/1ef449139923a22333f262dc8c75fa057903040c,"@@ -23,10 +23,9 @@
 /**
  * @author Asaf Ary, Stefan Birkner
  */
-// TODO Fix this. See https://github.com/junit-team/junit/issues/963
-@Ignore
 public class FailOnTimeoutTest {
     private static final int TIMEOUT = 100;
+    private static final int DURATION_THAT_EXCEEDS_TIMEOUT = Integer.MAX_VALUE;
 
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
@@ -39,13 +38,13 @@ public class FailOnTimeoutTest {
     @Test
     public void throwsTestTimedOutException() throws Throwable {
         thrown.expect(TestTimedOutException.class);
-        evaluateWithWaitDuration(TIMEOUT + 50);
+        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
     }
 
     @Test
     public void throwExceptionWithNiceMessageOnTimeout() throws Throwable {
         thrown.expectMessage(""test timed out after 100 milliseconds"");
-        evaluateWithWaitDuration(TIMEOUT + 50);
+        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
     }
 
     @Test
@@ -60,7 +59,7 @@ public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime()
             throws Throwable {
         thrown.expect(TestTimedOutException.class);
         evaluateWithWaitDuration(0);
-        evaluateWithWaitDuration(TIMEOUT + 50);
+        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
     }
 
     @Test
@@ -71,14 +70,14 @@ public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException()
             evaluateWithException(new RuntimeException());
         } catch (Throwable expected) {
         }
-        evaluateWithWaitDuration(TIMEOUT + 50);
+        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
     }
 
     @Test
     public void throwsExceptionWithTimeoutValueAndTimeUnitSet()
             throws Throwable {
         try {
-            evaluateWithWaitDuration(TIMEOUT + 50);
+            evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
             fail(""No exception was thrown when test timed out"");
         } catch (TestTimedOutException e) {
             assertEquals(TIMEOUT, e.getTimeout());
",True,"The commit message refers to the necessity of changes by mentioning the issue link (<issue_link>) and explaining that the previous running time of the statement was arbitrary and could lead to the statement being finished before the future was called. The changes made ensure that the statement's execution time is significantly longer than the timeout, addressing the issue and improving the reliability of the test.",True,"The commit message explains the necessity of the changes by stating that the previous running time of the statement was too short, causing the future to be called before the statement was finished. This is not a common sense or easy to infer change, as it requires modifying the code to ensure the statement runs long enough before the future is called.",True,"The commit message directly elaborates the motivation of the code change by mentioning the issue link (https://github.com/junit-team/junit/issues/963) and explaining the error scenario. It states that the previous implementation had a problem where the statement could finish executing before the future was called, causing issues. The commit message also explains that the change increases the running time of the statement to ensure this does not happen.",True,"The commit message mentions that the execution time of the statement was very long, which was done to ensure that the statement is not already finished when the future is called. This indicates that there was a problem in the process of software maintenance, specifically that the code was not functioning as intended due to an outdated or incorrect implementation.",True,The commit message directly mentions the defect it fixes by stating 'The time between starting the statement and calling the future is arbitrary. Now the execution time of the statement is very very long.' This clearly indicates that the change was made to address a problem where the statement was finishing too quickly before the future was called.,True,"The commit message accurately summarizes the changes made in the code diff. It mentions increasing the running time of a statement, which is reflected in the code diff where the wait duration in multiple test methods is changed from a fixed value to a much larger one (DURATION_THAT_EXCEEDS_TIMEOUT). This change ensures that the statement is not already finished when the future is called, as stated in the commit message.",True,"The commit message explains the technical principle underpinning the changes, which is to ensure that a statement is not already finished when the future is called. This is achieved by increasing the execution time of the statement to a duration that exceeds the timeout.",True,The commit message accurately describes the changes made in the code. It explains that the running time of a statement has been increased to ensure that the statement is not already finished when the future is called. This is achieved by changing the wait duration in several test cases to a value that exceeds the timeout.,False,The commit message does not lack an explanation. It clearly states the reason for the commit: 'The time between starting the statement and calling the future is arbitrary. Now the execution time of the statement is very very long. This ensures that the statement is not already finished when the future is called.' This is a significant change that cannot be easily inferred from the code diff alone.
https://github.com/square/okhttp/commit/2594c6c695f2898bba947ea86a7aaac8dcfd4dc4,Don't call callEnd() twice when application interceptors proceed twice.  <enter> I'm working towards reducing the role StreamAllocation plays. <enter>  <issue_link> ,https://api.github.com/repos/square/okhttp/commits/2594c6c695f2898bba947ea86a7aaac8dcfd4dc4,"@@ -88,8 +88,8 @@ public final class ConnectionPoolTest {
           .build();
       Call call = client.newCall(newRequest(addressA));
       Transmitter transmitter = new Transmitter(client, call);
-      transmitter.newStreamAllocation(addressA);
-      transmitter.acquire(c1, true);
+      transmitter.prepareToConnect(call.request());
+      transmitter.acquireConnection(c1, true);
     }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
@@ -186,8 +186,8 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
           .build();
       Call call = client.newCall(newRequest(connection.route().address()));
       Transmitter transmitter = new Transmitter(client, call);
-      transmitter.newStreamAllocation(call.request());
-      transmitter.acquire(connection, true);
+      transmitter.prepareToConnect(call.request());
+      transmitter.acquireConnection(connection, true);
     }
   }
 
@@ -1139,4 +1139,33 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
         ""CallEnd"");
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
+
+  @Test public void applicationInterceptorProceedsMultipleTimes() throws Exception {
+    server.enqueue(new MockResponse().setBody(""a""));
+    server.enqueue(new MockResponse().setBody(""b""));
+
+    client = client.newBuilder()
+        .addInterceptor(chain -> {
+          try (Response a = chain.proceed(chain.request())) {
+            assertEquals(""a"", a.body().string());
+          }
+          return chain.proceed(chain.request());
+        })
+        .build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
+    Response response = call.execute();
+    assertEquals(""b"", response.body().string());
+
+    List<String> expectedEvents = Arrays.asList(""CallStart"", ""DnsStart"", ""DnsEnd"",
+        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
+        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
+        ""ResponseBodyEnd"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"",
+        ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"",
+        ""CallEnd"");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
 }
@@ -110,17 +110,20 @@ public synchronized int connectionCount() {
   }
 
   /**
-   * Acquires a recycled connection to {@code address} for {@code streamAllocation}. If non-null
-   * {@code route} is the resolved route for a connection.
+   * Attempts to acquire a recycled connection to {@code address} for {@code transmitter}. If
+   * non-null {@code route} is the resolved route for a connection. Returns true if a connection was
+   * acquired.
    */
-  void acquire(Address address, Transmitter transmitter, @Nullable Route route) {
+  boolean transmitterAcquirePooledConnection(
+      Address address, Transmitter transmitter, @Nullable Route route) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
       if (connection.isEligible(address, route)) {
-        transmitter.acquire(connection, true);
-        return;
+        transmitter.acquireConnection(connection, true);
+        return true;
       }
     }
+    return false;
   }
 
   /**
@@ -149,9 +149,9 @@ public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory
         return pool.connectionBecameIdle(connection);
       }
 
-      @Override public void acquire(ConnectionPool pool, Address address,
-          Transmitter transmitter, @Nullable Route route) {
-        pool.acquire(address, transmitter, route);
+      @Override public boolean transmitterAcquirePooledConnection(
+          ConnectionPool pool, Address address, Transmitter transmitter, @Nullable Route route) {
+        return pool.transmitterAcquirePooledConnection(address, transmitter, route);
       }
 
       @Override public boolean equalsNonHost(Address a, Address b) {
@@ -259,6 +259,10 @@ Response getResponseWithInterceptorChain() throws IOException {
         originalRequest, this, client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis());
 
-    return chain.proceed(originalRequest);
+    try {
+      return chain.proceed(originalRequest);
+    } finally {
+      transmitter.noMoreStreamsOnCall();
+    }
   }
 }
@@ -51,8 +51,8 @@ public static void initializeInstanceForTests() {
 
   public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
 
-  public abstract void acquire(ConnectionPool pool, Address address,
-      Transmitter transmitter, @Nullable Route route);
+  public abstract boolean transmitterAcquirePooledConnection(
+      ConnectionPool pool, Address address, Transmitter transmitter, @Nullable Route route);
 
   public abstract boolean equalsNonHost(Address a, Address b);
 
@@ -44,6 +44,8 @@
 import okio.ForwardingSink;
 import okio.Sink;
 
+import static okhttp3.internal.Util.sameConnection;
+
 /**
  * Bridge between OkHttp's application and network layers. This class exposes high-level application
  * layer primitives: connections, requests, responses, and streams.
@@ -55,6 +57,7 @@ public final class Transmitter {
 
   private @Nullable Object callStackTrace;
 
+  private Request request;
   private volatile boolean canceled;
   private volatile StreamAllocation streamAllocation;
 
@@ -68,13 +71,24 @@ public void setCallStackTrace(@Nullable Object callStackTrace) {
     this.callStackTrace = callStackTrace;
   }
 
-  public void newStreamAllocation(Request request) {
-    newStreamAllocation(createAddress(request.url()));
-  }
+  /**
+   * Prepare to create a stream to carry {@code request}. This prefers to use the existing
+   * connection if it exists.
+   */
+  public void prepareToConnect(Request request) {
+    if (this.request != null) {
+      if (sameConnection(this.request.url(), request.url())) {
+        return; // Already ready.
+      }
+      if (streamAllocation != null) {
+        streamAllocation.transmitterReleaseConnection(false);
+        streamAllocation = null;
+      }
+    }
 
-  public void newStreamAllocation(Address address) {
+    this.request = request;
     this.streamAllocation = new StreamAllocation(this, client.connectionPool(),
-        address, call, eventListener, callStackTrace);
+        createAddress(request.url()), call, eventListener, callStackTrace);
   }
 
   private Address createAddress(HttpUrl url) {
@@ -116,7 +130,7 @@ public void streamFailed(@Nullable IOException e) {
   }
 
   public void noNewStreams() {
-    streamAllocation.noNewStreams();
+    streamAllocation.noNewStreamsOnConnection();
   }
 
   public RealWebSocket.Streams newWebSocketStreams() {
@@ -141,8 +155,10 @@ public boolean isConnectionMultiplexed() {
     return streamAllocation.connection().isMultiplexed();
   }
 
-  public void releaseStreamAllocation(boolean callEnd) {
-    streamAllocation.release(callEnd);
+  public void noMoreStreamsOnCall() {
+    if (streamAllocation != null) {
+      streamAllocation.transmitterReleaseConnection(true);
+    }
   }
 
   public boolean hasMoreRoutes() {
@@ -214,8 +230,8 @@ public boolean supportsUrl(HttpUrl url) {
     return streamAllocation.connection().supportsUrl(url);
   }
 
-  public void acquire(RealConnection connection, boolean reportedAcquired) {
-    streamAllocation.acquire(connection, reportedAcquired);
+  public void acquireConnection(RealConnection connection, boolean reportedAcquired) {
+    streamAllocation.transmitterAcquireConnection(connection, reportedAcquired);
   }
 
   public RealConnection connection() {
@@ -678,4 +678,11 @@ public static String getSystemProperty(String key, @Nullable String defaultValue
     }
     return value != null ? value : defaultValue;
   }
+
+  /** Returns true if an HTTP request for {@code a} and {@code b} can reuse a connection. */
+  public static boolean sameConnection(HttpUrl a, HttpUrl b) {
+    return a.host().equals(b.host())
+        && a.port() == b.port()
+        && a.scheme().equals(b.scheme());
+  }
 }
@@ -50,25 +50,26 @@
  *         connections. Each connection has its own allocation limit, which defines how many
  *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
  *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *         its follow up requests. We prefer to keep all streams of a single call on the same
- *         connection for better behavior and locality.
+ *     <li><strong>Transmitters:</strong> a logical sequence of streams, typically an initial
+ *         request and its follow up requests. We prefer to keep all streams of a single {@link
+ *         Call} on the same connection for better behavior and locality.
  * </ul>
  *
- * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
- * connections. This class has APIs to release each of the above resources:
+ * <p>Instances of this class act on behalf of a single transmitter, using one or more streams over
+ * one or more connections. This class has APIs to release each of the above resources:
  *
  * <ul>
- *     <li>{@link #noNewStreams} prevents the connection from being used for new streams in the
- *         future. Use this after a {@code Connection: close} header, or when the connection may be
- *         inconsistent.
+ *     <li>{@link #noNewStreamsOnConnection} prevents the connection from being used for new streams
+ *         in the future. Use this after a {@code Connection: close} header, or when the connection
+ *         may be inconsistent.
  *     <li>{@link #streamFinished streamFinished} releases the active stream from this allocation.
  *         Note that only one stream may be active at a given time, so it is necessary to call
  *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
  *         #newStream newStream()}.
- *     <li>{@link #release} removes the call's hold on the connection. Note that this won't
- *         immediately free the connection if there is a stream still lingering. That happens when a
- *         call is complete but its response body has yet to be fully consumed.
+ *     <li>{@link #transmitterReleaseConnection} removes the transmitter's hold on the connection.
+ *         Note that this won't immediately free the connection if there is a stream still
+ *         lingering. That happens when a call is complete but its response body has yet to be fully
+ *         consumed.
  * </ul>
  *
  * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
@@ -149,7 +150,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
       // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
       // isn't, take it out of the pool and start again.
       if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        noNewStreams();
+        noNewStreamsOnConnection();
         continue;
       }
 
@@ -189,8 +190,8 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
 
       if (result == null) {
         // Attempt to get a connection from the pool.
-        Internal.instance.acquire(connectionPool, address, transmitter, null);
-        if (connection != null) {
+        if (Internal.instance.transmitterAcquirePooledConnection(
+            connectionPool, address, transmitter, null)) {
           foundPooledConnection = true;
           result = connection;
         } else {
@@ -227,8 +228,8 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         List<Route> routes = routeSelection.getAll();
         for (int i = 0, size = routes.size(); i < size; i++) {
           Route route = routes.get(i);
-          Internal.instance.acquire(connectionPool, address, transmitter, route);
-          if (connection != null) {
+          if (Internal.instance.transmitterAcquirePooledConnection(
+              connectionPool, address, transmitter, route)) {
             foundPooledConnection = true;
             result = connection;
             this.route = route;
@@ -247,7 +248,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         route = selectedRoute;
         refusedStreamCount = 0;
         result = new RealConnection(connectionPool, selectedRoute);
-        acquire(result, false);
+        transmitterAcquireConnection(result, false);
       }
     }
 
@@ -347,7 +348,7 @@ public synchronized RealConnection connection() {
     return connection;
   }
 
-  public void release(boolean callEnd) {
+  public void transmitterReleaseConnection(boolean callEnd) {
     Socket socket;
     Connection releasedConnection;
     synchronized (connectionPool) {
@@ -368,7 +369,7 @@ public void release(boolean callEnd) {
   }
 
   /** Forbid new streams from being created on the connection that hosts this allocation. */
-  public void noNewStreams() {
+  public void noNewStreamsOnConnection() {
     Socket socket;
     Connection releasedConnection;
     synchronized (connectionPool) {
@@ -398,23 +399,15 @@ private Socket deallocate(boolean noNewStreams, boolean released, boolean stream
     if (released) {
       this.released = true;
     }
-    Socket socket = null;
     if (connection != null) {
       if (noNewStreams) {
         connection.noNewStreams = true;
       }
       if (this.codec == null && (this.released || connection.noNewStreams)) {
-        release(connection);
-        if (connection.transmitters.isEmpty()) {
-          connection.idleAtNanos = System.nanoTime();
-          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            socket = connection.socket();
-          }
-        }
-        connection = null;
+        return transmitterReleaseConnection();
       }
     }
-    return socket;
+    return null;
   }
 
   public void cancel() {
@@ -476,10 +469,10 @@ public void streamFailed(@Nullable IOException e) {
   }
 
   /**
-   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
-   * {@link #release} on the same connection.
+   * Use this allocation to hold {@code connection}. Each use of this must be paired with a call to
+   * {@link #transmitterReleaseConnection} on the same connection.
    */
-  public void acquire(RealConnection connection, boolean reportedAcquired) {
+  public void transmitterAcquireConnection(RealConnection connection, boolean reportedAcquired) {
     assert (Thread.holdsLock(connectionPool));
     if (this.connection != null) throw new IllegalStateException();
 
@@ -488,16 +481,34 @@ public void acquire(RealConnection connection, boolean reportedAcquired) {
     connection.transmitters.add(new TransmitterReference(transmitter, callStackTrace));
   }
 
-  /** Remove this allocation from the connection's list of allocations. */
-  private void release(RealConnection connection) {
+  /**
+   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
+   * caller should close.
+   */
+  private @Nullable Socket transmitterReleaseConnection() {
+    int index = -1;
     for (int i = 0, size = connection.transmitters.size(); i < size; i++) {
       Reference<Transmitter> reference = connection.transmitters.get(i);
       if (reference.get() == transmitter) {
-        connection.transmitters.remove(i);
-        return;
+        index = i;
+        break;
       }
     }
-    throw new IllegalStateException();
+
+    if (index == -1) throw new IllegalStateException();
+
+    RealConnection released = this.connection;
+    released.transmitters.remove(index);
+    this.connection = null;
+
+    if (released.transmitters.isEmpty()) {
+      released.idleAtNanos = System.nanoTime();
+      if (Internal.instance.connectionBecameIdle(connectionPool, released)) {
+        return released.socket();
+      }
+    }
+
+    return null;
   }
 
   /**
@@ -45,6 +45,7 @@
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
 import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.sameConnection;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
@@ -70,13 +71,12 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
     Transmitter transmitter = realChain.transmitter();
 
-    transmitter.newStreamAllocation(request);
-
     int followUpCount = 0;
     Response priorResponse = null;
     while (true) {
+      transmitter.prepareToConnect(request);
+
       if (transmitter.isCanceled()) {
-        transmitter.releaseStreamAllocation(true);
         throw new IOException(""Canceled"");
       }
 
@@ -102,7 +102,6 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
         // We're throwing an unchecked exception. Release any resources.
         if (releaseConnection) {
           transmitter.streamFailed(null);
-          transmitter.releaseStreamAllocation(true);
         }
       }
 
@@ -119,35 +118,28 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
       try {
         followUp = followUpRequest(response, transmitter.route());
       } catch (IOException e) {
-        transmitter.releaseStreamAllocation(true);
         throw e;
       }
 
       if (followUp == null) {
-        transmitter.releaseStreamAllocation(true);
         return response;
       }
 
       closeQuietly(response.body());
 
+      if (transmitter.hasCodec()) {
+        throw new IllegalStateException(""Closing the body of "" + response
+            + "" didn't close its backing stream. Bad interceptor?"");
+      }
+
       if (++followUpCount > MAX_FOLLOW_UPS) {
-        transmitter.releaseStreamAllocation(true);
         throw new ProtocolException(""Too many follow-up requests: "" + followUpCount);
       }
 
       if (followUp.body() instanceof UnrepeatableRequestBody) {
-        transmitter.releaseStreamAllocation(true);
         throw new HttpRetryException(""Cannot retry streamed HTTP body"", response.code());
       }
 
-      if (!sameConnection(response, followUp.url())) {
-        transmitter.releaseStreamAllocation(false);
-        transmitter.newStreamAllocation(followUp);
-      } else if (transmitter.hasCodec()) {
-        throw new IllegalStateException(""Closing the body of "" + response
-            + "" didn't close its backing stream. Bad interceptor?"");
-      }
-
       request = followUp;
       priorResponse = response;
     }
@@ -285,7 +277,7 @@ private Request followUpRequest(Response userResponse, Route route) throws IOExc
         // When redirecting across hosts, drop all authentication headers. This
         // is potentially annoying to the application layer since they have no
         // way to retain them.
-        if (!sameConnection(userResponse, url)) {
+        if (!sameConnection(userResponse.request().url(), url)) {
           requestBuilder.removeHeader(""Authorization"");
         }
 
@@ -350,15 +342,4 @@ private int retryAfter(Response userResponse, int defaultDelay) {
 
     return Integer.MAX_VALUE;
   }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  private boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
 }
",True,"The commit message refers to the necessity of changes by mentioning the need to 'reduce the role StreamAllocation plays' and 'working towards' this goal. Additionally, it mentions an issue link, which could provide more context about the necessity of the changes. The code diff also supports this by replacing instances of StreamAllocation with Transmitter, which suggests a refactoring to reduce its role.",True,"The commit message 'Don't call callEnd() twice when application interceptors proceed twice' clearly explains the necessity of the changes. It mentions that the changes are being made to reduce the role StreamAllocation plays, which is a clear indication that the change is intended to improve the overall functionality and efficiency of the code.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions the issue of 'callEnd()' being called twice when application interceptors proceed twice, which is a problem that could arise if the exceptions were not handled properly. This clearly describes the error scenario and the issue report.",True,"The commit message indicates that the changes were made to handle a situation where application interceptors proceed twice, which could lead to callEnd() being called twice. This is likely due to a problem in the software maintenance process, as the previous implementation was not correctly handling this scenario.",True,The commit message directly mentions the objective of the change by stating that it is working towards reducing the role StreamAllocation plays and fixing a bug where callEnd() was being called twice when application interceptors proceeded twice.,True,The commit message describes the change by summarizing the diffs. It mentions that the commit is aimed at reducing the role of StreamAllocation and that it fixes an issue where callEnd() was being called twice when application interceptors proceeded twice. This is a clear summary of the changes made in the code diff.,True,"The commit message explains that the changes are made to ensure that the callEnd() method is not called twice when application interceptors proceed twice. This is a technical principle that describes the correct handling of resources, in this case, network connections, to prevent leaks and ensure proper cleanup.",True,"The commit message expresses a change in the behavior of the application interceptors and the Transmitter class. It mentions that the application interceptors can now proceed multiple times, which was not the case before. This change is reflected in the code diff, where the application interceptors are now called twice for each request, and the Transmitter class is modified to handle this new behavior. The message also describes the functional perspective of the changes, explaining that the callEnd() method is no longer called twice when the application interceptors proceed twice.",False,"The commit message does not explicitly state the reason for the change, but it can be inferred from the code diff. The change is not just a simple removal or addition of a space, but rather a refactoring of the code. The methods 'newStreamAllocation' and 'acquire' are being replaced with 'prepareToConnect' and 'acquireConnection' respectively. This suggests that the code is being updated to better handle the connection and stream allocation process, which is a significant change. Therefore, a commit message explaining the reason for this refactoring would be beneficial."
https://github.com/square/okhttp/commit/1ab086360755fcb13356617fe6d738171889d810,"Add a test for interceptors throwing unchecked exceptions.  <enter> Our behavior here is not good. Right now it looks like we're leaking resources; nothing is releasing the socket in a 'finally' clause when interceptors crash. We're also not notifying the callback that the call has failed; that's left hanging. <enter> That said, we don't expect applications to recover from these exceptions. <enter>  Closes   <issue_link> ",https://api.github.com/repos/square/okhttp/commits/1ab086360755fcb13356617fe6d738171889d810,"@@ -23,6 +23,11 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -430,6 +435,73 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     callbackB.await(requestB.url()).assertBody(""b"");
   }
 
+  @Test public void applicationkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(client.interceptors());
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(client.networkInterceptors());
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
+   * with it.
+   *
+   * TODO(jwilson): test that resources are not leaked when this happens.
+   */
+  private void interceptorThrowsRuntimeExceptionSynchronous(
+      List<Interceptor> interceptors) throws Exception {
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException(""boom!"");
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl(""/""))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals(""boom!"", expected.getMessage());
+    }
+  }
+
+  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(client.interceptors());
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(client.networkInterceptors());
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
+   * exception goes to the uncaught exception handler.
+   *
+   * TODO(jwilson): test that resources are not leaked when this happens.
+   */
+  private void interceptorThrowsRuntimeExceptionAsynchronous(
+        List<Interceptor> interceptors) throws Exception {
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException(""boom!"");
+      }
+    });
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client.setDispatcher(new Dispatcher(executor));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl(""/""))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    assertEquals(""boom!"", executor.takeException().getMessage());
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -480,4 +552,29 @@ private Buffer gzip(String data) throws IOException {
     sink.close();
     return result;
   }
+
+  /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
+  private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
+    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
+
+    public ExceptionCatchingExecutor() {
+      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
+    }
+
+    @Override public void execute(final Runnable runnable) {
+      super.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            runnable.run();
+          } catch (Exception e) {
+            exceptions.add(e);
+          }
+        }
+      });
+    }
+
+    public Exception takeException() throws InterruptedException {
+      return exceptions.take();
+    }
+  }
 }
",True,"The commit message refers to the necessity of changes by mentioning that the current behavior is not good, as it looks like resources are leaking and callbacks are not notifying about the call failure when interceptors crash. This is then addressed in the code diff by adding tests for interceptors throwing unchecked exceptions and making changes to ensure resources are released and callbacks are notified appropriately.",True,The commit message explains the necessity of changes by mentioning that the current behavior is not good as it looks like resources are leaking and the callback is left hanging when interceptors crash. This provides a clear rationale for adding tests to handle these exceptions.,True,"The commit message directly elaborates the motivation of the code change by describing the error scenario. It mentions that the current behavior is not good as it looks like resources are being leaked and the callback is not notifying that the call has failed. The message also mentions that the exceptions are not expected to be recovered from, but it's important to handle them properly to avoid resource leaks.",True,"The commit message indicates the necessity of changes by describing the problem in the process of software maintenance. The problem is that when interceptors crash, resources are leaked and the callback is left hanging. This is not the expected behavior, and the changes are being made to fix these issues.",True,"The commit message directly mentions the issue it fixes, which is the leak of resources and the failure to notify the callback when interceptors crash. It also mentions the addition of tests to handle interceptors throwing unchecked exceptions, which is an improvement to the code.",True,"The commit message does a good job of summarizing the changes. It mentions adding tests for interceptors throwing unchecked exceptions, which is a clear reference to the added code. It also highlights the issues that arise from this situation, such as leaking resources and not notifying the callback that the call has failed. This is a good summary of the changes made in the diff, as it points out the key components of the change and contrasts the before and after scenarios.",True,The commit message explains that the changes are made to handle the scenario when interceptors throw unchecked exceptions. It mentions that the current behavior is not good as it leads to resource leaks and callbacks not being notified about the call failure. The technical principle underpinning the changes is to ensure that resources are properly released and callbacks are notified in case of exceptions.,True,"The commit message accurately describes the changes made to the code. It mentions adding tests for interceptors throwing unchecked exceptions, which is a new behavior introduced. The code diff shows the addition of new test methods and classes that simulate the scenario where an interceptor throws a RuntimeException. This is a functional change that improves the robustness of the application by handling unexpected exceptions and ensuring resources are not leaked.",False,The commit message does not lack an explanation. It clearly states the reason for the commit: to address the issue of resource leaks and unnotified callback failures when interceptors throw unchecked exceptions. The code diff supports this explanation by adding tests and additional code to handle these exceptions.
https://github.com/square/retrofit/commit/863030b551bc2e3447c5dde55d6bcc312218de6f,Add docs about null responses. ,https://api.github.com/repos/square/retrofit/commits/863030b551bc2e3447c5dde55d6bcc312218de6f,"@@ -74,7 +74,8 @@ public boolean isNetworkError() {
 
   /**
    * HTTP response body converted to the type declared by either the interface method return type or
-   * the generic type of the supplied {@link Callback} parameter.
+   * the generic type of the supplied {@link Callback} parameter. {@code null} if there is no
+   * response.
    */
   public Object getBody() {
     if (response == null) {
@@ -91,7 +92,9 @@ public Object getBody() {
     }
   }
 
-  /** HTTP response body converted to specified {@code type}. */
+  /**
+   * HTTP response body converted to specified {@code type}. {@code null} if there is no response.
+   */
   public Object getBodyAs(Type type) {
     if (response == null) {
       return null;
",True,"The commit message 'Add docs about null responses' refers to the necessity of changes by explaining that it is adding documentation about null responses in the code. This is an improvement in prior commits as it adds clarity to the codebase, specifically in the methods 'getBody()' and 'getBodyAs(Type type)', which now include documentation about what happens when there is no response.",True,"The commit message 'Add docs about null responses' does not explicitly explain why the changes were necessary. However, it is easy to infer from the code diff that the changes were made to document the possibility of null responses in the getBody() and getBodyAs() methods. This is a common practice in software development to improve code clarity and maintainability, especially when dealing with potential null values.",True,"The commit message 'Add docs about null responses' does describe the necessity of changes by elaborating the motivation of a code change. It mentions that the changes are being made to add documentation about null responses, which is likely in response to a scenario where the previous implementation did not handle null responses appropriately, leading to potential errors or unexpected behavior.",True,"The commit message 'Add docs about null responses' indicates that the developer is addressing a potential issue or requirement. Specifically, the code diff shows that the documentation has been updated to include information about null responses, which could be a result of changes in the API or a need to handle and document edge cases in the software development process.",True,"The commit message 'Add docs about null responses' does contain an expression that describes the objective of the change. Specifically, it mentions that the change is adding documentation to explain that the 'getBody' and 'getBodyAs' methods can now return null if there is no response, which is an improvement to the code as it provides more clarity about potential return values.",True,"The commit message 'Add docs about null responses' does describe a summary of what changes by being a summary of the diffs. It points out the key component of the change, which is the addition of documentation about null responses in the getBody() and getBodyAs() methods. The diff shows that the documentation has been updated to clarify that these methods can return null if there is no response, which is accurately reflected in the commit message.",True,"The commit message 'Add docs about null responses' does contain an expression that describes the technical principle underpinning the changes. The changes in the code diff indicate that the function now handles the case where there is no HTTP response, returning null in such situations. This is a common practice in programming to handle potential absence of data, and the commit message and code changes both clearly describe this principle.",True,"The commit message 'Add docs about null responses' does express a summary of the changes made in the code diff. The changes added to the documentation describe that the methods 'getBody()' and 'getBodyAs(Type type)' can now return null if there is no response. This introduces new behavior where these methods can return null, which was not previously documented or possible.",False,"The commit message does not lack an explanation. Although the change is small and simple, it is not immediately clear from the diff that the documentation now includes information about null responses. The commit message explicitly states that it adds documentation about null responses, which is a clear explanation of the change."
https://github.com/spring-projects/spring-boot/commit/296dc7132b8e444df0e6173740fa6bba5a5f1bd1,Allow JSON Testers to be `@Autowired`  <enter> Switch `@AutoConfigureJsonTesters` to use regular `@Autowired` injection for JSON testers. Prior to this commit JSON Tester fields were initialized directly which caused IDE issues and was also a little confusing. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/296dc7132b8e444df0e6173740fa6bba5a5f1bd1,"@@ -5011,12 +5011,13 @@ annotation.
 Spring Boot includes AssertJ based helpers that work with the JSONassert and JsonPath
 libraries to check that JSON is as expected. The `JacksonHelper`, `GsonHelper` and
 `BasicJsonTester` classes can be used for Jackson, Gson and Strings respectively. Any
-helper fields on the test class will be automatically initialized when using `@JsonTest`.
+helper fields on the test class can be `@Autowired` when using `@JsonTest`.
 
 [source,java,indent=0]
 ----
 	import org.junit.*;
 	import org.junit.runner.*;
+	import org.springframework.beans.factory.annotation.*;
 	import org.springframework.boot.test.autoconfigure.json.*;
 	import org.springframework.boot.test.context.*;
 	import org.springframework.boot.test.json.*;
@@ -5028,6 +5029,7 @@ helper fields on the test class will be automatically initialized when using `@J
 	@JsonTest
 	public class MyJsonTests {
 
+		@Autowired
 		private JacksonTester<VehicleDetails> json;
 
 		@Test
@@ -19,6 +19,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.autoconfigure.json.JsonTest;
 import org.springframework.boot.test.json.JacksonTester;
 import org.springframework.test.context.junit4.SpringRunner;
@@ -34,6 +35,7 @@
 @JsonTest
 public class VehicleDetailsJsonTests {
 
+	@Autowired
 	private JacksonTester<VehicleDetails> json;
 
 	@Test
@@ -18,42 +18,34 @@
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
-import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
+import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
+import org.springframework.boot.test.autoconfigure.properties.PropertyMapping;
 import org.springframework.boot.test.json.BasicJsonTester;
 import org.springframework.boot.test.json.GsonTester;
 import org.springframework.boot.test.json.JacksonTester;
-import org.springframework.context.ApplicationContext;
-import org.springframework.test.context.TestExecutionListeners;
-import org.springframework.test.context.TestExecutionListeners.MergeMode;
 
 /**
  * Annotation that can be applied to a test class to enable and configure
  * auto-configuration of JSON testers.
- * <p>
- * NOTE: {@code @AutoConfigureJsonTesters} works in conjunction with
- * {@link JsonTesterInitializationTestExecutionListener}. If you declare your own
- * {@link TestExecutionListeners @TestExecutionListeners} and don't
- * {@link MergeMode#MERGE_WITH_DEFAULTS merge with defaults} you must include
- * {@link JsonTesterInitializationTestExecutionListener} to use this annotation.
  *
  * @author Phillip Webb
- * @see JsonTesterInitializationTestExecutionListener
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
-@Inherited
+@ImportAutoConfiguration
+@PropertyMapping(""spring.test.jsontesters"")
 public @interface AutoConfigureJsonTesters {
 
 	/**
-	 * If {@link BasicJsonTester}, {@link JacksonTester} and {@link GsonTester} fields
-	 * should be initialized using marshallers from the {@link ApplicationContext}.
-	 * @return if JSON tester fields should be initialized
+	 * If {@link BasicJsonTester}, {@link JacksonTester} and {@link GsonTester} beans
+	 * should be registered. Defaults to {@code true}
+	 * @return if tester support is enabled
 	 */
-	boolean initFields() default true;
+	boolean enabled() default true;
 
 }
@@ -1,174 +0,0 @@
-/*
- * Copyright 2012-2016 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.test.autoconfigure.json;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.google.gson.Gson;
-
-import org.springframework.beans.BeansException;
-import org.springframework.beans.factory.ObjectFactory;
-import org.springframework.boot.test.json.BasicJsonTester;
-import org.springframework.boot.test.json.GsonTester;
-import org.springframework.boot.test.json.JacksonTester;
-import org.springframework.core.annotation.AnnotatedElementUtils;
-import org.springframework.test.context.TestContext;
-import org.springframework.test.context.TestExecutionListener;
-import org.springframework.test.context.support.AbstractTestExecutionListener;
-import org.springframework.util.ClassUtils;
-import org.springframework.util.ReflectionUtils;
-import org.springframework.util.ReflectionUtils.FieldCallback;
-
-/**
- * {@link TestExecutionListener} to initialize JSON tester fields.
- *
- * @author Phillip Webb
- * @since 1.4.0
- */
-public class JsonTesterInitializationTestExecutionListener
-		extends AbstractTestExecutionListener {
-
-	private static final String ASSERTJ_CLASS = ""org.assertj.core.api.Assert"";
-
-	private static final Map<String, Class<?>> INITIALIZERS;
-
-	static {
-		Map<String, Class<?>> initializers = new LinkedHashMap<String, Class<?>>();
-		initializers.put(""com.fasterxml.jackson.databind.ObjectMapper"",
-				JacksonInitializer.class);
-		initializers.put(""com.google.gson.Gson"", GsonInitializer.class);
-		INITIALIZERS = Collections.unmodifiableMap(initializers);
-	}
-
-	@Override
-	public void prepareTestInstance(TestContext testContext) throws Exception {
-		ClassLoader classLoader = getClass().getClassLoader();
-		if (ClassUtils.isPresent(ASSERTJ_CLASS, classLoader)
-				&& shouldInitializeFields(testContext)) {
-			initializeBasicJsonTesterFields(testContext);
-			initializeJsonMarshalTesterFields(classLoader, testContext);
-		}
-	}
-
-	private boolean shouldInitializeFields(TestContext testContext) {
-		AutoConfigureJsonTesters annotation = AnnotatedElementUtils.getMergedAnnotation(
-				testContext.getTestClass(), AutoConfigureJsonTesters.class);
-		return (annotation != null && annotation.initFields());
-	}
-
-	private void initializeBasicJsonTesterFields(final TestContext testContext) {
-		ReflectionUtils.doWithFields(testContext.getTestClass(), new FieldCallback() {
-
-			@Override
-			public void doWith(Field field)
-					throws IllegalArgumentException, IllegalAccessException {
-				if (BasicJsonTester.class.isAssignableFrom(field.getType())) {
-					setupField(field);
-				}
-			}
-
-			private void setupField(Field field) {
-				ReflectionUtils.makeAccessible(field);
-				Object existingInstance = ReflectionUtils.getField(field,
-						testContext.getTestInstance());
-				if (existingInstance == null) {
-					ReflectionUtils.setField(field, testContext.getTestInstance(),
-							new BasicJsonTester(testContext.getTestClass()));
-				}
-			}
-
-		});
-	}
-
-	private void initializeJsonMarshalTesterFields(ClassLoader classLoader,
-			TestContext testContext) {
-		for (Map.Entry<String, Class<?>> entry : INITIALIZERS.entrySet()) {
-			if (ClassUtils.isPresent(entry.getKey(), classLoader)) {
-				initializeJsonMarshalTesterFields(classLoader, testContext,
-						entry.getKey(), entry.getValue());
-			}
-		}
-	}
-
-	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
-	private void initializeJsonMarshalTesterFields(ClassLoader classLoader,
-			TestContext testContext, String marshallerClassName, Class<?> initializer) {
-		try {
-			Constructor<?> constructor = initializer.getDeclaredConstructor();
-			ReflectionUtils.makeAccessible(constructor);
-			initializeJsonMarshalTesterFields(testContext,
-					ClassUtils.resolveClassName(marshallerClassName, classLoader),
-					(Initializer) constructor.newInstance());
-		}
-		catch (Throwable ex) {
-			throw new IllegalStateException(ex);
-		}
-	}
-
-	private <T> void initializeJsonMarshalTesterFields(final TestContext testContext,
-			final Class<T> marshallerClass, Initializer<T> initializer) {
-		initializer.initialize(testContext, new ObjectFactory<T>() {
-
-			@Override
-			public T getObject() throws BeansException {
-				return testContext.getApplicationContext().getBean(marshallerClass);
-			}
-
-		});
-	}
-
-	/**
-	 * Strategy used to initialize JSON testers without cause class not found exceptions.
-	 * @param <M> the marshaller type
-	 */
-	interface Initializer<M> {
-
-		void initialize(TestContext testContext, ObjectFactory<M> marshaller);
-
-	}
-
-	/**
-	 * {@link Initializer} for {@link JacksonTester}.
-	 */
-	static class JacksonInitializer implements Initializer<ObjectMapper> {
-
-		@Override
-		public void initialize(TestContext testContext,
-				ObjectFactory<ObjectMapper> marshaller) {
-			JacksonTester.initFields(testContext.getTestInstance(), marshaller);
-		}
-
-	}
-
-	/**
-	 * {@link Initializer} for {@link GsonTester}.
-	 */
-	static class GsonInitializer implements Initializer<Gson> {
-
-		@Override
-		public void initialize(TestContext testContext, ObjectFactory<Gson> marshaller) {
-			GsonTester.initFields(testContext.getTestInstance(), marshaller);
-		}
-
-	}
-
-}
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2012-2016 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.test.autoconfigure.json;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+
+import org.springframework.beans.BeanUtils;
+import org.springframework.beans.BeansException;
+import org.springframework.beans.factory.FactoryBean;
+import org.springframework.beans.factory.config.BeanPostProcessor;
+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.test.json.AbstractJsonMarshalTester;
+import org.springframework.boot.test.json.BasicJsonTester;
+import org.springframework.boot.test.json.GsonTester;
+import org.springframework.boot.test.json.JacksonTester;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Scope;
+import org.springframework.core.ResolvableType;
+import org.springframework.test.util.ReflectionTestUtils;
+import org.springframework.util.ReflectionUtils;
+import org.springframework.util.ReflectionUtils.FieldCallback;
+
+/**
+ * Auto-configuration for Json testers.
+ *
+ * @author Phillip Webb
+ * @see AutoConfigureJsonTesters
+ * @since 1.4.0
+ */
+@Configuration
+@ConditionalOnClass(name = ""org.assertj.core.api.Assert"")
+@ConditionalOnProperty(""spring.test.jsontesters.enabled"")
+public class JsonTestersAutoConfiguration {
+
+	@Bean
+	public static JsonMarshalTestersBeanPostProcessor jsonMarshalTestersBeanPostProcessor() {
+		return new JsonMarshalTestersBeanPostProcessor();
+	}
+
+	@Bean
+	@Scope(""prototype"")
+	public FactoryBean<BasicJsonTester> BasicJsonTesterFactoryBean() {
+		return new JsonTesterFactoryBean<BasicJsonTester, Void>(BasicJsonTester.class,
+				null);
+	}
+
+	@Bean
+	@Scope(""prototype"")
+	@ConditionalOnClass(ObjectMapper.class)
+	@ConditionalOnBean(ObjectMapper.class)
+	public FactoryBean<JacksonTester<?>> jacksonTesterFactoryBean(ObjectMapper mapper) {
+		return new JsonTesterFactoryBean<JacksonTester<?>, ObjectMapper>(
+				JacksonTester.class, mapper);
+	}
+
+	@Bean
+	@Scope(""prototype"")
+	@ConditionalOnClass(ObjectMapper.class)
+	@ConditionalOnBean(Gson.class)
+	public FactoryBean<GsonTester<?>> gsonTesterFactoryBean(Gson gson) {
+		return new JsonTesterFactoryBean<GsonTester<?>, Gson>(GsonTester.class, gson);
+	}
+
+	/**
+	 * {@link FactoryBean} used to create JSON Tester instances.
+	 */
+	private class JsonTesterFactoryBean<T, M> implements FactoryBean<T> {
+
+		private final Class<?> objectType;
+
+		private final M marshaller;
+
+		JsonTesterFactoryBean(Class<?> objectType, M marshaller) {
+			this.objectType = objectType;
+			this.marshaller = marshaller;
+
+		}
+
+		@Override
+		public boolean isSingleton() {
+			return false;
+		}
+
+		@Override
+		@SuppressWarnings(""unchecked"")
+		public T getObject() throws Exception {
+			if (this.marshaller == null) {
+				Constructor<?> constructor = this.objectType.getDeclaredConstructor();
+				ReflectionUtils.makeAccessible(constructor);
+				return (T) BeanUtils.instantiateClass(constructor);
+			}
+			Constructor<?>[] constructors = this.objectType.getDeclaredConstructors();
+			for (Constructor<?> constructor : constructors) {
+				if (constructor.getParameterTypes().length == 1
+						&& constructor.getParameterTypes()[0]
+								.isInstance(this.marshaller)) {
+					ReflectionUtils.makeAccessible(constructor);
+					return (T) BeanUtils.instantiateClass(constructor, this.marshaller);
+				}
+			}
+			throw new IllegalStateException(
+					this.objectType + "" does not have a usable constructor"");
+		}
+
+		@Override
+		public Class<?> getObjectType() {
+			return this.objectType;
+		}
+
+	}
+
+	/**
+	 * {@link BeanPostProcessor} used to initialize JSON testers.
+	 */
+	private static class JsonMarshalTestersBeanPostProcessor
+			extends InstantiationAwareBeanPostProcessorAdapter {
+
+		@Override
+		public Object postProcessAfterInitialization(final Object bean, String beanName)
+				throws BeansException {
+
+			ReflectionUtils.doWithFields(bean.getClass(), new FieldCallback() {
+
+				@Override
+				public void doWith(Field field)
+						throws IllegalArgumentException, IllegalAccessException {
+					processFiled(bean, field);
+				}
+
+			});
+			return bean;
+		}
+
+		private void processFiled(Object bean, Field field) {
+			if (AbstractJsonMarshalTester.class.isAssignableFrom(field.getType())
+					|| BasicJsonTester.class.isAssignableFrom(field.getType())) {
+				ResolvableType type = ResolvableType.forField(field).getGeneric();
+				ReflectionUtils.makeAccessible(field);
+				Object tester = ReflectionUtils.getField(field, bean);
+				if (tester != null) {
+					ReflectionTestUtils.invokeMethod(tester, ""initialize"",
+							bean.getClass(), type);
+				}
+			}
+		}
+
+	}
+
+}
@@ -17,6 +17,10 @@ org.springframework.boot.test.autoconfigure.json.AutoConfigureJson=\
 org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
 org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration
 
+# AutoConfigureJsonTesters auto-configuration imports
+org.springframework.boot.test.autoconfigure.json.AutoConfigureJsonTesters=\
+org.springframework.boot.test.autoconfigure.json.JsonTestersAutoConfiguration
+
 # AutoConfigureMockMvc auto-configuration imports
 org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc=\
 org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration,\
@@ -69,6 +73,5 @@ org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCus
 # Test Execution Listeners
 org.springframework.test.context.TestExecutionListener=\
 org.springframework.boot.test.autoconfigure.AutoConfigureReportTestExecutionListener,\
-org.springframework.boot.test.autoconfigure.json.JsonTesterInitializationTestExecutionListener,\
 org.springframework.boot.test.autoconfigure.restdocs.RestDocsTestExecutionListener,\
 org.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerResetTestExecutionListener
@@ -19,6 +19,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.json.BasicJsonTester;
 import org.springframework.boot.test.json.GsonTester;
 import org.springframework.boot.test.json.JacksonTester;
@@ -35,12 +36,16 @@
 @JsonTest
 public class JsonTestIntegrationTests {
 
+	@Autowired
 	private BasicJsonTester basicJson;
 
+	@Autowired
 	private JacksonTester<ExampleBasicObject> jacksonBasicJson;
 
+	@Autowired
 	private JacksonTester<ExampleCustomObject> jacksonCustomJson;
 
+	@Autowired
 	private GsonTester<ExampleBasicObject> gsonJson;
 
 	@Test
@@ -19,6 +19,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.json.BasicJsonTester;
 import org.springframework.boot.test.json.GsonTester;
 import org.springframework.boot.test.json.JacksonTester;
@@ -33,13 +34,16 @@
  */
 @RunWith(SpringRunner.class)
 @JsonTest
-@AutoConfigureJsonTesters(initFields = false)
+@AutoConfigureJsonTesters(enabled = false)
 public class JsonTestWithAutoConfigureJsonTestersTests {
 
+	@Autowired(required = false)
 	private BasicJsonTester basicJson;
 
+	@Autowired(required = false)
 	private JacksonTester<ExampleBasicObject> jacksonTester;
 
+	@Autowired(required = false)
 	private GsonTester<ExampleBasicObject> gsonTester;
 
 	@Test
@@ -1,179 +0,0 @@
-/*
- * Copyright 2012-2016 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.test.autoconfigure.json;
-
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.google.gson.GsonBuilder;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.ExpectedException;
-
-import org.springframework.boot.test.json.BasicJsonTester;
-import org.springframework.boot.test.json.GsonTester;
-import org.springframework.boot.test.json.JacksonTester;
-import org.springframework.context.support.StaticApplicationContext;
-import org.springframework.test.context.TestContext;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
-/**
- * Tests for {@link JsonTesterInitializationTestExecutionListener}.
- *
- * @author Phillip Webb
- */
-public class JsonTesterInitializationTestExecutionListenerTests {
-
-	@Rule
-	public ExpectedException thrown = ExpectedException.none();
-
-	private JsonTesterInitializationTestExecutionListener listener = new JsonTesterInitializationTestExecutionListener();
-
-	@Test
-	public void prepareTestContextShouldInitializeBasicJsonTester() throws Exception {
-		WithBasicJsonTester instance = new WithBasicJsonTester();
-		this.listener.prepareTestInstance(mockTestContext(instance));
-		assertThat(instance.tester).isNotNull();
-	}
-
-	@Test
-	public void prepareTestContextShouldInitializeJacksonTester() throws Exception {
-		WithJacksonTester instance = new WithJacksonTester();
-		this.listener.prepareTestInstance(mockTestContext(instance, new ObjectMapper()));
-		assertThat(instance.tester).isNotNull();
-	}
-
-	@Test
-	public void prepareTestContextShouldInitializeGsonTester() throws Exception {
-		WithGsonTester instance = new WithGsonTester();
-		this.listener.prepareTestInstance(
-				mockTestContext(instance, new GsonBuilder().create()));
-		assertThat(instance.tester).isNotNull();
-	}
-
-	@Test
-	public void prepareTestContextWhenInitFieldsFalseShouldNotInitializeTesters()
-			throws Exception {
-		WithInitFieldsFalse instance = new WithInitFieldsFalse();
-		this.listener.prepareTestInstance(mockTestContext(instance, new ObjectMapper()));
-		assertThat(instance.basicTester).isNull();
-		assertThat(instance.jacksonTester).isNull();
-		assertThat(instance.gsonTester).isNull();
-	}
-
-	@Test
-	public void prepareTestContextWhenInitFieldsTrueShouldInitializeTesters()
-			throws Exception {
-		WithInitFieldsTrue instance = new WithInitFieldsTrue();
-		this.listener.prepareTestInstance(mockTestContext(instance));
-		assertThat(instance.tester).isNotNull();
-	}
-
-	@Test
-	public void prepareTestContextWhenMissingAnnotationShouldNotInitializeTesters()
-			throws Exception {
-		WithoutAnnotation instance = new WithoutAnnotation();
-		this.listener.prepareTestInstance(mockTestContext(instance));
-		assertThat(instance.basicTester).isNull();
-		assertThat(instance.jacksonTester).isNull();
-		assertThat(instance.gsonTester).isNull();
-	}
-
-	@Test
-	public void prepareTestContextWhenHasJacksonTesterButNoObjectMapperBeanShouldThrowException()
-			throws Exception {
-		WithJacksonTester instance = new WithJacksonTester();
-		this.thrown.expect(IllegalStateException.class);
-		this.thrown.expectMessage(""ObjectMapper"");
-		this.listener.prepareTestInstance(mockTestContext(instance));
-	}
-
-	@Test
-	public void prepareTestContextWhenHasJacksonTesterButNoGsonBeanShouldThrowException()
-			throws Exception {
-		WithGsonTester instance = new WithGsonTester();
-		this.thrown.expect(IllegalStateException.class);
-		this.thrown.expectMessage(""Gson"");
-		this.listener.prepareTestInstance(mockTestContext(instance));
-	}
-
-	private TestContext mockTestContext(Object testInstance) {
-		return mockTestContext(testInstance, null);
-	}
-
-	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
-	private TestContext mockTestContext(Object testInstance, Object bean) {
-		TestContext testContext = mock(TestContext.class);
-		StaticApplicationContext applicationContext = new StaticApplicationContext();
-		if (bean != null) {
-			applicationContext.getBeanFactory().registerSingleton(""bean"", bean);
-		}
-		given(testContext.getApplicationContext()).willReturn(applicationContext);
-		given(testContext.getTestClass()).willReturn((Class) testInstance.getClass());
-		given(testContext.getTestInstance()).willReturn(testInstance);
-		return testContext;
-	}
-
-	@AutoConfigureJsonTesters
-	static class WithBasicJsonTester {
-
-		private BasicJsonTester tester;
-
-	}
-
-	@AutoConfigureJsonTesters
-	static class WithJacksonTester {
-
-		private JacksonTester<Object> tester;
-	}
-
-	@AutoConfigureJsonTesters
-	static class WithGsonTester {
-
-		private GsonTester<Object> tester;
-	}
-
-	@AutoConfigureJsonTesters(initFields = false)
-	static class WithInitFieldsFalse {
-
-		private BasicJsonTester basicTester;
-
-		private JacksonTester<Object> jacksonTester;
-
-		private GsonTester<Object> gsonTester;
-
-	}
-
-	@AutoConfigureJsonTesters(initFields = true)
-	static class WithInitFieldsTrue {
-
-		private BasicJsonTester tester;
-
-	}
-
-	static class WithoutAnnotation {
-
-		private BasicJsonTester basicTester;
-
-		private JacksonTester<Object> jacksonTester;
-
-		private GsonTester<Object> gsonTester;
-
-	}
-
-}
@@ -70,9 +70,15 @@
  */
 public abstract class AbstractJsonMarshalTester<T> {
 
-	private final Class<?> resourceLoadClass;
+	private Class<?> resourceLoadClass;
 
-	private final ResolvableType type;
+	private ResolvableType type;
+
+	/**
+	 * Create a new uninitialized {@link AbstractJsonMarshalTester} instance.
+	 */
+	protected AbstractJsonMarshalTester() {
+	}
 
 	/**
 	 * Create a new {@link AbstractJsonMarshalTester} instance.
@@ -83,8 +89,20 @@ public abstract class AbstractJsonMarshalTester<T> {
 	public AbstractJsonMarshalTester(Class<?> resourceLoadClass, ResolvableType type) {
 		Assert.notNull(resourceLoadClass, ""ResourceLoadClass must not be null"");
 		Assert.notNull(type, ""Type must not be null"");
-		this.resourceLoadClass = resourceLoadClass;
-		this.type = type;
+		initialize(resourceLoadClass, type);
+	}
+
+	/**
+	 * Initialize the marshal tester for use.
+	 * @param resourceLoadClass the source class used when loading relative classpath
+	 * resources
+	 * @param type the type under test
+	 */
+	protected final void initialize(Class<?> resourceLoadClass, ResolvableType type) {
+		if (this.resourceLoadClass == null && this.type == null) {
+			this.resourceLoadClass = resourceLoadClass;
+			this.type = type;
+		}
 	}
 
 	/**
@@ -102,6 +120,7 @@ protected final ResolvableType getType() {
 	 * @throws IOException on write error
 	 */
 	public JsonContent<T> write(T value) throws IOException {
+		verify();
 		Assert.notNull(value, ""Value must not be null"");
 		String json = writeObject(value, this.type);
 		return new JsonContent<T>(this.resourceLoadClass, this.type, json);
@@ -114,6 +133,7 @@ public JsonContent<T> write(T value) throws IOException {
 	 * @throws IOException on parse error
 	 */
 	public T parseObject(byte[] jsonBytes) throws IOException {
+		verify();
 		return parse(jsonBytes).getObject();
 	}
 
@@ -124,6 +144,7 @@ public T parseObject(byte[] jsonBytes) throws IOException {
 	 * @throws IOException on parse error
 	 */
 	public ObjectContent<T> parse(byte[] jsonBytes) throws IOException {
+		verify();
 		Assert.notNull(jsonBytes, ""JsonBytes must not be null"");
 		return read(new ByteArrayResource(jsonBytes));
 	}
@@ -135,6 +156,7 @@ public ObjectContent<T> parse(byte[] jsonBytes) throws IOException {
 	 * @throws IOException on parse error
 	 */
 	public T parseObject(String jsonString) throws IOException {
+		verify();
 		return parse(jsonString).getObject();
 	}
 
@@ -145,6 +167,7 @@ public T parseObject(String jsonString) throws IOException {
 	 * @throws IOException on parse error
 	 */
 	public ObjectContent<T> parse(String jsonString) throws IOException {
+		verify();
 		Assert.notNull(jsonString, ""JsonString must not be null"");
 		return read(new StringReader(jsonString));
 	}
@@ -157,6 +180,7 @@ public ObjectContent<T> parse(String jsonString) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(String resourcePath) throws IOException {
+		verify();
 		return read(resourcePath).getObject();
 	}
 
@@ -168,6 +192,7 @@ public T readObject(String resourcePath) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(String resourcePath) throws IOException {
+		verify();
 		Assert.notNull(resourcePath, ""ResourcePath must not be null"");
 		return read(new ClassPathResource(resourcePath, this.resourceLoadClass));
 	}
@@ -179,6 +204,7 @@ public ObjectContent<T> read(String resourcePath) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(File file) throws IOException {
+		verify();
 		return read(file).getObject();
 	}
 
@@ -189,6 +215,7 @@ public T readObject(File file) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(File file) throws IOException {
+		verify();
 		Assert.notNull(file, ""File must not be null"");
 		return read(new FileSystemResource(file));
 	}
@@ -200,6 +227,7 @@ public ObjectContent<T> read(File file) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(InputStream inputStream) throws IOException {
+		verify();
 		return read(inputStream).getObject();
 	}
 
@@ -210,6 +238,7 @@ public T readObject(InputStream inputStream) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(InputStream inputStream) throws IOException {
+		verify();
 		Assert.notNull(inputStream, ""InputStream must not be null"");
 		return read(new InputStreamResource(inputStream));
 	}
@@ -221,6 +250,7 @@ public ObjectContent<T> read(InputStream inputStream) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(Resource resource) throws IOException {
+		verify();
 		return read(resource).getObject();
 	}
 
@@ -231,6 +261,7 @@ public T readObject(Resource resource) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(Resource resource) throws IOException {
+		verify();
 		Assert.notNull(resource, ""Resource must not be null"");
 		InputStream inputStream = resource.getInputStream();
 		T object = readObject(inputStream, this.type);
@@ -245,6 +276,7 @@ public ObjectContent<T> read(Resource resource) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public T readObject(Reader reader) throws IOException {
+		verify();
 		return read(reader).getObject();
 	}
 
@@ -255,6 +287,7 @@ public T readObject(Reader reader) throws IOException {
 	 * @throws IOException on read error
 	 */
 	public ObjectContent<T> read(Reader reader) throws IOException {
+		verify();
 		Assert.notNull(reader, ""Reader must not be null"");
 		T object = readObject(reader, this.type);
 		closeQuietly(reader);
@@ -269,6 +302,12 @@ private void closeQuietly(Closeable closeable) {
 		}
 	}
 
+	private void verify() {
+		Assert.state(this.resourceLoadClass != null,
+				""Unitialized JsonMarshalTester (ResourceLoadClass is null)"");
+		Assert.state(this.type != null, ""Unitialized JsonMarshalTester (Type is null)"");
+	}
+
 	/**
 	 * Write the specified object to a JSON string.
 	 * @param value the source value (never {@code null})
@@ -19,6 +19,7 @@
 import java.io.File;
 import java.io.InputStream;
 
+import org.springframework.core.ResolvableType;
 import org.springframework.core.io.Resource;
 import org.springframework.util.Assert;
 
@@ -45,7 +46,13 @@
  */
 public class BasicJsonTester {
 
-	private final JsonLoader loader;
+	private JsonLoader loader;
+
+	/**
+	 * Create a new uninialized {@link BasicJsonTester} instance.
+	 */
+	protected BasicJsonTester() {
+	}
 
 	/**
 	 * Create a new {@link BasicJsonTester} instance.
@@ -56,6 +63,18 @@ public BasicJsonTester(Class<?> resourceLoadClass) {
 		this.loader = new JsonLoader(resourceLoadClass);
 	}
 
+	/**
+	 * Initialize the marshal tester for use.
+	 * @param resourceLoadClass the source class used when loading relative classpath
+	 * resources
+	 * @param type the type under test
+	 */
+	protected final void initialize(Class<?> resourceLoadClass, ResolvableType type) {
+		if (this.loader == null) {
+			this.loader = new JsonLoader(resourceLoadClass);
+		}
+	}
+
 	/**
 	 * Create JSON content from the specified String source. The source can contain the
 	 * JSON itself or, if it ends with {@code .json}, the name of a resource to be loaded
@@ -64,6 +83,7 @@ public BasicJsonTester(Class<?> resourceLoadClass) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(CharSequence source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
@@ -74,6 +94,7 @@ public JsonContent<Object> from(CharSequence source) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(String path, Class<?> resourceLoadClass) {
+		verify();
 		return getJsonContent(this.loader.getJson(path, resourceLoadClass));
 	}
 
@@ -83,6 +104,7 @@ public JsonContent<Object> from(String path, Class<?> resourceLoadClass) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(byte[] source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
@@ -92,6 +114,7 @@ public JsonContent<Object> from(byte[] source) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(File source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
@@ -101,6 +124,7 @@ public JsonContent<Object> from(File source) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(InputStream source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
@@ -110,9 +134,14 @@ public JsonContent<Object> from(InputStream source) {
 	 * @return the JSON content
 	 */
 	public JsonContent<Object> from(Resource source) {
+		verify();
 		return getJsonContent(this.loader.getJson(source));
 	}
 
+	private void verify() {
+		Assert.state(this.loader != null, ""Unitialized BasicJsonTester"");
+	}
+
 	private JsonContent<Object> getJsonContent(String json) {
 		return new JsonContent<Object>(this.loader.getResourceLoadClass(), null, json);
 	}
@@ -57,6 +57,15 @@ public class GsonTester<T> extends AbstractJsonMarshalTester<T> {
 
 	private final Gson gson;
 
+	/**
+	 * Create a new uninitialized {@link GsonTester} instance.
+	 * @param gson the Gson instance
+	 */
+	protected GsonTester(Gson gson) {
+		Assert.notNull(gson, ""Gson must not be null"");
+		this.gson = gson;
+	}
+
 	/**
 	 * Create a new {@link GsonTester} instance.
 	 * @param resourceLoadClass the source class used to load resources
@@ -59,6 +59,15 @@ public class JacksonTester<T> extends AbstractJsonMarshalTester<T> {
 
 	private final ObjectMapper objectMapper;
 
+	/**
+	 * Create a new {@link JacksonTester} instance.
+	 * @param objectMapper the Jackson object mapper
+	 */
+	protected JacksonTester(ObjectMapper objectMapper) {
+		Assert.notNull(objectMapper, ""ObjectMapper must not be null"");
+		this.objectMapper = objectMapper;
+	}
+
 	/**
 	 * Create a new {@link JacksonTester} instance.
 	 * @param resourceLoadClass the source class used to load resources
",True,"The commit message refers to the change in the way JSON Testers are initialized. Prior to this commit, JSON Tester fields were initialized directly, which caused IDE issues and was a little confusing. The commit message mentions that now JSON Tester fields can be '@Autowired' when using '@JsonTest', which is a clear expression of the necessity of the change by describing the improvement it brings.",True,"The commit message 'Allow JSON Testers to be `@Autowired`' clearly describes the necessity of the changes. It explains that the change is made to enable the use of `@Autowired` for JSON testers, which was not possible before due to direct field initialization. This change addresses an issue where IDEs had problems and the initialization was also a bit confusing. By allowing `@Autowired`, the code becomes more Spring-idiomatic and easier to understand.",True,"The commit message explains that the change is necessary to allow JSON Testers to be `@Autowired`, which was previously causing IDE issues and was a little confusing. This directly elaborates the motivation of the code change by describing the problem that was being faced and the solution that was implemented.",True,The commit message 'Allow JSON Testers to be `@Autowired`' indicates that the developer has changed the way JSON testers are initialized to use regular `@Autowired` injection. This change was likely made to address the issue of IDE issues and confusion that was mentioned in the commit message. This suggests that the change was made to improve the development experience and make the code easier to use and understand.,True,The commit message directly mentions the change that allows JSON Testers to be '@Autowired' when using '@JsonTest'. This indicates that the change is improving the code by making it more convenient and flexible to use JSON Testers in tests.,True,"The commit message 'Allow JSON Testers to be `@Autowired`' accurately describes the change made in the code diff. The change involves modifying the JSON tester fields to be `@Autowired` when using `@JsonTest`, which is clearly stated in the message.",True,"The commit message explains that JSON Testers can now be autowired, which is a change in the technical principle underpinning the code. This change allows for more flexibility and ease of use in testing JSON data.",True,"The commit message 'Allow JSON Testers to be `@Autowired`' accurately describes the functional change made in the code diff. The change allows JSON Tester fields to be initialized using `@Autowired` when using `@JsonTest`, which was not possible before. This makes it easier to use JSON Testers in tests and improves the overall functionality of the testing framework.",False,"The commit message does not explicitly state the reason for the change, but it can be inferred from the code diff. The change is to allow JSON Testers to be autowired, which is a more convenient way to use them in tests. This change was made to address issues with IDEs and confusion caused by directly initializing JSON Tester fields. However, the commit message could have been more explicit about these issues and the benefits of the change."
https://github.com/spring-projects/spring-boot/commit/12724bf33211d68899d710fda376bd5636731e4c,"Fix ordering of keys in PropertySourcesPropertyValues  <enter> Since  @ConfigurationProperties  binding uses a single instance of PropertySourcesPropertyValues per bean, there doesn't seem to be any issue with using a normal LinkedHashMap. Then the order passed in as PropertySources will be preserved. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/12724bf33211d68899d710fda376bd5636731e4c,"@@ -19,8 +19,8 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 
 import org.springframework.beans.MutablePropertyValues;
 import org.springframework.beans.PropertyValue;
@@ -42,7 +42,7 @@
  */
 public class PropertySourcesPropertyValues implements PropertyValues {
 
-	private final Map<String, PropertyValue> propertyValues = new ConcurrentHashMap<String, PropertyValue>();
+	private final Map<String, PropertyValue> propertyValues = new LinkedHashMap<String, PropertyValue>();
 
 	private final PropertySources propertySources;
 
@@ -16,11 +16,14 @@
 
 package org.springframework.boot.bind;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 
 import org.junit.Before;
 import org.junit.Test;
+import org.springframework.beans.PropertyValue;
 import org.springframework.core.env.CompositePropertySource;
 import org.springframework.core.env.MapPropertySource;
 import org.springframework.core.env.MutablePropertySources;
@@ -61,6 +64,26 @@ public void testSize() {
 		assertEquals(1, propertyValues.getPropertyValues().length);
 	}
 
+	@Test
+	public void testOrderPreserved() {
+		LinkedHashMap<String, Object> map = new LinkedHashMap<String, Object>();
+		map.put(""one"", 1);
+		map.put(""two"", 2);
+		map.put(""three"", 3);
+		map.put(""four"", 4);
+		map.put(""five"", 5);
+		this.propertySources.addFirst(new MapPropertySource(""ordered"", map));
+		PropertySourcesPropertyValues propertyValues = new PropertySourcesPropertyValues(
+				this.propertySources);
+		PropertyValue[] values = propertyValues.getPropertyValues();
+		assertEquals(6, values.length);
+		Collection<String> names = new ArrayList<String>();
+		for (PropertyValue value : values) {
+			names.add(value.getName());
+		}
+		assertEquals(""[one, two, three, four, five, name]"", names.toString());
+	}
+
 	@Test
 	public void testNonEnumeratedValue() {
 		PropertySourcesPropertyValues propertyValues = new PropertySourcesPropertyValues(
",True,"The commit message explains the necessity of changes by referencing a convention in the Spring framework. It mentions that '@ConfigurationProperties' binding uses a single instance of PropertySourcesPropertyValues per bean, and there doesn't seem to be any issue with using a normal LinkedHashMap. This is because the order passed in as PropertySources will be preserved. This is a clear reference to a standard or convention in the framework, explaining why the commit changes the implementation from ConcurrentHashMap to LinkedHashMap.",True,"The commit message explains the necessity of the changes by stating that '@ConfigurationProperties' binding uses a single instance of PropertySourcesPropertyValues per bean, and that there doesn't seem to be any issue with using a normal LinkedHashMap instead of ConcurrentHashMap. This is because the order passed in as PropertySources will be preserved. The code diff also supports this explanation by showing the change from ConcurrentHashMap to LinkedHashMap. Additionally, the commit message mentions that it fixes an issue, which further supports the necessity of the changes.",True,"The commit message directly elaborates the motivation of the code change by explaining the issue with the previous implementation, which was that the order of keys in PropertySourcesPropertyValues was not being preserved. This was causing problems when @ConfigurationProperties binding was used, as it uses a single instance of PropertySourcesPropertyValues per bean. The commit message also mentions that the issue was fixed by changing the underlying data structure from ConcurrentHashMap to LinkedHashMap, which preserves the order of elements.",True,"The commit message mentions that the change is necessary because '@ConfigurationProperties' binding uses a single instance of PropertySourcesPropertyValues per bean, and there doesn't seem to be any issue with using a normal LinkedHashMap to preserve the order passed in as PropertySources. This indicates that the change is made to address a problem in the software maintenance process, specifically outdated code that is no longer suitable for the current requirements.",True,"The commit message directly mentions the issue it fixes, which is the ordering of keys in PropertySourcesPropertyValues. It explains that the change is made to preserve the order passed in as PropertySources, which was not possible with the previous ConcurrentHashMap implementation. The message also includes a reference to the issue link, further clarifying the context of the change.",True,"The commit message 'Fix ordering of keys in PropertySourcesPropertyValues' accurately summarizes the change made in the code diff. It points out the key component of the change, which is the replacement of ConcurrentHashMap with LinkedHashMap to preserve the order of properties passed in as PropertySources.",True,"The commit message explains that the change from ConcurrentHashMap to LinkedHashMap is made to preserve the order of keys in PropertySourcesPropertyValues. This is because @ConfigurationProperties binding uses a single instance of PropertySourcesPropertyValues per bean, and the order passed in as PropertySources needs to be preserved. This is a clear expression of the technical principle underpinning the changes, which is the importance of maintaining the order of elements in a data structure.",True,"The commit message 'Fix ordering of keys in PropertySourcesPropertyValues' accurately describes the code changes. It explains that the previous implementation used a ConcurrentHashMap, which does not preserve the order of elements. The commit changes this to a LinkedHashMap, which does preserve the order of elements. The commit message also mentions that this change will preserve the order passed in as PropertySources, which is a new behavior introduced by the change.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Since @ConfigurationProperties binding uses a single instance of PropertySourcesPropertyValues per bean, there doesn't seem to be any issue with using a normal LinkedHashMap. Then the order passed in as PropertySources will be preserved.' This explanation is necessary because the change from ConcurrentHashMap to LinkedHashMap might not be immediately obvious and could potentially cause issues with the preservation of order."
https://github.com/spring-projects/spring-boot/commit/1de2316a0b4c2d5896c34b954208a4c550466f22,"Refine validator and MVC validator configuration  <enter> This commit ensures that a primary JSR 303 and Spring Validator will be exposed if the auto-configuration kicks in. As `LocalValidatorFactoryBean` exposes 3 contracts (JSR-303 `Validator` and `ValidatorFactory` as well as the `Spring` validator one), this makes sure that those types can be injected by type. <enter> `LocalValidatorFactoryBean` exposes 3 contracts and we're only checking for the absence of a `javax.validation.Validator` to auto-configure a `LocalValidatorFactoryBean`. If no standard JSR validator exists but a Spring's `Validator` exists and is primary, we shouldn't flag the auto-configured one as `@Primary`. Previous iterations on this feature have made sure that we'll auto-configure at most one `javax.validation.Validator` so not flagging it `@Primary` is no problem. <enter> This commit also restores and adds tests that validates `ValidationAutoConfiguration` will configure a JSR validator even if a Spring Validator is present. <enter> This effectively  fixes   <issue_link>  in a different way. <enter>  Closes   <issue_link>   Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/1de2316a0b4c2d5896c34b954208a4c550466f22,"@@ -0,0 +1,88 @@
+/*
+ * Copyright 2012-2017 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.validation;
+
+import org.springframework.beans.BeansException;
+import org.springframework.beans.factory.BeanFactory;
+import org.springframework.beans.factory.BeanFactoryAware;
+import org.springframework.beans.factory.BeanFactoryUtils;
+import org.springframework.beans.factory.config.BeanDefinition;
+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
+import org.springframework.beans.factory.support.BeanDefinitionRegistry;
+import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
+import org.springframework.core.type.AnnotationMetadata;
+import org.springframework.validation.Validator;
+import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
+
+/**
+ * Enable the {@code Primary} flag on the auto-configured validator if necessary.
+ * <p>
+ * As {@link LocalValidatorFactoryBean} exposes 3 validator related contracts and we're
+ * only checking for the absence {@link javax.validation.Validator}, we should flag the
+ * auto-configured validator as primary only if no Spring's {@link Validator} is flagged
+ * as primary.
+ *
+ * @author Stephane Nicoll
+ */
+class PrimaryDefaultValidatorPostProcessor
+		implements ImportBeanDefinitionRegistrar, BeanFactoryAware {
+
+	/**
+	 * The bean name of the auto-configured Validator.
+	 */
+	private static final String VALIDATOR_BEAN_NAME = ""defaultValidator"";
+
+	private ConfigurableListableBeanFactory beanFactory;
+
+	@Override
+	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
+		if (beanFactory instanceof ConfigurableListableBeanFactory) {
+			this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
+		}
+	}
+
+	@Override
+	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
+			BeanDefinitionRegistry registry) {
+		if (this.beanFactory == null) {
+			return;
+		}
+		if (!registry.containsBeanDefinition(VALIDATOR_BEAN_NAME)) {
+			return;
+		}
+		BeanDefinition def = registry.getBeanDefinition(VALIDATOR_BEAN_NAME);
+		if (def != null
+				&& this.beanFactory.isTypeMatch(VALIDATOR_BEAN_NAME, LocalValidatorFactoryBean.class)
+				&& def.getRole() == BeanDefinition.ROLE_INFRASTRUCTURE) {
+			def.setPrimary(!hasPrimarySpringValidator(registry));
+		}
+	}
+
+	private boolean hasPrimarySpringValidator(BeanDefinitionRegistry registry) {
+		String[] validatorBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
+				this.beanFactory, Validator.class, false, false);
+		for (String validatorBean : validatorBeans) {
+			BeanDefinition def = registry.getBeanDefinition(validatorBean);
+			if (def != null && def.isPrimary()) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+}
+
@@ -28,6 +28,7 @@
 import org.springframework.boot.validation.MessageInterpolatorFactory;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Import;
 import org.springframework.context.annotation.Role;
 import org.springframework.core.env.Environment;
 import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
@@ -43,12 +44,13 @@
 @Configuration
 @ConditionalOnClass(ExecutableValidator.class)
 @ConditionalOnResource(resources = ""classpath:META-INF/services/javax.validation.spi.ValidationProvider"")
+@Import(PrimaryDefaultValidatorPostProcessor.class)
 public class ValidationAutoConfiguration {
 
 	@Bean
 	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
-	@ConditionalOnMissingBean
-	public static Validator jsr303Validator() {
+	@ConditionalOnMissingBean(Validator.class)
+	public static LocalValidatorFactoryBean defaultValidator() {
 		LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean();
 		MessageInterpolatorFactory interpolatorFactory = new MessageInterpolatorFactory();
 		factoryBean.setMessageInterpolator(interpolatorFactory.getObject());
@@ -31,15 +31,20 @@
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Primary;
 import org.springframework.validation.annotation.Validated;
+import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
 import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;
+import org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
 
 /**
  * Tests for {@link ValidationAutoConfiguration}.
  *
  * @author Stephane Nicoll
+ * @author Phillip Webb
  */
 public class ValidationAutoConfigurationTests {
 
@@ -55,6 +60,95 @@ public void close() {
 		}
 	}
 
+	@Test
+	public void validationAutoConfigurationShouldConfigureDefaultValidator() {
+		load(Config.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(springValidatorNames).containsExactly(""defaultValidator"");
+		Validator jsrValidator = this.context.getBean(Validator.class);
+		org.springframework.validation.Validator springValidator = this.context
+				.getBean(org.springframework.validation.Validator.class);
+		assertThat(jsrValidator).isInstanceOf(LocalValidatorFactoryBean.class);
+		assertThat(jsrValidator).isEqualTo(springValidator);
+		assertThat(isPrimaryBean(""defaultValidator"")).isTrue();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesValidatorShouldBackOff() {
+		load(UserDefinedValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""customValidator"");
+		assertThat(springValidatorNames).containsExactly(""customValidator"");
+		org.springframework.validation.Validator springValidator = this.context
+				.getBean(org.springframework.validation.Validator.class);
+		Validator jsrValidator = this.context.getBean(Validator.class);
+		assertThat(jsrValidator).isInstanceOf(OptionalValidatorFactoryBean.class);
+		assertThat(jsrValidator).isEqualTo(springValidator);
+		assertThat(isPrimaryBean(""customValidator"")).isFalse();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesDefaultValidatorShouldNotEnablePrimary() {
+		load(UserDefinedDefaultValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(springValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(isPrimaryBean(""defaultValidator"")).isFalse();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesJsrValidatorShouldBackOff() {
+		load(UserDefinedJsrValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""customValidator"");
+		assertThat(springValidatorNames).isEmpty();
+		assertThat(isPrimaryBean(""customValidator"")).isFalse();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesSpringValidatorShouldCreateJsrValidator() {
+		load(UserDefinedSpringValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(springValidatorNames).containsExactly(
+				""customValidator"", ""anotherCustomValidator"", ""defaultValidator"");
+		Validator jsrValidator = this.context.getBean(Validator.class);
+		org.springframework.validation.Validator springValidator = this.context
+				.getBean(org.springframework.validation.Validator.class);
+		assertThat(jsrValidator).isInstanceOf(LocalValidatorFactoryBean.class);
+		assertThat(jsrValidator).isEqualTo(springValidator);
+		assertThat(isPrimaryBean(""defaultValidator"")).isTrue();
+	}
+
+	@Test
+	public void validationAutoConfigurationWhenUserProvidesPrimarySpringValidatorShouldRemovePrimaryFlag() {
+		load(UserDefinedPrimarySpringValidatorConfig.class);
+		String[] jsrValidatorNames = this.context.getBeanNamesForType(Validator.class);
+		String[] springValidatorNames = this.context
+				.getBeanNamesForType(org.springframework.validation.Validator.class);
+		assertThat(jsrValidatorNames).containsExactly(""defaultValidator"");
+		assertThat(springValidatorNames).containsExactly(
+				""customValidator"", ""anotherCustomValidator"", ""defaultValidator"");
+		Validator jsrValidator = this.context.getBean(Validator.class);
+		org.springframework.validation.Validator springValidator = this.context
+				.getBean(org.springframework.validation.Validator.class);
+		assertThat(jsrValidator).isInstanceOf(LocalValidatorFactoryBean.class);
+		assertThat(springValidator).isEqualTo(
+				this.context.getBean(""anotherCustomValidator""));
+		assertThat(isPrimaryBean(""defaultValidator"")).isFalse();
+	}
+
 	@Test
 	public void validationIsEnabled() {
 		load(SampleService.class);
@@ -104,7 +198,11 @@ public void userDefinedMethodValidationPostProcessorTakesPrecedence() {
 						.getPropertyValue(""validator""));
 	}
 
-	public void load(Class<?> config, String... environment) {
+	private boolean isPrimaryBean(String beanName) {
+		return this.context.getBeanDefinition(beanName).isPrimary();
+	}
+
+	private void load(Class<?> config, String... environment) {
 		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
 		EnvironmentTestUtils.addEnvironment(ctx, environment);
 		if (config != null) {
@@ -115,6 +213,72 @@ public void load(Class<?> config, String... environment) {
 		this.context = ctx;
 	}
 
+	@Configuration
+	static class Config {
+
+	}
+
+	@Configuration
+	static class UserDefinedValidatorConfig {
+
+		@Bean
+		public OptionalValidatorFactoryBean customValidator() {
+			return new OptionalValidatorFactoryBean();
+		}
+
+	}
+
+	@Configuration
+	static class UserDefinedDefaultValidatorConfig {
+
+		@Bean
+		public OptionalValidatorFactoryBean defaultValidator() {
+			return new OptionalValidatorFactoryBean();
+		}
+
+	}
+
+	@Configuration
+	static class UserDefinedJsrValidatorConfig {
+
+		@Bean
+		public Validator customValidator() {
+			return mock(Validator.class);
+		}
+
+	}
+
+	@Configuration
+	static class UserDefinedSpringValidatorConfig {
+
+		@Bean
+		public org.springframework.validation.Validator customValidator() {
+			return mock(org.springframework.validation.Validator.class);
+		}
+
+		@Bean
+		public org.springframework.validation.Validator anotherCustomValidator() {
+			return mock(org.springframework.validation.Validator.class);
+		}
+
+	}
+
+	@Configuration
+	static class UserDefinedPrimarySpringValidatorConfig {
+
+		@Bean
+		public org.springframework.validation.Validator customValidator() {
+			return mock(org.springframework.validation.Validator.class);
+		}
+
+		@Bean
+		@Primary
+		public org.springframework.validation.Validator anotherCustomValidator() {
+			return mock(org.springframework.validation.Validator.class);
+		}
+
+	}
+
 	@Validated
 	static class SampleService {
 
@@ -39,6 +39,7 @@
 import org.springframework.beans.DirectFieldAccessor;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
 import org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration;
+import org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration;
 import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter;
 import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration.WelcomePageHandlerMapping;
 import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
@@ -59,6 +60,7 @@
 import org.springframework.test.util.ReflectionTestUtils;
 import org.springframework.test.web.servlet.MockMvc;
 import org.springframework.test.web.servlet.setup.MockMvcBuilders;
+import org.springframework.util.ObjectUtils;
 import org.springframework.util.ReflectionUtils;
 import org.springframework.util.StringUtils;
 import org.springframework.validation.Validator;
@@ -655,77 +657,126 @@ public boolean matches(Object value) {
 	}
 
 	@Test
-	public void validationNoJsr303ValidatorExposedByDefault() {
-		load();
+	public void validatorWhenNoValidatorShouldUseDefault() {
+		load(null, new Class<?>[] { ValidationAutoConfiguration.class });
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).isEmpty();
 		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
 				.isEmpty();
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(1);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(springValidatorBeans).containsExactly(""mvcValidator"");
 	}
 
 	@Test
-	public void validationCustomConfigurerTakesPrecedence() {
-		load(MvcValidator.class);
+	public void validatorWhenNoCustomizationShouldUseAutoConfigured() {
+		load();
+		String[] jsrValidatorBeans = this.context
+				.getBeanNamesForType(javax.validation.Validator.class);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(jsrValidatorBeans).containsExactly(""defaultValidator"");
+		assertThat(springValidatorBeans).containsExactly(""defaultValidator"", ""mvcValidator"");
+		Validator validator = this.context.getBean(""mvcValidator"", Validator.class);
+		assertThat(validator).isInstanceOf(WebMvcValidator.class);
+		Object defaultValidator = this.context.getBean(""defaultValidator"");
+		assertThat(((WebMvcValidator) validator).getTarget()).isSameAs(defaultValidator);
+		// Primary Spring validator is the one use by MVC behind the scenes
+		assertThat(this.context.getBean(Validator.class)).isEqualTo(defaultValidator);
+	}
+
+	@Test
+	public void validatorWithConfigurerShouldUseSpringValidator() {
+		load(MvcValidator.class, new Class<?>[] { ValidationAutoConfiguration.class });
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).isEmpty();
 		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
 				.isEmpty();
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(1);
-		Validator validator = this.context.getBean(Validator.class);
-		assertThat(validator)
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(springValidatorBeans).containsExactly(""mvcValidator"");
+		assertThat(this.context.getBean(""mvcValidator""))
 				.isSameAs(this.context.getBean(MvcValidator.class).validator);
 	}
 
 	@Test
-	public void validationCustomConfigurerTakesPrecedenceAndDoNotExposeJsr303() {
-		load(MvcJsr303Validator.class);
+	public void validatorWithConfigurerDoesNotExposeJsr303() {
+		load(MvcJsr303Validator.class, new Class<?>[] { ValidationAutoConfiguration.class });
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).isEmpty();
 		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
 				.isEmpty();
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(1);
-		Validator validator = this.context.getBean(Validator.class);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(springValidatorBeans).containsExactly(""mvcValidator"");
+		Validator validator = this.context.getBean(""mvcValidator"", Validator.class);
 		assertThat(validator).isInstanceOf(WebMvcValidator.class);
 		assertThat(((WebMvcValidator) validator).getTarget())
 				.isSameAs(this.context.getBean(MvcJsr303Validator.class).validator);
 	}
 
 	@Test
-	public void validationJsr303CustomValidatorReusedAsSpringValidator() {
-		load(CustomValidator.class);
+	public void validatorWithConfigurerTakesPrecedence() {
+		load(MvcValidator.class);
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).hasSize(1);
 		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
 				.hasSize(1);
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(2);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(springValidatorBeans).containsExactly(""defaultValidator"", ""mvcValidator"");
+		assertThat(this.context.getBean(""mvcValidator""))
+				.isSameAs(this.context.getBean(MvcValidator.class).validator);
+		// Primary Spring validator is the auto-configured one as the MVC one has been
+		// customized via a WebMvcConfigurer
+		assertThat(this.context.getBean(Validator.class))
+				.isEqualTo(this.context.getBean(""defaultValidator""));
+	}
+
+	@Test
+	public void validatorWithCustomSpringValidatorIgnored() {
+		load(CustomSpringValidator.class);
+		String[] jsrValidatorBeans = this.context
+				.getBeanNamesForType(javax.validation.Validator.class);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(jsrValidatorBeans).containsExactly(""defaultValidator"");
+		assertThat(springValidatorBeans).containsExactly(
+				""customSpringValidator"", ""defaultValidator"", ""mvcValidator"");
 		Validator validator = this.context.getBean(""mvcValidator"", Validator.class);
 		assertThat(validator).isInstanceOf(WebMvcValidator.class);
+		Object defaultValidator = this.context.getBean(""defaultValidator"");
 		assertThat(((WebMvcValidator) validator).getTarget())
-				.isSameAs(this.context.getBean(javax.validation.Validator.class));
+				.isSameAs(defaultValidator);
+		// Primary Spring validator is the one use by MVC behind the scenes
+		assertThat(this.context.getBean(Validator.class)).isEqualTo(defaultValidator);
 	}
 
 	@Test
-	public void validationJsr303ValidatorExposedAsSpringValidator() {
-		load(Jsr303Validator.class);
+	public void validatorWithCustomJsr303ValidatorExposedAsSpringValidator() {
+		load(CustomJsr303Validator.class);
 		assertThat(this.context.getBeansOfType(ValidatorFactory.class)).isEmpty();
-		assertThat(this.context.getBeansOfType(javax.validation.Validator.class))
-				.hasSize(1);
-		assertThat(this.context.getBeansOfType(Validator.class)).hasSize(1);
+		String[] jsrValidatorBeans = this.context
+				.getBeanNamesForType(javax.validation.Validator.class);
+		String[] springValidatorBeans = this.context.getBeanNamesForType(Validator.class);
+		assertThat(jsrValidatorBeans).containsExactly(""customJsr303Validator"");
+		assertThat(springValidatorBeans).containsExactly(""mvcValidator"");
 		Validator validator = this.context.getBean(Validator.class);
 		assertThat(validator).isInstanceOf(WebMvcValidator.class);
 		SpringValidatorAdapter target = ((WebMvcValidator) validator)
 				.getTarget();
 		assertThat(new DirectFieldAccessor(target).getPropertyValue(""targetValidator""))
-				.isSameAs(this.context.getBean(javax.validation.Validator.class));
+				.isSameAs(this.context.getBean(""customJsr303Validator""));
 	}
 
 	private void load(Class<?> config, String... environment) {
+		load(config, null, environment);
+	}
+
+	private void load(Class<?> config, Class<?>[] exclude, String... environment) {
 		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
 		EnvironmentTestUtils.addEnvironment(this.context, environment);
 		List<Class<?>> configClasses = new ArrayList<Class<?>>();
 		if (config != null) {
 			configClasses.add(config);
 		}
-		configClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,
+		configClasses.addAll(Arrays.asList(Config.class,
+				ValidationAutoConfiguration.class, WebMvcAutoConfiguration.class,
 				HttpMessageConvertersAutoConfiguration.class,
 				PropertyPlaceholderAutoConfiguration.class));
+		if (!ObjectUtils.isEmpty(exclude)) {
+			configClasses.removeAll(Arrays.asList(exclude));
+		}
 		this.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));
 		this.context.refresh();
 	}
@@ -919,21 +970,21 @@ public Validator getValidator() {
 	}
 
 	@Configuration
-	static class Jsr303Validator {
+	static class CustomJsr303Validator {
 
 		@Bean
-		public javax.validation.Validator jsr303Validator() {
+		public javax.validation.Validator customJsr303Validator() {
 			return mock(javax.validation.Validator.class);
 		}
 
 	}
 
 	@Configuration
-	static class CustomValidator {
+	static class CustomSpringValidator {
 
 		@Bean
-		public Validator customValidator() {
-			return new LocalValidatorFactoryBean();
+		public Validator customSpringValidator() {
+			return mock(Validator.class);
 		}
 
 	}
",True,"The commit message refers to the necessity of changes by mentioning the need to ensure that a primary JSR 303 and Spring Validator will be exposed if the auto-configuration kicks in. This is done to address the issue where `LocalValidatorFactoryBean` exposes 3 contracts and the commit message explains that only checking for the absence of a `javax.validation.Validator` might not be sufficient. The message also mentions that it is fixing an issue in a different way, which implies that there was a previous implementation that had issues. Overall, the commit message provides a clear explanation of the changes made and the reasons behind them.",True,"The commit message refers to the necessity of changes by not explicitly stating a rationale. It mentions that the commit ensures the auto-configuration of a primary JSR 303 and Spring Validator, which is a common practice in Spring applications. It also mentions that the commit restores and adds tests to validate the auto-configuration, which is a good practice to ensure the correctness of the changes. The code diff also supports this explanation, as it shows the addition of a new class and the modification of existing classes related to validation configuration.",True,"The commit message explains the motivation for the changes by mentioning the need to ensure that a primary JSR 303 and Spring Validator will be exposed if the auto-configuration kicks in. It also mentions the issue that this commit is addressing and how it fixes it in a different way. Additionally, the code diff shows that the commit is modifying the configuration of the Validator and MVC Validator, which is directly related to the motivation mentioned in the commit message.",True,"The commit message mentions that the changes are made to ensure that a primary JSR 303 and Spring Validator will be exposed if the auto-configuration kicks in. This indicates that the changes are made to address the need for software development to meet the requirements of users, specifically to provide a validator that can be injected by type.",True,"The commit message directly mentions the improvements it makes to the code by stating that it ensures that a primary JSR 303 and Spring Validator will be exposed if the auto-configuration kicks in. It also mentions that it restores and adds tests that validate the ValidationAutoConfiguration will configure a JSR validator even if a Spring Validator is present, effectively fixing an issue in a different way.",True,"The commit message describes the changes made to the validator and MVC validator configuration. It mentions that a primary JSR 303 and Spring Validator will be exposed if the auto-configuration kicks in. This is a summary of the diffs, as it points out the key components of the change, which are the modifications to the validator and MVC validator configuration.",True,"The commit message explains that the changes are made to ensure that a primary JSR 303 and Spring Validator will be exposed if the auto-configuration kicks in. This is based on the technical principle that if a standard JSR validator does not exist but a Spring's Validator exists and is primary, it should not be flagged as @Primary. This is to prevent conflicts and ensure proper functioning of the validation mechanism.",True,The commit message describes the changes made to the code in a functional perspective. It explains that the commit ensures the presence of a primary JSR 303 and Spring Validator if the auto-configuration kicks in. This is done by checking for the absence of a `javax.validation.Validator` and configuring a `LocalValidatorFactoryBean` if necessary. The message also mentions that the commit restores and adds tests to validate the `ValidationAutoConfiguration` and fixes an issue in a different way. This shows that the commit introduces new behaviors related to the validation configuration and testing.,False,"The commit message does not lack an explanation. It clearly states the reasons for the changes made, such as ensuring the auto-configuration of a primary JSR 303 and Spring Validator, handling the exposure of multiple contracts by LocalValidatorFactoryBean, and fixing an issue with the auto-configuration of a JSR validator when a Spring Validator is present."
https://github.com/spring-projects/spring-boot/commit/05e6af23cf2e60d5c61388fbb954bd56f00b9f94,Prepend without replacing in HttpMessageConverters  <enter> It was incorrect to simply replace existing instances because you can't tell from the instance which media types and java types it supports. This fix just prepends the custom converters so they get higher priority. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/05e6af23cf2e60d5c61388fbb954bd56f00b9f94,"@@ -75,15 +75,7 @@ public HttpMessageConverters(HttpMessageConverter<?>... additionalConverters) {
 	public HttpMessageConverters(Collection<HttpMessageConverter<?>> additionalConverters) {
 		List<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>();
 		List<HttpMessageConverter<?>> defaultConverters = getDefaultConverters();
-		for (HttpMessageConverter<?> converter : additionalConverters) {
-			int defaultConverterIndex = indexOfItemClass(defaultConverters, converter);
-			if (defaultConverterIndex == -1) {
-				converters.add(converter);
-			}
-			else {
-				defaultConverters.set(defaultConverterIndex, converter);
-			}
-		}
+		converters.addAll(additionalConverters);
 		converters.addAll(defaultConverters);
 		this.converters = Collections.unmodifiableList(converters);
 	}
@@ -120,16 +112,6 @@ private void reorderXmlConvertersToEnd(List<HttpMessageConverter<?>> converters)
 		converters.addAll(xml);
 	}
 
-	private <E> int indexOfItemClass(List<E> list, E item) {
-		Class<? extends Object> itemClass = item.getClass();
-		for (int i = 0; i < list.size(); i++) {
-			if (list.get(i).getClass().isAssignableFrom(itemClass)) {
-				return i;
-			}
-		}
-		return -1;
-	}
-
 	@Override
 	public Iterator<HttpMessageConverter<?>> iterator() {
 		return getConverters().iterator();
@@ -69,6 +69,15 @@ public void overrideExistingConverter() {
 		MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
 		HttpMessageConverters converters = new HttpMessageConverters(converter);
 		assertTrue(converters.getConverters().contains(converter));
+		int count = 0;
+		for (HttpMessageConverter<?> httpMessageConverter : converters) {
+			if (httpMessageConverter instanceof MappingJackson2HttpMessageConverter) {
+				count++;
+			}
+		}
+		// The existing converter is still there, but with a lower priority
+		assertEquals(2, count);
+		assertEquals(0, converters.getConverters().indexOf(converter));
 	}
 
 	@Test
",True,"The commit message explains the necessity of changes by referencing a problem in the prior implementation. It mentions that the previous approach of replacing existing instances was incorrect because it was not possible to determine from the instance which media types and Java types it supported. The commit message then explains that the fix prepends the custom converters so they get higher priority, which is a clear improvement over the previous approach.",True,"The commit message explains the necessity of changes by stating that it was incorrect to simply replace existing instances of HttpMessageConverters because you can't tell from the instance which media types and java types it supports. The fix prepends the custom converters so they get higher priority, which is a clear explanation of the change made in the code diff.",True,"The commit message explains the problem that occurred when replacing existing instances of HttpMessageConverters. It states that it was not possible to determine which media types and Java types the instance supported, which could lead to incorrect behavior. The message then explains that the fix involves prepending the custom converters so they get higher priority, effectively addressing the issue.",True,"The commit message indicates that the changes were made to address a problem in the software maintenance process. The problem is that the existing instances of HttpMessageConverters were being replaced, which could not accurately determine the media types and Java types they supported. This could lead to incorrect behavior. The fix prepends the custom converters so they get higher priority, which addresses the issue and ensures that the custom converters are used correctly.",True,The commit message directly mentions the issue it fixes by stating that it was incorrect to simply replace existing instances of HttpMessageConverters because you can't tell from the instance which media types and java types it supports. The message also explains the improvement made to the code by stating that the fix just prepends the custom converters so they get higher priority.,True,"The commit message 'Prepend without replacing in HttpMessageConverters' accurately summarizes the changes made in the diff. It highlights the key component of the change, which is the modification of the code to prepend custom converters instead of replacing existing instances. This is further clarified in the message body, which explains that the previous method of replacement was incorrect because it was not possible to determine the media types and Java types supported by the instance. The message also contrasts the before and after state of the code, implying that the change improves the functionality by giving higher priority to the custom converters.",True,"The commit message explains the technical principle underpinning the changes, which is the importance of preserving the order of HttpMessageConverters. By prepending the custom converters instead of replacing existing instances, the changes ensure that the custom converters have higher priority, which is crucial because you can't tell from the instance which media types and Java types it supports.",True,"The commit message 'Prepend without replacing in HttpMessageConverters' accurately describes the code changes. It explains that the code was incorrectly replacing existing instances of HttpMessageConverters, which could not be determined from the instance which media types and Java types it supports. The fix prepends the custom converters, giving them higher priority without replacing the existing ones. This change introduces new behavior where custom converters have higher priority than the default ones.",False,The commit message does not lack an explanation. It clearly states the reason for the change: 'It was incorrect to simply replace existing instances because you can't tell from the instance which media types and java types it supports. This fix just prepends the custom converters so they get higher priority.' This explanation is necessary to understand the context and the importance of the change.
https://github.com/square/retrofit/commit/238a9e59e69d61479a4505dba5f5659a599c699f,"Doc error. `@QueryMap` with `encoded=true` will stop default url encoding. So, calling with `foo.list(ImmutableMap.of('foo', 'foo+bar'))` yields '/search?foo=foo+bar' instead of '/search?foo=foo%2Bbar'. ",https://api.github.com/repos/square/retrofit/commits/238a9e59e69d61479a4505dba5f5659a599c699f,"@@ -43,8 +43,8 @@
  * &#64;GET(""/search"")
  * Call&lt;ResponseBody> list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
  * }</pre>
- * Calling with {@code foo.list(ImmutableMap.of(""foo"", ""foo+foo""))} yields
- * {@code /search?foo=foo%2Bbar}.
+ * Calling with {@code foo.list(ImmutableMap.of(""foo"", ""foo+bar""))} yields
+ * {@code /search?foo=foo+bar}.
  *
  * @see Query
  */
",True,"The commit message refers to a convention regarding URL encoding. It explains that the previous implementation was not following the standard URL encoding, which caused an issue when using special characters like '+'. The commit message explains the necessity of changes by referencing the convention of URL encoding and the problem it was causing.",True,"The commit message explains the necessity of the changes by highlighting a bug in the existing code. The bug is that the '@QueryMap' with 'encoded=true' is not performing URL encoding as expected, causing incorrect URLs to be generated. This is not a common sense or easy to infer issue, and the commit message clearly explains the problem and the solution.",True,The commit message directly elaborates the motivation of the code change by describing the error scenario. It explains that the previous implementation of the '@QueryMap' with 'encoded=true' was causing URL encoding issues. It provides an example where calling 'foo.list(ImmutableMap.of(,True,"The commit message indicates that the change was made due to a problem in the software maintenance process. The problem is that the '@QueryMap' with 'encoded=true' was not performing the default URL encoding correctly, which was causing issues when calling the 'foo.list' method with a map containing '+' characters. This issue was causing the '+' characters to be interpreted as spaces instead of '%2B', which was not the intended behavior.",True,"The commit message directly mentions the issue it fixes, which is the incorrect URL encoding when using '@QueryMap' with 'encoded=true'. It explains that the change will ensure that calling with 'foo+bar' yields '/search?foo=foo%2Bbar' instead of '/search?foo=foo+bar'.",True,"The commit message accurately summarizes the change by describing the issue with the '@QueryMap' annotation and its 'encoded' attribute. It explains that the change will stop the default URL encoding, and it provides an example of how this change will affect the output. The example in the commit message directly corresponds to the change in the code diff, which modifies the value passed to the 'list' method and the expected output in the URL.",True,"The commit message explains that the changes are made to handle URL encoding when using the '@QueryMap' annotation with 'encoded=true'. It explains that without this change, the '+' character in the query parameter would be URL encoded as '%2B', but with the change, it will be left as '+'. This is a clear explanation of the technical principle underpinning the changes, which is the handling of URL encoding in query parameters.",True,"The commit message accurately describes the change in the code. It explains that the '@QueryMap' annotation with 'encoded=true' will stop the default URL encoding. This change will result in a new behavior when calling the 'foo.list' method with a map containing '+' characters. Previously, these '+' characters would be URL encoded as '%2B', but now they will be sent as is, which can lead to incorrect results if the server is not expecting unencoded '+' characters.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: the change in the '@QueryMap' annotation with 'encoded=true' will stop default URL encoding. This means that the URL '/search?foo=foo+bar' will be produced instead of '/search?foo=foo%2Bbar'. This change is not trivial and could potentially break existing functionality, so an explanation is necessary."
https://github.com/square/retrofit/commit/f4ee9e28a6380662ea0ab8a9a02adbd021ef55e8,Added more tests for RxJava Single type support  <enter> Single.toBlocking() is present since RxJava 1.0.16 version. ,https://api.github.com/repos/square/retrofit/commits/f4ee9e28a6380662ea0ab8a9a02adbd021ef55e8,"@@ -54,7 +54,7 @@
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.14</rxjava.version>
+    <rxjava.version>1.1.0</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.4</gson.version>
@@ -32,10 +32,10 @@
 import rx.Observable;
 import rx.Single;
 import rx.observables.BlockingObservable;
+import rx.singles.BlockingSingle;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
 public final class RxJavaCallAdapterFactoryTest {
@@ -236,11 +236,97 @@ interface Service {
     }
   }
 
-  @Test public void single() {
-    // TODO Better tests here. Why is there no toBlocking() on Single?
-    assertNotNull(service.singleBody());
-    assertNotNull(service.singleResponse());
-    assertNotNull(service.singleResult());
+  @Test public void singleBodySuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingSingle<String> o = service.singleBody().toBlocking();
+    assertThat(o.value()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleBodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingSingle<String> o = service.singleBody().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 OK"");
+    }
+  }
+
+  @Test public void singleBodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<String> o = service.singleBody().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void singleResponseSuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
+    Response<String> response = o.value();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleResponseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+
+    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
+    Response<String> response = o.value();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleResponseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException t) {
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void singleResultSuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleResultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+
+    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+  }
+
+  @Test public void singleResultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
   }
 
   static class StringConverterFactory extends Converter.Factory {
",True,"The commit message explains the necessity of changes by referencing an improvement in the RxJava library. It mentions that Single.toBlocking() is present since RxJava 1.0.16 version, which is a newer version than the one currently used in the project. This justifies the update of the RxJava version in the project to take advantage of this new feature.",True,"The commit message 'Added more tests for RxJava Single type support' clearly describes the changes made to the codebase, which is adding more tests for the RxJava Single type. This is a common practice in software development to ensure the functionality of the code is maintained or improved. The message does not provide a rationale for the changes, but it is easy to infer that the tests are being added to improve the coverage and reliability of the code.",True,"The commit message 'Added more tests for RxJava Single type support' does describe the necessity of changes by elaborating the motivation of a code change. It mentions that Single.toBlocking() is present since RxJava 1.0.16 version, which implies that the previous implementation did not support this feature. The code diff also shows that the RxJava version has been updated from 1.0.14 to 1.1.0, further indicating that the changes are necessary to support the new version of RxJava.",True,"The commit message 'Added more tests for RxJava Single type support' indicates that the changes were made to accommodate new features or updates in the RxJava library. The message also mentions that 'Single.toBlocking() is present since RxJava 1.0.16 version', which suggests that the changes were made due to the need to support a newer version of RxJava. This indicates a requirement for software development to keep up with updates and changes in the libraries being used.",True,The commit message 'Added more tests for RxJava Single type support' directly mentions the improvement it makes to the code by adding more tests for the RxJava Single type. This is particularly evident in the code diff where new tests have been added for Single.toBlocking() which was not previously tested.,True,"The commit message 'Added more tests for RxJava Single type support' summarizes the changes made in the diff. It specifically mentions the addition of tests for RxJava Single type support, which is a key component of the change. The message also mentions that Single.toBlocking() is present since RxJava 1.0.16 version, which is a detail that is reflected in the diff where the RxJava version is updated from 1.0.14 to 1.1.0. Additionally, the diff shows the addition of new test methods and the import of BlockingSingle, which are both related to the changes mentioned in the commit message.",True,"The commit message explains that the changes are adding more tests for RxJava Single type support, which is a new feature since RxJava 1.0.16 version. The code diff also shows the addition of the BlockingSingle class, which is used in the new tests. This indicates that the technical principle underpinning the changes is the use of the toBlocking() method to convert a Single into a BlockingSingle, allowing for synchronous execution of the Single.",True,"The commit message 'Added more tests for RxJava Single type support' accurately describes the changes made in the code diff. The message explains that the changes are additions of more tests to support the RxJava Single type, which was introduced in version 1.0.16. The code diff shows the addition of new import statements for BlockingSingle and the addition of several new test methods that utilize the toBlocking() method on Single, which is a new behavior introduced by the updated RxJava version.",False,"The commit message does not lack an explanation. It clearly states that more tests are being added for RxJava Single type support, which is a significant change. The version of RxJava is also being updated, which could potentially introduce new behaviors or bugs. The code diff shows that new tests are being added and the version of RxJava is being updated, which supports the explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/09200361defde95ec48bd9169ab5db7590c9440b,"Align expectations of various JMX configurations  <enter> They all want to create an MBeanServer and when that happens user sees no MBeans, or sometimes just one set (Spring Core, Spring Integration or Spring Boot). To harmonise them we create a  @bean  of type MBeanServer and link to it in the other autoconfigs <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/09200361defde95ec48bd9169ab5db7590c9440b,"@@ -16,12 +16,15 @@
 
 package org.springframework.boot.actuate.autoconfigure;
 
+import javax.management.MBeanServer;
+
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.actuate.endpoint.Endpoint;
 import org.springframework.boot.actuate.endpoint.jmx.EndpointMBeanExporter;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
+import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -35,21 +38,22 @@
  */
 @Configuration
 @ConditionalOnExpression(""${endpoints.jmx.enabled:true} && ${spring.jmx.enabled:true}"")
-@AutoConfigureAfter({ EndpointAutoConfiguration.class })
+@AutoConfigureAfter({ EndpointAutoConfiguration.class, JmxAutoConfiguration.class })
 @EnableConfigurationProperties(EndpointMBeanExportProperties.class)
 public class EndpointMBeanExportAutoConfiguration {
 
 	@Autowired
 	EndpointMBeanExportProperties properties = new EndpointMBeanExportProperties();
 
 	@Bean
-	public EndpointMBeanExporter endpointMBeanExporter() {
+	public EndpointMBeanExporter endpointMBeanExporter(MBeanServer server) {
 		EndpointMBeanExporter mbeanExporter = new EndpointMBeanExporter();
 
 		String domain = this.properties.getDomain();
 		if (StringUtils.hasText(domain)) {
 			mbeanExporter.setDomain(domain);
 		}
+		mbeanExporter.setServer(server);
 
 		mbeanExporter.setEnsureUniqueRuntimeObjectNames(this.properties.isUniqueNames());
 		mbeanExporter.setObjectNameStaticProperties(this.properties.getStaticNames());
@@ -26,6 +26,7 @@
 import org.junit.Test;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
 import org.springframework.boot.actuate.endpoint.jmx.EndpointMBeanExporter;
+import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Configuration;
@@ -56,7 +57,8 @@ public void close() {
 	@Test
 	public void testEndpointMBeanExporterIsInstalled() {
 		this.context = new AnnotationConfigApplicationContext();
-		this.context.register(TestConfiguration.class, EndpointAutoConfiguration.class,
+		this.context.register(TestConfiguration.class, JmxAutoConfiguration.class,
+				EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 		this.context.refresh();
 		assertNotNull(this.context.getBean(EndpointMBeanExporter.class));
@@ -68,7 +70,8 @@ public void testEndpointMBeanExporterIsNotInstalled() {
 		environment.setProperty(""endpoints.jmx.enabled"", ""false"");
 		this.context = new AnnotationConfigApplicationContext();
 		this.context.setEnvironment(environment);
-		this.context.register(EndpointAutoConfiguration.class,
+		this.context.register(JmxAutoConfiguration.class,
+				EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 		this.context.refresh();
 		this.context.getBean(EndpointMBeanExporter.class);
@@ -84,7 +87,8 @@ public void testEndpointMBeanExporterWithProperties() throws IntrospectionExcept
 		environment.setProperty(""endpoints.jmx.static_names"", ""key1=value1, key2=value2"");
 		this.context = new AnnotationConfigApplicationContext();
 		this.context.setEnvironment(environment);
-		this.context.register(EndpointAutoConfiguration.class,
+		this.context.register(JmxAutoConfiguration.class,
+				EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 		this.context.refresh();
 		this.context.getBean(EndpointMBeanExporter.class);
@@ -101,11 +105,12 @@ public void testEndpointMBeanExporterWithProperties() throws IntrospectionExcept
 	public void testEndpointMBeanExporterInParentChild() throws IntrospectionException,
 			InstanceNotFoundException, MalformedObjectNameException, ReflectionException {
 		this.context = new AnnotationConfigApplicationContext();
-		this.context.register(EndpointAutoConfiguration.class,
+		this.context.register(JmxAutoConfiguration.class,
+				EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 
 		AnnotationConfigApplicationContext parent = new AnnotationConfigApplicationContext();
-		parent.register(EndpointAutoConfiguration.class,
+		parent.register(JmxAutoConfiguration.class, EndpointAutoConfiguration.class,
 				EndpointMBeanExportAutoConfiguration.class);
 		this.context.setParent(parent);
 
@@ -136,6 +136,11 @@
 			<artifactId>spring-integration-core</artifactId>
 			<optional>true</optional>
 		</dependency>
+		<dependency>
+			<groupId>org.springframework.integration</groupId>
+			<artifactId>spring-integration-jmx</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>org.springframework</groupId>
 			<artifactId>spring-jms</artifactId>
@@ -16,24 +16,40 @@
 
 package org.springframework.boot.autoconfigure.integration;
 
+import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.integration.config.EnableIntegration;
+import org.springframework.integration.jmx.config.EnableIntegrationMBeanExport;
+import org.springframework.integration.jmx.config.IntegrationMBeanExportConfiguration;
 
 /**
  * {@link org.springframework.boot.autoconfigure.EnableAutoConfiguration
  * Auto-configuration} for Spring Integration.
  * 
  * @author Artem Bilan
+ * @author Dave Syer
  * @since 1.1
  */
 @Configuration
 @ConditionalOnClass(EnableIntegration.class)
+@AutoConfigureAfter(JmxAutoConfiguration.class)
 public class IntegrationAutoConfiguration {
 
 	@Configuration
 	@EnableIntegration
 	protected static class IntegrationConfiguration {
 	}
 
+	@Configuration
+	@ConditionalOnClass(EnableIntegrationMBeanExport.class)
+	@ConditionalOnMissingBean(IntegrationMBeanExportConfiguration.class)
+	@ConditionalOnExpression(""${spring.jmx.enabled:true}"")
+	@EnableIntegrationMBeanExport(defaultDomain = ""${spring.jmx.default_domain:}"", server = ""${spring.jmx.server:mbeanServer}"")
+	protected static class IntegrationJmxConfiguration {
+	}
+
 }
@@ -16,13 +16,17 @@
 
 package org.springframework.boot.autoconfigure.jmx;
 
+import javax.management.MBeanServer;
+
 import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.EnableMBeanExport;
 import org.springframework.jmx.export.MBeanExporter;
+import org.springframework.jmx.support.MBeanServerFactoryBean;
 
 /**
  * {@link EnableAutoConfiguration Auto-configuration} to enable/disable Spring's
@@ -34,14 +38,21 @@
  */
 @Configuration
 @ConditionalOnClass({ MBeanExporter.class })
-@ConditionalOnMissingBean({ MBeanExporter.class })
 @ConditionalOnExpression(""${spring.jmx.enabled:true}"")
 public class JmxAutoConfiguration {
 
 	@Configuration
-	@EnableMBeanExport(defaultDomain = ""${spring.jmx.default_domain:}"", server = ""${spring.jmx.server:}"")
+	@ConditionalOnMissingBean({ MBeanExporter.class })
+	@EnableMBeanExport(defaultDomain = ""${spring.jmx.default_domain:}"", server = ""${spring.jmx.server:mbeanServer}"")
 	public static class MBeanExport {
+	}
 
+	@Bean
+	@ConditionalOnMissingBean(MBeanServer.class)
+	public MBeanServerFactoryBean mbeanServer() {
+		MBeanServerFactoryBean factory = new MBeanServerFactoryBean();
+		factory.setLocateExistingServerIfPossible(true);
+		return factory;
 	}
 
 }
@@ -17,6 +17,7 @@
 package org.springframework.boot.autoconfigure.integration;
 
 import org.junit.Test;
+import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.integration.support.channel.HeaderChannelRegistry;
 
@@ -32,7 +33,8 @@ public class IntegrationAutoConfigurationTests {
 
 	@Test
 	public void integrationIsAvailable() {
-		this.context.register(IntegrationAutoConfiguration.class);
+		this.context.register(JmxAutoConfiguration.class,
+				IntegrationAutoConfiguration.class);
 		this.context.refresh();
 		assertNotNull(this.context.getBean(HeaderChannelRegistry.class));
 		this.context.close();
@@ -1688,6 +1688,17 @@ infrastructure to receive messages asynchronously. Spring AMQP provides a simila
 feature set for the ``Advanced Message Queuing Protocol'' and Boot also provides
 auto-configuration options for `RabbitTemplate` and RabbitMQ.
 
+[[boot-features-messaging]]
+== Spring Integration
+
+Spring Integration provides abstractions over messaging and also other 
+transports such as HTTP, TCP etc. If Spring Integration is available
+on your classpath it will be initialized through the `@EnableIntegration`
+annotation. Message processing statistics will be published over JMX if
+``spring-integration-jmx'' is also on the classpath. 
+See the {sc-spring-boot-autoconfigure}/integration/IntegrationAutoConfiguration.{sc-ext}[`IntegrationAutoConfiguration`]
+class for more details.
+
 [[boot-features-jms]]
 == JMS
 
@@ -1792,6 +1803,17 @@ into your own beans:
 	}
 ----
 
+[[boot-features-jmx]]
+== Monitoring and management over JMX
+
+Java Management Extensions (JMX) provide a standard mechanism to
+monitor and manage applications. By default Spring Boot will create an
+`MBeanServer` with bean id ""mbeanServer"" and expose any of your beans
+that are annotated with Spring JMX annotations (`@ManagedResource`,
+`@ManagedAttribute`, `@ManagedOperation`).
+
+See the {sc-spring-boot-autoconfigure}/jmx/JmxAutoConfiguration.{sc-ext}[`JmxAutoConfiguration`]
+class for more details.
 
 [[boot-features-testing]]
 == Testing
@@ -23,6 +23,10 @@
 			<groupId>org.springframework.boot</groupId>
 			<artifactId>spring-boot-starter-integration</artifactId>
 		</dependency>
+		<dependency>
+			<groupId>org.springframework.integration</groupId>
+			<artifactId>spring-integration-jmx</artifactId>
+		</dependency>
 		<dependency>
 			<groupId>org.springframework.boot</groupId>
 			<artifactId>spring-boot-starter-test</artifactId>
@@ -1,2 +1,3 @@
 logging.file: /tmp/logs/app.log
-service.greeting: Hello
\ No newline at end of file
+service.greeting: Hello
+debug: true
\ No newline at end of file
",True,"The commit message refers to the necessity of changes by mentioning the issue of various JMX configurations creating an MBeanServer differently, causing user to see no MBeans or just one set. To harmonize them, the commit creates a @bean of type MBeanServer and links to it in the other autoconfigs. This is done to ensure consistency and predictability in the JMX configuration across different modules.",True,"The commit message 'Align expectations of various JMX configurations' describes the necessity of changes by explaining the problem that the changes are addressing. The problem is that different JMX configurations are creating an MBeanServer in different ways, which can lead to user seeing no MBeans or just one set. The changes are made to harmonise them by creating a single @bean of type MBeanServer and linking to it in the other autoconfigs. This makes the code more consistent and predictable, which is a clear benefit. The code diff also supports this explanation by showing the changes made to the code to achieve this.",True,"The commit message 'Align expectations of various JMX configurations' explains the motivation of the code change by mentioning that different JMX configurations were creating an MBeanServer in different ways, which was causing user visibility issues. The message also mentions that the change is to harmonize these configurations by creating a single @bean of type MBeanServer and linking to it in the other autoconfigs. Additionally, the message mentions that it fixes an issue, which further elaborates the necessity of the changes.",True,"The commit message 'Align expectations of various JMX configurations' indicates that the developer is addressing the need for software development to meet the requirements of users. Specifically, the changes are made to harmonize the creation of an MBeanServer across different configurations to ensure that users see the expected MBeans. This suggests that the changes are being made to improve the functionality and usability of the software.",True,The commit message 'Align expectations of various JMX configurations' directly mentions the change that it is harmonizing the JMX configurations to create an MBeanServer and link it to other autoconfigs. This change is likely to fix the issue where users were not seeing the expected MBeans.,True,"The commit message 'Align expectations of various JMX configurations' describes the changes made in the code diff. It mentions creating an MBeanServer and linking it to other autoconfigs, which are actions described in the diff. Additionally, it mentions harmonizing various JMX configurations, which is also a summary of the changes made in the diff.",True,"The commit message explains that the changes are made to harmonize various JMX configurations by creating a single @bean of type MBeanServer and linking to it in the other autoconfigs. This is done to ensure that when an MBeanServer is created, the user sees the expected MBeans instead of none or just one set. This aligns the expectations and demonstrates the principle of creating a single source of truth for a shared resource.",True,"The commit message 'Align expectations of various JMX configurations' describes the changes made to the code in a functional perspective. It explains that the code changes are made to harmonize the creation of an MBeanServer across different configurations (Spring Core, Spring Integration, Spring Boot) to ensure consistent behavior. The message also mentions the introduction of a new @bean of type MBeanServer and linking it to the other autoconfigs. This indicates that a new MBeanServer is being created and used to export MBeans, which is a new behavior introduced by the changes.",False,"The commit message explains the reason for the change, which is to harmonize various JMX configurations by creating a single MBeanServer and linking to it in the other autoconfigs. This change is not trivial and requires understanding of the JMX configuration in Spring Boot. Therefore, the commit message provides a clear explanation of the change, making it unnecessary to infer the reason from the code diff."
https://github.com/spring-projects/spring-boot/commit/2516dc033f909281702dfd2f99e8d0f05d59af8b,"Fix documentation example  <enter> Previously, the nested private static class would cause an error at startup stating that it was not accessible when trying to bind the property from the environment. The nested class should be public. <enter>  Closes   <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/2516dc033f909281702dfd2f99e8d0f05d59af8b,"@@ -813,7 +813,7 @@ as `@Valid` to trigger its validation. For example, building upon the above
 
 		// ... getters and setters
 
-		private static class RemoteAddress {
+		public static class RemoteAddress {
 
 			@NotEmpty
 			public String hostname;
",True,The commit message refers to a prior issue where a nested private static class caused an error at startup. The change to make the nested class public is explained as a necessary fix to resolve this issue. This references a convention or standard (making the class public to make it accessible) and the necessity of the change is clearly described.,True,The commit message explains the necessity of the change by stating that the nested private static class was causing an error at startup stating that it was not accessible when trying to bind the property from the environment. The change to make the nested class public is necessary to resolve this error.,True,"The commit message directly elaborates the motivation of the code change by describing the error scenario that occurred when trying to bind the property from the environment. It mentions that the nested private static class was not accessible at startup, causing an error. The commit message then explains that the class should be public to fix the issue. This clearly describes the necessity of the changes and provides a clear motivation for the code change.",True,"The commit message 'Fix documentation example' indicates that there was a problem in the documentation example, which caused an error at startup. The error message 'not accessible' suggests that the code was not functioning as intended, which is a problem in the software maintenance process. The change from 'private' to 'public' for the nested class was made to fix this issue, indicating that the change was necessary to address a problem.",True,"The commit message directly mentions the defect it fixes, which is the error at startup stating that the nested private static class was not accessible. The change made to the code, i.e., changing the nested class from private to public, is explicitly mentioned to fix this issue.",True,"The commit message accurately summarizes the change made in the code diff. It clearly states that the nested private static class was causing an error at startup and needed to be made public to fix the issue. This is a direct reflection of the change made in the code diff, where the access modifier of the class was changed from private to public.",True,"The commit message explains that the change was made to the access modifier of a nested class from private to public. This is based on the technical principle that in order for a class to be accessible and used in other parts of the codebase, it needs to have a public access modifier.",True,"The commit message accurately describes the change made in the code diff. It mentions that there was a nested private static class that caused an error at startup due to its inaccessibility. The commit message then states that the class should be made public to fix the issue. This change indeed introduces a new behavior, as it modifies the accessibility of the class, which could potentially affect how the property is bound from the environment.",False,The commit message does not lack an explanation. It clearly states the reason for the change: the nested private static class was causing an error at startup stating that it was not accessible when trying to bind the property from the environment. The change to make the nested class public is explicitly explained to resolve this issue.
https://github.com/apache/dubbo/commit/fa157deadf65d00c9884d611430ec78e585840ff,Refactor: remove NetUtils.getHostAddress() and relace it with NetUtils.getLocalHost() ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/fa157deadf65d00c9884d611430ec78e585840ff,"@@ -31,7 +31,7 @@ public class ConsumerContextClusterInterceptor implements ClusterInterceptor, Cl
     public void before(AbstractClusterInvoker<?> invoker, Invocation invocation) {
         RpcContext.getContext()
                 .setInvocation(invocation)
-                .setLocalAddress(NetUtils.getHostAddress(), 0);
+                .setLocalAddress(NetUtils.getLocalHost(), 0);
         if (invocation instanceof RpcInvocation) {
             ((RpcInvocation) invocation).setInvoker(invoker);
         }
@@ -139,12 +139,12 @@ static boolean isValidV4Address(InetAddress address) {
         if (address == null || address.isLoopbackAddress()) {
             return false;
         }
+
         String name = address.getHostAddress();
-        boolean result = (name != null
+        return (name != null
                 && IP_PATTERN.matcher(name).matches()
                 && !ANYHOST_VALUE.equals(name)
                 && !LOCALHOST_VALUE.equals(name));
-        return result;
     }
 
     /**
@@ -186,18 +186,16 @@ static InetAddress normalizeV6Address(Inet6Address address) {
 
     private static volatile String HOST_ADDRESS;
 
-    public static String getHostAddress () {
+    public static String getLocalHost() {
         if (HOST_ADDRESS != null) {
             return HOST_ADDRESS;
         }
 
-        HOST_ADDRESS = getLocalHost();
-        return HOST_ADDRESS;
-    }
-
-    public static String getLocalHost() {
         InetAddress address = getLocalAddress();
-        return address == null ? LOCALHOST_VALUE : address.getHostAddress();
+        if (address != null) {
+            return HOST_ADDRESS = address.getHostAddress();
+        }
+        return LOCALHOST_VALUE;
     }
 
     public static String filterLocalHost(String host) {
@@ -287,7 +285,7 @@ private static InetAddress getLocalAddress0() {
                             Optional<InetAddress> addressOp = toValidAddress(addresses.nextElement());
                             if (addressOp.isPresent()) {
                                 try {
-                                    if(addressOp.get().isReachable(100)){
+                                    if (addressOp.get().isReachable(100)) {
                                         return addressOp.get();
                                     }
                                 } catch (IOException e) {
@@ -387,7 +385,7 @@ public static void setInterface(MulticastSocket multicastSocket, boolean preferI
                 InetAddress address = (InetAddress) addresses.nextElement();
                 if (preferIpv6 && address instanceof Inet6Address) {
                     try {
-                        if(address.isReachable(100)){
+                        if (address.isReachable(100)) {
                             multicastSocket.setInterface(address);
                             interfaceSet = true;
                             break;
@@ -397,7 +395,7 @@ public static void setInterface(MulticastSocket multicastSocket, boolean preferI
                     }
                 } else if (!preferIpv6 && address instanceof Inet4Address) {
                     try {
-                        if(address.isReachable(100)){
+                        if (address.isReachable(100)) {
                             multicastSocket.setInterface(address);
                             interfaceSet = true;
                             break;
@@ -300,4 +300,11 @@ public void testMatchIpv4WithIpPort() throws UnknownHostException {
         assertFalse(NetUtils.matchIpRange(""192.168.1.1-61:90"", ""192.168.1.62"", 90));
         assertFalse(NetUtils.matchIpRange(""192.168.1.62:90"", ""192.168.1.63"", 90));
     }
+
+    @Test
+    public void testLocalHost() {
+        assertEquals(NetUtils.getLocalHost(), NetUtils.getLocalAddress().getHostAddress());
+        assertTrue(NetUtils.isValidLocalHost(NetUtils.getLocalHost()));
+        assertFalse(NetUtils.isInvalidLocalHost(NetUtils.getLocalHost()));
+    }
 }
",,,True,"The commit message 'Refactor: remove NetUtils.getHostAddress() and replace it with NetUtils.getLocalHost()' clearly describes the necessity of changes. The change is made to refactor the code and improve it. The old method NetUtils.getHostAddress() is being removed and replaced with NetUtils.getLocalHost(), which is a more appropriate method for the context in which it is used.",,,,,True,"The commit message directly mentions the change made to the code, which is the replacement of NetUtils.getHostAddress() with NetUtils.getLocalHost(). This change is likely made to improve the code by simplifying the method used to get the local host address.",,,True,"The commit message explains that the changes are made to improve the code by removing a redundant method `NetUtils.getHostAddress()` and replacing it with `NetUtils.getLocalHost()`. This is based on the technical principle of code refactoring, which aims to improve the design, structure, and maintainability of the code without changing its external behavior.",,,,
https://github.com/apache/dubbo/commit/f9f10ba5225e80c34953f56123ac1702c13e45c7,"In order to facilitate the consumer to better locate the failure of provider token check, the token value called by consumer will be printed out in the exception information ( <pr_link> ) ",https://api.github.com/repos/apache/dubbo/commits/f9f10ba5225e80c34953f56123ac1702c13e45c7,"@@ -48,7 +48,9 @@ public Result invoke(Invoker<?> invoker, Invocation inv)
             Map<String, Object> attachments = inv.getObjectAttachments();
             String remoteToken = (attachments == null ? null : (String) attachments.get(TOKEN_KEY));
             if (!token.equals(remoteToken)) {
-                throw new RpcException(""Invalid token! Forbid invoke remote service "" + serviceType + "" method "" + inv.getMethodName() + ""() from consumer "" + RpcContext.getContext().getRemoteHost() + "" to provider "" + RpcContext.getContext().getLocalHost());
+                throw new RpcException(""Invalid token! Forbid invoke remote service "" + serviceType + "" method "" + inv.getMethodName()
+                        + ""() from consumer "" + RpcContext.getContext().getRemoteHost() + "" to provider "" + RpcContext.getContext().getLocalHost()
+                        + "", consumer incorrect token is "" + remoteToken);
             }
         }
         return invoker.invoke(inv);
",True,"The commit message explains the necessity of changes by referencing a problem that the consumer is facing, which is the difficulty in locating the failure of provider token check. The changes made in the code diff are intended to facilitate this by printing out the token value called by the consumer in the exception information.",True,"The commit message clearly explains the necessity of the changes by stating that it is to facilitate the consumer in better locating the failure of provider token check. The code diff shows that the token value called by the consumer will be printed out in the exception information, which will help in diagnosing the issue.",True,"The commit message explains the motivation for the code change by mentioning the issue of the provider token check failing to locate the failure for the consumer. It also elaborates on the solution by printing out the token value in the exception information, which will help in identifying the incorrect token used by the consumer.",True,"The commit message indicates that the changes are made to facilitate the consumer in locating the failure of provider token check. This suggests that there is a problem in the current process, which is the incorrect token being used by the consumer. This is a source of requirements, as it is a user need to better locate and debug the issue.",True,The commit message directly mentions the improvement it makes to the code by stating that the token value called by the consumer will be printed out in the exception information. This change is made to facilitate the consumer in better locating the failure of provider token check.,True,"The commit message accurately summarizes the changes made in the code diff. It mentions that the token value called by the consumer will be printed out in the exception information, which is exactly what the code diff shows. Specifically, it adds the remoteToken value to the exception message, which was not present before.",True,"The commit message explains the technical principle underpinning the changes, which is to enhance the debugging and error-finding process. By printing out the token value in the exception information, the developer can easily locate the failure of the provider token check and identify the incorrect token used by the consumer.",True,"The commit message accurately summarizes the changes made in the code diff. It explains that the token value called by the consumer will be printed out in the exception information when the token check fails. This introduces a new behavior that provides more detailed information about the failure, which is beneficial for the consumer to locate the issue.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: to facilitate the consumer in locating the failure of provider token check. The change in the code diff is not trivial, as it involves printing out the token value in the exception information, which could help in debugging. Therefore, a clear explanation in the commit message is necessary to understand the purpose and impact of the change."
https://github.com/square/okhttp/commit/bffee2336725dde0f74933d5a7d12536c9bcbd06,"Introduce intermediate storage for frame contents.  <enter> This eliminates the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. Now, we only emit bytes once Okio reports complete segments. ",https://api.github.com/repos/square/okhttp/commits/bffee2336725dde0f74933d5a7d12536c9bcbd06,"@@ -246,13 +246,6 @@ public final class RealWebSocketTest {
         client.readMessage();
         clientListener.assertClose(1000, ""Hello!"");
 
-        try {
-          sink.writeUtf8(""lo!"").emit(); // No writing to the underlying sink.
-          fail();
-        } catch (IOException e) {
-          assertEquals(""closed"", e.getMessage());
-          sink.buffer().clear();
-        }
         try {
           sink.flush(); // No flushing.
           fail();
@@ -320,7 +313,7 @@ public final class RealWebSocketTest {
     clientListener.assertClose(1000, ""Bye!"");
   }
 
-  @Test public void protocolErrorBeforeCloseSendsClose() {
+  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
     server2client.write(ByteString.decodeHex(""0a00"")); // Invalid non-final ping frame.
 
     client.readMessage(); // Detects error, send close.
@@ -31,6 +31,8 @@
 
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -71,15 +73,30 @@ public final class WebSocketWriterTest {
     assertData(""8000"");
   }
 
-  @Test public void serverCloseFlushes() throws IOException {
+  @Test public void closeFlushes() throws IOException {
     BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT));
 
     sink.writeUtf8(""Hel"").flush();
     assertData(""010348656c"");
 
     sink.writeUtf8(""lo"").close();
-    assertData(""00026c6f"");
-    assertData(""8000"");
+    assertData(""80026c6f"");
+  }
+
+  @Test public void noWritesAfterClose() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT);
+
+    sink.close();
+    assertData(""8100"");
+
+    Buffer payload = new Buffer().writeUtf8(""Hello"");
+    try {
+      // Write to the unbuffered sink as BufferedSink keeps its own closed state.
+      sink.write(payload, payload.size());
+      fail();
+    } catch (IOException e) {
+      assertEquals(""closed"", e.getMessage());
+    }
   }
 
   @Test public void clientTextMessage() throws IOException {
@@ -96,39 +113,55 @@ public final class WebSocketWriterTest {
   }
 
   @Test public void serverBinaryMessage() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY));
 
-    sink.write(binaryData(50), 50);
+    sink.write(binaryData(50)).flush();
     assertData(""0232"");
-    assertData(binaryData(50).readByteArray());
+    assertData(binaryData(50));
 
-    sink.write(binaryData(50), 50);
+    sink.write(binaryData(50)).flush();
     assertData(""0032"");
-    assertData(binaryData(50).readByteArray());
+    assertData(binaryData(50));
 
     sink.close();
     assertData(""8000"");
   }
 
-  @Test public void serverBinaryMessageLengthShort() throws IOException {
+  @Test public void serverMessageLengthShort() throws IOException {
     Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
 
-    int length = 0xffff;
-    sink.write(binaryData(length), length);
-    assertData(""027effff"");
-    assertData(binaryData(length).readByteArray());
+    // Create a payload which will overflow the normal payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData(""027e""); // 'e' == 4-byte follow-up length.
+    assertData(String.format(""%04X"", payload.completeSegmentByteCount()));
+    assertData(payload.readByteArray());
 
     sink.close();
     assertData(""8000"");
   }
 
-  @Test public void serverBinaryMessageLengthLong() throws IOException {
+  @Test public void serverMessageLengthLong() throws IOException {
     Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
 
-    int length = 65537;
-    sink.write(binaryData(length), length);
-    assertData(""027f0000000000010001"");
-    assertData(binaryData(length).readByteArray());
+    // Create a payload which will overflow the normal and short payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData(""027f""); // 'f' == 16-byte follow-up length.
+    assertData(String.format(""%016X"", byteCount));
+    assertData(payload.readByteArray(byteCount));
 
     sink.close();
     assertData(""8000"");
@@ -139,30 +172,24 @@ public final class WebSocketWriterTest {
     random.nextBytes(maskKey1);
     byte[] maskKey2 = new byte[4];
     random.nextBytes(maskKey2);
-    byte[] maskKey3 = new byte[4];
-    random.nextBytes(maskKey3);
 
     random.setSeed(0); // Reset the seed so real data matches.
 
-    Sink sink = clientWriter.newMessageSink(OPCODE_BINARY);
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY));
 
-    sink.write(binaryData(50), 50);
-    byte[] part1 = binaryData(50).readByteArray();
+    byte[] part1 = binaryData(50);
+    sink.write(part1).flush();
     toggleMask(part1, 50, maskKey1, 0);
     assertData(""02b2"");
     assertData(maskKey1);
     assertData(part1);
 
-    sink.write(binaryData(50), 50);
-    byte[] part2 = binaryData(50).readByteArray();
+    byte[] part2 = binaryData(50);
+    sink.write(part2).close();
     toggleMask(part2, 50, maskKey2, 0);
-    assertData(""00b2"");
+    assertData(""80b2"");
     assertData(maskKey2);
     assertData(part2);
-
-    sink.close();
-    assertData(""8080"");
-    assertData(maskKey3);
   }
 
   @Test public void serverEmptyClose() throws IOException {
@@ -251,7 +278,7 @@ public final class WebSocketWriterTest {
 
   @Test public void pingTooLongThrows() throws IOException {
     try {
-      serverWriter.writePing(binaryData(1000));
+      serverWriter.writePing(new Buffer().write(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals(""Payload size must be less than or equal to 125"", e.getMessage());
@@ -260,7 +287,7 @@ public final class WebSocketWriterTest {
 
   @Test public void pongTooLongThrows() throws IOException {
     try {
-      serverWriter.writePong(binaryData(1000));
+      serverWriter.writePong(new Buffer().write(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals(""Payload size must be less than or equal to 125"", e.getMessage());
@@ -269,7 +296,7 @@ public final class WebSocketWriterTest {
 
   @Test public void closeTooLongThrows() throws IOException {
     try {
-      String longString = binaryData(75).readByteString().hex();
+      String longString = ByteString.of(binaryData(75)).hex();
       serverWriter.writeClose(1000, longString);
       fail();
     } catch (IllegalArgumentException e) {
@@ -303,9 +330,9 @@ private void assertData(byte[] data) throws IOException {
     }
   }
 
-  private static Buffer binaryData(int length) {
+  private static byte[] binaryData(int length) {
     byte[] junk = new byte[length];
     new Random(0).nextBytes(junk);
-    return new Buffer().write(junk);
+    return junk;
   }
 }
@@ -87,28 +87,48 @@ private Object nextEvent() {
     }
   }
 
-  public void assertTextMessage(String payload) {
+  public void assertTextMessage(String payload) throws IOException {
     Message message = new Message(TEXT);
     message.buffer.writeUtf8(payload);
-    assertEquals(message, nextEvent());
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(message, actual);
   }
 
-  public void assertBinaryMessage(byte[] payload) {
+  public void assertBinaryMessage(byte[] payload) throws IOException {
     Message message = new Message(BINARY);
     message.buffer.write(payload);
-    assertEquals(message, nextEvent());
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(message, actual);
   }
 
-  public void assertPing(Buffer payload) {
-    assertEquals(new Ping(payload), nextEvent());
+  public void assertPing(Buffer payload) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Ping(payload), actual);
   }
 
-  public void assertPong(Buffer payload) {
-    assertEquals(new Pong(payload), nextEvent());
+  public void assertPong(Buffer payload) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Pong(payload), actual);
   }
 
-  public void assertClose(int code, String reason) {
-    assertEquals(new Close(code, reason), nextEvent());
+  public void assertClose(int code, String reason) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Close(code, reason), actual);
   }
 
   public void assertFailure(Class<? extends IOException> cls, String message) {
@@ -68,14 +68,16 @@ public final class WebSocketProtocol {
   static final int OPCODE_CONTROL_PONG = 0xa;
 
   /**
-   * Maximum length of frame payload. Larger payloads, if supported, can use the special values
-   * {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
+   * Maximum length of frame payload. Larger payloads, if supported by the frame type, can use the
+   * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
-  static final int PAYLOAD_MAX = 125;
+  static final long PAYLOAD_BYTE_MAX = 125L;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
    */
   static final int PAYLOAD_SHORT = 126;
+  /** Maximum length of a frame payload to be denoted as {@link #PAYLOAD_SHORT}. */
+  static final long PAYLOAD_SHORT_MAX = 0xffffL;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
    * length.
@@ -42,7 +42,7 @@
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static java.lang.Integer.toHexString;
@@ -147,8 +147,8 @@ private void readHeader() throws IOException {
     }
     frameBytesRead = 0;
 
-    if (isControlFrame && frameLength > PAYLOAD_MAX) {
-      throw new ProtocolException(""Control frame must be less than "" + PAYLOAD_MAX + ""B."");
+    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
+      throw new ProtocolException(""Control frame must be less than "" + PAYLOAD_BYTE_MAX + ""B."");
     }
 
     if (isMasked) {
@@ -30,8 +30,9 @@
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 
 /**
@@ -44,13 +45,16 @@
  */
 public final class WebSocketWriter {
   private final boolean isClient;
-  /** Writes must be guarded by synchronizing on this instance! */
-  private final BufferedSink sink;
   private final Random random;
 
+  /** Writes must be guarded by synchronizing on 'this'. */
+  private final BufferedSink sink;
+  /** Access must be guarded by synchronizing on 'this'. */
+  private boolean writerClosed;
+
+  private final Buffer buffer = new Buffer();
   private final FrameSink frameSink = new FrameSink();
 
-  private boolean closed;
   private boolean activeWriter;
 
   private final byte[] maskKey;
@@ -70,15 +74,15 @@ public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
 
   /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
   public void writePing(Buffer payload) throws IOException {
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_PING, payload);
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
     }
   }
 
   /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
   public void writePong(Buffer payload) throws IOException {
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_PONG, payload);
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
     }
   }
 
@@ -103,21 +107,23 @@ public void writeClose(int code, String reason) throws IOException {
       }
     }
 
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
-      closed = true;
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
+      writerClosed = true;
     }
   }
 
-  private void writeControlFrame(int opcode, Buffer payload) throws IOException {
-    if (closed) throw new IOException(""closed"");
+  private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IOException {
+    assert Thread.holdsLock(this);
+
+    if (writerClosed) throw new IOException(""closed"");
 
     int length = 0;
     if (payload != null) {
       length = (int) payload.size();
-      if (length > PAYLOAD_MAX) {
+      if (length > PAYLOAD_BYTE_MAX) {
         throw new IllegalArgumentException(
-            ""Payload size must be less than or equal to "" + PAYLOAD_MAX);
+            ""Payload size must be less than or equal to "" + PAYLOAD_BYTE_MAX);
       }
     }
 
@@ -133,7 +139,7 @@ private void writeControlFrame(int opcode, Buffer payload) throws IOException {
       sink.write(maskKey);
 
       if (payload != null) {
-        writeAllMasked(payload, length);
+        writeMaskedSynchronized(payload, length);
       }
     } else {
       sink.writeByte(b1);
@@ -143,7 +149,7 @@ private void writeControlFrame(int opcode, Buffer payload) throws IOException {
       }
     }
 
-    sink.flush();
+    sink.emit();
   }
 
   /**
@@ -156,54 +162,57 @@ public Sink newMessageSink(int formatOpcode) {
     }
     activeWriter = true;
 
+    // Reset FrameSink state for a new writer.
     frameSink.formatOpcode = formatOpcode;
     frameSink.isFirstFrame = true;
+    frameSink.closed = false;
+
     return frameSink;
   }
 
-  private void writeFrame(int formatOpcode, Buffer source, long byteCount,
-      boolean isFirstFrame, boolean isFinal) throws IOException {
-    if (closed) throw new IOException(""closed"");
-
-    int opcode = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
+  private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+      boolean isFinal) throws IOException {
+    assert Thread.holdsLock(this);
 
-    synchronized (sink) {
-      int b0 = opcode;
-      if (isFinal) {
-        b0 |= B0_FLAG_FIN;
-      }
-      sink.writeByte(b0);
+    if (writerClosed) throw new IOException(""closed"");
 
-      int b1 = 0;
-      if (isClient) {
-        b1 |= B1_FLAG_MASK;
-        random.nextBytes(maskKey);
-      }
-      if (byteCount <= PAYLOAD_MAX) {
-        b1 |= (int) byteCount;
-        sink.writeByte(b1);
-      } else if (byteCount <= 0xffffL) { // Unsigned short.
-        b1 |= PAYLOAD_SHORT;
-        sink.writeByte(b1);
-        sink.writeShort((int) byteCount);
-      } else {
-        b1 |= PAYLOAD_LONG;
-        sink.writeByte(b1);
-        sink.writeLong(byteCount);
-      }
+    int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
+    if (isFinal) {
+      b0 |= B0_FLAG_FIN;
+    }
+    sink.writeByte(b0);
 
-      if (isClient) {
-        sink.write(maskKey);
-        writeAllMasked(source, byteCount);
-      } else {
-        sink.write(source, byteCount);
-      }
+    int b1 = 0;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      random.nextBytes(maskKey);
+    }
+    if (byteCount <= PAYLOAD_BYTE_MAX) {
+      b1 |= (int) byteCount;
+      sink.writeByte(b1);
+    } else if (byteCount <= PAYLOAD_SHORT_MAX) {
+      b1 |= PAYLOAD_SHORT;
+      sink.writeByte(b1);
+      sink.writeShort((int) byteCount);
+    } else {
+      b1 |= PAYLOAD_LONG;
+      sink.writeByte(b1);
+      sink.writeLong(byteCount);
+    }
 
-      sink.flush();
+    if (isClient) {
+      sink.write(maskKey);
+      writeMaskedSynchronized(buffer, byteCount);
+    } else {
+      sink.write(buffer, byteCount);
     }
+
+    sink.emit();
   }
 
-  private void writeAllMasked(BufferedSource source, long byteCount) throws IOException {
+  private void writeMaskedSynchronized(BufferedSource source, long byteCount) throws IOException {
+    assert Thread.holdsLock(this);
+
     long written = 0;
     while (written < byteCount) {
       int toRead = (int) Math.min(byteCount, maskBuffer.length);
@@ -218,18 +227,29 @@ private void writeAllMasked(BufferedSource source, long byteCount) throws IOExce
   private final class FrameSink implements Sink {
     private int formatOpcode;
     private boolean isFirstFrame;
+    private boolean closed;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
-      writeFrame(formatOpcode, source, byteCount, isFirstFrame, false /* final */);
-      isFirstFrame = false;
+      if (closed) throw new IOException(""closed"");
+
+      buffer.write(source, byteCount);
+
+      long emitCount = buffer.completeSegmentByteCount();
+      if (emitCount > 0) {
+        synchronized (WebSocketWriter.this) {
+          writeMessageFrameSynchronized(formatOpcode, emitCount, isFirstFrame, false /* final */);
+        }
+        isFirstFrame = false;
+      }
     }
 
     @Override public void flush() throws IOException {
       if (closed) throw new IOException(""closed"");
 
-      synchronized (sink) {
-        sink.flush();
+      synchronized (WebSocketWriter.this) {
+        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
       }
+      isFirstFrame = false;
     }
 
     @Override public Timeout timeout() {
@@ -240,21 +260,10 @@ private final class FrameSink implements Sink {
     @Override public void close() throws IOException {
       if (closed) throw new IOException(""closed"");
 
-      int length = 0;
-
-      synchronized (sink) {
-        sink.writeByte(B0_FLAG_FIN | OPCODE_CONTINUATION);
-
-        if (isClient) {
-          sink.writeByte(B1_FLAG_MASK | length);
-          random.nextBytes(maskKey);
-          sink.write(maskKey);
-        } else {
-          sink.writeByte(length);
-        }
-        sink.flush();
+      synchronized (WebSocketWriter.this) {
+        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
       }
-
+      closed = true;
       activeWriter = false;
     }
   }
@@ -17,10 +17,6 @@
 import static com.squareup.okhttp.ws.WebSocket.BINARY;
 import static com.squareup.okhttp.ws.WebSocket.TEXT;
 
-/**
- * NOTE: This is currently broken because the Echo server does not correctly echo empty frames
- * which OkHttp uses for final frames on streamed messages.
- */
 public final class WebSocketEcho implements WebSocketListener {
   private final Executor writeExecutor = Executors.newSingleThreadExecutor();
 
",True,The commit message refers to the necessity of changes by mentioning the elimination of the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. This is done to improve efficiency and reduce unnecessary data transmission.,True,"The commit message 'Introduce intermediate storage for frame contents' describes the necessity of changes by explaining that it eliminates the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. This is done to optimize the sending of bytes once Okio reports complete segments. This explanation clearly communicates the reason for the changes, making it unnecessary to infer the rationale from the code diff.",True,The commit message explains the motivation for the changes by mentioning that it eliminates the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. This is done to optimize the performance and reduce unnecessary data transmission.,True,"The commit message indicates that the changes were made to eliminate the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. This was done to optimize the process and reduce unnecessary data transmission. This suggests that the changes were made to improve the efficiency and performance of the software, which can be considered a necessity for software development.",True,"The commit message mentions the change will introduce intermediate storage for frame contents, which is done to eliminate the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. This improves the code by optimizing the sending of frames and reducing unnecessary operations.",True,"The commit message 'Introduce intermediate storage for frame contents' effectively summarizes the changes made in the code diff. It highlights the addition of intermediate storage to eliminate the need for sending a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. This change is also mentioned in the code diff, where the code for sending a frame for every write and an empty frame for close has been removed, and the new intermediate storage has been introduced.",True,"The commit message explains that the changes are made to introduce an intermediate storage for frame contents. This is done to eliminate the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. This is a technical principle that optimizes the sending of data by only emitting bytes once Okio reports complete segments, which can improve performance and efficiency.",True,"The commit message expresses the introduction of an intermediate storage for frame contents. This change eliminates the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. Instead, bytes are only emitted once Okio reports complete segments. This change improves efficiency and reduces unnecessary data transmission.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'This eliminates the need to always send a frame for every FrameSink#write and to always send an empty frame for FrameSink#close. Now, we only emit bytes once Okio reports complete segments.' This change is not trivial and the reason for it is not immediately obvious from the code diff."
https://github.com/square/okhttp/commit/ba5d3e278b027ee7a2cb741a1bec3646f9d11e16,Migrate from Travis to GitHub Action for publishing ,https://api.github.com/repos/square/okhttp/commits/ba5d3e278b027ee7a2cb741a1bec3646f9d11e16,"@@ -1,26 +0,0 @@
-#!/bin/bash
-#
-# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
-#
-# Adapted from https://coderwall.com/p/9b_lfq and
-# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
-
-SLUG=""square/okhttp""
-JDK=""openjdk11""
-BRANCH=""master""
-
-set -e
-
-if [ ""$TRAVIS_REPO_SLUG"" != ""$SLUG"" ]; then
-  echo ""Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'.""
-elif [ ""$TRAVIS_JDK_VERSION"" != ""$JDK"" ]; then
-  echo ""Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'.""
-elif [ ""$TRAVIS_PULL_REQUEST"" != ""false"" ]; then
-  echo ""Skipping snapshot deployment: was pull request.""
-elif [ ""$TRAVIS_BRANCH"" != ""$BRANCH"" ]; then
-  echo ""Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.""
-else
-  echo ""Deploying snapshot...""
-  ./gradlew clean uploadArchives
-  echo ""Snapshot deployed!""
-fi
@@ -0,0 +1,29 @@
+name: build
+
+on: [push, pull_request]
+
+env:
+  GRADLE_OPTS: ""-Dorg.gradle.jvmargs=-Xmx4g -Dorg.gradle.daemon=false -Dkotlin.incremental=false""
+
+jobs:
+  publish:
+    runs-on: ubuntu-latest
+    if: github.ref == 'refs/heads/master'
+
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v2
+
+      - name: Validate Gradle Wrapper
+        uses: gradle/wrapper-validation-action@v1
+
+      - name: Configure JDK
+        uses: actions/setup-java@v1
+        with:
+          java-version: 11
+
+      - name: Upload Artifacts
+        run: ./gradlew uploadArchives
+        env:
+          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_USERNAME: ${{ secrets.SONATYPE_NEXUS_USERNAME }}
+          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_PASSWORD: ${{ secrets.SONATYPE_NEXUS_PASSWORD }}
@@ -1,35 +0,0 @@
-language: java
-
-dist: trusty
-
-jdk:
-  - openjdk11
-
-script:
-  - ./gradlew jar --parallel
-
-after_success:
-  - .buildscript/deploy_snapshot.sh
-
-env:
-  global:
-    - secure: ""fELrorBJHDz+Xk9iSVMnamu0qC0+pYnFvjnEIcGnmKMMxLI/CIMACghIfSkqZhKAcU3hvxgWzyY8JBMnf5tykUjjOwmubAjZ9qIvwujtrUoUitUkpvVaPtqF0d1Yx0Xq4qt3NB9cOugPR/cPGnoEvSKfND3g+o5ta7KzdjwMBCY=""
-    - secure: ""WMkcWrsvzJNf48w7DJwipUNbhAoggCkC+NM31esq9/GDceGtVWj4hssQETynG4+ckxr0wGqUxsTRTz0uGhX6Fi58haG8yKp+g/HVClqI5EYjI44ptPcwlqlbYjuGbk65k1OGGZLctA6fQA3uT0zee05/yBjJx/jOqrN+PD1tW38=""
-
-branches:
-  only:
-    - master
-
-notifications:
-  email: false
-
-sudo: false
-
-before_cache:
-  - rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
-  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
-
-cache:
-  directories:
-    - $HOME/.gradle/caches/
-    - $HOME/.gradle/wrapper/
",True,"The commit message refers to the necessity of changes by mentioning the migration from Travis to GitHub Action for publishing. This is an improvement over the previous system, as GitHub Actions is a more modern and integrated solution for continuous integration and deployment.",True,"The commit message 'Migrate from Travis to GitHub Action for publishing' clearly explains the reason for the changes. It is not common sense or easy to infer that the change is necessary because the project was previously using Travis for continuous integration and deployment, and it is now migrating to GitHub Actions. This is a significant change that requires explanation in the commit message.",True,"The commit message 'Migrate from Travis to GitHub Action for publishing' does describe the necessity of changes. It explains that the change is being made to migrate from Travis to GitHub Action for publishing, which could potentially improve the efficiency and functionality of the publishing process.",True,"The commit message 'Migrate from Travis to GitHub Action for publishing' indicates that the developer is making a change due to a need for software development. Specifically, the change is being made to improve the development environment by migrating from Travis to GitHub Actions. This is a common practice to take advantage of new features or tools that can streamline the development process.",True,"The commit message 'Migrate from Travis to GitHub Action for publishing' directly mentions the change that is being made to the codebase, which is migrating the continuous integration (CI) tool from Travis to GitHub Actions. This change is likely to improve the efficiency and functionality of the publishing process.",True,The commit message 'Migrate from Travis to GitHub Action for publishing' accurately summarizes the changes made in the diff. It clearly states that the commit involves migrating the publishing process from Travis to GitHub Actions. The diff supports this by removing the Travis configuration and adding a GitHub Actions configuration for publishing.,True,The commit message 'Migrate from Travis to GitHub Action for publishing' indicates that the technical principle underpinning the changes is the use of continuous integration and continuous delivery (CI/CD) tools. The diff shows that the project is moving from using Travis CI to GitHub Actions for automating the publishing process. This change is likely to improve the efficiency and reliability of the software delivery pipeline.,True,"The commit message 'Migrate from Travis to GitHub Action for publishing' accurately describes the functional change in the code. The code diff shows that the project is moving from using Travis CI for continuous integration and deployment to GitHub Actions. This change introduces new behaviors such as the use of GitHub Actions for building and publishing the project, and the use of environment variables for securely storing credentials.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Migrate from Travis to GitHub Action for publishing'. This change is not trivial as it involves a significant modification to the continuous integration/continuous deployment (CI/CD) pipeline. The diff shows the removal of the entire Travis CI configuration and the addition of a GitHub Actions configuration. This change is not just a simple modification like removing a space, but rather a significant change in the project's infrastructure."
https://github.com/square/okhttp/commit/fd509b937c4a5438fe02ddf06ade5ad56736af5d,Inject a leading . for better matching under JavaNetCookieJar  <enter> Closes :  <issue_link> ,https://api.github.com/repos/square/okhttp/commits/fd509b937c4a5438fe02ddf06ade5ad56736af5d,"@@ -23,6 +23,7 @@
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.URI;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -271,6 +272,58 @@ public void testNetscapeResponse() throws Exception {
     assertNull(request.getHeader(""Quux""));
   }
 
+  @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse(""https://www.squareup.com/"");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, ""a=android; Domain=squareup.com"")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals(""a"", actualCookies.get(0).name());
+    assertEquals(""android"", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse(""https://www.squareup.com/"");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, ""a=android; Domain=.squareup.com"")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals(""a"", actualCookies.get(0).name());
+    assertEquals(""android"", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesExactly() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse(""https://squareup.com/"");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, ""a=android; Domain=squareup.com"")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals(""a"", actualCookies.get(0).name());
+    assertEquals(""android"", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url1 = HttpUrl.parse(""https://api.squareup.com/"");
+    cookieJar.saveFromResponse(url1, Arrays.asList(
+        Cookie.parse(url1, ""a=android; Domain=api.squareup.com"")));
+
+    HttpUrl url2 = HttpUrl.parse(""https://www.squareup.com/"");
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
+    assertEquals(Collections.<Cookie>emptyList(), actualCookies);
+  }
+
   private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
     return server.url(path)
         .newBuilder()
@@ -40,7 +40,7 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
     if (cookieHandler != null) {
       List<String> cookieStrings = new ArrayList<>();
       for (Cookie cookie : cookies) {
-        cookieStrings.add(cookie.toString());
+        cookieStrings.add(cookie.toString(true));
       }
       Map<String, List<String>> multimap = Collections.singletonMap(""Set-Cookie"", cookieStrings);
       try {
@@ -530,6 +530,15 @@ public Cookie build() {
   }
 
   @Override public String toString() {
+    return toString(false);
+  }
+
+  /**
+   * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is
+   *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This
+   *     extra dot is ignored by more recent specifications.
+   */
+  String toString(boolean forObsoleteRfc2965) {
     StringBuilder result = new StringBuilder();
     result.append(name);
     result.append('=');
@@ -544,7 +553,11 @@ public Cookie build() {
     }
 
     if (!hostOnly) {
-      result.append(""; domain="").append(domain);
+      result.append(""; domain="");
+      if (forObsoleteRfc2965) {
+        result.append(""."");
+      }
+      result.append(domain);
     }
 
     result.append(""; path="").append(path);
",True,"The commit message refers to the necessity of changes by mentioning 'JavaNetCookieJar' and the addition of a leading dot for better matching. This is likely a reference to a convention or standard in the context of handling cookies in Java, where the leading dot is used to match subdomains.",True,"The commit message 'Inject a leading . for better matching under JavaNetCookieJar' describes the necessity of the changes by explaining that the change is needed for better matching under JavaNetCookieJar. This is not a common sense or easy to infer change, as it involves modifying the code to handle a specific behavior of JavaNetCookieJar.",True,"The commit message 'Inject a leading . for better matching under JavaNetCookieJar' directly elaborates the motivation of the code change. It mentions the issue of better matching under JavaNetCookieJar, which is likely a problem that could arise if the leading dot was not included in the domain pattern. This is especially clear in the added test cases, where the behavior of the cookie jar is tested with and without the leading dot in the domain pattern.",True,"The commit message 'Inject a leading . for better matching under JavaNetCookieJar' indicates that the developer made changes to improve the matching of cookies under JavaNetCookieJar. This could be due to a problem in the process of software maintenance, such as outdated code that didn't handle certain cases correctly, causing issues with cookie matching. The code diff also supports this interpretation, as it shows the addition of several tests that check the behavior of the cookie matching under different scenarios, including one that specifically mentions 'RFC 2965 dot', which is a known issue in cookie handling.",True,"The commit message 'Inject a leading . for better matching under JavaNetCookieJar' directly mentions the improvement it makes to the code, which is to better match cookies under JavaNetCookieJar by injecting a leading dot in the domain pattern. This is specifically mentioned in the code diff where the toString method in the Cookie class is modified to include a leading dot for RFC 2965 compatibility.",True,"The commit message 'Inject a leading . for better matching under JavaNetCookieJar' accurately summarizes the changes made in the diff. Specifically, it highlights the addition of a leading dot in the domain pattern of the cookie, which is necessary for better matching under JavaNetCookieJar. This change is reflected in the diff where the toString method of the Cookie class is modified to include a leading dot when the forObsoleteRfc2965 parameter is true.",True,"The commit message explains that a leading dot is injected for better matching under JavaNetCookieJar. This is based on the code diff where a leading dot is added in the toString() method of the Cookie class, which is used in the JavaNetCookieJar class. This is a technical principle that allows for more flexible domain matching, particularly under the obsolete RFC 2965.",True,"The commit message 'Inject a leading . for better matching under JavaNetCookieJar' accurately describes the functional change in the code. The change is to modify the 'toString' method of the 'Cookie' class to include a leading '.' in the domain pattern when the 'forObsoleteRfc2965' parameter is true. This is done to ensure that 'example.com' matches 'www.example.com' under RFC 2965, which is the behavior being introduced by this change.",False,"The commit message does not lack an explanation. It mentions 'Inject a leading . for better matching under JavaNetCookieJar' which explains the reason for the change. The change is not just a simple removal of a space, but rather an addition of a leading dot in the domain of the cookies for better matching under JavaNetCookieJar. This is a significant change that requires an explanation in the commit message."
https://github.com/junit-team/junit4/commit/078e45bd31a9920e00633ad6ce658e22529304f2,Brought in old JUnit4ClassRunner for compatibility. Renamed new JUnit4ClassRunner to BlockJUnit4ClassRunner. ,https://api.github.com/repos/junit-team/junit4/commits/078e45bd31a9920e00633ad6ce658e22529304f2,"@@ -16,11 +16,11 @@
 import org.junit.experimental.theories.internal.ParameterizedAssertionError;
 import org.junit.internal.AssumptionViolatedException;
 import org.junit.internal.runners.InitializationError;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.internal.runners.links.Statement;
 import org.junit.internal.runners.model.FrameworkMethod;
 
-public class Theories extends JUnit4ClassRunner {
+public class Theories extends BlockJUnit4ClassRunner {
 	public Theories(Class<?> klass) throws InitializationError {
 		super(klass);
 	}
@@ -91,7 +91,7 @@ protected void runWithIncompleteAssignment(Assignments incomplete)
 		protected void runWithCompleteAssignment(final Assignments complete)
 				throws InstantiationException, IllegalAccessException,
 				InvocationTargetException, NoSuchMethodException, Throwable {
-			new JUnit4ClassRunner(getTestClass()) {
+			new BlockJUnit4ClassRunner(getTestClass()) {
 				@Override
 				protected void collectInitializationErrors(
 						List<Throwable> errors) {
@@ -3,13 +3,13 @@
  */
 package org.junit.internal.builders;
 
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.runner.Runner;
 import org.junit.runners.RunnerBuilder;
 
 public class JUnit4Builder extends RunnerBuilder {
 	@Override
 	public Runner runnerForClass(Class<?> testClass) throws Throwable {
-		return new JUnit4ClassRunner(testClass);
+		return new BlockJUnit4ClassRunner(testClass);
 	}
 }
\ No newline at end of file
@@ -0,0 +1,80 @@
+package org.junit.internal.deprecated;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.runner.Description;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunNotifier;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public
+class ClassRoadie {
+	private RunNotifier fNotifier;
+	private TestClass fTestClass;
+	private Description fDescription;
+	private final Runnable fRunnable;
+	
+	public ClassRoadie(RunNotifier notifier, TestClass testClass,
+			Description description, Runnable runnable) {
+		fNotifier= notifier;
+		fTestClass= testClass;
+		fDescription= description;
+		fRunnable= runnable;
+	}
+
+	protected void runUnprotected() {
+		fRunnable.run();
+	};
+
+	protected void addFailure(Throwable targetException) {
+		fNotifier.fireTestFailure(new Failure(fDescription, targetException));
+	}
+
+	public void runProtected() {
+		try {
+			runBefores();
+			runUnprotected();
+		} catch (FailedBefore e) {
+		} finally {
+			runAfters();
+		}
+	}
+
+	private void runBefores() throws FailedBefore {
+		try {
+			try {
+				List<Method> befores= fTestClass.getBefores();
+				for (Method before : befores)
+					before.invoke(null);
+			} catch (InvocationTargetException e) {
+				throw e.getTargetException();
+			}
+		} catch (org.junit.internal.AssumptionViolatedException e) {
+			throw new FailedBefore();
+		} catch (Throwable e) {
+			addFailure(e);
+			throw new FailedBefore();
+		}
+	}
+
+	private void runAfters() {
+		List<Method> afters= fTestClass.getAfters();
+		for (Method after : afters)
+			try {
+				after.invoke(null);
+			} catch (InvocationTargetException e) {
+				addFailure(e.getTargetException());
+			} catch (Throwable e) {
+				addFailure(e); // Untested, but seems impossible
+			}
+	}
+}
\ No newline at end of file
@@ -0,0 +1,14 @@
+package org.junit.internal.deprecated;
+
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+class FailedBefore extends Exception {
+	private static final long serialVersionUID= 1L;
+}
\ No newline at end of file
@@ -0,0 +1,158 @@
+package org.junit.internal.deprecated;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import org.junit.internal.AssumptionViolatedException;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.runner.Description;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunNotifier;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class MethodRoadie {
+	private final Object fTest;
+	private final RunNotifier fNotifier;
+	private final Description fDescription;
+	private TestMethod fTestMethod;
+
+	public MethodRoadie(Object test, TestMethod method, RunNotifier notifier, Description description) {
+		fTest= test;
+		fNotifier= notifier;
+		fDescription= description;
+		fTestMethod= method;
+	}
+
+	public void run() {
+		if (fTestMethod.isIgnored()) {
+			fNotifier.fireTestIgnored(fDescription);
+			return;
+		}
+		fNotifier.fireTestStarted(fDescription);
+		try {
+			long timeout= fTestMethod.getTimeout();
+			if (timeout > 0)
+				runWithTimeout(timeout);
+			else
+				runTest();
+		} finally {
+			fNotifier.fireTestFinished(fDescription);
+		}
+	}
+
+	private void runWithTimeout(final long timeout) {
+		runBeforesThenTestThenAfters(new Runnable() {
+		
+			public void run() {
+				ExecutorService service= Executors.newSingleThreadExecutor();
+				Callable<Object> callable= new Callable<Object>() {
+					public Object call() throws Exception {
+						runTestMethod();
+						return null;
+					}
+				};
+				Future<Object> result= service.submit(callable);
+				service.shutdown();
+				try {
+					boolean terminated= service.awaitTermination(timeout,
+							TimeUnit.MILLISECONDS);
+					if (!terminated)
+						service.shutdownNow();
+					result.get(0, TimeUnit.MILLISECONDS); // throws the exception if one occurred during the invocation
+				} catch (TimeoutException e) {
+					addFailure(new Exception(String.format(""test timed out after %d milliseconds"", timeout)));
+				} catch (Exception e) {
+					addFailure(e);
+				}				
+			}
+		});
+	}
+	
+	public void runTest() {
+		runBeforesThenTestThenAfters(new Runnable() {
+			public void run() {
+				runTestMethod();
+			}
+		});
+	}
+
+	public void runBeforesThenTestThenAfters(Runnable test) {
+		try {
+			runBefores();
+			test.run();
+		} catch (FailedBefore e) {
+		} catch (Exception e) {
+			throw new RuntimeException(""test should never throw an exception to this level"");
+		} finally {
+			runAfters();
+		}		
+	}
+	
+	protected void runTestMethod() {
+		try {
+			fTestMethod.invoke(fTest);
+			if (fTestMethod.expectsException())
+				addFailure(new AssertionError(""Expected exception: "" + fTestMethod.getExpectedException().getName()));
+		} catch (InvocationTargetException e) {
+			Throwable actual= e.getTargetException();
+			if (actual instanceof AssumptionViolatedException)
+				return;
+			else if (!fTestMethod.expectsException())
+				addFailure(actual);
+			else if (fTestMethod.isUnexpected(actual)) {
+				String message= ""Unexpected exception, expected<"" + fTestMethod.getExpectedException().getName() + ""> but was<""
+					+ actual.getClass().getName() + "">"";
+				addFailure(new Exception(message, actual));
+			}
+		} catch (Throwable e) {
+			addFailure(e);
+		}
+	}
+	
+	private void runBefores() throws FailedBefore {
+		try {
+			try {
+				List<Method> befores= fTestMethod.getBefores();
+				for (Method before : befores)
+					before.invoke(fTest);
+			} catch (InvocationTargetException e) {
+				throw e.getTargetException();
+			}
+		} catch (AssumptionViolatedException e) {
+			throw new FailedBefore();
+		} catch (Throwable e) {
+			addFailure(e);
+			throw new FailedBefore();
+		}
+	}
+
+	private void runAfters() {
+		List<Method> afters= fTestMethod.getAfters();
+		for (Method after : afters)
+			try {
+				after.invoke(fTest);
+			} catch (InvocationTargetException e) {
+				addFailure(e.getTargetException());
+			} catch (Throwable e) {
+				addFailure(e); // Untested, but seems impossible
+			}
+	}
+
+	protected void addFailure(Throwable e) {
+		fNotifier.fireTestFailure(new Failure(fDescription, e));
+	}
+}
+
@@ -0,0 +1,93 @@
+package org.junit.internal.deprecated;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.InitializationError;
+import org.junit.internal.runners.JUnit4ClassRunner;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class MethodValidator {
+
+	private final List<Throwable> fErrors= new ArrayList<Throwable>();
+
+	private TestClass fTestClass;
+
+	public MethodValidator(TestClass testClass) {
+		fTestClass = testClass;
+	}
+
+	public void validateInstanceMethods() {
+		validateTestMethods(After.class, false);
+		validateTestMethods(Before.class, false);
+		validateTestMethods(Test.class, false);
+		
+		List<Method> methods= fTestClass.getAnnotatedMethods(Test.class);
+		if (methods.size() == 0)
+			fErrors.add(new Exception(""No runnable methods""));
+	}
+
+	public void validateStaticMethods() {
+		validateTestMethods(BeforeClass.class, true);
+		validateTestMethods(AfterClass.class, true);
+	}
+	
+	public List<Throwable> validateMethodsForDefaultRunner() {
+		validateNoArgConstructor();
+		validateStaticMethods();
+		validateInstanceMethods();
+		return fErrors;
+	}
+	
+	public void assertValid() throws InitializationError {
+		if (!fErrors.isEmpty())
+			throw new InitializationError(fErrors);
+	}
+
+	public void validateNoArgConstructor() {
+		try {
+			fTestClass.getConstructor();
+		} catch (Exception e) {
+			fErrors.add(new Exception(""Test class should have public zero-argument constructor"", e));
+		}
+	}
+
+	private void validateTestMethods(Class<? extends Annotation> annotation,
+			boolean isStatic) {
+		List<Method> methods= fTestClass.getAnnotatedMethods(annotation);
+		
+		for (Method each : methods) {
+			if (Modifier.isStatic(each.getModifiers()) != isStatic) {
+				String state= isStatic ? ""should"" : ""should not"";
+				fErrors.add(new Exception(""Method "" + each.getName() + ""() ""
+						+ state + "" be static""));
+			}
+			if (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))
+				fErrors.add(new Exception(""Class "" + each.getDeclaringClass().getName()
+						+ "" should be public""));
+			if (!Modifier.isPublic(each.getModifiers()))
+				fErrors.add(new Exception(""Method "" + each.getName()
+						+ "" should be public""));
+			if (each.getReturnType() != Void.TYPE)
+				fErrors.add(new Exception(""Method "" + each.getName()
+						+ "" should be void""));
+			if (each.getParameterTypes().length != 0)
+				fErrors.add(new Exception(""Method "" + each.getName()
+						+ "" should have no parameters""));
+		}
+	}
+}
@@ -0,0 +1,103 @@
+package org.junit.internal.deprecated;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class TestClass {
+	private final Class<?> fClass;
+	
+	public TestClass(Class<?> klass) {
+		fClass= klass;
+	}
+
+	public List<Method> getTestMethods() {
+		return getAnnotatedMethods(Test.class);
+	}
+
+	List<Method> getBefores() {
+		return getAnnotatedMethods(BeforeClass.class);
+	}
+
+	List<Method> getAfters() {
+		return getAnnotatedMethods(AfterClass.class);
+	}
+	
+	public List<Method> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {
+		List<Method> results= new ArrayList<Method>();
+		for (Class<?> eachClass : getSuperClasses(fClass)) {
+			Method[] methods= eachClass.getDeclaredMethods();
+			for (Method eachMethod : methods) {
+				Annotation annotation= eachMethod.getAnnotation(annotationClass);
+				if (annotation != null && ! isShadowed(eachMethod, results)) 
+					results.add(eachMethod);
+			}
+		}
+		if (runsTopToBottom(annotationClass))
+			Collections.reverse(results);
+		return results;
+	}
+
+	private boolean runsTopToBottom(Class< ? extends Annotation> annotation) {
+		return annotation.equals(Before.class) || annotation.equals(BeforeClass.class);
+	}
+	
+	private boolean isShadowed(Method method, List<Method> results) {
+		for (Method each : results) {
+			if (isShadowed(method, each))
+				return true;
+		}
+		return false;
+	}
+
+	private boolean isShadowed(Method current, Method previous) {
+		if (! previous.getName().equals(current.getName()))
+			return false;
+		if (previous.getParameterTypes().length != current.getParameterTypes().length)
+			return false;
+		for (int i= 0; i < previous.getParameterTypes().length; i++) {
+			if (! previous.getParameterTypes()[i].equals(current.getParameterTypes()[i]))
+				return false;
+		}
+		return true;
+	}
+
+	private List<Class<?>> getSuperClasses(Class< ?> testClass) {
+		ArrayList<Class<?>> results= new ArrayList<Class<?>>();
+		Class<?> current= testClass;
+		while (current != null) {
+			results.add(current);
+			current= current.getSuperclass();
+		}
+		return results;
+	}
+
+	public Constructor<?> getConstructor() throws SecurityException, NoSuchMethodException {
+		return fClass.getConstructor();
+	}
+
+	public Class<?> getJavaClass() {
+		return fClass;
+	}
+
+	public String getName() {
+		return fClass.getName();
+	}
+
+}
@@ -0,0 +1,70 @@
+package org.junit.internal.deprecated;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.Test.None;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
+import org.junit.internal.runners.JUnit4ClassRunner;
+
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class TestMethod {
+	private final Method fMethod;
+	private TestClass fTestClass;
+
+	public TestMethod(Method method, TestClass testClass) {
+		fMethod= method;
+		fTestClass= testClass;
+	}
+
+	public boolean isIgnored() {
+		return fMethod.getAnnotation(Ignore.class) != null;
+	}
+
+	public long getTimeout() {
+		Test annotation= fMethod.getAnnotation(Test.class);
+		if (annotation == null)
+			return 0;
+		long timeout= annotation.timeout();
+		return timeout;
+	}
+
+	protected Class<? extends Throwable> getExpectedException() {
+		Test annotation= fMethod.getAnnotation(Test.class);
+		if (annotation == null || annotation.expected() == None.class)
+			return null;
+		else
+			return annotation.expected();
+	}
+
+	boolean isUnexpected(Throwable exception) {
+		return ! getExpectedException().isAssignableFrom(exception.getClass());
+	}
+
+	boolean expectsException() {
+		return getExpectedException() != null;
+	}
+
+	List<Method> getBefores() {
+		return fTestClass.getAnnotatedMethods(Before.class);
+	}
+
+	List<Method> getAfters() {
+		return fTestClass.getAnnotatedMethods(After.class);
+	}
+
+	public void invoke(Object test) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
+		fMethod.invoke(test);
+	}
+
+}
@@ -0,0 +1,140 @@
+package org.junit.internal.runners;
+
+import java.util.List;
+
+import org.junit.internal.runners.links.ExpectException;
+import org.junit.internal.runners.links.Fail;
+import org.junit.internal.runners.links.FailOnTimeout;
+import org.junit.internal.runners.links.IgnoreTestNotifier;
+import org.junit.internal.runners.links.InvokeMethod;
+import org.junit.internal.runners.links.Notifier;
+import org.junit.internal.runners.links.RunAfters;
+import org.junit.internal.runners.links.RunBefores;
+import org.junit.internal.runners.links.RunTestNotifier;
+import org.junit.internal.runners.links.Statement;
+import org.junit.internal.runners.model.EachTestNotifier;
+import org.junit.internal.runners.model.FrameworkMethod;
+import org.junit.internal.runners.model.ReflectiveCallable;
+import org.junit.internal.runners.model.TestAnnotation;
+import org.junit.internal.runners.model.TestClass;
+import org.junit.internal.runners.model.TestMethod;
+import org.junit.runner.Description;
+import org.junit.runner.manipulation.Filterable;
+import org.junit.runner.manipulation.Sortable;
+import org.junit.runner.notification.RunNotifier;
+
+public class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> implements Filterable, Sortable {
+	protected final List<FrameworkMethod> fTestMethods;
+
+	public BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {
+		this(new TestClass(klass));
+	}
+	
+	public BlockJUnit4ClassRunner(TestClass testClass) throws InitializationError {
+		super(testClass);
+		fTestMethods= computeTestMethods();
+		validate();
+	}
+	
+	//
+	// Override in subclasses
+	//
+
+	protected List<FrameworkMethod> computeTestMethods() {
+		return getTestClass().getTestMethods();
+	}
+
+	@Override
+	protected void collectInitializationErrors(List<Throwable> errors) {
+		getTestClass().validateMethodsForDefaultRunner(errors);
+	}
+
+	protected Object createTest() throws Exception {
+		return getTestClass().getConstructor().newInstance();
+	}
+
+	protected String testName(FrameworkMethod method) {
+		return method.getName();
+	}
+	
+	protected Statement childBlock(FrameworkMethod method) {
+		Object test;
+		try {
+			test= new ReflectiveCallable() {
+				@Override
+				protected Object runReflectiveCall() throws Throwable {
+					return createTest();
+				}
+			}.run();
+		} catch (Throwable e) {
+			return new Fail(e);
+		}
+
+		TestAnnotation annotation= new TestAnnotation(method);
+		
+		Statement link= invoke(method, test);
+		link= possiblyExpectingExceptions(annotation, link);
+		link= withPotentialTimeout(annotation, link);
+		link= withBefores(method, test, link);
+		link= withAfters(method, test, link);
+		return link;
+	}
+	
+	//
+	// Implementation of ParentRunner
+	// 
+	
+	@Override
+	protected void runChild(FrameworkMethod method, RunNotifier notifier) {
+		Description description= describeChild(method);
+		EachTestNotifier eachNotifier= new EachTestNotifier(notifier,
+				description);
+		notifying(method, childBlock(method)).run(eachNotifier);
+	}
+
+	@Override
+	protected Description describeChild(FrameworkMethod method) {
+		return Description.createTestDescription(getTestClass().getJavaClass(),
+				testName(method), method.getMethod().getAnnotations());
+	}
+
+	@Override
+	protected List<FrameworkMethod> getChildren() {
+		return fTestMethods;
+	}
+
+	//
+	// Statement builders
+	//
+	
+	protected Statement invoke(FrameworkMethod method, Object test) {
+		return new InvokeMethod(method, test);
+	}
+
+	protected Statement possiblyExpectingExceptions(TestAnnotation annotation,
+			Statement next) {
+		return annotation.expectsException() ? new ExpectException(next, annotation
+				.getExpectedException()) : next;
+	}
+
+	protected Statement withPotentialTimeout(TestAnnotation annotation,
+			Statement next) {
+		long timeout= annotation.getTimeout();
+		return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
+	}
+
+	protected Statement withAfters(FrameworkMethod method, Object target,
+			Statement link) {
+		return new RunAfters(link, new TestMethod(getTestClass()), target);
+	}
+
+	protected Statement withBefores(FrameworkMethod method, Object target,
+			Statement link) {
+		return new RunBefores(link, new TestMethod(getTestClass()), target);
+	}
+
+	protected Notifier notifying(FrameworkMethod method, Statement link) {
+		return method.isIgnored() ? new IgnoreTestNotifier()
+				: new RunTestNotifier(link);
+	}
+}
@@ -1,140 +1,147 @@
 package org.junit.internal.runners;
 
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
 import java.util.List;
 
-import org.junit.internal.runners.links.ExpectException;
-import org.junit.internal.runners.links.Fail;
-import org.junit.internal.runners.links.FailOnTimeout;
-import org.junit.internal.runners.links.IgnoreTestNotifier;
-import org.junit.internal.runners.links.InvokeMethod;
-import org.junit.internal.runners.links.Notifier;
-import org.junit.internal.runners.links.RunAfters;
-import org.junit.internal.runners.links.RunBefores;
-import org.junit.internal.runners.links.RunTestNotifier;
-import org.junit.internal.runners.links.Statement;
-import org.junit.internal.runners.model.EachTestNotifier;
-import org.junit.internal.runners.model.FrameworkMethod;
-import org.junit.internal.runners.model.ReflectiveCallable;
-import org.junit.internal.runners.model.TestAnnotation;
-import org.junit.internal.runners.model.TestClass;
-import org.junit.internal.runners.model.TestMethod;
+import org.junit.internal.deprecated.ClassRoadie;
+import org.junit.internal.deprecated.MethodRoadie;
+import org.junit.internal.deprecated.MethodValidator;
+import org.junit.internal.deprecated.TestClass;
+import org.junit.internal.deprecated.TestMethod;
 import org.junit.runner.Description;
+import org.junit.runner.Runner;
+import org.junit.runner.manipulation.Filter;
 import org.junit.runner.manipulation.Filterable;
+import org.junit.runner.manipulation.NoTestsRemainException;
 import org.junit.runner.manipulation.Sortable;
+import org.junit.runner.manipulation.Sorter;
+import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunNotifier;
 
-public class JUnit4ClassRunner extends ParentRunner<FrameworkMethod> implements Filterable, Sortable {
-	protected final List<FrameworkMethod> fTestMethods;
+/**
+ * @deprecated Included for backwards compatibility with JUnit 4.4. Will be
+ *             removed in the next release. Please use
+ *             {@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.
+ */
+@Deprecated
+public class JUnit4ClassRunner extends Runner implements Filterable, Sortable {
+	private final List<Method> fTestMethods;
+	private TestClass fTestClass;
 
 	public JUnit4ClassRunner(Class<?> klass) throws InitializationError {
-		this(new TestClass(klass));
+		fTestClass= new TestClass(klass);
+		fTestMethods= getTestMethods();
+		validate();
 	}
 	
-	public JUnit4ClassRunner(TestClass testClass) throws InitializationError {
-		super(testClass);
-		fTestMethods= computeTestMethods();
-		validate();
+	protected List<Method> getTestMethods() {
+		return fTestClass.getTestMethods();
 	}
 	
-	//
-	// Override in subclasses
-	//
+	protected void validate() throws InitializationError {
+		MethodValidator methodValidator= new MethodValidator(fTestClass);
+		methodValidator.validateMethodsForDefaultRunner();
+		methodValidator.assertValid();
+	}
+
+	@Override
+	public void run(final RunNotifier notifier) {
+		new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {
+			public void run() {
+				runMethods(notifier);
+			}
+		}).runProtected();
+	}
 
-	protected List<FrameworkMethod> computeTestMethods() {
-		return getTestClass().getTestMethods();
+	protected void runMethods(final RunNotifier notifier) {
+		for (Method method : fTestMethods)
+			invokeTestMethod(method, notifier);
 	}
 
 	@Override
-	protected void collectInitializationErrors(List<Throwable> errors) {
-		getTestClass().validateMethodsForDefaultRunner(errors);
+	public Description getDescription() {
+		Description spec= Description.createSuiteDescription(getName(), classAnnotations());
+		List<Method> testMethods= fTestMethods;
+		for (Method method : testMethods)
+			spec.addChild(methodDescription(method));
+		return spec;
 	}
 
-	protected Object createTest() throws Exception {
-		return getTestClass().getConstructor().newInstance();
+	protected Annotation[] classAnnotations() {
+		return fTestClass.getJavaClass().getAnnotations();
 	}
 
-	protected String testName(FrameworkMethod method) {
-		return method.getName();
+	protected String getName() {
+		return getTestClass().getName();
 	}
 	
-	protected Statement childBlock(FrameworkMethod method) {
+	protected Object createTest() throws Exception {
+		return getTestClass().getConstructor().newInstance();
+	}
+
+	protected void invokeTestMethod(Method method, RunNotifier notifier) {
+		Description description= methodDescription(method);
 		Object test;
 		try {
-			test= new ReflectiveCallable() {
-				@Override
-				protected Object runReflectiveCall() throws Throwable {
-					return createTest();
-				}
-			}.run();
-		} catch (Throwable e) {
-			return new Fail(e);
+			test= createTest();
+		} catch (InvocationTargetException e) {
+			testAborted(notifier, description, e.getCause());
+			return;			
+		} catch (Exception e) {
+			testAborted(notifier, description, e);
+			return;
 		}
-
-		TestAnnotation annotation= new TestAnnotation(method);
-		
-		Statement link= invoke(method, test);
-		link= possiblyExpectingExceptions(annotation, link);
-		link= withPotentialTimeout(annotation, link);
-		link= withBefores(method, test, link);
-		link= withAfters(method, test, link);
-		return link;
-	}
-	
-	//
-	// Implementation of ParentRunner
-	// 
-	
-	@Override
-	protected void runChild(FrameworkMethod method, RunNotifier notifier) {
-		Description description= describeChild(method);
-		EachTestNotifier eachNotifier= new EachTestNotifier(notifier,
-				description);
-		notifying(method, childBlock(method)).run(eachNotifier);
+		TestMethod testMethod= wrapMethod(method);
+		new MethodRoadie(test, testMethod, notifier, description).run();
 	}
 
-	@Override
-	protected Description describeChild(FrameworkMethod method) {
-		return Description.createTestDescription(getTestClass().getJavaClass(),
-				testName(method), method.getMethod().getAnnotations());
+	private void testAborted(RunNotifier notifier, Description description,
+			Throwable e) {
+		notifier.fireTestStarted(description);
+		notifier.fireTestFailure(new Failure(description, e));
+		notifier.fireTestFinished(description);
 	}
 
-	@Override
-	protected List<FrameworkMethod> getChildren() {
-		return fTestMethods;
+	protected TestMethod wrapMethod(Method method) {
+		return new TestMethod(method, fTestClass);
 	}
 
-	//
-	// Statement builders
-	//
-	
-	protected Statement invoke(FrameworkMethod method, Object test) {
-		return new InvokeMethod(method, test);
+	protected String testName(Method method) {
+		return method.getName();
 	}
 
-	protected Statement possiblyExpectingExceptions(TestAnnotation annotation,
-			Statement next) {
-		return annotation.expectsException() ? new ExpectException(next, annotation
-				.getExpectedException()) : next;
+	protected Description methodDescription(Method method) {
+		return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), testAnnotations(method));
 	}
 
-	protected Statement withPotentialTimeout(TestAnnotation annotation,
-			Statement next) {
-		long timeout= annotation.getTimeout();
-		return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
+	protected Annotation[] testAnnotations(Method method) {
+		return method.getAnnotations();
 	}
 
-	protected Statement withAfters(FrameworkMethod method, Object target,
-			Statement link) {
-		return new RunAfters(link, new TestMethod(getTestClass()), target);
+	public void filter(Filter filter) throws NoTestsRemainException {
+		for (Iterator<Method> iter= fTestMethods.iterator(); iter.hasNext();) {
+			Method method= iter.next();
+			if (!filter.shouldRun(methodDescription(method)))
+				iter.remove();
+		}
+		if (fTestMethods.isEmpty())
+			throw new NoTestsRemainException();
 	}
 
-	protected Statement withBefores(FrameworkMethod method, Object target,
-			Statement link) {
-		return new RunBefores(link, new TestMethod(getTestClass()), target);
+	public void sort(final Sorter sorter) {
+		Collections.sort(fTestMethods, new Comparator<Method>() {
+			public int compare(Method o1, Method o2) {
+				return sorter.compare(methodDescription(o1), methodDescription(o2));
+			}
+		});
 	}
 
-	protected Notifier notifying(FrameworkMethod method, Statement link) {
-		return method.isIgnored() ? new IgnoreTestNotifier()
-				: new RunTestNotifier(link);
+	protected TestClass getTestClass() {
+		return fTestClass;
 	}
-}
+}
\ No newline at end of file
@@ -9,7 +9,7 @@
 import java.util.List;
 
 import org.junit.internal.runners.InitializationError;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.internal.runners.links.Statement;
 import org.junit.internal.runners.model.FrameworkMethod;
 import org.junit.internal.runners.model.TestClass;
@@ -74,7 +74,7 @@ public Parameterized(Class<?> klass) throws Throwable {
 		validate();
 	}
 	
-	private static class TestClassRunnerForParameters extends JUnit4ClassRunner {
+	private static class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {
 		private final int fParameterSetNumber;
 
 		private final List<Object[]> fParameterList;
@@ -3,6 +3,6 @@
  *
  * @since 4.0
  * @see org.junit.runner.Runner
- * @see org.junit.internal.runners.JUnit4ClassRunner
+ * @see org.junit.internal.runners.BlockJUnit4ClassRunner
  */
 package org.junit.runners;
\ No newline at end of file
@@ -8,6 +8,7 @@
 import org.junit.tests.assertion.AssertionTest;
 import org.junit.tests.assertion.BothTest;
 import org.junit.tests.assertion.EachTest;
+import org.junit.tests.deprecated.JUnit4ClassRunnerTest;
 import org.junit.tests.description.AnnotatedDescriptionTest;
 import org.junit.tests.description.SuiteDescriptionTest;
 import org.junit.tests.description.TestDescriptionTest;
@@ -105,7 +106,8 @@
 	AllMembersSupplierTest.class,
 	MatcherTest.class,
 	ObjectContractTest.class,
-	TheoriesPerformanceTest.class
+	TheoriesPerformanceTest.class,
+	JUnit4ClassRunnerTest.class
 })
 public class AllTests {
 	public static Test suite() {
@@ -0,0 +1,51 @@
+package org.junit.tests.deprecated;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+import org.junit.Test;
+import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.runner.JUnitCore;
+import org.junit.runner.Result;
+import org.junit.runner.RunWith;
+
+/*
+ * This is a simple smoke test to make sure the old JUnit4ClassRunner basically works.
+ * Delete this test when JUnit4ClassRunner goes to the Great Heap In The Sky.
+ */
+public class JUnit4ClassRunnerTest {
+
+	@RunWith(JUnit4ClassRunner.class)
+	public static class Example {
+		@Test public void success() {}
+		@Test public void failure() {
+			fail();
+		}
+	}
+	
+	@Test
+	public void runWithOldJUnit4ClassRunner() {
+		Result result= JUnitCore.runClasses(Example.class);
+		assertThat(result.getRunCount(), is(2));
+		assertThat(result.getFailureCount(), is(1));
+	}
+
+	@RunWith(JUnit4ClassRunner.class)
+	public static class UnconstructableExample {
+		public UnconstructableExample() {
+			throw new UnsupportedOperationException();
+		}
+		@Test public void success() {}
+		@Test public void failure() {
+			fail();
+		}
+	}
+
+	
+	@Test
+	public void runWithOldJUnit4ClassRunnerAndBadConstructor() {
+		Result result= JUnitCore.runClasses(UnconstructableExample.class);
+		assertThat(result.getRunCount(), is(2));
+		assertThat(result.getFailureCount(), is(2));
+	}
+}
@@ -9,7 +9,7 @@
 import junit.framework.TestResult;
 import org.junit.Before;
 import org.junit.Test;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.runner.Description;
 import org.junit.runner.RunWith;
 import org.junit.runner.Runner;
@@ -91,7 +91,7 @@ public void generatedErrorTestsMatchUp() {
 		assertTrue(shouldFail == listener.getError());
 	}
 	
-	public static class InitializesWithError extends JUnit4ClassRunner {
+	public static class InitializesWithError extends BlockJUnit4ClassRunner {
 		public InitializesWithError(Class<?> klass) throws Exception {
 			super(klass);
 			throw new Exception();
@@ -14,7 +14,7 @@
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.internal.runners.InitializationError;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
@@ -85,7 +85,7 @@ public static Collection<Object[]> params() {
 	
 	private List<Throwable> validateAllMethods(Class<?> clazz) {
 		try {
-			new JUnit4ClassRunner(clazz);
+			new BlockJUnit4ClassRunner(clazz);
 		} catch (InitializationError e) {
 			return e.getCauses();
 		}
@@ -17,7 +17,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.internal.runners.InitializationError;
-import org.junit.internal.runners.JUnit4ClassRunner;
+import org.junit.internal.runners.BlockJUnit4ClassRunner;
 import org.junit.internal.runners.model.TestClass;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
@@ -88,7 +88,7 @@ static public class SubShadows extends SuperWrong {
 
 	private List<Throwable> validateAllMethods(Class<?> clazz) {
 		try {
-			new JUnit4ClassRunner(clazz);
+			new BlockJUnit4ClassRunner(clazz);
 		} catch (InitializationError e) {
 			return e.getCauses();
 		}
",True,The commit message refers to the necessity of changes by mentioning the use of old JUnit4ClassRunner for compatibility and the renaming of the new JUnit4ClassRunner to BlockJUnit4ClassRunner. This suggests that the changes are being made to maintain compatibility with older versions of JUnit and to improve the codebase.,True,"The commit message refers to the necessity of changes by mentioning the need to bring in an old JUnit4ClassRunner for compatibility. This implies that the new JUnit4ClassRunner is not compatible with the existing codebase, and the old one is needed for compatibility reasons. This is a clear indication of the necessity of the changes.",True,"The commit message explains that the old JUnit4ClassRunner is being brought in for compatibility reasons and that the new JUnit4ClassRunner has been renamed to BlockJUnit4ClassRunner. This indicates that there was a change in the codebase that required the use of the old JUnit4ClassRunner for compatibility with existing tests or code. This could be due to a deprecation or removal of the new JUnit4ClassRunner in a future release, or it could be due to a known issue with the new JUnit4ClassRunner that has been resolved in the old version.",True,"The commit message 'Brought in old JUnit4ClassRunner for compatibility. Renamed new JUnit4ClassRunner to BlockJUnit4ClassRunner.' indicates that the developer brought in the old JUnit4ClassRunner for compatibility reasons, suggesting that there might be existing code or tests that rely on the old version. This could be due to the need for software development to maintain compatibility with existing requirements or to accommodate for outdated code.",True,The commit message 'Brought in old JUnit4ClassRunner for compatibility. Renamed new JUnit4ClassRunner to BlockJUnit4ClassRunner.' directly mentions the change to maintain compatibility with older versions of JUnit by bringing back the old JUnit4ClassRunner and renaming the new one to BlockJUnit4ClassRunner.,True,The commit message 'Brought in old JUnit4ClassRunner for compatibility. Renamed new JUnit4ClassRunner to BlockJUnit4ClassRunner.' accurately describes the changes made in the code diff. The message clearly states that the old JUnit4ClassRunner is being brought in for compatibility and that the new JUnit4ClassRunner has been renamed to BlockJUnit4ClassRunner. This is reflected in the code diff where the import statements and class names have been changed accordingly.,True,"The commit message explains that the old JUnit4ClassRunner is being brought in for compatibility, and it has been renamed to BlockJUnit4ClassRunner. This suggests that the technical principle underpinning the changes is backward compatibility, as the old class name is being retained to avoid breaking existing code that depends on it.",True,"The commit message 'Brought in old JUnit4ClassRunner for compatibility. Renamed new JUnit4ClassRunner to BlockJUnit4ClassRunner.' describes the changes made in the code diff. The message explains that the old JUnit4ClassRunner is being brought in for compatibility and that the new JUnit4ClassRunner has been renamed to BlockJUnit4ClassRunner. This change is reflected in the code diff where the import statements and class names have been updated accordingly. The commit message also describes the new behavior introduced by the renaming, which is that the new BlockJUnit4ClassRunner is used instead of the old JUnit4ClassRunner.",False,"The commit message provides a clear explanation of the reason for the change, which is to bring in old JUnit4ClassRunner for compatibility and rename the new JUnit4ClassRunner to BlockJUnit4ClassRunner. The change is not just a simple renaming, but also involves bringing in a new class and modifying several other classes. Therefore, the commit message does not lack an explanation."
https://github.com/square/retrofit/commit/00d3f9070e15e514430e5dbb2aec602547c3c92d,AndroidLog: Added getTag() and logChunk() methods  for easier subclassing. ,https://api.github.com/repos/square/retrofit/commits/00d3f9070e15e514430e5dbb2aec602547c3c92d,"@@ -16,7 +16,15 @@ public AndroidLog(String tag) {
   @Override public void log(String message) {
     for (int i = 0, len = message.length(); i < len; i += LOG_CHUNK_SIZE) {
       int end = Math.min(len, i + LOG_CHUNK_SIZE);
-      Log.d(tag, message.substring(i, end));
+      logChunk(message.substring(i, end));
     }
   }
+
+  public void logChunk(String chunk) {
+    Log.d(getTag(), chunk);
+  }
+
+  public String getTag() {
+    return tag;
+  }
 }
",True,The commit message refers to the necessity of changes by mentioning 'easier subclassing'. This is because the added methods (getTag() and logChunk()) allow for easier customization and extension of the AndroidLog class in subclasses. This is a common practice in object-oriented programming to make code more flexible and reusable.,True,"The commit message 'AndroidLog: Added getTag() and logChunk() methods for easier subclassing.' does not explicitly state the reason for the changes, but it is easy to infer from the code diff that the changes are being made to facilitate easier subclassing. This is a common practice in software development, where adding methods like getTag() and logChunk() can make it easier for other developers to extend or modify the class in the future. Therefore, the commit message does not need to provide a rationale, as it is a common sense change that can be easily inferred from the code diff.",False,"The commit message does not explicitly describe the necessity of changes or the motivation behind the code change. It only states that the changes were made for easier subclassing. However, the code diff suggests that the changes were made to improve the structure and maintainability of the code, but it does not directly address any errors, shortcomings, or issue reports.",False,"The commit message 'AndroidLog: Added getTag() and logChunk() methods for easier subclassing' does not explicitly describe the necessity of changes. It does not mention any user requirements, problems in the process of software maintenance, or changes in the runtime or development environment. Instead, it describes the changes made to the code, which is adding new methods for easier subclassing.",True,"The commit message 'AndroidLog: Added getTag() and logChunk() methods for easier subclassing.' directly mentions the improvement it makes to the code, which is making it easier to subclass the AndroidLog class by adding two new methods: getTag() and logChunk().",True,"The commit message 'AndroidLog: Added getTag() and logChunk() methods for easier subclassing.' accurately summarizes the changes made in the diff. It clearly states the addition of two new methods (getTag() and logChunk()) and their purpose, which is to facilitate easier subclassing of the AndroidLog class.",True,"The commit message describes the technical principle of 'separation of concerns' and 'single responsibility'. By adding the getTag() and logChunk() methods, the class is made more modular and easier to subclass. This allows for better code organization and easier customization of the logging functionality.",True,"The commit message 'AndroidLog: Added getTag() and logChunk() methods for easier subclassing.' accurately summarizes the changes made in the code diff. It explains that two new methods, getTag() and logChunk(), have been added to the AndroidLog class. These methods make it easier to subclass the AndroidLog class, as they allow for the tag and chunk of a log message to be easily retrieved and logged. This introduces new behaviors, such as the ability to log messages in chunks and the ability to retrieve the tag of a log message.",False,"The commit message does not lack an explanation. Although the change is small and simple, the commit message explicitly states the reason for the commit: 'Added getTag() and logChunk() methods for easier subclassing.' This explains that the methods are being added to facilitate the creation of subclasses, which is not immediately obvious from the code diff."
https://github.com/square/okhttp/commit/18f3564a4f2b17c3067e7f02337e3909ba5cb3ba,Update deploy_snapshot.sh to temporarily ignore javadoc errors and compile tests but not run ( <pr_link> ) ,https://api.github.com/repos/square/okhttp/commits/18f3564a4f2b17c3067e7f02337e3909ba5cb3ba,"@@ -21,6 +21,6 @@ elif [ ""$TRAVIS_BRANCH"" != ""$BRANCH"" ]; then
   echo ""Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'.""
 else
   echo ""Deploying snapshot...""
-  mvn clean source:jar javadoc:jar deploy --settings="".buildscript/settings.xml"" -Dmaven.test.skip=true
+  mvn clean package source:jar javadoc:jar deploy --settings="".buildscript/settings.xml"" -Dmaven.javadoc.failOnError=false -DskipTests
   echo ""Snapshot deployed!""
 fi
",True,The commit message refers to the necessity of changes by mentioning that it is temporarily ignoring javadoc errors and compiling tests but not running them. This is done to address the issue of javadoc errors that were causing the snapshot deployment to fail. This change is likely an improvement over prior commits that did not handle javadoc errors or did not compile tests at all.,True,The commit message explains the necessity of changes by stating that it is temporarily ignoring javadoc errors and compiling tests but not running them. This is done to allow the snapshot deployment to proceed without being blocked by these issues. This is a common practice in software development to unblock the deployment pipeline and address non-critical issues later.,True,"The commit message explains the motivation for the code change by mentioning that it is temporarily ignoring javadoc errors and compiling tests but not running them. This is likely done to address a problem where the javadoc errors were causing the build to fail, and the tests are being skipped to save time or resources.",True,"The commit message 'Update deploy_snapshot.sh to temporarily ignore javadoc errors and compile tests but not run' indicates that the developer made changes to the script to ignore javadoc errors and compile tests. This could be due to the need to meet certain requirements, such as the need to deploy a snapshot version of the software despite the presence of javadoc errors or unpassed tests. This suggests that there might be a problem in the development or testing process that is being temporarily worked around.",True,"The commit message directly mentions the change made to the script, which is to temporarily ignore javadoc errors and compile tests but not run them. This change is an improvement to the code as it allows the script to continue executing even if there are javadoc errors or test failures, which could have previously caused the script to fail.",True,"The commit message accurately summarizes the changes made in the diff. It mentions that the script is being updated to temporarily ignore javadoc errors and to skip running tests, which is exactly what the diff shows. The message also contrasts the before and after state of the script, which adds clarity to the changes made.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly describes the changes made to the script, such as ignoring javadoc errors and skipping tests, but it does not explain why these changes were made or what principle they are based on.",True,"The commit message 'Update deploy_snapshot.sh to temporarily ignore javadoc errors and compile tests but not run' accurately summarizes the changes made in the code diff. The changes temporarily ignore javadoc errors by setting 'Dmaven.javadoc.failOnError=false' and skip the tests by adding '-DskipTests'. This means that the code will still be compiled and deployed, but any javadoc errors will be ignored and the tests will not be run. This change introduces new behavior where javadoc errors are not causing the build to fail and tests are not being executed.",False,"The commit message does not lack an explanation. Although the change is small and simple, it is not immediately clear from the diff that the commit is temporarily ignoring javadoc errors and compiling tests but not running them. The change from 'maven.test.skip=true' to 'maven.javadoc.failOnError=false -DskipTests' is not self-explanatory without the context provided in the commit message."
https://github.com/apache/dubbo/commit/793bf8244411c33b675e08f1499122bc82654d44,Defensive check to solve issue <issue_link> ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/793bf8244411c33b675e08f1499122bc82654d44,"@@ -37,6 +37,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutorService;
@@ -200,7 +201,11 @@ private boolean isProviderSide(URL url) {
 
     private List<URL> convert(List<HealthService> services) {
         return services.stream()
-                .map(s -> s.getService().getMeta().get(URL_META_KEY))
+                .map(HealthService::getService)
+                .filter(Objects::nonNull)
+                .map(HealthService.Service::getMeta)
+                .filter(m -> m != null && m.containsKey(URL_META_KEY))
+                .map(m -> m.get(URL_META_KEY))
                 .map(URL::valueOf)
                 .collect(Collectors.toList());
     }
",True,"The commit message refers to the issue it is solving, which is a good practice as it provides context for the changes. Additionally, the code diff shows that a defensive check is being added to handle the case where the getService() method might return null. This is an improvement that addresses a potential null pointer exception, which is a common source of bugs in Java code.",True,"The commit message 'Defensive check to solve issue <issue_link> ( <pr_link> )' does not explicitly explain the necessity of the changes. However, the code diff shows that a null check is being added to the 'convert' method, which is a common practice to prevent NullPointerExceptions. This is a common sense change that does not require an explicit rationale in the commit message.",True,"The commit message 'Defensive check to solve issue <issue_link> ( <pr_link> )' directly references an issue and a pull request, which suggests that the changes were made to address a specific problem. Additionally, the code diff shows that a new import statement for 'java.util.Objects' has been added, which is likely used in the defensive check to handle potential null values in the 'convert' method. This indicates that the changes were made to prevent a potential NullPointerException, which is a common error scenario.",True,"The commit message 'Defensive check to solve issue' indicates that the changes were made to address a specific issue, which is a common requirement in software development. The issue link and PR link provided in the message also suggest that the changes were made to meet the requirements of a user or to fix a problem in the software maintenance process.",True,"The commit message 'Defensive check to solve issue <issue_link>' directly mentions the issue it is fixing, which is a common practice. Additionally, the code diff shows that the change is adding a null check (importing Objects and using Objects::nonNull) to prevent potential NullPointerExceptions, which is a common way to fix issues related to defensive programming.",True,"The commit message 'Defensive check to solve issue' does describe a summary of what changes by pointing out the key component of the change, which is the addition of a defensive check in the 'convert' method. The diff shows the addition of the 'Objects' import and the use of 'Objects::nonNull' and 'm -> m.containsKey(URL_META_KEY)' to ensure that the method does not throw a NullPointerException. The message also mentions solving an issue, which could be inferred from the diff as the addition of the defensive checks.",True,"The commit message 'Defensive check to solve issue' indicates that the changes are made to handle potential null or invalid inputs. This is a common technical principle known as 'Defensive Programming', which involves checking for and handling unexpected or invalid inputs to prevent errors and ensure the program behaves as expected.",True,"The commit message 'Defensive check to solve issue' does express a summary of the changes. The code diff shows that a new import statement has been added for 'java.util.Objects', which is used in the 'convert' method to filter out null values. This change introduces a new behavior of checking for null values before accessing the 'getMeta' method, which was not present in the previous version of the code. This defensive check is likely intended to solve the issue mentioned in the commit message, adding an extra layer of safety to the code.",False,"The commit message does not lack an explanation. It explicitly mentions the issue it is solving and the defensive check it is adding. The change in the code diff is not trivial, as it involves adding a new import statement and modifying a method to handle potential null values. These changes are not straightforward and could potentially cause issues if not handled properly, which is why the commit message explicitly mentions the issue and the solution."
https://github.com/square/okhttp/commit/c8638813ff5f90715417e489b342aae5e410c5b2,Build setup tweak to work around release plugin bug.  <enter> http://jira.codehaus.org/browse/MRELEASE-812 ,https://api.github.com/repos/square/okhttp/commits/c8638813ff5f90715417e489b342aae5e410c5b2,"@@ -138,19 +138,26 @@
           <artifactId>maven-javadoc-plugin</artifactId>
           <version>2.9</version>
         </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-release-plugin</artifactId>
-          <version>2.3.2</version>
-          <configuration>
-            <autoVersionSubmodules>true</autoVersionSubmodules>
-          </configuration>
-        </plugin>
       </plugins>
     </pluginManagement>
 
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
",True,"The commit message refers to a bug in the release plugin (http://jira.codehaus.org/browse/MRELEASE-812) that is causing issues. By updating the version of the release plugin, the commit is addressing a known issue, which is a common reason for changes. This can be considered as an improvement over the prior commit, as the new version should resolve the bug.",True,The commit message 'Build setup tweak to work around release plugin bug' clearly explains the necessity of the changes. It refers to a known issue (MRELEASE-812) that is causing problems with the release plugin. The code diff shows that the version of the release plugin is being updated to a newer version (2.4.2) and a new dependency is being added to fix the issue. This is a common practice to address known bugs or issues in software.,True,The commit message directly elaborates the motivation of the code change by mentioning a bug in the release plugin (http://jira.codehaus.org/browse/MRELEASE-812) and stating that the change is a workaround to fix this bug. This clearly describes the necessity of the changes and the shortcoming of the previous implementation.,True,The commit message 'Build setup tweak to work around release plugin bug' indicates that the changes were made to address a problem in the software maintenance process. The problem is specifically mentioned as a 'release plugin bug' which is referenced in the JIRA link provided. This suggests that the changes were made to fix an issue that was causing problems during the software release process.,True,"The commit message 'Build setup tweak to work around release plugin bug' directly mentions the issue it is fixing, which is a bug in the release plugin. The code diff also supports this by showing that the version of the maven-release-plugin is being updated to a newer version, which is likely to fix the bug mentioned in the JIRA link provided in the commit message.",True,"The commit message 'Build setup tweak to work around release plugin bug' does describe a summary of the changes made in the diff. The key component of the change is the modification of the 'maven-release-plugin' version from 2.3.2 to 2.4.2. Additionally, a new dependency for 'maven-scm-provider-gitexe' has been added. This change is made to work around a known bug, which is referenced in the commit message.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions a workaround for a release plugin bug, but it does not explain why the version of the plugin or its dependency was changed.",True,"The commit message 'Build setup tweak to work around release plugin bug' does express a change in the codebase. Specifically, it mentions that the maven-release-plugin version is being updated from 2.3.2 to 2.4.2. This change is likely to address a known bug (as referenced in the JIRA link). The updated version of the plugin may introduce new behaviors or fix existing issues, but the commit message does not explicitly describe these new behaviors. However, it does provide enough context to infer that the change is likely to have an impact on the release process.",False,"The commit message does not lack an explanation. It explicitly mentions the reason for the commit: 'Build setup tweak to work around release plugin bug'. The bug is also referenced in the commit message. The code diff shows that the version of the maven-release-plugin is being updated, which is likely to fix the bug mentioned in the commit message."
https://github.com/junit-team/junit4/commit/610b38e6c9753ab01b8aef093d2fcaeabe3a7a32,Updated release notes  <enter> Signed-off-by: Kent Beck <kent@threeriversinstitute.org> ,https://api.github.com/repos/junit-team/junit4/commits/610b38e6c9753ab01b8aef093d2fcaeabe3a7a32,"@@ -6,7 +6,6 @@
   of each test method in a test class.  For example, this class will
   keep a log of each passing and failing test:
   
-	@RunWith(Interceptors.class)
 	public static class WatchmanTest {
 		private static String watchedLog;
 
@@ -38,7 +37,6 @@
 
 - The TestName Interceptor makes the current test name available inside test methods:
 
-	@RunWith(Interceptors.class)
 	public class NameInterceptorTest {
 		@Interceptor public TestName name = new TestName();
 		
@@ -53,7 +51,6 @@
 
 - The Timeout Interceptor applies the same timeout to all test methods in a class:
 
-	@RunWith(Interceptors.class)
 	public static class HasGlobalTimeout {
 		public static String log;
 		
@@ -71,7 +68,7 @@
 	}
 
 ### Timeouts ###
-- Tests that timeout now show the stack trace of the test thread.
+- Tests that time out now show the stack trace of the test thread.
 
 ### Docs ###
 - Javadocs now link to online JDK javadocs (bug 2090230)
",True,"The commit message 'Updated release notes' does not explicitly describe the necessity of changes by referencing conventions, standards, improvements in prior commits, or implemented features. However, the code diff indicates that the changes made are related to the removal of '@RunWith(Interceptors.class)' annotations from test classes. This could be interpreted as a standardization or improvement, as the removal of redundant code can simplify the structure and make the codebase more maintainable.",True,"The commit message 'Updated release notes' does not provide a clear explanation for the changes made in the code diff. The changes in the diff are removing the '@RunWith(Interceptors.class)' annotation from three test classes and modifying a sentence in the release notes about timeouts. While it's easy to infer that these changes are likely related to refactoring or updating the documentation, the commit message does not explicitly state this. Therefore, the commit message does not fully describe the necessity of the changes.",False,"The commit message 'Updated release notes' does not directly elaborate the motivation of the code change. It does not mention any error scenario, issue report, or shortcoming of the previous implementation. Instead, it simply states that the release notes have been updated. The code diff, however, shows that certain lines of code have been removed, which might indicate that these lines were no longer necessary or relevant.",True,"The commit message 'Updated release notes' does not explicitly describe the necessity of changes. However, the code diff indicates that the developer removed the '@RunWith(Interceptors.class)' annotation from multiple test classes. This could be a change made to address the outdated code issue, as the Interceptors class might no longer be necessary or supported in the current development environment.",True,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. However, the code diff indicates that the '@RunWith(Interceptors.class)' annotation has been removed from three test classes. This change could potentially simplify subclassing in the future, as it reduces the amount of boilerplate code required in each test class. Additionally, the release notes mention that tests that timeout now show the stack trace of the test thread, which could be an improvement over previous behavior. However, without more context, it's difficult to definitively say that this change was made to fix a defect.",True,"The commit message 'Updated release notes' does describe a summary of what changes by pointing out the key components of the change, which are the removal of '@RunWith(Interceptors.class)' from three test classes and the modification of a sentence in the release notes about tests that time out.",True,"The commit message describes the technical principle underpinning the changes by mentioning the removal of '@RunWith(Interceptors.class)' from test classes. This change likely improves the modularity and maintainability of the codebase by reducing the use of a specific testing framework's annotations, making the codebase more flexible and adaptable to different testing frameworks.",True,"The commit message 'Updated release notes' does contain an expression that describes a summary of what changes by explaining the code changes from a functional perspective. The code diff shows that the '@RunWith(Interceptors.class)' annotation has been removed from three test classes. This change likely means that the test classes are no longer using interceptors, which could result in new behaviors or changes in the way tests are executed. Additionally, the commit message mentions that tests that timeout now show the stack trace of the test thread, which is also a change described in the code diff. Therefore, the commit message does a good job of summarizing the changes and describing the new behavior introduced.",True,"The commit message does not explicitly explain the reason for the commit, but the change is clear from the code diff. The commit removed the '@RunWith(Interceptors.class)' line from three sections of the release notes, which suggests that the use of interceptors is no longer necessary or relevant. This could be due to a refactoring or a change in the project's requirements. However, the explanation is not explicitly stated in the commit message, but it can be inferred from the change."
https://github.com/square/okhttp/commit/0665b628fafec38271d7a66421ae04c7fd35dd29,Add support for following HTTP 307 temporary redirects.  <enter> Fixes Android bug 41739. ,https://api.github.com/repos/square/okhttp/commits/0665b628fafec38271d7a66421ae04c7fd35dd29,"@@ -60,6 +60,10 @@
  * is currently connected to a server.
  */
 public class HttpURLConnectionImpl extends HttpURLConnection {
+
+  /** Numeric status code, 307: Temporary Redirect. */
+  static final int HTTP_TEMP_REDIRECT = 307;
+
   /**
    * How many redirects should we follow? Chrome follows 21; Firefox, curl,
    * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
@@ -400,7 +404,8 @@ private Retry processResponseHeaders() throws IOException {
     Proxy selectedProxy = httpEngine.connection != null
         ? httpEngine.connection.getProxy()
         : requestedProxy;
-    switch (getResponseCode()) {
+    final int responseCode = getResponseCode();
+    switch (responseCode) {
       case HTTP_PROXY_AUTH:
         if (selectedProxy.type() != Proxy.Type.HTTP) {
           throw new ProtocolException(""Received HTTP_PROXY_AUTH (407) code while not using proxy"");
@@ -415,12 +420,18 @@ private Retry processResponseHeaders() throws IOException {
       case HTTP_MOVED_PERM:
       case HTTP_MOVED_TEMP:
       case HTTP_SEE_OTHER:
+      case HTTP_TEMP_REDIRECT:
         if (!getInstanceFollowRedirects()) {
           return Retry.NONE;
         }
         if (++redirectionCount > MAX_REDIRECTS) {
           throw new ProtocolException(""Too many redirects: "" + redirectionCount);
         }
+        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals(""GET"") && !method.equals(""HEAD"")) {
+          // ""If the 307 status code is received in response to a request other than GET or HEAD,
+          // the user agent MUST NOT automatically redirect the request""
+          return Retry.NONE;
+        }
         String location = getHeaderField(""Location"");
         if (location == null) {
           return Retry.NONE;
@@ -1731,6 +1731,70 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
     assertEquals(1, server.getRequestCount());
   }
 
+  @Test public void response307WithGet() throws Exception {
+    test307Redirect(""GET"");
+  }
+
+  @Test public void response307WithHead() throws Exception {
+    test307Redirect(""HEAD"");
+  }
+
+  @Test public void response307WithOptions() throws Exception {
+    test307Redirect(""OPTIONS"");
+  }
+
+  @Test public void response307WithPost() throws Exception {
+    test307Redirect(""POST"");
+  }
+
+  private void test307Redirect(String method) throws Exception {
+    MockResponse response1 = new MockResponse()
+        .setResponseCode(HttpURLConnectionImpl.HTTP_TEMP_REDIRECT)
+        .addHeader(""Location: /page2"");
+    if (!method.equals(""HEAD"")) {
+      response1.setBody(""This page has moved!"");
+    }
+    server.enqueue(response1);
+    server.enqueue(new MockResponse().setBody(""Page 2""));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl(""/page1""));
+    connection.setRequestMethod(method);
+    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    if (method.equals(""POST"")) {
+      connection.setDoOutput(true);
+      OutputStream outputStream = connection.getOutputStream();
+      outputStream.write(requestBody);
+      outputStream.close();
+    }
+
+    String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals(method + "" /page1 HTTP/1.1"", page1.getRequestLine());
+
+    if (method.equals(""GET"")) {
+        assertEquals(""Page 2"", response);
+    } else if (method.equals(""HEAD""))  {
+        assertTrue(response.isEmpty());
+    } else {
+      // Methods other than GET/HEAD shouldn't follow the redirect
+      if (method.equals(""POST"")) {
+        assertTrue(connection.getDoOutput());
+        assertEquals(Arrays.toString(requestBody), Arrays.toString(page1.getBody()));
+      }
+      assertEquals(1, server.getRequestCount());
+      assertEquals(""This page has moved!"", response);
+      return;
+    }
+
+    // GET/HEAD requests should have followed the redirect with the same method
+    assertFalse(connection.getDoOutput());
+    assertEquals(2, server.getRequestCount());
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals(method + "" /page2 HTTP/1.1"", page2.getRequestLine());
+  }
+
   @Test public void follow20Redirects() throws Exception {
     for (int i = 0; i < 20; i++) {
       server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
",True,"The commit message 'Add support for following HTTP 307 temporary redirects. Fixes Android bug 41739.' refers to a specific HTTP status code (307) that the commit adds support for. This is a clear reference to a standard (HTTP/1.1) and a necessary change to fix a bug (Android bug 41739). Additionally, the code diff shows that the commit adds a new constant for the HTTP_TEMP_REDIRECT status code, modifies the processResponseHeaders() method to handle this new status code, and adds new tests to ensure the functionality works as expected.",True,"The commit message 'Add support for following HTTP 307 temporary redirects. Fixes Android bug 41739.' describes the necessity of changes by stating that it adds support for a new HTTP status code (307) that requires redirection. This is not a common sense or easy to infer change, as it involves modifying the code to handle a new HTTP status code and adding tests to ensure the new functionality works correctly.",True,"The commit message 'Add support for following HTTP 307 temporary redirects. Fixes Android bug 41739.' directly mentions the issue it is fixing, which is Android bug 41739. This implies that there was a problem with the previous implementation that did not support HTTP 307 temporary redirects. Additionally, the code diff shows that the changes made include adding a new constant for the HTTP_TEMP_REDIRECT status code and modifying the processResponseHeaders() method to handle this new status code. This suggests that the changes were made to address the specific issue of not following HTTP 307 temporary redirects.",True,"The commit message 'Add support for following HTTP 307 temporary redirects. Fixes Android bug 41739.' indicates that the changes were made to address a specific issue, which is the need to support HTTP 307 temporary redirects to fix Android bug 41739. This suggests that the changes were made in response to a requirement or problem in the software maintenance process.",True,"The commit message 'Add support for following HTTP 307 temporary redirects. Fixes Android bug 41739.' directly mentions the improvement it makes to the code by adding support for HTTP 307 temporary redirects, which fixes the Android bug 41739.",True,"The commit message 'Add support for following HTTP 307 temporary redirects' accurately summarizes the changes made in the diff. It specifically mentions the addition of support for HTTP 307 temporary redirects, which is reflected in the code diff where a new constant HTTP_TEMP_REDIRECT is added, and the switch statement in the processResponseHeaders() method is updated to handle this new response code. Additionally, the commit message mentions the addition of tests for the new functionality, which is also reflected in the diff.",True,"The commit message explains that the changes are made to support HTTP 307 temporary redirects. The code diff adds a new constant HTTP_TEMP_REDIRECT with the value 307 and modifies the switch statement in the processResponseHeaders() method to handle this new status code. Additionally, the diff includes a check to ensure that only GET and HEAD requests are automatically redirected when a 307 status code is received, as per the HTTP/1.1 specification.",True,"The commit message 'Add support for following HTTP 307 temporary redirects' accurately describes the changes made in the code diff. The diff adds a new constant HTTP_TEMP_REDIRECT with the value 307, which represents the HTTP status code for temporary redirects. The code diff also includes modifications to the processResponseHeaders() method to handle the new HTTP_TEMP_REDIRECT status code. Additionally, the diff includes new test cases to verify the behavior of the HTTP 307 temporary redirects, which further confirms that the changes introduce new behaviors.",False,"The commit message does not lack an explanation. It explicitly mentions adding support for HTTP 307 temporary redirects and fixing Android bug 41739. The code diff also shows the addition of a new constant for HTTP_TEMP_REDIRECT and modifications to the processResponseHeaders method to handle this new redirect code. The commit message also includes a reference to the bug it is fixing, which provides additional context for the change."
https://github.com/square/okhttp/commit/59e68cd2bcba789e7faca70f8910afd2edeed2be,"Introduce Exchange.  <enter> This is the payoff that preceding changes have been working towards. This splits StreamAllocation into three parts: <enter>  - ExchangeFinder: strategy to allocate connections for exchanges  - Exchange: a single request/response pair  - Transmitter: a sequence of exchanges for a Call <enter> The refactoring isn't totally complete, but this should be the last big one. <enter>  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/59e68cd2bcba789e7faca70f8910afd2edeed2be,"@@ -96,7 +96,7 @@ public final class ConnectionPoolTest {
       Call call = client.newCall(newRequest(addressA));
       Transmitter transmitter = new Transmitter(client, call);
       transmitter.prepareToConnect(call.request());
-      transmitter.acquireConnection(c1);
+      transmitter.acquireConnectionNoEvents(c1);
     }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
@@ -183,7 +183,7 @@ public final class ConnectionPoolTest {
     assertEquals(0L, pool.cleanup(100L));
     assertEquals(Collections.emptyList(), c1.transmitters);
 
-    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected.
+    assertTrue(c1.noNewExchanges); // Can't allocate once a leak has been detected.
   }
 
   /** Use a helper method so there's no hidden reference remaining on the stack. */
@@ -195,7 +195,7 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
       Call call = client.newCall(newRequest(connection.route().address()));
       Transmitter transmitter = new Transmitter(client, call);
       transmitter.prepareToConnect(call.request());
-      transmitter.acquireConnection(connection);
+      transmitter.acquireConnectionNoEvents(connection);
     }
   }
 
@@ -35,11 +35,10 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.DeferredTrailers;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Transmitter;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.connection.RealConnectionPool;
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.proxy.NullProxySelector;
@@ -164,10 +163,6 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
       }
 
-      @Override public Transmitter transmitter(Call call) {
-        return ((RealCall) call).transmitter();
-      }
-
       @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
         return ((RealCall) call).timeoutExit(e);
       }
@@ -176,9 +171,13 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         return RealCall.newRealCall(client, originalRequest, true);
       }
 
-      @Override public void initDeferredTrailers(
-          Response.Builder responseBuilder, DeferredTrailers deferredTrailers) {
-        responseBuilder.initDeferredTrailers(deferredTrailers);
+      @Override public void initExchange(
+          Response.Builder responseBuilder, Exchange exchange) {
+        responseBuilder.initExchange(exchange);
+      }
+
+      @Override public @Nullable Exchange exchange(Response response) {
+        return response.exchange;
       }
     };
   }
@@ -83,18 +83,11 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       if (executed) throw new IllegalStateException(""Already Executed"");
       executed = true;
     }
-    captureCallStackTrace();
     timeout.enter();
     transmitter.callStart();
     try {
       client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain();
-      if (result == null) throw new IOException(""Canceled"");
-      return result;
-    } catch (IOException e) {
-      e = timeoutExit(e);
-      transmitter.callFailed(e);
-      throw e;
+      return getResponseWithInterceptorChain();
     } finally {
       client.dispatcher().finished(this);
     }
@@ -110,17 +103,11 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     return e;
   }
 
-  private void captureCallStackTrace() {
-    transmitter.initCallStackTrace(
-        Platform.get().getStackTraceForCloseable(""response.body().close()""));
-  }
-
   @Override public void enqueue(Callback responseCallback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException(""Already Executed"");
       executed = true;
     }
-    captureCallStackTrace();
     transmitter.callStart();
     client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
@@ -146,10 +133,6 @@ private void captureCallStackTrace() {
     return RealCall.newRealCall(client, originalRequest, forWebSocket);
   }
 
-  Transmitter transmitter() {
-    return transmitter;
-  }
-
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
     private volatile AtomicInteger callsPerHost = new AtomicInteger(0);
@@ -192,7 +175,7 @@ void executeOn(ExecutorService executorService) {
       } catch (RejectedExecutionException e) {
         InterruptedIOException ioException = new InterruptedIOException(""executor rejected"");
         ioException.initCause(e);
-        transmitter.callFailed(ioException);
+        transmitter.noMoreExchanges(ioException);
         responseCallback.onFailure(RealCall.this, ioException);
       } finally {
         if (!success) {
@@ -206,20 +189,14 @@ void executeOn(ExecutorService executorService) {
       timeout.enter();
       try {
         Response response = getResponseWithInterceptorChain();
-        if (transmitter.isCanceled()) {
-          signalledCallback = true;
-          responseCallback.onFailure(RealCall.this, new IOException(""Canceled""));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(RealCall.this, response);
-        }
+        if (transmitter.isCanceled()) throw new IOException(""Canceled"");
+        signalledCallback = true;
+        responseCallback.onResponse(RealCall.this, response);
       } catch (IOException e) {
-        e = timeoutExit(e);
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, ""Callback failure for "" + toLoggableString(), e);
         } else {
-          transmitter.callFailed(e);
           responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
@@ -259,10 +236,14 @@ Response getResponseWithInterceptorChain() throws IOException {
         originalRequest, this, client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis());
 
+    IOException ioException = null;
     try {
       return chain.proceed(originalRequest);
+    } catch (IOException e) {
+      ioException = e;
+      throw e;
     } finally {
-      transmitter.noMoreStreamsOnCall();
+      transmitter.noMoreExchanges(ioException);
     }
   }
 }
@@ -20,7 +20,7 @@
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
-import okhttp3.internal.DeferredTrailers;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.http.HttpHeaders;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -54,7 +54,7 @@ public final class Response implements Closeable {
   final @Nullable Response priorResponse;
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
-  final @Nullable DeferredTrailers deferredTrailers;
+  final @Nullable Exchange exchange;
 
   private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
@@ -71,7 +71,7 @@ public final class Response implements Closeable {
     this.priorResponse = builder.priorResponse;
     this.sentRequestAtMillis = builder.sentRequestAtMillis;
     this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
-    this.deferredTrailers = builder.deferredTrailers;
+    this.exchange = builder.exchange;
   }
 
   /**
@@ -144,7 +144,8 @@ public Headers headers() {
    * before the entire HTTP response body has been consumed.
    */
   public Headers trailers() throws IOException {
-    return deferredTrailers.trailers();
+    if (exchange == null) throw new IllegalStateException(""trailers not available"");
+    return exchange.trailers();
   }
 
   /**
@@ -314,7 +315,7 @@ public static class Builder {
     @Nullable Response priorResponse;
     long sentRequestAtMillis;
     long receivedResponseAtMillis;
-    @Nullable DeferredTrailers deferredTrailers;
+    @Nullable Exchange exchange;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -333,7 +334,7 @@ public Builder() {
       this.priorResponse = response.priorResponse;
       this.sentRequestAtMillis = response.sentRequestAtMillis;
       this.receivedResponseAtMillis = response.receivedResponseAtMillis;
-      this.deferredTrailers = response.deferredTrailers;
+      this.exchange = response.exchange;
     }
 
     public Builder request(Request request) {
@@ -441,8 +442,8 @@ public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
       return this;
     }
 
-    void initDeferredTrailers(DeferredTrailers deferredTrailers) {
-      this.deferredTrailers = deferredTrailers;
+    void initExchange(Exchange deferredTrailers) {
+      this.exchange = deferredTrailers;
     }
 
     public Response build() {
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.IOException;
-import okhttp3.Headers;
-
-public interface DeferredTrailers {
-  /** Call this only after the HTTP response body has been exhausted. */
-  Headers trailers() throws IOException;
-}
@@ -27,6 +27,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.connection.RealConnectionPool;
 
 /**
@@ -59,12 +60,12 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
 
   public abstract boolean isInvalidHttpUrlHost(IllegalArgumentException e);
 
-  public abstract Transmitter transmitter(Call call);
-
   public abstract @Nullable IOException timeoutExit(Call call, @Nullable IOException e);
 
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 
-  public abstract void initDeferredTrailers(
-      Response.Builder responseBuilder, DeferredTrailers deferredTrailers);
+  public abstract void initExchange(
+      Response.Builder responseBuilder, Exchange exchange);
+
+  public abstract @Nullable Exchange exchange(Response response);
 }
@@ -16,55 +16,56 @@
 package okhttp3.internal;
 
 import java.io.IOException;
+import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
-import java.net.ProtocolException;
-import java.net.SocketException;
+import java.net.Socket;
 import javax.annotation.Nullable;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
+import okhttp3.Connection;
 import okhttp3.EventListener;
-import okhttp3.Handshake;
-import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.Route;
+import okhttp3.internal.connection.Exchange;
+import okhttp3.internal.connection.ExchangeFinder;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RealConnectionPool;
-import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.RealResponseBody;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
+import okhttp3.internal.platform.Platform;
 
+import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.sameConnection;
 
 /**
  * Bridge between OkHttp's application and network layers. This class exposes high-level application
  * layer primitives: connections, requests, responses, and streams.
+ *
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
  */
 public final class Transmitter {
-  public final OkHttpClient client;
-  public final RealConnectionPool connectionPool;
-  public final Call call;
-  public final EventListener eventListener;
+  private final OkHttpClient client;
+  private final RealConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
 
   private @Nullable Object callStackTrace;
 
   private Request request;
-  private volatile boolean canceled;
-  private volatile StreamAllocation streamAllocation;
+  private ExchangeFinder exchangeFinder;
+
+  // Guarded by connectionPool.
+  public RealConnection connection;
+  private Exchange exchange;
+  private boolean canceled;
+  private boolean noMoreExchanges;
 
   public Transmitter(OkHttpClient client, Call call) {
     this.client = client;
@@ -73,8 +74,9 @@ public Transmitter(OkHttpClient client, Call call) {
     this.eventListener = client.eventListenerFactory().create(call);
   }
 
-  public void initCallStackTrace(@Nullable Object callStackTrace) {
-    this.callStackTrace = callStackTrace;
+  public void callStart() {
+    this.callStackTrace = Platform.get().getStackTraceForCloseable(""response.body().close()"");
+    eventListener.callStart(call);
   }
 
   /**
@@ -83,19 +85,18 @@ public void initCallStackTrace(@Nullable Object callStackTrace) {
    */
   public void prepareToConnect(Request request) {
     if (this.request != null) {
-      if (sameConnection(this.request.url(), request.url())) {
-        return; // Already ready.
-      }
-      if (streamAllocation != null) {
-        streamAllocation.transmitterReleaseConnection(false);
-        streamAllocation = null;
+      if (sameConnection(this.request.url(), request.url())) return; // Already ready.
+      if (exchange != null) throw new IllegalStateException();
+
+      if (exchangeFinder != null) {
+        maybeReleaseConnection(null, true);
+        exchangeFinder = null;
       }
     }
 
     this.request = request;
-    this.streamAllocation = new StreamAllocation(this,
-        Internal.instance.realConnectionPool(client.connectionPool()), createAddress(request.url()),
-        call, eventListener, callStackTrace);
+    this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()),
+        call, eventListener);
   }
 
   private Address createAddress(HttpUrl url) {
@@ -113,283 +114,161 @@ private Address createAddress(HttpUrl url) {
         client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
   }
 
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    canceled = true;
-    StreamAllocation streamAllocation = this.streamAllocation;
-    if (streamAllocation != null) streamAllocation.cancel();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  public void releaseStreamForException() {
-    streamAllocation.releaseStreamForException();
-  }
-
-  public void noNewStreamsOnConnection() {
-    connection().noNewStreams();
-  }
-
-  public RealWebSocket.Streams newWebSocketStreams() {
-    return streamAllocation.connection().newWebSocketStreams(this);
-  }
-
-  public void socketTimeout(int timeout) throws SocketException {
-    streamAllocation.connection().socket().setSoTimeout(timeout);
-  }
-
-  /** Returns the connection that carries the allocated stream. */
-  public RealConnection newStream(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
-    return streamAllocation.connection();
-  }
-
-  public Handshake handshake() {
-    return streamAllocation.connection().handshake();
-  }
-
-  public boolean isConnectionMultiplexed() {
-    return streamAllocation.connection().isMultiplexed();
-  }
-
-  public void noMoreStreamsOnCall() {
-    if (streamAllocation != null) {
-      streamAllocation.transmitterReleaseConnection(true);
+  /** Returns a new exchange to carry a new request and response. */
+  public Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    synchronized (connectionPool) {
+      if (noMoreExchanges) throw new IllegalStateException(""released"");
+      if (exchange != null) throw new IllegalStateException(""exchange != null"");
     }
-  }
-
-  public boolean canRetry() {
-    return streamAllocation.canRetry();
-  }
-
-  public Route route() {
-    return streamAllocation.route();
-  }
-
-  public boolean hasCodec() {
-    return streamAllocation != null && streamAllocation.codec() != null;
-  }
-
-  public void callStart() {
-    eventListener.callStart(call);
-  }
 
-  public void callFailed(IOException e) {
-    eventListener.callFailed(call, e);
-  }
+    HttpCodec httpCodec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);
+    Exchange result = new Exchange(this, call, eventListener, exchangeFinder, httpCodec);
 
-  public void writeRequestHeaders(Request request) throws IOException {
-    try {
-      eventListener.requestHeadersStart(call);
-      streamAllocation.codec().writeRequestHeaders(request);
-      eventListener.requestHeadersEnd(call, request);
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
+    synchronized (connectionPool) {
+      this.exchange = result;
+      return result;
     }
   }
 
-  public Sink createRequestBody(Request request) throws IOException {
-    long contentLength = request.body().contentLength();
-    eventListener.requestBodyStart(call);
-    Sink rawRequestBody = streamAllocation.codec().createRequestBody(request, contentLength);
-    return new RequestBodySink(rawRequestBody, contentLength);
-  }
-
-  public void flushRequest() throws IOException {
-    try {
-      streamAllocation.codec().flushRequest();
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
-    }
-  }
+  public void acquireConnectionNoEvents(RealConnection connection) {
+    assert (Thread.holdsLock(connectionPool));
 
-  public void finishRequest() throws IOException {
-    try {
-      streamAllocation.codec().finishRequest();
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
-    }
+    if (this.connection != null) throw new IllegalStateException();
+    this.connection = connection;
+    connection.transmitters.add(new TransmitterReference(this, callStackTrace));
   }
 
-  public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    try {
-      eventListener.responseHeadersStart(call);
-      return streamAllocation.codec().readResponseHeaders(expectContinue);
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
+  /**
+   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
+   * caller should close.
+   */
+  public @Nullable Socket releaseConnectionNoEvents() {
+    assert (Thread.holdsLock(connectionPool));
+
+    int index = -1;
+    for (int i = 0, size = this.connection.transmitters.size(); i < size; i++) {
+      Reference<Transmitter> reference = this.connection.transmitters.get(i);
+      if (reference.get() == this) {
+        index = i;
+        break;
+      }
     }
-  }
-
-  public void responseHeadersEnd(Response response) {
-    eventListener.responseHeadersEnd(call, response);
-  }
 
-  public ResponseBody openResponseBody(Response response) throws IOException {
-    try {
-      streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
-      String contentType = response.header(""Content-Type"");
-      HttpCodec codec = streamAllocation.codec();
-      long contentLength = codec.reportedContentLength(response);
-      Source rawSource = codec.openResponseBodySource(response);
-      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
-      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
-    } catch (IOException e) {
-      streamAllocation.streamFailed(e);
-      throw e;
-    }
-  }
+    if (index == -1) throw new IllegalStateException();
 
-  public DeferredTrailers deferredTrailers() {
-    return new DeferredTrailers() {
-      HttpCodec codec = streamAllocation.codec();
+    RealConnection released = this.connection;
+    released.transmitters.remove(index);
+    this.connection = null;
 
-      @Override public Headers trailers() throws IOException {
-        return codec.trailers();
+    if (released.transmitters.isEmpty()) {
+      released.idleAtNanos = System.nanoTime();
+      if (connectionPool.connectionBecameIdle(released)) {
+        return released.socket();
       }
-    };
-  }
-
-  public boolean supportsUrl(HttpUrl url) {
-    return streamAllocation.connection().supportsUrl(url);
-  }
+    }
 
-  public void acquireConnection(RealConnection connection) {
-    streamAllocation.transmitterAcquireConnection(connection);
+    return null;
   }
 
-  public RealConnection connection() {
-    return streamAllocation.connection();
+  public void exchangeDoneDueToException() {
+    synchronized (connectionPool) {
+      if (noMoreExchanges) throw new IllegalStateException();
+      exchange = null;
+    }
   }
 
-  public void responseBodyComplete(long bytesRead, IOException e) {
-    if (e != null) {
-      streamAllocation.streamFailed(e);
-    }
-    if (streamAllocation != null) {
-      streamAllocation.responseBodyComplete(bytesRead, e);
+  public void exchangeDone(@Nullable IOException e) {
+    synchronized (connectionPool) {
+      if (exchange == null) throw new IllegalStateException(""exchange == null"");
+      exchange.connection().successCount++;
+      exchange = null;
     }
+    maybeReleaseConnection(e, false);
   }
 
-  /** A request body that fires events when it completes. */
-  private final class RequestBodySink extends ForwardingSink {
-    /** The exact number of bytes to be written, or -1L if that is unknown. */
-    private long contentLength;
-    private long bytesReceived;
-    private boolean closed;
-
-    RequestBodySink(Sink delegate, long contentLength) {
-      super(delegate);
-      this.contentLength = contentLength;
+  public void noMoreExchanges(IOException e) {
+    synchronized (connectionPool) {
+      noMoreExchanges = true;
     }
+    maybeReleaseConnection(e, false);
+  }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException(""closed"");
-      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
-        throw new ProtocolException(""expected "" + contentLength
-            + "" bytes but received "" + (bytesReceived + byteCount));
-      }
-      try {
-        super.write(source, byteCount);
-        this.bytesReceived += byteCount;
-      } catch (IOException e) {
-        streamAllocation.streamFailed(e);
-        throw e;
+  /**
+   * Release the connection if it is no longer needed. This is called after each exchange completes
+   * and after the call signals that no more exchanges are expected.
+   *
+   * @param force true to release the connection even if more exchanges are expected for the call.
+   */
+  private void maybeReleaseConnection(@Nullable IOException e, boolean force) {
+    Socket socket;
+    Connection releasedConnection;
+    boolean callEnd;
+    synchronized (connectionPool) {
+      if (force && exchange != null) {
+        throw new IllegalStateException(""cannot release connection while it is in use"");
       }
+      releasedConnection = this.connection;
+      socket = this.connection != null && exchange == null && (force || noMoreExchanges)
+          ? releaseConnectionNoEvents()
+          : null;
+      if (this.connection != null) releasedConnection = null;
+      callEnd = noMoreExchanges && exchange == null;
     }
+    closeQuietly(socket);
 
-    @Override public void flush() throws IOException {
-      try {
-        super.flush();
-      } catch (IOException e) {
-        streamAllocation.streamFailed(e);
-        throw e;
-      }
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      if (contentLength != -1L && bytesReceived != contentLength) {
-        throw new ProtocolException(""unexpected end of stream"");
-      }
-      eventListener.requestBodyEnd(call, bytesReceived);
-      try {
-        super.close();
-      } catch (IOException e) {
-        streamAllocation.streamFailed(e);
-        throw e;
+    if (callEnd) {
+      e = Internal.instance.timeoutExit(call, e);
+      if (e != null) {
+        eventListener.callFailed(call, e);
+      } else {
+        eventListener.callEnd(call);
       }
     }
   }
 
-  /** A response body that fires events when it completes. */
-  final class ResponseBodySource extends ForwardingSource {
-    private long contentLength;
-    private long bytesReceived;
-    private boolean completed;
-    private boolean closed;
-
-    ResponseBodySource(Source delegate, long contentLength) {
-      super(delegate);
-      this.contentLength = contentLength;
+  public boolean canRetry() {
+    return exchangeFinder.canRetry();
+  }
 
-      if (contentLength == 0L) {
-        complete(null);
-      }
+  public boolean hasExchange() {
+    synchronized (connectionPool) {
+      return exchange != null;
     }
+  }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException(""closed"");
-      try {
-        long read = delegate().read(sink, byteCount);
-        if (read == -1L) {
-          complete(null);
-          return -1L;
-        }
-
-        long newBytesReceived = bytesReceived + read;
-        if (contentLength != -1L && newBytesReceived > contentLength) {
-          throw new ProtocolException(""expected "" + contentLength
-              + "" bytes but received "" + newBytesReceived);
-        }
-
-        bytesReceived = newBytesReceived;
-        if (newBytesReceived == contentLength) {
-          complete(null);
-        }
-
-        return read;
-      } catch (IOException e) {
-        complete(e);
-        throw e;
-      }
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    Exchange exchangeToCancel;
+    RealConnection connectionToCancel;
+    synchronized (connectionPool) {
+      canceled = true;
+      exchangeToCancel = exchange;
+      connectionToCancel = exchangeFinder != null && exchangeFinder.connectingConnection() != null
+          ? exchangeFinder.connectingConnection()
+          : connection;
     }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      super.close();
-      complete(null);
+    if (exchangeToCancel != null) {
+      exchangeToCancel.cancel();
+    } else if (connectionToCancel != null) {
+      connectionToCancel.cancel();
     }
+  }
 
-    void complete(IOException e) {
-      if (completed) return;
-      completed = true;
-      responseBodyComplete(bytesReceived, e);
+  public boolean isCanceled() {
+    synchronized (connectionPool) {
+      return canceled;
     }
   }
 
@@ -39,8 +39,8 @@ public ConnectInterceptor(OkHttpClient client) {
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
     boolean doExtensiveHealthChecks = !request.method().equals(""GET"");
-    RealConnection connection = transmitter.newStream(chain, doExtensiveHealthChecks);
+    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);
 
-    return realChain.proceed(request, transmitter, connection);
+    return realChain.proceed(request, transmitter, exchange);
   }
 }
@@ -0,0 +1,270 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.SocketException;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Transmitter;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.ws.RealWebSocket;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Transmits a single HTTP request and a response pair. This layers connection management and events
+ * on {@link HttpCodec}, which handles the actual I/O.
+ */
+public final class Exchange {
+  final Transmitter transmitter;
+  final Call call;
+  final EventListener eventListener;
+  final ExchangeFinder finder;
+  final HttpCodec codec;
+
+  public Exchange(Transmitter transmitter, Call call, EventListener eventListener,
+      ExchangeFinder finder, HttpCodec codec) {
+    this.transmitter = transmitter;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.finder = finder;
+    this.codec = codec;
+  }
+
+  public RealConnection connection() {
+    return codec.connection();
+  }
+
+  public void writeRequestHeaders(Request request) throws IOException {
+    try {
+      eventListener.requestHeadersStart(call);
+      codec.writeRequestHeaders(request);
+      eventListener.requestHeadersEnd(call, request);
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public Sink createRequestBody(Request request) throws IOException {
+    long contentLength = request.body().contentLength();
+    eventListener.requestBodyStart(call);
+    Sink rawRequestBody = codec.createRequestBody(request, contentLength);
+    return new RequestBodySink(rawRequestBody, contentLength);
+  }
+
+  public void flushRequest() throws IOException {
+    try {
+      codec.flushRequest();
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void finishRequest() throws IOException {
+    try {
+      codec.finishRequest();
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public @Nullable Response.Builder readResponseHeaders(
+      boolean expectContinue) throws IOException {
+    try {
+      eventListener.responseHeadersStart(call);
+      Response.Builder result = codec.readResponseHeaders(expectContinue);
+      if (result != null) {
+        Internal.instance.initExchange(result, this);
+      }
+      return result;
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void responseHeadersEnd(Response response) {
+    eventListener.responseHeadersEnd(call, response);
+  }
+
+  public ResponseBody openResponseBody(Response response) throws IOException {
+    try {
+      eventListener.responseBodyStart(call);
+      String contentType = response.header(""Content-Type"");
+      long contentLength = codec.reportedContentLength(response);
+      Source rawSource = codec.openResponseBodySource(response);
+      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
+      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+    } catch (IOException e) {
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public Headers trailers() throws IOException {
+    return codec.trailers();
+  }
+
+  public RealWebSocket.Streams newWebSocketStreams() throws SocketException {
+    return codec.connection().newWebSocketStreams(this);
+  }
+
+  public void noNewExchangesOnConnection() {
+    codec.connection().noNewExchanges();
+  }
+
+  public void cancel() {
+    codec.cancel();
+  }
+
+  void trackFailure(IOException e) {
+    finder.trackFailure();
+    codec.connection().trackFailure(e);
+  }
+
+  void responseBodyComplete(long bytesRead, @Nullable IOException e) {
+    if (e != null) {
+      trackFailure(e);
+    }
+    eventListener.responseBodyEnd(call, bytesRead);
+    transmitter.exchangeDone(e);
+  }
+
+  /** A request body that fires events when it completes. */
+  private final class RequestBodySink extends ForwardingSink {
+    /** The exact number of bytes to be written, or -1L if that is unknown. */
+    private long contentLength;
+    private long bytesReceived;
+    private boolean closed;
+
+    RequestBodySink(Sink delegate, long contentLength) {
+      super(delegate);
+      this.contentLength = contentLength;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException(""closed"");
+      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
+        throw new ProtocolException(""expected "" + contentLength
+            + "" bytes but received "" + (bytesReceived + byteCount));
+      }
+      try {
+        super.write(source, byteCount);
+        this.bytesReceived += byteCount;
+      } catch (IOException e) {
+        trackFailure(e);
+        throw e;
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      try {
+        super.flush();
+      } catch (IOException e) {
+        trackFailure(e);
+        throw e;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      if (contentLength != -1L && bytesReceived != contentLength) {
+        throw new ProtocolException(""unexpected end of stream"");
+      }
+      eventListener.requestBodyEnd(call, bytesReceived);
+      try {
+        super.close();
+      } catch (IOException e) {
+        trackFailure(e);
+        throw e;
+      }
+    }
+  }
+
+  /** A response body that fires events when it completes. */
+  final class ResponseBodySource extends ForwardingSource {
+    private long contentLength;
+    private long bytesReceived;
+    private boolean completed;
+    private boolean closed;
+
+    ResponseBodySource(Source delegate, long contentLength) {
+      super(delegate);
+      this.contentLength = contentLength;
+
+      if (contentLength == 0L) {
+        complete(null);
+      }
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException(""closed"");
+      try {
+        long read = delegate().read(sink, byteCount);
+        if (read == -1L) {
+          complete(null);
+          return -1L;
+        }
+
+        long newBytesReceived = bytesReceived + read;
+        if (contentLength != -1L && newBytesReceived > contentLength) {
+          throw new ProtocolException(""expected "" + contentLength
+              + "" bytes but received "" + newBytesReceived);
+        }
+
+        bytesReceived = newBytesReceived;
+        if (newBytesReceived == contentLength) {
+          complete(null);
+        }
+
+        return read;
+      } catch (IOException e) {
+        complete(e);
+        throw e;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      super.close();
+      complete(null);
+    }
+
+    void complete(IOException e) {
+      if (completed) return;
+      completed = true;
+      responseBodyComplete(bytesReceived, e);
+    }
+  }
+}
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.util.List;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Route;
+import okhttp3.internal.Transmitter;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpCodec;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
+ *
+ * <ol>
+ *   <li>If the current call already has a connection that can satisfy the request it is used.
+ *       Using the same connection for an initial exchange and its follow-ups may improve locality.
+ *
+ *   <li>If there is a connection in the pool that can satisfy the request it is used. Note that
+ *       it is possible for shared exchanges to make requests to different host names! See {@link
+ *       RealConnection#isEligible} for details.
+ *
+ *   <li>If there's no existing connection, make a list of routes (which may require blocking DNS
+ *       lookups) and attempt a new connection them. When failures occur, retries iterate the list
+ *       of available routes.
+ * </ol>
+ *
+ * <p>If the pool gains an eligible connection while DNS, TCP, or TLS work is in flight, this finder
+ * will prefer pooled connections. Only pooled HTTP/2 connections are used for such de-duplication.
+ *
+ * <p>It is possible to cancel the finding process.
+ */
+public final class ExchangeFinder {
+  private final Transmitter transmitter;
+  private final Address address;
+  private final RealConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
+
+  private RouteSelector.Selection routeSelection;
+
+  // State guarded by connectionPool.
+  private final RouteSelector routeSelector;
+  private RealConnection connectingConnection;
+  private boolean hasStreamFailure;
+
+  public ExchangeFinder(Transmitter transmitter, RealConnectionPool connectionPool,
+      Address address, Call call, EventListener eventListener) {
+    this.transmitter = transmitter;
+    this.connectionPool = connectionPool;
+    this.address = address;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.routeSelector = new RouteSelector(
+        address, connectionPool.routeDatabase, call, eventListener);
+  }
+
+  public HttpCodec find(
+      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    int connectTimeout = chain.connectTimeoutMillis();
+    int readTimeout = chain.readTimeoutMillis();
+    int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
+    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+    try {
+      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
+      return resultConnection.newCodec(client, chain);
+    } catch (RouteException e) {
+      trackFailure();
+      throw e;
+    } catch (IOException e) {
+      trackFailure();
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
+    while (true) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          pingIntervalMillis, connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        candidate.noNewExchanges();
+        continue;
+      }
+
+      return candidate;
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
+    boolean foundPooledConnection = false;
+    RealConnection result = null;
+    Route selectedRoute = null;
+    RealConnection releasedConnection;
+    Socket toClose;
+    synchronized (connectionPool) {
+      if (transmitter.isCanceled()) throw new IOException(""Canceled"");
+      hasStreamFailure = false; // This is a fresh attempt.
+
+      Route previousRoute = retryCurrentRoute()
+          ? transmitter.connection.route()
+          : null;
+
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new exchanges.
+      releasedConnection = transmitter.connection;
+      toClose = transmitter.connection != null && transmitter.connection.noNewExchanges
+          ? transmitter.releaseConnectionNoEvents()
+          : null;
+
+      if (transmitter.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = transmitter.connection;
+        releasedConnection = null;
+      }
+
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
+          foundPooledConnection = true;
+          result = transmitter.connection;
+        } else {
+          selectedRoute = previousRoute;
+        }
+      }
+    }
+    closeQuietly(toClose);
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result;
+    }
+
+    // If we need a route selection, make one. This is a blocking operation.
+    boolean newRouteSelection = false;
+    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+      newRouteSelection = true;
+      routeSelection = routeSelector.next();
+    }
+
+    List<Route> routes = null;
+    synchronized (connectionPool) {
+      if (transmitter.isCanceled()) throw new IOException(""Canceled"");
+
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        routes = routeSelection.getAll();
+        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, false)) {
+          foundPooledConnection = true;
+          result = transmitter.connection;
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
+        result = new RealConnection(connectionPool, selectedRoute);
+        connectingConnection = result;
+      }
+    }
+
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+      return result;
+    }
+
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
+    connectionPool.routeDatabase.connected(result.route());
+
+    Socket socket = null;
+    synchronized (connectionPool) {
+      connectingConnection = null;
+      // Last attempt at connection coalescing, which only occurs if we attempted multiple
+      // concurrent connections to the same host.
+      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
+        // We lost the race! Close the connection we created and return the pooled connection.
+        result.noNewExchanges = true;
+        socket = result.socket();
+        result = transmitter.connection;
+      } else {
+        connectionPool.put(result);
+        transmitter.acquireConnectionNoEvents(result);
+      }
+    }
+    closeQuietly(socket);
+
+    eventListener.connectionAcquired(call, result);
+    return result;
+  }
+
+  public RealConnection connectingConnection() {
+    assert (Thread.holdsLock(connectionPool));
+    return connectingConnection;
+  }
+
+  public void trackFailure() {
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      hasStreamFailure = true; // Permit retries.
+    }
+  }
+
+  public boolean canRetry() {
+    synchronized (connectionPool) {
+      // Don't try if the failure wasn't our fault!
+      if (!hasStreamFailure) return false;
+
+      return retryCurrentRoute()
+          || (routeSelection != null && routeSelection.hasNext())
+          || routeSelector.hasNext();
+    }
+  }
+
+  /**
+   * Return true if the route used for the current connection should be retried, even if the
+   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
+   * coalesced connections.
+   */
+  private boolean retryCurrentRoute() {
+    return transmitter.connection != null
+        && transmitter.connection.routeFailureCount == 0
+        && Util.sameConnection(transmitter.connection.route().address().url(), address.url());
+  }
+}
@@ -99,10 +99,10 @@ public final class RealConnection extends Http2Connection.Listener implements Co
   // The fields below track connection state and are guarded by connectionPool.
 
   /**
-   * If true, no new streams can be created on this connection. Once true this is always true.
+   * If true, no new exchanges can be created on this connection. Once true this is always true.
    * Guarded by {@link #connectionPool}.
    */
-  public boolean noNewStreams;
+  public boolean noNewExchanges;
 
   /**
    * The number of times there was a problem establishing a stream that could be due to route
@@ -130,11 +130,11 @@ public RealConnection(RealConnectionPool connectionPool, Route route) {
     this.route = route;
   }
 
-  /** Prevent further streams from being created on this connection. */
-  public void noNewStreams() {
+  /** Prevent further exchanges from being created on this connection. */
+  public void noNewExchanges() {
     assert (!Thread.holdsLock(connectionPool));
     synchronized (connectionPool) {
-      noNewStreams = true;
+      noNewExchanges = true;
     }
   }
 
@@ -472,8 +472,8 @@ private Request createTunnelRequest() throws IOException {
    * {@code route} is the resolved route for a connection.
    */
   public boolean isEligible(Address address, @Nullable List<Route> routes) {
-    // If this connection is not accepting new streams, we're done.
-    if (transmitters.size() >= allocationLimit || noNewStreams) return false;
+    // If this connection is not accepting new exchanges, we're done.
+    if (transmitters.size() >= allocationLimit || noNewExchanges) return false;
 
     // If the non-host fields of the address don't overlap, we're done.
     if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
@@ -548,11 +548,12 @@ public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain) throws S
     }
   }
 
-  public RealWebSocket.Streams newWebSocketStreams(Transmitter transmitter) {
-    noNewStreams();
+  public RealWebSocket.Streams newWebSocketStreams(Exchange exchange) throws SocketException {
+    socket.setSoTimeout(0);
+    noNewExchanges();
     return new RealWebSocket.Streams(true, source, sink) {
       @Override public void close() throws IOException {
-        transmitter.responseBodyComplete(-1L, null);
+        exchange.responseBodyComplete(-1L, null);
       }
     };
   }
@@ -628,34 +629,35 @@ public boolean isMultiplexed() {
 
   /**
    * Track a failure using this connection. This may prevent both the connection and its route from
-   * being used for future streams.
+   * being used for future exchanges.
    */
   void trackFailure(@Nullable IOException e) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (e instanceof StreamResetException) {
-      ErrorCode errorCode = ((StreamResetException) e).errorCode;
-      if (errorCode == ErrorCode.REFUSED_STREAM) {
-        // Retry REFUSED_STREAM errors once on the same connection.
-        refusedStreamCount++;
-        if (refusedStreamCount > 1) {
-          noNewStreams = true;
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      if (e instanceof StreamResetException) {
+        ErrorCode errorCode = ((StreamResetException) e).errorCode;
+        if (errorCode == ErrorCode.REFUSED_STREAM) {
+          // Retry REFUSED_STREAM errors once on the same connection.
+          refusedStreamCount++;
+          if (refusedStreamCount > 1) {
+            noNewExchanges = true;
+            routeFailureCount++;
+          }
+        } else if (errorCode != ErrorCode.CANCEL) {
+          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
+          noNewExchanges = true;
           routeFailureCount++;
         }
-      } else if (errorCode != ErrorCode.CANCEL) {
-        // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
-        noNewStreams = true;
-        routeFailureCount++;
-      }
-    } else if (!isMultiplexed() || e instanceof ConnectionShutdownException) {
-      noNewStreams = true;
+      } else if (!isMultiplexed() || e instanceof ConnectionShutdownException) {
+        noNewExchanges = true;
 
-      // If this route hasn't completed a call, avoid it for new connections.
-      if (successCount == 0) {
-        if (e != null) {
-          connectionPool.connectFailed(route, e);
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (successCount == 0) {
+          if (e != null) {
+            connectionPool.connectFailed(route, e);
+          }
+          routeFailureCount++;
         }
-        routeFailureCount++;
       }
     }
   }
@@ -108,7 +108,7 @@ boolean transmitterAcquirePooledConnection(Address address, Transmitter transmit
     for (RealConnection connection : connections) {
       if (requireMultiplexed && !connection.isMultiplexed()) continue;
       if (!connection.isEligible(address, routes)) continue;
-      transmitter.acquireConnection(connection);
+      transmitter.acquireConnectionNoEvents(connection);
       return true;
     }
     return false;
@@ -127,9 +127,9 @@ void put(RealConnection connection) {
    * Notify this pool that {@code connection} has become idle. Returns true if the connection has
    * been removed from the pool and should be closed.
    */
-  boolean connectionBecameIdle(RealConnection connection) {
+  public boolean connectionBecameIdle(RealConnection connection) {
     assert (Thread.holdsLock(this));
-    if (connection.noNewStreams || maxIdleConnections == 0) {
+    if (connection.noNewExchanges || maxIdleConnections == 0) {
       connections.remove(connection);
       return true;
     } else {
@@ -144,7 +144,7 @@ public void evictAll() {
       for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
         RealConnection connection = i.next();
         if (connection.transmitters.isEmpty()) {
-          connection.noNewStreams = true;
+          connection.noNewExchanges = true;
           evictedConnections.add(connection);
           i.remove();
         }
@@ -237,7 +237,7 @@ private int pruneAndGetAllocationCount(RealConnection connection, long now) {
       Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);
 
       references.remove(i);
-      connection.noNewStreams = true;
+      connection.noNewExchanges = true;
 
       // If this was the last allocation, the connection is eligible for immediate eviction.
       if (references.isEmpty()) {
@@ -1,455 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.lang.ref.Reference;
-import java.net.Socket;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Transmitter;
-import okhttp3.internal.Transmitter.TransmitterReference;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpCodec;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * This class coordinates the relationship between three entities:
- *
- * <ul>
- *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *         potentially slow to establish so it is necessary to be able to cancel a connection
- *         currently being connected.
- *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *         connections. Each connection has its own allocation limit, which defines how many
- *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Transmitters:</strong> a logical sequence of streams, typically an initial
- *         request and its follow up requests. We prefer to keep all streams of a single {@link
- *         Call} on the same connection for better behavior and locality.
- * </ul>
- *
- * <p>Instances of this class act on behalf of a single transmitter, using one or more streams over
- * one or more connections. This class has APIs to release each of the above resources:
- *
- * <ul>
- *     <li>{@link RealConnection#noNewStreams} prevents the connection from being used for new
- *         streams in the future. Use this after a {@code Connection: close} header, or when the
- *         connection may be inconsistent.
- *     <li>{@link #responseBodyComplete} releases the active stream from this allocation.
- *         Note that only one stream may be active at a given time, so it is necessary to call
- *         it before creating a subsequent stream with {@link #newStream}.
- *     <li>{@link #transmitterReleaseConnection} removes the transmitter's hold on the connection.
- *         Note that this won't immediately free the connection if there is a stream still
- *         lingering. That happens when a call is complete but its response body has yet to be fully
- *         consumed.
- * </ul>
- *
- * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
- * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
- * but not the other streams sharing its connection. But if the TLS handshake is still in progress
- * then canceling may break the entire connection.
- */
-public final class StreamAllocation {
-  public final Transmitter transmitter;
-  public final Address address;
-  private final RealConnectionPool connectionPool;
-  public final Call call;
-  public final EventListener eventListener;
-  private final Object callStackTrace;
-
-  private RouteSelector.Selection routeSelection;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private RealConnection connectingConnection;
-  private RealConnection connection;
-  private boolean released;
-  private boolean canceled;
-  private boolean hasStreamFailure;
-  private HttpCodec codec;
-
-  public StreamAllocation(Transmitter transmitter, RealConnectionPool connectionPool,
-      Address address, Call call, EventListener eventListener, Object callStackTrace) {
-    this.transmitter = transmitter;
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.routeSelector = new RouteSelector(
-        address, connectionPool.routeDatabase, call, eventListener);
-    this.callStackTrace = callStackTrace;
-  }
-
-  public HttpCodec newStream(
-      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    int connectTimeout = chain.connectTimeoutMillis();
-    int readTimeout = chain.readTimeoutMillis();
-    int writeTimeout = chain.writeTimeoutMillis();
-    int pingIntervalMillis = client.pingIntervalMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, chain);
-
-      synchronized (connectionPool) {
-        codec = resultCodec;
-        return resultCodec;
-      }
-    } catch (RouteException e) {
-      streamFailed(e.getLastConnectException());
-      throw e;
-    } catch (IOException e) {
-      streamFailed(e);
-      throw new RouteException(e);
-    }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
-      boolean doExtensiveHealthChecks) throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          pingIntervalMillis, connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        candidate.noNewStreams();
-        continue;
-      }
-
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
-    boolean foundPooledConnection = false;
-    RealConnection result = null;
-    Route selectedRoute = null;
-    RealConnection releasedConnection;
-    Socket toClose;
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException(""released"");
-      if (codec != null) throw new IllegalStateException(""codec != null"");
-      if (canceled) throw new IOException(""Canceled"");
-
-      Route previousRoute = retryCurrentRoute()
-          ? connection.route()
-          : null;
-
-      // Attempt to use an already-allocated connection. We need to be careful here because our
-      // already-allocated connection may have been restricted from creating new streams.
-      releasedConnection = connection;
-      toClose = connection != null && connection.noNewStreams
-          ? transmitterReleaseConnection()
-          : null;
-
-      if (connection != null) {
-        // We had an already-allocated connection and it's good.
-        result = connection;
-        releasedConnection = null;
-      }
-
-      if (result == null) {
-        // Attempt to get a connection from the pool.
-        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
-          foundPooledConnection = true;
-          result = connection;
-        } else {
-          selectedRoute = previousRoute;
-        }
-      }
-    }
-    closeQuietly(toClose);
-
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-    }
-    if (result != null) {
-      // If we found an already-allocated or pooled connection, we're done.
-      return result;
-    }
-
-    // If we need a route selection, make one. This is a blocking operation.
-    boolean newRouteSelection = false;
-    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
-      newRouteSelection = true;
-      routeSelection = routeSelector.next();
-    }
-
-    List<Route> routes = null;
-    synchronized (connectionPool) {
-      if (canceled) throw new IOException(""Canceled"");
-
-      if (newRouteSelection) {
-        // Now that we have a set of IP addresses, make another attempt at getting a connection from
-        // the pool. This could match due to connection coalescing.
-        routes = routeSelection.getAll();
-        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, false)) {
-          foundPooledConnection = true;
-          result = connection;
-        }
-      }
-
-      if (!foundPooledConnection) {
-        if (selectedRoute == null) {
-          selectedRoute = routeSelection.next();
-        }
-
-        // Create a connection and assign it to this allocation immediately. This makes it possible
-        // for an asynchronous cancel() to interrupt the handshake we're about to do.
-        hasStreamFailure = false;
-        result = new RealConnection(connectionPool, selectedRoute);
-        connectingConnection = result;
-      }
-    }
-
-    // If we found a pooled connection on the 2nd time around, we're done.
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-      return result;
-    }
-
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
-        connectionRetryEnabled, call, eventListener);
-    connectionPool.routeDatabase.connected(result.route());
-
-    Socket socket = null;
-    synchronized (connectionPool) {
-      connectingConnection = null;
-      // Last attempt at connection coalescing, which only occurs if we attempted multiple
-      // concurrent connections to the same host.
-      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
-        // We lost the race! Close the connection we created and return the pooled connection.
-        result.noNewStreams = true;
-        socket = result.socket();
-        result = connection;
-      } else {
-        connectionPool.put(result);
-        transmitterAcquireConnection(result);
-      }
-    }
-    closeQuietly(socket);
-
-    eventListener.connectionAcquired(call, result);
-    return result;
-  }
-
-  public void responseBodyComplete(long bytesRead, IOException e) {
-    eventListener.responseBodyEnd(call, bytesRead);
-
-    Socket socket;
-    Connection releasedConnection;
-    boolean callEnd;
-    synchronized (connectionPool) {
-      if (codec == null) throw new IllegalStateException(""codec == null"");
-      connection.successCount++;
-      this.codec = null;
-      releasedConnection = connection;
-      socket = this.released
-          ? transmitterReleaseConnection()
-          : null;
-      if (connection != null) releasedConnection = null;
-      callEnd = this.released;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-
-    if (callEnd) {
-      e = Internal.instance.timeoutExit(call, e);
-    }
-    if (e != null) {
-      eventListener.callFailed(call, e);
-    } else if (callEnd) {
-      eventListener.callEnd(call);
-    }
-  }
-
-  public HttpCodec codec() {
-    synchronized (connectionPool) {
-      return codec;
-    }
-  }
-
-  public Route route() {
-    synchronized (connectionPool) {
-      return connection != null ? connection.route() : null;
-    }
-  }
-
-  public RealConnection connection() {
-    synchronized (connectionPool) {
-      return connection;
-    }
-  }
-
-  public void transmitterReleaseConnection(boolean callEnd) {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      this.released = true;
-      socket = connection != null && this.codec == null
-          ? transmitterReleaseConnection()
-          : null;
-      if (connection != null) releasedConnection = null;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      if (callEnd) {
-        Internal.instance.timeoutExit(call, null);
-      }
-      eventListener.connectionReleased(call, releasedConnection);
-      if (callEnd) {
-        eventListener.callEnd(call);
-      }
-    }
-  }
-
-  public void cancel() {
-    HttpCodec codecToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      codecToCancel = codec;
-      connectionToCancel = connectingConnection != null ? connectingConnection : connection;
-    }
-    if (codecToCancel != null) {
-      codecToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
-    }
-  }
-
-  public void releaseStreamForException() {
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException();
-      this.codec = null;
-    }
-  }
-
-  public void streamFailed(IOException e) {
-    synchronized (connectionPool) {
-      hasStreamFailure = true;
-      if (connection != null) {
-        connection.trackFailure(e);
-      }
-    }
-  }
-
-  /**
-   * Use this allocation to hold {@code connection}. Each use of this must be paired with a call to
-   * {@link #transmitterReleaseConnection} on the same connection.
-   */
-  public void transmitterAcquireConnection(RealConnection connection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (this.connection != null) throw new IllegalStateException();
-
-    this.connection = connection;
-    connection.transmitters.add(new TransmitterReference(transmitter, callStackTrace));
-  }
-
-  /**
-   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
-   * caller should close.
-   */
-  private @Nullable Socket transmitterReleaseConnection() {
-    int index = -1;
-    for (int i = 0, size = connection.transmitters.size(); i < size; i++) {
-      Reference<Transmitter> reference = connection.transmitters.get(i);
-      if (reference.get() == transmitter) {
-        index = i;
-        break;
-      }
-    }
-
-    if (index == -1) throw new IllegalStateException();
-
-    RealConnection released = this.connection;
-    released.transmitters.remove(index);
-    this.connection = null;
-
-    if (released.transmitters.isEmpty()) {
-      released.idleAtNanos = System.nanoTime();
-      if (connectionPool.connectionBecameIdle(released)) {
-        return released.socket();
-      }
-    }
-
-    return null;
-  }
-
-  public boolean canRetry() {
-    synchronized (connectionPool) {
-      // Don't try if the failure wasn't our fault!
-      if (!hasStreamFailure) return false;
-
-      return retryCurrentRoute()
-          || (routeSelection != null && routeSelection.hasNext())
-          || routeSelector.hasNext();
-    }
-  }
-
-  /**
-   * Return true if the route used for the current connection should be retried, even if the
-   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
-   * coalesced connections.
-   */
-  private boolean retryCurrentRoute() {
-    return connection != null
-        && connection.routeFailureCount == 0
-        && Util.sameConnection(connection.route().address().url(), address.url());
-  }
-
-  @Override public String toString() {
-    RealConnection connection = connection();
-    return connection != null ? connection.toString() : address.toString();
-  }
-}
@@ -20,9 +20,8 @@
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Transmitter;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.duplex.DuplexRequestBody;
 import okio.BufferedSink;
 import okio.Okio;
@@ -37,77 +36,73 @@ public CallServerInterceptor(boolean forWebSocket) {
 
   @Override public Response intercept(Chain chain) throws IOException {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Transmitter transmitter = realChain.transmitter();
+    Exchange exchange = realChain.exchange();
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
 
-    transmitter.writeRequestHeaders(request);
+    exchange.writeRequestHeaders(request);
 
     Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
       // If there's a ""Expect: 100-continue"" header on the request, wait for a ""HTTP/1.1 100
       // Continue"" response before transmitting the request body. If we don't get that, return
       // what we did get (such as a 4xx response) without ever transmitting the request body.
       if (""100-continue"".equalsIgnoreCase(request.header(""Expect""))) {
-        transmitter.flushRequest();
-        responseBuilder = transmitter.readResponseHeaders(true);
+        exchange.flushRequest();
+        responseBuilder = exchange.readResponseHeaders(true);
       }
 
       if (responseBuilder == null) {
         if (request.body() instanceof DuplexRequestBody) {
           // Prepare a duplex body so that the application can send a request body later.
-          transmitter.flushRequest();
-          BufferedSink bufferedRequestBody = Okio.buffer(transmitter.createRequestBody(request));
+          exchange.flushRequest();
+          BufferedSink bufferedRequestBody = Okio.buffer(exchange.createRequestBody(request));
           request.body().writeTo(bufferedRequestBody);
         } else {
           // Write the request body if the ""Expect: 100-continue"" expectation was met.
-          BufferedSink bufferedRequestBody = Okio.buffer(transmitter.createRequestBody(request));
+          BufferedSink bufferedRequestBody = Okio.buffer(exchange.createRequestBody(request));
           request.body().writeTo(bufferedRequestBody);
           bufferedRequestBody.close();
         }
-      } else if (!transmitter.isConnectionMultiplexed()) {
+      } else if (!exchange.connection().isMultiplexed()) {
         // If the ""Expect: 100-continue"" expectation wasn't met, prevent the HTTP/1 connection
         // from being reused. Otherwise we're still obligated to transmit the request body to
         // leave the connection in a consistent state.
-        transmitter.noNewStreamsOnConnection();
+        exchange.noNewExchangesOnConnection();
       }
     }
 
     if (!(request.body() instanceof DuplexRequestBody)) {
-      transmitter.finishRequest();
+      exchange.finishRequest();
     }
 
     if (responseBuilder == null) {
-      responseBuilder = transmitter.readResponseHeaders(false);
+      responseBuilder = exchange.readResponseHeaders(false);
     }
 
-    responseBuilder
+    Response response = responseBuilder
         .request(request)
-        .handshake(transmitter.handshake())
+        .handshake(exchange.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis());
-    Internal.instance.initDeferredTrailers(responseBuilder, transmitter.deferredTrailers());
-    Response response = responseBuilder.build();
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build();
 
     int code = response.code();
     if (code == 100) {
       // server sent a 100-continue even though we did not request one.
       // try again to read the actual response
-      responseBuilder = transmitter.readResponseHeaders(false);
-
-      responseBuilder
+      response = exchange.readResponseHeaders(false)
           .request(request)
-          .handshake(transmitter.handshake())
+          .handshake(exchange.connection().handshake())
           .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(System.currentTimeMillis());
-      Internal.instance.initDeferredTrailers(responseBuilder, transmitter.deferredTrailers());
-      response = responseBuilder.build();
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
 
       code = response.code();
     }
 
-    transmitter.responseHeadersEnd(response);
+    exchange.responseHeadersEnd(response);
 
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
@@ -116,13 +111,13 @@ public CallServerInterceptor(boolean forWebSocket) {
           .build();
     } else {
       response = response.newBuilder()
-          .body(transmitter.openResponseBody(response))
+          .body(exchange.openResponseBody(response))
           .build();
     }
 
     if (""close"".equalsIgnoreCase(response.request().header(""Connection""))
         || ""close"".equalsIgnoreCase(response.header(""Connection""))) {
-      transmitter.noNewStreamsOnConnection();
+      exchange.noNewExchangesOnConnection();
     }
 
     if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
@@ -16,6 +16,7 @@
 package okhttp3.internal.http;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -53,7 +54,7 @@ public interface HttpCodec {
    * @param expectContinue true to return null if this is an intermediate response with a ""100""
    *     response code. Otherwise this method never returns null.
    */
-  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
+  @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
 
   long reportedContentLength(Response response) throws IOException;
 
@@ -25,7 +25,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Transmitter;
-import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.Exchange;
 
 import static okhttp3.internal.Util.checkDuration;
 
@@ -39,7 +39,7 @@
 public final class RealInterceptorChain implements Interceptor.Chain {
   private final List<Interceptor> interceptors;
   private final Transmitter transmitter;
-  private final @Nullable RealConnection connection;
+  private final @Nullable Exchange exchange;
   private final int index;
   private final Request request;
   private final Call call;
@@ -49,11 +49,11 @@ public final class RealInterceptorChain implements Interceptor.Chain {
   private int calls;
 
   public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmitter,
-      @Nullable RealConnection connection, int index, Request request, Call call,
+      @Nullable Exchange exchange, int index, Request request, Call call,
       int connectTimeout, int readTimeout, int writeTimeout) {
     this.interceptors = interceptors;
     this.transmitter = transmitter;
-    this.connection = connection;
+    this.exchange = exchange;
     this.index = index;
     this.request = request;
     this.call = call;
@@ -62,8 +62,8 @@ public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmit
     this.writeTimeout = writeTimeout;
   }
 
-  @Override public Connection connection() {
-    return connection;
+  @Override public @Nullable Connection connection() {
+    return exchange != null ? exchange.connection() : null;
   }
 
   @Override public int connectTimeoutMillis() {
@@ -72,7 +72,7 @@ public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmit
 
   @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
     int millis = checkDuration(""timeout"", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, connection, index, request, call,
+    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
         millis, readTimeout, writeTimeout);
   }
 
@@ -82,7 +82,7 @@ public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmit
 
   @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
     int millis = checkDuration(""timeout"", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, connection, index, request, call,
+    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
         connectTimeout, millis, writeTimeout);
   }
 
@@ -92,14 +92,19 @@ public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmit
 
   @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
     int millis = checkDuration(""timeout"", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, connection, index, request, call,
+    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
         connectTimeout, readTimeout, millis);
   }
 
   public Transmitter transmitter() {
     return transmitter;
   }
 
+  public Exchange exchange() {
+    if (exchange == null) throw new IllegalStateException();
+    return exchange;
+  }
+
   @Override public Call call() {
     return call;
   }
@@ -109,35 +114,35 @@ public Transmitter transmitter() {
   }
 
   @Override public Response proceed(Request request) throws IOException {
-    return proceed(request, transmitter, connection);
+    return proceed(request, transmitter, exchange);
   }
 
-  public Response proceed(Request request, Transmitter transmitter, RealConnection connection)
+  public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange)
       throws IOException {
     if (index >= interceptors.size()) throw new AssertionError();
 
     calls++;
 
     // If we already have a stream, confirm that the incoming request will use it.
-    if (this.connection != null && !this.transmitter.supportsUrl(request.url())) {
+    if (this.exchange != null && !this.exchange.connection().supportsUrl(request.url())) {
       throw new IllegalStateException(""network interceptor "" + interceptors.get(index - 1)
           + "" must retain the same host and port"");
     }
 
     // If we already have a stream, confirm that this is the only call to chain.proceed().
-    if (this.connection != null && calls > 1) {
+    if (this.exchange != null && calls > 1) {
       throw new IllegalStateException(""network interceptor "" + interceptors.get(index - 1)
           + "" must call proceed() exactly once"");
     }
 
     // Call the next interceptor in the chain.
-    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, connection,
+    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange,
         index + 1, request, call, connectTimeout, readTimeout, writeTimeout);
     Interceptor interceptor = interceptors.get(index);
     Response response = interceptor.intercept(next);
 
     // Confirm that the next interceptor made its required call to chain.proceed().
-    if (connection != null && index + 1 < interceptors.size() && next.calls != 1) {
+    if (exchange != null && index + 1 < interceptors.size() && next.calls != 1) {
       throw new IllegalStateException(""network interceptor "" + interceptor
           + "" must call proceed() exactly once"");
     }
@@ -23,6 +23,7 @@
 import java.net.Proxy;
 import java.net.SocketTimeoutException;
 import java.security.cert.CertificateException;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.HttpUrl;
@@ -32,7 +33,9 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.Route;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Transmitter;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.connection.RouteException;
 import okhttp3.internal.http2.ConnectionShutdownException;
 
@@ -99,7 +102,7 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
       } finally {
         // The network call threw an exception. Release any resources.
         if (!success) {
-          transmitter.releaseStreamForException();
+          transmitter.exchangeDoneDueToException();
         }
       }
 
@@ -114,7 +117,9 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
 
       Request followUp;
       try {
-        followUp = followUpRequest(response, transmitter.route());
+        Exchange exchange = Internal.instance.exchange(response);
+        Route route = exchange != null ? exchange.connection().route() : null;
+        followUp = followUpRequest(response, route);
       } catch (IOException e) {
         throw e;
       }
@@ -125,7 +130,7 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
 
       closeQuietly(response.body());
 
-      if (transmitter.hasCodec()) {
+      if (transmitter.hasExchange()) {
         throw new IllegalStateException(""Closing the body of "" + response
             + "" didn't close its backing stream. Bad interceptor?"");
       }
@@ -209,7 +214,7 @@ private boolean isRecoverable(IOException e, boolean requestSendStarted) {
    * either add authentication headers, follow redirects or handle a client request timeout. If a
    * follow-up is either unnecessary or not applicable, this returns null.
    */
-  private Request followUpRequest(Response userResponse, Route route) throws IOException {
+  private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException {
     if (userResponse == null) throw new IllegalStateException();
     int responseCode = userResponse.code();
 
@@ -273,7 +273,7 @@ private Source newChunkedSource(HttpUrl url) {
   private Source newUnknownLengthSource() {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    realConnection.noNewStreams();
+    realConnection.noNewExchanges();
     return new UnknownLengthSource();
   }
 
@@ -380,7 +380,7 @@ private abstract class AbstractSource implements Source {
       try {
         return source.read(sink, byteCount);
       } catch (IOException e) {
-        realConnection.noNewStreams();
+        realConnection.noNewExchanges();
         responseBodyComplete();
         throw e;
       }
@@ -418,7 +418,7 @@ private class FixedLengthSource extends AbstractSource {
 
       long read = super.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        realConnection.noNewStreams(); // The server didn't supply the promised content length.
+        realConnection.noNewExchanges(); // The server didn't supply the promised content length.
         ProtocolException e = new ProtocolException(""unexpected end of stream"");
         responseBodyComplete();
         throw e;
@@ -435,7 +435,7 @@ private class FixedLengthSource extends AbstractSource {
       if (closed) return;
 
       if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        realConnection.noNewStreams(); // Unread bytes remain on the stream.
+        realConnection.noNewExchanges(); // Unread bytes remain on the stream.
         responseBodyComplete();
       }
 
@@ -466,7 +466,7 @@ private class ChunkedSource extends AbstractSource {
 
       long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        realConnection.noNewStreams(); // The server didn't supply the promised chunk length.
+        realConnection.noNewExchanges(); // The server didn't supply the promised chunk length.
         ProtocolException e = new ProtocolException(""unexpected end of stream"");
         responseBodyComplete();
         throw e;
@@ -501,7 +501,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        realConnection.noNewStreams(); // Unread bytes remain on the stream.
+        realConnection.noNewExchanges(); // Unread bytes remain on the stream.
         responseBodyComplete();
       }
       closed = true;
@@ -38,8 +38,8 @@
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Transmitter;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.Exchange;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -190,25 +190,20 @@ public void connect(OkHttpClient client) {
     call.timeout().clearTimeout();
     call.enqueue(new Callback() {
       @Override public void onResponse(Call call, Response response) {
-        Transmitter transmitter = Internal.instance.transmitter(call);
-
+        Streams streams;
         try {
-          checkResponse(response);
-        } catch (ProtocolException e) {
+          streams = extractStreamsFromResponse(response);
+        } catch (IOException e) {
           failWebSocket(e, response);
           closeQuietly(response);
           return;
         }
 
-        // Promote the HTTP streams into web socket streams.
-        Streams streams = transmitter.newWebSocketStreams();
-
         // Process all web socket messages.
         try {
           String name = ""OkHttp WebSocket "" + request.url().redact();
           initReaderAndWriter(name, streams);
           listener.onOpen(RealWebSocket.this, response);
-          transmitter.socketTimeout(0);
           loopReader();
         } catch (Exception e) {
           failWebSocket(e, null);
@@ -221,7 +216,7 @@ public void connect(OkHttpClient client) {
     });
   }
 
-  void checkResponse(Response response) throws ProtocolException {
+  Streams extractStreamsFromResponse(Response response) throws IOException {
     if (response.code() != 101) {
       throw new ProtocolException(""Expected HTTP 101 response but was '""
           + response.code() + "" "" + response.message() + ""'"");
@@ -246,6 +241,12 @@ void checkResponse(Response response) throws ProtocolException {
       throw new ProtocolException(""Expected 'Sec-WebSocket-Accept' header value '""
           + acceptExpected + ""' but was '"" + headerAccept + ""'"");
     }
+
+    Exchange exchange = Internal.instance.exchange(response);
+    if (exchange == null) {
+      throw new ProtocolException(""Web Socket exchange missing: bad interceptor?"");
+    }
+    return exchange.newWebSocketStreams();
   }
 
   public void initReaderAndWriter(String name, Streams streams) throws IOException {
",True,"The commit message refers to the necessity of changes by mentioning the introduction of a new feature, Exchange, which is described as the payoff of previous changes. This new feature is mentioned to be the last big one, implying that the previous changes were working towards this introduction. Additionally, the message mentions that the refactoring isn't totally complete, but this should be the last big one, suggesting that the changes are significant and have been planned.",True,"The commit message refers to the introduction of a new component called 'Exchange', which is a single request/response pair. This change is significant because it splits the previous 'StreamAllocation' into three parts: 'ExchangeFinder', 'Exchange', and 'Transmitter'. This suggests that the code is being refactored to better separate concerns and improve modularity. The message does not explicitly mention adding test cases, typographic fixes, text file changes, annotations, refactorings, or version management, but the overall nature of the changes suggests that these activities may have been involved.",,,,,True,The commit message mentions the change will introduce a new class called 'Exchange' which is a single request/response pair. This indicates that the change is improving the code structure and organization by separating the concerns of a single request/response pair into its own class.,True,"The commit message describes the introduction of a new component called 'Exchange' which is a single request/response pair. This is a summary of the changes made in the code diff, pointing out the key components of the change, such as the introduction of the Exchange class and the removal of the Transmitter class.",True,"The commit message explains that the changes are introducing an 'Exchange' which is a single request/response pair. This is a technical principle that underpins the changes, as it separates the concerns of a single HTTP request/response pair from the concerns of managing a connection and its associated streams.",True,"The commit message expresses a renaming and specifies that the behavior only applies to JSON. The code diff shows that the Exchange class is introduced, which handles a single request/response pair. This is a significant change that affects the functional perspective of the code.",True,"The commit message does not provide an explicit explanation for the changes, but it is clear that the changes are related to refactoring the code to split StreamAllocation into three parts: ExchangeFinder, Exchange, and Transmitter. This refactoring is likely to improve the code's maintainability and scalability. The changes are also small and simple, so it is not necessary to provide an explicit explanation for them in the commit message."
https://github.com/square/okhttp/commit/e36d7ecc26be18021da3555fc8b14381df7af34d,"Fix flakiness in CallTest.cancelTagImmediatelyAfterEnqueue()  <enter> There's a race where the HTTP engine has been created, but not yet connected and the cancel isn't as immediate as it could be. Fix the test by making sure there's a response to be retrieved. <enter> With the upcoming connection pool changes we might make the implementation more robust. <enter>  Closes :  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/e36d7ecc26be18021da3555fc8b14381df7af34d,"@@ -1525,13 +1525,13 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
     Call call = client.newCall(new Request.Builder()
         .url(server.url(""/a""))
         .tag(""request"")
         .build());
     call.enqueue(callback);
     client.cancel(""request"");
-    assertEquals(0, server.getRequestCount());
     callback.await(server.url(""/a"")).assertFailure(""Canceled"");
   }
 
",True,"The commit message refers to a known issue in the code, which is the 'flakiness' in the CallTest.cancelTagImmediatelyAfterEnqueue() test. The message explains that there's a race condition where the HTTP engine has been created but not yet connected, causing the cancel not to be as immediate as it could be. The commit message then describes the fix, which is making sure there's a response to be retrieved. Additionally, the message mentions that with upcoming connection pool changes, the implementation might be made more robust, suggesting that the fix is a temporary solution and will be improved upon in the future.",False,"The commit message does not contain an expression that describes the necessity of changes by not offering a rationale. It clearly states the issue and the solution, which is fixing a race condition in the test. The message also mentions a potential future change, but it does not explain why the current change is necessary in the context of that future change.",True,"The commit message explains the issue that was being faced, which is the flakiness in the test CallTest.cancelTagImmediatelyAfterEnqueue(). It mentions that there's a race where the HTTP engine has been created but not yet connected, causing the cancel not to be as immediate as it could be. The message also elaborates on the solution, which is to make sure there's a response to be retrieved. This directly describes the necessity of the changes and the motivation behind them.",True,"The commit message 'Fix flakiness in CallTest.cancelTagImmediatelyAfterEnqueue()' indicates that the developer is addressing an issue of unpredictable or inconsistent test results, which is a common problem in software maintenance. The problem is described as a race condition where the HTTP engine has been created but not yet connected, causing the cancel not to be as immediate as it could be. This suggests that the changes are being made to improve the reliability and stability of the software.",True,"The commit message directly mentions the defect it fixes, which is the flakiness in the CallTest.cancelTagImmediatelyAfterEnqueue() method. The message explains that there's a race where the HTTP engine has been created but not yet connected, causing the cancel not to be as immediate as it could be. The commit message also describes the change made to the test, which is ensuring there's a response to be retrieved. This change is expected to make the implementation more robust with the upcoming connection pool changes.",True,"The commit message accurately summarizes the changes made in the diff. It mentions the issue of flakiness in the CallTest.cancelTagImmediatelyAfterEnqueue() test, which is caused by a race condition where the HTTP engine has not yet connected. The message then describes the fix, which involves making sure there's a response to be retrieved. The diff supports this explanation by showing the addition of a server.enqueue() call and the removal of an assertEquals() call, both of which are related to the fix described in the commit message.",False,The commit message does not explicitly describe a technical principle underpinning the changes. It mainly discusses the issue of flakiness in a test and the need to make sure there's a response to be retrieved to fix the test. It does not explain a fundamental concept or principle that the changes are based on.,True,"The commit message 'Fix flakiness in CallTest.cancelTagImmediatelyAfterEnqueue()' describes the issue that the test was flaky due to a race condition where the HTTP engine was not yet connected when the cancel was issued. The code changes made to the test ensure that there's a response to be retrieved, which should make the cancel more immediate. This change introduces a new behavior in the test, making it more robust and less likely to fail due to the race condition.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Fix flakiness in CallTest.cancelTagImmediatelyAfterEnqueue()'. The explanation provided in the message is that there's a race where the HTTP engine has been created but not yet connected, causing the cancel not to be as immediate as it could be. The commit message also mentions that the test is being fixed by making sure there's a response to be retrieved. This explanation is not easily inferred from the code diff, as the change is not as obvious as a simple space removal."
https://github.com/spring-projects/spring-boot/commit/8a0f0354dfed2fc6d4cb1b046ec03fe5b7ff1146,"Disable Log4J2's shutdown hook by default  <enter> Log4J2 enables its shutdown hook by default. When the JVM is exiting, this creates a race between logging that happens during the application context being closed and Log4J2 being shut down such that the logging is lost. <enter> This commit updates SpringBootConfigurationFactory so that it produces a custom sub-class of DefaultConfiguration that disables the shutdown hook by default. In addition to solving the problem described above, this also aligns the Log4J2 logging system with the logging.register-shutdown-hook property which defaults to false. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/8a0f0354dfed2fc6d4cb1b046ec03fe5b7ff1146,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -27,12 +27,18 @@
 import org.springframework.boot.logging.LoggingSystem;
 
 /**
- * Spring Boot {@link ConfigurationFactory} that prevents logger warnings from being
- * printed when the application first starts. This factory is ordered last and is
- * triggered by a {@code log4j2.springboot} classpath resource (which is bundled in this
- * jar). If the {@link Log4J2LoggingSystem} is active, a {@link DefaultConfiguration} is
- * returned with the expectation that the system will later re-initialize Log4J2 with the
- * correct configuration file.
+ * Spring Boot {@link ConfigurationFactory} that customizes Log4J2's default configuration
+ * to:
+ *
+ * <ol>
+ * <li>Prevent logger warnings from being printed when the application first starts.
+ * <li>Disable its shutdown hook
+ * </ol>
+ *
+ * This factory is ordered last and is triggered by a {@code log4j2.springboot} classpath
+ * resource (which is bundled in this jar). If the {@link Log4J2LoggingSystem} is active,
+ * a custom {@link DefaultConfiguration} is returned with the expectation that the system
+ * will later re-initialize Log4J2 with the correct configuration file.
  *
  * @author Phillip Webb
  * @since 1.5.0
@@ -53,10 +59,18 @@ public Configuration getConfiguration(LoggerContext loggerContext,
 			ConfigurationSource source) {
 		if (source != null && source != ConfigurationSource.NULL_SOURCE) {
 			if (LoggingSystem.get(loggerContext.getClass().getClassLoader()) != null) {
-				return new DefaultConfiguration();
+				return new SpringBootConfiguration();
 			}
 		}
 		return null;
 	}
 
+	private static final class SpringBootConfiguration extends DefaultConfiguration {
+
+		private SpringBootConfiguration() {
+			this.isShutdownHookEnabled = false;
+		}
+
+	}
+
 }
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.logging.log4j2;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.config.ConfigurationSource;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link SpringBootConfigurationFactory}.
+ *
+ * @author Andy Wilkinson
+ */
+public class SpringBootConfigurationFactoryTests {
+
+	@Test
+	public void producesConfigurationWithShutdownHookDisabled() throws IOException {
+		ConfigurationSource source = new ConfigurationSource(
+				new ByteArrayInputStream(new byte[0]));
+		assertThat(new SpringBootConfigurationFactory()
+				.getConfiguration(new LoggerContext(""""), source).isShutdownHookEnabled())
+						.isFalse();
+	}
+
+}
",True,The commit message refers to a problem with Log4J2's shutdown hook that causes logging to be lost during application context closure. The commit message explains that this change is necessary to solve this problem and also aligns the Log4J2 logging system with the logging.register-shutdown-hook property which defaults to false. This shows that the commit message is describing the necessity of changes by referencing a problem that exists and the solution implemented.,True,"The commit message explains the necessity of the changes by describing the problem that the changes are addressing. The problem is that Log4J2's shutdown hook can cause logging to be lost when the JVM is exiting. The changes made in the commit are to disable the shutdown hook by default to solve this problem. This is not a common sense or easy to infer change, as the default behavior of Log4J2 is to enable the shutdown hook, and the problem it can cause is not immediately obvious. The commit message also mentions that the changes align the Log4J2 logging system with the logging.register-shutdown-hook property which defaults to false. Additionally, the code diff shows that a new test case has been added to ensure that the shutdown hook is disabled by default.",True,The commit message directly elaborates the motivation of the code change by describing the problem scenario (logging being lost during application context closure due to a race between logging and Log4J2 shutdown) and mentioning the issue it resolves. It also explains the solution implemented (disabling Log4J2's shutdown hook by default) and how it aligns with another logging property.,True,"The commit message describes the necessity of changes by mentioning the problem of logging being lost during the application context being closed and Log4J2 being shut down. This issue is caused by Log4J2's shutdown hook being enabled by default, which creates a race condition. The commit message also mentions that this change aligns the Log4J2 logging system with the logging.register-shutdown-hook property which defaults to false, indicating that the change is being made to address an outdated or incorrect configuration.",True,"The commit message directly mentions the problem it solves, which is the race condition between logging during application context closure and Log4J2 shutdown, and the improvement it makes, which is disabling Log4J2's shutdown hook by default. This is clearly stated in the message and is also reflected in the code diff.",True,"The commit message accurately summarizes the changes made in the diff. It mentions the disabling of Log4J2's shutdown hook by default, which is a key component of the change. It also contrasts the before and after situation by mentioning that this change solves a problem where logging was lost during application context closure due to the JVM exiting and Log4J2 being shut down. The diff also supports this by showing the addition of a custom sub-class of DefaultConfiguration that disables the shutdown hook.",True,"The commit message explains that the changes are made to disable Log4J2's shutdown hook by default. This is a technical principle that is being implemented to solve a specific problem: the race condition between logging that happens during the application context being closed and Log4J2 being shut down, which can lead to lost logging. The code diff also supports this explanation by showing the addition of a private static class 'SpringBootConfiguration' that extends 'DefaultConfiguration' and sets 'isShutdownHookEnabled' to false.",True,The commit message 'Disable Log4J2's shutdown hook by default' accurately summarizes the code changes. It explains that the commit updates the SpringBootConfigurationFactory to produce a custom sub-class of DefaultConfiguration that disables the shutdown hook by default. This change addresses a problem where logging could be lost during application context closure due to a race between logging and Log4J2 shutdown. The message also mentions that this change aligns the Log4J2 logging system with the logging.register-shutdown-hook property which defaults to false. The code diff supports this explanation by showing the addition of a private static inner class SpringBootConfiguration that extends DefaultConfiguration and sets isShutdownHookEnabled to false.,False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Log4J2 enables its shutdown hook by default. When the JVM is exiting, this creates a race between logging that happens during the application context being closed and Log4J2 being shut down such that the logging is lost. This commit updates SpringBootConfigurationFactory so that it produces a custom sub-class of DefaultConfiguration that disables the shutdown hook by default.' This explanation is necessary to understand the purpose and impact of the change."
https://github.com/square/retrofit/commit/54c8e17ad51bd35e75009233c3be6cdc3afe310e,Update documentation for handling of @field and @part values. ,https://api.github.com/repos/square/retrofit/commits/54c8e17ad51bd35e75009233c3be6cdc3afe310e,"@@ -25,7 +25,9 @@
 /**
  * Named pair for a form-encoded request.
  * <p>
- * Values may be {@code null} which will omit them from the request body.
+ * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
+ * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
+ * field pair for each non-{@code null} item.
  * <p>
  * Simple Example:
  * <pre>
@@ -36,6 +38,15 @@
  * </pre>
  * Calling with {@code foo.example(""Bob Smith"", ""President"")} yields a request body of
  * {@code name=Bob+Smith&occupation=President}.
+ * <p>
+ * Array Example:
+ * <pre>
+ * &#64;FormUrlEncoded
+ * &#64;POST(""/list"")
+ * void example(@Field(""name"") String... names);
+ * </pre>
+ * Calling with {@code foo.example(""Bob Smith"", ""Jane Doe"")} yields a request body of
+ * {@code name=Bob+Smith&name=Jane+Doe}.
  *
  * @see FormUrlEncoded
  * @see FieldMap
@@ -35,6 +35,8 @@
  * retrofit.converter.Converter#toBody(Object)}.</li>
  * </ul>
  * <p>
+ * Values may be {@code null} which will omit them from the request body.
+ * <p>
  * <pre>
  * &#64;Multipart
  * &#64;POST(""/"")
@@ -26,9 +26,8 @@
  * Query parameter appended to the URL.
  * <p>
  * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
- * A {@link java.util.List List} or array will result in a query parameter for each value.
- * {@code null} as a value to the parameter or as a value in a list will not be included in the
- * URL.
+ * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
+ * query parameter for each non-{@code null} item.
  * <p>
  * Simple Example:
  * <pre>
",True,"The commit message refers to the necessity of changes by explaining how the handling of @field and @part values has been updated. It mentions that values are now converted to strings using String#valueOf(Object) and then form URL encoded. It also explains that null values are ignored and that passing a List or array will result in a field pair for each non-null item. This is an improvement over the previous behavior, which did not handle null values and Lists/arrays in the same way.",True,"The commit message 'Update documentation for handling of @field and @part values' does not explicitly state the necessity of the changes, but it is easy to infer from the code diff that the changes are being made to update the documentation to reflect the new behavior of the @field and @part values. This is a common practice in software development to ensure that the documentation accurately reflects the current state of the code.",True,"The commit message explains the necessity of changes by elaborating the motivation of a code change. It mentions that the changes are being made to the documentation to handle the @field and @part values differently. The code diff shows that the documentation has been updated to explain that values are now converted to strings using String#valueOf(Object) and then form URL encoded. Additionally, it explains that null values are ignored and that passing a List or array will result in a field pair for each non-null item. This change is likely necessary to address a shortcoming in the previous implementation, which did not properly handle null values and Lists/arrays.",True,"The commit message 'Update documentation for handling of @field and @part values' indicates that the changes are made to the documentation to reflect the changes in the codebase. This suggests that the changes are likely made to address the need for clearer documentation, which could be a result of user requirements or problems in the software maintenance process, such as outdated or confusing documentation.",True,"The commit message 'Update documentation for handling of @field and @part values' does contain an expression that describes the objective of the change. Specifically, it mentions that the change is updating the documentation to explain how values are converted to strings, how null values are handled, and how lists or arrays are processed. This indicates that the change is likely improving the clarity and accuracy of the documentation, which could be beneficial for users of the code.",True,"The commit message 'Update documentation for handling of @field and @part values' accurately summarizes the changes made in the diff. It specifically mentions the updates to the documentation for handling '@field' and '@part' values, which is a key component of the change. The message also contrasts the before and after scenarios by describing how values are now converted to strings and how null values are handled differently.",True,"The commit message explains that the changes are made to handle the conversion of values to strings and how null values are handled. It mentions that null values are ignored and that passing a List or array will result in a field or query parameter for each non-null item. This describes the technical principle underpinning the changes, which is the handling of data types and null values in the request body.",True,"The commit message 'Update documentation for handling of @field and @part values' does express a summary of the changes made to the documentation. It describes how values are converted to strings, how null values are handled, and how lists or arrays are processed. It also provides examples to illustrate these changes. Specifically, it introduces new behaviors such as the conversion of values to strings using String#valueOf(Object) and the handling of null values and lists or arrays.",False,"The commit message does not lack an explanation. It clearly states that the documentation is being updated to handle the '@field' and '@part' values. The code diff shows that the documentation has been updated to explain how values are converted to strings, how null values are handled, and how arrays and lists are handled. The commit message does not simply describe a small, simple change, but rather a significant update to the documentation."
https://github.com/junit-team/junit4/commit/16a2b51b9d9425cd7dacad85e2df97985996ca8d,"Disable parts of doclint for the site's javadoc.  <enter> This is a follow-up to  <otherCommit_link> . That commit is missing to apply the doclint rules to site generation. Hence the site goal fails because of doclint issues. Now doclint is disabled for all groups but accessibility and reference for the site generation, too. ",https://api.github.com/repos/junit-team/junit4/commits/16a2b51b9d9425cd7dacad85e2df97985996ca8d,"@@ -514,6 +514,16 @@
                     </plugin>
                 </plugins>
             </build>
+            <reporting>
+                <plugins>
+                    <plugin>
+                        <artifactId>maven-javadoc-plugin</artifactId>
+                        <configuration>
+                            <additionalparam>-Xdoclint:accessibility -Xdoclint:reference</additionalparam>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </reporting>
         </profile>
         <profile>
             <id>fast-tests</id>
",True,The commit message refers to a convention (doclint rules) that was not applied in a prior commit (otherCommit_link). The commit message explains why the changes were made: to disable parts of doclint for the site's javadoc to allow the site goal to succeed without doclint issues. The code diff supports this explanation by adding configuration to disable certain doclint rules for the site generation.,True,"The commit message explains the necessity of the changes by stating that the site's javadoc generation was failing due to doclint issues. This is not a common sense or easy to infer change, as it requires specific configuration to disable certain doclint rules for the site generation. The code diff also supports this explanation by showing the addition of configuration to disable doclint for the site's javadoc.",True,"The commit message explains the motivation for the code change by mentioning the issue that arose in a previous commit. It states that the site goal was failing due to doclint issues, and that this commit is a follow-up to another commit that was missing the application of doclint rules to site generation. The commit message also elaborates on the necessity of the changes by stating that doclint is now disabled for all groups but accessibility and reference for the site generation, which should resolve the issue.",True,"The commit message indicates that the changes were made due to a problem in the software maintenance process. The problem is that the doclint rules were not applied to site generation in a previous commit, causing the site goal to fail due to doclint issues. This suggests that the outdated code was the source of the requirement for the changes.",True,"The commit message directly mentions the defect it fixes, which is the failure of the site goal due to doclint issues. It also mentions that doclint is now disabled for all groups but accessibility and reference for the site generation, which is an improvement to the code.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions disabling parts of doclint for the site's javadoc, which is the key component of the change. It also contrasts the before and after state by mentioning that doclint was previously enabled for site generation and is now disabled for all groups except accessibility and reference. The code diff supports this by adding a new reporting section that configures the maven-javadoc-plugin to only apply certain doclint rules.",True,"The commit message explains that the changes are made to disable certain rules of doclint for the site's javadoc. This is done to allow the site generation to proceed without failing due to doclint issues. The technical principle underpinning the changes is to balance the need for documentation quality (as enforced by doclint) with the need to generate the site successfully. By selectively disabling certain doclint rules, the commit message is describing a trade-off between these two principles.",True,"The commit message clearly explains the changes made to the code. It mentions that it is disabling parts of doclint for the site's javadoc, which is a functional change. It also explains the reason for this change, referring to a previous commit where doclint rules were not applied to site generation. The message also introduces new behavior by specifying that doclint is now disabled for all groups but accessibility and reference for the site generation, too.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'That commit is missing to apply the doclint rules to site generation. Hence the site goal fails because of doclint issues. Now doclint is disabled for all groups but accessibility and reference for the site generation, too.' This explanation is necessary because the change is not a simple one-line fix, but rather a modification to the project's configuration to disable certain rules for the site's javadoc."
https://github.com/square/okhttp/commit/5569a0d20f4669ddde8227d8777de54ddf373181,Remove obsolete @JvmField ,https://api.github.com/repos/square/okhttp/commits/5569a0d20f4669ddde8227d8777de54ddf373181,"@@ -38,8 +38,7 @@ internal class RealCall private constructor(
   val client: OkHttpClient,
   /** The application's original request unadulterated by redirects or auth headers.  */
   val originalRequest: Request,
-  // TODO(egorand): Remove @JvmField once Dispatcher.java is converted to Kotlin
-  @JvmField val forWebSocket: Boolean
+  val forWebSocket: Boolean
 ) : Call {
   /**
    * There is a cycle between the [Call] and [Transmitter] that makes this awkward.
",True,The commit message refers to a TODO comment in the code that mentions removing the @JvmField annotation once Dispatcher.java is converted to Kotlin. This implies that the @JvmField annotation is no longer necessary because Kotlin does not require it for interoperability with Java. This explains the necessity of the changes and references a convention or standard (Kotlin interoperability with Java) that justifies the removal of the annotation.,True,The commit message 'Remove obsolete @JvmField' clearly describes the change without providing a rationale. The change is removing an annotation that is no longer necessary because the Java code that was using it has been converted to Kotlin. This is a common refactoring step to clean up code and make it more idiomatic to the language being used.,False,"The commit message does not explicitly describe the necessity of changes. It only mentions the removal of '@JvmField' annotation, which is a Kotlin feature used to expose Java-compatible fields. However, the code diff does not indicate any functional issues or errors that could have been resolved by this change. Therefore, the message does not directly elaborate the motivation of the code change.",True,"The commit message 'Remove obsolete @JvmField' indicates that the developer is removing the '@JvmField' annotation from the 'forWebSocket' variable. This change is likely due to the need to modernize the codebase, as '@JvmField' is not necessary in Kotlin and can be removed to simplify the code. The comment 'TODO(egorand): Remove @JvmField once Dispatcher.java is converted to Kotlin' in the code diff also suggests that the '@JvmField' annotation is no longer needed because the 'Dispatcher.java' file is being converted to Kotlin.",True,"The commit message 'Remove obsolete @JvmField' directly mentions the change that is being made to the code, which is the removal of an annotation that is no longer necessary. This change is likely made to simplify the code and remove unnecessary elements, which can be considered as an improvement to the codebase.",True,"The commit message 'Remove obsolete @JvmField' accurately summarizes the change in the diff, which is the removal of the '@JvmField' annotation from the 'forWebSocket' property. This change is a key component of the modification, and the message clearly contrasts the before and after state of the code.",True,The commit message 'Remove obsolete @JvmField' suggests that the change is being made to improve the codebase by removing unnecessary annotations. The code diff shows that the '@JvmField' annotation is being removed from the 'forWebSocket' property. This is likely done to follow Kotlin's best practices and to make the code more idiomatic to Kotlin. The technical principle underpinning this change is likely 'Write idiomatic Kotlin code' or 'Follow Kotlin's best practices for interoperability with Java'.,True,"The commit message 'Remove obsolete @JvmField' accurately describes the code change, which is the removal of the '@JvmField' annotation from the 'forWebSocket' property. This change does not introduce any new behaviors or functionalities, but it simplifies the code by removing an annotation that is no longer necessary.",True,"The commit message explicitly states that the '@JvmField' annotation is being removed because it is obsolete. The code diff also clearly shows this change. Since the reason for the change is clearly stated in the commit message and the code diff, there was no need for an additional explanation."
https://github.com/square/retrofit/commit/26d19ea8877696a253be8c00b2baed6b359baaa2,Java 7 is required since <otherCommit_link> ,https://api.github.com/repos/square/retrofit/commits/26d19ea8877696a253be8c00b2baed6b359baaa2,"@@ -24,7 +24,7 @@ compile 'com.squareup.retrofit:retrofit:1.9.0'
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
-Retrofit requires at minimum Java 6 or Android 2.3.
+Retrofit requires at minimum Java 7 or Android 2.3.
 
 
 
",True,The commit message refers to a convention or standard (Java 7 is required) and also mentions a prior commit (<otherCommit_link>). This indicates that the changes made in the commit are necessary to address a problem or improvement mentioned in the referenced commit.,True,"The commit message explicitly states the reason for the change, which is that Java 7 is now required due to changes made in a previous commit. This is a clear and concise explanation of the necessity for the changes, making it unnecessary to infer the reason from the code diff.",True,"The commit message directly elaborates the motivation of the code change by stating that Java 7 is required due to a change in the previous commit. This implies that the previous implementation may not have been compatible with Java 7, which necessitates the change.",True,"The commit message 'Java 7 is required since <otherCommit_link>' indicates that the change in the code diff is necessary due to a change in the development environment. Specifically, the message states that Java 7 is now required to run the Retrofit library, which was previously compatible with Java 6. This suggests that the change is made to address a problem in the software maintenance process, namely, the outdated code that was not compatible with the newer version of Java.",True,"The commit message directly mentions the change made to the code, which is increasing the minimum Java version required from 6 to 7. This change is likely made to fix a compatibility issue or to take advantage of new features introduced in Java 7.",True,"The commit message 'Java 7 is required since <otherCommit_link>' accurately summarizes the change in the diff, which is the update of the minimum Java version required from Java 6 to Java 7. This is a clear and concise summary of the change, pointing out the key component that was modified.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that the minimum Java version required has been increased from Java 6 to Java 7. This is a change in a configuration or dependency, not a change in the underlying code or implementation.",True,The commit message clearly states that the change is an update to the minimum Java version requirement for Retrofit. This change introduces new behavior as it restricts the usage of Retrofit to environments that support Java 7 or higher. The code diff also supports this explanation by showing the change from Java 6 to Java 7.,True,"The commit message explicitly states the reason for the change, which is to update the minimum Java version required to Java 7. This is a significant change that cannot be easily inferred from the code diff, which only shows a single line modification. Therefore, the commit message does not lack an explanation."
https://github.com/square/okhttp/commit/4ab6a8258b0df3a3528029f810e1f48952dba2d7,Remove old SSL protocol method. ,https://api.github.com/repos/square/okhttp/commits/4ab6a8258b0df3a3528029f810e1f48952dba2d7,"@@ -16,9 +16,8 @@
 
 package com.squareup.okhttp.mockwebserver;
 
-import com.squareup.okhttp.TlsVersion;
-import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.TlsVersion;
 import java.net.Socket;
 import java.util.ArrayList;
 import java.util.List;
@@ -135,11 +134,6 @@ public int getSequenceNumber() {
     return sequenceNumber;
   }
 
-  /** @deprecated Use {@link #getTlsVersion()}. */
-  public String getSslProtocol() {
-    return tlsVersion != null ? Internal.instance.tlsVersionJavaName(tlsVersion) : null;
-  }
-
   /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
   public TlsVersion getTlsVersion() {
     return tlsVersion;
@@ -120,10 +120,6 @@ public class OkHttpClient implements Cloneable {
         connection.connectAndSetOwner(client, owner, request);
       }
 
-      @Override public String tlsVersionJavaName(TlsVersion tlsVersion) {
-        return tlsVersion.javaName;
-      }
-
       @Override
       public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
         call.enqueue(responseCallback, forWebSocket);
@@ -23,7 +23,6 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
-import com.squareup.okhttp.TlsVersion;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
@@ -70,8 +69,6 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
   public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
       HttpEngine owner, Request request) throws IOException;
 
-  public abstract String tlsVersionJavaName(TlsVersion tlsVersion);
-
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
   public abstract void callEngineReleaseConnection(Call call) throws IOException;
",True,"The commit message 'Remove old SSL protocol method' refers to the necessity of changes by mentioning the removal of an old SSL protocol method. This is likely done to improve security and adhere to modern standards, as the old method may be outdated or less secure.",True,"The commit message 'Remove old SSL protocol method' clearly describes the necessity of the changes. The code diff shows that the method 'getSslProtocol' and its associated import statements are being removed. This is likely because the method was deprecated in favor of 'getTlsVersion', which is still present in the code. This is a common practice in software development where old, deprecated methods are removed to improve code clarity and maintainability.",False,"The commit message 'Remove old SSL protocol method' does not directly elaborate the motivation of the code change. It does not mention any error scenario, issue report, or shortcoming of the previous implementation. Instead, it simply states that an old SSL protocol method is being removed, without providing any context or explanation for why this change is necessary.",True,"The commit message 'Remove old SSL protocol method' indicates that the changes were made due to the need to update the codebase. The outdated SSL protocol method was removed, likely because it was no longer supported or considered secure. This is a common requirement in software maintenance to ensure the codebase remains up-to-date and secure.",True,"The commit message 'Remove old SSL protocol method' directly mentions the change that it is making to the code, which is the removal of an old SSL protocol method. This implies that the change is being made to improve the codebase, likely by simplifying it and removing outdated or unnecessary code.",True,"The commit message 'Remove old SSL protocol method' accurately summarizes the changes in the diff. It clearly states that an old SSL protocol method is being removed, which is consistent with the deletion of the 'getSslProtocol' method and the associated import statement for 'TlsVersion' and 'Internal'.",True,"The commit message 'Remove old SSL protocol method' indicates that the changes are related to the deprecation and removal of an outdated SSL protocol method. This suggests that the technical principle underpinning the changes is the need to update and modernize the codebase to use more secure and up-to-date protocols, which is a common technical principle in software development.",True,"The commit message 'Remove old SSL protocol method' accurately describes the code changes. The code diff shows that the method 'getSslProtocol' and its associated import statements have been removed. This change implies that the old way of retrieving the SSL protocol is no longer supported, and the new method 'getTlsVersion' should be used instead. This change introduces a new behavior where the SSL protocol can be retrieved using the 'TlsVersion' enum, which is a more modern and secure way of handling SSL protocols.",False,"The commit message removed an old SSL protocol method, which is a significant change. The removal of this method could potentially break existing functionality, as it was previously used to retrieve the SSL protocol version. The commit message does not explicitly explain why this method was removed, which could lead to confusion for other developers who review the code changes."
https://github.com/square/okhttp/commit/18b2660873ed8f028ee72981c882ed676aa08030,"New CertificateAuthorityCouncil class to normalize certificate chains.  <enter> The goal of this is to get the root CA certificate into the certificate chain, so that it can be considered by the certificate pinner. The work to integrate CertificateAuthorityCouncil with CertificatePinner will come in a follow-up PR. <enter> See:  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/18b2660873ed8f028ee72981c882ed676aa08030,"@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+import java.util.UUID;
+import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+/**
+ * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
+ * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
+ * held certificates, as done in practice by certificate authorities.
+ */
+public final class HeldCertificate {
+  public final X509Certificate certificate;
+  public final KeyPair keyPair;
+
+  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public static final class Builder {
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private final long duration = 1000L * 60 * 60 * 24; // One day.
+    private String hostname;
+    private String serialNumber = ""1"";
+    private KeyPair keyPair;
+    private HeldCertificate issuedBy;
+
+    public Builder serialNumber(String serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /**
+     * Set this certificate's hostname. This is the CN (common name) in the certificate. Will be a
+     * random string if no value is provided.
+     */
+    public Builder hostname(String hostname) {
+      this.hostname = hostname;
+      return this;
+    }
+
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
+     * generated.
+     */
+    public Builder issuedBy(HeldCertificate signedBy) {
+      this.issuedBy = signedBy;
+      return this;
+    }
+
+    public HeldCertificate build() throws GeneralSecurityException {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+      X500Principal subject = hostname != null
+          ? new X500Principal(""CN="" + hostname)
+          : new X500Principal(""CN="" + UUID.randomUUID());
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (issuedBy != null) {
+        signedByKeyPair = issuedBy.keyPair;
+        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long now = System.currentTimeMillis();
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(new BigInteger(serialNumber));
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(now));
+      generator.setNotAfter(new Date(now + duration));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm(""SHA256WithRSAEncryption"");
+      X509Certificate certificate = generator.generateX509Certificate(
+          signedByKeyPair.getPrivate(), ""BC"");
+      return new HeldCertificate(certificate, heldKeyPair);
+    }
+
+    public KeyPair generateKeyPair() throws GeneralSecurityException {
+      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
+      keyPairGenerator.initialize(1024, new SecureRandom());
+      return keyPairGenerator.generateKeyPair();
+    }
+  }
+}
@@ -13,29 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package okhttp3.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.math.BigInteger;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
 import java.security.KeyStore;
 import java.security.SecureRandom;
-import java.security.Security;
 import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.Date;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
-import javax.security.auth.x500.X500Principal;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
 
 /**
  * Constructs an SSL context for testing. This uses Bouncy Castle to generate a self-signed
@@ -45,16 +35,8 @@
  * instances where possible.
  */
 public final class SslContextBuilder {
-  static {
-    Security.addProvider(new BouncyCastleProvider());
-  }
-
-  private static final long ONE_DAY_MILLIS = 1000L * 60 * 60 * 24;
   private static SSLContext localhost; // Lazily initialized.
-
   private final String hostName;
-  private long notBefore = System.currentTimeMillis();
-  private long notAfter = System.currentTimeMillis() + ONE_DAY_MILLIS;
 
   /**
    * @param hostName the subject of the host. For TLS this should be the domain name that the client
@@ -79,17 +61,19 @@ public static synchronized SSLContext localhost() {
   }
 
   public SSLContext build() throws GeneralSecurityException {
-    char[] password = ""password"".toCharArray();
-
-    // Generate public and private keys and use them to make a self-signed certificate.
-    KeyPair keyPair = generateKeyPair();
-    X509Certificate certificate = selfSignedCertificate(keyPair, ""1"");
+    // Generate a self-signed cert for the server to serve and the client to trust.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .hostname(hostName)
+        .build();
 
-    // Put 'em in a key store.
+    // Put the certificate in a key store.
+    char[] password = ""password"".toCharArray();
     KeyStore keyStore = newEmptyKeyStore(password);
-    Certificate[] certificateChain = {certificate};
-    keyStore.setKeyEntry(""private"", keyPair.getPrivate(), password, certificateChain);
-    keyStore.setCertificateEntry(""cert"", certificate);
+    Certificate[] certificateChain = {heldCertificate.certificate};
+    keyStore.setKeyEntry(""private"",
+        heldCertificate.keyPair.getPrivate(), password, certificateChain);
+    keyStore.setCertificateEntry(""cert"", heldCertificate.certificate);
 
     // Wrap it up in an SSL context.
     KeyManagerFactory keyManagerFactory =
@@ -104,32 +88,6 @@ public SSLContext build() throws GeneralSecurityException {
     return sslContext;
   }
 
-  public KeyPair generateKeyPair() throws GeneralSecurityException {
-    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
-    keyPairGenerator.initialize(1024, new SecureRandom());
-    return keyPairGenerator.generateKeyPair();
-  }
-
-  /**
-   * Generates a certificate for {@code hostName} containing {@code keyPair}'s public key, signed by
-   * {@code keyPair}'s private key.
-   */
-  @SuppressWarnings(""deprecation"") // use the old Bouncy Castle APIs to reduce dependencies.
-  public X509Certificate selfSignedCertificate(KeyPair keyPair, String serialNumber)
-      throws GeneralSecurityException {
-    X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-    X500Principal issuer = new X500Principal(""CN="" + hostName);
-    X500Principal subject = new X500Principal(""CN="" + hostName);
-    generator.setSerialNumber(new BigInteger(serialNumber));
-    generator.setIssuerDN(issuer);
-    generator.setNotBefore(new Date(notBefore));
-    generator.setNotAfter(new Date(notAfter));
-    generator.setSubjectDN(subject);
-    generator.setPublicKey(keyPair.getPublic());
-    generator.setSignatureAlgorithm(""SHA256WithRSAEncryption"");
-    return generator.generateX509Certificate(keyPair.getPrivate(), ""BC"");
-  }
-
   private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
     try {
       KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.cert.Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.tls.CertificateAuthorityCouncil;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class CertificateAuthorityCouncilTest {
+  @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(root), council.normalizeCertificateChain(list(root)));
+  }
+
+  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil();
+
+    try {
+      council.normalizeCertificateChain(list(root));
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certB, certA, root),
+        council.normalizeCertificateChain(list(certB, certA, root)));
+  }
+
+  @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certB, certA, root),
+        council.normalizeCertificateChain(list(certB, certA))); // Root is added!
+  }
+
+  @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber(""4"")
+        .issuedBy(certB)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        council.normalizeCertificateChain(list(certC, certA, root, certB)));
+  }
+
+  @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber(""4"")
+        .issuedBy(certB)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        council.normalizeCertificateChain(list(certC, certA, certB)));
+  }
+
+  @Test public void unrelatedCertificatesAreOmitted() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certUnnecessary = new HeldCertificate.Builder()
+        .serialNumber(""4"")
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    assertEquals(list(certB, certA, root),
+        council.normalizeCertificateChain(list(certB, certUnnecessary, certA, root)));
+  }
+
+  @Test public void unnecessaryTrustedCertificatesAreOmitted() throws Exception {
+    HeldCertificate superRoot = new HeldCertificate.Builder()
+        .serialNumber(""1"")
+        .build();
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber(""2"")
+        .issuedBy(superRoot)
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber(""3"")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber(""4"")
+        .issuedBy(certA)
+        .build();
+
+    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(
+        superRoot.certificate, root.certificate);
+    assertEquals(list(certB, certA, root),
+        council.normalizeCertificateChain(list(certB, certA, root, superRoot)));
+  }
+
+  private List<Certificate> list(HeldCertificate... heldCertificates) {
+    List<Certificate> result = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      result.add(heldCertificate.certificate);
+    }
+    return result;
+  }
+}
@@ -16,11 +16,9 @@
 package okhttp3;
 
 import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.cert.X509Certificate;
 import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.HeldCertificate;
 import okio.ByteString;
 import org.junit.Test;
 
@@ -32,39 +30,35 @@
 import static org.junit.Assert.fail;
 
 public final class CertificatePinnerTest {
-  static SslContextBuilder sslContextBuilder;
+  static HeldCertificate certA1;
+  static String certA1Pin;
+  static ByteString certA1PinBase64;
 
-  static KeyPair keyPairA;
-  static X509Certificate keypairACertificate1;
-  static String keypairACertificate1Pin;
-  static ByteString keypairACertificate1PinBase64;
+  static HeldCertificate certB1;
+  static String certB1Pin;
+  static ByteString certB1PinBase64;
 
-  static KeyPair keyPairB;
-  static X509Certificate keypairBCertificate1;
-  static String keypairBCertificate1Pin;
-  static ByteString keypairBCertificate1PinBase64;
-
-  static KeyPair keyPairC;
-  static X509Certificate keypairCCertificate1;
-  static String keypairCCertificate1Pin;
+  static HeldCertificate certC1;
+  static String certC1Pin;
 
   static {
     try {
-      sslContextBuilder = new SslContextBuilder(""example.com"");
-
-      keyPairA = sslContextBuilder.generateKeyPair();
-      keypairACertificate1 = sslContextBuilder.selfSignedCertificate(keyPairA, ""1"");
-      keypairACertificate1Pin = CertificatePinner.pin(keypairACertificate1);
-      keypairACertificate1PinBase64 = pinToBase64(keypairACertificate1Pin);
-
-      keyPairB = sslContextBuilder.generateKeyPair();
-      keypairBCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairB, ""1"");
-      keypairBCertificate1Pin = CertificatePinner.pin(keypairBCertificate1);
-      keypairBCertificate1PinBase64 = pinToBase64(keypairBCertificate1Pin);
-
-      keyPairC = sslContextBuilder.generateKeyPair();
-      keypairCCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairC, ""1"");
-      keypairCCertificate1Pin = CertificatePinner.pin(keypairCCertificate1);
+      certA1 = new HeldCertificate.Builder()
+          .serialNumber(""100"")
+          .build();
+      certA1Pin = CertificatePinner.pin(certA1.certificate);
+      certA1PinBase64 = pinToBase64(certA1Pin);
+
+      certB1 = new HeldCertificate.Builder()
+          .serialNumber(""200"")
+          .build();
+      certB1Pin = CertificatePinner.pin(certB1.certificate);
+      certB1PinBase64 = pinToBase64(certB1Pin);
+
+      certC1 = new HeldCertificate.Builder()
+          .serialNumber(""300"")
+          .build();
+      certC1Pin = CertificatePinner.pin(certC1.certificate);
     } catch (GeneralSecurityException e) {
       throw new AssertionError(e);
     }
@@ -94,162 +88,166 @@ static ByteString pinToBase64(String pin) {
 
   /** Multiple certificates generated from the same keypair have the same pin. */
   @Test public void sameKeypairSamePin() throws Exception {
-    X509Certificate keypairACertificate2 = sslContextBuilder.selfSignedCertificate(keyPairA, ""2"");
-    String keypairACertificate2Pin = CertificatePinner.pin(keypairACertificate2);
+    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
+        .keyPair(certA1.keyPair)
+        .serialNumber(""101"")
+        .build();
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
 
-    X509Certificate keypairBCertificate2 = sslContextBuilder.selfSignedCertificate(keyPairB, ""2"");
-    String keypairBCertificate2Pin = CertificatePinner.pin(keypairBCertificate2);
+    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
+        .keyPair(certB1.keyPair)
+        .serialNumber(""201"")
+        .build();
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
 
-    assertTrue(keypairACertificate1Pin.equals(keypairACertificate2Pin));
-    assertTrue(keypairBCertificate1Pin.equals(keypairBCertificate2Pin));
-    assertFalse(keypairACertificate1Pin.equals(keypairBCertificate1Pin));
+    assertTrue(certA1Pin.equals(keypairACertificate2Pin));
+    assertTrue(certB1Pin.equals(keypairBCertificate2Pin));
+    assertFalse(certA1Pin.equals(certB1Pin));
   }
 
   @Test public void successfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairACertificate1Pin)
+        .add(""example.com"", certA1Pin)
         .build();
 
-    certificatePinner.check(""example.com"", keypairACertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate);
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairBCertificate1Pin)
+        .add(""example.com"", certB1Pin)
         .build();
 
-    certificatePinner.check(""example.com"", keypairACertificate1, keypairBCertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate, certB1.certificate);
   }
 
   @Test public void unsuccessfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairACertificate1Pin)
+        .add(""example.com"", certA1Pin)
         .build();
 
     try {
-      certificatePinner.check(""example.com"", keypairBCertificate1);
+      certificatePinner.check(""example.com"", certB1.certificate);
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
   }
 
   @Test public void multipleCertificatesForOneHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairACertificate1Pin, keypairBCertificate1Pin)
+        .add(""example.com"", certA1Pin, certB1Pin)
         .build();
 
-    certificatePinner.check(""example.com"", keypairACertificate1);
-    certificatePinner.check(""example.com"", keypairBCertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate);
+    certificatePinner.check(""example.com"", certB1.certificate);
   }
 
   @Test public void multipleHostnamesForOneCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""example.com"", keypairACertificate1Pin)
-        .add(""www.example.com"", keypairACertificate1Pin)
+        .add(""example.com"", certA1Pin)
+        .add(""www.example.com"", certA1Pin)
         .build();
 
-    certificatePinner.check(""example.com"", keypairACertificate1);
-    certificatePinner.check(""www.example.com"", keypairACertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate);
+    certificatePinner.check(""www.example.com"", certA1.certificate);
   }
 
   @Test public void absentHostnameMatches() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check(""example.com"", keypairACertificate1);
+    certificatePinner.check(""example.com"", certA1.certificate);
   }
 
   @Test public void successfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
         .build();
 
-    certificatePinner.check(""a.example.com"", keypairACertificate1);
+    certificatePinner.check(""a.example.com"", certA1.certificate);
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairBCertificate1Pin)
+        .add(""*.example.com"", certB1Pin)
         .build();
 
-    certificatePinner.check(""a.example.com"", keypairACertificate1, keypairBCertificate1);
+    certificatePinner.check(""a.example.com"", certA1.certificate, certB1.certificate);
   }
 
   @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
         .build();
 
     try {
-      certificatePinner.check(""a.example.com"", keypairBCertificate1);
+      certificatePinner.check(""a.example.com"", certB1.certificate);
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
   }
 
   @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin, keypairBCertificate1Pin)
+        .add(""*.example.com"", certA1Pin, certB1Pin)
         .build();
 
-    certificatePinner.check(""a.example.com"", keypairACertificate1);
-    certificatePinner.check(""a.example.com"", keypairBCertificate1);
+    certificatePinner.check(""a.example.com"", certA1.certificate);
+    certificatePinner.check(""a.example.com"", certB1.certificate);
   }
 
   @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
-        .add(""a.example.com"", keypairBCertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
+        .add(""a.example.com"", certB1Pin)
         .build();
 
-    certificatePinner.check(""a.example.com"", keypairACertificate1);
-    certificatePinner.check(""a.example.com"", keypairBCertificate1);
+    certificatePinner.check(""a.example.com"", certA1.certificate);
+    certificatePinner.check(""a.example.com"", certB1.certificate);
   }
 
   @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
-        .add(""a.example.com"", keypairBCertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
+        .add(""a.example.com"", certB1Pin)
         .build();
 
     try {
-      certificatePinner.check(""a.example.com"", keypairCCertificate1);
+      certificatePinner.check(""a.example.com"", certC1.certificate);
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
   }
 
   @Test public void successfulFindMatchingPins() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""first.com"", keypairACertificate1Pin, keypairBCertificate1Pin)
-        .add(""second.com"", keypairCCertificate1Pin)
+        .add(""first.com"", certA1Pin, certB1Pin)
+        .add(""second.com"", certC1Pin)
         .build();
 
-    Set<ByteString> expectedPins =
-        setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
+    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
     Set<ByteString> matchedPins = certificatePinner.findMatchingPins(""first.com"");
 
     assertEquals(expectedPins, matchedPins);
   }
 
   @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
-        .add(""a.example.com"", keypairBCertificate1Pin)
-        .add(""b.example.com"", keypairCCertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
+        .add(""a.example.com"", certB1Pin)
+        .add(""b.example.com"", certC1Pin)
         .build();
 
-    Set<ByteString> expectedPins =
-        setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
+    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
     Set<ByteString> matchedPins = certificatePinner.findMatchingPins(""a.example.com"");
 
     assertEquals(expectedPins, matchedPins);
   }
 
   @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(""*.example.com"", keypairACertificate1Pin)
+        .add(""*.example.com"", certA1Pin)
         .build();
 
     assertNull(certificatePinner.findMatchingPins(""example.com""));
@@ -34,6 +34,7 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
+import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -58,6 +59,7 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.Internal;
+import okhttp3.internal.Platform;
 import okhttp3.internal.RecordingAuthenticator;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
@@ -2303,9 +2305,9 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
   @Test public void httpsWithCustomTrustManager() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager();
+    RecordingTrustManager trustManager = new RecordingTrustManager(sslContext);
     SSLContext sc = SSLContext.getInstance(""TLS"");
-    sc.init(null, new TrustManager[] {trustManager}, new java.security.SecureRandom());
+    sc.init(null, new TrustManager[] {trustManager}, new SecureRandom());
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(hostnameVerifier)
@@ -2321,8 +2323,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     assertContent(""DEF"", urlFactory.open(url));
     assertContent(""GHI"", urlFactory.open(url));
 
-    assertEquals(Arrays.asList(""verify "" + server.getHostName()),
-        hostnameVerifier.calls);
+    assertEquals(Arrays.asList(""verify "" + server.getHostName()), hostnameVerifier.calls);
     assertEquals(Arrays.asList(""checkServerTrusted [CN="" + server.getHostName() + "" 1]""),
         trustManager.calls);
   }
@@ -3535,9 +3536,14 @@ public abstract HttpURLConnection connect(
 
   private static class RecordingTrustManager implements X509TrustManager {
     private final List<String> calls = new ArrayList<String>();
+    private final X509TrustManager delegate;
+
+    public RecordingTrustManager(SSLContext sslContext) {
+      this.delegate = Platform.get().trustManager(sslContext.getSocketFactory());
+    }
 
     public X509Certificate[] getAcceptedIssuers() {
-      return new X509Certificate[] {};
+      return delegate.getAcceptedIssuers();
     }
 
     public void checkClientTrusted(X509Certificate[] chain, String authType)
@@ -0,0 +1,120 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the ""License""); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.PublicKey;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.security.auth.x500.X500Principal;
+
+/**
+ * A set of trusted Certificate Authority (CA) certificates that are trusted to verify the TLS
+ * certificates offered by remote web servers.
+ *
+ * <p>This class includes code from <a href=""https://conscrypt.org/"">Conscrypt's</a> {@code
+ * TrustManagerImpl} and {@code TrustedCertificateIndex}.
+ */
+public final class CertificateAuthorityCouncil {
+  private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts = new LinkedHashMap<>();
+
+  public CertificateAuthorityCouncil(X509Certificate... caCerts) {
+    for (X509Certificate caCert : caCerts) {
+      X500Principal subject = caCert.getSubjectX500Principal();
+      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+      if (subjectCaCerts == null) {
+        subjectCaCerts = new ArrayList<>(1);
+        subjectToCaCerts.put(subject, subjectCaCerts);
+      }
+      subjectCaCerts.add(caCert);
+    }
+  }
+
+  /**
+   * Computes the effective certificate chain from the raw array returned by Java's built in TLS
+   * APIs. This method returns a list of certificates where the first element is {@code chain[0]},
+   * each certificate is signed by the certificate that follows, and the last certificate is a
+   * trusted CA certificate.
+   *
+   * <p>Use of this method is necessary to omit unexpected certificates that aren't relevant to the
+   * TLS handshake and to extract the trusted CA certificate for the benefit of certificate pinning.
+   *
+   * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
+   * This is unexpected unless the X509 trust manager in this class is different from the trust
+   * manager that was used to establish {@code chain}.
+   */
+  public List<Certificate> normalizeCertificateChain(List<Certificate> chain)
+      throws SSLPeerUnverifiedException {
+    Deque<Certificate> queue = new ArrayDeque<>(chain);
+    List<Certificate> result = new ArrayList<>();
+    result.add(queue.removeFirst());
+
+    followIssuerChain:
+    while (true) {
+      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
+
+      // If this cert has been signed by a trusted CA cert, we're done. Add the trusted CA
+      // certificate to the end of the chain, unless it's already present. (That would happen if the
+      // first certificate in the chain is itself a self-signed and trusted CA certificate.)
+      X509Certificate caCert = findByIssuerAndSignature(toVerify);
+      if (caCert != null) {
+        if (result.size() > 1 || !toVerify.equals(caCert)) {
+          result.add(caCert);
+        }
+        return result;
+      }
+
+      // Search for the certificate in the chain that signed this certificate. This is typically the
+      // next element in the chain, but it could be any element.
+      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
+        Certificate signingCert = i.next();
+        if (toVerify.getIssuerDN().equals(((X509Certificate) signingCert).getSubjectDN())) {
+          i.remove();
+          result.add(signingCert);
+          continue followIssuerChain;
+        }
+      }
+
+      throw new SSLPeerUnverifiedException(""Failed to find a cert that signed "" + toVerify);
+    }
+  }
+
+  /** Returns the trusted CA certificate that signed {@code cert}. */
+  private X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    X500Principal issuer = cert.getIssuerX500Principal();
+    List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+    if (subjectCaCerts == null) return null;
+
+    for (X509Certificate caCert : subjectCaCerts) {
+      PublicKey publicKey = caCert.getPublicKey();
+      try {
+        cert.verify(publicKey);
+        return caCert;
+      } catch (Exception ignored) {
+      }
+    }
+
+    return null;
+  }
+}
",True,"The commit message refers to the necessity of changes by mentioning the goal of the commit, which is to get the root CA certificate into the certificate chain so that it can be considered by the certificate pinner. This is done to ensure the security of the TLS connection and to comply with certificate pinning standards.",True,"The commit message explains the necessity of the changes by stating that the goal of the new CertificateAuthorityCouncil class is to 'get the root CA certificate into the certificate chain, so that it can be considered by the certificate pinner.' This is a clear and concise explanation of why the changes are being made.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that the goal of the new CertificateAuthorityCouncil class is to 'get the root CA certificate into the certificate chain, so that it can be considered by the certificate pinner.' This clearly describes the problem that the new class is intended to solve, which is the absence of the root CA certificate in the certificate chain, making it difficult for the certificate pinner to verify the chain.",True,"The commit message mentions the need to 'get the root CA certificate into the certificate chain, so that it can be considered by the certificate pinner.' This indicates that the change is being made to address a requirement, in this case, to ensure that the root CA certificate is included in the certificate chain for certificate pinning.",True,"The commit message directly mentions the objective of the change by stating that the goal is to 'get the root CA certificate into the certificate chain, so that it can be considered by the certificate pinner.' This clearly describes the improvement made to the code.",True,"The commit message 'New CertificateAuthorityCouncil class to normalize certificate chains' describes the purpose of the code change, which is to create a new class called CertificateAuthorityCouncil to normalize certificate chains. This is a summary of the changes made in the code diff, which includes the addition of a new class and its methods. The message also contrasts the before and after situation by mentioning the need to get the root CA certificate into the certificate chain so that it can be considered by the certificate pinner.",True,"The commit message explains that the new CertificateAuthorityCouncil class is used to normalize certificate chains, specifically to ensure that the root CA certificate is included in the chain. This is a technical principle that underpins the changes, as it ensures that the certificate pinner can consider all relevant certificates when verifying the server's identity.",True,"The commit message expresses the creation of a new class, CertificateAuthorityCouncil, which is used to normalize certificate chains. This is a functional change that introduces new behavior, as it allows the root CA certificate to be considered by the certificate pinner, which was not possible before.",False,"The commit message provides a clear explanation of the reason for the commit, which is to normalize certificate chains and get the root CA certificate into the chain for consideration by the certificate pinner. The code diff also supports this explanation by adding a new CertificateAuthorityCouncil class and modifying existing classes to use it. Therefore, the commit message does not lack an explanation."
https://github.com/spring-projects/spring-boot/commit/205fa2507b019f5e1348f6bc554fdd18691152ba,Remove maven-eclipse-plugin as it has been retired  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/205fa2507b019f5e1348f6bc554fdd18691152ba,"@@ -193,7 +193,6 @@
 		<maven-compiler-plugin.version>3.7.0</maven-compiler-plugin.version>
 		<maven-dependency-plugin.version>3.0.2</maven-dependency-plugin.version>
 		<maven-deploy-plugin.version>2.8.2</maven-deploy-plugin.version>
-		<maven-eclipse-plugin.version>2.10</maven-eclipse-plugin.version>
 		<maven-enforcer-plugin.version>3.0.0-M1</maven-enforcer-plugin.version>
 		<maven-failsafe-plugin.version>2.22.0</maven-failsafe-plugin.version>
 		<maven-install-plugin.version>2.5.2</maven-install-plugin.version>
@@ -2912,11 +2911,6 @@
 					<artifactId>maven-dependency-plugin</artifactId>
 					<version>${maven-dependency-plugin.version}</version>
 				</plugin>
-				<plugin>
-					<groupId>org.apache.maven.plugins</groupId>
-					<artifactId>maven-eclipse-plugin</artifactId>
-					<version>${maven-eclipse-plugin.version}</version>
-				</plugin>
 				<plugin>
 					<groupId>org.apache.maven.plugins</groupId>
 					<artifactId>maven-enforcer-plugin</artifactId>
",True,"The commit message refers to the necessity of changes by mentioning that the maven-eclipse-plugin has been retired. This implies that the plugin is no longer supported or maintained, and its removal is necessary to keep the project up-to-date and functioning correctly.",True,"The commit message 'Remove maven-eclipse-plugin as it has been retired' clearly explains the reason for the change. The maven-eclipse-plugin is no longer maintained, which is a common reason for removing a plugin from a project. The code diff also supports this explanation by showing the removal of the maven-eclipse-plugin from the project configuration.",True,"The commit message 'Remove maven-eclipse-plugin as it has been retired' directly elaborates the motivation of the code change. It mentions that the maven-eclipse-plugin has been retired, which could potentially cause problems if it was still being used. The code diff also supports this explanation by showing the removal of the maven-eclipse-plugin from the configuration.",True,"The commit message 'Remove maven-eclipse-plugin as it has been retired' indicates that the changes were made due to the need for software maintenance. The maven-eclipse-plugin has been retired, which means it is no longer supported or updated. This can lead to issues with the development environment, as the plugin may no longer function correctly. Therefore, the developer removed the plugin from the project to ensure the project continues to build and run correctly.",True,"The commit message 'Remove maven-eclipse-plugin as it has been retired' directly mentions the reason for the change, which is that the maven-eclipse-plugin has been retired and is no longer supported. This is a clear indication of the improvement made to the code.",True,"The commit message 'Remove maven-eclipse-plugin as it has been retired' accurately summarizes the changes made in the diff. It clearly states that a component (maven-eclipse-plugin) has been removed, which is reflected in the diff where the version line for maven-eclipse-plugin has been deleted.",True,"The commit message explains that the maven-eclipse-plugin is being removed because it has been retired. This is a technical principle underpinning the changes, which is to keep the project up-to-date and using only supported tools.",True,"The commit message 'Remove maven-eclipse-plugin as it has been retired' clearly describes the change made in the code diff. It explains that the maven-eclipse-plugin has been removed from the project configuration files, which is confirmed by the code diff where the version for maven-eclipse-plugin is removed from the POM file. This change does not introduce any new behaviors, but it removes an outdated and retired plugin, which is a significant change from a functional perspective.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'Remove maven-eclipse-plugin as it has been retired'. This is a clear and concise explanation of the change, even though it can be inferred from the code diff. The message also includes a reference to the pull request, which adds additional context to the change."
https://github.com/square/okhttp/commit/cf63fcc48ae3e1dc3fb32120ca2fb04877fa041e,Remove creation of 'fat' jar.  <enter> Since the 'okhttp-protocols' module no longer exists we do not need to create this. ,https://api.github.com/repos/square/okhttp/commits/cf63fcc48ae3e1dc3fb32120ca2fb04877fa041e,"@@ -34,24 +34,6 @@
           <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
         </configuration>
       </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
     </plugins>
   </build>
 </project>
",True,"The commit message refers to the necessity of changes by mentioning that the 'okhttp-protocols' module no longer exists. This implies that the creation of a 'fat' jar, which was previously done to include this module, is no longer necessary. This is a clear reference to a change in the project's dependencies, which is a common reason for code changes.",True,"The commit message explicitly states the reason for the changes: 'Since the 'okhttp-protocols' module no longer exists, we do not need to create this fat jar.' The code diff also clearly shows the removal of the configuration for the 'maven-assembly-plugin', which is used to create the 'fat' jar. This makes it easy to infer that the changes are necessary to reflect the removal of the 'okhttp-protocols' module.",True,"The commit message directly elaborates the motivation of the code change by stating that the 'okhttp-protocols' module no longer exists, which means the creation of a 'fat' jar is no longer necessary.",True,"The commit message 'Remove creation of 'fat' jar. Since the 'okhttp-protocols' module no longer exists we do not need to create this.' indicates that the changes were made due to the removal of the 'okhttp-protocols' module, which is a source of requirements. The developer no longer needs to create a 'fat' jar because the module it depended on is no longer available.",True,"The commit message directly mentions the reason for the change: 'Since the 'okhttp-protocols' module no longer exists, we do not need to create this fat jar.' This clearly states that the change is being made to address a situation where the 'okhttp-protocols' module no longer exists, and the creation of the 'fat' jar is no longer necessary.",True,"The commit message 'Remove creation of 'fat' jar. Since the 'okhttp-protocols' module no longer exists we do not need to create this.' accurately summarizes the changes made in the diff. It clearly states that a section of the code that was used to create a 'fat' jar has been removed, which is exactly what the diff shows. The message also provides a reason for the change, which adds context to the modification.",True,"The commit message explains that the creation of a 'fat' jar is being removed because the 'okhttp-protocols' module no longer exists. This is a technical principle underpinning the changes, which is the principle of 'dependency management' - the removal of unnecessary dependencies to streamline the build process and reduce the size of the final artifact.",True,"The commit message 'Remove creation of 'fat' jar. Since the 'okhttp-protocols' module no longer exists we do not need to create this.' accurately describes the code changes. It explains that the removal of a section of the code is due to the non-existence of the 'okhttp-protocols' module. This change effectively stops the creation of a 'fat' jar, which is a new behavior introduced by the removal of the code.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Since the 'okhttp-protocols' module no longer exists, we do not need to create this fat jar.' The change is not trivial, as it involves removing a significant portion of the configuration for the Maven Assembly Plugin, which is used to create a 'fat' jar. The explanation in the commit message is clear and concise, and it accurately reflects the changes made in the code diff."
https://github.com/junit-team/junit4/commit/5eee07b3e21f196b8cb937fb88eb8cf4be694f76,"Optimize ParentRunner.filter for nested suites  <enter> Prior to this change, applying a filter to a nested suite would create redundant nested filters ",https://api.github.com/repos/junit-team/junit4/commits/5eee07b3e21f196b8cb937fb88eb8cf4be694f76,"@@ -50,8 +50,6 @@ public abstract class ParentRunner<T> extends Runner implements Filterable,
 		Sortable {
 	private final TestClass fTestClass;
 
-	private Filter fFilter= Filter.ALL;
-
 	private Sorter fSorter= Sorter.NULL;
 
 	private List<T> fFilteredChildren= null;
@@ -319,13 +317,11 @@ public void run(final RunNotifier notifier) {
 	//
 
 	public void filter(Filter filter) throws NoTestsRemainException {
-		fFilter= fFilter.intersect(filter);
-
 		for (Iterator<T> iter = getFilteredChildren().iterator(); iter.hasNext(); ) {
 			T each = iter.next();
-			if (shouldRun(each))
+			if (shouldRun(filter, each))
 				try {
-					filterChild(each);
+					filter.apply(each);
 				} catch (NoTestsRemainException e) {
 					iter.remove();
 				}
@@ -365,12 +361,8 @@ private void sortChild(T child) {
 		fSorter.apply(child);
 	}
 
-	private void filterChild(T child) throws NoTestsRemainException {
-		fFilter.apply(child);
-	}
-
-	private boolean shouldRun(T each) {
-		return fFilter.shouldRun(describeChild(each));
+	private boolean shouldRun(Filter filter, T each) {
+		return filter.shouldRun(describeChild(each));
 	}
 
 	private Comparator<? super T> comparator() {
",True,"The commit message refers to a problem that existed prior to the change. It mentions that 'applying a filter to a nested suite would create redundant nested filters', which is a clear explanation of the necessity for the changes. The code diff also supports this explanation by showing the removal of redundant filtering code.",True,"The commit message 'Optimize ParentRunner.filter for nested suites' clearly explains the reason for the changes. It states that applying a filter to a nested suite would create redundant nested filters, which is a problem that the commit aims to solve. This is not a common sense or easy to infer change, as it involves optimizing the code for better performance and efficiency. The code diff also supports this explanation by showing the removal of redundant filtering code.",True,The commit message explains the motivation for the change by mentioning the issue of creating redundant nested filters when applying a filter to a nested suite. This directly elaborates the shortcoming of the previous implementation and the necessity of the changes.,True,"The commit message 'Optimize ParentRunner.filter for nested suites' indicates that the developer made changes to improve the efficiency of the code. The explanation in the message, 'Prior to this change, applying a filter to a nested suite would create redundant nested filters', suggests that there was a problem in the process of software maintenance, specifically that the previous implementation was not optimal and could lead to unnecessary computations, which is a valid reason for making changes.",True,"The commit message directly mentions the objective of the change by stating that it optimizes the ParentRunner.filter for nested suites. This optimization is done to eliminate the creation of redundant nested filters, which is a clear improvement to the code.",True,"The commit message 'Optimize ParentRunner.filter for nested suites' accurately summarizes the changes made in the code diff. It highlights the optimization of the filter method for nested suites, which was previously creating redundant nested filters. The message also contrasts the before and after state of the code by mentioning the removal of the redundant filtering process.",True,"The commit message explains that the changes are made to optimize the ParentRunner.filter method for nested suites. The optimization is achieved by reducing redundant nested filters and applying the filter directly to the child elements. This is based on the technical principle of reducing unnecessary computations and operations, which can improve performance and efficiency.",True,The commit message 'Optimize ParentRunner.filter for nested suites' accurately summarizes the changes made in the code diff. It explains that the optimization was done to avoid creating redundant nested filters when applying a filter to a nested suite. This change improves the efficiency of the code and does not introduce any new behaviors or functionalities.,False,"The commit message explains the reason for the change, which is to optimize the ParentRunner.filter for nested suites. The change is not just a simple removal of a space, but rather a modification to the code logic to improve efficiency and performance. Therefore, an explanation of the change is necessary to understand the purpose and impact of the commit."
https://github.com/square/retrofit/commit/b6748ac88759a4768c1003930bb5c921ac49d8d1,Mark GSON as provided since we jarjar it in. ,https://api.github.com/repos/square/retrofit/commits/b6748ac88759a4768c1003930bb5c921ac49d8d1,"@@ -29,6 +29,7 @@
         <dependency>
             <groupId>com.google.code.gson</groupId>
             <artifactId>gson</artifactId>
+            <scope>provided</scope>
         </dependency>
         <dependency>
             <groupId>org.apache.httpcomponents</groupId>
",True,"The commit message 'Mark GSON as provided since we jarjar it in' refers to the necessity of changes by explaining that the GSON dependency is being marked as 'provided' because it is being jarjar'd (repacked) into the project's final jar. This is a common practice to avoid having duplicate copies of the same library in the final artifact, which can lead to issues and increase the size of the jar. By marking the dependency as 'provided', it is indicating that the dependency will be provided at runtime by the container or the application server, and it does not need to be included in the final jar.",True,"The commit message 'Mark GSON as provided since we jarjar it in.' clearly explains the reason for the change. The change is made to the dependency configuration in a build file, where the scope of the GSON library is being changed from its default (compile) to 'provided'. This is done because the project is using a tool called jarjar to repackage the GSON library into the project's own JAR file. By marking GSON as 'provided', it ensures that the GSON library is not included in the final packaged JAR file to avoid any conflicts or duplications.",True,The commit message 'Mark GSON as provided since we jarjar it in' directly elaborates the motivation of the code change. It mentions that the GSON library is being marked as 'provided' because it is being jarjar'd (a tool used to repackage Java libraries) in the project. This change is likely necessary to avoid classpath conflicts or to ensure that the correct version of the library is used at runtime.,True,"The commit message 'Mark GSON as provided since we jarjar it in' indicates that the changes were made due to the need to modify the build configuration. The developer is marking GSON as 'provided' because it is being jarjar'd (repacked) into the final application jar, which means it will be provided at runtime by the application itself, not by the container or build system. This is a common requirement in software development to optimize the final build size or to avoid classpath conflicts.",True,"The commit message 'Mark GSON as provided since we jarjar it in' directly mentions the change made to the code, which is to mark GSON as provided because it is being jarjar'd (a tool used to repackage Java libraries). This change is likely made to avoid classpath conflicts during runtime, which is an improvement to the code.",True,"The commit message 'Mark GSON as provided since we jarjar it in' accurately summarizes the change in the code diff. It clearly states that the change is adding the 'provided' scope to the GSON dependency, which is a key component of the change. Additionally, it provides context for the change by mentioning that the change is necessary because the GSON library is being jarjar'ed (a process that combines multiple JAR files into one).",True,"The commit message 'Mark GSON as provided since we jarjar it in' indicates that the technical principle underpinning the changes is dependency management. The change is marking GSON as 'provided' in the project's dependencies, which means that the dependency is expected to be provided at runtime by a container or the JDK. This is done because the project is using Jarjar to repackage the GSON library, which can cause classpath issues if not handled correctly.",True,"The commit message 'Mark GSON as provided since we jarjar it in.' accurately describes the code change. The change is adding a 'provided' scope to the GSON dependency in the project's configuration. This means that the GSON library is not included in the project's build output, but it will be provided at runtime. This change introduces a new behavior where the project will rely on the GSON library being available at runtime, rather than including it in the project's distribution.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Mark GSON as provided since we jarjar it in.' This is a significant change as it modifies the dependency scope, which can have a significant impact on the build and runtime behavior of the project."
https://github.com/junit-team/junit4/commit/24dfdd762e753c83babca3768d4b508cf5c6a86c,Fix dead link to the ant task in FAQ ( <pr_link> )  <enter> Documentation to the ant junit task has been moved to another location. ,https://api.github.com/repos/junit-team/junit4/commits/24dfdd762e753c83babca3768d4b508cf5c6a86c,"@@ -1461,7 +1461,7 @@ a test failure, rather than the source file's line number?</question>
           Idiomatic naming patterns for unit tests
           are <code>Test*.java</code> and <code>*Test.java</code>.
           Documentation and examples are at <a
-                                               href=""http://ant.apache.org/manual/OptionalTasks/junit.html"">http://ant.apache.org/manual/OptionalTasks/junit.html</a>.
+                                               href=""https://ant.apache.org/manual/Tasks/junit.html"">https://ant.apache.org/manual/Tasks/junit.html</a>.
         </p>
       </li>
       <li>
",True,"The commit message refers to a change in documentation that was necessary due to the documentation for the ant junit task having been moved to a new location. This explains why the commit updated the link in the FAQ, as it is common to keep documentation up-to-date and accurate.",True,"The commit message 'Fix dead link to the ant task in FAQ' clearly describes the necessity of the changes. The code diff shows that the link in the documentation has been updated because the documentation for the ant junit task has been moved to a new location. This is a common reason for updating links in documentation, and it is easy to infer the need for the change from the commit message and the code diff.",True,"The commit message explains the necessity of changes by mentioning that 'Documentation to the ant junit task has been moved to another location'. This directly elaborates the motivation of the code change, which is to fix a broken link due to the documentation's new location.",True,"The commit message indicates that the developer made changes due to a problem in the process of software maintenance. The problem is a dead link to the ant task in the FAQ, which has been moved to another location. This change was necessary to ensure the accuracy and usability of the documentation.",True,"The commit message directly mentions the issue it fixes, which is a dead link to the ant task in the FAQ. The change made in the code diff is to update the link to the correct location, which fixes the issue.",True,"The commit message 'Fix dead link to the ant task in FAQ' accurately summarizes the change made in the diff. The key component of the change is the update of the link to the ant junit task in the FAQ. The message contrasts the old link with the new one, which is a clear indication of the change made in the code diff.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions that the documentation for the ant junit task has been moved to a new location, which is a change in the codebase, not a principle.",False,"The commit message does not describe the code changes from a functional perspective. It only mentions that the documentation link for the ant junit task has been moved to a new location. However, the code diff shows a change in the URL of the link, but it does not introduce any new behaviors or functional changes.",False,"The commit message does not lack an explanation. Although the change is small and simple, it is not immediately clear from the diff that the link has been updated. The commit message explicitly states that the link has been updated and provides a reason for the change, which is that the documentation for the ant junit task has been moved to a new location."
https://github.com/square/okhttp/commit/50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d,"Move out of the libcore package.  <enter> To promote the code into AOSP, we'll keep this package as-is and do the jarjar in Android instead. ",https://api.github.com/repos/square/okhttp/commits/50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d,"@@ -101,31 +101,6 @@
                     <target>${java.version}</target>
                 </configuration>
             </plugin>
-            <plugin>
-                <groupId>org.sonatype.plugins</groupId>
-                <artifactId>jarjar-maven-plugin</artifactId>
-                <version>1.5</version>
-                <executions>
-                    <execution>
-                        <phase>package</phase>
-                        <goals>
-                            <goal>jarjar</goal>
-                        </goals>
-                        <configuration>
-                            <includes>
-                                <include>asm:asm</include>
-                                <include>org.sonatype.sisu.inject:cglib</include>
-                            </includes>
-                            <rules>
-                                <rule>
-                                    <pattern>libcore.**</pattern>
-                                    <result>com.squareup.okhttp.libcore.@1</result>
-                                </rule>
-                            </rules>
-                        </configuration>
-                    </execution>
-                </executions>
-            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-checkstyle-plugin</artifactId>
@@ -15,6 +15,8 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.net.http.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.net.http.HttpsURLConnectionImpl;
 import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URL;
@@ -33,9 +35,9 @@ public OkHttpClient setProxy(Proxy proxy) {
     public HttpURLConnection open(URL url) {
         String protocol = url.getProtocol();
         if (protocol.equals(""http"")) {
-            return new libcore.net.http.HttpURLConnectionImpl(url, 80, proxy);
+            return new HttpURLConnectionImpl(url, 80, proxy);
         } else if (protocol.equals(""https"")) {
-            return new libcore.net.http.HttpsURLConnectionImpl(url, 443, proxy);
+            return new HttpsURLConnectionImpl(url, 443, proxy);
         } else {
             throw new IllegalArgumentException();
         }
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore;
+package com.squareup.okhttp.internal;
 
 import com.squareup.okhttp.OkHttpClient;
 import java.io.OutputStream;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 import java.io.FileDescriptor;
 
@@ -19,10 +19,10 @@
 * @author Alexander Y. Kleymenov
 */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.EmptyArray;
 import java.io.UnsupportedEncodingException;
-import libcore.util.EmptyArray;
 
 /**
  * <a href=""http://www.ietf.org/rfc/rfc2045.txt"">Base64</a> encoder/decoder.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 /**
  * Iterates over big- or little-endian bytes. See {@link MemoryMappedFile#bigEndianIterator} and
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.Charsets;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.BufferedWriter;
 import java.io.Closeable;
 import java.io.EOFException;
@@ -41,8 +43,6 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import libcore.util.Charsets;
-import libcore.util.Libcore;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 import java.io.Closeable;
 import java.io.File;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 public final class OsConstants {
     private OsConstants() { }
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
 public final class SizeOf {
     public static final int CHAR = 2;
@@ -14,8 +14,9 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
 import java.io.IOException;
@@ -24,7 +25,6 @@
 import java.io.Reader;
 import java.io.StringWriter;
 import java.util.concurrent.atomic.AtomicReference;
-import libcore.util.Libcore;
 
 public final class Streams {
     private static AtomicReference<byte[]> skipBuffer = new AtomicReference<byte[]>();
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.Charsets;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
-import libcore.util.Charsets;
 
 /**
  * Buffers input from an {@link InputStream} for reading lines.
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net;
+package com.squareup.okhttp.internal.net;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net;
+package com.squareup.okhttp.internal.net;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.io.Streams;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import libcore.io.Streams;
 
 /**
  * An input stream for the body of an HTTP response.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.io.IOException;
 import java.io.OutputStream;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 final class HeaderParser {
 
@@ -14,20 +14,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
-import static com.squareup.okhttp.OkHttpConnection.HTTP_PROXY_AUTH;
-import static com.squareup.okhttp.OkHttpConnection.HTTP_UNAUTHORIZED;
+import com.squareup.okhttp.internal.io.Base64;
 import java.io.IOException;
 import java.net.Authenticator;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.PasswordAuthentication;
 import java.net.Proxy;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
-import libcore.io.Base64;
 
 /**
  * Handles HTTP authentication headers from origin and proxy servers.
@@ -15,14 +15,19 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
-import static com.squareup.okhttp.OkHttpConnection.HTTP_PROXY_AUTH;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.io.IoUtils;
+import com.squareup.okhttp.internal.net.spdy.SpdyConnection;
+import com.squareup.okhttp.internal.util.Libcore;
+import com.squareup.okhttp.internal.util.Objects;
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.Socket;
@@ -33,11 +38,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
-import libcore.Platform;
-import libcore.io.IoUtils;
-import libcore.net.spdy.SpdyConnection;
-import libcore.util.Libcore;
-import libcore.util.Objects;
 
 /**
  * Holds the sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection,
@@ -15,14 +15,14 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.util.Libcore;
 import java.net.Socket;
 import java.net.SocketException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
-import libcore.util.Libcore;
 
 /**
  * A pool of HTTP and SPDY connections. This class exposes its tuning parameters
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.text.DateFormat;
 import java.text.ParseException;
@@ -15,8 +15,14 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
-
+package com.squareup.okhttp.internal.net.http;
+
+import com.squareup.okhttp.internal.io.IoUtils;
+import com.squareup.okhttp.internal.net.Dns;
+import com.squareup.okhttp.internal.util.EmptyArray;
+import com.squareup.okhttp.internal.util.ExtendedResponseCache;
+import com.squareup.okhttp.internal.util.Libcore;
+import com.squareup.okhttp.internal.util.ResponseSource;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -39,12 +45,6 @@
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
-import libcore.io.IoUtils;
-import libcore.net.Dns;
-import libcore.util.EmptyArray;
-import libcore.util.ExtendedResponseCache;
-import libcore.util.Libcore;
-import libcore.util.ResponseSource;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -14,8 +14,16 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
-
+package com.squareup.okhttp.internal.net.http;
+
+import com.squareup.okhttp.internal.io.Base64;
+import com.squareup.okhttp.internal.io.DiskLruCache;
+import com.squareup.okhttp.internal.io.IoUtils;
+import com.squareup.okhttp.internal.io.StrictLineReader;
+import com.squareup.okhttp.internal.util.Charsets;
+import com.squareup.okhttp.internal.util.ExtendedResponseCache;
+import com.squareup.okhttp.internal.util.IntegralToString;
+import com.squareup.okhttp.internal.util.ResponseSource;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -47,14 +55,6 @@
 import java.util.Map;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import libcore.io.Base64;
-import libcore.io.DiskLruCache;
-import libcore.io.IoUtils;
-import libcore.io.StrictLineReader;
-import libcore.util.Charsets;
-import libcore.util.ExtendedResponseCache;
-import libcore.util.IntegralToString;
-import libcore.util.ResponseSource;
 
 /**
  * Cache responses in a directory on the file system. Most clients should use
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.io.Streams;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -25,8 +27,6 @@
 import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Socket;
-import libcore.io.Streams;
-import libcore.util.Libcore;
 
 final class HttpTransport implements Transport {
     /**
@@ -15,8 +15,10 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.io.IoUtils;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -33,8 +35,6 @@
 import java.util.List;
 import java.util.Map;
 import javax.net.ssl.SSLHandshakeException;
-import libcore.io.IoUtils;
-import libcore.util.Libcore;
 
 /**
  * This implementation uses HttpEngine to send requests and receive responses.
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.io.IOException;
 import java.net.Proxy;
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -15,8 +15,10 @@
  *  limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.io.Streams;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
@@ -31,8 +33,6 @@
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.TreeMap;
-import libcore.io.Streams;
-import libcore.util.Libcore;
 
 /**
  * The HTTP status and unparsed header fields of a single HTTP message. Values
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.net.URI;
 import java.util.Date;
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.util.Objects;
+import com.squareup.okhttp.internal.util.ResponseSource;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URI;
@@ -26,8 +28,6 @@
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
-import libcore.util.Objects;
-import libcore.util.ResponseSource;
 
 /**
  * Parsed HTTP response headers.
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.ProtocolException;
-import libcore.util.Libcore;
 
 /**
  * An HTTP request body that's completely buffered in memory. This allows
@@ -13,8 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.net.Dns;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_AGGRESSIVE;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_COMPATIBLE;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_NULL;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -26,11 +31,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
-import libcore.net.Dns;
-import static libcore.net.http.HttpConnection.TLS_MODE_AGGRESSIVE;
-import static libcore.net.http.HttpConnection.TLS_MODE_COMPATIBLE;
-import static libcore.net.http.HttpConnection.TLS_MODE_NULL;
-import libcore.util.Libcore;
 
 /**
  * Selects routes to connect to an origin server. Each connection requires a
@@ -14,16 +14,16 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.net.spdy.SpdyConnection;
+import com.squareup.okhttp.internal.net.spdy.SpdyStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.util.List;
-import libcore.net.spdy.SpdyConnection;
-import libcore.net.spdy.SpdyStream;
 
 final class SpdyTransport implements Transport {
     private final HttpEngine httpEngine;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 import java.io.IOException;
 
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 final class Settings {
     /** Peer request to clear durable settings. */
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.io.Streams;
+import static com.squareup.okhttp.internal.net.spdy.Threads.newThreadFactory;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -29,9 +31,6 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import libcore.io.Streams;
-
-import static libcore.net.spdy.Threads.newThreadFactory;
 
 /**
  * A socket connection to a remote peer. A connection hosts streams which can
@@ -14,8 +14,9 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.io.Streams;
 import java.io.DataInputStream;
 import java.io.EOFException;
 import java.io.IOException;
@@ -27,7 +28,6 @@
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
 import java.util.zip.InflaterInputStream;
-import libcore.io.Streams;
 
 /**
  * Read version 2 SPDY frames.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -14,17 +14,16 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.io.Streams;
+import com.squareup.okhttp.internal.util.Libcore;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
-import java.util.List;
-import libcore.io.Streams;
-import libcore.util.Libcore;
-
 import static java.nio.ByteOrder.BIG_ENDIAN;
+import java.util.List;
 
 /**
  * A logical bidirectional stream.
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.Platform;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.List;
 import java.util.zip.Deflater;
-import libcore.Platform;
 
 /**
  * Write version 2 SPDY frames.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
 import java.util.concurrent.ThreadFactory;
 
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.nio.charset.Charset;
 
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.lang.ref.Reference;
 import java.util.Collections;
@@ -14,14 +14,15 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
+import com.squareup.okhttp.internal.net.MimeUtils;
 import java.net.FileNameMap;
 import java.util.Locale;
-import libcore.net.MimeUtils;
 
 /**
- * Implements {@link java.net.FileNameMap} in terms of {@link libcore.net.MimeUtils}.
+ * Implements {@link java.net.FileNameMap} in terms of
+ * {@link com.squareup.okhttp.internal.net.MimeUtils}.
  */
 class DefaultFileNameMap implements FileNameMap {
     public String getContentTypeFor(String filename) {
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class EmptyArray {
     private EmptyArray() {
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.io.IOException;
 import java.net.CacheResponse;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 /**
  * Converts integral types to strings. This class is public but hidden so that it can also be
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 import java.io.File;
 import java.io.IOException;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableBoolean {
     public boolean value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableByte {
     public byte value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableChar {
     public char value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableDouble {
     public double value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableFloat {
     public float value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableInt {
     public int value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableLong {
     public long value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class MutableShort {
     public short value;
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 public final class Objects {
     private Objects() {
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 /**
  * Where the HTTP client should look for a response.
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package libcore.util;
+package com.squareup.okhttp.internal.util;
 
 /**
  * Exploits a weakness in the runtime to throw an arbitrary throwable without
@@ -14,8 +14,11 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import static com.squareup.okhttp.internal.io.DiskLruCache.JOURNAL_FILE;
+import static com.squareup.okhttp.internal.io.DiskLruCache.MAGIC;
+import static com.squareup.okhttp.internal.io.DiskLruCache.VERSION_1;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
@@ -29,10 +32,6 @@
 import java.util.List;
 import junit.framework.TestCase;
 
-import static libcore.io.DiskLruCache.JOURNAL_FILE;
-import static libcore.io.DiskLruCache.MAGIC;
-import static libcore.io.DiskLruCache.VERSION_1;
-
 public final class DiskLruCacheTest extends TestCase {
     private final int appVersion = 100;
     private String javaTmpDir;
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package libcore.io;
+package com.squareup.okhttp.internal.io;
 
+import com.squareup.okhttp.internal.util.Charsets;
 import java.io.ByteArrayInputStream;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import junit.framework.TestCase;
-import libcore.util.Charsets;
 
 public class StrictLineReaderTest extends TestCase {
 
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import com.squareup.okhttp.OkHttpClient;
 import java.io.BufferedReader;
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import com.google.mockwebserver.MockResponse;
 import com.google.mockwebserver.MockWebServer;
 import com.google.mockwebserver.RecordedRequest;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import com.squareup.okhttp.OkHttpClient;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
@@ -58,8 +59,6 @@
 import java.util.zip.GZIPOutputStream;
 import junit.framework.TestCase;
 
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-
 /**
  * Android's HttpResponseCacheTest.
  */
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import junit.framework.TestCase;
 
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import java.util.Arrays;
 import java.util.List;
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
+import com.squareup.okhttp.internal.net.Dns;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_AGGRESSIVE;
+import static com.squareup.okhttp.internal.net.http.HttpConnection.TLS_MODE_COMPATIBLE;
+import com.squareup.okhttp.internal.net.ssl.SslContextBuilder;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -32,10 +36,6 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
 import junit.framework.TestCase;
-import libcore.net.Dns;
-import static libcore.net.http.HttpConnection.TLS_MODE_AGGRESSIVE;
-import static libcore.net.http.HttpConnection.TLS_MODE_COMPATIBLE;
-import libcore.net.ssl.SslContextBuilder;
 
 public final class RouteSelectorTest extends TestCase {
     private static final int proxyAPort = 1001;
@@ -14,13 +14,18 @@
  * limitations under the License.
  */
 
-package libcore.net.http;
+package com.squareup.okhttp.internal.net.http;
 
 import com.google.mockwebserver.MockResponse;
 import com.google.mockwebserver.MockWebServer;
 import com.google.mockwebserver.RecordedRequest;
 import com.google.mockwebserver.SocketPolicy;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.internal.net.ssl.SslContextBuilder;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
@@ -69,12 +74,6 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
 import junit.framework.TestCase;
-import libcore.net.ssl.SslContextBuilder;
-
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 
 /**
  * Android's URLConnectionTest.
@@ -14,8 +14,9 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
+package com.squareup.okhttp.internal.net.spdy;
 
+import com.squareup.okhttp.internal.io.Streams;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -29,7 +30,6 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
-import libcore.io.Streams;
 
 /**
  * Replays prerecorded outgoing frames and records incoming frames.
@@ -13,17 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package libcore.net.spdy;
-
+package com.squareup.okhttp.internal.net.spdy;
+
+import static com.squareup.okhttp.internal.net.spdy.Settings.DOWNLOAD_BANDWIDTH;
+import static com.squareup.okhttp.internal.net.spdy.Settings.DOWNLOAD_RETRANS_RATE;
+import static com.squareup.okhttp.internal.net.spdy.Settings.MAX_CONCURRENT_STREAMS;
+import static com.squareup.okhttp.internal.net.spdy.Settings.PERSISTED;
+import static com.squareup.okhttp.internal.net.spdy.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.net.spdy.Settings.UPLOAD_BANDWIDTH;
 import junit.framework.TestCase;
 
-import static libcore.net.spdy.Settings.DOWNLOAD_BANDWIDTH;
-import static libcore.net.spdy.Settings.DOWNLOAD_RETRANS_RATE;
-import static libcore.net.spdy.Settings.MAX_CONCURRENT_STREAMS;
-import static libcore.net.spdy.Settings.PERSISTED;
-import static libcore.net.spdy.Settings.PERSIST_VALUE;
-import static libcore.net.spdy.Settings.UPLOAD_BANDWIDTH;
-
 public final class SettingsTest extends TestCase {
     public void testUnsetField() {
         Settings settings = new Settings();
@@ -14,8 +14,18 @@
  * limitations under the License.
  */
 
-package libcore.net.spdy;
-
+package com.squareup.okhttp.internal.net.spdy;
+
+import static com.squareup.okhttp.internal.net.spdy.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.FLAG_FIN;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_DATA;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_NOOP;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_PING;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_SYN_REPLY;
+import static com.squareup.okhttp.internal.net.spdy.SpdyConnection.TYPE_SYN_STREAM;
+import static com.squareup.okhttp.internal.net.spdy.SpdyStream.RST_INVALID_STREAM;
+import static com.squareup.okhttp.internal.util.Charsets.UTF_8;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -25,17 +35,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import junit.framework.TestCase;
 
-import static libcore.net.spdy.Settings.PERSIST_VALUE;
-import static libcore.net.spdy.SpdyConnection.FLAG_FIN;
-import static libcore.net.spdy.SpdyConnection.TYPE_DATA;
-import static libcore.net.spdy.SpdyConnection.TYPE_NOOP;
-import static libcore.net.spdy.SpdyConnection.TYPE_PING;
-import static libcore.net.spdy.SpdyConnection.TYPE_RST_STREAM;
-import static libcore.net.spdy.SpdyConnection.TYPE_SYN_REPLY;
-import static libcore.net.spdy.SpdyConnection.TYPE_SYN_STREAM;
-import static libcore.net.spdy.SpdyStream.RST_INVALID_STREAM;
-import static libcore.util.Charsets.UTF_8;
-
 public final class SpdyConnectionTest extends TestCase {
     private static final IncomingStreamHandler REJECT_INCOMING_STREAMS
             = new IncomingStreamHandler() {
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package libcore.net.ssl;
+package com.squareup.okhttp.internal.net.ssl;
 
 import java.io.IOException;
 import java.io.InputStream;
",True,The commit message refers to the need to promote the code into AOSP by keeping the package as-is and doing the jarjar in Android instead. This is likely a reference to the need to restructure the package to fit into the Android Open Source Project (AOSP) without causing conflicts with existing libraries. This is a common practice to ensure compatibility and consistency within the Android ecosystem.,True,"The commit message does not explicitly state the reason for the change, but it is clear from the code diff that the change is being made to promote the code into AOSP. This is a common practice to avoid package name conflicts and to make the code more compatible with the Android platform. The removal of the jarjar-maven-plugin configuration and the changes to the package names in the code also indicate that this is the reason for the change.",False,The commit message does not explicitly describe the necessity of changes. It only mentions that the package is being kept as-is and the jarjar operation will be done in Android instead. This does not provide a clear explanation of why the changes are being made.,True,The commit message mentions the need to promote the code into AOSP and do the jarjar in Android instead. This suggests that the change is being made to accommodate the requirements of the Android Open Source Project (AOSP) and to ensure compatibility with the Android environment.,False,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only mentions the reason for the change, which is to promote the code into AOSP and do the jarjar in Android instead. However, it does not explicitly state what the change is or how it improves the code.",True,"The commit message describes the change by summarizing the code diff. It mentions moving the package out of 'libcore' and removing the jarjar-maven-plugin configuration, which are both changes reflected in the diff. Additionally, it mentions promoting the code into AOSP and doing the jarjar in Android instead, which are reasons for the changes but not directly reflected in the diff.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. While it mentions moving the package out of 'libcore' and using 'jarjar' in Android, it does not explain why these changes were made or what technical principle they are based on.",True,"The commit message describes the functional change of moving the libcore package out of the project and keeping it as-is while doing the jarjar in Android instead. This change is reflected in the code diff, which shows the removal of the jarjar-maven-plugin configuration and the renaming of certain classes and imports to reflect the new package structure.",False,"The commit message does not explicitly explain the reason for moving the libcore package. However, the context and the code diff suggest that the change is being made to promote the code into AOSP and to do the jarjar in Android instead. This is a significant change that could potentially break compatibility, so it would be appropriate to include an explanation in the commit message."
https://github.com/square/okhttp/commit/5ba145aa6c737878281c3fc655657002320b71c0,"Limit recovery attempts for REFUSED_STREAM errors  <enter> We limit per-connection retries but not per-call retries, so this was creating large numbers of connections each of which called the server and accepted yet another REFUSED_STREAM. <enter> Instead we fail sooner with a StreamResetException. <enter> This shows that the ExchangeFinder interface is still somewhat inadequate to support all of the use cases we have. ",https://api.github.com/repos/square/okhttp/commits/5ba145aa6c737878281c3fc655657002320b71c0,"@@ -163,7 +163,7 @@ class Exchange(
   }
 
   private fun trackFailure(e: IOException) {
-    finder.trackFailure()
+    finder.trackFailure(e)
     codec.connection.trackFailure(call.client, e)
   }
 
@@ -19,7 +19,6 @@ import java.io.IOException
 import java.net.Socket
 import okhttp3.Address
 import okhttp3.EventListener
-import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
 import okhttp3.Route
 import okhttp3.internal.assertThreadDoesntHoldLock
@@ -28,9 +27,13 @@ import okhttp3.internal.canReuseConnectionFor
 import okhttp3.internal.closeQuietly
 import okhttp3.internal.http.ExchangeCodec
 import okhttp3.internal.http.RealInterceptorChain
+import okhttp3.internal.http2.ConnectionShutdownException
+import okhttp3.internal.http2.ErrorCode
+import okhttp3.internal.http2.StreamResetException
 
 /**
- * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
+ * Attempts to find the connections for an exchange and any retries that follow. This uses the
+ * following strategies:
  *
  *  1. If the current call already has a connection that can satisfy the request it is used. Using
  *     the same connection for an initial exchange and its follow-ups may improve locality.
@@ -59,7 +62,9 @@ class ExchangeFinder(
   // State guarded by connectionPool.
   private var routeSelector: RouteSelector? = null
   private var connectingConnection: RealConnection? = null
-  private var hasStreamFailure = false
+  private var refusedStreamCount = 0
+  private var connectionShutdownCount = 0
+  private var otherFailureCount = 0
   private var nextRouteToTry: Route? = null
 
   fun find(
@@ -77,10 +82,10 @@ class ExchangeFinder(
       )
       return resultConnection.newCodec(client, chain)
     } catch (e: RouteException) {
-      trackFailure()
+      trackFailure(e.lastConnectException)
       throw e
     } catch (e: IOException) {
-      trackFailure()
+      trackFailure(e)
       throw RouteException(e)
     }
   }
@@ -144,7 +149,6 @@ class ExchangeFinder(
     val toClose: Socket?
     synchronized(connectionPool) {
       if (call.isCanceled()) throw IOException(""Canceled"")
-      hasStreamFailure = false // This is a fresh attempt.
 
       releasedConnection = call.connection
       toClose = if (call.connection != null &&
@@ -158,9 +162,15 @@ class ExchangeFinder(
         // We had an already-allocated connection and it's good.
         result = call.connection
         releasedConnection = null
+        nextRouteToTry = null
       }
 
       if (result == null) {
+        // The connection hasn't had any problems for this call.
+        refusedStreamCount = 0
+        connectionShutdownCount = 0
+        otherFailureCount = 0
+
         // Attempt to get a connection from the pool.
         if (connectionPool.callAcquirePooledConnection(address, call, null, false)) {
           foundPooledConnection = true
@@ -270,24 +280,30 @@ class ExchangeFinder(
     return connectingConnection
   }
 
-  fun trackFailure() {
+  fun trackFailure(e: IOException) {
     connectionPool.assertThreadDoesntHoldLock()
 
     synchronized(connectionPool) {
-      hasStreamFailure = true // Permit retries.
+      if (e is StreamResetException && e.errorCode == ErrorCode.REFUSED_STREAM) {
+        refusedStreamCount++
+      } else if (e is ConnectionShutdownException) {
+        connectionShutdownCount++
+      } else {
+        otherFailureCount++
+      }
     }
   }
 
-  /** Returns true if there is a failure that retrying might fix. */
-  fun hasStreamFailure(): Boolean {
+  /**
+   * Returns true if the current route has a failure that retrying could fix, and that there's
+   * a route to retry on.
+   */
+  fun retryAfterFailure(): Boolean {
     synchronized(connectionPool) {
-      return hasStreamFailure
-    }
-  }
+      if (refusedStreamCount == 0 && connectionShutdownCount == 0 && otherFailureCount == 0) {
+        return false // Nothing to recover from.
+      }
 
-  /** Returns true if a current route is still good or if there are routes we haven't tried yet. */
-  fun hasRouteToTry(): Boolean {
-    synchronized(connectionPool) {
       if (nextRouteToTry != null) {
         return true
       }
@@ -315,11 +331,13 @@ class ExchangeFinder(
    * coalesced connections.
    */
   private fun retryCurrentRoute(): Boolean {
+    if (refusedStreamCount > 1 || connectionShutdownCount > 1 || otherFailureCount > 0) {
+      return false // This route has too many problems to retry.
+    }
+
     val connection = call.connection
     return connection != null &&
         connection.routeFailureCount == 0 &&
         connection.route().address.url.canReuseConnectionFor(address.url)
   }
-
-  fun canReuseFinderFor(httpUrl: HttpUrl) = httpUrl.canReuseConnectionFor(address.url)
 }
@@ -213,29 +213,24 @@ class RealCall(
    * find an exchange to carry the request.
    *
    * Note that an exchange will not be needed if the request is satisfied by the cache.
+   *
+   * @param newExchangeFinder true if this is not a retry and new routing can be performed.
    */
-  fun enterNetworkInterceptorExchange(request: Request) {
+  fun enterNetworkInterceptorExchange(request: Request, newExchangeFinder: Boolean) {
     check(interceptorScopedExchange == null)
     check(exchange == null) {
       ""cannot make a new request because the previous response is still open: "" +
           ""please call response.close()""
     }
 
-    val exchangeFinder = this.exchangeFinder
-    if (exchangeFinder != null) {
-      if (exchangeFinder.canReuseFinderFor(request.url) && exchangeFinder.hasRouteToTry()) {
-        return // Already ready.
-      }
-
-      maybeReleaseConnection(null, true)
+    if (newExchangeFinder) {
+      this.exchangeFinder = ExchangeFinder(
+          connectionPool,
+          createAddress(request.url),
+          this,
+          eventListener
+      )
     }
-
-    this.exchangeFinder = ExchangeFinder(
-        connectionPool,
-        createAddress(request.url),
-        this,
-        eventListener
-    )
   }
 
   /** Finds a new or pooled connection to carry a forthcoming request and response. */
@@ -441,7 +436,7 @@ class RealCall(
     )
   }
 
-  fun canRetry() = exchangeFinder!!.hasStreamFailure() && exchangeFinder!!.hasRouteToTry()
+  fun retryAfterFailure() = exchangeFinder!!.retryAfterFailure()
 
   /**
    * Returns a string that describes this call. Doesn't include a full URL as that might contain
@@ -59,8 +59,9 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
     val call = realChain.call
     var followUpCount = 0
     var priorResponse: Response? = null
+    var newExchangeFinder = true
     while (true) {
-      call.enterNetworkInterceptorExchange(request)
+      call.enterNetworkInterceptorExchange(request, newExchangeFinder)
 
       var response: Response
       var closeActiveExchange = true
@@ -71,17 +72,20 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
 
         try {
           response = realChain.proceed(request)
+          newExchangeFinder = true
         } catch (e: RouteException) {
           // The attempt to connect via a route failed. The request will not have been sent.
           if (!recover(e.lastConnectException, call, request, requestSendStarted = false)) {
             throw e.firstConnectException
           }
+          newExchangeFinder = false
           continue
         } catch (e: IOException) {
           // An attempt to communicate with a server failed. The request may have been sent.
           if (!recover(e, call, request, requestSendStarted = e !is ConnectionShutdownException)) {
             throw e
           }
+          newExchangeFinder = false
           continue
         }
 
@@ -147,7 +151,8 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
     if (!isRecoverable(e, requestSendStarted)) return false
 
     // No more routes to attempt.
-    if (!call.canRetry()) return false
+    if (!call.retryAfterFailure()) return false
+
     // For failure recovery, use the same route selector with a new connection.
     return true
   }
@@ -89,7 +89,7 @@ public final class ConnectionPoolTest {
           .connectionPool(poolApi)
           .build();
       RealCall call = (RealCall) client.newCall(newRequest(addressA));
-      call.enterNetworkInterceptorExchange(call.request());
+      call.enterNetworkInterceptorExchange(call.request(), true);
       call.acquireConnectionNoEvents(c1);
     }
 
@@ -211,7 +211,7 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
           .connectionPool(pool)
           .build();
       RealCall call = (RealCall) client.newCall(newRequest(connection.route().address()));
-      call.enterNetworkInterceptorExchange(call.request());
+      call.enterNetworkInterceptorExchange(call.request(), true);
       call.acquireConnectionNoEvents(connection);
     }
   }
@@ -853,6 +853,33 @@ private void waitForDataFrames(int dataLength) throws Exception {
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
+  /**
+   * We had a bug where we'd perform infinite retries of route that fail with connection shutdown
+   * errors. The problem was that the logic that decided whether to reuse a route didn't track
+   * certain HTTP/2 errors. https://github.com/square/okhttp/issues/5547
+   */
+  @Test
+  public void noRecoveryFromTwoRefusedStreams() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.getHttpCode()));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.getHttpCode()));
+    server.enqueue(new MockResponse()
+        .setBody(""abc""));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url(""/""))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertThat(expected.errorCode).isEqualTo(ErrorCode.REFUSED_STREAM);
+    }
+  }
+
   @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
",True,The commit message refers to the necessity of changes by mentioning that the ExchangeFinder interface is still somewhat inadequate to support all of the use cases they have. This implies that the changes made in the commit are improvements or modifications to address the limitations of the existing interface.,True,"The commit message explains the necessity of changes by stating that the ExchangeFinder interface is still inadequate to support all of the use cases they have. Specifically, it mentions that the current implementation does not limit per-call retries for REFUSED_STREAM errors, which was creating large numbers of connections. The commit then introduces a change to fail sooner with a StreamResetException, which is a more appropriate response for this type of error.",True,"The commit message explains the motivation for the code change by mentioning the issue of 'REFUSED_STREAM' errors creating large numbers of connections and the need to fail sooner with a 'StreamResetException'. It also mentions that the 'ExchangeFinder' interface is still inadequate to support all use cases, which implies a shortcoming in the previous implementation. This directly elaborates the necessity of changes and describes the problem scenario.",True,"The commit message indicates that the changes were made to limit the number of retries for REFUSED_STREAM errors. This is done to address the issue that the ExchangeFinder interface is still inadequate to support all use cases, which suggests that there is a problem in the process of software maintenance that the changes are intended to resolve.",True,"The commit message directly mentions the defect it fixes by stating 'We limit per-connection retries but not per-call retries, so this was creating large numbers of connections each of which called the server and accepted yet another REFUSED_STREAM. Instead we fail sooner with a StreamResetException.' This clearly indicates that the change is made to improve the code and fix the mentioned issue.",True,"The commit message describes the change made to limit the recovery attempts for REFUSED_STREAM errors. This is summarized in the diff by adding a parameter to the trackFailure method, which indicates that the method is now tracking the specific exception that occurred. This change is also mentioned in the commit message as a reason for failing sooner with a StreamResetException, which is a good summary of the diff.",True,"The commit message explains that the changes are made to limit recovery attempts for REFUSED_STREAM errors. This shows that the technical principle underpinning the changes is to fail sooner with a StreamResetException when encountering REFUSED_STREAM errors, which is a type of HTTP/2 error. This is done to improve the efficiency and reliability of the ExchangeFinder interface, which is currently inadequate to support all use cases.",True,"The commit message expresses a change in the handling of REFUSED_STREAM errors in the ExchangeFinder class. It mentions that the previous implementation created large numbers of connections each of which called the server and accepted yet another REFUSED_STREAM. The new implementation fails sooner with a StreamResetException. This change describes a new behavior introduced in the code, which is a more efficient handling of REFUSED_STREAM errors.",False,"The commit message explains the reason for the commit by stating that it limits the recovery attempts for REFUSED_STREAM errors. This is not something that can be easily inferred from the code diff, which only shows a small change in the trackFailure method. The explanation in the commit message is necessary to understand the purpose of the change."
https://github.com/apache/dubbo/commit/5caa422add46efa9b6de8c0e763e1ccecbcbfacd,just for modify comments and imports ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/5caa422add46efa9b6de8c0e763e1ccecbcbfacd,"@@ -52,18 +52,18 @@ public ZookeeperClient connect(URL url) {
         List<String> addressList = getURLBackupAddress(url);
         // The field define the zookeeper server , including protocol, host, port, username, password
         if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {
-            logger.info(""Get result from map for the first time when invoking zookeeperTransporter.connnect ."");
+            logger.info(""find valid zookeeper client from the cache for address: "" + url);
             return zookeeperClient;
         }
         // avoid creating too many connections， so add lock
         synchronized (zookeeperClientMap) {
             if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {
-                logger.info(""Get result from map for the second time when invoking zookeeperTransporter.connnect ."");
+                logger.info(""find valid zookeeper client from the cache for address: "" + url);
                 return zookeeperClient;
             }
 
-            zookeeperClient = createZookeeperClient(createServerURL(url));
-            logger.info(""Get result by creating new connection when invoking zookeeperTransporter.connnect ."");
+            zookeeperClient = createZookeeperClient(toClientURL(url));
+            logger.info(""No valid zookeeper client found from cache, therefore create a new client for url. "" + url);
             writeToClientMap(addressList, zookeeperClient);
         }
         return zookeeperClient;
@@ -131,7 +131,7 @@ void writeToClientMap(List<String> addressList, ZookeeperClient zookeeperClient)
      * @param url
      * @return
      */
-    URL createServerURL(URL url) {
+    URL toClientURL(URL url) {
         Map<String, String> parameterMap = new HashMap<>();
         // for CuratorZookeeperClient
         if (url.getParameter(Constants.TIMEOUT_KEY) != null) {
@@ -16,13 +16,14 @@
  */
 package org.apache.dubbo.remoting.zookeeper.support;
 
-import org.apache.curator.test.TestingServer;
 import org.apache.dubbo.common.Constants;
 import org.apache.dubbo.common.URL;
 import org.apache.dubbo.common.utils.NetUtils;
 import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
 import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
 import org.apache.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter;
+
+import org.apache.curator.test.TestingServer;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
@@ -67,7 +68,7 @@ public void testZookeeperClient() {
     @Test
     public void testCreateServerURL() {
         URL url = URL.valueOf(""zookeeper://127.0.0.1:"" + zkServerPort + ""/org.apache.dubbo.registry.RegistryService?application=metadatareport-local-xml-provider2&dubbo=2.0.2&interface=org.apache.dubbo.registry.RegistryService&pid=47418&specVersion=2.7.0-SNAPSHOT&timestamp=1547102428828&timeout=2300"");
-        URL newUrl = abstractZookeeperTransporter.createServerURL(url);
+        URL newUrl = abstractZookeeperTransporter.toClientURL(url);
         Assert.assertEquals(newUrl.getProtocol(), ""zookeeper"");
         Assert.assertEquals(newUrl.getHost(), ""127.0.0.1"");
         Assert.assertEquals(newUrl.getPort(), zkServerPort);
@@ -80,9 +81,9 @@ public void testCreateServerURL() {
 
 
     @Test
-    public void testCreateServerURLWhenHasUser() {
+    public void testToCreateURLWhenHasUser() {
         URL url = URL.valueOf(""zookeeper://us2:pw2@127.0.0.1:"" + zkServerPort + ""/org.apache.dubbo.registry.RegistryService?application=metadatareport-local-xml-provider2&dubbo=2.0.2&interface=org.apache.dubbo.registry.RegistryService&pid=47418&specVersion=2.7.0-SNAPSHOT&timestamp=1547102428828"");
-        URL newUrl = abstractZookeeperTransporter.createServerURL(url);
+        URL newUrl = abstractZookeeperTransporter.toClientURL(url);
         Assert.assertEquals(newUrl.getProtocol(), ""zookeeper"");
         Assert.assertEquals(newUrl.getHost(), ""127.0.0.1"");
         Assert.assertEquals(newUrl.getPort(), zkServerPort);
",True,"The commit message refers to the necessity of changes by mentioning the improvement in the code. The changes made to the logger messages provide more clarity about the actions being performed, such as finding a valid Zookeeper client from the cache or creating a new client when none is found. This improves the readability and maintainability of the code.",True,"The commit message 'just for modify comments and imports' does not provide a clear rationale for the changes. However, the code diff shows that the changes are not just typographic fixes or annotations. The commit modifies the log messages and the method name 'createServerURL' to 'toClientURL'. This suggests that the changes are likely related to improving the code's readability and functionality, which is not easily inferred from the commit message.",True,"The commit message does not explicitly mention the error scenario or issue report, but the code diff suggests that the changes were made to improve the caching mechanism of Zookeeper clients. This could potentially prevent the creation of too many connections and find valid Zookeeper clients from the cache, which could be considered as a shortcoming of the previous implementation.",True,"The commit message does not explicitly state the reason for the changes, but the code diff indicates that the changes were made to handle the scenario where no valid Zookeeper client is found in the cache. This suggests that the changes were made to address a problem in the software maintenance process, specifically the need to create a new Zookeeper client when no valid one is found in the cache.",True,"The commit message does not explicitly mention the defects it fixes or the improvements it makes to the code. However, the code diff shows that the commit has modified the logging messages and the method name 'createServerURL' to 'toClientURL'. This suggests that the change is likely related to improving the clarity and accuracy of the logging messages and the method naming, which could be considered as an improvement to the code.",False,"The commit message only mentions modifying comments and imports, but it does not describe the changes made to the code. The code diff shows modifications to the logger messages and the renaming of a method, but these changes are not explicitly mentioned in the commit message.",True,"The commit message does not explicitly state the technical principle, but the code diff reveals that the changes are made to implement a caching mechanism for Zookeeper clients. This is a common technique to improve performance by reusing existing resources instead of creating new ones. Therefore, the principle underpinning the changes is 'Caching'.",False,"The commit message only mentions modifying comments and imports, but it does not describe the functional changes made to the code. The code diff shows changes to the logger messages and the method name, but it does not clearly describe any new behaviors introduced.",True,"The commit message 'just for modify comments and imports' does not provide a clear explanation of the changes made in the code. However, the changes in the code diff are relatively small and simple. The logger messages have been updated to provide more clarity about the actions being performed. Additionally, the method name 'createServerURL' has been changed to 'toClientURL' for better readability and understanding of its purpose. Therefore, the reason for the commit can be easily inferred from the changes made in the code."
https://github.com/square/retrofit/commit/745e29b7832c3cc37e7b6d395aded79a908c3bbc,"Remove deprecated error identifier.  <enter> This whole class is probably going to die or morph, but killing off tech debt before major refactorings makes me feel good. ",https://api.github.com/repos/square/retrofit/commits/745e29b7832c3cc37e7b6d395aded79a908c3bbc,"@@ -86,15 +86,6 @@ public Response getResponse() {
     return response;
   }
 
-  /**
-   * Whether or not this error was the result of a network error.
-   *
-   * @deprecated Use {@link #getKind() getKind() == Kind.NETWORK}.
-   */
-  @Deprecated public boolean isNetworkError() {
-    return kind == Kind.NETWORK;
-  }
-
   /** The event kind which triggered this error. */
   public Kind getKind() {
     return kind;
@@ -577,7 +577,6 @@ private interface InvalidExample extends Example {
       fail(""RetrofitError expected on malformed response body."");
     } catch (RetrofitError e) {
       assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-      assertThat(e.isNetworkError());
       assertThat(e.getCause()).isInstanceOf(IOException.class);
       assertThat(e.getCause()).hasMessage(""I'm broken!"");
     }
",True,"The commit message refers to the necessity of changes by mentioning that the deprecated error identifier is being removed. This is done to address tech debt and to prepare for a potential refactoring of the class. The code diff also shows that the deprecated method 'isNetworkError()' is being removed, which was mentioned in the commit message. This indicates that the commit message is describing the changes made in the code diff.",True,"The commit message 'Remove deprecated error identifier' clearly describes the changes made in the code diff. The deprecated method 'isNetworkError()' is being removed, which is a common refactoring to clean up code and remove outdated or unnecessary elements. The message does not provide a rationale beyond the fact that the method is deprecated and the class is likely to be refactored or removed in the future. This is a common practice in software development to improve code quality and maintainability.",True,"The commit message explains the motivation for the change by mentioning that the whole class is likely to die or morph in the future. This implies that the deprecated error identifier is no longer necessary and is considered technical debt that should be removed before major refactorings. Additionally, the code diff shows that the isNetworkError() method is being removed, which was deprecated in favor of using the getKind() method. This further supports the explanation that the change is being made to improve the codebase and remove unnecessary code.",True,"The commit message 'Remove deprecated error identifier' indicates that the changes are being made to address outdated code or tech debt. The code diff shows that a deprecated method 'isNetworkError()' is being removed, which suggests that it was no longer necessary or relevant to the current software development requirements.",True,"The commit message directly mentions the objective of the change by stating that it is removing a deprecated error identifier. This implies that the change is being made to improve the code and simplify it, as the deprecated method is no longer needed.",True,"The commit message 'Remove deprecated error identifier' accurately summarizes the change in the diff. It specifically mentions the removal of a deprecated method 'isNetworkError()' and its replacement with 'getKind() == Kind.NETWORK'. This highlights the key component of the change, which is the modification of the error identification mechanism.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on the removal of deprecated code and the personal satisfaction of clearing technical debt before major refactoring. The code diff, however, shows the removal of a method that was deprecated in favor of another method, which could imply the principle of encapsulation or the use of more modern APIs.",True,"The commit message 'Remove deprecated error identifier' accurately summarizes the code changes. The code diff shows that a deprecated method 'isNetworkError()' is being removed, which was used to check if the error was the result of a network error. The new behavior introduced is that the same information can now be obtained by checking if 'getKind() == Kind.NETWORK'. This change makes the code more modern and efficient, and it also removes unnecessary code.",False,"The commit message does provide an explanation for the change, which is to remove a deprecated error identifier. The explanation mentions that the entire class might be removed or refactored in the future, and the commit is being made to address tech debt before major refactoring. The code diff also shows that the deprecated method 'isNetworkError()' is being removed, which supports the explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/5afe4743cbf4ff69ffe4bbcefa4508b1a4ac6f4b,Remove deprecated configuration properties  <enter> This commit removes the following deprecated properties: <enter> * `server.connection-timeout` * `server.use-forward-headers` * `server.jetty.max-http-post-size` * `server.tomcat.max-http-post-size` <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/5afe4743cbf4ff69ffe4bbcefa4508b1a4ac6f4b,"@@ -100,13 +100,6 @@ public class ServerProperties {
 	 */
 	private DataSize maxHttpHeaderSize = DataSize.ofKilobytes(8);
 
-	/**
-	 * Time that connectors wait for another HTTP request before closing the connection.
-	 * When not set, the connector's container-specific default is used. Use a value of -1
-	 * to indicate no (that is, an infinite) timeout.
-	 */
-	private Duration connectionTimeout;
-
 	@NestedConfigurationProperty
 	private Ssl ssl;
 
@@ -145,17 +138,6 @@ public void setAddress(InetAddress address) {
 		this.address = address;
 	}
 
-	@DeprecatedConfigurationProperty(reason = ""replaced to support additional strategies"",
-			replacement = ""server.forward-headers-strategy"")
-	public Boolean isUseForwardHeaders() {
-		return ForwardHeadersStrategy.NATIVE.equals(this.forwardHeadersStrategy);
-	}
-
-	public void setUseForwardHeaders(Boolean useForwardHeaders) {
-		this.forwardHeadersStrategy = Boolean.TRUE.equals(useForwardHeaders) ? ForwardHeadersStrategy.NATIVE
-				: ForwardHeadersStrategy.NONE;
-	}
-
 	public String getServerHeader() {
 		return this.serverHeader;
 	}
@@ -172,18 +154,6 @@ public void setMaxHttpHeaderSize(DataSize maxHttpHeaderSize) {
 		this.maxHttpHeaderSize = maxHttpHeaderSize;
 	}
 
-	@Deprecated
-	@DeprecatedConfigurationProperty(
-			reason = ""Each server behaves differently. Use server specific properties instead."")
-	public Duration getConnectionTimeout() {
-		return this.connectionTimeout;
-	}
-
-	@Deprecated
-	public void setConnectionTimeout(Duration connectionTimeout) {
-		this.connectionTimeout = connectionTimeout;
-	}
-
 	public ErrorProperties getError() {
 		return this.error;
 	}
@@ -443,17 +413,6 @@ public void setMinSpareThreads(int minSpareThreads) {
 			this.getThreads().setMinSpare(minSpareThreads);
 		}
 
-		@Deprecated
-		@DeprecatedConfigurationProperty(replacement = ""server.tomcat.max-http-form-post-size"")
-		public DataSize getMaxHttpPostSize() {
-			return this.maxHttpFormPostSize;
-		}
-
-		@Deprecated
-		public void setMaxHttpPostSize(DataSize maxHttpPostSize) {
-			this.maxHttpFormPostSize = maxHttpPostSize;
-		}
-
 		public DataSize getMaxHttpFormPostSize() {
 			return this.maxHttpFormPostSize;
 		}
@@ -1084,17 +1043,6 @@ public Threads getThreads() {
 			return this.threads;
 		}
 
-		@Deprecated
-		@DeprecatedConfigurationProperty(replacement = ""server.jetty.max-http-form-post-size"")
-		public DataSize getMaxHttpPostSize() {
-			return this.maxHttpFormPostSize;
-		}
-
-		@Deprecated
-		public void setMaxHttpPostSize(DataSize maxHttpPostSize) {
-			this.maxHttpFormPostSize = maxHttpPostSize;
-		}
-
 		public DataSize getMaxHttpFormPostSize() {
 			return this.maxHttpFormPostSize;
 		}
@@ -87,8 +87,6 @@ public void customize(ConfigurableJettyWebServerFactory factory) {
 						.addServerCustomizers(new MaxHttpHeaderSizeCustomizer(maxHttpHeaderSize)));
 		propertyMapper.from(jettyProperties::getMaxHttpFormPostSize).asInt(DataSize::toBytes).when(this::isPositive)
 				.to((maxHttpFormPostSize) -> customizeMaxHttpFormPostSize(factory, maxHttpFormPostSize));
-		propertyMapper.from(properties::getConnectionTimeout).whenNonNull()
-				.to((connectionTimeout) -> customizeIdleTimeout(factory, connectionTimeout));
 		propertyMapper.from(jettyProperties::getConnectionIdleTimeout).whenNonNull()
 				.to((idleTimeout) -> customizeIdleTimeout(factory, idleTimeout));
 		propertyMapper.from(jettyProperties::getAccesslog).when(ServerProperties.Jetty.Accesslog::isEnabled)
@@ -60,8 +60,6 @@ public void customize(NettyReactiveWebServerFactory factory) {
 		PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
 		propertyMapper.from(this.serverProperties::getMaxHttpHeaderSize)
 				.to((maxHttpRequestHeaderSize) -> customizeMaxHttpHeaderSize(factory, maxHttpRequestHeaderSize));
-		propertyMapper.from(this.serverProperties::getConnectionTimeout)
-				.to((connectionTimeout) -> customizeGenericConnectionTimeout(factory, connectionTimeout));
 		ServerProperties.Netty nettyProperties = this.serverProperties.getNetty();
 		propertyMapper.from(nettyProperties::getConnectionTimeout).whenNonNull()
 				.to((connectionTimeout) -> customizeConnectionTimeout(factory, connectionTimeout));
@@ -80,14 +78,6 @@ private void customizeMaxHttpHeaderSize(NettyReactiveWebServerFactory factory, D
 				(httpRequestDecoderSpec) -> httpRequestDecoderSpec.maxHeaderSize((int) maxHttpHeaderSize.toBytes())));
 	}
 
-	private void customizeGenericConnectionTimeout(NettyReactiveWebServerFactory factory, Duration connectionTimeout) {
-		if (!connectionTimeout.isZero()) {
-			long timeoutMillis = connectionTimeout.isNegative() ? 0 : connectionTimeout.toMillis();
-			factory.addServerCustomizers((httpServer) -> httpServer.tcpConfiguration((tcpServer) -> tcpServer
-					.selectorOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, (int) timeoutMillis)));
-		}
-	}
-
 	private void customizeConnectionTimeout(NettyReactiveWebServerFactory factory, Duration connectionTimeout) {
 		factory.addServerCustomizers((httpServer) -> httpServer.tcpConfiguration((tcpServer) -> tcpServer
 				.selectorOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, (int) connectionTimeout.toMillis())));
@@ -100,8 +100,6 @@ public void customize(ConfigurableTomcatWebServerFactory factory) {
 		propertyMapper.from(tomcatProperties::getAccesslog).when(ServerProperties.Tomcat.Accesslog::isEnabled)
 				.to((enabled) -> customizeAccessLog(factory));
 		propertyMapper.from(tomcatProperties::getUriEncoding).whenNonNull().to(factory::setUriEncoding);
-		propertyMapper.from(properties::getConnectionTimeout).whenNonNull()
-				.to((connectionTimeout) -> customizeConnectionTimeout(factory, connectionTimeout));
 		propertyMapper.from(tomcatProperties::getConnectionTimeout).whenNonNull()
 				.to((connectionTimeout) -> customizeConnectionTimeout(factory, connectionTimeout));
 		propertyMapper.from(tomcatProperties::getMaxConnections).when(this::isPositive)
@@ -78,8 +78,6 @@ public void customize(ConfigurableUndertowWebServerFactory factory) {
 		ServerProperties properties = this.serverProperties;
 		map.from(properties::getMaxHttpHeaderSize).asInt(DataSize::toBytes).when(this::isPositive)
 				.to(options.server(UndertowOptions.MAX_HEADER_SIZE));
-		map.from(properties::getConnectionTimeout).asInt(Duration::toMillis)
-				.to(options.server(UndertowOptions.NO_REQUEST_TIMEOUT));
 		mapUndertowProperties(factory, options);
 		mapAccessLogProperties(factory);
 		map.from(this::getOrDeduceUseForwardHeaders).to(factory::setUseForwardHeaders);
@@ -29,6 +29,14 @@
         ""level"": ""error""
       }
     },
+    {
+      ""name"": ""server.connection-timeout"",
+      ""type"" : ""java.time.Duration"",
+      ""deprecation"": {
+        ""reason"": ""Each server behaves differently. Use server specific properties instead."",
+        ""level"": ""error""
+      }
+    },
     {
       ""name"": ""server.jetty.accesslog.date-format"",
       ""deprecation"": {
@@ -119,6 +127,14 @@
       ""description"": ""Whether to enable HTTP/2 support, if the current environment supports it."",
       ""defaultValue"": false
     },
+    {
+      ""name"": ""server.jetty.max-http-post-size"",
+      ""type"": ""org.springframework.util.unit.DataSize"",
+      ""deprecation"": {
+        ""replacement"": ""server.jetty.max-http-form-post-size"",
+        ""level"": ""error""
+      }
+    },
     {
       ""name"": ""server.port"",
       ""defaultValue"": 8080
@@ -245,6 +261,23 @@
       ""name"": ""server.ssl.trust-store-type"",
       ""description"": ""Type of the trust store.""
     },
+    {
+      ""name"": ""server.tomcat.max-http-post-size"",
+      ""type"": ""org.springframework.util.unit.DataSize"",
+      ""deprecation"": {
+        ""replacement"": ""server.tomcat.max-http-form-post-size"",
+        ""level"": ""error""
+      }
+    },
+    {
+      ""name"": ""server.use-forward-headers"",
+      ""type"": ""java.lang.Boolean"",
+      ""deprecation"": {
+        ""reason"": ""Replaced to support additional strategies."",
+        ""replacement"": ""server.forward-headers-strategy"",
+        ""level"": ""error""
+      }
+    },
     {
       ""name"": ""spring.aop.auto"",
       ""type"": ""java.lang.Boolean"",
@@ -105,12 +105,6 @@ void testServerHeader() {
 		assertThat(this.properties.getServerHeader()).isEqualTo(""Custom Server"");
 	}
 
-	@Test
-	void testConnectionTimeout() {
-		bind(""server.connection-timeout"", ""60s"");
-		assertThat(this.properties.getConnectionTimeout()).hasMillis(60000);
-	}
-
 	@Test
 	void testTomcatBinding() {
 		Map<String, String> map = new HashMap<>();
@@ -403,7 +397,7 @@ void tomcatMinSpareThreadsMatchesProtocolDefault() throws Exception {
 
 	@Test
 	void tomcatMaxHttpPostSizeMatchesConnectorDefault() throws Exception {
-		assertThat(this.properties.getTomcat().getMaxHttpPostSize().toBytes())
+		assertThat(this.properties.getTomcat().getMaxHttpFormPostSize().toBytes())
 				.isEqualTo(getDefaultConnector().getMaxPostSize());
 	}
 
@@ -41,6 +41,7 @@
 import org.junit.jupiter.api.Test;
 
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.ServerProperties.ForwardHeadersStrategy;
 import org.springframework.boot.autoconfigure.web.ServerProperties.Jetty;
 import org.springframework.boot.context.properties.bind.Bindable;
 import org.springframework.boot.context.properties.bind.Binder;
@@ -251,7 +252,7 @@ private RequestLogWriter getLogWriter(CustomRequestLog requestLog) {
 
 	@Test
 	void setUseForwardHeaders() {
-		this.serverProperties.setUseForwardHeaders(true);
+		this.serverProperties.setForwardHeadersStrategy(ForwardHeadersStrategy.NATIVE);
 		ConfigurableJettyWebServerFactory factory = mock(ConfigurableJettyWebServerFactory.class);
 		this.customizer.customize(factory);
 		verify(factory).setUseForwardHeaders(true);
@@ -30,6 +30,7 @@
 import reactor.netty.tcp.TcpServer;
 
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.ServerProperties.ForwardHeadersStrategy;
 import org.springframework.boot.context.properties.source.ConfigurationPropertySources;
 import org.springframework.boot.web.embedded.netty.NettyReactiveWebServerFactory;
 import org.springframework.boot.web.embedded.netty.NettyServerCustomizer;
@@ -84,14 +85,6 @@ void defaultUseForwardHeaders() {
 		verify(factory).setUseForwardHeaders(false);
 	}
 
-	@Test
-	void setUseForwardHeaders() {
-		this.serverProperties.setUseForwardHeaders(true);
-		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
-		this.customizer.customize(factory);
-		verify(factory).setUseForwardHeaders(true);
-	}
-
 	@Test
 	void forwardHeadersWhenStrategyIsNativeShouldConfigureValve() {
 		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NATIVE);
@@ -109,30 +102,6 @@ void forwardHeadersWhenStrategyIsNoneShouldNotConfigureValve() {
 		verify(factory).setUseForwardHeaders(false);
 	}
 
-	@Test
-	void setServerConnectionTimeoutAsZero() {
-		setupServerConnectionTimeout(Duration.ZERO);
-		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
-		this.customizer.customize(factory);
-		verifyConnectionTimeout(factory, null);
-	}
-
-	@Test
-	void setServerConnectionTimeoutAsMinusOne() {
-		setupServerConnectionTimeout(Duration.ofNanos(-1));
-		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
-		this.customizer.customize(factory);
-		verifyConnectionTimeout(factory, 0);
-	}
-
-	@Test
-	void setServerConnectionTimeout() {
-		setupServerConnectionTimeout(Duration.ofSeconds(1));
-		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
-		this.customizer.customize(factory);
-		verifyConnectionTimeout(factory, 1000);
-	}
-
 	@Test
 	void setConnectionTimeout() {
 		setupConnectionTimeout(Duration.ofSeconds(1));
@@ -156,14 +125,8 @@ private void verifyConnectionTimeout(NettyReactiveWebServerFactory factory, Inte
 		assertThat(options).containsEntry(ChannelOption.CONNECT_TIMEOUT_MILLIS, expected);
 	}
 
-	private void setupServerConnectionTimeout(Duration connectionTimeout) {
-		this.serverProperties.setUseForwardHeaders(null);
-		this.serverProperties.setMaxHttpHeaderSize(null);
-		this.serverProperties.setConnectionTimeout(connectionTimeout);
-	}
-
 	private void setupConnectionTimeout(Duration connectionTimeout) {
-		this.serverProperties.setUseForwardHeaders(null);
+		this.serverProperties.setForwardHeadersStrategy(ForwardHeadersStrategy.NONE);
 		this.serverProperties.setMaxHttpHeaderSize(null);
 		this.serverProperties.getNetty().setConnectionTimeout(connectionTimeout);
 	}
@@ -32,6 +32,7 @@
 import org.junit.jupiter.api.Test;
 
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.ServerProperties.ForwardHeadersStrategy;
 import org.springframework.boot.context.properties.bind.Bindable;
 import org.springframework.boot.context.properties.bind.Binder;
 import org.springframework.boot.context.properties.source.ConfigurationPropertySources;
@@ -111,12 +112,6 @@ void customBackgroundProcessorDelay() {
 		assertThat(server.getTomcat().getEngine().getBackgroundProcessorDelay()).isEqualTo(5);
 	}
 
-	@Test
-	void customDisableMaxHttpPostSize() {
-		bind(""server.tomcat.max-http-post-size=-1"");
-		customizeAndRunServer((server) -> assertThat(server.getTomcat().getConnector().getMaxPostSize()).isEqualTo(-1));
-	}
-
 	@Test
 	void customDisableMaxHttpFormPostSize() {
 		bind(""server.tomcat.max-http-form-post-size=-1"");
@@ -131,13 +126,6 @@ void customMaxConnections() {
 						.isEqualTo(5));
 	}
 
-	@Test
-	void customMaxHttpPostSize() {
-		bind(""server.tomcat.max-http-post-size=10000"");
-		customizeAndRunServer(
-				(server) -> assertThat(server.getTomcat().getConnector().getMaxPostSize()).isEqualTo(10000));
-	}
-
 	@Test
 	void customMaxHttpFormPostSize() {
 		bind(""server.tomcat.max-http-form-post-size=10000"");
@@ -289,9 +277,8 @@ void defaultRemoteIpValve() {
 	}
 
 	@Test
-	void setUseForwardHeaders() {
-		// Since 1.3.0 no need to explicitly set header names if use-forward-header=true
-		this.serverProperties.setUseForwardHeaders(true);
+	void setUseNativeForwardHeadersStrategy() {
+		this.serverProperties.setForwardHeadersStrategy(ForwardHeadersStrategy.NATIVE);
 		testRemoteIpValveConfigured();
 	}
 
@@ -210,14 +210,6 @@ void defaultUseForwardHeaders() {
 		verify(factory).setUseForwardHeaders(false);
 	}
 
-	@Test
-	void setUseForwardHeaders() {
-		this.serverProperties.setUseForwardHeaders(true);
-		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
-		this.customizer.customize(factory);
-		verify(factory).setUseForwardHeaders(true);
-	}
-
 	@Test
 	void forwardHeadersWhenStrategyIsNativeShouldConfigureValve() {
 		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NATIVE);
@@ -1,3 +1,3 @@
 server.compression.enabled: true
 server.compression.min-response-size: 1
-server.connection-timeout=5000
+server.tomcat.connection-timeout=5s
",True,"The commit message refers to the removal of deprecated configuration properties, which is a common practice to improve the codebase and adhere to standards. The properties removed are `server.connection-timeout`, `server.use-forward-headers`, `server.jetty.max-http-post-size`, and `server.tomcat.max-http-post-size`. These properties were deprecated, and their removal is necessary to maintain the codebase and ensure it is up-to-date with the latest standards and best practices.",True,"The commit message 'Remove deprecated configuration properties' clearly states the reason for the changes, which are the removal of deprecated properties. The code diff shows that these properties are no longer present in the code, which confirms the necessity of the changes. The removed properties include 'server.connection-timeout', 'server.use-forward-headers', 'server.jetty.max-http-post-size', and 'server.tomcat.max-http-post-size'. These properties were deprecated, and their removal does not require an explicit rationale in the commit message.",True,"The commit message explains the motivation for the changes by mentioning that the deprecated properties are being removed. Additionally, the code diff shows that these properties were related to server connection timeout, which could potentially lead to issues if not properly managed. The commit message also closes an issue, which could provide further context about the necessity of the changes.",True,"The commit message 'Remove deprecated configuration properties' indicates that the changes are being made to remove properties that are no longer supported or recommended for use. This could be due to the deprecation of these properties in the API, which is a common source of requirements for changes in software development.",True,"The commit message directly mentions the removal of deprecated properties, which implies that the change is made to address issues or improvements in the code.",True,"The commit message 'Remove deprecated configuration properties' accurately summarizes the changes made in the code diff. It specifically mentions the removal of four deprecated properties, which are all present in the diff. This shows that the commit message is a clear summary of the changes made in the code.",True,"The commit message explains that the removed properties are deprecated and have been replaced with newer, more specific properties. This indicates that the change is based on the principle of updating and modernizing the configuration to better support the underlying server technologies and to provide more flexibility and control.",True,"The commit message 'Remove deprecated configuration properties' accurately describes the changes made in the code diff. It specifically mentions the removal of four deprecated properties, which are all present in the diff. Additionally, the commit message provides a link to the issue, which is a good practice. The message does not explicitly describe the behavior changes, but since the removed properties are deprecated, it can be inferred that their removal will not introduce any new behaviors.",False,"The commit message does not lack an explanation. It clearly states that the deprecated properties are being removed, which is a significant change that requires justification. The commit message also provides the list of removed properties and references the issue that prompted the change."
https://github.com/spring-projects/spring-boot/commit/24e873cd7c2608e642fd6e90460bc98079ba4e27,Move files from /.eclipse into /eclipse  <enter> Move the `eclipse.properties` file from `.eclipse` into `eclipse` since the IDE plugin supports both. ,https://api.github.com/repos/spring-projects/spring-boot/commits/24e873cd7c2608e642fd6e90460bc98079ba4e27,,False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that the `eclipse.properties` file is being moved from `.eclipse` to `eclipse` because the IDE plugin supports both locations. However, without more context or information about the project's conventions or standards, it's difficult to determine if this change was necessary or beneficial.",True,The commit message explains the reason for the change by stating that the IDE plugin supports both the old and new locations for the `eclipse.properties` file. This is a clear indication that the change is necessary to maintain the functionality of the plugin.,True,"The commit message explains the motivation for the change by mentioning that the IDE plugin supports both the locations for the `eclipse.properties` file, which implies that there was a shortcoming in the previous implementation that didn't account for this flexibility.",True,"The commit message indicates that the change is made to support both the old and new locations of the `eclipse.properties` file. This suggests that the change is made to accommodate a change in the IDE plugin, which could be due to user requirements or problems in the software maintenance process, such as outdated code or changes in the development environment.",True,"The commit message directly mentions the change's objective, which is to move the `eclipse.properties` file from `.eclipse` into `eclipse` to support both locations. This change is made to improve the code by ensuring the IDE plugin can find the configuration file in its new location.",True,The commit message does contain an expression that describes a summary of what changes by being a summary of the diffs. The message clearly states that it is moving files from one directory to another and specifies which file is being moved. This is a clear and concise summary of the changes made in the code diff.,False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that the files are being moved from one location to another due to the IDE plugin's support for both locations. However, it does not explain why this change is necessary or what technical principle it is based on.",True,"The commit message describes a change in the file structure of the project. It explains that the 'eclipse.properties' file is being moved from the '.eclipse' directory to the 'eclipse' directory. This change is functional as it allows the IDE plugin to support both the old and new locations of the file, which does not introduce any new behaviors but rather ensures the existing functionality continues to work.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'Move the `eclipse.properties` file from `.eclipse` into `eclipse` since the IDE plugin supports both.' This reason is not easily inferred from the code diff, as the diff only shows the file movement and not the context or reason behind it."
https://github.com/square/okhttp/commit/0e0f3a2d8d95278bf362eaeb08f13516e383fafd,"Push OkHttp 3.14.x into the sea. It is no longer supported. ( <pr_link> )  <enter> OkHttp 4.x is our only branch receiving security fixes, bug fixes, and new features. <enter> OkHttp 3.12.x gets security fixes only. ",https://api.github.com/repos/square/okhttp/commits/0e0f3a2d8d95278bf362eaeb08f13516e383fafd,"@@ -6,7 +6,6 @@ Security Policy
 | Version | Supported        | Notes          |
 | ------- | ---------------- | -------------- |
 | 4.x     | ✅               |  Android 5.0+ (API level 21+) and on Java 8+. |
-| 3.14.x  | Until 2020-06-30 |                |
 | 3.12.x  | Until 2021-12-31 | Android 2.3+ (API level 9+) and Java 7+. Platforms may not support TLSv1.2. |
 
 
",True,"The commit message refers to the support and maintenance policy for different versions of OkHttp. It explains that OkHttp 3.14.x is no longer supported, while OkHttp 4.x is the only branch receiving security fixes, bug fixes, and new features. This is a clear reference to a convention or standard (the support policy) and explains the necessity of the changes.",True,"The commit message clearly states the reason for the changes: OkHttp 3.14.x is no longer supported, and OkHttp 4.x is the only branch receiving updates. This is a common practice in version management to ensure that only the latest and most secure versions are used.",True,"The commit message explains the necessity of changes by mentioning that OkHttp 3.14.x is no longer supported. It states that OkHttp 4.x is the only branch receiving security fixes, bug fixes, and new features, while OkHttp 3.14.x does not. This directly elaborates the motivation of the code change, which is to ensure the project's security and functionality.",True,"The commit message indicates that the changes are necessary due to the end of support for OkHttp 3.14.x. The message mentions that OkHttp 3.14.x is no longer supported, and that OkHttp 4.x is the only branch receiving security fixes, bug fixes, and new features. This suggests that the changes are being made to address a problem in the software maintenance process, specifically the need to update to a supported version of the software to ensure security and functionality.",True,The commit message directly mentions the reason for the change by stating that OkHttp 3.14.x is no longer supported and that it is being replaced with OkHttp 4.x. This implies that the change is being made to improve the codebase by fixing security vulnerabilities and adding new features that are not available in the older version.,True,"The commit message accurately summarizes the changes made in the diff. It clearly states that OkHttp 3.14.x is being removed from the supported versions, and it mentions that OkHttp 4.x is the only version receiving updates. This directly reflects the changes made in the diff, which removed the line mentioning OkHttp 3.14.x.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly discusses the support status of different versions of OkHttp, but it does not explain why the changes are being made or what technical principle is being applied.",True,"The commit message expresses a change in the supported versions of OkHttp. It clearly states that OkHttp 3.14.x is no longer supported, and it highlights that OkHttp 4.x is the only branch receiving security fixes, bug fixes, and new features. This accurately summarizes the code changes from a functional perspective, as it describes the new behavior introduced by removing support for OkHttp 3.14.x and focusing on OkHttp 4.x.",False,"The commit message does not lack an explanation. It clearly states that OkHttp 3.14.x is no longer supported because OkHttp 4.x is the only branch receiving security fixes, bug fixes, and new features. The diff also supports this explanation by removing the line that mentions OkHttp 3.14.x being supported."
https://github.com/square/retrofit/commit/246bef5bf34c0598a91038b2e15bace7718408d4,Remove old ProGuard nonsense.  <enter> As of API 26 the android.jar contains the classes checked by Platform and used by Platform.Java8. And we don't encourage throwing checked exceptions from the service method but instead routing them through your call adapter. ,https://api.github.com/repos/square/retrofit/commits/246bef5bf34c0598a91038b2e15bace7718408d4,"@@ -30,10 +30,16 @@ Retrofit requires at minimum Java 7 or Android 2.3.
 ProGuard
 --------
 
-If you are using ProGuard you might need to add the following options:
+If you are using ProGuard you need to add the following options:
 ```
--dontwarn okio.**
--dontwarn javax.annotation.**
+# Retain generic type information for use by reflection by converters and adapters.
+-keepattributes Signature
+# Retain service method parameters.
+-keepclassmembernames,allowobfuscation interface * {
+    @retrofit2.http.* <methods>;
+}
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
 ```
 
 
@@ -176,18 +176,14 @@ <h4>Gradle</h4>
               <h4>ProGuard</h4>
               <p>If you are using ProGuard in your project add the following lines to your configuration:</p>
               <pre class=""prettyprint"">
-# Platform calls Class.forName on types which do not exist on Android to determine platform.
--dontnote retrofit2.Platform
-# Platform used when running on Java 8 VMs. Will not be used at runtime.
--dontwarn retrofit2.Platform$Java8
 # Retain generic type information for use by reflection by converters and adapters.
 -keepattributes Signature
-# Retain declared checked exceptions for use by a Proxy instance.
--keepattributes Exceptions
 # Retain service method parameters.
 -keepclassmembernames,allowobfuscation interface * {
     @retrofit2.http.* <methods>;
 }
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
 </pre>
             <p>Retrofit uses <a href=""https://github.com/square/okio"">Okio</a> under the hood, so you may want to look at its <a href=""https://github.com/square/okio#proguard"">ProGuard rules</a> as well.</p>
             </section>
",True,"The commit message refers to a convention regarding the use of ProGuard, explaining why the commit removes the old ProGuard nonsense. It mentions that as of API 26, the android.jar contains the classes checked by Platform and used by Platform.Java8, which makes the old ProGuard rules unnecessary. Additionally, the commit message suggests that the changes are made to encourage a better practice of routing checked exceptions through the call adapter instead of throwing them from the service method.",True,"The commit message explains the necessity of changes by stating that the old ProGuard configurations are no longer necessary. This is because as of API 26, the android.jar contains the classes checked by Platform and used by Platform.Java8. Additionally, the commit message mentions that the changes are made to retain generic type information for use by reflection by converters and adapters, retain service method parameters, and ignore an annotation used for build tooling. These explanations make it clear why the changes were made, even though the changes are common in the context of using ProGuard with Retrofit.",True,"The commit message explains the motivation for the changes by mentioning that as of API 26, the android.jar contains the classes checked by Platform and used by Platform.Java8. This means that the old ProGuard nonsense is no longer necessary. Additionally, the message mentions that the changes are made to avoid throwing checked exceptions from the service method, which is not encouraged.",True,"The commit message 'Remove old ProGuard nonsense' indicates that the changes are being made due to the outdated code in the ProGuard configuration. The message mentions that 'As of API 26 the android.jar contains the classes checked by Platform and used by Platform.Java8', which suggests that the changes are necessary to adapt to a new version of the Android API. This implies a problem in the maintenance of the software, specifically that the existing ProGuard configuration is no longer compatible with the current version of the Android API.",True,"The commit message directly mentions the objective of the change by stating 'Remove old ProGuard nonsense.' This implies that the change is being made to simplify or update the ProGuard configuration, which is likely due to changes in the Android API or best practices.",True,"The commit message 'Remove old ProGuard nonsense' summarizes the changes made in the diff by stating that it is removing outdated ProGuard options that are no longer necessary. It also mentions the addition of new ProGuard options to retain generic type information and service method parameters, which are listed in the diff.",True,"The commit message explains that the changes are being made to accommodate ProGuard, a tool used to shrink, optimize, and obfuscate your code. The message highlights the need to retain generic type information for use by reflection by converters and adapters, retain service method parameters, and ignore an annotation used for build tooling. These changes are based on the technical principle of preserving necessary information for the proper functioning of the Retrofit library, which uses Okio under the hood.",True,"The commit message 'Remove old ProGuard nonsense' describes the changes made to the ProGuard configuration. It explains that the changes are necessary because as of API 26, the android.jar contains the classes checked by Platform and used by Platform.Java8. This means that certain ProGuard options are no longer needed. The message also introduces new ProGuard options that are required to retain generic type information for use by reflection by converters and adapters, retain service method parameters, and ignore an annotation used for build tooling.",False,"The commit message does not just remove a space or a line. It explains the reason for the changes, which is to update the ProGuard options due to changes in the Android API and best practices for handling exceptions. The changes are not trivial and could potentially break the build if not properly handled, so an explanation is necessary."
https://github.com/square/retrofit/commit/2e15cf9e75e4204aa492ecc1cbe53053f95a2a8f,Promote Android logging to a class which knows about chunking.  <enter> Remove the concept of chunking from calling code. This is an Android-specific implementation detail which is now only performed when needed. ,https://api.github.com/repos/square/retrofit/commits/2e15cf9e75e4204aa492ecc1cbe53053f95a2a8f,"@@ -17,12 +17,12 @@
 
 import android.os.Build;
 import android.os.Process;
-import android.util.Log;
 import com.google.gson.Gson;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
 import retrofit.android.AndroidApacheClient;
+import retrofit.android.AndroidLog;
 import retrofit.android.MainThreadExecutor;
 import retrofit.client.Client;
 import retrofit.client.OkClient;
@@ -143,11 +143,7 @@ private static class Android extends Platform {
     }
 
     @Override RestAdapter.Log defaultLog() {
-      return new RestAdapter.Log() {
-        @Override public void log(String message) {
-          Log.d(""Retrofit"", message);
-        }
-      };
+      return new AndroidLog(""Retrofit"");
     }
   }
 
@@ -107,7 +107,6 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public class RestAdapter {
-  private static final int LOG_CHUNK_SIZE = 4000;
   static final String THREAD_PREFIX = ""Retrofit-"";
   static final String IDLE_THREAD_NAME = THREAD_PREFIX + ""Idle"";
 
@@ -396,11 +395,7 @@ private Request logAndReplaceRequest(Request request) throws IOException {
           byte[] bodyBytes = ((TypedByteArray) body).getBytes();
           bodySize = bodyBytes.length;
           String bodyCharset = MimeUtil.parseCharset(bodyMime);
-          String bodyString = new String(bodyBytes, bodyCharset);
-          for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
-            int end = Math.min(len, i + LOG_CHUNK_SIZE);
-            log.log(bodyString.substring(i, end));
-          }
+          log.log(new String(bodyBytes, bodyCharset));
         }
       }
 
@@ -440,11 +435,7 @@ private Response logAndReplaceResponse(String url, Response response, long elaps
           bodySize = bodyBytes.length;
           String bodyMime = body.mimeType();
           String bodyCharset = MimeUtil.parseCharset(bodyMime);
-          String bodyString = new String(bodyBytes, bodyCharset);
-          for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
-            int end = Math.min(len, i + LOG_CHUNK_SIZE);
-            log.log(bodyString.substring(i, end));
-          }
+          log.log(new String(bodyBytes, bodyCharset));
         }
       }
 
@@ -0,0 +1,22 @@
+package retrofit.android;
+
+import android.util.Log;
+import retrofit.RestAdapter;
+
+/** A {@link RestAdapter.Log logger} for Android. */
+public class AndroidLog implements RestAdapter.Log {
+  private static final int LOG_CHUNK_SIZE = 4000;
+
+  private final String tag;
+
+  public AndroidLog(String tag) {
+    this.tag = tag;
+  }
+
+  @Override public void log(String message) {
+    for (int i = 0, len = message.length(); i < len; i += LOG_CHUNK_SIZE) {
+      int end = Math.min(len, i + LOG_CHUNK_SIZE);
+      Log.d(tag, message.substring(i, end));
+    }
+  }
+}
",True,"The commit message refers to the concept of chunking, which is an implementation detail specific to Android. The changes promote this functionality to a separate class, making it more modular and reducing the responsibility of the calling code. This improves the codebase by separating concerns and making the code more maintainable.",True,"The commit message explains that the changes are being made to promote Android logging to a class which knows about chunking and to remove the concept of chunking from calling code. This is done to encapsulate an Android-specific implementation detail, which is only performed when needed. The code diff also supports this explanation by showing the removal of the chunking logic from the calling code and the creation of a new AndroidLog class that handles chunking.",True,"The commit message explains the motivation for the changes by mentioning that the concept of chunking is being removed from the calling code and is now only performed when needed. This is done to promote Android logging to a class that knows about chunking, which is an Android-specific implementation detail.",True,"The commit message 'Promote Android logging to a class which knows about chunking. Remove the concept of chunking from calling code. This is an Android-specific implementation detail which is now only performed when needed.' indicates that the changes were made to handle Android-specific logging requirements. The message mentions 'chunking', which was previously handled in the calling code, but is now only performed when needed, suggesting that this was done to improve performance or maintainability. This could be considered a change made to address a problem in the process of software maintenance, specifically out of date code that was no longer necessary.",True,The commit message directly mentions the improvement it makes to the code by stating that it promotes Android logging to a class which knows about chunking and removes the concept of chunking from calling code. This change simplifies the code and hides an Android-specific implementation detail.,True,"The commit message 'Promote Android logging to a class which knows about chunking' accurately summarizes the changes made in the diff. It highlights the key component of the change, which is the refactoring of the logging functionality into a separate class that handles chunking. Additionally, the message contrasts the before and after by mentioning the removal of the chunking concept from the calling code, implying that this was previously handled inline.",True,The commit message explains that the changes are promoting the Android logging to a separate class which handles the concept of chunking. This is a technical principle underpinning the changes as it improves the modularity and separation of concerns in the codebase.,True,"The commit message expresses a refactoring of the code by promoting Android logging to a separate class. This change introduces a new behavior where logging is now handled by the AndroidLog class, which is responsible for chunking the log messages. The code diff also supports this explanation by showing the removal of the chunking logic from the calling code and the introduction of the AndroidLog class.",False,"The commit message does explain the reason for the commit, which is to promote Android logging to a separate class and remove the concept of chunking from the calling code. This change is not just a simple removal of a space, but rather a refactoring of the code to improve modularity and separation of concerns. Therefore, a commit message is necessary to explain this change."
https://github.com/square/retrofit/commit/9d683b75b111e60d30da8a03335d2ce71f5e8585,"Migrate forced suspension mechanism from yield to Dispatcher.Default  <enter> Since it's possible for certain dispatchers to completely avoid yielding, and currently the immediate dispatchers exhibit this behavior, we need an alternate mechanism of forcing suspension or UndeclaredThrowableExceptions will still be seen. <enter> Retrofit does not have its own thread pool onto which we can defer resuming. Instead we rely to Dispatchers.Default and forcibly suspend the caller using low-level coroutine intrinsics. ",https://api.github.com/repos/square/retrofit/commits/9d683b75b111e60d30da8a03335d2ce71f5e8585,"@@ -170,7 +170,7 @@ static final class SuspendForResponse<ResponseT> extends HttpServiceMethod<Respo
       try {
         return KotlinExtensions.awaitResponse(call, continuation);
       } catch (Exception e) {
-        return KotlinExtensions.yieldAndThrow(e, continuation);
+        return KotlinExtensions.suspendAndThrow(e, continuation);
       }
     }
   }
@@ -206,7 +206,7 @@ static final class SuspendForBody<ResponseT> extends HttpServiceMethod<ResponseT
             ? KotlinExtensions.awaitNullable(call, continuation)
             : KotlinExtensions.await(call, continuation);
       } catch (Exception e) {
-        return KotlinExtensions.yieldAndThrow(e, continuation);
+        return KotlinExtensions.suspendAndThrow(e, continuation);
       }
     }
   }
@@ -18,8 +18,11 @@
 
 package retrofit2
 
+import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.suspendCancellableCoroutine
-import kotlinx.coroutines.yield
+import kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED
+import kotlin.coroutines.intrinsics.intercepted
+import kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn
 import kotlin.coroutines.resume
 import kotlin.coroutines.resumeWithException
 
@@ -97,7 +100,20 @@ suspend fun <T : Any> Call<T>.awaitResponse(): Response<T> {
   }
 }
 
-internal suspend fun Exception.yieldAndThrow(): Nothing {
-  yield()
-  throw this
+/**
+ * Force the calling coroutine to suspend before throwing [this].
+ *
+ * This is needed when a checked exception is synchronously caught in a [java.lang.reflect.Proxy]
+ * invocation to avoid being wrapped in [java.lang.reflect.UndeclaredThrowableException].
+ *
+ * The implementation is derived from:
+ * https://github.com/Kotlin/kotlinx.coroutines/pull/1667#issuecomment-556106349
+ */
+internal suspend fun Exception.suspendAndThrow(): Nothing {
+  suspendCoroutineUninterceptedOrReturn<Nothing> { continuation ->
+    Dispatchers.Default.dispatch(continuation.context, Runnable {
+      continuation.intercepted().resumeWithException(this@suspendAndThrow)
+    })
+    COROUTINE_SUSPENDED
+  }
 }
@@ -15,9 +15,11 @@
  */
 package retrofit2
 
+import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.GlobalScope
 import kotlinx.coroutines.async
 import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.withContext
 import okhttp3.OkHttpClient
 import okhttp3.mockwebserver.MockResponse
 import okhttp3.mockwebserver.MockWebServer
@@ -35,6 +37,7 @@ import retrofit2.http.Path
 import java.io.IOException
 import java.lang.reflect.ParameterizedType
 import java.lang.reflect.Type
+import kotlin.coroutines.CoroutineContext
 
 class KotlinSuspendTest {
   @get:Rule val server = MockWebServer()
@@ -283,15 +286,19 @@ class KotlinSuspendTest {
 
     server.shutdown()
 
-    // The problematic behavior of the UnknownHostException being synchronously thrown is
-    // probabilistic based on thread preemption. Running a thousand times will almost always
-    // trigger it, so we run an order of magnitude more to be safe.
-    repeat(10000) {
-      try {
-        example.body()
-        fail()
-      } catch (_: IOException) {
-        // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+    // Run with a dispatcher that prevents yield from actually deferring work. An old workaround
+    // for this problem relied on yield, but it is not guaranteed to prevent direct execution.
+    withContext(DirectUnconfinedDispatcher) {
+      // The problematic behavior of the UnknownHostException being synchronously thrown is
+      // probabilistic based on thread preemption. Running a thousand times will almost always
+      // trigger it, so we run an order of magnitude more to be safe.
+      repeat(10000) {
+        try {
+          example.body()
+          fail()
+        } catch (_: IOException) {
+          // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+        }
       }
     }
   }
@@ -305,16 +312,25 @@ class KotlinSuspendTest {
 
     server.shutdown()
 
-    // The problematic behavior of the UnknownHostException being synchronously thrown is
-    // probabilistic based on thread preemption. Running a thousand times will almost always
-    // trigger it, so we run an order of magnitude more to be safe.
-    repeat(10000) {
-      try {
-        example.response()
-        fail()
-      } catch (_: IOException) {
-        // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+    // Run with a dispatcher that prevents yield from actually deferring work. An old workaround
+    // for this problem relied on yield, but it is not guaranteed to prevent direct execution.
+    withContext(DirectUnconfinedDispatcher) {
+      // The problematic behavior of the UnknownHostException being synchronously thrown is
+      // probabilistic based on thread preemption. Running a thousand times will almost always
+      // trigger it, so we run an order of magnitude more to be safe.
+      repeat(10000) {
+        try {
+          example.response()
+          fail()
+        } catch (_: IOException) {
+          // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+        }
       }
     }
   }
+
+  private object DirectUnconfinedDispatcher : CoroutineDispatcher() {
+    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false
+    override fun dispatch(context: CoroutineContext, block: Runnable) = block.run()
+  }
 }
",True,"The commit message refers to the necessity of changes by referencing a problem with the current implementation. It mentions that certain dispatchers can completely avoid yielding, which leads to UndeclaredThrowableExceptions. The commit message then explains that the changes are being made to address this issue by migrating the forced suspension mechanism from yield to Dispatcher.Default.",True,"The commit message explains the necessity of changes by providing a clear rationale. It explains that certain dispatchers can completely avoid yielding, and currently the immediate dispatchers exhibit this behavior. This can lead to UndeclaredThrowableExceptions being seen. The commit message then explains that the solution is to migrate the forced suspension mechanism from yield to Dispatcher.Default, which is a more reliable way to force suspension.",True,"The commit message directly elaborates the motivation of the code change by mentioning the issue of UndeclaredThrowableExceptions that could arise if the exceptions were not properly handled. It also mentions the specific scenario where certain dispatchers completely avoid yielding, which is the cause of the problem.",True,"The commit message describes the necessity of changes by mentioning the problem of UndeclaredThrowableExceptions being seen when certain dispatchers completely avoid yielding. This indicates that the changes are being made to address a problem in the software maintenance process, specifically to fix a bug or issue.",True,"The commit message directly mentions the issue it fixes: 'UndeclaredThrowableExceptions will still be seen' due to certain dispatchers completely avoiding yielding. The change is made to 'force suspension' using an alternate mechanism, which is described as 'migrating from yield to Dispatcher.Default'.",True,"The commit message describes the change accurately by summarizing the key components of the change. It mentions the migration of the forced suspension mechanism from 'yield' to 'Dispatcher.Default', which is a clear contrast between the before and after. Additionally, it explains the reason for the change, which is to avoid UndeclaredThrowableExceptions when certain dispatchers completely avoid yielding. The code diff also supports this explanation by showing the specific methods that are being renamed from 'yieldAndThrow' to 'suspendAndThrow'.",True,"The commit message explains that the change is made to address the issue of UndeclaredThrowableExceptions being seen when certain dispatchers completely avoid yielding. This is due to the synchronous throwing of UnknownHostException, which is being resolved by forcing the suspension of the caller using low-level coroutine intrinsics. This is a clear expression of the technical principle underpinning the changes, which is to ensure that exceptions are not wrapped in UndeclaredThrowableException by forcing the caller to suspend.",True,"The commit message describes the migration of the forced suspension mechanism from 'yield' to 'Dispatcher.Default'. This change is made to address the issue where certain dispatchers can completely avoid yielding, leading to UndeclaredThrowableExceptions. The commit message explains this functional change and its impact on the behavior of the code.",False,"The commit message does not lack an explanation. It clearly explains the reason for the commit: the current forced suspension mechanism using 'yield' can lead to UndeclaredThrowableExceptions, especially with certain dispatchers that completely avoid yielding. The commit replaces 'yield' with 'Dispatcher.Default' to avoid this issue."
https://github.com/spring-projects/spring-boot/commit/ae3225e76e6f5e7d7680bfd9b5cca9da13a6efbc,"Mention that Lettuce requires commons-pool2  <enter> We intend to remove this limitation in a future milestone but as the Lettuce auto-configuration requires `commons-pool2`, this commit updates the How-To to mention that. <enter> See  <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/ae3225e76e6f5e7d7680bfd9b5cca9da13a6efbc,"@@ -3081,8 +3081,9 @@ normal in a Spring Boot application (you normally only have one application cont
 === Use Lettuce instead of Jedis
 The Spring Boot starter (`spring-boot-starter-data-redis`) uses
 https://github.com/xetorthio/jedis/[Jedis] by default. You need to exclude that dependency
-and include the https://github.com/lettuce-io/lettuce-core/[Lettuce] one instead. Spring
-Boot manages that dependency to help make this process as easy as possible.
+and include the https://github.com/lettuce-io/lettuce-core/[Lettuce] one instead. You also
+need `commons-pool2`. Spring Boot manages these dependencies to help make this process as
+easy as possible.
 
 Example in Maven:
 
@@ -3102,6 +3103,10 @@ Example in Maven:
 		<groupId>io.lettuce</groupId>
 		<artifactId>lettuce-core</artifactId>
 	</dependency>
+	<dependency>
+		<groupId>org.apache.commons</groupId>
+		<artifactId>commons-pool2</artifactId>
+	</dependency>
 ----
 
 Example in Gradle:
@@ -3113,7 +3118,8 @@ Example in Gradle:
 	}
 
 	dependencies {
-		compile(""io.lettuce:lettuce-core:{lettuce.version}"")
+		compile(""io.lettuce:lettuce-core"")
+		compile(""org.apache.commons:commons-pool2"")
 		// ...
 	}
 ----
",True,"The commit message mentions that Lettuce requires commons-pool2, which is not previously mentioned in the documentation. This commit updates the documentation to reflect this requirement, which is a necessary change to ensure that users are aware of the additional dependency needed when using Lettuce. This is an example of the commit message describing the necessity of changes by referencing a convention or standard (in this case, the requirement of commons-pool2 for Lettuce).",True,"The commit message mentions that Lettuce requires commons-pool2 and the code diff shows that the dependency has been added to the project. This is a common requirement when using Lettuce, so the commit message does not need to provide a detailed rationale for the change.",True,"The commit message explains the necessity of changes by mentioning that Lettuce requires commons-pool2 for its auto-configuration. This is a shortcoming of the previous implementation that is being addressed in the commit. The message also mentions that this limitation will be removed in a future milestone, but for now, the How-To is being updated to include this requirement.",True,"The commit message mentions that Lettuce requires commons-pool2, which is not previously mentioned in the documentation. This indicates a problem in the process of software maintenance, specifically out-of-date code or documentation.",True,"The commit message directly mentions the improvement it makes to the code by stating that it updates the How-To to mention that Lettuce requires commons-pool2. This is an important change as it was previously not explicitly stated, and the code diff confirms this change.",True,The commit message accurately summarizes the changes made in the code diff. It mentions that Lettuce requires commons-pool2 and that this requirement is being added to the project. It also mentions that the How-To section of the project is being updated to reflect this change. This is a clear and concise summary of the changes made in the code diff.,True,"The commit message explains that the changes are made to accommodate the requirement of Lettuce, which needs commons-pool2. This highlights the technical principle that a dependency of a new library (Lettuce) is being added to the project, which is a common practice in software development.",True,The commit message accurately summarizes the changes by explaining that it removes the limitation that Lettuce requires commons-pool2. It also mentions that this change is made to update the How-To documentation. The code diff supports this by adding the commons-pool2 dependency to the examples for both Maven and Gradle.,False,The commit message does not lack an explanation. It clearly states that Lettuce requires commons-pool2 and that the change is made to update the documentation to reflect this requirement. The code diff also supports this explanation by adding the commons-pool2 dependency to the examples in both Maven and Gradle.
https://github.com/junit-team/junit4/commit/1360f9b696f2fb1bc32b16b070ffb3363a88864f,Update Maven GPG plugin from 1.4 to 1.5.  <enter> Just to keep up-to-date. Release notes:  http://jira.codehaus.org/browse/MGPG/fixforversion/17635 ,https://api.github.com/repos/junit-team/junit4/commits/1360f9b696f2fb1bc32b16b070ffb3363a88864f,"@@ -289,7 +289,7 @@
                         (&ndash;&ndash; stands for double dash)
                         -->
                         <artifactId>maven-gpg-plugin</artifactId>
-                        <version>1.4</version>
+                        <version>1.5</version>
                         <executions>
                             <execution>
                                 <id>gpg-sign</id>
",True,"The commit message refers to the necessity of changes by mentioning that the update is to keep the Maven GPG plugin up-to-date. This is a common practice to ensure the use of the latest version for security and feature updates. The message also provides a link to the release notes, which can further explain the improvements or bug fixes in the new version.",True,"The commit message 'Update Maven GPG plugin from 1.4 to 1.5. Just to keep up-to-date.' does contain an expression that describes the necessity of changes. The message explicitly states that the update is to keep the plugin up-to-date, which is a common reason for version updates. The code diff also supports this explanation, as it only changes the version number of the Maven GPG plugin from 1.4 to 1.5. This is a clear indication of an update to keep the software up-to-date.",False,"The commit message does not explicitly describe the necessity of the changes. It only mentions that the update is to keep the system up-to-date and provides a link to the release notes. However, it does not elaborate on any error scenario, issue report, or shortcoming of the previous implementation that necessitated the change.",True,"The commit message 'Update Maven GPG plugin from 1.4 to 1.5. Just to keep up-to-date.' indicates that the developer is updating the plugin to the latest version to keep the software up-to-date. This could be due to the need to incorporate new features, improvements, or bug fixes provided in the newer version. Therefore, the message expresses the necessity of changes to meet the requirements of users or to maintain the software.",True,"The commit message directly mentions the change from version 1.4 to 1.5 of the Maven GPG plugin. This change is likely made to keep the plugin up-to-date. The provided Jira link (http://jira.codehaus.org/browse/MGPG/fixforversion/17635) might contain more details about the improvements or defects fixed in version 1.5, but the commit message itself does not explicitly state these. However, the mention of updating the plugin and providing a link to the release notes suggests that the change is likely to include improvements or bug fixes.",True,"The commit message 'Update Maven GPG plugin from 1.4 to 1.5' accurately summarizes the change in the code diff. It clearly states the component that was changed (Maven GPG plugin), the previous version (1.4), and the new version (1.5). This is a direct and clear summary of the changes made in the diff.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that the Maven GPG plugin is being updated from version 1.4 to 1.5 for the purpose of keeping up-to-date. The code diff shows that the version number is being changed, but it does not provide any insight into why this change is necessary or what technical principle it is based on.",True,"The commit message 'Update Maven GPG plugin from 1.4 to 1.5' clearly describes the change in the code diff. It explains that the version of the Maven GPG plugin is being updated from 1.4 to 1.5. This change does not introduce new behaviors or functionalities, but it does modify existing behavior as the new version may have bug fixes or improvements that affect the plugin's functionality. The message also provides a link to the release notes, which can be used to further understand the changes made in the update.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'Just to keep up-to-date'. Additionally, it provides a link to the release notes for further context. The change in the code diff is also a version update, which is a significant change that warrants an explanation in the commit message."
https://github.com/square/okhttp/commit/16f1d048165d2bf0aee4833ff7d8b415f537ce64,"api has changed, fixing the example ",https://api.github.com/repos/square/okhttp/commits/16f1d048165d2bf0aee4833ff7d8b415f537ce64,"@@ -42,7 +42,7 @@ public void test() throws Exception {
   server.start();
 
   // Ask the server for its URL. You'll need this to make HTTP requests.
-  URL baseUrl = server.url(""/v1/chat/"");
+  HttpUrl baseUrl = server.url(""/v1/chat/"");
 
   // Exercise your application code, which should make those HTTP requests.
   // Responses are returned in the same order that they are enqueued.
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that the API has changed and the example is being fixed. However, without looking at the code diff, it's not clear what specific changes were made to the API or the example that require fixing.",False,"The commit message does not explicitly state the reason for the change, such as a bug fix, feature addition, or performance improvement. While it's clear from the diff that the change is related to an API update, the message does not provide a clear explanation of why the change was necessary or what problem it solves. Therefore, the message does not fully describe the necessity of the changes.",False,"The commit message does not explicitly describe the necessity of changes. It only mentions that the API has changed and it's fixing the example. However, the code diff suggests that the change is due to a type mismatch, as the URL type is changed from URL to HttpUrl. A more descriptive commit message could have mentioned this type mismatch and explained why it was necessary to change the type.",True,"The commit message 'api has changed, fixing the example' indicates that the developer made changes to the example to match the changes of an API. This suggests that the source of the requirements was a change in the API, which is a common source of necessity for changes in software development.",True,"The commit message 'api has changed, fixing the example' directly mentions the change made to the code, which is fixing the example. The code diff also supports this by changing the URL type from URL to HttpUrl. This change could be due to a defect in the previous implementation or an improvement to better handle HTTP URLs, which is explicitly mentioned in the commit message.",False,"The commit message does not directly describe the change made in the diff. It mentions that the API has changed and that an example is being fixed, but it does not explicitly state that the URL type has been changed from URL to HttpUrl.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions that the API has changed and an example is being fixed. The code diff suggests that the URL object type is being changed from URL to HttpUrl, which might be due to the need for additional functionality provided by HttpUrl. However, the commit message does not explain why this change was necessary or what principle it is based on.",True,"The commit message 'api has changed, fixing the example' does contain an expression that describes a summary of what changes by explaining the code changes from a functional perspective. The change in the code diff from 'URL baseUrl' to 'HttpUrl baseUrl' indicates that the type of the base URL has been modified. This change likely signifies that the API client is being updated to use a more specific and appropriate type for the base URL, which could introduce new behaviors or capabilities. Therefore, the commit message does describe new behaviors introduced by the change.",True,"The commit message indicates that a change was made to the API, specifically the type of the base URL. The change from 'URL' to 'HttpUrl' is a clear indication of the reason for the commit. Since the change is small and simple, and its purpose can be easily inferred from the code diff, there was no need for an additional explanation in the commit message."
https://github.com/square/okhttp/commit/32a2b1d8d000a19d4a340cc1d77a68973a9d65dc,"OkBuffer API sketch.  <enter> I'm unhappy with java.io:  * No timeouts.  * Every layer needs to copy bytes around. Always copying bytes.  * Features like mark/reset and available() are clumsy.  * Its awkard in mixed text/binary protocols like HTTP because    character decoding is separate and takes over the stream. <enter> Unfortunately java.nio isn't better, just different:  * It's complex.  * Buffers are fixed size.  * No built-in buffer pooling.  * Features like mark/reset/position are clumsy. <enter> This is an obnoxious attempt at a 3rd I/O interface, mostly inspired by InputStream and OutputStream, but using growable buffers instead of byte arrays as the core data container. ",https://api.github.com/repos/square/okhttp/commits/32a2b1d8d000a19d4a340cc1d77a68973a9d65dc,"@@ -18,7 +18,7 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.util.Arrays;
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal;
 
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.lang.reflect.Constructor;
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package com.squareup.okhttp.internal.bytes;
 
+import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -34,7 +35,7 @@
  * process.
  */
 public final class ByteString {
-  private final byte[] data;
+  final byte[] data;
   private transient int hashCode; // Lazily computed; 0 if unknown.
   private transient String utf8; // Lazily computed.
 
@@ -119,7 +120,7 @@ public static ByteString concat(ByteString... byteStrings) {
     return new ByteString(result);
   }
 
-  private ByteString(byte[] data) {
+  ByteString(byte[] data) {
     this.data = data; // Trusted internal constructor doesn't clone data.
   }
 
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+
+/**
+ * A collection of bytes in memory.
+ *
+ * <p><strong>Moving data from one OkBuffer to another is fast.</strong> Instead
+ * of copying bytes from one place in memory to another, this class just changes
+ * ownership of the underlying bytes.
+ *
+ * <p><strong>This buffer grows with your data.</strong> Just like ArrayList,
+ * each OkBuffer starts small. It consumes only the memory it needs to.
+ *
+ * <p><strong>This buffer pools its byte arrays.</strong> When you allocate a
+ * byte array in Java, the runtime must zero-fill the requested array before
+ * returning it to you. Even if you're going to write over that space anyway.
+ * This class avoids zero-fill and GC churn by pooling byte arrays.
+ */
+public final class OkBuffer implements Source, Sink {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+  private Segment segment;
+  private long byteCount;
+
+  public OkBuffer() {
+  }
+
+  /** Returns the number of bytes currently in this buffer. */
+  public long byteCount() {
+    return byteCount;
+  }
+
+  /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
+  public ByteString readByteString(int byteCount) {
+    return new ByteString(readBytes(byteCount));
+  }
+
+  /** Removes {@code byteCount} bytes from this, decodes them as UTF-8 and returns the string. */
+  public String readUtf8(int byteCount) {
+    return new String(readBytes(byteCount), Util.UTF_8);
+  }
+
+  private byte[] readBytes(int byteCount) {
+    if (byteCount > this.byteCount) {
+      throw new IllegalArgumentException(
+          String.format(""requested %s > available %s"", byteCount, this.byteCount));
+    }
+
+    int offset = 0;
+    byte[] result = new byte[byteCount];
+
+    while (offset < byteCount) {
+      int toCopy = Math.min(byteCount - offset, segment.limit - segment.pos);
+      System.arraycopy(segment.data, segment.pos, result, offset, toCopy);
+
+      offset += toCopy;
+      segment.pos += toCopy;
+
+      if (segment.pos == segment.limit) {
+        segment = segment.pop(); // Recycle this empty segment.
+      }
+    }
+
+    this.byteCount -= byteCount;
+    return result;
+  }
+
+  /** Appends {@code byteString} to this. */
+  public void write(ByteString byteString) {
+    write(byteString.data);
+  }
+
+  /** Encodes {@code string} as UTF-8 and appends the bytes to this. */
+  public void writeUtf8(String string) {
+    write(string.getBytes(Util.UTF_8));
+  }
+
+  private void write(byte[] data) {
+    int offset = 0;
+    while (offset < data.length) {
+      if (segment == null) {
+        segment = SegmentPool.INSTANCE.take(); // Acquire a first segment.
+        segment.next = segment.prev = segment;
+      }
+
+      Segment tail = segment.prev;
+      if (tail.limit == Segment.SIZE) {
+        tail = tail.push(); // Acquire a new empty segment.
+      }
+
+      int toCopy = Math.min(data.length - offset, Segment.SIZE - tail.limit);
+      System.arraycopy(data, offset, tail.data, tail.limit, toCopy);
+
+      offset += toCopy;
+      tail.limit += toCopy;
+    }
+
+    this.byteCount += data.length;
+  }
+
+  @Override public void write(OkBuffer source, long byteCount, Timeout timeout) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount, Timeout timeout) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public long indexOf(byte b, Timeout timeout) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public void flush(Timeout timeout) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public void close(Timeout timeout) {
+    throw new UnsupportedOperationException();
+  }
+
+  /**
+   * Returns the contents of this buffer in hex. For buffers larger than 1 MiB
+   * this method is undefined.
+   */
+  @Override public String toString() {
+    if (byteCount > 0x100000) return super.toString();
+    char[] result = new char[(int) (byteCount * 2)];
+    int offset = 0;
+    for (Segment s = segment; offset < byteCount; s = s.next) {
+      for (int i = s.pos; i < s.limit; i++) {
+        result[offset++] = HEX_DIGITS[(s.data[i] >> 4) & 0xf];
+        result[offset++] = HEX_DIGITS[s.data[i] & 0xf];
+      }
+      offset += s.limit - s.pos;
+    }
+    return new String(result);
+  }
+}
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+/**
+ * A segment of an OkBuffer.
+ *
+ * <p>Each segment in an OkBuffer is a circularly-linked list node referencing
+ * the following and preceding segments in the buffer.
+ *
+ * <p>Each segment in the pool is a singly-linked list node referencing the rest
+ * of segments in the pool.
+ */
+final class Segment {
+  /** The size of all segments in bytes. */
+  // TODO: Using fixed-size segments makes pooling easier. But it harms memory
+  //       efficiency and encourages copying. Try variable sized segments?
+  // TODO: Is 2 KiB a good default segment size?
+  static final int SIZE = 2048;
+
+  final byte[] data;
+  int pos;
+  int limit;
+
+  /** Next segment in a linked list. */
+  Segment next;
+
+  /** Previous segment in a linked list. */
+  Segment prev;
+
+  Segment() {
+    data = new byte[SIZE];
+  }
+
+  /**
+   * Removes this head of a circularly-linked list, recycles it, and returns the
+   * new head of the list. Returns null if the list is now empty.
+   */
+  public Segment pop() {
+    Segment result = next != this ? next : null;
+    prev.next = next;
+    next.prev = prev;
+    next = null;
+    prev = null;
+    SegmentPool.INSTANCE.recycle(this);
+    return result;
+  }
+
+  /**
+   * Acquires a segment and appends it to this tail of a circularly-linked list.
+   * Returns the new tail segment.
+   */
+  public Segment push() {
+    Segment result = SegmentPool.INSTANCE.take();
+    result.prev = this;
+    result.next = next;
+    next.prev = result;
+    next = result;
+    return result;
+  }
+}
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+/**
+ * A collection of unused segments, necessary to avoid GC churn and zero-fill.
+ * This pool is a thread-safe static singleton.
+ */
+final class SegmentPool {
+  static final SegmentPool INSTANCE = new SegmentPool();
+
+  /** The maximum number of bytes to pool. */
+  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?
+  static final long MAX_SIZE = 64 * 1024; // 64 KiB.
+
+  /** Singly-linked list of segments. */
+  private Segment next;
+
+  /** Total bytes in this pool. */
+  long byteCount;
+
+  private SegmentPool() {
+  }
+
+  Segment take() {
+    synchronized (this) {
+      if (next != null) {
+        Segment result = next;
+        next = result.next;
+        result.next = null;
+        byteCount -= Segment.SIZE;
+        return result;
+      }
+    }
+    return new Segment(); // Pool is empty. Don't zero-fill while holding a lock.
+  }
+
+  void recycle(Segment segment) {
+    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();
+    synchronized (this) {
+      if (byteCount + Segment.SIZE > MAX_SIZE) return; // Pool is full.
+      byteCount += Segment.SIZE;
+      segment.next = next;
+      segment.pos = segment.limit = 0;
+      next = segment;
+    }
+  }
+}
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+
+/**
+ * An alternative to OutputStream.
+ */
+public interface Sink {
+  /** Removes {@code byteCount} bytes from {@code source} and appends them to this. */
+  void write(OkBuffer source, long byteCount, Timeout timeout) throws IOException;
+
+  /** Pushes all buffered bytes to their final destination. */
+  void flush(Timeout timeout) throws IOException;
+
+  /**
+   * Pushes all buffered bytes to their final destination and releases the
+   * resources held by this sink. It is an error to write a closed sink. It is
+   * safe to close a sink more than once.
+   */
+  void close(Timeout timeout) throws IOException;
+}
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+
+/**
+ * An alternative to InputStream.
+ */
+public interface Source {
+  /**
+   * Removes {@code byteCount} bytes from this and appends them to {@code sink}.
+   * Returns the number of bytes actually written.
+   */
+  long read(OkBuffer sink, long byteCount, Timeout timeout) throws IOException;
+
+  /**
+   * Returns the index of {@code b} in this, or -1 if this source is exhausted
+   * first. This may cause this source to buffer a large number of bytes.
+   */
+  long indexOf(byte b, Timeout timeout) throws IOException;
+
+  /**
+   * Closes this source and releases the resources held by this source. It is an
+   * error to read a closed source. It is safe to close a source more than once.
+   */
+  void close(Timeout timeout) throws IOException;
+}
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * The deadline for a requested operation. If the timeout elapses before the
+ * operation has completed, the operation should be aborted.
+ */
+public class Timeout {
+  public static final Timeout NONE = new Timeout() {
+    @Override public Timeout start(long timeout, TimeUnit unit) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean reached() {
+      return false;
+    }
+  };
+
+  private long deadlineNanos;
+
+  public Timeout() {
+  }
+
+  public Timeout start(long timeout, TimeUnit unit) {
+    deadlineNanos = System.nanoTime() + unit.toNanos(timeout);
+    return this;
+  }
+
+  public boolean reached() {
+    return System.nanoTime() - deadlineNanos >= 0; // Subtract to avoid overflow!
+  }
+}
@@ -1,6 +1,6 @@
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
 public final class Header {
@@ -1,7 +1,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
@@ -1,6 +1,6 @@
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.DataInputStream;
@@ -16,9 +16,9 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class OkBufferTest {
+  @Test public void readAndWriteUtf8() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(""ab"");
+    assertEquals(2, buffer.byteCount());
+    buffer.writeUtf8(""cdef"");
+    assertEquals(6, buffer.byteCount());
+    assertEquals(""abcd"", buffer.readUtf8(4));
+    assertEquals(2, buffer.byteCount());
+    assertEquals(""ef"", buffer.readUtf8(2));
+    assertEquals(0, buffer.byteCount());
+    try {
+      buffer.readUtf8(1);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void bufferToString() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(""\u0000\u0001\u0002\u007f"");
+    assertEquals(""0001027f"", buffer.toString());
+  }
+
+  @Test public void multipleSegmentBuffers() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a',  1000));
+    buffer.writeUtf8(repeat('b',  2500));
+    buffer.writeUtf8(repeat('c',  5000));
+    buffer.writeUtf8(repeat('d', 10000));
+    buffer.writeUtf8(repeat('e', 25000));
+    buffer.writeUtf8(repeat('f', 50000));
+
+    assertEquals(repeat('a', 999), buffer.readUtf8(999)); // a...a
+    assertEquals(""a"" + repeat('b', 2500) + ""c"", buffer.readUtf8(2502)); // ab...bc
+    assertEquals(repeat('c', 4998), buffer.readUtf8(4998)); // c...c
+    assertEquals(""c"" + repeat('d', 10000) + ""e"", buffer.readUtf8(10002)); // cd...de
+    assertEquals(repeat('e', 24998), buffer.readUtf8(24998)); // e...e
+    assertEquals(""e"" + repeat('f', 50000), buffer.readUtf8(50001)); // ef...f
+    assertEquals(0, buffer.byteCount());
+  }
+
+  @Test public void fillAndDrainPool() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+
+    // Take 2 * MAX_SIZE segments. This will drain the pool, even if other tests filled it.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+
+    // Recycle MAX_SIZE segments. They're all in the pool.
+    buffer.readByteString((int) SegmentPool.MAX_SIZE);
+    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
+
+    // Recycle MAX_SIZE more segments. The pool is full so they get garbage collected.
+    buffer.readByteString((int) SegmentPool.MAX_SIZE);
+    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
+
+    // Take MAX_SIZE segments to drain the pool.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+
+    // Take MAX_SIZE more segments. The pool is drained so these will need to be allocated.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
@@ -16,7 +16,7 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpEngine;
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
@@ -24,7 +24,7 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.io.FileNotFoundException;
@@ -20,7 +20,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
",True,"The commit message refers to the limitations and inconveniences of the existing java.io and java.nio interfaces for I/O operations, such as no timeouts, complexities, and clumsy features. The message then introduces a new I/O interface, OkBuffer, which aims to address these issues by using growable buffers instead of byte arrays and providing features like mark/reset/position in a more convenient way.",True,"The commit message does not explicitly describe the necessity of changes, but it is clear from the code diff that the changes are being made to improve the I/O interface of the OkHttp library. The commit message mentions that the existing java.io and java.nio interfaces have limitations such as no timeouts, complex buffer management, and clumsy features. The commit introduces a new I/O interface that addresses these issues by using growable buffers and providing better buffer pooling.",True,"The commit message explains the shortcomings of the previous java.io and java.nio interfaces, such as no timeouts, complexities, clumsy features, and lack of built-in buffer pooling. It also mentions that this new OkBuffer interface is inspired by InputStream and OutputStream but uses growable buffers instead of byte arrays as the core data container. This suggests that the changes are being made to improve performance and efficiency.",True,"The commit message expresses the necessity of changes by describing the problems in the existing I/O interfaces. It mentions that java.io and java.nio have issues such as no timeouts, frequent byte copying, clumsy features, and complexities. The commit message also introduces a new I/O interface as a solution, which uses growable buffers instead of byte arrays as the core data container.",True,"The commit message directly mentions the improvements it makes to the code by introducing a new OkBuffer API that addresses the limitations of java.io and java.nio. It highlights the issues with timeouts, copying bytes, clumsy features, and complexities in the existing I/O interfaces. The new OkBuffer API is designed to be more efficient, simpler, and easier to use, with features like growable buffers, built-in buffer pooling, and a more intuitive API.",True,"The commit message describes the changes made to the codebase by summarizing the differences in the code diff. It mentions the renaming of the ByteString class from the 'com.squareup.okhttp.internal' package to the 'com.squareup.okhttp.internal.bytes' package, which is a key component of the change. Additionally, the message highlights the introduction of a new OkBuffer class, which is a significant addition to the project. The message also discusses the reasons for these changes, such as the limitations of java.io and java.nio, which adds context to the changes.",True,"The commit message explains that the new OkBuffer API is being introduced to address the limitations of java.io and java.nio. It mentions that the new API uses growable buffers instead of byte arrays as the core data container, which is a technical principle underpinning the changes.",True,"The commit message expresses a change in the I/O interface, specifically mentioning the use of growable buffers instead of byte arrays. This change is described as a functional improvement, as it aims to address the limitations of java.io and java.nio, such as no timeouts, complexities, fixed-size buffers, and clumsy features like mark/reset/position. The code diff also supports this explanation, as it shows the introduction of a new OkBuffer class that uses growable buffers and a segment pooling mechanism.",False,"The commit message does not lack an explanation. While the change is small and simple, the commit message provides a clear explanation of the reasons for the change, such as the limitations and awkwardness of java.io and java.nio for I/O operations, and the attempt to create a more obnoxious but potentially better third I/O interface."
https://github.com/junit-team/junit4/commit/d2b75f93d21d2584efab1129aacd1f3020c37fca,"Document limitationBuild with Maven 3.1.1 (using Maven Wrapper) <enter>
This makes the build independent from the Maven version that is
installed on the build machine. E.g. Travis has Maven 3.5.6 installed
that does not support Java 6 anymore.
Maven version 3.1.1 is used because all newer version don't support Java 1.5.",https://api.github.com/repos/junit-team/junit4/commits/d2b75f93d21d2584efab1129aacd1f3020c37fca,"@@ -0,0 +1 @@
+distributionUrl=https://repo1.maven.org/maven2/org/apache/maven/apache-maven/3.1.1/apache-maven-3.1.1-bin.zip
\ No newline at end of file
@@ -1,5 +1,5 @@
 language: java
-script: mvn verify javadoc:javadoc site:site
+script: ./mvnw verify javadoc:javadoc site:site
 jdk:
   - oraclejdk7
   - oraclejdk8
@@ -17,10 +17,10 @@ We love pull requests. Here is a quick guide:
 1. You need to have Maven and a JDK (at least version 1.5) installed.
 2. [Fork the repo](https://help.github.com/articles/fork-a-repo).
 3. [Create a new branch](https://help.github.com/articles/creating-and-deleting-branches-within-your-repository/) from master.
-4. Ensure that you have a clean state by running `mvn verify`.
+4. Ensure that you have a clean state by running `./mvnw verify`.
 5. Add your change together with a test (tests are not needed for refactorings and documentation changes).
 6. Format your code: Import the JUnit project in Eclipse and use its formatter or apply the rules in the `CODING_STYLE` file manually. Only format the code you've changed; reformatting unrelated code makes it harder for us to review your changes.
-7. Run `mvn verify` again and ensure all tests are passing.
+7. Run `./mvnw verify` again and ensure all tests are passing.
 8. Push to your fork and [submit a pull request](https://help.github.com/articles/creating-a-pull-request/).
 
 Now you are waiting on us. We review your pull request and at least leave some comments.
@@ -4,7 +4,7 @@ Steps to build junit:
   - Write release notes
 - Not too tedious:
   - Push to github (junit-team)
-  - Run the mvn clean install
+  - Run the ./mvnw clean install
   - If not done, update src/main/config/settings.xml in /private/.../settings.xml on CloudBees' webdav share.
   - If not done, copy GnuPG keys in to ${gpg.homedir}. See settings.xml.
   - Perform Maven deployment of a snapshot or release version in Jenkins
@@ -14,19 +14,19 @@ Steps to build junit:
 
     - (to deploy gpg signed snapshot version)
 
-      $ mvn -Pjunit-release clean deploy
+      $ ./mvnw -Pjunit-release clean deploy
 
     - (to cut a release of the current targetted version)
 
-      $ mvn -B release:prepare release:perform
+      $ ./mvnw -B release:prepare release:perform
 
       This will result in the current pom.xml version having -SNAPSHOT removed
       and the release cut from that version. The version will then be incremented
       and -SNAPSHOT added back in anticipation of the next release version.
 
     - (to cut a release of while changing the version from the current target)
 
-      $ mvn -B -DreleaseVersion=5.0 release:prepare release:perform
+      $ ./mvnw -B -DreleaseVersion=5.0 release:prepare release:perform
 
       This will ignore the current version in the pom.xml, set it to 5.0 and
       the release cut from that 5.0 version. Then 5.0 will be incremented (to 5.1)
@@ -35,12 +35,12 @@ Steps to build junit:
     - (to deploy specified release version and next target release in non-interactive mode -B)
       An example with the next development version and deploying release version:
 
-      $ mvn -B -DreleaseVersion=4.12 -DdevelopmentVersion=4.13-SNAPSHOT release:prepare release:perform
+      $ ./mvnw -B -DreleaseVersion=4.12 -DdevelopmentVersion=4.13-SNAPSHOT release:prepare release:perform
 
   - If you are not an official release manager, and you want to cut a release of
     JUnit for use within your organization, use the following command
 
-      $ mvn -DpushChanges=false -DlocalCheckout '-Darguments=-Dgpg.skip=true -DaltDeploymentRepository=my-company-repo-id::default::my-company-repo-url' -B -DreleaseVersion=4.12-mycompany-1 release:prepare release:perform 
+      $ ./mvnw -DpushChanges=false -DlocalCheckout '-Darguments=-Dgpg.skip=true -DaltDeploymentRepository=my-company-repo-id::default::my-company-repo-url' -B -DreleaseVersion=4.12-mycompany-1 release:prepare release:perform 
 
     where 
       - my-company-repo-id is the <id> of your company's <server> entry in your
@@ -0,0 +1,227 @@
+#!/bin/sh
+# ----------------------------------------------------------------------------
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+# ----------------------------------------------------------------------------
+
+# ----------------------------------------------------------------------------
+# Maven2 Start Up Batch script
+#
+# Required ENV vars:
+# ------------------
+#   JAVA_HOME - location of a JDK home dir
+#
+# Optional ENV vars
+# -----------------
+#   M2_HOME - location of maven2's installed home dir
+#   MAVEN_OPTS - parameters passed to the Java VM when running Maven
+#     e.g. to debug Maven itself, use
+#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
+#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files
+# ----------------------------------------------------------------------------
+
+if [ -z ""$MAVEN_SKIP_RC"" ] ; then
+
+  if [ -f /etc/mavenrc ] ; then
+    . /etc/mavenrc
+  fi
+
+  if [ -f ""$HOME/.mavenrc"" ] ; then
+    . ""$HOME/.mavenrc""
+  fi
+
+fi
+
+# OS specific support.  $var _must_ be set to either true or false.
+cygwin=false;
+darwin=false;
+mingw=false
+case ""`uname`"" in
+  CYGWIN*) cygwin=true ;;
+  MINGW*) mingw=true;;
+  Darwin*) darwin=true
+    # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home
+    # See https://developer.apple.com/library/mac/qa/qa1170/_index.html
+    if [ -z ""$JAVA_HOME"" ]; then
+      if [ -x ""/usr/libexec/java_home"" ]; then
+        export JAVA_HOME=""`/usr/libexec/java_home`""
+      else
+        export JAVA_HOME=""/Library/Java/Home""
+      fi
+    fi
+    ;;
+esac
+
+if [ -z ""$JAVA_HOME"" ] ; then
+  if [ -r /etc/gentoo-release ] ; then
+    JAVA_HOME=`java-config --jre-home`
+  fi
+fi
+
+if [ -z ""$M2_HOME"" ] ; then
+  ## resolve links - $0 may be a link to maven's home
+  PRG=""$0""
+
+  # need this for relative symlinks
+  while [ -h ""$PRG"" ] ; do
+    ls=`ls -ld ""$PRG""`
+    link=`expr ""$ls"" : '.*-> \(.*\)$'`
+    if expr ""$link"" : '/.*' > /dev/null; then
+      PRG=""$link""
+    else
+      PRG=""`dirname ""$PRG""`/$link""
+    fi
+  done
+
+  saveddir=`pwd`
+
+  M2_HOME=`dirname ""$PRG""`/..
+
+  # make it fully qualified
+  M2_HOME=`cd ""$M2_HOME"" && pwd`
+
+  cd ""$saveddir""
+  # echo Using m2 at $M2_HOME
+fi
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched
+if $cygwin ; then
+  [ -n ""$M2_HOME"" ] &&
+    M2_HOME=`cygpath --unix ""$M2_HOME""`
+  [ -n ""$JAVA_HOME"" ] &&
+    JAVA_HOME=`cygpath --unix ""$JAVA_HOME""`
+  [ -n ""$CLASSPATH"" ] &&
+    CLASSPATH=`cygpath --path --unix ""$CLASSPATH""`
+fi
+
+# For Mingw, ensure paths are in UNIX format before anything is touched
+if $mingw ; then
+  [ -n ""$M2_HOME"" ] &&
+    M2_HOME=""`(cd ""$M2_HOME""; pwd)`""
+  [ -n ""$JAVA_HOME"" ] &&
+    JAVA_HOME=""`(cd ""$JAVA_HOME""; pwd)`""
+  # TODO classpath?
+fi
+
+if [ -z ""$JAVA_HOME"" ]; then
+  javaExecutable=""`which javac`""
+  if [ -n ""$javaExecutable"" ] && ! [ ""`expr \""$javaExecutable\"" : '\([^ ]*\)'`"" = ""no"" ]; then
+    # readlink(1) is not available as standard on Solaris 10.
+    readLink=`which readlink`
+    if [ ! `expr ""$readLink"" : '\([^ ]*\)'` = ""no"" ]; then
+      if $darwin ; then
+        javaHome=""`dirname \""$javaExecutable\""`""
+        javaExecutable=""`cd \""$javaHome\"" && pwd -P`/javac""
+      else
+        javaExecutable=""`readlink -f \""$javaExecutable\""`""
+      fi
+      javaHome=""`dirname \""$javaExecutable\""`""
+      javaHome=`expr ""$javaHome"" : '\(.*\)/bin'`
+      JAVA_HOME=""$javaHome""
+      export JAVA_HOME
+    fi
+  fi
+fi
+
+if [ -z ""$JAVACMD"" ] ; then
+  if [ -n ""$JAVA_HOME""  ] ; then
+    if [ -x ""$JAVA_HOME/jre/sh/java"" ] ; then
+      # IBM's JDK on AIX uses strange locations for the executables
+      JAVACMD=""$JAVA_HOME/jre/sh/java""
+    else
+      JAVACMD=""$JAVA_HOME/bin/java""
+    fi
+  else
+    JAVACMD=""`which java`""
+  fi
+fi
+
+if [ ! -x ""$JAVACMD"" ] ; then
+  echo ""Error: JAVA_HOME is not defined correctly."" >&2
+  echo ""  We cannot execute $JAVACMD"" >&2
+  exit 1
+fi
+
+if [ -z ""$JAVA_HOME"" ] ; then
+  echo ""Warning: JAVA_HOME environment variable is not set.""
+fi
+
+CLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher
+
+# traverses directory structure from process work directory to filesystem root
+# first directory with .mvn subdirectory is considered project base directory
+find_maven_basedir() {
+
+  if [ -z ""$1"" ]
+  then
+    echo ""Path not specified to find_maven_basedir""
+    return 1
+  fi
+
+  basedir=""$1""
+  wdir=""$1""
+  while [ ""$wdir"" != '/' ] ; do
+    if [ -d ""$wdir""/.mvn ] ; then
+      basedir=$wdir
+      break
+    fi
+    # workaround for JBEAP-8937 (on Solaris 10/Sparc)
+    if [ -d ""${wdir}"" ]; then
+      wdir=`cd ""$wdir/..""; pwd`
+    fi
+    # end of workaround
+  done
+  echo ""${basedir}""
+}
+
+# concatenates all lines of a file
+concat_lines() {
+  if [ -f ""$1"" ]; then
+    echo ""$(tr -s '\n' ' ' < ""$1"")""
+  fi
+}
+
+BASE_DIR=`find_maven_basedir ""$(pwd)""`
+if [ -z ""$BASE_DIR"" ]; then
+  exit 1;
+fi
+
+export MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-""$BASE_DIR""}
+if [ ""$MVNW_VERBOSE"" = true ]; then
+  echo $MAVEN_PROJECTBASEDIR
+fi
+MAVEN_OPTS=""$(concat_lines ""$MAVEN_PROJECTBASEDIR/.mvn/jvm.config"") $MAVEN_OPTS""
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin; then
+  [ -n ""$M2_HOME"" ] &&
+    M2_HOME=`cygpath --path --windows ""$M2_HOME""`
+  [ -n ""$JAVA_HOME"" ] &&
+    JAVA_HOME=`cygpath --path --windows ""$JAVA_HOME""`
+  [ -n ""$CLASSPATH"" ] &&
+    CLASSPATH=`cygpath --path --windows ""$CLASSPATH""`
+  [ -n ""$MAVEN_PROJECTBASEDIR"" ] &&
+    MAVEN_PROJECTBASEDIR=`cygpath --path --windows ""$MAVEN_PROJECTBASEDIR""`
+fi
+
+WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain
+
+exec ""$JAVACMD"" \
+  $MAVEN_OPTS \
+  -classpath ""$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar"" \
+  ""-Dmaven.home=${M2_HOME}"" ""-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}"" \
+  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG ""$@""
@@ -0,0 +1,143 @@
+@REM ----------------------------------------------------------------------------
+@REM Licensed to the Apache Software Foundation (ASF) under one
+@REM or more contributor license agreements.  See the NOTICE file
+@REM distributed with this work for additional information
+@REM regarding copyright ownership.  The ASF licenses this file
+@REM to you under the Apache License, Version 2.0 (the
+@REM ""License""); you may not use this file except in compliance
+@REM with the License.  You may obtain a copy of the License at
+@REM
+@REM    http://www.apache.org/licenses/LICENSE-2.0
+@REM
+@REM Unless required by applicable law or agreed to in writing,
+@REM software distributed under the License is distributed on an
+@REM ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+@REM KIND, either express or implied.  See the License for the
+@REM specific language governing permissions and limitations
+@REM under the License.
+@REM ----------------------------------------------------------------------------
+
+@REM ----------------------------------------------------------------------------
+@REM Maven2 Start Up Batch script
+@REM
+@REM Required ENV vars:
+@REM JAVA_HOME - location of a JDK home dir
+@REM
+@REM Optional ENV vars
+@REM M2_HOME - location of maven2's installed home dir
+@REM MAVEN_BATCH_ECHO - set to 'on' to enable the echoing of the batch commands
+@REM MAVEN_BATCH_PAUSE - set to 'on' to wait for a key stroke before ending
+@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven
+@REM     e.g. to debug Maven itself, use
+@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
+@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files
+@REM ----------------------------------------------------------------------------
+
+@REM Begin all REM lines with '@' in case MAVEN_BATCH_ECHO is 'on'
+@echo off
+@REM enable echoing my setting MAVEN_BATCH_ECHO to 'on'
+@if ""%MAVEN_BATCH_ECHO%"" == ""on""  echo %MAVEN_BATCH_ECHO%
+
+@REM set %HOME% to equivalent of $HOME
+if ""%HOME%"" == """" (set ""HOME=%HOMEDRIVE%%HOMEPATH%"")
+
+@REM Execute a user defined script before this one
+if not ""%MAVEN_SKIP_RC%"" == """" goto skipRcPre
+@REM check for pre script, once with legacy .bat ending and once with .cmd ending
+if exist ""%HOME%\mavenrc_pre.bat"" call ""%HOME%\mavenrc_pre.bat""
+if exist ""%HOME%\mavenrc_pre.cmd"" call ""%HOME%\mavenrc_pre.cmd""
+:skipRcPre
+
+@setlocal
+
+set ERROR_CODE=0
+
+@REM To isolate internal variables from possible post scripts, we use another setlocal
+@setlocal
+
+@REM ==== START VALIDATION ====
+if not ""%JAVA_HOME%"" == """" goto OkJHome
+
+echo.
+echo Error: JAVA_HOME not found in your environment. >&2
+echo Please set the JAVA_HOME variable in your environment to match the >&2
+echo location of your Java installation. >&2
+echo.
+goto error
+
+:OkJHome
+if exist ""%JAVA_HOME%\bin\java.exe"" goto init
+
+echo.
+echo Error: JAVA_HOME is set to an invalid directory. >&2
+echo JAVA_HOME = ""%JAVA_HOME%"" >&2
+echo Please set the JAVA_HOME variable in your environment to match the >&2
+echo location of your Java installation. >&2
+echo.
+goto error
+
+@REM ==== END VALIDATION ====
+
+:init
+
+@REM Find the project base dir, i.e. the directory that contains the folder "".mvn"".
+@REM Fallback to current working directory if not found.
+
+set MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%
+IF NOT ""%MAVEN_PROJECTBASEDIR%""=="""" goto endDetectBaseDir
+
+set EXEC_DIR=%CD%
+set WDIR=%EXEC_DIR%
+:findBaseDir
+IF EXIST ""%WDIR%""\.mvn goto baseDirFound
+cd ..
+IF ""%WDIR%""==""%CD%"" goto baseDirNotFound
+set WDIR=%CD%
+goto findBaseDir
+
+:baseDirFound
+set MAVEN_PROJECTBASEDIR=%WDIR%
+cd ""%EXEC_DIR%""
+goto endDetectBaseDir
+
+:baseDirNotFound
+set MAVEN_PROJECTBASEDIR=%EXEC_DIR%
+cd ""%EXEC_DIR%""
+
+:endDetectBaseDir
+
+IF NOT EXIST ""%MAVEN_PROJECTBASEDIR%\.mvn\jvm.config"" goto endReadAdditionalConfig
+
+@setlocal EnableExtensions EnableDelayedExpansion
+for /F ""usebackq delims="" %%a in (""%MAVEN_PROJECTBASEDIR%\.mvn\jvm.config"") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a
+@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%
+
+:endReadAdditionalConfig
+
+SET MAVEN_JAVA_EXE=""%JAVA_HOME%\bin\java.exe""
+
+set WRAPPER_JAR=""%MAVEN_PROJECTBASEDIR%\.mvn\wrapper\maven-wrapper.jar""
+set WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain
+
+%MAVEN_JAVA_EXE% %JVM_CONFIG_MAVEN_PROPS% %MAVEN_OPTS% %MAVEN_DEBUG_OPTS% -classpath %WRAPPER_JAR% ""-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%"" %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*
+if ERRORLEVEL 1 goto error
+goto end
+
+:error
+set ERROR_CODE=1
+
+:end
+@endlocal & set ERROR_CODE=%ERROR_CODE%
+
+if not ""%MAVEN_SKIP_RC%"" == """" goto skipRcPost
+@REM check for post script, once with legacy .bat ending and once with .cmd ending
+if exist ""%HOME%\mavenrc_post.bat"" call ""%HOME%\mavenrc_post.bat""
+if exist ""%HOME%\mavenrc_post.cmd"" call ""%HOME%\mavenrc_post.cmd""
+:skipRcPost
+
+@REM pause the script if MAVEN_BATCH_PAUSE is set to 'on'
+if ""%MAVEN_BATCH_PAUSE%"" == ""on"" pause
+
+if ""%MAVEN_TERMINATE_CMD%"" == ""on"" exit %ERROR_CODE%
+
+exit /B %ERROR_CODE%
",True,"The commit message refers to a convention regarding the build environment. It mentions using Maven 3.1.1 with the Maven Wrapper to make the build independent from the Maven version installed on the build machine. This is done to address the issue that Travis has Maven 3.5.6 installed, which does not support Java 6 anymore, while all newer versions of Maven do not support Java 1.5. This explains why the commit is changing the Maven version and using the Maven Wrapper.",True,"The commit message explains the necessity of the changes by stating that the build needs to be independent from the Maven version installed on the build machine. This is because the build machine has Maven 3.5.6 installed, which does not support Java 6 anymore, but the project requires Java 1.5 support. To achieve this, the commit message specifies that Maven version 3.1.1 is used, as it is the oldest version that supports Java 1.5. Additionally, the commit message mentions that the build script is modified to use the Maven Wrapper, which allows for a consistent Maven version to be used across different environments.",True,"The commit message explains the motivation for the code change by mentioning that the build machine has Maven 3.5.6 installed, which does not support Java 6 anymore. The commit message also mentions that all newer versions of Maven than 3.1.1 do not support Java 1.5, which is the reason for using Maven 3.1.1. This clearly explains the necessity of the changes made in the code diff.",True,"The commit message indicates that the developer is changing the Maven version used in the build process to make it independent from the Maven version installed on the build machine. This is done to address the issue that the current Maven version (3.5.6) installed on the build machine (Travis) does not support Java 6 anymore, while all newer versions of Maven do not support Java 1.5. This change is made to ensure the software's compatibility with older Java versions.",True,"The commit message directly mentions the objective of the change by stating that it makes the build independent from the Maven version installed on the build machine. This is done to address the issue where Travis has Maven 3.5.6 installed, which does not support Java 6 anymore. The change is made to use Maven version 3.1.1, which is the oldest version that supports Java 1.5.",True,"The commit message describes the change by summarizing the diffs. It mentions the use of Maven Wrapper to make the build independent from the Maven version installed on the build machine. It also explains why a specific version of Maven (3.1.1) is used, which is due to the fact that newer versions do not support Java 1.5. The message contrasts the before and after by mentioning the change from using 'mvn' commands to using './mvnw' commands, which is a result of the Maven Wrapper implementation.",True,The commit message explains that the build is made independent from the Maven version installed on the build machine by using the Maven Wrapper. This is a technical principle that allows for consistent and reproducible builds across different environments.,True,"The commit message expresses a change in the build process to make it independent from the Maven version installed on the build machine. It specifies that the build will now use Maven 3.1.1, which is mentioned in the code diff. The message also explains that this change is necessary because the previously installed Maven version (3.5.6) does not support Java 6 anymore, and all newer versions of Maven do not support Java 1.5. This change introduces new behavior in the build process, as it now uses a specific version of Maven and can only be run on machines with a compatible Java version.",False,"The commit message explains the reason for the change, which is to make the build independent from the Maven version installed on the build machine. This is not easily inferred from the code diff, as the change involves updating the Maven version used in the build process, not just a simple modification like removing a space."
https://github.com/spring-projects/spring-boot/commit/893654bdd1d71fdf42b21d8ca16c4c18faf6a3ea,Update documentation for new HealthIndicator support ,https://api.github.com/repos/spring-projects/spring-boot/commits/893654bdd1d71fdf42b21d8ca16c4c18faf6a3ea,"@@ -1,5 +1,5 @@
 = Spring Boot Reference Guide
-Phillip Webb; Dave Syer; Josh Long; Stéphane Nicoll; Rob Winch; Andy Wilkinson; Marcel Overdijk;
+Phillip Webb; Dave Syer; Josh Long; Stéphane Nicoll; Rob Winch; Andy Wilkinson; Marcel Overdijk; Christian Dupuis;
 :doctype: book
 :toc:
 :toclevels: 4
@@ -162,9 +162,13 @@ To provide custom health information you can register a Spring bean that impleme
 	}
 ----
 
-Spring Boot also provides a
-{sc-spring-boot-actuator}/health/SimpleHealthIndicator.{sc-ext}[`SimpleHealthIndicator`]
-implementation that attempts a simple database test.
+Spring Boot provides a
+{sc-spring-boot-actuator}/health/SimpleDatabaseHealthIndicator.{sc-ext}[`SimpleDatabaseHealthIndicator`]
+implementation that attempts a simple database test as well as implementations for 
+Redis and MongoDB. 
+
+Spring Boot adds the `HealthIndicator` instances automatically if beans of type `DataSource`,
+`MongoTemplate` or `RedisConnectionFactory` are present in the `ApplicationContext`.
 
 
 
",True,"The commit message refers to the new feature that has been added to the documentation, which is the support for new HealthIndicators. This change is necessary to provide more comprehensive health information for databases, as it introduces implementations for Redis and MongoDB in addition to the existing database test. The message also mentions that Spring Boot automatically adds HealthIndicator instances if certain beans are present in the ApplicationContext, which is an improvement over the previous version of the documentation that only mentioned the SimpleHealthIndicator implementation for a database test.",True,"The commit message 'Update documentation for new HealthIndicator support' does not explicitly explain the necessity of the changes. However, it is easy to infer that the changes are made to document the addition of new features in the Spring Boot framework, specifically the new HealthIndicator implementations for databases, Redis, and MongoDB. This is a common practice in software development to keep documentation up-to-date with the codebase.",False,"The commit message does not directly elaborate the motivation of the code change. It only mentions the update of documentation for new HealthIndicator support, but it does not describe any error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message 'Update documentation for new HealthIndicator support' and the code diff indicate that the changes were made to accommodate new features in the software. Specifically, the addition of new implementations for Redis and MongoDB in the `HealthIndicator` interface suggests that these features were added to meet the requirements of users who use these databases. Therefore, the commit message does express the necessity of changes by describing the source of the requirements.",True,"The commit message 'Update documentation for new HealthIndicator support' directly mentions the improvement it makes to the code, which is the addition of new health indicators for databases, Redis, and MongoDB. This change enhances the functionality of the code by providing more comprehensive health information.",True,"The commit message 'Update documentation for new HealthIndicator support' accurately summarizes the changes made in the diff. It highlights the addition of new health indicators for databases, Redis, and MongoDB, and it mentions the automatic addition of HealthIndicator instances if certain beans are present in the ApplicationContext. This clearly describes the key components of the change.",True,"The commit message 'Update documentation for new HealthIndicator support' and the code diff both refer to the addition of new health indicators for databases, Redis, and MongoDB. This change is based on the technical principle of extending the functionality of the application to provide more detailed health information about its components, which is a common practice in microservices architecture.",True,"The commit message 'Update documentation for new HealthIndicator support' accurately summarizes the changes made in the code diff. The diff shows that the documentation has been updated to include new HealthIndicator implementations for databases, Redis, and MongoDB. This change introduces new behaviors in the application, allowing it to provide health information for these additional components.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit, which is to update the documentation for new HealthIndicator support. The code diff also supports this explanation by adding a new author to the documentation and modifying the documentation to include support for new database health indicators."
https://github.com/junit-team/junit4/commit/8a367c1b918f02135d333f3cea8b576c20287361,"Revert 'ExternalResource: declare after() to throw Throwable ( <pr_link> )'  <enter> Revert commit  <otherCommit_link> . It breaks code that extends ExternalResource, overrides after() and calls super.after() in after(). ",https://api.github.com/repos/junit-team/junit4/commits/8a367c1b918f02135d333f3cea8b576c20287361,"@@ -77,10 +77,8 @@ protected void before() throws Throwable {
 
     /**
      * Override to tear down your specific external resource.
-     *
-     * @throws Throwable if teardown fails
      */
-    protected void after() throws Throwable {
+    protected void after() {
         // do nothing
     }
 }
",True,"The commit message refers to a prior commit that changed the declaration of the 'after()' method to throw Throwable. The current commit is reverting this change because it breaks code that extends ExternalResource, overrides 'after()', and calls 'super.after()' in 'after()'. This explains the necessity of the changes by referencing a convention or standard (the original implementation) that was broken by the prior commit.",True,"The commit message explains the necessity of the changes by stating that the reverted commit breaks code that extends ExternalResource, overrides after(), and calls super.after() in after(). This is not a common sense or easy to infer change, as it could potentially cause runtime errors or unexpected behavior in the codebase.",True,"The commit message explains the problem that arises when the 'after()' method is declared to throw Throwable. It mentions that it breaks code that extends ExternalResource, overrides 'after()', and calls 'super.after()' in 'after()'. This scenario directly elaborates the motivation of the code change, which is to fix a breaking change in the previous implementation.",True,"The commit message indicates that the changes were made to revert a previous commit that declared the 'after()' method to throw Throwable. This was done because the change broke code that extended ExternalResource, overrode 'after()', and called 'super.after()' in 'after()'. This suggests that the previous change was causing problems in the software maintenance process, specifically breaking existing code that relied on the 'after()' method not throwing Throwable.",True,"The commit message directly mentions the issue it is fixing. It states that the reverted commit breaks code that extends ExternalResource and overrides after() method, calling super.after(). This issue is caused by the declaration of after() to throw Throwable in the reverted commit. The commit message effectively describes the problem and the solution, which is to revert the change.",True,"The commit message describes the change by summarizing the diff and contrasting the before and after. It mentions the removal of the 'throws Throwable' clause from the 'after()' method, which is a change reflected in the diff.",True,"The commit message explains the technical principle underpinning the changes, which is the concept of checked exceptions in Java. The original commit changed the 'after()' method to throw Throwable, which is a checked exception. This change broke code that extended ExternalResource and overrode 'after()', as they were not prepared to handle a checked exception. The commit message correctly identifies this issue and explains that the change is being reverted to maintain the existing behavior of the code.",True,"The commit message describes the changes made to the code by explaining that it reverts a previous commit that declared the 'after()' method to throw Throwable. This change breaks code that extends ExternalResource, overrides 'after()', and calls 'super.after()' in 'after()'. The message accurately summarizes the functional impact of the code changes, which is to remove the Throwable declaration from the 'after()' method, thereby fixing the broken code.",False,"The commit message does not lack an explanation. It clearly states the reason for the revert, which is that the previous commit broke code that extends ExternalResource and overrides the after() method. The change in the code diff (removing the 'throws Throwable' from the after() method) is not the sole reason for the explanation, as it is necessary to understand the context of the code and the issue that the previous commit caused."
https://github.com/junit-team/junit4/commit/a90b496a6595856066504baf4f737fb853a6e45d,"Ensure exceptions from methodBlock() don't result in unrooted tests.  <enter> The introduction of the runLeaf() method in BlockJUnit4ClassRunner in JUnit 4.9 introduced a regression with regard to exception handling. <enter> Specifically, the invocation of methodBlock() is no longer executed within a try-catch block as was the case in previous versions of JUnit. <enter> Custom modifications to methodBlock() or the methods it invokes may in fact throw exceptions. In such cases, exceptions thrown from methodBlock() cause the current test execution to abort immediately. As a result, the failing test method is unrooted in test reports, and subsequent test methods are never invoked. Furthermore, RunListeners registered with JUnit are not notified. <enter> This commit addresses this issue by wrapping the invocation of methodBlock() within a try-catch block. If an exception is not thrown, the resulting Statement is passed to runLeaf(). If an exception is thrown, it is wrapped in a Fail statement which is passed to runLeaf(). <enter>  Closes   <issue_link>   Closes   <pr_link> ",https://api.github.com/repos/junit-team/junit4/commits/a90b496a6595856066504baf4f737fb853a6e45d,"@@ -55,7 +55,9 @@
  * @since 4.5
  */
 public class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {
+
     private final ConcurrentHashMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>();
+
     /**
      * Creates a BlockJUnit4ClassRunner to run {@code testClass}
      *
@@ -75,10 +77,17 @@ protected void runChild(final FrameworkMethod method, RunNotifier notifier) {
         if (isIgnored(method)) {
             notifier.fireTestIgnored(description);
         } else {
-            runLeaf(methodBlock(method), description, notifier);
+            Statement statement;
+            try {
+                statement = methodBlock(method);
+            }
+            catch (Throwable ex) {
+                statement = new Fail(ex);
+            }
+            runLeaf(statement, description, notifier);
         }
     }
-    
+
     /**
      * Evaluates whether {@link FrameworkMethod}s are ignored based on the
      * {@link Ignore} annotation.
@@ -390,10 +399,10 @@ private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
     protected List<MethodRule> rules(Object target) {
         List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, 
                 Rule.class, MethodRule.class);
-        
+
         rules.addAll(getTestClass().getAnnotatedFieldValues(target,
                 Rule.class, MethodRule.class));
-        
+
         return rules;
     }
 
@@ -0,0 +1,90 @@
+package org.junit.runners;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.Test;
+import org.junit.runner.Description;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunListener;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.model.FrameworkMethod;
+import org.junit.runners.model.InitializationError;
+import org.junit.runners.model.Statement;
+
+/**
+ * Tests that verify proper behavior for custom runners that extend
+ * {@link BlockJUnit4ClassRunner}.
+ *
+ * @author Sam Brannen
+ * @since 4.13
+ */
+public class CustomBlockJUnit4ClassRunnerTest {
+
+	@Test
+	public void exceptionsFromMethodBlockMustNotResultInUnrootedTests() throws Exception {
+		TrackingRunListener listener = new TrackingRunListener();
+		RunNotifier notifier = new RunNotifier();
+		notifier.addListener(listener);
+
+		new CustomBlockJUnit4ClassRunner(CustomBlockJUnit4ClassRunnerTestCase.class).run(notifier);
+		assertEquals(""tests started."", 2, listener.testStartedCount.get());
+		assertEquals(""tests failed."", 1, listener.testFailureCount.get());
+		assertEquals(""tests finished."", 2, listener.testFinishedCount.get());
+	}
+
+
+	public static class CustomBlockJUnit4ClassRunnerTestCase {
+		@Test public void shouldPass() { /* no-op */ }
+		@Test public void throwException() { /* no-op */ }
+	}
+
+	/**
+	 * Custom extension of {@link BlockJUnit4ClassRunner} that always throws
+	 * an exception from the {@code methodBlock()} if a test method is named
+	 * exactly {@code ""throwException""}.
+	 */
+	private static class CustomBlockJUnit4ClassRunner extends BlockJUnit4ClassRunner {
+
+		CustomBlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError {
+			super(testClass);
+		}
+
+		@Override
+		protected Statement methodBlock(FrameworkMethod method) {
+			if (""throwException"".equals(method.getName())) {
+				throw new RuntimeException(""throwException() test method invoked"");
+			}
+			return super.methodBlock(method);
+		}
+	}
+
+	/**
+	 * Simple {@link RunListener} that tracks the number of times that
+	 * certain callbacks are invoked.
+	 */
+	private static class TrackingRunListener extends RunListener {
+
+		final AtomicInteger testStartedCount = new AtomicInteger();
+		final AtomicInteger testFailureCount = new AtomicInteger();
+		final AtomicInteger testFinishedCount = new AtomicInteger();
+
+
+		@Override
+		public void testStarted(Description description) throws Exception {
+			testStartedCount.incrementAndGet();
+		}
+
+		@Override
+		public void testFailure(Failure failure) throws Exception {
+			testFailureCount.incrementAndGet();
+		}
+
+		@Override
+		public void testFinished(Description description) throws Exception {
+			testFinishedCount.incrementAndGet();
+		}
+	}
+
+}
@@ -18,6 +18,7 @@
 import org.junit.runner.notification.ConcurrentRunNotifierTest;
 import org.junit.runner.notification.RunNotifierTest;
 import org.junit.runner.notification.SynchronizedRunListenerTest;
+import org.junit.runners.CustomBlockJUnit4ClassRunnerTest;
 import org.junit.runners.Suite;
 import org.junit.runners.Suite.SuiteClasses;
 import org.junit.runners.model.FrameworkFieldTest;
@@ -203,6 +204,7 @@
         RuleMemberValidatorTest.class,
         RuleChainTest.class,
         BlockJUnit4ClassRunnerTest.class,
+        CustomBlockJUnit4ClassRunnerTest.class,
         MethodSorterTest.class,
         TestedOnSupplierTest.class,
         StacktracePrintingMatcherTest.class,
",True,"The commit message refers to a regression in JUnit 4.9 that caused exceptions from methodBlock() to not be properly handled. This issue was introduced with the runLeaf() method, which no longer wrapped the invocation of methodBlock() within a try-catch block. The commit message explains that this can lead to the current test execution aborting immediately, the failing test method being unrooted in test reports, and subsequent test methods not being invoked. The commit message also mentions that RunListeners registered with JUnit are not notified. The commit addresses this issue by wrapping the invocation of methodBlock() within a try-catch block, which is a clear reference to a convention or standard (proper exception handling) and an improvement over prior commits.",True,The commit message describes the necessity of changes by explaining the issue with the JUnit 4.9 update that caused exceptions from methodBlock() to result in unrooted tests. This issue is not easily inferred from the code diff and requires an explanation to understand the reason for the changes.,True,"The commit message clearly explains the problem that was introduced in JUnit 4.9, which is that exceptions thrown from methodBlock() are not handled properly, causing the current test execution to abort immediately and leaving the failing test method unrooted in test reports. The commit message also mentions that this issue affects custom modifications to methodBlock() or the methods it invokes, and that RunListeners registered with JUnit are not notified. The commit message then describes the solution, which is to wrap the invocation of methodBlock() within a try-catch block.",True,"The commit message describes the source of the requirements as a regression introduced in JUnit 4.9. The issue is that custom modifications to methodBlock() or the methods it invokes may throw exceptions, causing the current test execution to abort immediately. This results in the failing test method being unrooted in test reports and subsequent test methods not being invoked. The commit addresses this issue by wrapping the invocation of methodBlock() within a try-catch block.",True,"The commit message directly mentions the issue it addresses: 'The introduction of the runLeaf() method in BlockJUnit4ClassRunner in JUnit 4.9 introduced a regression with regard to exception handling. Specifically, the invocation of methodBlock() is no longer executed within a try-catch block as was the case in previous versions of JUnit. This commit addresses this issue by wrapping the invocation of methodBlock() within a try-catch block.' This clearly indicates that the change is made to fix an existing defect in the code.",True,"The commit message describes the change made to the code by summarizing the issue with the previous version of JUnit and explaining how the commit addresses it. Specifically, it mentions that the invocation of methodBlock() is no longer executed within a try-catch block, which can cause exceptions to be thrown and unrooted tests to occur. The commit message then explains that the issue is addressed by wrapping the invocation of methodBlock() within a try-catch block, which ensures that exceptions are handled properly and that tests are not unrooted.",True,"The commit message explains that the change was made to address an issue with exception handling in the JUnit 4.9 release. The message describes the technical principle underpinning the changes, which is the need to wrap the invocation of methodBlock() within a try-catch block to ensure that exceptions thrown from this method are properly handled and do not cause the current test execution to abort immediately, leaving subsequent test methods unrooted in test reports and RunListeners unnotified.",True,"The commit message describes the issue with the JUnit 4.9 update that caused exceptions from the methodBlock() method to not be properly handled. It explains that this issue resulted in unrooted tests and that the commit addresses this by wrapping the invocation of methodBlock() within a try-catch block. This change ensures that exceptions are properly handled and that RunListeners are notified, as described in the code diff.",False,"The commit message does not lack an explanation. It clearly explains the issue with the previous version of JUnit and how the change in the code addresses that issue. The commit message also provides context about the regression, the problem it causes, and the solution it implements. The code diff supports the explanation provided in the commit message."
https://github.com/junit-team/junit4/commit/0d6cd750d53486f01f12ddfee8657d94b5940574,Remove old todo ,https://api.github.com/repos/junit-team/junit4/commits/0d6cd750d53486f01f12ddfee8657d94b5940574,"@@ -23,8 +23,6 @@ public boolean matchesSafely(PrintableResult item) {
 		};
 	}
 	
-	// TODO: (Dec 7, 2007 10:15:15 AM) fix type
-
 	@SuppressWarnings(""unchecked"")
 	public static Matcher<Object> hasSingleFailureContaining(final String string) {
 		return new BaseMatcher<Object>() {
",False,"The commit message 'Remove old todo' does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features. It simply states that a todo comment has been removed from the code. While the removal of the todo comment might imply that the issue it was referring to has been addressed, the message does not explicitly state this.",True,The commit message 'Remove old todo' clearly describes the changes made in the code diff. The diff shows the removal of a TODO comment that was no longer relevant or necessary. This is a common practice in software development and does not require a detailed explanation in the commit message.,False,"The commit message 'Remove old todo' does not explicitly describe the necessity of changes or the motivation behind the code change. It only mentions the removal of a todo comment, which does not necessarily imply that there was an error scenario, issue report, or shortcoming in the previous implementation that required the change.",True,"The commit message 'Remove old todo' and the code diff indicate that the developer removed an outdated todo comment from the code. The todo comment mentioned 'fix type' which suggests that there was a requirement or problem in the code that needed to be addressed. Therefore, the commit message does contain an expression that describes the necessity of changes.",False,"The commit message 'Remove old todo' does not directly mention the defects it fixes or the improvements it makes to the code. The code diff shows that the commit removed a TODO comment that mentioned a type fix, but the commit message does not explicitly state this. Therefore, the commit message does not directly describe the objective of the change.",True,"The commit message 'Remove old todo' accurately summarizes the change in the diff, which is the removal of a commented out todo that mentioned fixing a type. This directly points out the key component of the change, which is the removal of the outdated todo comment.",False,"The commit message 'Remove old todo' does not contain an expression that describes the technical principle underpinning the changes. The changes in the diff are simply removing a todo comment and a related line of code, which does not reveal any underlying technical principle.",False,"The commit message 'Remove old todo' does not describe the code changes from a functional perspective. It only mentions the removal of a todo comment, but it does not explain what the code changes are or what new behaviors have been introduced.",False,"The commit message does not explicitly explain the reason for removing the old todo. While it's clear from the diff that the todo was removed, it's not clear why the todo was there in the first place or what the 'fix type' comment referred to. Therefore, the commit message could benefit from a more detailed explanation."
https://github.com/square/okhttp/commit/0d069f3b7bc524320fc76051408384f8ece77412,Prefer ByteString.encodeString.  <enter> This saves cloning the byte array because the byte array can't be modified by the caller. ,https://api.github.com/repos/square/okhttp/commits/0d069f3b7bc524320fc76051408384f8ece77412,"@@ -30,8 +30,7 @@ public static String basic(String userName, String password) {
 
   public static String basic(String userName, String password, Charset charset) {
     String usernameAndPassword = userName + "":"" + password;
-    byte[] bytes = usernameAndPassword.getBytes(charset);
-    String encoded = ByteString.of(bytes).base64();
+    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
     return ""Basic "" + encoded;
   }
 }
",True,"The commit message refers to a convention of using ByteString.encodeString instead of manually converting the string to bytes. This is done to avoid cloning the byte array and potential modification by the caller, which is an improvement over the previous implementation.",True,"The commit message explains the reason for the change by stating that 'Prefer ByteString.encodeString' is used to save cloning the byte array because the byte array can't be modified by the caller. This is a common reason for refactoring code, and it's not immediately obvious from the diff alone, so the commit message provides a necessary explanation.",True,"The commit message explains the motivation for the change by stating that 'This saves cloning the byte array because the byte array can't be modified by the caller.' This implies that the previous implementation could potentially lead to issues if the byte array was modified after it was passed to ByteString.of(), which the new implementation avoids by using ByteString.encodeString() directly.",True,"The commit message 'Prefer ByteString.encodeString' indicates that the developer is making a change to improve the efficiency of the code. The message 'This saves cloning the byte array because the byte array can't be modified by the caller' suggests that the change is being made to address a problem in the software maintenance process. Specifically, the problem is that the byte array was being unnecessarily cloned and modified, which could potentially lead to issues. By using ByteString.encodeString, the developer is able to avoid this problem and improve the efficiency of the code.",True,"The commit message 'Prefer ByteString.encodeString' directly mentions the change that is being made to the code. The change is made to simplify the code and save cloning the byte array, which is mentioned in the message as 'This saves cloning the byte array because the byte array can't be modified by the caller.' This indicates that the change is being made to improve the code.",True,"The commit message 'Prefer ByteString.encodeString' accurately summarizes the change in the code diff. It highlights the key component of the change, which is the replacement of the 'getBytes' and 'ByteString.of' methods with 'ByteString.encodeString'. This change is made to save cloning the byte array, as stated in the commit message.",True,"The commit message 'Prefer ByteString.encodeString' highlights the technical principle of immutability. By using ByteString.encodeString, the byte array is not cloned, and it cannot be modified by the caller, thus ensuring the immutability of the data.",True,"The commit message 'Prefer ByteString.encodeString' accurately summarizes the code change. It explains that the change is made to save cloning the byte array, which can't be modified by the caller. This is achieved by replacing the existing method of converting a string to a byte array and then to a ByteString with the new method ByteString.encodeString. This new method directly encodes the string to a ByteString using the specified charset, which is a more efficient and functional change.",False,"The commit message does not lack an explanation. It clearly states the reason for the change: 'Prefer ByteString.encodeString' and provides a reason for this preference: 'This saves cloning the byte array because the byte array can't be modified by the caller.' The change is not just a simple removal of a space, but a more significant refactoring of the code."
https://github.com/spring-projects/spring-boot/commit/85c0b44dcbbe4d201f8b7fd72a97c31c2d07a3ec,"Test that LaunchedURLClassLoader works when thread is interrupted  <enter> Previously, RandomAccessDataFile used a semaphore and acquired it interruptibly. This meant that an interrupted thread was unable to access the file. Notably, this would prevent LaunchedURLClassLoader from loading classes or resources on an interrupted thread. <enter> The previous commit ( <otherCommit_link> ) updates RandomAccessDataFile to acquire the semaphore uninterruptibly. This commit adds a test to LaunchedURLClassLoader to verify that it can now load a resource from an interrupted thread. <enter>  Closes   <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/85c0b44dcbbe4d201f8b7fd72a97c31c2d07a3ec,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2014 the original author or authors.
+ * Copyright 2012-2016 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -36,6 +36,7 @@
  *
  * @author Dave Syer
  * @author Phillip Webb
+ * @author Andy Wilkinson
  */
 @SuppressWarnings(""resource"")
 public class LaunchedURLClassLoaderTests {
@@ -101,4 +102,23 @@ public void resolveFromNested() throws Exception {
 		assertThat(resource.openConnection().getInputStream().read(), equalTo(3));
 	}
 
+	@Test
+	public void resolveFromNestedWhileThreadIsInterrupted() throws Exception {
+		File file = this.temporaryFolder.newFile();
+		TestJarCreator.createTestJar(file);
+		JarFile jarFile = new JarFile(file);
+		URL url = jarFile.getUrl();
+		LaunchedURLClassLoader loader = new LaunchedURLClassLoader(new URL[] { url },
+				null);
+		try {
+			Thread.currentThread().interrupt();
+			URL resource = loader.getResource(""nested.jar!/3.dat"");
+			assertThat(resource.toString(), equalTo(url + ""nested.jar!/3.dat""));
+			assertThat(resource.openConnection().getInputStream().read(), equalTo(3));
+		}
+		finally {
+			Thread.interrupted();
+		}
+	}
+
 }
",True,"The commit message refers to a prior commit that changed the behavior of RandomAccessDataFile to acquire a semaphore uninterruptibly. This change is then explained to have caused an issue with LaunchedURLClassLoader, which was unable to load classes or resources on an interrupted thread. The commit message then explains that the test being added in this commit is to verify that LaunchedURLClassLoader can now load a resource from an interrupted thread, addressing the issue identified in the prior commit.",True,"The commit message describes the necessity of changes by explaining that the previous commit made RandomAccessDataFile acquire the semaphore uninterruptibly, which prevented LaunchedURLClassLoader from loading classes or resources on an interrupted thread. The commit message then explains that it adds a test to LaunchedURLClassLoader to verify that it can now load a resource from an interrupted thread. This is a clear and concise explanation of the changes made in the code diff and the reason for those changes.",True,"The commit message explains the problem scenario that occurred previously when a thread was interrupted. It mentions that an interrupted thread was unable to access a file due to the use of a semaphore in the RandomAccessDataFile class. This issue prevented LaunchedURLClassLoader from loading classes or resources on an interrupted thread. The commit message also elaborates on the solution, which is to update RandomAccessDataFile to acquire the semaphore uninterruptibly and add a test to LaunchedURLClassLoader to verify that it can now load a resource from an interrupted thread.",True,The commit message describes the necessity of changes by mentioning the problem that an interrupted thread was unable to access a file due to the use of a semaphore in the previous commit. This issue prevented LaunchedURLClassLoader from loading classes or resources on an interrupted thread. The commit message also indicates that the changes were made to address this problem.,True,"The commit message directly mentions the defect it fixes by stating that previously, an interrupted thread was unable to access a file, which would prevent LaunchedURLClassLoader from loading classes or resources on an interrupted thread. The commit message also mentions the improvement it makes to the code by adding a test to LaunchedURLClassLoader to verify that it can now load a resource from an interrupted thread.",True,"The commit message accurately summarizes the changes made in the diff. It mentions the addition of a test to LaunchedURLClassLoader that verifies its ability to load a resource from an interrupted thread. This is also reflected in the diff, where a new test method 'resolveFromNestedWhileThreadIsInterrupted' has been added to the LaunchedURLClassLoaderTests class.",True,"The commit message explains that the changes were made to allow LaunchedURLClassLoader to load classes or resources on an interrupted thread. This is achieved by updating RandomAccessDataFile to acquire the semaphore uninterruptibly. The added test in LaunchedURLClassLoader verifies this functionality, demonstrating the technical principle that a thread's interruption status should not prevent it from accessing necessary resources.",True,"The commit message expresses a change in behavior and adds a new test case. It mentions that previously, an interrupted thread was unable to access a file due to the use of a semaphore that was acquired interruptibly. This issue was causing LaunchedURLClassLoader to fail loading classes or resources on an interrupted thread. The commit then updates the code to acquire the semaphore uninterruptibly and adds a new test to LaunchedURLClassLoader to verify that it can now load a resource from an interrupted thread. This new test case is added to the LaunchedURLClassLoaderTests class, which is shown in the diff.",False,"The commit message does not lack an explanation. It clearly states that the previous commit made RandomAccessDataFile acquire the semaphore uninterruptibly, which was causing an interrupted thread to be unable to access the file. This change was causing LaunchedURLClassLoader to fail loading classes or resources on an interrupted thread. The commit message then explains that it adds a test to LaunchedURLClassLoader to verify that it can now load a resource from an interrupted thread, which is a significant change that requires explanation."
https://github.com/spring-projects/spring-boot/commit/f9d94c6ed080c45bc96a76e134d9db5bb038f900,Remove duplicate word in docs ,https://api.github.com/repos/spring-projects/spring-boot/commits/f9d94c6ed080c45bc96a76e134d9db5bb038f900,"@@ -808,7 +808,7 @@ If you need to _completely_ disable restart support (for example, because it doe
 If you work with an IDE that continuously compiles changed files, you might prefer to trigger restarts only at specific times.
 To do so, you can use a ""`trigger file`"", which is a special file that must be modified when you want to actually trigger a restart check.
 
-NOTE: Any update to the file file will trigger a check, but restart only actually occurs if Devtools has detected it has something to do.
+NOTE: Any update to the file will trigger a check, but restart only actually occurs if Devtools has detected it has something to do.
 
 To use a trigger file, set the `spring.devtools.restart.trigger-file` property to the name (excluding any path) of your trigger file.
 The trigger file must appear somewhere on your classpath.
",False,"The commit message 'Remove duplicate word in docs' does not describe the necessity of changes by referencing conventions, standards, improvements in prior commits, or implemented features. It only mentions a simple correction in the documentation, without explaining why this change is necessary or beneficial.",True,"The commit message 'Remove duplicate word in docs' does not explicitly explain why the change was necessary. However, it is easy to infer that the change was made to improve the clarity and accuracy of the documentation, which is a common reason for making such changes. Therefore, the commit message does not provide a rationale for the changes, but it is still descriptive of the necessity of the changes.",False,"The commit message 'Remove duplicate word in docs' does not directly elaborate the motivation of the code change. It does not mention any error scenario, issue report, or shortcoming of the previous implementation that necessitated the change. The change is simply a correction of a typographical error, not a functional or structural modification.",True,"The commit message 'Remove duplicate word in docs' does not explicitly describe the necessity of changes. However, the code diff indicates that a duplicate word 'it' has been removed from the documentation. This could be a small correction to improve clarity or accuracy, which might have been identified as a problem in the software maintenance process, such as outdated or incorrect documentation.",False,"The commit message 'Remove duplicate word in docs' does not directly mention the defects it fixes or the improvements it makes to the code. It only mentions a change in the documentation, not the functionality of the code.",True,"The commit message 'Remove duplicate word in docs' accurately summarizes the change in the diff. The change is a simple correction to remove a duplicate word in the documentation. The diff shows that the word 'file' is repeated twice in a note, and the change removes one of the occurrences. This is a clear and concise summary of the change.",False,The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions removing a duplicate word in the documentation. The code diff does not provide any clear indication of a technical principle being implemented or modified.,False,"The commit message 'Remove duplicate word in docs' does not describe the functional changes made in the code diff. It only mentions a modification in the documentation, but it does not explain what the modification is or what new behavior it introduces. The code diff shows a modification in a note about triggering restarts in a development tool, but the commit message does not mention this change or its functional implications.",True,"The commit message 'Remove duplicate word in docs' clearly indicates that a small and simple change was made to the documentation. The code diff shows that the word 'file' was repeated twice in a sentence, and removing one instance of the word does not change the meaning or functionality of the documentation. Therefore, the commit message does not need to provide an explicit explanation of the change."
https://github.com/spring-projects/spring-boot/commit/2a85a2557d37e133a10a513fc71b5ccf4ee2d4ff,"Fix health indicator auto-configuration order  <enter> Previously, the health auto-configuration `AutoconfigureOrder` entry for couchbase was referring to the standard couchbase auto-configuration that is not responsible to configure the `CouchbaseOperations` bean. Yet, the health indicator implementation was relying on the presence of such a bean. <enter> This commit fixes the `AutoconfigureOrder` entry so that it refers to `CouchbaseDataAutoConfiguration` now. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/2a85a2557d37e133a10a513fc71b5ccf4ee2d4ff,"@@ -52,8 +52,8 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration;
+import org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;
@@ -91,7 +91,7 @@
 @Configuration
 @AutoConfigureBefore({ EndpointAutoConfiguration.class })
 @AutoConfigureAfter({ CassandraAutoConfiguration.class,
-		CassandraDataAutoConfiguration.class, CouchbaseAutoConfiguration.class,
+		CassandraDataAutoConfiguration.class, CouchbaseDataAutoConfiguration.class,
 		DataSourceAutoConfiguration.class, ElasticsearchAutoConfiguration.class,
 		JestAutoConfiguration.class, JmsAutoConfiguration.class,
 		MailSenderAutoConfiguration.class, MongoAutoConfiguration.class,
",True,"The commit message explains the necessity of changes by referencing a problem in prior commits. It mentions that the health auto-configuration was referring to the standard couchbase auto-configuration, which is not responsible for configuring the `CouchbaseOperations` bean. However, the health indicator implementation was relying on the presence of such a bean. The commit message then explains that the `AutoconfigureOrder` entry has been fixed to refer to `CouchbaseDataAutoConfiguration` now, which is the correct configuration for the `CouchbaseOperations` bean.",True,"The commit message explains the necessity of changes by stating that the health auto-configuration was referring to the wrong class for the AutoconfigureOrder entry. This was causing the health indicator implementation to fail because it was relying on the presence of a bean that was not being correctly configured. The commit message does not offer a rationale for this change, but it is easy to infer that the change is necessary to fix a bug in the code.",True,"The commit message directly elaborates the motivation of the code change by explaining the error scenario. It mentions that the previous implementation of the health auto-configuration was referring to the wrong auto-configuration class, which could lead to the absence of the `CouchbaseOperations` bean that the health indicator implementation relies on. The commit message also mentions that it closes an issue, which further supports the necessity of the changes.",True,"The commit message indicates that the developer made changes due to a problem in the software maintenance process. The problem is that the health auto-configuration was referring to the standard couchbase auto-configuration, which is not responsible for configuring the `CouchbaseOperations` bean. However, the health indicator implementation was relying on the presence of such a bean. This issue was fixed by changing the `AutoconfigureOrder` entry to refer to `CouchbaseDataAutoConfiguration` instead.",True,"The commit message directly mentions the defect it fixes by stating that the health auto-configuration was referring to the standard couchbase auto-configuration that is not responsible to configure the `CouchbaseOperations` bean, which the health indicator implementation was relying on. The message then explains that the commit fixes this issue by changing the `AutoconfigureOrder` entry to refer to `CouchbaseDataAutoConfiguration` now.",True,"The commit message accurately summarizes the changes made in the code diff. It specifically mentions the issue of the incorrect auto-configuration order for the health indicator, which was referring to the standard Couchbase auto-configuration instead of the CouchbaseDataAutoConfiguration. The message then explains that this commit fixes the issue by updating the AutoconfigureOrder entry to refer to CouchbaseDataAutoConfiguration. This clearly describes the key components of the change and contrasts the before and after situation.",True,"The commit message explains that the technical principle underpinning the changes is the correct configuration order. The health auto-configuration for couchbase was referring to the wrong auto-configuration class, which was causing the `CouchbaseOperations` bean to not be configured. This commit fixes the `AutoconfigureOrder` entry so that it refers to `CouchbaseDataAutoConfiguration` now, which is the correct class to configure the `CouchbaseOperations` bean. This ensures that the health indicator implementation can rely on the presence of the `CouchbaseOperations` bean.",True,The commit message accurately describes the code changes by explaining that the health auto-configuration order for Couchbase was incorrectly referring to the standard Couchbase auto-configuration instead of the CouchbaseDataAutoConfiguration. This change ensures that the health indicator implementation can rely on the presence of the CouchbaseOperations bean. The message also introduces new behavior by fixing a potential issue with the health indicator's functionality.,False,"The commit message does not lack an explanation. It clearly states the reason for the commit: the health auto-configuration order was referring to the wrong class, causing the health indicator implementation to fail. This is not a trivial change and requires an explanation to understand the context and the problem being solved."
https://github.com/spring-projects/spring-boot/commit/fe3d2c39a0f4cf016c8ceb27dbeab5508c85e65f,Fix broken links in the documentation ,https://api.github.com/repos/spring-projects/spring-boot/commits/fe3d2c39a0f4cf016c8ceb27dbeab5508c85e65f,"@@ -38,7 +38,7 @@ Having trouble with Spring Boot, We'd like to help!
 * Report bugs with Spring Boot at https://github.com/spring-projects/spring-boot/issues.
 
 NOTE: All of Spring Boot is open source, including the documentation! If you find problems
-with the docs; or if you just want to improve them, please <<github-code, get involved>>.
+with the docs; or if you just want to improve them, please {github-code}[get involved].
 
 [[boot-documentation-first-steps]]
 == First steps
@@ -157,8 +157,9 @@ installed you can follow the instructions at http://www.gradle.org/.
 Spring Boot dependencies can be declared using the `org.springframework.boot` `group`.
 Typically your project will declare dependencies to one or more
 <<using-spring-boot.adoc#using-boot-starter-poms, ``Starter POMs''>>. Spring Boot
-provides a useful <<build-tool-plugins.adoc#build-tool-plugins-gradle, Gradle plugin>>
-that can be used to simplify dependency declarations and to create executable jars.
+provides a useful <<build-tool-plugins.adoc#build-tool-plugins-gradle-plugin, Gradle
+plugin>> that can be used to simplify dependency declarations and to create executable
+jars.
 
 .Gradle Wrapper
 ****
@@ -721,8 +722,8 @@ Hopefully this section has provided you with some of the Spring Boot basics, and
 on your way to writing your own applications. If you're a task-oriented type of
 developer you might want to jump over to http://spring.io and check out some of the
 http://spring.io/guides/[getting started] guides that solve specific
-'``How do I do that with Spring''' problems; we also have a Spring Boot specific
-'<<howto.adoc#how-to, How-to>>' reference documentation.
+'``How do I do that with Spring''' problems; we also have Spring Boot-specific
+'<<howto.adoc#howto, How-to>>' reference documentation.
 
 Otherwise, the next logical step is to read '<<using-spring-boot.adoc#using-boot>>'. If
 you're really impatient, you could also jump ahead and read about
",False,"The commit message 'Fix broken links in the documentation' does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features. It simply states that the changes made are to fix broken links in the documentation.",True,"The commit message 'Fix broken links in the documentation' clearly describes the necessity of the changes without providing a rationale. It is common sense that broken links in documentation can cause confusion and make it difficult for users to navigate and understand the content. The diff provided also supports this, showing the exact changes made to fix the broken links.",True,"The commit message 'Fix broken links in the documentation' directly elaborates the motivation of the code change. It mentions the issue of broken links in the documentation, which is a problem that could arise if the links were not properly maintained. This clearly describes the necessity of the changes.",True,"The commit message 'Fix broken links in the documentation' indicates that the developer made changes to the documentation to fix links that were no longer working. This could be due to a problem in the maintenance of the documentation, such as outdated links, which is a common issue in software maintenance.",True,"The commit message 'Fix broken links in the documentation' directly mentions the improvement it makes to the code, which is fixing broken links in the documentation. This clearly describes the objective of the change.",True,"The commit message 'Fix broken links in the documentation' accurately summarizes the changes made in the diff. The diff shows modifications to the documentation, specifically fixing broken links. The commit message highlights this key component of the change, making it clear that the purpose of the commit is to improve the documentation by fixing links.",False,"The commit message 'Fix broken links in the documentation' does not explicitly describe a technical principle underpinning the changes. It simply states that the changes made are to fix broken links in the documentation, which is more about the content and presentation of the documentation rather than a technical principle.",False,"The commit message 'Fix broken links in the documentation' does not describe the code changes from a functional perspective or introduce new behaviors. It only mentions fixing broken links, which is a maintenance task rather than a functional change.",False,"The commit message 'Fix broken links in the documentation' does not necessarily imply that the change was small and simple. While the code diff shows that a single character was changed, it does not specify which link was broken. Additionally, the change could have been made in multiple places within the documentation. Therefore, the commit message provides a clear explanation of the reason for the commit, which is to fix broken links in the documentation."
https://github.com/spring-projects/spring-boot/commit/715cf7da7564daaa8c349d34bd826b27ad71b183,"Do not enable cglib if spring.aop.proxy-target-class is configured  <enter> This commit makes sure to honour the `spring.aop.proxy-target-class` property if set by the user. Previously, the `PersistenceExceptionTranslationPostProcessor` was always configured to use cglib, regardless of the value of that property. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/715cf7da7564daaa8c349d34bd826b27ad71b183,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2014 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -20,14 +20,17 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.bind.RelaxedPropertyResolver;
 import org.springframework.context.annotation.Bean;
+import org.springframework.core.env.Environment;
 import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
 
 /**
  * {@link EnableAutoConfiguration Auto-configuration} for Spring's persistence exception
  * translation.
  *
  * @author Andy Wilkinson
+ * @author Stephane Nicoll
  * @since 1.2.0
  */
 @ConditionalOnClass(PersistenceExceptionTranslationPostProcessor.class)
@@ -36,10 +39,18 @@ public class PersistenceExceptionTranslationAutoConfiguration {
 	@Bean
 	@ConditionalOnMissingBean(PersistenceExceptionTranslationPostProcessor.class)
 	@ConditionalOnProperty(prefix = ""spring.dao.exceptiontranslation"", name = ""enabled"", matchIfMissing = true)
-	public static PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor() {
+	public static PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor(
+			Environment environment) {
 		PersistenceExceptionTranslationPostProcessor postProcessor = new PersistenceExceptionTranslationPostProcessor();
-		postProcessor.setProxyTargetClass(true);
+		postProcessor.setProxyTargetClass(determineProxyTargetClass(environment));
 		return postProcessor;
 	}
 
+	private static boolean determineProxyTargetClass(Environment environment) {
+		RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,
+				""spring.aop."");
+		Boolean value = resolver.getProperty(""proxyTargetClass"", Boolean.class);
+		return (value != null ? value : true);
+	}
+
 }
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -37,10 +37,10 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 /**
- *
  * Tests for {@link PersistenceExceptionTranslationAutoConfiguration}
  *
  * @author Andy Wilkinson
+ * @author Stephane Nicoll
  */
 public class PersistenceExceptionTranslationAutoConfigurationTests {
 
@@ -54,7 +54,7 @@ public void close() {
 	}
 
 	@Test
-	public void exceptionTranslationPostProcessorBeanIsCreated() {
+	public void exceptionTranslationPostProcessorUsesCglibByDefault() {
 		this.context = new AnnotationConfigApplicationContext(
 				PersistenceExceptionTranslationAutoConfiguration.class);
 		Map<String, PersistenceExceptionTranslationPostProcessor> beans = this.context
@@ -64,7 +64,20 @@ public void exceptionTranslationPostProcessorBeanIsCreated() {
 	}
 
 	@Test
-	public void exceptionTranslationPostProcessorBeanIsDisabled() {
+	public void exceptionTranslationPostProcessorCanBeConfiguredToUseJdkProxy() {
+		this.context = new AnnotationConfigApplicationContext();
+		EnvironmentTestUtils.addEnvironment(this.context,
+				""spring.aop.proxyTargetClass=false"");
+		this.context.register(PersistenceExceptionTranslationAutoConfiguration.class);
+		this.context.refresh();
+		Map<String, PersistenceExceptionTranslationPostProcessor> beans = this.context
+				.getBeansOfType(PersistenceExceptionTranslationPostProcessor.class);
+		assertThat(beans).hasSize(1);
+		assertThat(beans.values().iterator().next().isProxyTargetClass()).isFalse();
+	}
+
+	@Test
+	public void exceptionTranslationPostProcessorCanBeDisabled() {
 		this.context = new AnnotationConfigApplicationContext();
 		EnvironmentTestUtils.addEnvironment(this.context,
 				""spring.dao.exceptiontranslation.enabled=false"");
",True,The commit message refers to the necessity of changes by referencing a configuration property 'spring.aop.proxy-target-class'. It explains that the change is made to honor this property if set by the user. This is a clear reference to a convention or standard that the codebase follows.,True,"The commit message 'Do not enable cglib if spring.aop.proxy-target-class is configured' clearly explains the necessity of the changes. It states that the changes are made to honor the 'spring.aop.proxy-target-class' property if set by the user. This is not a common sense or easy to infer change, as the previous implementation always configured 'PersistenceExceptionTranslationPostProcessor' to use cglib, regardless of the value of that property.",True,"The commit message explains the motivation for the change by mentioning the issue with the previous implementation where the `PersistenceExceptionTranslationPostProcessor` was always configured to use cglib, regardless of the value of the `spring.aop.proxy-target-class` property. The message also closes an issue, which is a common practice to link a commit to a specific issue report.",True,"The commit message 'Do not enable cglib if spring.aop.proxy-target-class is configured' indicates that the change was made to honor the user's configuration. The previous code always configured 'PersistenceExceptionTranslationPostProcessor' to use cglib, regardless of the 'spring.aop.proxy-target-class' property. This change ensures that the property is respected, which is a requirement expressed by the user.",True,"The commit message directly mentions the improvement it makes to the code by stating that it makes sure to honor the 'spring.aop.proxy-target-class' property if set by the user. This change fixes the previous behavior where the 'PersistenceExceptionTranslationPostProcessor' was always configured to use cglib, regardless of the value of that property.",True,"The commit message 'Do not enable cglib if spring.aop.proxy-target-class is configured' accurately summarizes the change made in the code diff. The change involves modifying the PersistenceExceptionTranslationPostProcessor bean to honor the 'spring.aop.proxy-target-class' property. This is a clear and concise summary of the key component of the change, which is the modification of the bean's configuration based on the property value.",True,"The commit message explains that the change is made to honor the 'spring.aop.proxy-target-class' property if set by the user. This is a technical principle underpinning the changes, as it ensures that the user's configuration is respected and not overridden by default settings.",True,"The commit message 'Do not enable cglib if spring.aop.proxy-target-class is configured' accurately describes the changes made in the code. The changes involve adding a new method 'determineProxyTargetClass' that checks the value of the 'spring.aop.proxy-target-class' property. If this property is set, the method will return its value, otherwise, it will return true. This new behavior ensures that the 'PersistenceExceptionTranslationPostProcessor' only uses cglib if the 'spring.aop.proxy-target-class' property is not configured or set to true.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit, which is to honor the 'spring.aop.proxy-target-class' property if set by the user. This is not something that can be easily inferred from the code diff, as the change involves adding new logic to determine whether to use cglib or not based on the property value."
https://github.com/spring-projects/spring-boot/commit/e69ec6bb09e93aa5d240cfdb826e93cebb91278e,"Log classpath once environment has been prepared  <enter> Previously, the classpath would be logged in response to the ApplicationStartedEvent. At this point, logging could be disabled while the logging system is being initialized, or because the log levels configured in the environment have not yet been applied. <enter> This commit moves the logging to happen in response to an ApplicationEnvironmentPreparedEvent by which point the logging system has been initialized and its levels have been configured. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/e69ec6bb09e93aa5d240cfdb826e93cebb91278e,"@@ -22,17 +22,18 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
+import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
 import org.springframework.boot.context.event.ApplicationFailedEvent;
-import org.springframework.boot.context.event.ApplicationStartedEvent;
 import org.springframework.context.ApplicationEvent;
 import org.springframework.context.event.GenericApplicationListener;
 import org.springframework.context.event.SmartApplicationListener;
 import org.springframework.core.ResolvableType;
 
 /**
- * A {@link SmartApplicationListener} that reacts to {@link ApplicationStartedEvent start
- * events} and to {@link ApplicationFailedEvent failed events} by logging the classpath of
- * the thread context class loader (TCCL) at {@code DEBUG} level.
+ * A {@link SmartApplicationListener} that reacts to
+ * {@link ApplicationEnvironmentPreparedEvent environment prepared events} and to
+ * {@link ApplicationFailedEvent failed events} by logging the classpath of the thread
+ * context class loader (TCCL) at {@code DEBUG} level.
  *
  * @author Andy Wilkinson
  */
@@ -46,7 +47,7 @@ public final class ClasspathLoggingApplicationListener
 	@Override
 	public void onApplicationEvent(ApplicationEvent event) {
 		if (this.logger.isDebugEnabled()) {
-			if (event instanceof ApplicationStartedEvent) {
+			if (event instanceof ApplicationEnvironmentPreparedEvent) {
 				this.logger
 						.debug(""Application started with classpath: "" + getClasspath());
 			}
@@ -68,7 +69,7 @@ public boolean supportsEventType(ResolvableType resolvableType) {
 		if (type == null) {
 			return false;
 		}
-		return ApplicationStartedEvent.class.isAssignableFrom(type)
+		return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(type)
 				|| ApplicationFailedEvent.class.isAssignableFrom(type);
 	}
 
",True,"The commit message explains the necessity of changes by referencing a prior issue where the classpath was logged in response to the ApplicationStartedEvent. It mentions that logging could be disabled while the logging system was being initialized or because the log levels configured in the environment had not yet been applied. The commit message then explains that the logging has been moved to happen in response to an ApplicationEnvironmentPreparedEvent, which occurs after the logging system has been initialized and its levels have been configured.",True,"The commit message explains the necessity of changes by providing a rationale. It explains that the classpath was previously logged in response to the ApplicationStartedEvent, but this could lead to logging being disabled or not having the configured log levels applied. The commit moves the logging to happen in response to an ApplicationEnvironmentPreparedEvent, which ensures that the logging system has been initialized and its levels have been configured.",True,"The commit message explains the problem that could arise if the classpath was logged during the ApplicationStartedEvent. It mentions that logging could be disabled while the logging system is being initialized, or because the log levels configured in the environment have not yet been applied. This could lead to important information being missed. The commit message then explains that the classpath is now logged in response to an ApplicationEnvironmentPreparedEvent, by which point the logging system has been initialized and its levels have been configured. This ensures that the classpath is always logged, even in situations where logging might otherwise be disabled.",True,"The commit message indicates that the changes were made due to the need to ensure that the logging system has been initialized and its levels have been configured before logging the classpath. This suggests that the previous implementation could lead to logging issues, which is a problem in the process of software maintenance.",True,"The commit message directly mentions the improvement it makes to the code. It explains that the classpath logging is now happening in response to an ApplicationEnvironmentPreparedEvent, which was changed in the code diff. This change was made to ensure that the logging system has been initialized and its levels have been configured before the classpath is logged. This improves the functionality of the code by ensuring that the classpath is logged at the appropriate time and with the correct configuration.",True,"The commit message does a good job of summarizing the changes made to the code. It clearly states that the classpath logging is now happening in response to an ApplicationEnvironmentPreparedEvent instead of an ApplicationStartedEvent. This is also reflected in the code diff, where the imports and the event type checks have been updated accordingly. The message effectively contrasts the before and after state of the code, making it clear what has been changed.",True,"The commit message explains that the classpath is being logged at a later point in the application lifecycle, specifically in response to an ApplicationEnvironmentPreparedEvent. This is done to ensure that the logging system has been initialized and its levels have been configured, which is a technical principle underpinning the changes.",True,"The commit message describes the changes made to the code by explaining the functional perspective. It mentions that the classpath logging was previously done in response to the ApplicationStartedEvent, but this has been changed to happen in response to an ApplicationEnvironmentPreparedEvent. This change ensures that the logging system has been initialized and its levels have been configured before the classpath is logged. This introduces new behavior as it changes when the classpath is logged, which could potentially provide more useful information.",False,"The commit message does not lack an explanation. It clearly explains the reason for the commit: the classpath is being logged at a different point in the application lifecycle to ensure that the logging system has been initialized and its levels have been configured. This change is not trivial and could have potential impacts on the application's behavior, so an explanation is necessary."
https://github.com/square/retrofit/commit/948a0db7ef1d46c66237ed2feb9f6f08ee159c68,"Allow service interfaces to extend other interfaces  <enter> With a higher minSdkVersion, the bug which prevented this on Android no longer exists. ",https://api.github.com/repos/square/retrofit/commits/948a0db7ef1d46c66237ed2feb9f6f08ee159c68,"@@ -22,7 +22,10 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.net.URL;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -128,10 +131,7 @@ public final class Retrofit {
    */
   @SuppressWarnings(""unchecked"") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
-    }
+    validateServiceInterface(service);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
@@ -151,11 +151,33 @@ public <T> T create(final Class<T> service) {
         });
   }
 
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
-        loadServiceMethod(method);
+  private void validateServiceInterface(Class<?> service) {
+    if (!service.isInterface()) {
+      throw new IllegalArgumentException(""API declarations must be interfaces."");
+    }
+
+    Deque<Class<?>> check = new ArrayDeque<>(1);
+    check.add(service);
+    while (!check.isEmpty()) {
+      Class<?> candidate = check.removeFirst();
+      if (candidate.getTypeParameters().length != 0) {
+        StringBuilder message = new StringBuilder(""Type parameters are unsupported on "")
+            .append(candidate.getName());
+        if (candidate != service) {
+          message.append("" which is an interface of "")
+              .append(service.getName());
+        }
+        throw new IllegalArgumentException(message.toString());
+      }
+      Collections.addAll(check, candidate.getInterfaces());
+    }
+
+    if (validateEagerly) {
+      Platform platform = Platform.get();
+      for (Method method : service.getDeclaredMethods()) {
+        if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
+          loadServiceMethod(method);
+        }
       }
     }
   }
@@ -317,18 +317,6 @@ static ResponseBody buffer(final ResponseBody body) throws IOException {
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
-  static <T> void validateServiceInterface(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException(""API declarations must be interfaces."");
-    }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException(""API interfaces must not extend other interfaces."");
-    }
-  }
-
   static Type getParameterUpperBound(int index, ParameterizedType type) {
     Type[] types = type.getActualTypeArguments();
     if (index < 0 || index >= types.length) {
@@ -85,6 +85,10 @@ interface FutureMethod {
   }
   interface Extending extends CallMethod {
   }
+  interface TypeParam<T> {
+  }
+  interface ExtendingTypeParam extends TypeParam<String> {
+  }
   interface StringService {
     @GET(""/"") String get();
   }
@@ -129,15 +133,47 @@ interface MutableParameters {
     assertThat(example.toString()).isNotEmpty();
   }
 
-  @Test public void interfaceWithExtendIsNotSupported() {
+  @Test public void interfaceWithTypeParameterThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url(""/""))
+        .build();
+
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    try {
+      retrofit.create(TypeParam.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""Type parameters are unsupported on retrofit2.RetrofitTest$TypeParam"");
+    }
+  }
+
+  @Test public void interfaceWithExtend() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url(""/""))
         .build();
+
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    Extending extending = retrofit.create(Extending.class);
+    String result = extending.getResponseBody().execute().body().string();
+    assertEquals(""Hi"", result);
+  }
+
+  @Test public void interfaceWithExtendWithTypeParameterThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url(""/""))
+        .build();
+
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
     try {
-      retrofit.create(Extending.class);
+      retrofit.create(ExtendingTypeParam.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""API interfaces must not extend other interfaces."");
+      assertThat(e).hasMessage(
+          ""Type parameters are unsupported on retrofit2.RetrofitTest$TypeParam ""
+              + ""which is an interface of retrofit2.RetrofitTest$ExtendingTypeParam"");
     }
   }
 
",True,The commit message refers to a bug in Android that prevented service interfaces from extending other interfaces. This is a convention or standard that the commit message is explaining why the changes were made. The code diff also supports this explanation as it shows the removal of the check that disallowed service interfaces from extending other interfaces.,True,"The commit message does not explicitly state the reason for the change, but it is clear from the code diff that the change is being made to allow service interfaces to extend other interfaces. This is done to address a bug that existed in earlier versions of Android, which is mentioned in the commit message. Therefore, the commit message does not need to provide a rationale for the change, as it is easy to infer the necessity of the change from the code diff and the commit message.",True,"The commit message explains the motivation for the change by mentioning that with a higher minSdkVersion, the bug which prevented service interfaces from extending other interfaces no longer exists. This directly elaborates the necessity of the changes, as it addresses a known issue in the previous implementation.",True,"The commit message 'Allow service interfaces to extend other interfaces' indicates that the change was made to accommodate a requirement or need. Specifically, the message mentions that the change was made due to the removal of a bug in Android with a higher minSdkVersion. This suggests that the change was made to improve the functionality or usability of the software, which is a common source of requirements.",True,"The commit message 'Allow service interfaces to extend other interfaces' directly mentions the improvement it makes to the code by stating that it allows service interfaces to extend other interfaces. This is a significant change that addresses the previous limitation in Android where this was not possible due to a bug, as mentioned in the message.",True,"The commit message 'Allow service interfaces to extend other interfaces' accurately summarizes the change in the code diff. The diff shows that the validation for service interfaces has been modified to allow them to extend other interfaces. This change is explicitly mentioned in the commit message, which makes it a summary of the diffs, pointing out the key component of the change.",True,"The commit message explains that the change allows service interfaces to extend other interfaces, which is a technical principle that allows for more flexible and composable API declarations. This is reflected in the code diff, where the validation for service interfaces not extending other interfaces has been removed, allowing for this new behavior.",True,"The commit message 'Allow service interfaces to extend other interfaces' does describe a summary of what changes by explaining the code changes from a functional perspective. It explains that the change allows service interfaces to extend other interfaces, which was previously not possible due to a bug in Android. This new behavior is described in the code diff, where the validation for service interfaces not extending other interfaces has been removed.",False,"The commit message explains the reason for the change, which is that with a higher minSdkVersion, the bug which prevented service interfaces from extending other interfaces no longer exists. This is not something that can be easily inferred from the code diff, as the diff only shows the removal of a method that previously checked for this restriction."
https://github.com/spring-projects/spring-boot/commit/da4f8514b293ef1c99deb0024e8147d4e553aa49,Add byte-buddy managed dependency  <enter> Add a managed dependency for byte-buddy since Mockito needs 1.6 and Hibernate pulls in 1.5. <enter> See  <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/da4f8514b293ef1c99deb0024e8147d4e553aa49,"@@ -1,4 +1,6 @@
-<?xml version=""1.0"" encoding=""UTF-8""?><project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
 	<groupId>org.springframework.boot</groupId>
 	<artifactId>spring-boot-dependencies</artifactId>
@@ -51,6 +53,7 @@
 		<assertj.version>2.6.0</assertj.version>
 		<atomikos.version>3.9.3</atomikos.version>
 		<bitronix.version>2.1.4</bitronix.version>
+		<byte-buddy.version>1.6.0</byte-buddy.version>
 		<caffeine.version>2.3.5</caffeine.version>
 		<cassandra-driver.version>3.1.3</cassandra-driver.version>
 		<classmate.version>1.3.3</classmate.version>
@@ -953,6 +956,11 @@
 				<artifactId>mysql-connector-java</artifactId>
 				<version>${mysql.version}</version>
 			</dependency>
+			<dependency>
+				<groupId>net.bytebuddy</groupId>
+				<artifactId>byte-buddy</artifactId>
+				<version>${byte-buddy.version}</version>
+			</dependency>
 			<dependency>
 				<groupId>net.java.dev.jna</groupId>
 				<artifactId>jna</artifactId>
@@ -2561,4 +2569,4 @@
 			<id>integration-test</id>
 		</profile>
 	</profiles>
-</project>
\ No newline at end of file
+</project>
",True,"The commit message explains the necessity of changes by referencing the versions of Mockito and Hibernate that the project uses. It mentions that Mockito needs version 1.6 and Hibernate pulls in version 1.5, so the commit adds a managed dependency for byte-buddy version 1.6. This shows that the commit message is describing the changes in relation to existing conventions, standards, and implemented features.",True,The commit message clearly explains the necessity of changes by stating that Mockito needs version 1.6 and Hibernate pulls in version 1.5 of byte-buddy. This provides a clear rationale for adding a managed dependency for byte-buddy version 1.6. The code diff also supports this explanation by adding the byte-buddy dependency to the project's POM file.,True,"The commit message directly elaborates the motivation of the code change by mentioning that Mockito needs version 1.6 and Hibernate pulls in version 1.5 of byte-buddy. This indicates that there was a compatibility issue with the previous version, which the commit message aims to resolve.",True,"The commit message 'Add a managed dependency for byte-buddy since Mockito needs 1.6 and Hibernate pulls in 1.5' indicates that the changes were made due to the need for a newer version of byte-buddy to meet the requirements of Mockito and Hibernate. This suggests that the changes were made to address a problem in the software maintenance process, specifically outdated code.",True,"The commit message directly mentions the improvement it makes to the code by adding a managed dependency for byte-buddy. This is done to ensure compatibility with Mockito and Hibernate, which require specific versions of byte-buddy.",True,"The commit message 'Add byte-buddy managed dependency' accurately summarizes the change made in the diff. It specifically mentions the addition of a new dependency for byte-buddy, which is also reflected in the diff. The message also explains why this change was made, stating that Mockito needs version 1.6 and Hibernate pulls in version 1.5. This provides context for the change and makes it clear that the addition of the byte-buddy dependency is a necessary update.",True,"The commit message explains that a new managed dependency for byte-buddy is being added to the project. This is done because Mockito needs version 1.6 and Hibernate pulls in version 1.5. This indicates that the technical principle underpinning the changes is dependency management, specifically ensuring that the project uses the correct versions of its dependencies to avoid compatibility issues.",True,"The commit message 'Add byte-buddy managed dependency' clearly describes the change made to the code, which is the addition of a new managed dependency for byte-buddy. The message also explains the reason for this change, stating that Mockito needs version 1.6 and Hibernate pulls in version 1.5. This indicates that the new dependency is being added to address compatibility issues with other dependencies in the project. The code diff also supports this explanation by showing the addition of the byte-buddy dependency in the project's POM file.",False,The commit message does not lack an explanation. It clearly states the reason for the commit: 'Add a managed dependency for byte-buddy since Mockito needs 1.6 and Hibernate pulls in 1.5.' This is a necessary explanation because the change is not trivial and might not be immediately obvious from the code diff.
https://github.com/square/okhttp/commit/09f424f12e48e2640915bf61c86a9ecd928e459e,fix README.md typo ( <pr_link> ) ,https://api.github.com/repos/square/okhttp/commits/09f424f12e48e2640915bf61c86a9ecd928e459e,"@@ -114,7 +114,7 @@ Also, we have a [bill of materials (BOM)][bom] available to help you keep OkHttp
        // define a BOM and its version
        implementation(platform(""com.squareup.okhttp3:okhttp-bom:4.9.0""))
        
-       // define any required OkHttp artifacts without verion
+       // define any required OkHttp artifacts without version
        implementation(""com.squareup.okhttp3:okhttp"")
        implementation(""com.squareup.okhttp3:logging-interceptor"")
     }
",False,"The commit message only mentions a typo fix in the README.md file, but it does not reference any conventions, standards, improvements in prior commits, or implemented features. The code diff also does not provide any context that could justify the necessity of the changes.",True,"The commit message 'fix README.md typo' does not explicitly explain why the change is necessary. However, it is common sense that a typo in a README.md file should be corrected. Additionally, the code diff shows a simple typographic fix in the README.md file, which further supports the assumption that the change was not made for a significant reason, but rather to improve clarity or accuracy.",False,"The commit message only mentions a typo fix in the README.md file and does not elaborate on the necessity of the changes. It does not describe an error scenario, mention an issue report, or explain any shortcomings of the previous implementation.",False,"The commit message 'fix README.md typo' does not contain an expression that describes the necessity of changes. It only mentions a typo fix in the README.md file. The code diff does not indicate any software development for user requirements, problems in the process of software maintenance like out of date code, runtime or development environment change.",False,"The commit message only mentions a typo fix in the README.md file, but it does not directly describe the objective of the change in terms of fixing defects or making improvements to the code.",True,"The commit message 'fix README.md typo' does not directly describe the changes made in the code diff. However, it does indicate a change in the README.md file, which is not reflected in the provided diff. The diff shows a change in a build.gradle.kts file, where the comment 'without verion' has been corrected to 'without version'. While the commit message does not explicitly mention this change, it does imply a modification to the project's configuration files, which is reflected in the diff.",False,"The commit message only mentions a typo fix in the README.md file, but it does not describe any technical principle underpinning the changes in the code diff. The code diff shows a correction in the comment of the build.gradle file, changing 'verion' to 'version', which is not a significant change that requires a description of a technical principle.",False,"The commit message only mentions a typo fix in the README.md file, but it does not describe any changes in the code or introduce new behaviors. The code diff shows a simple typo correction in a comment, not a functional change.",True,"The commit message 'fix README.md typo' clearly indicates that a small typographical error was corrected in the README.md file. The change in the code diff, replacing 'verion' with 'version', is a simple and straightforward correction that can be easily inferred from the context. Therefore, there was no need for an additional explanation in the commit message."
https://github.com/square/retrofit/commit/0fff59140b5791ad0f1b1c7bf7826db2e00a73f1,Pull out ServiceMethod base class  <enter> This will allow us to support multiple forms of invocation beyond HTTP calls. ,https://api.github.com/repos/square/retrofit/commits/0fff59140b5791ad0f1b1c7bf7826db2e00a73f1,"@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+
+/** Adapts an invocation of an interface method into an HTTP call. */
+final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
+  private final RequestFactory requestFactory;
+  private final okhttp3.Call.Factory callFactory;
+  private final CallAdapter<ResponseT, ReturnT> callAdapter;
+  private final Converter<ResponseBody, ResponseT> responseConverter;
+
+  HttpServiceMethod(Builder<ResponseT, ReturnT> builder) {
+    requestFactory = builder.requestFactory;
+    callFactory = builder.retrofit.callFactory();
+    callAdapter = builder.callAdapter;
+    responseConverter = builder.responseConverter;
+  }
+
+  @Override ReturnT invoke(@Nullable Object[] args) {
+    return callAdapter.adapt(
+        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
+  }
+
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method. This
+   * requires potentially-expensive reflection so it is best to build each service method only once
+   * and reuse it. Builders cannot be reused.
+   */
+  static final class Builder<ResponseT, ReturnT> {
+    final Retrofit retrofit;
+    final Method method;
+
+    RequestFactory requestFactory;
+    Type responseType;
+    Converter<ResponseBody, ResponseT> responseConverter;
+    CallAdapter<ResponseT, ReturnT> callAdapter;
+
+    Builder(Retrofit retrofit, Method method) {
+      this.retrofit = retrofit;
+      this.method = method;
+    }
+
+    HttpServiceMethod<ResponseT, ReturnT> build() {
+      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
+      callAdapter = createCallAdapter();
+      responseType = callAdapter.responseType();
+      if (responseType == Response.class || responseType == okhttp3.Response.class) {
+        throw methodError(""'""
+            + Utils.getRawType(responseType).getName()
+            + ""' is not a valid response body type. Did you mean ResponseBody?"");
+      }
+      responseConverter = createResponseConverter();
+
+      if (requestFactory.httpMethod.equals(""HEAD"") && !Void.class.equals(responseType)) {
+        throw methodError(""HEAD method must use Void as response type."");
+      }
+
+      return new HttpServiceMethod<>(this);
+    }
+
+    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
+      Type returnType = method.getGenericReturnType();
+      if (Utils.hasUnresolvableType(returnType)) {
+        throw methodError(
+            ""Method return type must not include a type variable or wildcard: %s"", returnType);
+      }
+      if (returnType == void.class) {
+        throw methodError(""Service methods cannot return void."");
+      }
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        //noinspection unchecked
+        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, ""Unable to create call adapter for %s"", returnType);
+      }
+    }
+
+    private Converter<ResponseBody, ResponseT> createResponseConverter() {
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        return retrofit.responseBodyConverter(responseType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, ""Unable to create converter for %s"", responseType);
+      }
+    }
+
+    private RuntimeException methodError(String message, Object... args) {
+      return methodError(null, message, args);
+    }
+
+    private RuntimeException methodError(Throwable cause, String message, Object... args) {
+      message = String.format(message, args);
+      return new IllegalArgumentException(message
+          + ""\n    for method ""
+          + method.getDeclaringClass().getSimpleName()
+          + "".""
+          + method.getName(), cause);
+    }
+  }
+}
@@ -58,7 +58,7 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
+  private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
 
   final okhttp3.Call.Factory callFactory;
   final HttpUrl baseUrl;
@@ -157,8 +157,8 @@ private void eagerlyValidateMethods(Class<?> service) {
     }
   }
 
-  ServiceMethod<?, ?> loadServiceMethod(Method method) {
-    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+  ServiceMethod<?> loadServiceMethod(Method method) {
+    ServiceMethod<?> result = serviceMethodCache.get(method);
     if (result != null) return result;
 
     synchronized (serviceMethodCache) {
@@ -15,112 +15,13 @@
  */
 package retrofit2;
 
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
-import java.lang.reflect.Type;
 import javax.annotation.Nullable;
-import okhttp3.ResponseBody;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
-final class ServiceMethod<ResponseT, ReturnT> {
-  static <ResponseT, ReturnT> ServiceMethod<ResponseT, ReturnT> parseAnnotations(Retrofit retrofit,
-      Method method) {
-    return new ServiceMethod.Builder<ResponseT, ReturnT>(retrofit, method).build();
+abstract class ServiceMethod<T> {
+  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    return new HttpServiceMethod.Builder<Object, T>(retrofit, method).build();
   }
 
-  private final RequestFactory requestFactory;
-  private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<ResponseT, ReturnT> callAdapter;
-  private final Converter<ResponseBody, ResponseT> responseConverter;
-
-  ServiceMethod(Builder<ResponseT, ReturnT> builder) {
-    requestFactory = builder.requestFactory;
-    callFactory = builder.retrofit.callFactory();
-    callAdapter = builder.callAdapter;
-    responseConverter = builder.responseConverter;
-  }
-
-  ReturnT invoke(@Nullable Object[] args) {
-    return callAdapter.adapt(
-        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  private static final class Builder<ResponseT, ReturnT> {
-    final Retrofit retrofit;
-    final Method method;
-
-    RequestFactory requestFactory;
-    Type responseType;
-    Converter<ResponseBody, ResponseT> responseConverter;
-    CallAdapter<ResponseT, ReturnT> callAdapter;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-    }
-
-    ServiceMethod<ResponseT, ReturnT> build() {
-      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
-
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError(""'""
-            + Utils.getRawType(responseType).getName()
-            + ""' is not a valid response body type. Did you mean ResponseBody?"");
-      }
-      responseConverter = createResponseConverter();
-
-      if (requestFactory.httpMethod.equals(""HEAD"") && !Void.class.equals(responseType)) {
-        throw methodError(""HEAD method must use Void as response type."");
-      }
-
-      return new ServiceMethod<>(this);
-    }
-
-    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(
-            ""Method return type must not include a type variable or wildcard: %s"", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError(""Service methods cannot return void."");
-      }
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, ""Unable to create call adapter for %s"", returnType);
-      }
-    }
-
-    private Converter<ResponseBody, ResponseT> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, ""Unable to create converter for %s"", responseType);
-      }
-    }
-
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
-    }
-
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + ""\n    for method ""
-          + method.getDeclaringClass().getSimpleName()
-          + "".""
-          + method.getName(), cause);
-    }
-  }
+  abstract T invoke(@Nullable Object[] args);
 }
",True,"The commit message refers to the necessity of changes by mentioning that it is allowing for multiple forms of invocation beyond HTTP calls. This is an improvement over the previous implementation, which only supported HTTP calls. The code diff also supports this, as it introduces a new base class for service methods that can handle multiple forms of invocation.",True,"The commit message 'Pull out ServiceMethod base class' does not explicitly state the necessity of the changes, but it can be inferred from the code diff. The code diff shows the creation of a new base class 'HttpServiceMethod' and its usage in the 'Retrofit' class. This suggests that the changes are being made to support multiple forms of invocation beyond HTTP calls, which is a clear necessity for the project.",True,"The commit message 'Pull out ServiceMethod base class' explains the motivation for the change by stating that it will allow the support for multiple forms of invocation beyond HTTP calls. This implies that the current implementation might have limitations in this area, which is a clear indication of a shortcoming that the change aims to address.",True,"The commit message 'Pull out ServiceMethod base class' indicates that the developer is making changes to support multiple forms of invocation beyond HTTP calls. This could be due to the need for software development to meet the requirements of users who need to make different types of calls, or it could be a problem in the process of software maintenance, such as outdated code that no longer supports the necessary functionality.",True,"The commit message 'Pull out ServiceMethod base class' directly mentions the improvement it makes to the code, which is to allow support for multiple forms of invocation beyond HTTP calls. This is a clear indication that the change is intended to address a limitation or defect in the existing code.",True,"The commit message 'Pull out ServiceMethod base class' accurately summarizes the key component of the change, which is the creation of a new base class called 'HttpServiceMethod'. This class is used to adapt an invocation of an interface method into an HTTP call, as described in the code diff.",True,"The commit message 'Pull out ServiceMethod base class' describes the technical principle of creating a reusable base class for service methods, which allows for the support of multiple forms of invocation beyond HTTP calls. This is evident in the code diff, where a new abstract class 'ServiceMethod' is created, and the 'HttpServiceMethod' class extends this base class. This design allows for the addition of new types of service methods in the future without modifying existing code.",True,"The commit message 'Pull out ServiceMethod base class' describes the code change of creating a new base class called 'ServiceMethod' and refactoring the existing 'HttpServiceMethod' class to extend this new base class. This change allows for the support of multiple forms of invocation beyond HTTP calls, as stated in the commit message. The new base class provides a blueprint for adapting an invocation of an interface method into an HTTP call, which is then implemented by the 'HttpServiceMethod' class. This change introduces new behavior by enabling the handling of different types of invocations, expanding the functionality of the codebase.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'This will allow us to support multiple forms of invocation beyond HTTP calls.' The code diff shows the creation of a new base class 'HttpServiceMethod' which is likely to be used to support other types of invocation, such as WebSocket calls or gRPC calls. This is a significant change that requires explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/8561929164846ef4b3323a8b3f88a09ea1441785,"Improve Spring Session sample  <enter> This commit improves the Spring Session sample by providing multiple build profiles that make it possible to easily try out different session stores. By default, JDBC session store backed by an in-memory embedded H2 database is used. <enter> See  <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/8561929164846ef4b3323a8b3f88a09ea1441785,"@@ -158,8 +158,8 @@ The following sample applications are provided:
 | link:spring-boot-sample-servlet[spring-boot-sample-servlet]
 | Web application with a ""raw"" `Servlet` returning plain text content
 
-| link:spring-boot-sample-session-redis[spring-boot-sample-session-redis]
-| Web Application that uses Spring Session to store session data in Redis
+| link:spring-boot-sample-session[spring-boot-sample-session]
+| Web Application that uses Spring Session to manage session data
 
 | link:spring-boot-sample-simple[spring-boot-sample-simple]
 | Simple command line application
@@ -71,7 +71,7 @@
 		<module>spring-boot-sample-secure-oauth2-actuator</module>
 		<module>spring-boot-sample-secure-oauth2-resource</module>
 		<module>spring-boot-sample-servlet</module>
-		<module>spring-boot-sample-session-redis</module>
+		<module>spring-boot-sample-session</module>
 		<module>spring-boot-sample-simple</module>
 		<module>spring-boot-sample-test</module>
 		<module>spring-boot-sample-test-nomockito</module>
@@ -1,50 +0,0 @@
-<?xml version=""1.0"" encoding=""UTF-8""?>
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
-	<modelVersion>4.0.0</modelVersion>
-	<parent>
-		<!-- Your own application should inherit from spring-boot-starter-parent -->
-		<groupId>org.springframework.boot</groupId>
-		<artifactId>spring-boot-samples</artifactId>
-		<version>2.0.0.BUILD-SNAPSHOT</version>
-	</parent>
-	<artifactId>spring-boot-sample-session-redis</artifactId>
-	<name>Spring Boot Session Redis Sample</name>
-	<description>Spring Boot Session Redis Sample</description>
-	<url>http://projects.spring.io/spring-boot/</url>
-	<organization>
-		<name>Pivotal Software, Inc.</name>
-		<url>http://www.spring.io</url>
-	</organization>
-	<properties>
-		<main.basedir>${basedir}/../..</main.basedir>
-	</properties>
-	<dependencies>
-		<!-- Compile -->
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-web</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-data-redis</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework.session</groupId>
-			<artifactId>spring-session-data-redis</artifactId>
-		</dependency>
-		<!-- Test -->
-		<dependency>
-			<groupId>org.springframework.boot</groupId>
-			<artifactId>spring-boot-starter-test</artifactId>
-			<scope>test</scope>
-		</dependency>
-	</dependencies>
-	<build>
-		<plugins>
-			<plugin>
-				<groupId>org.springframework.boot</groupId>
-				<artifactId>spring-boot-maven-plugin</artifactId>
-			</plugin>
-		</plugins>
-	</build>
-</project>
@@ -0,0 +1,48 @@
+= Spring Boot Spring Session Sample
+
+This sample demonstrates the Spring Session auto-configuration support. Spring Session
+supports multiple session store types, including:
+
+* `Redis`
+* `JDBC`
+* `Hazelcast`
+
+
+
+== Using a different session store
+Initially, the project uses JDBC session store backed by an in-memory embedded H2
+database. You can try out your favorite session store as explained below.
+
+
+
+=== Redis
+Add `org.springframework.session:spring-session-data-redis` and
+`spring-boot-starter-data-redis` dependencies to the project and make sure it is
+configured properly (by default, a Redis instance with the default settings is expected
+on your local box).
+
+TIP: Run sample application using Redis session store using
+`$mvn spring-boot:run -Predis`.
+
+
+
+=== JDBC
+Add `org.springframework.session:spring-session-jdbc`,
+`org.springframework.boot:spring-boot-starter-jdbc` and `com.h2database:h2` dependencies
+to the project. An in-memory embedded H2 database is automatically configured.
+
+TIP: Run sample application using JDBC session store with
+`$mvn spring-boot:run -Pjdbc`.
+
+Note that this profile is active by default.
+
+
+
+=== Hazelcast
+Add `org.springframework.session:spring-session-hazelcast` and `com.hazelcast:hazelcast`
+dependencies to the project to enable support for Hazelcast. Since there is a default
+`hazelcast.xml` configuration file at the root of the classpath, it is used to
+automatically configure the underlying `HazelcastInstance`.
+
+TIP: Run sample application using Hazelcast session store with
+`$mvn spring-boot:run -Phazelcast`.
@@ -0,0 +1,90 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<!-- Your own application should inherit from spring-boot-starter-parent -->
+		<groupId>org.springframework.boot</groupId>
+		<artifactId>spring-boot-samples</artifactId>
+		<version>2.0.0.BUILD-SNAPSHOT</version>
+	</parent>
+	<artifactId>spring-boot-sample-session</artifactId>
+	<name>Spring Boot Session Sample</name>
+	<description>Spring Boot Session Sample</description>
+	<url>http://projects.spring.io/spring-boot/</url>
+	<organization>
+		<name>Pivotal Software, Inc.</name>
+		<url>http://www.spring.io</url>
+	</organization>
+	<properties>
+		<main.basedir>${basedir}/../..</main.basedir>
+	</properties>
+	<dependencies>
+		<!-- Compile -->
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-web</artifactId>
+		</dependency>
+		<!-- Test -->
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-test</artifactId>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
+	<build>
+		<plugins>
+			<plugin>
+				<groupId>org.springframework.boot</groupId>
+				<artifactId>spring-boot-maven-plugin</artifactId>
+			</plugin>
+		</plugins>
+	</build>
+	<profiles>
+		<profile>
+			<id>redis</id>
+			<dependencies>
+				<dependency>
+					<groupId>org.springframework.session</groupId>
+					<artifactId>spring-session-data-redis</artifactId>
+				</dependency>
+				<dependency>
+					<groupId>org.springframework.boot</groupId>
+					<artifactId>spring-boot-starter-data-redis</artifactId>
+				</dependency>
+			</dependencies>
+		</profile>
+		<profile>
+			<id>jdbc</id>
+			<activation>
+				<activeByDefault>true</activeByDefault>
+			</activation>
+			<dependencies>
+				<dependency>
+					<groupId>org.springframework.session</groupId>
+					<artifactId>spring-session-jdbc</artifactId>
+				</dependency>
+				<dependency>
+					<groupId>org.springframework.boot</groupId>
+					<artifactId>spring-boot-starter-jdbc</artifactId>
+				</dependency>
+				<dependency>
+					<groupId>com.h2database</groupId>
+					<artifactId>h2</artifactId>
+				</dependency>
+			</dependencies>
+		</profile>
+		<profile>
+			<id>hazelcast</id>
+			<dependencies>
+				<dependency>
+					<groupId>org.springframework.session</groupId>
+					<artifactId>spring-session-hazelcast</artifactId>
+				</dependency>
+				<dependency>
+					<groupId>com.hazelcast</groupId>
+					<artifactId>hazelcast</artifactId>
+				</dependency>
+			</dependencies>
+		</profile>
+	</profiles>
+</project>
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2015 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -20,10 +20,10 @@
 import org.springframework.boot.autoconfigure.SpringBootApplication;
 
 @SpringBootApplication
-public class SampleSessionRedisApplication {
+public class SampleSessionApplication {
 
 	public static void main(String[] args) throws Exception {
-		SpringApplication.run(SampleSessionRedisApplication.class);
+		SpringApplication.run(SampleSessionApplication.class);
 	}
 
 }
@@ -0,0 +1,20 @@
+<hazelcast xsi:schemaLocation=""http://www.hazelcast.com/schema/config hazelcast-config-3.8.xsd""
+		   xmlns=""http://www.hazelcast.com/schema/config""
+		   xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
+
+	<map name=""spring:session:sessions"">
+		<attributes>
+			<attribute extractor=""org.springframework.session.hazelcast.PrincipalNameExtractor"">principalName</attribute>
+		</attributes>
+		<indexes>
+			<index>principalName</index>
+		</indexes>
+	</map>
+
+	<network>
+		<join>
+			<multicast enabled=""false""/>
+		</join>
+	</network>
+
+</hazelcast>
@@ -23,7 +23,6 @@
 import org.springframework.boot.builder.SpringApplicationBuilder;
 import org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer;
 import org.springframework.context.ConfigurableApplicationContext;
-import org.springframework.data.redis.RedisConnectionFailureException;
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpMethod;
 import org.springframework.http.RequestEntity;
@@ -33,31 +32,20 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 /**
- * Tests for {@link SampleSessionRedisApplication}.
+ * Tests for {@link SampleSessionApplication}.
  *
  * @author Andy Wilkinson
  */
-public class SampleSessionRedisApplicationTests {
+public class SampleSessionApplicationTests {
 
 	@Test
 	public void sessionExpiry() throws Exception {
-
-		String port = null;
-
-		try {
-			ConfigurableApplicationContext context = new SpringApplicationBuilder()
-					.sources(SampleSessionRedisApplication.class)
-					.properties(""server.port:0"")
-					.initializers(new ServerPortInfoApplicationContextInitializer())
-					.run();
-			port = context.getEnvironment().getProperty(""local.server.port"");
-		}
-		catch (RuntimeException ex) {
-			if (!redisServerRunning(ex)) {
-				return;
-			}
-			throw ex;
-		}
+		ConfigurableApplicationContext context = new SpringApplicationBuilder()
+				.sources(SampleSessionApplication.class)
+				.properties(""server.port:0"")
+				.initializers(new ServerPortInfoApplicationContextInitializer())
+				.run();
+		String port = context.getEnvironment().getProperty(""local.server.port"");
 
 		URI uri = URI.create(""http://localhost:"" + port + ""/"");
 		RestTemplate restTemplate = new RestTemplate();
@@ -79,11 +67,4 @@ public void sessionExpiry() throws Exception {
 		assertThat(uuid2).isNotEqualTo(uuid3);
 	}
 
-	private boolean redisServerRunning(Throwable ex) {
-		if (ex instanceof RedisConnectionFailureException) {
-			return false;
-		}
-		return (ex.getCause() == null || redisServerRunning(ex.getCause()));
-	}
-
 }
",True,"The commit message refers to the necessity of changes by mentioning the improvement in the Spring Session sample. It explains that the commit adds multiple build profiles that make it possible to easily try out different session stores. This is a clear reference to a convention or standard, as it allows users to switch between different session stores without having to modify the application code.",True,"The commit message 'Improve Spring Session sample' does not explicitly state the necessity of the changes, but it is clear from the code diff that the changes are made to provide multiple build profiles that make it easier to try out different session stores. This is a common practice to improve the flexibility and usability of the sample application, and the commit message does not need to explicitly state this as it is a well-known convention in the development community.",True,"The commit message explains the motivation for the change by stating that it improves the Spring Session sample by providing multiple build profiles that make it possible to easily try out different session stores. This directly addresses the shortcoming of the previous implementation, which only supported a single session store (Redis).",True,"The commit message 'Improve Spring Session sample' indicates that the changes were made to enhance the functionality of the Spring Session sample. The message mentions the addition of multiple build profiles that allow for easy testing of different session stores. This suggests that the developer was addressing a requirement for more flexibility and versatility in the sample application, which could be seen as a user requirement.",True,"The commit message 'Improve Spring Session sample' clearly mentions that the change is to improve the Spring Session sample by providing multiple build profiles that make it possible to easily try out different session stores. This directly indicates that the change is an improvement to the code, as it adds more functionality and flexibility to the sample application.",True,"The commit message describes the changes made to the Spring Session sample by mentioning the addition of multiple build profiles for different session stores. It also contrasts the before and after by stating that the previous Redis session store has been replaced with a more general Spring Session, which can manage session data.",True,"The commit message explains that the Spring Session sample has been improved to provide multiple build profiles that allow for easy testing of different session stores. This highlights the principle of modularity and flexibility in software design, where different components can be swapped out or configured to suit different needs.",True,"The commit message 'Improve Spring Session sample' describes the changes made to the codebase. It explains that the commit improves the Spring Session sample by providing multiple build profiles that allow for easy testing of different session stores. The message also mentions that by default, JDBC session store backed by an in-memory embedded H2 database is used. The code diff provided supports this explanation by showing changes to the project name, description, and dependencies, as well as the addition of build profiles for Redis, JDBC, and Hazelcast session stores. The message does not explicitly describe the new behaviors introduced, but the changes to the project and the addition of different session store options imply that the application will now be able to manage session data in different ways, which is a new behavior.",False,The commit message does not lack an explanation. It clearly states that the commit improves the Spring Session sample by providing multiple build profiles that make it possible to easily try out different session stores. This change is not trivial and the commit message provides a clear explanation of the reason for the change.
https://github.com/spring-projects/spring-boot/commit/fa6ee8e34d5f76ee57dd9f9c84bb047c5ee3d356,Clarify h2-console requires a servlet-based web app  <enter> Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/fa6ee8e34d5f76ee57dd9f9c84bb047c5ee3d356,"@@ -3610,7 +3610,7 @@ http://www.h2database.com/html/quickstart.html#h2_console[browser-based console]
 Spring Boot can auto-configure for you. The console is auto-configured when the following
 conditions are met:
 
-* You are developing a web application.
+* You are developing a servlet-based web application.
 * `com.h2database:h2` is on the classpath.
 * You are using <<using-spring-boot.adoc#using-boot-devtools,Spring Boot's developer
 tools>>.
",True,"The commit message 'Clarify h2-console requires a servlet-based web app' refers to a convention or standard by specifying that the h2-console feature requires a servlet-based web application. This clarification is necessary to avoid confusion or errors, as the change in the code diff indicates.",True,"The commit message 'Clarify h2-console requires a servlet-based web app' is describing a necessary change to the documentation. The change in the code diff is from 'web application' to 'servlet-based web application', which clarifies that the h2-console feature requires a servlet-based web application to function. This change is not trivial and could potentially confuse users who are not aware of this requirement, so it is necessary to document it clearly.",True,"The commit message 'Clarify h2-console requires a servlet-based web app' directly elaborates the motivation of the code change by specifying that the h2-console requires a servlet-based web application, which is different from a regular web application. This change is likely necessary to fix an issue, as indicated by the 'Fixes <issue_link>' part of the message. The code diff also supports this by specifically changing the requirement from 'web application' to 'servlet-based web application'.",True,"The commit message 'Clarify h2-console requires a servlet-based web app' indicates that the developer is addressing a requirement change. The change in the code diff from 'web application' to 'servlet-based web application' suggests that there has been a clarification in the software requirements, likely due to a change in the type of web application being developed.",True,"The commit message 'Clarify h2-console requires a servlet-based web app' directly mentions the improvement it makes to the code. It specifies that the change is to clarify that the h2-console requires a servlet-based web application, which is an improvement to the existing documentation or code.",True,"The commit message 'Clarify h2-console requires a servlet-based web app' accurately summarizes the change in the diff. It points out the key component of the change, which is the modification of the requirement for the h2-console from a web application to a servlet-based web application. This is a clear and concise summary of the change made in the code diff.",True,"The commit message 'Clarify h2-console requires a servlet-based web app' does describe a technical principle underpinning the changes. The principle is that the h2-console, a browser-based console for the H2 database, requires a servlet-based web application to function properly. This is a technical principle because it explains a necessary condition for the correct functioning of a specific feature or component in the codebase.",True,"The commit message 'Clarify h2-console requires a servlet-based web app' accurately describes the code change. It explains that the condition for auto-configuring the h2 console has been modified from 'You are developing a web application' to 'You are developing a servlet-based web application'. This change introduces a new behavior where the h2 console will only be auto-configured for servlet-based web applications, which is a clear and functional explanation of the code change.",False,"The commit message does not lack an explanation. It explicitly states that the change is made to clarify that the h2-console requires a servlet-based web application. This is not a trivial change and could potentially cause issues if not properly understood, so an explanation is necessary."
https://github.com/spring-projects/spring-boot/commit/46fbca66a69d102db55f7c454565f82ff5be6b98,Fix typo 'a' -> 'an',https://api.github.com/repos/spring-projects/spring-boot/commits/46fbca66a69d102db55f7c454565f82ff5be6b98,"@@ -158,7 +158,7 @@ Health information can be used to check the status of your running application.
 often used by monitoring software to alert someone if a production system goes down.
 The default information exposed by the `health` endpoint depends on how it is accessed.
 For an unauthenticated connection in a secure application a simple '`status`' message is 
-returned, and for a authenticated connection additional details are also displayed (see
+returned, and for an authenticated connection additional details are also displayed (see
 <<production-ready-health-access-restrictions>> for HTTP details).
 
 Health information is collected from all
",False,"The commit message only mentions a typo fix, which is a small change and does not reference any conventions, standards, improvements in prior commits, or implemented features.",True,"The commit message 'Fix typo 'a' -> 'an'' clearly describes the necessity of the change, which is to correct a typographical error. This is a common practice in software development and does not require a detailed explanation, as the purpose of the change is self-explanatory.",False,"The commit message 'Fix typo 'a' -> 'an'' does not directly elaborate the motivation of the code change. It does not describe an error scenario, mention an issue report, or explain any shortcomings of the previous implementation. Instead, it simply states that a typographical error was corrected.",False,"The commit message 'Fix typo 'a' -> 'an'' does not contain an expression that describes the necessity of changes. It only mentions a typographical error, which is not related to user requirements, software maintenance problems, or changes in the development environment.",False,"The commit message only mentions a typo fix, which is a small change in the code that doesn't necessarily improve the functionality or fix any defects. It doesn't directly mention any improvements or defect fixes related to the code.",False,"The commit message only mentions a typo fix, but it does not summarize the changes made in the diff. The diff shows a change in the text of the health endpoint documentation, specifically correcting a typo. However, the commit message does not describe this change or list the key components of the change.",False,"The commit message only mentions a typo fix, not a technical principle. The code diff shows a change in the text of the health endpoint response for authenticated connections, but the commit message does not explain why this change was made or what principle it is based on.",False,"The commit message only mentions a typo fix, but it does not describe any functional changes or new behaviors introduced by the code changes. The code diff shows a simple typographical correction in the documentation, not a functional change in the codebase.",True,"The commit message clearly states that a typo was fixed, changing 'a' to 'an'. This is a small and simple change that can easily be inferred from the diff. Therefore, there was no need for an additional explanation in the commit message."
https://github.com/junit-team/junit4/commit/cb0c4e9f7c9be8be7c11e4934f6bd71a312102ec,"For <issue_link> , remove FrameworkMethod.getParameterSignatures()  <enter> Having this method in place made a class from the 'core' of JUnit (org.junit.runners.model) depend on something from 'experimental' -- a dependency going in the wrong direction. ",https://api.github.com/repos/junit-team/junit4/commits/cb0c4e9f7c9be8be7c11e4934f6bd71a312102ec,"@@ -78,7 +78,7 @@ protected void validateTestMethods(List<Throwable> errors) {
                 each.validatePublicVoidNoArg(false, errors);
             }
             
-            for (ParameterSignature signature : each.getParameterSignatures()) {
+            for (ParameterSignature signature : ParameterSignature.signatures(each.getMethod())) {
                 ParametersSuppliedBy annotation = signature.findDeepAnnotation(ParametersSuppliedBy.class);
                 if (annotation != null) {
                     validateParameterSupplier(annotation.value(), errors);
@@ -7,7 +7,6 @@
 import java.lang.reflect.Type;
 import java.util.List;
 
-import org.junit.experimental.theories.ParameterSignature;
 import org.junit.internal.runners.model.ReflectiveCallable;
 
 /**
@@ -198,10 +197,6 @@ public <T extends Annotation> T getAnnotation(Class<T> annotationType) {
         return fMethod.getAnnotation(annotationType);
     }
 
-    public List<ParameterSignature> getParameterSignatures() {
-        return ParameterSignature.signatures(fMethod);
-    }
-
     @Override
     public String toString() {
         return fMethod.toString();
",True,"The commit message refers to a convention or standard regarding the dependency direction between different parts of the JUnit framework. It explains that the changes are necessary to remove a dependency from the 'core' of JUnit to something from the 'experimental' section, which is going in the wrong direction. This is a clear reference to a standard or convention within the project.",True,"The commit message explains the necessity of changes by stating that having the method 'FrameworkMethod.getParameterSignatures()' in place made a class from the 'core' of JUnit depend on something from 'experimental'. This dependency was going in the wrong direction, which is a clear reason for the removal of the method. The code diff also supports this explanation by showing the removal of the method and its associated import statement.",True,The commit message directly elaborates the motivation of the code change by mentioning the issue link and explaining that the method 'FrameworkMethod.getParameterSignatures()' was causing a dependency going in the wrong direction from the 'core' of JUnit to something 'experimental'. This clearly describes the shortcoming of the previous implementation and the necessity of the changes.,True,"The commit message indicates that the changes were made to address an issue (referenced by the issue link). The issue is that the method FrameworkMethod.getParameterSignatures() was causing a dependency going in the wrong direction, with a class from the 'core' of JUnit depending on something from 'experimental'. This suggests that the changes were made to improve the maintainability of the software by removing unnecessary dependencies and making the codebase more modular.",True,"The commit message directly mentions the issue it fixes, which is the undesirable dependency from 'core' JUnit to 'experimental'. This issue is resolved by removing the FrameworkMethod.getParameterSignatures() method, which was causing the dependency. The change is also explained in the diff, where the method call is replaced with a direct call to ParameterSignature.signatures(each.getMethod()).",True,"The commit message accurately summarizes the changes made in the code diff. It mentions the removal of the FrameworkMethod.getParameterSignatures() method, which is also reflected in the diff. Additionally, the message explains the reason for the change, highlighting the undesirable dependency between the 'core' and 'experimental' parts of JUnit.",True,"The commit message explains the technical principle underpinning the changes. It mentions that the method 'FrameworkMethod.getParameterSignatures()' is being removed because it creates a dependency from a core JUnit class to an experimental one, which goes against the principle of modularity and separation of concerns.",True,"The commit message does a good job of summarizing the changes. It mentions the removal of the 'FrameworkMethod.getParameterSignatures()' method, which is also reflected in the code diff. The message explains the reason for this removal, stating that it made a class from the 'core' of JUnit depend on something from 'experimental', which is a dependency going in the wrong direction. Additionally, the message describes the new behavior introduced by replacing the method with 'ParameterSignature.signatures(each.getMethod())', which is also visible in the code diff.",False,The commit message does not lack an explanation. It clearly states the reason for the change: 'Having this method in place made a class from the 'core' of JUnit depend on something from 'experimental'. This dependency going in the wrong direction was the reason for the removal of the method.' The code diff also supports this explanation by showing the removal of the method and its dependencies.
https://github.com/apache/dubbo/commit/80776517e923a7bb77a307b74d3b5fdfa1c2b22d,"temporarily change spring-context-support dependency back to SNAPSHOT, the formal release turns to be broken.",https://api.github.com/repos/apache/dubbo/commits/80776517e923a7bb77a307b74d3b5fdfa1c2b22d,"@@ -542,6 +542,10 @@
             <groupId>org.springframework</groupId>
             <artifactId>spring-context</artifactId>
         </dependency>
+        <dependency>
+            <groupId>com.alibaba.spring</groupId>
+            <artifactId>spring-context-support</artifactId>
+        </dependency>
         <dependency>
             <groupId>org.javassist</groupId>
             <artifactId>javassist</artifactId>
@@ -145,7 +145,7 @@
         <eureka.version>1.9.12</eureka.version>
 
         <!-- Alibaba -->
-        <alibaba_spring_context_support_version>1.0.4</alibaba_spring_context_support_version>
+        <alibaba_spring_context_support_version>1.0.4-SNAPSHOT</alibaba_spring_context_support_version>
 
         <jaxb_version>2.2.7</jaxb_version>
         <activation_version>1.2.0</activation_version>
",True,"The commit message refers to a problem with the formal release of the spring-context-support dependency, stating that it is broken. This explains the necessity of the changes made in the commit, which is to temporarily revert back to the SNAPSHOT version of the dependency.",True,"The commit message 'temporarily change spring-context-support dependency back to SNAPSHOT, the formal release turns to be broken.' clearly explains the necessity of the changes. It states that the formal release of the dependency is broken, and the changes are made to revert back to a working version (SNAPSHOT). This explanation is sufficient to understand the reason for the changes without needing additional context or code review.",True,"The commit message directly elaborates the motivation of the code change by mentioning that the formal release of the spring-context-support dependency is broken, and the change is made temporarily to revert back to the SNAPSHOT version until the issue is resolved.",True,"The commit message 'temporarily change spring-context-support dependency back to SNAPSHOT, the formal release turns to be broken' indicates that the developer made changes due to a problem. The message mentions that the formal release of the spring-context-support dependency is broken, which necessitated the change back to the SNAPSHOT version.",True,"The commit message directly mentions the issue that the formal release of the spring-context-support dependency is broken, and the change made is a temporary fix to revert back to the SNAPSHOT version until the issue is resolved.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions the modification of the spring-context-support dependency from version 1.0.4 to 1.0.4-SNAPSHOT, which is also reflected in the diff. Additionally, the message explains the reason for the change, stating that the formal release of the dependency is broken, and the change is temporary.",False,The commit message does not explicitly state or describe a technical principle underpinning the changes. It only mentions that a dependency version was temporarily changed due to a broken release issue.,True,"The commit message accurately describes the change made in the code diff. It explains that the version of the 'spring-context-support' dependency was temporarily changed back to SNAPSHOT due to a broken formal release. This change introduces new behavior as it switches the dependency version, which could potentially introduce new features, fixes, or bugs.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'the formal release turns to be broken'. This reason is not easily inferred from the code diff, as the change is not trivial (changing a dependency version from a released version to a snapshot version)."
https://github.com/apache/dubbo/commit/ff76661ef4ad2af0b92c208dc0740bb00e93020b,change version to 2.7.6-SNAPSHOT to prepare for next major release ,https://api.github.com/repos/apache/dubbo/commits/ff76661ef4ad2af0b92c208dc0740bb00e93020b,"@@ -162,7 +162,7 @@
         <mortbay_jetty_version>6.1.26</mortbay_jetty_version>
         <portlet_version>2.0</portlet_version>
         <maven_flatten_version>1.1.0</maven_flatten_version>
-        <revision>2.7.5-SNAPSHOT</revision>
+        <revision>2.7.6-SNAPSHOT</revision>
     </properties>
 
     <dependencyManagement>
@@ -32,7 +32,7 @@
     <packaging>pom</packaging>
 
     <properties>
-        <revision>2.7.5-SNAPSHOT</revision>
+        <revision>2.7.6-SNAPSHOT</revision>
         <maven_flatten_version>1.1.0</maven_flatten_version>
     </properties>
 
@@ -125,7 +125,7 @@
         <arguments />
         <checkstyle.skip>true</checkstyle.skip>
         <rat.skip>true</rat.skip>
-        <revision>2.7.5-SNAPSHOT</revision>
+        <revision>2.7.6-SNAPSHOT</revision>
     </properties>
 
     <modules>
",False,"The commit message only mentions the change in version number from 2.7.5-SNAPSHOT to 2.7.6-SNAPSHOT to prepare for the next major release. It does not reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes.",True,"The commit message 'change version to 2.7.6-SNAPSHOT to prepare for next major release' does not provide a rationale for the change, but it is easy to infer from the code diff that the version is being updated to prepare for the next major release. This is a common practice in software development and does not require an explicit explanation in the commit message.",False,"The commit message 'change version to 2.7.6-SNAPSHOT to prepare for next major release' does not explicitly describe the necessity of the changes. It only mentions the version change and the preparation for the next major release, but it does not elaborate on any error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message 'change version to 2.7.6-SNAPSHOT to prepare for next major release' indicates that the developer is making changes to prepare for a future major release. This could be due to the need for software development to meet the requirements of users for new features or improvements. The changes in the code diff also support this interpretation, as the version number is being updated in multiple places in the project.",False,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only states that the version is being changed to prepare for the next major release. There is no mention of any specific changes, improvements, or defects being addressed in this commit.",True,"The commit message 'change version to 2.7.6-SNAPSHOT to prepare for next major release' accurately summarizes the changes made in the diff. It clearly states that the version number is being updated from 2.7.5-SNAPSHOT to 2.7.6-SNAPSHOT, which is also reflected in the diff. The message provides a clear description of the change, listing the key component that was modified, and contrasting the before and after versions.",False,"The commit message only mentions changing the version number from 2.7.5-SNAPSHOT to 2.7.6-SNAPSHOT to prepare for the next major release. It does not explicitly describe a technical principle underpinning the changes. The code diff shows that the version number is updated in multiple places in the project's configuration files, but it does not provide any insight into the technical principle or reason for this change.",True,"The commit message 'change version to 2.7.6-SNAPSHOT to prepare for next major release' accurately summarizes the changes made in the code diff. The message clearly states that a version change has been made, from 2.7.5-SNAPSHOT to 2.7.6-SNAPSHOT, and it also hints at the preparation for a future major release. The code diff supports this explanation by showing that the version number has been updated in multiple places within the project's configuration files.",False,"The commit message does not lack an explanation. It explicitly states the reason for the change: 'to prepare for next major release'. This is a significant change, not just a minor adjustment, and the commit message provides a clear explanation for it."
https://github.com/square/okhttp/commit/9b4e74f8c8ce6fff4281c2d7369fb25f6772a64e,"A Pipe.  <enter> This is something we need to implement HttpURLConnection atop the native OkHttp API. The application thread wants to be active, writing to its OutputStream. But in OkHttp's API, this work wants to happen in the RequestBody.writeTo() callback. To make this work we give the HttpUrlConnection OutputStream the sink end of the pipe, and the RequestBody the source end of the pipe. It's a bit of plumbing, but the benefit is that backpressure, timeouts, and failures will propagate as expected. ",https://api.github.com/repos/square/okhttp/commits/9b4e74f8c8ce6fff4281c2d7369fb25f6772a64e,"@@ -0,0 +1,403 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.Random;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.ByteString;
+import okio.HashingSink;
+import okio.Source;
+import org.junit.After;
+import org.junit.Test;
+
+import static junit.framework.TestCase.fail;
+import static org.junit.Assert.assertEquals;
+
+public final class PipeTest {
+  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);
+
+  @After public void tearDown() throws Exception {
+    executorService.shutdown();
+  }
+
+  @Test public void test() throws Exception {
+    Pipe pipe = new Pipe(6);
+    pipe.sink.write(new Buffer().writeUtf8(""abc""), 3L);
+
+    Source source = pipe.source;
+    Buffer readBuffer = new Buffer();
+    assertEquals(3L, source.read(readBuffer, 6L));
+    assertEquals(""abc"", readBuffer.readUtf8());
+
+    pipe.sink.close();
+    assertEquals(-1L, source.read(readBuffer, 6L));
+
+    source.close();
+  }
+
+  /**
+   * A producer writes the first 16 MiB of bytes generated by {@code new Random(0)} to a sink, and a
+   * consumer consumes them. Both compute hashes of their data to confirm that they're as expected.
+   */
+  @Test public void largeDataset() throws Exception {
+    final Pipe pipe = new Pipe(1000L); // An awkward size to force producer/consumer exchange.
+    final long totalBytes = 16L * 1024L * 1024L;
+    ByteString expectedHash = ByteString.decodeHex(""7c3b224bea749086babe079360cf29f98d88262d"");
+
+    // Write data to the sink.
+    Future<ByteString> sinkHash = executorService.submit(new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        HashingSink hashingSink = HashingSink.sha1(pipe.sink);
+        Random random = new Random(0);
+        byte[] data = new byte[8192];
+
+        Buffer buffer = new Buffer();
+        for (long i = 0L; i < totalBytes; i += data.length) {
+          random.nextBytes(data);
+          buffer.write(data);
+          hashingSink.write(buffer, buffer.size());
+        }
+
+        hashingSink.close();
+        return hashingSink.hash();
+      }
+    });
+
+    // Read data from the source.
+    Future<ByteString> sourceHash = executorService.submit(new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        Buffer blackhole = new Buffer();
+        HashingSink hashingSink = HashingSink.sha1(blackhole);
+
+        Buffer buffer = new Buffer();
+        while (pipe.source.read(buffer, Long.MAX_VALUE) != -1) {
+          hashingSink.write(buffer, buffer.size());
+          blackhole.clear();
+        }
+
+        pipe.source.close();
+        return hashingSink.hash();
+      }
+    });
+
+    assertEquals(expectedHash, sinkHash.get());
+    assertEquals(expectedHash, sourceHash.get());
+  }
+
+  @Test public void sinkTimeout() throws Exception {
+    Pipe pipe = new Pipe(3);
+    pipe.sink.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    pipe.sink.write(new Buffer().writeUtf8(""abc""), 3L);
+    double start = now();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8(""def""), 3L);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+
+    Buffer readBuffer = new Buffer();
+    assertEquals(3L, pipe.source.read(readBuffer, 6L));
+    assertEquals(""abc"", readBuffer.readUtf8());
+  }
+
+  @Test public void sourceTimeout() throws Exception {
+    Pipe pipe = new Pipe(3L);
+    pipe.source.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    double start = now();
+    Buffer readBuffer = new Buffer();
+    try {
+      pipe.source.read(readBuffer, 6L);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+    assertEquals(0, readBuffer.size());
+  }
+
+  /**
+   * The writer is writing 12 bytes as fast as it can to a 3 byte buffer. The reader alternates
+   * sleeping 250 ms, then reading 3 bytes. That should make for an approximate timeline like this:
+   *
+   * 0: writer writes 'abc', blocks 0: reader sleeps until 250 250: reader reads 'abc', sleeps until
+   * 500 250: writer writes 'def', blocks 500: reader reads 'def', sleeps until 750 500: writer
+   * writes 'ghi', blocks 750: reader reads 'ghi', sleeps until 1000 750: writer writes 'jkl',
+   * returns 1000: reader reads 'jkl', returns
+   *
+   * Because the writer is writing to a buffer, it finishes before the reader does.
+   */
+  @Test public void sinkBlocksOnSlowReader() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Buffer buffer = new Buffer();
+          Thread.sleep(250L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals(""abc"", buffer.readUtf8());
+          Thread.sleep(250L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals(""def"", buffer.readUtf8());
+          Thread.sleep(250L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals(""ghi"", buffer.readUtf8());
+          Thread.sleep(250L);
+          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
+          assertEquals(""jkl"", buffer.readUtf8());
+        } catch (IOException | InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8(""abcdefghijkl""), 12);
+    assertElapsed(750.0, start);
+  }
+
+  @Test public void sinkWriteFailsByClosedReader() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        try {
+          pipe.source.close();
+        } catch (IOException e) {
+          throw new AssertionError();
+        }
+      }
+    }, 250, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8(""abcdef""), 6);
+      fail();
+    } catch (IOException expected) {
+      assertEquals(""source is closed"", expected.getMessage());
+      assertElapsed(250.0, start);
+    }
+  }
+
+  @Test public void sinkFlushWaitsForReaderToReadEverything() throws Exception {
+    final Buffer readBuffer = new Buffer();
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(250);
+          pipe.source.read(readBuffer, 3);
+          Thread.sleep(250);
+          pipe.source.read(readBuffer, 3);
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8(""abcdef""), 6);
+    pipe.sink.flush();
+    assertElapsed(500.0, start);
+    assertEquals(""abcdef"", readBuffer.readUtf8());
+  }
+
+  @Test public void sinkFlushFailsIfReaderIsClosedBeforeAllDataIsRead() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(250);
+          pipe.source.read(new Buffer(), 3);
+          Thread.sleep(250);
+          pipe.source.close();
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8(""abcdef""), 6);
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals(""source is closed"", expected.getMessage());
+      assertElapsed(500.0, start);
+    }
+  }
+
+  @Test public void sinkCloseFailsIfReaderIsClosedBeforeAllDataIsRead() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(250);
+          pipe.source.read(new Buffer(), 3);
+          Thread.sleep(250);
+          pipe.source.close();
+        } catch (InterruptedException | IOException e) {
+          throw new AssertionError(e);
+        }
+      }
+    });
+
+    double start = now();
+    pipe.sink.write(new Buffer().writeUtf8(""abcdef""), 6);
+    try {
+      pipe.sink.close();
+      fail();
+    } catch (IOException expected) {
+      assertEquals(""source is closed"", expected.getMessage());
+      assertElapsed(500.0, start);
+    }
+
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals(""closed"", expected.getMessage());
+    }
+  }
+
+  @Test public void sinkClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.sink.close();
+    try {
+      pipe.sink.write(new Buffer().writeUtf8(""abc""), 3);
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals(""closed"", expected.getMessage());
+    }
+    try {
+      pipe.sink.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals(""closed"", expected.getMessage());
+    }
+  }
+
+  @Test public void sinkMultipleClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.sink.close();
+    pipe.sink.close();
+  }
+
+  @Test public void sourceClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.source.close();
+    try {
+      pipe.source.read(new Buffer(), 3);
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals(""closed"", expected.getMessage());
+    }
+  }
+
+  @Test public void sourceMultipleClose() throws Exception {
+    Pipe pipe = new Pipe(100L);
+    pipe.source.close();
+    pipe.source.close();
+  }
+
+  @Test public void sourceReadUnblockedByClosedSink() throws Exception {
+    final Pipe pipe = new Pipe(3L);
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        try {
+          pipe.sink.close();
+        } catch (IOException e) {
+          throw new AssertionError();
+        }
+      }
+    }, 250, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    Buffer readBuffer = new Buffer();
+    assertEquals(-1, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(0, readBuffer.size());
+    assertElapsed(250.0, start);
+  }
+
+  /**
+   * The writer has 12 bytes to write. It alternates sleeping 250 ms, then writing 3 bytes. The
+   * reader is reading as fast as it can. That should make for an approximate timeline like this:
+   *
+   * 0: writer sleeps until 250 0: reader blocks 250: writer writes 'abc', sleeps until 500 250:
+   * reader reads 'abc' 500: writer writes 'def', sleeps until 750 500: reader reads 'def' 750:
+   * writer writes 'ghi', sleeps until 1000 750: reader reads 'ghi' 1000: writer writes 'jkl',
+   * returns 1000: reader reads 'jkl', returns
+   */
+  @Test public void sourceBlocksOnSlowWriter() throws Exception {
+    final Pipe pipe = new Pipe(100L);
+    executorService.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(250L);
+          pipe.sink.write(new Buffer().writeUtf8(""abc""), 3);
+          Thread.sleep(250L);
+          pipe.sink.write(new Buffer().writeUtf8(""def""), 3);
+          Thread.sleep(250L);
+          pipe.sink.write(new Buffer().writeUtf8(""ghi""), 3);
+          Thread.sleep(250L);
+          pipe.sink.write(new Buffer().writeUtf8(""jkl""), 3);
+        } catch (IOException | InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    double start = now();
+    Buffer readBuffer = new Buffer();
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(""abc"", readBuffer.readUtf8());
+    assertElapsed(250.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(""def"", readBuffer.readUtf8());
+    assertElapsed(500.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(""ghi"", readBuffer.readUtf8());
+    assertElapsed(750.0, start);
+
+    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
+    assertEquals(""jkl"", readBuffer.readUtf8());
+    assertElapsed(1000.0, start);
+  }
+
+  /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
+  private double now() {
+    return System.nanoTime() / 1000000.0d;
+  }
+
+  /**
+   * Fails the test unless the time from start until now is duration, accepting differences in
+   * -50..+150 milliseconds.
+   */
+  private void assertElapsed(double duration, double start) {
+    assertEquals(duration, now() - start + 50d, 100.0);
+  }
+}
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.InterruptedIOException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import okio.Timeout;
+import org.junit.After;
+import org.junit.Test;
+
+import static junit.framework.TestCase.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public final class WaitUntilNotifiedTest {
+  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(0);
+
+  @After public void tearDown() throws Exception {
+    executorService.shutdown();
+  }
+
+  @Test public synchronized void notified() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(5000, TimeUnit.MILLISECONDS);
+
+    double start = now();
+    executorService.schedule(new Runnable() {
+      @Override public void run() {
+        synchronized (WaitUntilNotifiedTest.this) {
+          WaitUntilNotifiedTest.this.notify();
+        }
+      }
+    }, 250, TimeUnit.MILLISECONDS);
+
+    Pipe.waitUntilNotified(this, timeout);
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void timeout() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(250, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void deadline() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.deadline(250, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void deadlineBeforeTimeout() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(5000, TimeUnit.MILLISECONDS);
+    timeout.deadline(250, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void timeoutBeforeDeadline() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.timeout(250, TimeUnit.MILLISECONDS);
+    timeout.deadline(5000, TimeUnit.MILLISECONDS);
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(250.0, start);
+  }
+
+  @Test public synchronized void deadlineAlreadyReached() throws Exception {
+    Timeout timeout = new Timeout();
+    timeout.deadlineNanoTime(System.nanoTime());
+    double start = now();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""timeout"", expected.getMessage());
+    }
+    assertElapsed(0.0, start);
+  }
+
+  @Test public synchronized void threadInterrupted() throws Exception {
+    Timeout timeout = new Timeout();
+    double start = now();
+    Thread.currentThread().interrupt();
+    try {
+      Pipe.waitUntilNotified(this, timeout);
+      fail();
+    } catch (InterruptedIOException expected) {
+      assertEquals(""interrupted"", expected.getMessage());
+      assertFalse(Thread.interrupted());
+    }
+    assertElapsed(0.0, start);
+  }
+
+  /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
+  private double now() {
+    return System.nanoTime() / 1000000.0d;
+  }
+
+  /**
+   * Fails the test unless the time from start until now is duration, accepting differences in
+   * -50..+150 milliseconds.
+   */
+  private void assertElapsed(double duration, double start) {
+    assertEquals(duration, now() - start + 50d, 100.0);
+  }
+}
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import okio.Buffer;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+/**
+ * A source and a sink that are attached. The sink's output is the source's input. Typically each
+ * is accessed by its own thread: a producer thread writes data to the sink and a consumer thread
+ * reads data from the source.
+ *
+ * <p>This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum
+ * size. When a producer thread outruns its consumer the buffer fills up and eventually writes to
+ * the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its
+ * producer reads block until there is data to be read. Limits on the amount of time spent waiting
+ * for the other party can be configured with {@linkplain Timeout timeouts} on the source and the
+ * sink.
+ *
+ * <p>When the sink is closed, source reads will continue to complete normally until the buffer has
+ * been exhausted. At that point reads will return -1, indicating the end of the stream. But if the
+ * source is closed first, writes to the sink will immediately fail with an {@link IOException}.
+ */
+public final class Pipe {
+  final long maxBufferSize;
+  final Buffer buffer = new Buffer();
+  boolean sinkClosed;
+  boolean sourceClosed;
+  public final Sink sink = new PipeSink();
+  public final Source source = new PipeSource();
+
+  public Pipe(long maxBufferSize) {
+    if (maxBufferSize < 1L) {
+      throw new IllegalArgumentException(""maxBufferSize < 1: "" + maxBufferSize);
+    }
+    this.maxBufferSize = maxBufferSize;
+  }
+
+  final class PipeSink implements Sink {
+    final Timeout timeout = new Timeout();
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) throw new IllegalStateException(""closed"");
+
+        while (byteCount > 0) {
+          if (sourceClosed) throw new IOException(""source is closed"");
+
+          long bufferSpaceAvailable = maxBufferSize - buffer.size();
+          if (bufferSpaceAvailable == 0) {
+            waitUntilNotified(buffer, timeout); // Wait until the source drains the buffer.
+            continue;
+          }
+
+          long bytesToWrite = Math.min(bufferSpaceAvailable, byteCount);
+          buffer.write(source, bytesToWrite);
+          byteCount -= bytesToWrite;
+          buffer.notifyAll(); // Notify the source that it can resume reading.
+        }
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) throw new IllegalStateException(""closed"");
+
+        while (buffer.size() > 0) {
+          if (sourceClosed) throw new IOException(""source is closed"");
+          waitUntilNotified(buffer, timeout);
+        }
+      }
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (buffer) {
+        if (sinkClosed) return;
+        try {
+          flush();
+        } finally {
+          sinkClosed = true;
+          buffer.notifyAll(); // Notify the source that no more bytes are coming.
+        }
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+  }
+
+  final class PipeSource implements Source {
+    final Timeout timeout = new Timeout();
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      synchronized (buffer) {
+        if (sourceClosed) throw new IllegalStateException(""closed"");
+
+        while (buffer.size() == 0) {
+          if (sinkClosed) return -1L;
+          waitUntilNotified(buffer, timeout); // Wait until the sink fills the buffer.
+        }
+
+        long result = buffer.read(sink, byteCount);
+        buffer.notifyAll(); // Notify the sink that it can resume writing.
+        return result;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (buffer) {
+        sourceClosed = true;
+        buffer.notifyAll(); // Notify the sink that no more bytes are desired.
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+  }
+
+  /**
+   * Waits on {@code monitor} until it is notified. Throws {@link InterruptedIOException} if either
+   * the thread is interrupted or if {@code timeout} elapses before {@code monitor} is notified. The
+   * caller must be synchronized on {@code monitor}.
+   */
+  static void waitUntilNotified(Object monitor, Timeout timeout) throws IOException {
+    try {
+      boolean hasDeadline = timeout.hasDeadline();
+      long timeoutNanos = timeout.timeoutNanos();
+
+      if (!hasDeadline && timeoutNanos == 0L) {
+        monitor.wait(); // There is no timeout: wait forever.
+        return;
+      }
+
+      // Compute how long we'll wait.
+      long waitNanos;
+      long start = System.nanoTime();
+      if (hasDeadline && timeoutNanos != 0) {
+        long deadlineNanos = timeout.deadlineNanoTime() - start;
+        waitNanos = Math.min(timeoutNanos, deadlineNanos);
+      } else if (hasDeadline) {
+        waitNanos = timeout.deadlineNanoTime() - start;
+      } else {
+        waitNanos = timeoutNanos;
+      }
+
+      // Attempt to wait that long. This will break out early if the monitor is notified.
+      long elapsedNanos = 0L;
+      if (waitNanos > 0L) {
+        long waitMillis = waitNanos / 1000000L;
+        monitor.wait(waitMillis, (int) (waitNanos - waitMillis * 1000000L));
+        elapsedNanos = System.nanoTime() - start;
+      }
+
+      // Throw if the timeout elapsed before the monitor was notified.
+      if (elapsedNanos >= waitNanos) {
+        throw new InterruptedIOException(""timeout"");
+      }
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException(""interrupted"");
+    }
+  }
+}
+
",True,"The commit message refers to the necessity of changes by mentioning that the application thread wants to be active, writing to its OutputStream, but in OkHttp's API, this work wants to happen in the RequestBody.writeTo() callback. To make this work, the commit introduces a Pipe, which is a bit of plumbing, but the benefit is that backpressure, timeouts, and failures will propagate as expected.",True,"The commit message does not explicitly state the reason for the changes, but it is clear from the code diff that the changes are being made to implement HttpURLConnection atop the native OkHttp API. This is a significant change that requires modifying the codebase to accommodate the new functionality. The commit message provides a brief explanation of the changes, which is sufficient to understand the necessity of the modifications.",True,"The commit message explains the necessity of the changes by mentioning that the application thread wants to write to its OutputStream, but in OkHttp's API, this work wants to happen in the RequestBody.writeTo() callback. To make this work, the commit message explains that a pipe is being implemented to give the HttpUrlConnection OutputStream the sink end of the pipe, and the RequestBody the source end of the pipe. This is done to allow backpressure, timeouts, and failures to propagate as expected.",True,"The commit message indicates that the developer is implementing HttpURLConnection atop the native OkHttp API. This is done to meet the requirement of the application thread wanting to be active and write to its OutputStream, which is not possible in OkHttp's API. The change is made to accommodate this requirement, which is a clear expression of the necessity for the changes.",True,"The commit message directly mentions the objective of the change by stating that it is implementing HttpURLConnection atop the native OkHttp API. This is done to allow the application thread to write to its OutputStream while the OkHttp API wants the work to happen in the RequestBody.writeTo() callback. The message explains how this is achieved by using a pipe to connect the HttpURLConnection OutputStream with the RequestBody. This change is intended to enable backpressure, timeouts, and failures to propagate as expected.",True,"The commit message describes the implementation of a Pipe class that allows data to be written to a sink and read from a source. It mentions the use of a buffer to decouple the source and sink, and it highlights the benefits of backpressure, timeouts, and failure propagation. This accurately summarizes the changes made in the code diff.",True,"The commit message explains that the changes are made to implement HttpURLConnection atop the native OkHttp API. The application thread wants to write to its OutputStream, but in OkHttp's API, this work wants to happen in the RequestBody.writeTo() callback. To make this work, they give the HttpUrlConnection OutputStream the sink end of the pipe, and the RequestBody the source end of the pipe. This is done to enable backpressure, timeouts, and failures to propagate as expected, which is a technical principle underpinning the changes.",True,"The commit message describes the implementation of a new class called 'Pipe' which is a combination of a source and a sink. It explains that this class is used to implement HttpURLConnection atop the native OkHttp API. The message explains that the application thread wants to write to its OutputStream, but in OkHttp's API, this work wants to happen in the RequestBody.writeTo() callback. To make this work, the HttpUrlConnection OutputStream is given the sink end of the pipe, and the RequestBody is given the source end of the pipe. This allows for backpressure, timeouts, and failures to propagate as expected.",False,"The commit message does not lack an explanation. It clearly explains the reason for the commit, which is to implement HttpURLConnection atop the native OkHttp API. The change is not trivial and involves creating a new Pipe class and modifying existing classes to use it. The commit message provides a good explanation of the problem and the solution, making it clear why the change was necessary and how it was implemented."
https://github.com/apache/dubbo/commit/b4afeb982b943ca8c6bbd261302a9e161c2e98a9,"follow up for pr#4339, remove the space ( <pr_link> ) ",https://api.github.com/repos/apache/dubbo/commits/b4afeb982b943ca8c6bbd261302a9e161c2e98a9,"@@ -31,56 +31,56 @@
  * Code generator for Adaptive class
  */
 public class AdaptiveClassCodeGenerator {
-    
+
     private static final Logger logger = LoggerFactory.getLogger(AdaptiveClassCodeGenerator.class);
 
     private static final String CLASSNAME_INVOCATION = ""org.apache.dubbo.rpc.Invocation"";
-    
+
     private static final String CODE_PACKAGE = ""package %s;\n"";
-    
+
     private static final String CODE_IMPORTS = ""import %s;\n"";
-    
+
     private static final String CODE_CLASS_DECLARATION = ""public class %s$Adaptive implements %s {\n"";
-    
+
     private static final String CODE_METHOD_DECLARATION = ""public %s %s(%s) %s {\n%s}\n"";
-    
+
     private static final String CODE_METHOD_ARGUMENT = ""%s arg%d"";
-    
+
     private static final String CODE_METHOD_THROWS = ""throws %s"";
-    
+
     private static final String CODE_UNSUPPORTED = ""throw new UnsupportedOperationException(\""The method %s of interface %s is not adaptive method!\"");\n"";
-    
+
     private static final String CODE_URL_NULL_CHECK = ""if (arg%d == null) throw new IllegalArgumentException(\""url == null\"");\n%s url = arg%d;\n"";
-    
+
     private static final String CODE_EXT_NAME_ASSIGNMENT = ""String extName = %s;\n"";
-    
+
     private static final String CODE_EXT_NAME_NULL_CHECK = ""if(extName == null) ""
                     + ""throw new IllegalStateException(\""Failed to get extension (%s) name from url (\"" + url.toString() + \"") use keys(%s)\"");\n"";
-    
+
     private static final String CODE_INVOCATION_ARGUMENT_NULL_CHECK = ""if (arg%d == null) throw new IllegalArgumentException(\""invocation == null\""); ""
                     + ""String methodName = arg%d.getMethodName();\n"";
-    
-    
+
+
     private static final String CODE_EXTENSION_ASSIGNMENT = ""%s extension = (%<s)%s.getExtensionLoader(%s.class).getExtension(extName);\n"";
 
-    private static final String CODE_EXTENSION_METHOD_INVOKE_ARGUMENT = ""arg%d "";
+    private static final String CODE_EXTENSION_METHOD_INVOKE_ARGUMENT = ""arg%d"";
 
     private final Class<?> type;
-    
+
     private String defaultExtName;
-    
+
     public AdaptiveClassCodeGenerator(Class<?> type, String defaultExtName) {
         this.type = type;
         this.defaultExtName = defaultExtName;
     }
-    
+
     /**
      * test if given type has at least one method annotated with <code>SPI</code>
      */
     private boolean hasAdaptiveMethod() {
         return Arrays.stream(type.getMethods()).anyMatch(m -> m.isAnnotationPresent(Adaptive.class));
     }
-    
+
     /**
      * generate and return class code
      */
@@ -94,13 +94,13 @@ public String generate() {
         code.append(generatePackageInfo());
         code.append(generateImports());
         code.append(generateClassDeclaration());
-        
+
         Method[] methods = type.getMethods();
         for (Method method : methods) {
             code.append(generateMethod(method));
         }
         code.append(""}"");
-        
+
         if (logger.isDebugEnabled()) {
             logger.debug(code.toString());
         }
@@ -127,18 +127,18 @@ private String generateImports() {
     private String generateClassDeclaration() {
         return String.format(CODE_CLASS_DECLARATION, type.getSimpleName(), type.getCanonicalName());
     }
-    
+
     /**
-     * generate method not annotated with Adaptive with throwing unsupported exception 
+     * generate method not annotated with Adaptive with throwing unsupported exception
      */
     private String generateUnsupported(Method method) {
         return String.format(CODE_UNSUPPORTED, method, type.getName());
     }
-    
+
     /**
      * get index of parameter with type URL
      */
-    private int getUrlTypeIndex(Method method) {            
+    private int getUrlTypeIndex(Method method) {
         int urlTypeIndex = -1;
         Class<?>[] pts = method.getParameterTypes();
         for (int i = 0; i < pts.length; ++i) {
@@ -149,7 +149,7 @@ private int getUrlTypeIndex(Method method) {
         }
         return urlTypeIndex;
     }
-    
+
     /**
      * generate method declaration
      */
@@ -171,9 +171,9 @@ private String generateMethodArguments(Method method) {
                         .mapToObj(i -> String.format(CODE_METHOD_ARGUMENT, pts[i].getCanonicalName(), i))
                         .collect(Collectors.joining("", ""));
     }
-    
+
     /**
-     * generate method throws 
+     * generate method throws
      */
     private String generateMethodThrows(Method method) {
         Class<?>[] ets = method.getExceptionTypes();
@@ -184,14 +184,14 @@ private String generateMethodThrows(Method method) {
             return """";
         }
     }
-    
+
     /**
-     * generate method URL argument null check 
+     * generate method URL argument null check
      */
     private String generateUrlNullCheck(int index) {
         return String.format(CODE_URL_NULL_CHECK, index, URL.class.getName(), index);
     }
-    
+
     /**
      * generate method content
      */
@@ -202,7 +202,7 @@ private String generateMethodContent(Method method) {
             return generateUnsupported(method);
         } else {
             int urlTypeIndex = getUrlTypeIndex(method);
-            
+
             // found parameter in URL type
             if (urlTypeIndex != -1) {
                 // Null Point check
@@ -215,19 +215,19 @@ private String generateMethodContent(Method method) {
             String[] value = getMethodAdaptiveValue(adaptiveAnnotation);
 
             boolean hasInvocation = hasInvocationArgument(method);
-            
+
             code.append(generateInvocationArgumentNullCheck(method));
-            
+
             code.append(generateExtNameAssignment(value, hasInvocation));
             // check extName == null?
             code.append(generateExtNameNullCheck(value));
-            
+
             code.append(generateExtensionAssignment());
 
             // return statement
             code.append(generateReturnAndInvocation(method));
         }
-        
+
         return code.toString();
     }
 
@@ -279,7 +279,7 @@ private String generateExtNameAssignment(String[] value, boolean hasInvocation)
                 }
             }
         }
-        
+
         return String.format(CODE_EXT_NAME_ASSIGNMENT, getNameCode);
     }
 
@@ -302,15 +302,15 @@ private String generateReturnAndInvocation(Method method) {
 
         return returnStatement + String.format(""extension.%s(%s);\n"", method.getName(), args);
     }
-    
+
     /**
      * test if method has argument of type <code>Invocation</code>
      */
     private boolean hasInvocationArgument(Method method) {
         Class<?>[] pts = method.getParameterTypes();
         return Arrays.stream(pts).anyMatch(p -> CLASSNAME_INVOCATION.equals(p.getName()));
     }
-    
+
     /**
      * generate code to test argument of type <code>Invocation</code> is null
      */
@@ -343,7 +343,7 @@ private String[] getMethodAdaptiveValue(Adaptive adaptiveAnnotation) {
      */
     private String generateUrlAssignmentIndirectly(Method method) {
         Class<?>[] pts = method.getParameterTypes();
-        
+
         // find URL getter method
         for (int i = 0; i < pts.length; ++i) {
             for (Method m : pts[i].getMethods()) {
@@ -357,7 +357,7 @@ private String generateUrlAssignmentIndirectly(Method method) {
                 }
             }
         }
-        
+
         // getter method not found, throw
         throw new IllegalStateException(""Failed to create adaptive class for interface "" + type.getName()
                         + "": not found url parameter or url attribute in parameters of method "" + method.getName());
@@ -380,5 +380,5 @@ private String generateGetUrlNullCheck(int index, Class<?> type, String method)
         code.append(String.format(""%s url = arg%d.%s();\n"", URL.class.getName(), index, method));
         return code.toString();
     }
-    
+
 }
",True,"The commit message refers to a previous pull request (pr#4339) and mentions the removal of a space. While the exact reason for this removal is not explicitly stated in the message, it can be inferred from the code diff that the space removal is likely related to code formatting or consistency, as the removed spaces are around empty lines in the code. This suggests that the commit message is describing the necessity of changes by referencing a convention or standard, in this case, the formatting and consistency of the code.",True,"The commit message 'follow up for pr#4339, remove the space ( <pr_link> )' does not explicitly describe the necessity of the changes. However, the changes made in the code diff are typographic fixes, specifically removing unnecessary spaces. This is a common practice to improve code readability and consistency, and it is easy to infer that these changes are necessary without a detailed explanation in the commit message.",True,"The commit message 'follow up for pr#4339, remove the space ( <pr_link> )' directly references the pull request (pr#4339) and implies that the changes are made to address the issues or enhancements discussed in that pull request. This indicates that the commit message elaborates the motivation of the code change by referring to a specific issue report.",True,"The commit message 'follow up for pr#4339, remove the space ( <pr_link> )' does not explicitly describe the necessity of changes. However, the code diff suggests that the changes are likely related to software maintenance, specifically the removal of unnecessary spaces in the code. This could be done to improve readability, maintain consistency, or to comply with coding standards. Therefore, the commit message could be interpreted as indicating a need for maintenance to improve the codebase.",True,"The commit message 'follow up for pr#4339, remove the space ( <pr_link> )' does not directly mention the defects it fixes or the improvements it makes to the code. However, the code diff suggests that the change is likely related to code formatting or style, as it only involves removing unnecessary blank lines. While this does not explicitly describe a functional improvement or defect fix, it could potentially improve code readability and maintainability. Therefore, the answer is technically 'false' as the commit message does not directly mention the improvements or defects, but the context and the code diff suggest that the change might have been made for code clarity.",True,The commit message ,True,"The commit message does not explicitly state the technical principle underpinning the changes, but the code diff suggests that the changes are related to the generation of adaptive classes. The technical principle here is likely the use of the Adaptive pattern, which allows a system to choose the appropriate algorithm or behavior at runtime based on the context or input. This is evident in the code diff where methods are being generated based on the presence or absence of the @Adaptive annotation.",True,"The commit message 'follow up for pr#4339, remove the space ( <pr_link> )' does not directly describe the code changes. However, the code diff provided shows modifications to the AdaptiveClassCodeGenerator class, which generates code for an adaptive class. These changes do not introduce new behaviors or functionalities, but rather they are refactoring or formatting changes. The message does not explicitly describe these changes, but it can be inferred from the context that the changes are likely related to code generation and adaptation.",True,"The commit message removed a space, which is a minor change that doesn't require an explanation. The code diff also doesn't indicate any significant changes that would necessitate an explanation in the commit message."
https://github.com/square/okhttp/commit/dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3,"Move connection pooling logic.  <enter> Previously we had this ugly, awkward release() method that attempted to manage connection pooling, discarding streams for caching, and closing broken streams. <enter> Move connection reuse to HttpConnection, with policy informed by HttpEngine. It specifies what to do when the connection becomes idle: pool, close or hold. The connection does what it's told. ",https://api.github.com/repos/square/okhttp/commits/dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3,"@@ -65,7 +65,7 @@
  * should the attempt fail.
  */
 public final class Connection implements Closeable {
-
+  private final ConnectionPool pool;
   private final Route route;
 
   private Socket socket;
@@ -78,7 +78,8 @@ public final class Connection implements Closeable {
   private long idleStartTimeNs;
   private Handshake handshake;
 
-  public Connection(Route route) {
+  public Connection(ConnectionPool pool, Route route) {
+    this.pool = pool;
     this.route = route;
   }
 
@@ -96,7 +97,7 @@ public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelReq
       upgradeToTls(tunnelRequest);
     } else {
       streamWrapper();
-      httpConnection = new HttpConnection(in, out);
+      httpConnection = new HttpConnection(pool, this, in, out);
     }
     connected = true;
   }
@@ -164,7 +165,7 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
           .protocol(selectedProtocol).build();
       spdyConnection.sendConnectionHeader();
     } else {
-      httpConnection = new HttpConnection(in, out);
+      httpConnection = new HttpConnection(pool, this, in, out);
     }
   }
 
@@ -306,7 +307,7 @@ public void updateReadTimeout(int newTimeout) throws IOException {
    * retried if the proxy requires authorization.
    */
   private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(in, out);
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, in, out);
     Request request = tunnelRequest.getRequest();
     String requestLine = tunnelRequest.requestLine();
     while (true) {
@@ -244,12 +244,9 @@ public void recycle(Connection connection) {
    * Shares the SPDY connection with the pool. Callers to this method may
    * continue to use {@code connection}.
    */
-  public void maybeShare(Connection connection) {
+  public void share(Connection connection) {
+    if (!connection.isSpdy()) throw new IllegalArgumentException();
     executorService.execute(connectionsCleanupRunnable);
-    if (!connection.isSpdy()) {
-      // Only SPDY connections are sharable.
-      return;
-    }
     if (connection.isAlive()) {
       synchronized (this) {
         connections.addFirst(connection);
@@ -80,7 +80,7 @@ Object tag() {
           .exception(e)
           .build());
     } finally {
-      engine.release(true); // Release the connection if it isn't already released.
+      engine.close(); // Close the connection if it isn't already.
       dispatcher.finished(this);
     }
   }
@@ -142,19 +142,18 @@ private Response getResponse() throws IOException {
       Request redirect = processResponse(engine, response);
 
       if (redirect == null) {
-        engine.automaticallyReleaseConnectionToPool();
+        engine.releaseConnection();
         return response.newBuilder()
             .body(new RealResponseBody(response, engine.getResponseBody()))
             .redirectedBy(redirectedBy)
             .build();
       }
 
       if (!sameConnection(request, redirect)) {
-        engine.automaticallyReleaseConnectionToPool();
+        engine.releaseConnection();
       }
 
-      engine.release(false);
-      Connection connection = engine.getConnection();
+      Connection connection = engine.close();
       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
       request = redirect;
       engine = new HttpEngine(client, request, false, connection, null, null);
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Response;
@@ -61,16 +62,59 @@ public final class HttpConnection {
   private static final int STATE_READING_RESPONSE_BODY = 5;
   private static final int STATE_CLOSED = 6;
 
+  private static final int ON_IDLE_HOLD = 0;
+  private static final int ON_IDLE_POOL = 1;
+  private static final int ON_IDLE_CLOSE = 2;
+
+  private final ConnectionPool pool;
+  private final Connection connection;
   private final InputStream in;
   private final OutputStream out;
 
   private int state = STATE_IDLE;
+  private int onIdle = ON_IDLE_HOLD;
 
-  public HttpConnection(InputStream in, OutputStream out) {
+  public HttpConnection(ConnectionPool pool, Connection connection, InputStream in,
+      OutputStream out) {
+    this.pool = pool;
+    this.connection = connection;
     this.in = in;
     this.out = out;
   }
 
+  /**
+   * Configure this connection to put itself back into the connection pool when
+   * the HTTP response body is exhausted.
+   */
+  public void poolOnIdle() {
+    onIdle = ON_IDLE_POOL;
+
+    // If we're already idle, go to the pool immediately.
+    if (state == STATE_IDLE) {
+      onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+      pool.recycle(connection);
+    }
+  }
+
+  /**
+   * Configure this connection to close itself when the HTTP response body is
+   * exhausted.
+   */
+  public void closeOnIdle() throws IOException {
+    onIdle = ON_IDLE_CLOSE;
+
+    // If we're already idle, close immediately.
+    if (state == STATE_IDLE) {
+      state = STATE_CLOSED;
+      connection.close();
+    }
+  }
+
+  /** Returns true if this connection is closed. */
+  public boolean isClosed() {
+    return state == STATE_CLOSED;
+  }
+
   public void flush() throws IOException {
     out.flush();
   }
@@ -126,11 +170,8 @@ public Response.Builder readResponse() throws IOException {
    * cannot be cached unless it is consumed completely) or to enable connection
    * reuse.
    */
-  private static boolean discardStream(HttpEngine httpEngine, InputStream responseBodyIn) {
-    Connection connection = httpEngine.getConnection();
-    if (connection == null) return false;
+  public boolean discard(InputStream responseBodyIn) {
     Socket socket = connection.getSocket();
-    if (socket == null) return false;
     try {
       int socketTimeout = socket.getSoTimeout();
       socket.setSoTimeout(Transport.DISCARD_STREAM_TIMEOUT_MILLIS);
@@ -163,38 +204,33 @@ public void writeRequestBody(RetryableOutputStream requestBody) throws IOExcepti
     requestBody.writeToSocket(out);
   }
 
-  public InputStream newFixedLengthInputStream(
-      CacheRequest cacheRequest, HttpEngine httpEngine, long length) throws IOException {
+  public InputStream newFixedLengthInputStream(CacheRequest cacheRequest, long length)
+      throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthInputStream(in, cacheRequest, httpEngine, length);
+    return new FixedLengthInputStream(cacheRequest, length);
   }
 
   /**
    * Call this to advance past a response body for HTTP responses that do not
    * have a response body.
    */
-  public void emptyResponseBody() {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
-    state = STATE_IDLE;
+  public void emptyResponseBody() throws IOException {
+    newFixedLengthInputStream(null, 0L); // Transition to STATE_IDLE.
   }
 
   public InputStream newChunkedInputStream(
       CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedInputStream(in, cacheRequest, httpEngine);
+    return new ChunkedInputStream(cacheRequest, httpEngine);
   }
 
   public InputStream newUnknownLengthInputStream(CacheRequest cacheRequest, HttpEngine httpEngine)
       throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new UnknownLengthHttpInputStream(in, cacheRequest, httpEngine);
-  }
-
-  public boolean discard(HttpEngine httpEngine, InputStream responseBodyIn) {
-    return discardStream(httpEngine, responseBodyIn);
+    return new UnknownLengthHttpInputStream(cacheRequest);
   }
 
   /** An HTTP body with a fixed length known in advance. */
@@ -347,17 +383,11 @@ private void writeBufferedChunkToSocket() throws IOException {
   }
 
   private class AbstractHttpInputStream extends InputStream {
-    protected final InputStream in;
-    protected final HttpEngine httpEngine;
     private final CacheRequest cacheRequest;
     protected final OutputStream cacheBody;
     protected boolean closed;
 
-    AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest)
-        throws IOException {
-      this.in = in;
-      this.httpEngine = httpEngine;
-
+    AbstractHttpInputStream(CacheRequest cacheRequest) throws IOException {
       OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
 
       // Some apps return a null body; for compatibility we treat that like a null cache request.
@@ -378,9 +408,7 @@ private class AbstractHttpInputStream extends InputStream {
     }
 
     protected final void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException(""stream closed"");
-      }
+      if (closed) throw new IOException(""stream closed"");
     }
 
     protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOException {
@@ -395,11 +423,19 @@ protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOE
      */
     protected final void endOfInput() throws IOException {
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
+
       if (cacheRequest != null) {
         cacheBody.close();
       }
-      httpEngine.release(false);
+
       state = STATE_IDLE;
+      if (onIdle == ON_IDLE_POOL) {
+        onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+        pool.recycle(connection);
+      } else if (onIdle == ON_IDLE_CLOSE) {
+        state = STATE_CLOSED;
+        connection.close();
+      }
     }
 
     /**
@@ -418,7 +454,7 @@ protected final void unexpectedEndOfInput() {
       if (cacheRequest != null) {
         cacheRequest.abort();
       }
-      httpEngine.release(true);
+      Util.closeQuietly(connection);
       state = STATE_CLOSED;
     }
   }
@@ -427,9 +463,8 @@ protected final void unexpectedEndOfInput() {
   private class FixedLengthInputStream extends AbstractHttpInputStream {
     private long bytesRemaining;
 
-    public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine,
-        long length) throws IOException {
-      super(is, httpEngine, cacheRequest);
+    public FixedLengthInputStream(CacheRequest cacheRequest, long length) throws IOException {
+      super(cacheRequest);
       bytesRemaining = length;
       if (bytesRemaining == 0) {
         endOfInput();
@@ -464,7 +499,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
       if (closed) {
         return;
       }
-      if (bytesRemaining != 0 && !discardStream(httpEngine, this)) {
+      if (bytesRemaining != 0 && !discard(this)) {
         unexpectedEndOfInput();
       }
       closed = true;
@@ -476,10 +511,11 @@ private class ChunkedInputStream extends AbstractHttpInputStream {
     private static final int NO_CHUNK_YET = -1;
     private int bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
+    private final HttpEngine httpEngine;
 
-    ChunkedInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine)
-        throws IOException {
-      super(is, httpEngine, cacheRequest);
+    ChunkedInputStream(CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
+      super(cacheRequest);
+      this.httpEngine = httpEngine;
     }
 
     @Override public int read(byte[] buffer, int offset, int count) throws IOException {
@@ -541,7 +577,7 @@ private void readChunkSize() throws IOException {
       if (closed) {
         return;
       }
-      if (hasMoreChunks && !discardStream(httpEngine, this)) {
+      if (hasMoreChunks && !discard(this)) {
         unexpectedEndOfInput();
       }
       closed = true;
@@ -552,9 +588,8 @@ private void readChunkSize() throws IOException {
   class UnknownLengthHttpInputStream extends AbstractHttpInputStream {
     private boolean inputExhausted;
 
-    UnknownLengthHttpInputStream(InputStream in, CacheRequest cacheRequest, HttpEngine httpEngine)
-        throws IOException {
-      super(in, httpEngine, cacheRequest);
+    UnknownLengthHttpInputStream(CacheRequest cacheRequest) throws IOException {
+      super(cacheRequest);
     }
 
     @Override public int read(byte[] buffer, int offset, int count) throws IOException {
@@ -68,11 +68,6 @@
  *
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
- *
- * <p>This class may hold a socket connection that needs to be released or
- * recycled. By default, this socket connection is held when the last byte of
- * the response is consumed. To release the connection when it is no longer
- * required, use {@link #automaticallyReleaseConnectionToPool()}.
  */
 public class HttpEngine {
   final OkHttpClient client;
@@ -121,15 +116,6 @@ public class HttpEngine {
   /** The cache request currently being populated from a network response. */
   private CacheRequest cacheRequest;
 
-  /**
-   * True if the socket connection should be released to the connection pool
-   * when the response has been fully read.
-   */
-  private boolean automaticallyReleaseConnectionToPool;
-
-  /** True if the socket connection is no longer needed by this engine. */
-  private boolean connectionReleased;
-
   /**
    * @param request the HTTP request without a body. The body must be
    *     written via the engine's request body stream.
@@ -199,9 +185,10 @@ public final void sendRequest() throws IOException {
       }
 
     } else {
-      // We're using a cached response. Close the connection we may have inherited from a redirect.
+      // We're using a cached response. Recycle a connection we may have inherited from a redirect.
       if (connection != null) {
-        disconnect();
+        client.getConnectionPool().recycle(connection);
+        connection = null;
       }
 
       // No need for the network! Promote the cached response immediately.
@@ -243,7 +230,7 @@ private void connect() throws IOException {
 
     if (!connection.isConnected()) {
       connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig());
-      client.getConnectionPool().maybeShare(connection);
+      if (connection.isSpdy()) client.getConnectionPool().share(connection);
       client.getRoutesDatabase().connected(connection.getRoute());
     } else if (!connection.isSpdy()) {
       connection.updateReadTimeout(client.getReadTimeout());
@@ -252,15 +239,6 @@ private void connect() throws IOException {
     route = connection.getRoute();
   }
 
-  /**
-   * Recycle the connection to the origin server. It is an error to call this
-   * with a request in flight.
-   */
-  private void disconnect() {
-    client.getConnectionPool().recycle(connection);
-    connection = null;
-  }
-
   /**
    * Called immediately before the transport transmits HTTP request headers.
    * This is used to observe the sent time should the request be cached.
@@ -324,10 +302,10 @@ public HttpEngine recover(IOException e) {
       return null;
     }
 
-    release(true);
+    Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, request, bufferRequestBody, null, routeSelector,
+    return new HttpEngine(client, request, bufferRequestBody, connection, routeSelector,
         (RetryableOutputStream) requestBodyOut);
   }
 
@@ -363,42 +341,42 @@ private void maybeCache() throws IOException {
   }
 
   /**
-   * Cause the socket connection to be released to the connection pool when
-   * it is no longer needed. If it is already unneeded, it will be pooled
-   * immediately. Otherwise the connection is held so that redirects can be
-   * handled by the same connection.
+   * Configure the socket connection to be either pooled or closed when it is
+   * either exhausted or closed. If it is unneeded when this is called, it will
+   * be released immediately.
    */
-  public final void automaticallyReleaseConnectionToPool() {
-    automaticallyReleaseConnectionToPool = true;
-    if (connection != null && connectionReleased) {
-      disconnect();
+  public final void releaseConnection() throws IOException {
+    if (transport != null) {
+      transport.releaseConnectionOnIdle();
     }
+    connection = null;
   }
 
   /**
-   * Releases this engine so that its resources may be either reused or
-   * closed. Also call {@link #automaticallyReleaseConnectionToPool} unless
-   * the connection will be used to follow a redirect.
+   * Release any resources held by this engine. If a connection is still held by
+   * this engine, it is returned.
    */
-  public final void release(boolean streamCanceled) {
-    // If the response body comes from the cache, close it.
-    if (validatingResponse != null
-        && validatingResponse.body() != null
-        && responseBodyIn == validatingResponse.body().byteStream()) {
-      closeQuietly(responseBodyIn);
+  public final Connection close() {
+    // If this engine never achieved a response body, its connection cannot be reused.
+    if (responseBodyIn == null) {
+      closeQuietly(connection);
+      connection = null;
+      return null;
     }
 
-    if (connection != null && !connectionReleased) {
-      connectionReleased = true;
+    // Close the response body. This will recycle the connection if it is eligible.
+    closeQuietly(responseBodyIn);
 
-      if (transport == null
-          || !transport.makeReusable(streamCanceled, requestBodyOut, responseTransferIn)) {
-        closeQuietly(connection);
-        connection = null;
-      } else if (automaticallyReleaseConnectionToPool) {
-        disconnect();
-      }
+    // Close the connection if it cannot be reused.
+    if (transport != null && !transport.canReuseConnection()) {
+      closeQuietly(connection);
+      connection = null;
+      return null;
     }
+
+    Connection result = connection;
+    connection = null;
+    return result;
   }
 
   /**
@@ -553,7 +531,7 @@ public final void readResponse() throws IOException {
     if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
       if (validatingResponse.validate(response)) {
         transport.emptyTransferStream();
-        release(false);
+        releaseConnection();
         response = combine(validatingResponse, response);
 
         // Update the cache after combining headers but before stripping the
@@ -18,7 +18,6 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.AbstractOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -104,46 +103,39 @@ public void writeRequestHeaders(Request request) throws IOException {
     return httpConnection.readResponse();
   }
 
-  public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn) {
-    if (streamCanceled) {
-      return false;
-    }
-
-    // We cannot reuse sockets that have incomplete output.
-    if (requestBodyOut != null && !((AbstractOutputStream) requestBodyOut).isClosed()) {
-      return false;
+  @Override public void releaseConnectionOnIdle() throws IOException {
+    if (canReuseConnection()) {
+      httpConnection.poolOnIdle();
+    } else {
+      httpConnection.closeOnIdle();
     }
+  }
 
+  @Override public boolean canReuseConnection() {
     // If the request specified that the connection shouldn't be reused, don't reuse it.
     if (""close"".equalsIgnoreCase(httpEngine.getRequest().header(""Connection""))) {
       return false;
     }
 
     // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.getResponse() != null
-        && ""close"".equalsIgnoreCase(httpEngine.getResponse().header(""Connection""))) {
+    if (""close"".equalsIgnoreCase(httpEngine.getResponse().header(""Connection""))) {
       return false;
     }
 
-    if (responseBodyIn instanceof HttpConnection.UnknownLengthHttpInputStream) {
+    if (httpConnection.isClosed()) {
       return false;
     }
 
-    if (responseBodyIn != null) {
-      return httpConnection.discard(httpEngine, responseBodyIn);
-    }
-
     return true;
   }
 
-  @Override public void emptyTransferStream() {
+  @Override public void emptyTransferStream() throws IOException {
     httpConnection.emptyResponseBody();
   }
 
   @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
     if (!httpEngine.hasResponseBody()) {
-      return httpConnection.newFixedLengthInputStream(cacheRequest, httpEngine, 0);
+      return httpConnection.newFixedLengthInputStream(cacheRequest, 0);
     }
 
     if (""chunked"".equalsIgnoreCase(httpEngine.getResponse().header(""Transfer-Encoding""))) {
@@ -152,7 +144,7 @@ public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
 
     long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
     if (contentLength != -1) {
-      return httpConnection.newFixedLengthInputStream(cacheRequest, httpEngine, contentLength);
+      return httpConnection.newFixedLengthInputStream(cacheRequest, contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
@@ -24,9 +24,9 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -101,15 +101,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final void disconnect() {
     // Calling disconnect() before a connection exists should have no effect.
     if (httpEngine != null) {
-      // We close the response body here instead of in
-      // HttpEngine.release because that is called when input
-      // has been completely read from the underlying socket.
-      // However the response body can be a GZIPInputStream that
-      // still has unread data.
-      if (httpEngine.hasResponse()) {
-        Util.closeQuietly(httpEngine.getResponseBody());
-      }
-      httpEngine.release(true);
+      httpEngine.close();
     }
   }
 
@@ -327,7 +319,7 @@ private HttpEngine getResponse() throws IOException {
 
       Retry retry = processResponseHeaders();
       if (retry == Retry.NONE) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+        httpEngine.releaseConnection();
         return httpEngine;
       }
 
@@ -353,12 +345,11 @@ private HttpEngine getResponse() throws IOException {
       }
 
       if (retry == Retry.DIFFERENT_CONNECTION) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+        httpEngine.releaseConnection();
       }
 
-      httpEngine.release(false);
-      httpEngine = newHttpEngine(retryMethod, httpEngine.getConnection(),
-          (RetryableOutputStream) requestBody);
+      Connection connection = httpEngine.close();
+      httpEngine = newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);
     }
   }
 
@@ -117,7 +117,7 @@ public Connection next(String method) throws IOException {
           if (!hasNextPostponed()) {
             throw new NoSuchElementException();
           }
-          return new Connection(nextPostponed());
+          return new Connection(pool, nextPostponed());
         }
         lastProxy = nextProxy();
         resetNextInetSocketAddress(lastProxy);
@@ -135,7 +135,7 @@ public Connection next(String method) throws IOException {
       return next(method);
     }
 
-    return new Connection(route);
+    return new Connection(pool, route);
   }
 
   /**
@@ -195,9 +195,11 @@ public static Response.Builder readNameValueBlock(List<Header> headerBlock,
     return new SpdyInputStream(stream, cacheRequest, httpEngine);
   }
 
-  @Override public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn) {
-    return true; // SPDY sockets are always reusable.
+  @Override public void releaseConnectionOnIdle() {
+  }
+
+  @Override public boolean canReuseConnection() {
+    return true; // TODO: spdyConnection.isClosed() ?
   }
 
   /** When true, this header should not be emitted or consumed. */
@@ -242,15 +244,12 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
    */
   abstract static class AbstractHttpInputStream extends InputStream {
     protected final InputStream in;
-    protected final HttpEngine httpEngine;
     private final CacheRequest cacheRequest;
     protected final OutputStream cacheBody;
     protected boolean closed;
 
-    AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest)
-        throws IOException {
+    AbstractHttpInputStream(InputStream in, CacheRequest cacheRequest) throws IOException {
       this.in = in;
-      this.httpEngine = httpEngine;
 
       OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
 
@@ -272,9 +271,7 @@ abstract static class AbstractHttpInputStream extends InputStream {
     }
 
     protected final void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException(""stream closed"");
-      }
+      if (closed) throw new IOException(""stream closed"");
     }
 
     protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOException {
@@ -291,7 +288,6 @@ protected final void endOfInput() throws IOException {
       if (cacheRequest != null) {
         cacheBody.close();
       }
-      httpEngine.release(false);
     }
 
     /**
@@ -310,7 +306,6 @@ protected final void unexpectedEndOfInput() {
       if (cacheRequest != null) {
         cacheRequest.abort();
       }
-      httpEngine.release(true);
     }
   }
 
@@ -321,7 +316,7 @@ private static class SpdyInputStream extends AbstractHttpInputStream {
 
     SpdyInputStream(SpdyStream stream, CacheRequest cacheRequest, HttpEngine httpEngine)
         throws IOException {
-      super(stream.getInputStream(), httpEngine, cacheRequest);
+      super(stream.getInputStream(), cacheRequest);
       this.stream = stream;
     }
 
@@ -65,12 +65,20 @@ interface Transport {
   Response.Builder readResponseHeaders() throws IOException;
 
   /** Notify the transport that no response body will be read. */
-  void emptyTransferStream();
+  void emptyTransferStream() throws IOException;
 
   // TODO: make this the content stream?
   InputStream getTransferStream(CacheRequest cacheRequest) throws IOException;
 
-  /** Returns true if the underlying connection can be recycled. */
-  boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn);
+  /**
+   * Configures the response body to pool or close the socket connection when
+   * the response body is closed.
+   */
+  void releaseConnectionOnIdle() throws IOException;
+
+  /**
+   * Returns true if the socket connection held by this transport can be reused
+   * for a follow-up exchange.
+   */
+  boolean canReuseConnection();
 }
@@ -35,6 +35,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public final class ConnectionPoolTest {
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
@@ -54,7 +55,6 @@ public final class ConnectionPoolTest {
   private Connection httpD;
   private Connection httpE;
   private Connection spdyA;
-  private Connection spdyB;
 
   @Before public void setUp() throws Exception {
     spdyServer.useHttps(sslContext.getSocketFactory(), false);
@@ -74,20 +74,18 @@ public final class ConnectionPoolTest {
 
     Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true);
     Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, true);
-    httpA = new Connection(httpRoute);
+    httpA = new Connection(null, httpRoute);
     httpA.connect(200, 200, null);
-    httpB = new Connection(httpRoute);
+    httpB = new Connection(null, httpRoute);
     httpB.connect(200, 200, null);
-    httpC = new Connection(httpRoute);
+    httpC = new Connection(null, httpRoute);
     httpC.connect(200, 200, null);
-    httpD = new Connection(httpRoute);
+    httpD = new Connection(null, httpRoute);
     httpD.connect(200, 200, null);
-    httpE = new Connection(httpRoute);
+    httpE = new Connection(null, httpRoute);
     httpE.connect(200, 200, null);
-    spdyA = new Connection(spdyRoute);
-    spdyA.connect(200, 200, null);
-    spdyB = new Connection(spdyRoute);
-    spdyB.connect(200, 200, null);
+    spdyA = new Connection(null, spdyRoute);
+    spdyA.connect(20000, 20000, null);
   }
 
   @After public void tearDown() throws Exception {
@@ -100,15 +98,15 @@ public final class ConnectionPoolTest {
     Util.closeQuietly(httpD);
     Util.closeQuietly(httpE);
     Util.closeQuietly(spdyA);
-    Util.closeQuietly(spdyB);
   }
 
   @Test public void poolSingleHttpConnection() throws IOException {
     ConnectionPool pool = new ConnectionPool(1, KEEP_ALIVE_DURATION_MS);
     Connection connection = pool.get(httpAddress);
     assertNull(connection);
 
-    connection = new Connection(new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
+    connection = new Connection(
+        null, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
     connection.connect(200, 200, null);
     assertEquals(0, pool.getConnectionCount());
     pool.recycle(connection);
@@ -134,7 +132,7 @@ public final class ConnectionPoolTest {
 
   @Test public void getSpdyConnection() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     assertSame(spdyA, pool.get(spdyAddress));
     assertPooled(pool, spdyA);
   }
@@ -189,7 +187,7 @@ public final class ConnectionPoolTest {
 
   @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     pool.recycle(httpA);
     assertPooled(pool, httpA, spdyA);
     assertSame(spdyA, pool.get(spdyAddress));
@@ -210,9 +208,13 @@ public final class ConnectionPoolTest {
     assertTrue(httpA.getSocket().isClosed());
   }
 
-  @Test public void shareHttpConnectionDoesNothing() throws Exception {
+  @Test public void shareHttpConnectionFails() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(httpA);
+    try {
+      pool.share(httpA);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
     assertPooled(pool);
   }
 
@@ -224,7 +226,7 @@ public final class ConnectionPoolTest {
 
   @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
     assertNull(pool.get(httpAddress));
     assertPooled(pool, spdyA); // Connection should still be in the pool.
@@ -270,7 +272,7 @@ public final class ConnectionPoolTest {
     assertEquals(0, pool.getSpdyConnectionCount());
 
     // spdy A should be added and http B should be removed.
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     Thread.sleep(50);
     assertEquals(2, pool.getConnectionCount());
     assertEquals(1, pool.getHttpConnectionCount());
@@ -299,13 +301,6 @@ public final class ConnectionPoolTest {
     assertEquals(1, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
 
-    // Nothing should change.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
     // An http connection should be removed from the pool.
     recycledHttpConnection = pool.get(httpAddress);
     assertNotNull(recycledHttpConnection);
@@ -314,13 +309,6 @@ public final class ConnectionPoolTest {
     assertEquals(0, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
 
-    // Shouldn't change numbers because spdyConnections A and B user the same server address.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
     // spdy A will be returned and kept in the pool. Pool shouldn't change.
     sharedSpdyConnection = pool.get(spdyAddress);
     assertEquals(spdyA, sharedSpdyConnection);
@@ -350,7 +338,7 @@ public final class ConnectionPoolTest {
     // Add 3 connections to the pool.
     pool.recycle(httpA);
     pool.recycle(httpB);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     assertEquals(3, pool.getConnectionCount());
     assertEquals(2, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
@@ -383,7 +371,7 @@ public final class ConnectionPoolTest {
     pool.recycle(httpA);
     Util.closeQuietly(httpA); // Include a closed connection in the pool.
     pool.recycle(httpB);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     int connectionCount = pool.getConnectionCount();
     assertTrue(connectionCount == 2 || connectionCount == 3);
 
",True,"The commit message refers to the necessity of changes by mentioning the previous 'ugly, awkward release() method' that attempted to manage connection pooling, discarding streams for caching, and closing broken streams. The new commit moves this logic to HttpConnection and introduces a policy informed by HttpEngine, specifying what to do when the connection becomes idle: pool, close, or hold. This change is made to improve the code structure and functionality.",True,"The commit message does not explicitly state the reason for moving the connection pooling logic, but it is clear from the code diff that the logic is being moved to improve the management of connections, which is a common reason for refactoring code. Additionally, the message mentions the removal of an 'ugly, awkward release() method' and the addition of a new 'HttpConnection' class with a policy for handling idle connections, which further suggests that the changes are intended to improve the overall functionality and maintainability of the code.",True,"The commit message explains that the previous implementation had a release() method that attempted to manage connection pooling, discarding streams for caching, and closing broken streams. The new implementation moves this logic to HttpConnection and specifies what to do when the connection becomes idle: pool, close or hold. This change is motivated by the need to better manage connection pooling and handle different scenarios more efficiently.",True,"The commit message mentions moving connection pooling logic and specifying what to do when the connection becomes idle: pool, close or hold. This indicates that the developer is addressing the need to manage connections more efficiently, which is a common requirement in software development to optimize resource usage and improve performance.",True,"The commit message directly mentions the improvements made to the code, such as moving connection pooling logic to HttpConnection and specifying what to do when the connection becomes idle: pool, close or hold. This clearly describes the objective of the change.",True,"The commit message describes the changes made to the connection pooling logic. It mentions moving the connection reuse to HttpConnection and specifying what to do when the connection becomes idle: pool, close, or hold. This accurately reflects the changes made in the code diff, which involve modifying the HttpConnection class to include methods for pooling or closing the connection when idle, and updating the Connection class to include a reference to the ConnectionPool.",True,"The commit message explains that the connection pooling logic has been moved to HttpConnection, which now specifies what to do when the connection becomes idle: pool, close, or hold. This change encapsulates the technical principle of managing connection pooling, which is a key aspect of efficient network communication.",True,"The commit message expresses a change in the connection pooling logic and specifies that the behavior only applies to SPDY connections. This is supported by the code diff, which shows changes related to SPDY connections and the introduction of a new policy for idle connections.",False,"The commit message does a good job of explaining the reason for the commit. It mentions that the connection pooling logic is being moved to HttpConnection, and it specifies the policy for what to do when the connection becomes idle: pool, close, or hold. This is clear and concise, and it doesn't seem necessary to add an additional explanation in the commit message."
https://github.com/square/retrofit/commit/ffab8145393225741167a003577696549573e857,Fix spelling ,https://api.github.com/repos/square/retrofit/commits/ffab8145393225741167a003577696549573e857,"@@ -209,7 +209,7 @@ public void testFailedExpansion() throws IOException {
     assertEquals(values[99], queueFile.peek());
   }
 
-  public void testPeakWithElementReader() throws IOException {
+  public void testPeekWithElementReader() throws IOException {
     QueueFile queueFile = new QueueFile(file);
     final byte[] a = {1, 2};
     queueFile.add(a);
",False,"The commit message 'Fix spelling' does not describe the necessity of changes by referencing conventions, standards, improvements in prior commits, or implemented features. It only mentions a spelling correction, which does not provide any context about the changes made in the code diff.",True,"The commit message 'Fix spelling' does not provide a rationale for the change. The change is a simple typographic fix, where the word 'peak' is corrected to 'peek'. This change is not related to adding test cases, text file changes, annotations, refactorings, or version management. It is easy to infer the necessity of the change from the code diff, as the incorrect spelling is clearly a mistake.",False,"The commit message 'Fix spelling' does not describe the necessity of changes or elaborate the motivation of the code change. It only mentions a typographical error, not a functional or logical issue. The code diff shows a simple spelling mistake in the method name, but the commit message does not provide any context or explanation about why this change was necessary.",False,"The commit message 'Fix spelling' does not explicitly describe the necessity of changes. The code diff shows a spelling correction in the method name 'testPeakWithElementReader' to 'testPeekWithElementReader'. This change does not indicate a user requirement, a problem in the software maintenance process, or a change in the development environment.",False,"The commit message 'Fix spelling' does not directly mention the defects it fixes or the improvements it makes to the code. The code diff shows a spelling mistake in the method name, but the commit message does not explicitly state that the change is to fix a typo or improve readability.",False,"The commit message 'Fix spelling' does not describe the changes made in the code diff. The code diff shows a spelling correction in the name of a method, but the commit message does not mention this change. Therefore, the commit message does not contain an expression that summarizes the changes made in the code diff.",False,The commit message 'Fix spelling' does not contain an expression that describes the technical principle underpinning the changes. The code diff shows a simple spelling correction in the method name from 'testPeakWithElementReader' to 'testPeekWithElementReader'. This is a typographical error and does not involve any significant changes to the underlying code or its functionality.,False,"The commit message 'Fix spelling' does not describe the code changes from a functional perspective. It only mentions a spelling correction, but the code diff shows a renaming of a method from 'testPeakWithElementReader' to 'testPeekWithElementReader'. This renaming does not introduce any new behaviors or functional changes to the code.",True,The commit message 'Fix spelling' is not necessary because the change in the code diff is a simple typo correction. The method name 'testPeakWithElementReader' was changed to 'testPeekWithElementReader'. The change is self-explanatory and does not require an additional explanation in the commit message.
https://github.com/spring-projects/spring-boot/commit/f34508ff8a1d85b43a0beccfc8d7377c2c993450,Remove outdated key  <enter> The `spring.metrics.export.redis.aggregate-key-pattern` is no longer defined but was still referenced in the documentation. ,https://api.github.com/repos/spring-projects/spring-boot/commits/f34508ff8a1d85b43a0beccfc8d7377c2c993450,"@@ -726,7 +726,6 @@ content into your application; rather pick only the properties that you need.
 	spring.metrics.export.send-latest=true # flag to switch off any available optimizations based on not exporting unchanged metric values
 	spring.metrics.export.includes= # list of patterns for metric names to include
 	spring.metrics.export.excludes= # list of patterns for metric names to exclude. Applied after the includes
-	spring.metrics.export.redis.aggregate-key-pattern= # pattern that tells the aggregator what to do with the keys from the source repository
 	spring.metrics.export.redis.prefix=spring.metrics # prefix for redis repository if active
 	spring.metrics.export.redis.key=keys.spring.metrics # key for redis repository export (if active)
 	spring.metrics.export.triggers.*= # specific trigger properties per MetricWriter bean name
",True,"The commit message explains the necessity of changes by referencing a convention. The key `spring.metrics.export.redis.aggregate-key-pattern` is no longer defined but was still referenced in the documentation. This implies that the key was outdated and no longer needed, which is a clear reference to a convention or standard (in this case, the updated documentation) that the commit message is following.",True,"The commit message 'Remove outdated key' clearly explains the necessity of the changes. The key `spring.metrics.export.redis.aggregate-key-pattern` is no longer defined but was still referenced in the documentation, which implies that it was outdated and needed to be removed. This is a common sense change that doesn't require a detailed rationale.",True,The commit message explains the motivation for the change by mentioning that the `spring.metrics.export.redis.aggregate-key-pattern` is no longer defined but was still referenced in the documentation. This indicates that the change is necessary to correct an error or shortcoming in the previous implementation.,True,"The commit message 'Remove outdated key' indicates that the key 'spring.metrics.export.redis.aggregate-key-pattern' is no longer defined but was still referenced in the documentation. This suggests that the change was made due to a problem in the software maintenance process, specifically outdated code that was no longer relevant or functional.",True,"The commit message directly mentions the issue it fixes, which is the outdated key `spring.metrics.export.redis.aggregate-key-pattern` that was still referenced in the documentation but no longer defined in the code. This clearly indicates that the change is made to fix a problem or improve the code.",True,"The commit message 'Remove outdated key' accurately summarizes the change in the code diff. It specifically mentions the key 'spring.metrics.export.redis.aggregate-key-pattern' that is being removed, which is also the only change in the diff. The message provides a clear description of the change, listing the key component that was removed.",True,"The commit message explains that the key 'spring.metrics.export.redis.aggregate-key-pattern' is no longer defined in the code but was still referenced in the documentation. This indicates that the technical principle underpinning the changes is the removal of outdated or unused configuration options to keep the system clean, maintainable, and up-to-date.",True,"The commit message 'Remove outdated key' clearly describes the change in the code diff. It explains that the key 'spring.metrics.export.redis.aggregate-key-pattern' is no longer defined in the code but was still referenced in the documentation. This change does not introduce new behaviors, but rather removes an outdated and no longer used configuration option, which is a significant change from a functional perspective.",False,"The commit message does not lack an explanation. It clearly states that the key 'spring.metrics.export.redis.aggregate-key-pattern' is no longer defined but was still referenced in the documentation. This provides a clear reason for the removal of the key, even though the change is small and simple."
https://github.com/apache/dubbo/commit/5668d740766f6303e789f072100cd235e4b67582,"Fix export provider error, change to catch throwable, handle NoClassDefFoundError ( <pr_link> ) ",https://api.github.com/repos/apache/dubbo/commits/5668d740766f6303e789f072100cd235e4b67582,"@@ -40,7 +40,7 @@
 
 /**
  * When there're more than one registry for subscription.
- *
+ * <p>
  * This extension provides a strategy to decide how to distribute traffics among them:
  * 1. registry marked as 'preferred=true' has the highest priority.
  * 2. check the zone the current request belongs, pick the registry that has the same zone first.
@@ -143,10 +143,10 @@ public void publishServiceDefinition(URL providerUrl) {
                 serviceDefinitions.put(providerUrl.getServiceKey(), data);
                 return;
             }
-            logger.info(""publishProvider interfaceName is empty . providerUrl: "" + providerUrl.toFullString());
-        } catch (ClassNotFoundException e) {
+            logger.error(""publishProvider interfaceName is empty . providerUrl: "" + providerUrl.toFullString());
+        } catch (Throwable t) {
             //ignore error
-            logger.error(""publishProvider getServiceDescriptor error. providerUrl: "" + providerUrl.toFullString(), e);
+            logger.error(""publishProvider getServiceDescriptor error. providerUrl: "" + providerUrl.toFullString(), t.getCause());
         }
     }
 
@@ -100,9 +100,9 @@ private void publishProvider(URL providerUrl) throws RpcException {
                 return;
             }
             logger.error(""publishProvider interfaceName is empty . providerUrl: "" + providerUrl.toFullString());
-        } catch (ClassNotFoundException e) {
+        } catch (Throwable t) {
             //ignore error
-            logger.error(""publishProvider getServiceDescriptor error. providerUrl: "" + providerUrl.toFullString(), e);
+            logger.error(""publishProvider getServiceDescriptor error. providerUrl: "" + providerUrl.toFullString(), t.getCause());
         }
     }
 
",True,"The commit message refers to the necessity of changes by mentioning the 'export provider error' and 'NoClassDefFoundError' that were previously encountered. The changes made in the code diff are to catch a more general 'Throwable' instead of 'ClassNotFoundException', which is an improvement as it can handle a broader range of exceptions. Additionally, the logging level for the error message has been changed from 'info' to 'error', which indicates that the severity of the issue has been recognized and the change is made to provide more accurate logging.",True,"The commit message 'Fix export provider error, change to catch throwable, handle NoClassDefFoundError' clearly describes the changes made in the code diff. It mentions the error that was fixed, the change made to catch a throwable instead of a specific exception, and the additional handling of NoClassDefFoundError. These changes are not trivial and are likely not easy to infer from the code diff, so the commit message provides a necessary explanation of the changes.",True,"The commit message 'Fix export provider error, change to catch throwable, handle NoClassDefFoundError' directly elaborates the motivation of the code change by mentioning the error scenario 'export provider error' and the specific exception 'NoClassDefFoundError' that was being handled in the code. This provides a clear indication of the necessity of the changes made in the code.",True,"The commit message 'Fix export provider error, change to catch throwable, handle NoClassDefFoundError' indicates that the developer made changes to handle a specific error ('export provider error') that was occurring in the code. This could be due to a problem in the software maintenance process, such as outdated code that is no longer compatible with the current runtime or development environment. The changes made to catch a throwable and handle NoClassDefFoundError suggest that the developer is addressing a runtime issue.",True,"The commit message 'Fix export provider error, change to catch throwable, handle NoClassDefFoundError' directly mentions the errors it fixes in the code. Specifically, it mentions fixing an export provider error, changing the catch block to catch Throwable instead of ClassNotFoundException, and handling NoClassDefFoundError. These changes are all described in the commit message, making it clear and descriptive of the changes made to the code.",True,"The commit message 'Fix export provider error, change to catch throwable, handle NoClassDefFoundError' accurately summarizes the changes made in the code diff. It mentions the error that was fixed, the change made to catch a throwable instead of a ClassNotFoundException, and the addition of handling NoClassDefFoundError. These are all key components of the change listed in the commit message.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on fixing an error and making changes to the code to handle exceptions differently. The code diff shows that the changes are related to error handling and logging, but it does not clearly indicate a specific technical principle being implemented or addressed.",True,"The commit message 'Fix export provider error, change to catch throwable, handle NoClassDefFoundError' does express a summary of the changes made in the code diff. It mentions fixing an error in the export provider, changing the catch block to catch a throwable instead of a ClassNotFoundException, and handling NoClassDefFoundError. These changes are functional in nature and introduce new behaviors such as catching a broader range of exceptions and logging errors differently.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Fix export provider error'. The changes made in the code diff are related to this issue. The error being fixed is a ClassNotFoundException, which is now being caught as a Throwable to handle NoClassDefFoundError as well. This is a significant change that requires an explanation in the commit message."
https://github.com/apache/dubbo/commit/54b0d7e3f4bc8f348c6260f649c6e3174d5b8a03,Remove duplicate dependency from [dubbo-bom] and [dubbo-demo-xml-consumer] ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/54b0d7e3f4bc8f348c6260f649c6e3174d5b8a03,"@@ -374,11 +374,6 @@
                 <artifactId>dubbo-metadata-api</artifactId>
                 <version>${project.version}</version>
             </dependency>
-            <dependency>
-                <groupId>org.apache.dubbo</groupId>
-                <artifactId>dubbo-metadata-api</artifactId>
-                <version>${project.version}</version>
-            </dependency>
             <dependency>
                 <groupId>org.apache.dubbo</groupId>
                 <artifactId>dubbo-metadata-report-zookeeper</artifactId>
@@ -67,10 +67,6 @@
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-metadata-report-nacos</artifactId>
         </dependency>
-        <dependency>
-            <groupId>org.apache.dubbo</groupId>
-            <artifactId>dubbo-metadata-report-zookeeper</artifactId>
-        </dependency>
         <dependency>
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-config-spring</artifactId>
",True,The commit message refers to the necessity of changes by mentioning the removal of a duplicate dependency. This is a common practice to improve the efficiency and maintainability of the project. The code diff also supports this explanation by showing the exact lines of code that were removed.,True,"The commit message 'Remove duplicate dependency' clearly and concisely describes the necessity of the changes. It is easy to infer from the code diff that there are duplicate dependencies in the project files, which can lead to unnecessary resource consumption and potential conflicts. The message does not require further explanation or rationale, as it is a common practice to remove duplicate dependencies to optimize the project.",True,"The commit message directly elaborates the motivation of the code change by mentioning the removal of a duplicate dependency. This indicates that the previous implementation had an issue with redundant dependencies, which could have caused unnecessary resource consumption or potential conflicts.",True,"The commit message 'Remove duplicate dependency from [dubbo-bom] and [dubbo-demo-xml-consumer]' indicates that the developer is addressing a problem in the process of software maintenance. The problem is the presence of duplicate dependencies in the project, which can lead to unnecessary resource consumption and potential conflicts. By removing the duplicate dependencies, the developer is improving the efficiency and stability of the software.",True,The commit message directly mentions the objective of the change by stating that it removes a duplicate dependency from the project. This change improves the code by reducing redundancy and potentially improving build times and resource usage.,True,"The commit message 'Remove duplicate dependency from [dubbo-bom] and [dubbo-demo-xml-consumer]' accurately summarizes the changes made in the diff. It clearly states that the change is the removal of a duplicate dependency, which is also evident in the diff where two instances of the same dependency are removed.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions the removal of a duplicate dependency, which is more about code cleanliness and maintenance rather than a technical principle.",True,"The commit message 'Remove duplicate dependency from [dubbo-bom] and [dubbo-demo-xml-consumer]' accurately describes the changes made in the code diff. The changes removed duplicate dependencies for 'dubbo-metadata-api' and 'dubbo-metadata-report-zookeeper' from the project, which is a functional change that improves the project's efficiency and reduces redundancy. This change does not introduce any new behaviors or functionalities.",False,"The commit message does not lack an explanation. It explicitly states that the duplicate dependency is being removed from two projects: [dubbo-bom] and [dubbo-demo-xml-consumer]. The code diff also supports this explanation by showing the exact lines of code that were removed. Therefore, the commit message provides a clear and sufficient explanation for the change."
https://github.com/spring-projects/spring-boot/commit/8e2e493946357bcefb53d0b0a608becad7719413,"Remove HSQLDB dependency from Batch Starter  <enter> This commit removes HSQLDB dependency from Batch Starter as most apps that use Spring Batch will prefer to use a RDBMS of their choice to store batch metadata. <enter> Additionally, explicit spring-jdbc dependency has been replaced with JDBC Starter dependency. <enter> See  <pr_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/8e2e493946357bcefb53d0b0a608becad7719413,"@@ -23,6 +23,10 @@
 			<groupId>org.springframework.boot</groupId>
 			<artifactId>spring-boot-starter-batch</artifactId>
 		</dependency>
+		<dependency>
+			<groupId>org.hsqldb</groupId>
+			<artifactId>hsqldb</artifactId>
+		</dependency>
 		<dependency>
 			<groupId>org.springframework.boot</groupId>
 			<artifactId>spring-boot-starter-test</artifactId>
@@ -8,7 +8,7 @@
 	</parent>
 	<artifactId>spring-boot-starter-batch</artifactId>
 	<name>Spring Boot Batch Starter</name>
-	<description>Starter for using Spring Batch, including HSQLDB in-memory database</description>
+	<description>Starter for using Spring Batch</description>
 	<url>http://projects.spring.io/spring-boot/</url>
 	<organization>
 		<name>Pivotal Software, Inc.</name>
@@ -23,12 +23,8 @@
 			<artifactId>spring-boot-starter</artifactId>
 		</dependency>
 		<dependency>
-			<groupId>org.hsqldb</groupId>
-			<artifactId>hsqldb</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.springframework</groupId>
-			<artifactId>spring-jdbc</artifactId>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-jdbc</artifactId>
 		</dependency>
 		<dependency>
 			<groupId>org.springframework.batch</groupId>
@@ -1 +1 @@
-provides: spring-batch
\ No newline at end of file
+provides: spring-batch-core
\ No newline at end of file
",True,"The commit message explains the necessity of changes by referencing a common practice in applications that use Spring Batch. It mentions that most applications will prefer to use a RDBMS of their choice to store batch metadata, which is why the HSQLDB dependency is being removed. This is a clear reference to a convention or standard that the change is addressing.",True,"The commit message clearly explains the necessity of changes by stating that the HSQLDB dependency is being removed from Batch Starter because most applications that use Spring Batch will prefer to use a RDBMS of their choice to store batch metadata. This is not a common sense or easy to infer change, but rather a decision based on the specific use case and requirements of the project.",True,"The commit message directly elaborates the motivation of the code change by mentioning that most apps that use Spring Batch will prefer to use a RDBMS of their choice to store batch metadata, which is not provided by HSQLDB. This explains the necessity of changes and the shortcoming of the previous implementation.",True,The commit message indicates that the changes were made to remove the HSQLDB dependency from Batch Starter due to the preference of most apps that use Spring Batch to use a RDBMS of their choice to store batch metadata. This suggests that the changes were made to meet the requirements of users who prefer to use their own database for batch metadata.,True,"The commit message directly mentions the objective of the change by stating that it removes the HSQLDB dependency from Batch Starter. This is done to allow apps that use Spring Batch to use a RDBMS of their choice for batch metadata. Additionally, the message mentions that the explicit spring-jdbc dependency has been replaced with JDBC Starter dependency, which further improves the code by simplifying dependencies.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions the removal of the HSQLDB dependency from the Batch Starter, which is a key component of the change. Additionally, it mentions the replacement of the explicit spring-jdbc dependency with the JDBC Starter dependency, further describing the change. The message also contrasts the before and after state of the project by mentioning the removal of the HSQLDB dependency and the change in the project description.",True,"The commit message explains that the changes are made to allow for the use of a RDBMS of the user's choice for storing batch metadata, instead of relying on the HSQLDB dependency. This highlights the principle of separation of concerns and flexibility, which is a common technical principle in software development.",True,"The commit message accurately summarizes the changes by explaining that it removes the HSQLDB dependency from the Batch Starter. This change allows applications using Spring Batch to choose their own RDBMS for storing batch metadata. Additionally, the message mentions that the explicit spring-jdbc dependency has been replaced with the JDBC Starter dependency, which further supports the functional perspective of the code changes.",False,The commit message does not lack an explanation. It clearly states the reasons for removing the HSQLDB dependency and replacing the explicit spring-jdbc dependency with JDBC Starter dependency. These reasons are not easily inferred from the code diff alone.
https://github.com/square/retrofit/commit/8bd6c990a728955f91646156b78244061ea91a2a,Prepare next development version ,https://api.github.com/repos/square/retrofit/commits/8bd6c990a728955f91646156b78244061ea91a2a,"@@ -1,6 +1,40 @@
 Change Log
 ==========
 
+Version 2.5.0 *(2018-11-18)*
+============================
+
+ * New: Built-in support for Kotlin's `Unit` type. This behaves the same as Java's `Void` where the body
+   content is ignored and immediately discarded.
+ * New: Build-in support for Java 8's `Optional` and `CompletableFuture` types. Previously the 'converter-java8'
+   and 'adapter-java8' dependencies were needed and explicitly adding `Java8OptionalConverterFactory` and/or
+   `Java8CallAdapterFactory` to your `Retrofit.Builder` in order to use these types. Support is now built-in and
+   those types and their artifacts are marked as deprecated.
+ * New: `Invocation` class provides a reference to the invoked method and argument list as a tag on the
+   underlying OkHttp `Call`. This can be accessed from an OkHttp interceptor for things like logging, analytics,
+   or metrics aggregation.
+ * New: Kotlin extension for `Retrofit` which allows you call `create` passing the interface type only as
+   a generic parameter (e.g., `retrofit.create<MyService>()`).
+ * New: Added `Response.success` overload which allows specifying a custom 2xx status code.
+ * New: Added `Call.failure` overload which allows passing any `Throwable` subtype.
+ * New: Minimal R8 rules now ship inside the jar requiring no client configuration in the common case.
+ * Fix: Do not propagate fatal errors to the callback. They are sent to the thread's uncaught
+   exception handler.
+ * Fix: Do not enqueue/execute an otherwise useless call when the RxJava type is disposed by `onSubscribe`.
+ * Fix: Call `RxJavaPlugins` assembly hook when creating an RxJava 2 type.
+ * Fix: Ensure both the Guava and Java 8 `Optional` converters delegate properly. This ensures that converters
+   registered prior to the optional converter can be used for deserializing the body type.
+ * Fix: Prevent `@Path` values from participating in path-traversal. This ensures untrusted input passed as
+   a path value cannot cause you to make a request to an un-intended relative URL.
+ * Fix: Simple XML converter (which is deprecated) no longer wraps subtypes of `RuntimeException`
+   or `IOException` when it fails.
+ * Fix: Prevent JAXB converter from loading remote entities and DTDs.
+ * Fix: Correctly detect default methods in interfaces on Android (API 24+). These still do not work, but
+   now a correct exception will be thrown when detected.
+ * Fix: Report more accurate exceptions when a `@QueryName` or `@QueryMap` precedes a `@Url` parameter.
+ * Update OkHttp dependency to 3.12.
+
+
 Version 2.4.0 *(2018-03-14)*
 ----------------------------
 
@@ -9,18 +9,7 @@ For more information please see [the website][1].
 Download
 --------
 
-Download [the latest JAR][2] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>retrofit</artifactId>
-  <version>2.4.0</version>
-</dependency>
-```
-or Gradle:
-```groovy
-implementation 'com.squareup.retrofit2:retrofit:2.4.0'
-```
+Download [the latest JAR][2] or grab from Maven central at the coordinates `com.squareup.retrofit2:retrofit:2.5.0`.
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
@@ -30,10 +19,11 @@ Retrofit requires at minimum Java 7 or Android 2.3.
 R8 / ProGuard
 -------------
 
-If you are using R8 or ProGuard add the options from
-[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro).
+If you are using R8 the shrinking and obfuscation rules are included automatically.
 
-You might also need rules for OkHttp and Okio which are dependencies of this library.
+ProGuard users must manually add the options from
+[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro).
+(Note: You might also need rules for OkHttp and Okio which are dependencies of this library)
 
 
 License
",True,"The commit message refers to the addition of new features and improvements in the codebase. For example, it mentions the addition of built-in support for Kotlin's `Unit` type, Java 8's `Optional` and `CompletableFuture` types, and the `Invocation` class. These changes are described as improvements and additions to the library, which suggests that the commit message is describing the necessity of changes.",True,"The commit message 'Prepare next development version' does not explicitly describe the necessity of changes, but the code diff provides a detailed list of new features, fixes, and updates. This includes adding support for Kotlin's `Unit` type, Java 8's `Optional` and `CompletableFuture` types, a new `Invocation` class, a Kotlin extension for `Retrofit`, and various fixes and updates. Therefore, the commit message can be considered to contain an expression that describes the necessity of changes.",True,"The commit message does describe the necessity of changes by elaborating the motivation of a code change. It mentions the new features added such as built-in support for Kotlin's `Unit` type, Java 8's `Optional` and `CompletableFuture` types, and the `Invocation` class. It also mentions the fixes made such as preventing fatal errors from propagating to the callback, fixing the JAXB converter from loading remote entities and DTDs, and correcting the detection of default methods in interfaces on Android. These changes are necessary to improve the functionality, security, and compatibility of the code.",True,"The commit message 'Prepare next development version' does not explicitly describe the necessity of changes. However, the code diff indicates that the changes are made to support new features and fix bugs. This suggests that the changes are likely due to the need for software development to meet new requirements or to address problems in the process of software maintenance, such as outdated code or runtime environment changes.",True,"The commit message does contain expressions that describe the objective of the change. It mentions several new features and improvements, such as built-in support for Kotlin's `Unit` type, Java 8's `Optional` and `CompletableFuture` types, and the `Invocation` class. It also mentions several fixes, such as fixing fatal errors propagation to the callback, preventing `@Path` values from participating in path-traversal, and correctly detecting default methods in interfaces on Android.",True,"The commit message 'Prepare next development version' does contain an expression that describes a summary of what changes by being a summary of the diffs. It mentions the addition of new features such as built-in support for Kotlin's `Unit` type, Java 8's `Optional` and `CompletableFuture` types, and the `Invocation` class. It also mentions fixes for various issues, such as preventing path-traversal and ensuring default methods in interfaces are handled correctly. Overall, the message provides a good overview of the changes made in the commit.",True,"The commit message highlights the addition of built-in support for Kotlin's `Unit` type, Java 8's `Optional` and `CompletableFuture` types, and the provision of a reference to the invoked method and argument list as a tag on the underlying OkHttp `Call`. These changes demonstrate the principle of enhancing interoperability and functionality, which is a common technical principle in software development.",True,"The commit message 'Prepare next development version' does contain an expression that describes a summary of what changes. It mentions the new features added such as built-in support for Kotlin's `Unit` type, Java 8's `Optional` and `CompletableFuture` types, an `Invocation` class, a Kotlin extension for `Retrofit`, and overloads for `Response.success` and `Call.failure`. It also mentions the fixes made for issues such as propagating fatal errors to the callback, preventing path-traversal, and preventing JAXB converter from loading remote entities and DTDs. These changes describe new behaviors introduced in the code.",True,"The commit message 'Prepare next development version' does not explicitly explain the reason for the commit. However, the code diff shows that the commit is updating the version number and adding several new features and fixes to the Retrofit library. These changes are significant and not easily inferred from the small change in the version number. Therefore, a more detailed explanation of the changes would have been beneficial in the commit message."
https://github.com/square/retrofit/commit/b3fcdca9939f376d9f825bb6ccaeeaa97c0f8325,"Fix inconsistencies in javadocs.  <enter> These changes were made with consistency in mind, in relation to the rest of the project:  - Change self-closing <p/> tags to regular <p> tags.  - Add missing <p> tags. ",https://api.github.com/repos/square/retrofit/commits/b3fcdca9939f376d9f825bb6ccaeeaa97c0f8325,"@@ -5,7 +5,7 @@
 
 /**
  * Represents a named parameter and its value.
- * <p/>
+ * <p>
  * This is used in one of three places in a request:
  * <ul>
  * <li>Named replacement in the relative URL path.
@@ -11,7 +11,7 @@ public interface Profiler<T> {
   /**
    * Invoked before an HTTP method call. The object returned by this method will be
    * passed to {@link #afterCall} when the call returns.
-   *
+   * <p>
    * This method gives implementors the opportunity to include information that may
    * change during the server call in {@code afterCall} logic.
    */
@@ -58,11 +58,11 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
 
   /**
    * Adapts a Java interface to a REST API.
-   * <p/>
+   * <p>
    * The relative path for a given method is obtained from an annotation on the method describing
    * the request type. The names of URL parameters are retrieved from {@link Name}
    * annotations on the method parameters.
-   * <p/>
+   * <p>
    * HTTP requests happen in one of two ways:
    * <ul>
    * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
@@ -74,7 +74,7 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
    * response will be converted to the method's return type using the specified
    * {@link Converter}.</li>
    * </ul>
-   * <p/>
+   * <p>
    * For example:
    * <pre>
    *   public interface MyApi {
@@ -260,13 +260,14 @@ private static Profiler.RequestInformation getRequestInfo(Server server,
 
   /**
    * Build a new {@link RestAdapter}.
-   * <p/>
+   * <p>
    * Calling the following methods is required before calling {@link #build()}:
    * <ul>
    * <li>{@link #setServer(Server)}</li>
    * <li>{@link #setClient(Client.Provider)}</li>
    * <li>{@link #setConverter(Converter)}</li>
    * </ul>
+   * <p>
    * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following
    * is also required:
    * <ul>
",True,"The commit message refers to the necessity of changes by mentioning the need for consistency in javadocs. It specifically mentions the changes made in relation to the rest of the project, such as changing self-closing <p/> tags to regular <p> tags and adding missing <p> tags. This shows that the changes were made with a standard or convention in mind, which is to ensure consistency throughout the project.",True,"The commit message 'Fix inconsistencies in javadocs' does not explicitly state the reason for the changes, but the code diff provides clear evidence of the necessity of the changes. The changes made include adding missing <p> tags and changing self-closing <p/> tags to regular <p> tags. These are common practices to ensure consistency and proper formatting in javadocs. Therefore, it is not necessary to provide a rationale in the commit message as the changes are self-explanatory.",False,"The commit message does not directly elaborate the motivation of the code change. It mentions the need for consistency and the changes made, but it does not describe any specific error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message 'Fix inconsistencies in javadocs' indicates that the changes were made to improve the consistency and readability of the documentation. This could be due to a requirement for better software maintenance, as outdated or inconsistent documentation can lead to confusion and errors. The changes include adding missing <p> tags and changing self-closing <p/> tags to regular <p> tags, which suggests a need for consistency in the formatting of the documentation.",True,"The commit message 'Fix inconsistencies in javadocs' does directly mention the change made to the code, which is to ensure consistency in the use of javadoc tags. Specifically, it mentions the addition of missing <p> tags and the change of self-closing <p/> tags to regular <p> tags. These changes improve the readability and consistency of the javadocs.",True,"The commit message 'Fix inconsistencies in javadocs' does describe a summary of the changes made in the diff. It mentions the changes made to self-closing <p/> tags and the addition of missing <p> tags, which are both reflected in the diff. Additionally, the message provides context about the changes being made with consistency in mind, which is a good practice and aligns with the changes made in the diff.",False,"The commit message does not explicitly state or describe the technical principle underpinning the changes. It mainly focuses on the consistency of javadocs and the changes made to improve that consistency, such as adding missing <p> tags and changing self-closing <p/> tags to regular <p> tags. However, it does not explain any underlying technical principle that guides these changes.",True,"The commit message 'Fix inconsistencies in javadocs' does describe the changes made in the code diff. It mentions the changes made to javadocs, which are the modifications to self-closing <p/> tags and the addition of missing <p> tags. These changes are made with consistency in mind, as stated in the message. The changes do not introduce new behaviors or functionalities, but rather ensure that the documentation is consistent with the rest of the project.",False,"The commit message explains the reason for the changes, which is to fix inconsistencies in javadocs. The changes made include changing self-closing <p/> tags to regular <p> tags and adding missing <p> tags. These changes are not trivial and could potentially affect the readability and understanding of the code, so an explanation in the commit message is necessary."
https://github.com/apache/dubbo/commit/48cb8e41a76b49b184f2b97e61b42eb109a16229,refactor package  <enter> git-svn-id:  http://code.alibabatech.com/svn/dubbo/trunk@1395  1a56cb94-b969-4eaa-88fa-be21384802f2 ,https://api.github.com/repos/apache/dubbo/commits/48cb8e41a76b49b184f2b97e61b42eb109a16229,,False,"The commit message does not contain an expression that describes the necessity of changes by referencing conventions, standards, improvements in prior commits, or implemented features. It simply states that the package is being refactored, without providing any context or explanation for why this is necessary.",True,"The commit message 'refactor package' does not provide a clear explanation for the necessity of the changes. However, it is common sense that refactoring a package might be done to improve the structure, readability, or maintainability of the code, without necessarily needing an explicit rationale in the commit message.",False,"The commit message does not contain any expression that directly elaborates the motivation of the code change. It only mentions the refactoring of a package and provides a git-svn-id, which is not related to the necessity or motivation of the changes.",False,"The commit message 'refactor package' does not explicitly describe the necessity of changes. It could be that the developer is reorganizing the code for better maintainability or readability, but it does not indicate a user requirement, a problem in the software maintenance process, or a change in the development environment.",False,"The commit message does not directly mention any defects it fixes or improvements it makes to the code. It only states that it is refactoring the package, which is a general term that could mean a variety of things, including code optimization, simplification, or reorganization, but it does not specify what exact defects are being fixed or what improvements are being made.",False,"The commit message 'refactor package' does not provide a summary of the changes made in the code diff. It only mentions that a refactoring has been done in the package, but it does not describe the specific changes made, nor does it contrast the before and after state of the code. Therefore, it does not meet the criteria of describing a summary of the changes based on the diffs.",False,"The commit message does not contain an expression that describes the technical principle underpinning the changes. It only mentions refactoring the package and provides a git-svn-id, which is not related to any technical principle.",False,"The commit message 'refactor package' does not provide a summary of the changes made in the code diff. It only mentions that the package is being refactored and provides a git-svn-id, which is not related to the functional changes in the code. The message does not describe any new behaviors introduced or explain the code changes from a functional perspective.",True,"The commit message 'refactor package' is quite generic and doesn't provide a clear explanation of the changes made. However, in this case, the commit message includes 'git-svn-id', which is often used to track the revision in a Git repository that was fetched from a Subversion repository. This suggests that the changes might be related to the synchronization process between the two version control systems. Without seeing the actual code diff, it's difficult to determine the exact nature of the refactoring. But, given the presence of 'git-svn-id' in the commit message, it's likely that the commit was made to update the metadata used for tracking the Subversion revision, rather than making significant changes to the code. Therefore, there was no need for an explicit explanation of the change."
https://github.com/apache/dubbo/commit/93b1cf014af7cce13f12816ab7114881765d4471,"Move UT in config-api to bootstrap temporarily, to solve the unreasonable dependency problem between modules. For long term run, we should refactor the config-api module to stop it from depending on other modules.",https://api.github.com/repos/apache/dubbo/commits/93b1cf014af7cce13f12816ab7114881765d4471,"@@ -43,5 +43,69 @@
             <artifactId>dubbo-registry-api</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-monitor-default</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-dubbo</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-rmi</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-remoting-netty4</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>javax.validation</groupId>
+            <artifactId>validation-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.hibernate</groupId>
+            <artifactId>hibernate-validator</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish</groupId>
+            <artifactId>javax.el</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-default</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-multicast</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-serialization-hessian2</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-serialization-jdk</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 </project>
\ No newline at end of file
@@ -1,515 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import junit.framework.TestCase;
-import org.apache.dubbo.config.api.Greeting;
-import org.apache.dubbo.config.support.Parameter;
-import org.hamcrest.Matchers;
-import org.junit.Test;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.junit.Assert.assertThat;
-
-public class AbstractConfigTest {
-
-    //FIXME
-  /*  @Test
-    public void testAppendProperties1() throws Exception {
-        try {
-            System.setProperty(""dubbo.properties.i"", ""1"");
-            System.setProperty(""dubbo.properties.c"", ""c"");
-            System.setProperty(""dubbo.properties.b"", ""2"");
-            System.setProperty(""dubbo.properties.d"", ""3"");
-            System.setProperty(""dubbo.properties.f"", ""4"");
-            System.setProperty(""dubbo.properties.l"", ""5"");
-            System.setProperty(""dubbo.properties.s"", ""6"");
-            System.setProperty(""dubbo.properties.str"", ""dubbo"");
-            System.setProperty(""dubbo.properties.bool"", ""true"");
-            PropertiesConfig config = new PropertiesConfig();
-            AbstractConfig.appendProperties(config);
-            TestCase.assertEquals(1, config.getI());
-            TestCase.assertEquals('c', config.getC());
-            TestCase.assertEquals((byte) 0x02, config.getB());
-            TestCase.assertEquals(3d, config.getD());
-            TestCase.assertEquals(4f, config.getF());
-            TestCase.assertEquals(5L, config.getL());
-            TestCase.assertEquals(6, config.getS());
-            TestCase.assertEquals(""dubbo"", config.getStr());
-            TestCase.assertTrue(config.isBool());
-        } finally {
-            System.clearProperty(""dubbo.properties.i"");
-            System.clearProperty(""dubbo.properties.c"");
-            System.clearProperty(""dubbo.properties.b"");
-            System.clearProperty(""dubbo.properties.d"");
-            System.clearProperty(""dubbo.properties.f"");
-            System.clearProperty(""dubbo.properties.l"");
-            System.clearProperty(""dubbo.properties.s"");
-            System.clearProperty(""dubbo.properties.str"");
-            System.clearProperty(""dubbo.properties.bool"");
-        }
-    }
-
-    @Test
-    public void testAppendProperties2() throws Exception {
-        try {
-            System.setProperty(""dubbo.properties.two.i"", ""2"");
-            PropertiesConfig config = new PropertiesConfig(""two"");
-            AbstractConfig.appendProperties(config);
-            TestCase.assertEquals(2, config.getI());
-        } finally {
-            System.clearProperty(""dubbo.properties.two.i"");
-        }
-    }
-
-    @Test
-    public void testAppendProperties3() throws Exception {
-        try {
-            Properties p = new Properties();
-            p.put(""dubbo.properties.str"", ""dubbo"");
-            ConfigUtils.setProperties(p);
-            PropertiesConfig config = new PropertiesConfig();
-            AbstractConfig.appendProperties(config);
-            TestCase.assertEquals(""dubbo"", config.getStr());
-        } finally {
-            System.clearProperty(Constants.DUBBO_PROPERTIES_KEY);
-            ConfigUtils.setProperties(null);
-        }
-    }*/
-
-    @Test
-    public void testAppendParameters1() throws Exception {
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(""default.num"", ""one"");
-        parameters.put(""num"", ""ONE"");
-        AbstractConfig.appendParameters(parameters, new ParameterConfig(1, ""hello/world"", 30, ""password""), ""prefix"");
-        TestCase.assertEquals(""one"", parameters.get(""prefix.key.1""));
-        TestCase.assertEquals(""two"", parameters.get(""prefix.key.2""));
-        TestCase.assertEquals(""ONE,one,1"", parameters.get(""prefix.num""));
-        TestCase.assertEquals(""hello%2Fworld"", parameters.get(""prefix.naming""));
-        TestCase.assertEquals(""30"", parameters.get(""prefix.age""));
-        TestCase.assertFalse(parameters.containsKey(""prefix.key-2""));
-        TestCase.assertFalse(parameters.containsKey(""prefix.secret""));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testAppendParameters2() throws Exception {
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractConfig.appendParameters(parameters, new ParameterConfig());
-    }
-
-    @Test
-    public void testAppendParameters3() throws Exception {
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractConfig.appendParameters(parameters, null);
-        TestCase.assertTrue(parameters.isEmpty());
-    }
-
-    @Test
-    public void testAppendParameters4() throws Exception {
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractConfig.appendParameters(parameters, new ParameterConfig(1, ""hello/world"", 30, ""password""));
-        TestCase.assertEquals(""one"", parameters.get(""key.1""));
-        TestCase.assertEquals(""two"", parameters.get(""key.2""));
-        TestCase.assertEquals(""1"", parameters.get(""num""));
-        TestCase.assertEquals(""hello%2Fworld"", parameters.get(""naming""));
-        TestCase.assertEquals(""30"", parameters.get(""age""));
-    }
-
-    @Test
-    public void testAppendAttributes1() throws Exception {
-        Map<String, Object> parameters = new HashMap<String, Object>();
-        AbstractConfig.appendAttributes(parameters, new AttributeConfig('l', true, (byte) 0x01), ""prefix"");
-        TestCase.assertEquals('l', parameters.get(""prefix.let""));
-        TestCase.assertEquals(true, parameters.get(""prefix.activate""));
-        TestCase.assertFalse(parameters.containsKey(""prefix.flag""));
-    }
-
-    @Test
-    public void testAppendAttributes2() throws Exception {
-        Map<String, Object> parameters = new HashMap<String, Object>();
-        AbstractConfig.appendAttributes(parameters, new AttributeConfig('l', true, (byte) 0x01));
-        TestCase.assertEquals('l', parameters.get(""let""));
-        TestCase.assertEquals(true, parameters.get(""activate""));
-        TestCase.assertFalse(parameters.containsKey(""flag""));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkExtension() throws Exception {
-        AbstractConfig.checkExtension(Greeting.class, ""hello"", ""world"");
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkMultiExtension1() throws Exception {
-        AbstractConfig.checkMultiExtension(Greeting.class, ""hello"", ""default,world"");
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkMultiExtension2() throws Exception {
-        AbstractConfig.checkMultiExtension(Greeting.class, ""hello"", ""default,-world"");
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkLength() throws Exception {
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0; i <= 200; i++) {
-            builder.append(""a"");
-        }
-        AbstractConfig.checkLength(""hello"", builder.toString());
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkPathLength() throws Exception {
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0; i <= 200; i++) {
-            builder.append(""a"");
-        }
-        AbstractConfig.checkPathLength(""hello"", builder.toString());
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkName() throws Exception {
-        AbstractConfig.checkName(""hello"", ""world%"");
-    }
-
-    @Test
-    public void checkNameHasSymbol() throws Exception {
-        try {
-            AbstractConfig.checkNameHasSymbol(""hello"", "":*,/-0123abcdABCD"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    public void checkKey() throws Exception {
-        try {
-            AbstractConfig.checkKey(""hello"", ""*,-0123abcdABCD"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    public void checkMultiName() throws Exception {
-        try {
-            AbstractConfig.checkMultiName(""hello"", "",-._0123abcdABCD"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    public void checkPathName() throws Exception {
-        try {
-            AbstractConfig.checkPathName(""hello"", ""/-$._0123abcdABCD"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    public void checkMethodName() throws Exception {
-        try {
-            AbstractConfig.checkMethodName(""hello"", ""abcdABCD0123abcd"");
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-
-        try {
-            AbstractConfig.checkMethodName(""hello"", ""0a"");
-            TestCase.fail(""the value should be illegal."");
-        } catch (Exception e) {
-            // ignore
-        }
-    }
-
-    @Test
-    public void checkParameterName() throws Exception {
-        Map<String, String> parameters = Collections.singletonMap(""hello"", "":*,/-._0123abcdABCD"");
-        try {
-            AbstractConfig.checkParameterName(parameters);
-        } catch (Exception e) {
-            TestCase.fail(""the value should be legal."");
-        }
-    }
-
-    @Test
-    @Config(interfaceClass = Greeting.class, filter = {""f1, f2""}, listener = {""l1, l2""},
-            parameters = {""k1"", ""v1"", ""k2"", ""v2""})
-    public void appendAnnotation() throws Exception {
-        Config config = getClass().getMethod(""appendAnnotation"").getAnnotation(Config.class);
-        AnnotationConfig annotationConfig = new AnnotationConfig();
-        annotationConfig.appendAnnotation(Config.class, config);
-        TestCase.assertSame(Greeting.class, annotationConfig.getInterface());
-        TestCase.assertEquals(""f1, f2"", annotationConfig.getFilter());
-        TestCase.assertEquals(""l1, l2"", annotationConfig.getListener());
-        TestCase.assertEquals(2, annotationConfig.getParameters().size());
-        TestCase.assertEquals(""v1"", annotationConfig.getParameters().get(""k1""));
-        TestCase.assertEquals(""v2"", annotationConfig.getParameters().get(""k2""));
-        assertThat(annotationConfig.toString(), Matchers.containsString(""filter=\""f1, f2\"" ""));
-        assertThat(annotationConfig.toString(), Matchers.containsString(""listener=\""l1, l2\"" ""));
-    }
-
-    private static class PropertiesConfig extends AbstractConfig {
-        private char c;
-        private boolean bool;
-        private byte b;
-        private int i;
-        private long l;
-        private float f;
-        private double d;
-        private short s;
-        private String str;
-
-        PropertiesConfig() {
-        }
-
-        PropertiesConfig(String id) {
-            this.id = id;
-        }
-
-        public char getC() {
-            return c;
-        }
-
-        public void setC(char c) {
-            this.c = c;
-        }
-
-        public boolean isBool() {
-            return bool;
-        }
-
-        public void setBool(boolean bool) {
-            this.bool = bool;
-        }
-
-        public byte getB() {
-            return b;
-        }
-
-        public void setB(byte b) {
-            this.b = b;
-        }
-
-        public int getI() {
-            return i;
-        }
-
-        public void setI(int i) {
-            this.i = i;
-        }
-
-        public long getL() {
-            return l;
-        }
-
-        public void setL(long l) {
-            this.l = l;
-        }
-
-        public float getF() {
-            return f;
-        }
-
-        public void setF(float f) {
-            this.f = f;
-        }
-
-        public double getD() {
-            return d;
-        }
-
-        public void setD(double d) {
-            this.d = d;
-        }
-
-        public String getStr() {
-            return str;
-        }
-
-        public void setStr(String str) {
-            this.str = str;
-        }
-
-        public short getS() {
-            return s;
-        }
-
-        public void setS(short s) {
-            this.s = s;
-        }
-    }
-
-    private static class ParameterConfig {
-        private int number;
-        private String name;
-        private int age;
-        private String secret;
-
-        ParameterConfig() {
-        }
-
-        ParameterConfig(int number, String name, int age, String secret) {
-            this.number = number;
-            this.name = name;
-            this.age = age;
-            this.secret = secret;
-        }
-
-        @Parameter(key = ""num"", append = true)
-        public int getNumber() {
-            return number;
-        }
-
-        public void setNumber(int number) {
-            this.number = number;
-        }
-
-        @Parameter(key = ""naming"", append = true, escaped = true, required = true)
-        public String getName() {
-            return name;
-        }
-
-        public void setName(String name) {
-            this.name = name;
-        }
-
-        public int getAge() {
-            return age;
-        }
-
-        public void setAge(int age) {
-            this.age = age;
-        }
-
-        @Parameter(excluded = true)
-        public String getSecret() {
-            return secret;
-        }
-
-        public void setSecret(String secret) {
-            this.secret = secret;
-        }
-
-        public Map getParameters() {
-            Map<String, String> map = new HashMap<String, String>();
-            map.put(""key.1"", ""one"");
-            map.put(""key-2"", ""two"");
-            return map;
-        }
-    }
-
-    private static class AttributeConfig {
-        private char letter;
-        private boolean activate;
-        private byte flag;
-
-        public AttributeConfig(char letter, boolean activate, byte flag) {
-            this.letter = letter;
-            this.activate = activate;
-            this.flag = flag;
-        }
-
-        @Parameter(attribute = true, key = ""let"")
-        public char getLetter() {
-            return letter;
-        }
-
-        public void setLetter(char letter) {
-            this.letter = letter;
-        }
-
-        @Parameter(attribute = true)
-        public boolean isActivate() {
-            return activate;
-        }
-
-        public void setActivate(boolean activate) {
-            this.activate = activate;
-        }
-
-        public byte getFlag() {
-            return flag;
-        }
-
-        public void setFlag(byte flag) {
-            this.flag = flag;
-        }
-    }
-
-    @Retention(RetentionPolicy.RUNTIME)
-    @Target({ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE})
-    public @interface Config {
-        Class<?> interfaceClass() default void.class;
-
-        String interfaceName() default """";
-
-        String[] filter() default {};
-
-        String[] listener() default {};
-
-        String[] parameters() default {};
-    }
-
-    private static class AnnotationConfig extends AbstractConfig {
-        private Class interfaceClass;
-        private String filter;
-        private String listener;
-        private Map<String, String> parameters;
-
-        public Class getInterface() {
-            return interfaceClass;
-        }
-
-        public void setInterface(Class interfaceName) {
-            this.interfaceClass = interfaceName;
-        }
-
-        public String getFilter() {
-            return filter;
-        }
-
-        public void setFilter(String filter) {
-            this.filter = filter;
-        }
-
-        public String getListener() {
-            return listener;
-        }
-
-        public void setListener(String listener) {
-            this.listener = listener;
-        }
-
-        public Map<String, String> getParameters() {
-            return parameters;
-        }
-
-        public void setParameters(Map<String, String> parameters) {
-            this.parameters = parameters;
-        }
-    }
-}
@@ -1,411 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.IOUtils;
-import org.apache.dubbo.config.api.Greeting;
-import org.apache.dubbo.config.mock.GreetingLocal1;
-import org.apache.dubbo.config.mock.GreetingLocal2;
-import org.apache.dubbo.config.mock.GreetingLocal3;
-import org.apache.dubbo.config.mock.GreetingMock1;
-import org.apache.dubbo.config.mock.GreetingMock2;
-import org.apache.dubbo.monitor.MonitorService;
-import org.apache.dubbo.registry.RegistryService;
-import junit.framework.TestCase;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.ClassRule;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Properties;
-
-public class AbstractInterfaceConfigTest {
-    @ClassRule
-    public static TemporaryFolder tempDir = new TemporaryFolder();
-    private static File dubboProperties;
-
-    @BeforeClass
-    public static void setUp() throws Exception {
-        dubboProperties = tempDir.newFile(Constants.DUBBO_PROPERTIES_KEY);
-        System.setProperty(Constants.DUBBO_PROPERTIES_KEY, dubboProperties.getAbsolutePath());
-    }
-
-    @AfterClass
-    public static void tearDown() throws Exception {
-        System.clearProperty(Constants.DUBBO_PROPERTIES_KEY);
-    }
-
-    @Test
-    public void testCheckRegistry1() throws Exception {
-        System.setProperty(""dubbo.registry.address"", ""addr1|addr2"");
-        try {
-            InterfaceConfig interfaceConfig = new InterfaceConfig();
-            interfaceConfig.checkRegistry();
-            TestCase.assertEquals(2, interfaceConfig.getRegistries().size());
-        } finally {
-            System.clearProperty(""dubbo.registry.address"");
-        }
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testCheckRegistry2() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkRegistry();
-    }
-
-    @Test
-    public void checkApplication1() throws Exception {
-        try {
-            ConfigUtils.setProperties(null);
-            System.clearProperty(Constants.SHUTDOWN_WAIT_KEY);
-            System.clearProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);
-
-            writeDubboProperties(Constants.SHUTDOWN_WAIT_KEY, ""100"");
-            System.setProperty(""dubbo.application.name"", ""demo"");
-            InterfaceConfig interfaceConfig = new InterfaceConfig();
-            interfaceConfig.checkApplication();
-            ApplicationConfig appConfig = interfaceConfig.getApplication();
-            TestCase.assertEquals(""demo"", appConfig.getName());
-            TestCase.assertEquals(""100"", System.getProperty(Constants.SHUTDOWN_WAIT_KEY));
-
-            System.clearProperty(Constants.SHUTDOWN_WAIT_KEY);
-            ConfigUtils.setProperties(null);
-            writeDubboProperties(Constants.SHUTDOWN_WAIT_SECONDS_KEY, ""1000"");
-            System.setProperty(""dubbo.application.name"", ""demo"");
-            interfaceConfig = new InterfaceConfig();
-            interfaceConfig.checkApplication();
-            TestCase.assertEquals(""1000"", System.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY));
-        } finally {
-            ConfigUtils.setProperties(null);
-            System.clearProperty(""dubbo.application.name"");
-            System.clearProperty(Constants.SHUTDOWN_WAIT_KEY);
-            System.clearProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);
-        }
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkApplication2() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkApplication();
-    }
-
-    @Test
-    public void testLoadRegistries() throws Exception {
-        System.setProperty(""dubbo.registry.address"", ""addr1"");
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        List<URL> urls = interfaceConfig.loadRegistries(true);
-        TestCase.assertEquals(1, urls.size());
-        URL url = urls.get(0);
-        TestCase.assertEquals(""registry"", url.getProtocol());
-        TestCase.assertEquals(""addr1:9090"", url.getAddress());
-        TestCase.assertEquals(RegistryService.class.getName(), url.getPath());
-        TestCase.assertTrue(url.getParameters().containsKey(""timestamp""));
-        TestCase.assertTrue(url.getParameters().containsKey(""pid""));
-        TestCase.assertTrue(url.getParameters().containsKey(""registry""));
-        TestCase.assertTrue(url.getParameters().containsKey(""dubbo""));
-    }
-
-    @Test
-    public void testLoadMonitor() throws Exception {
-        System.setProperty(""dubbo.monitor.address"", ""monitor-addr:12080"");
-        System.setProperty(""dubbo.monitor.protocol"", ""monitor"");
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        URL url = interfaceConfig.loadMonitor(new URL(""dubbo"", ""addr1"", 9090));
-        TestCase.assertEquals(""monitor-addr:12080"", url.getAddress());
-        TestCase.assertEquals(MonitorService.class.getName(), url.getParameter(""interface""));
-        TestCase.assertNotNull(url.getParameter(""dubbo""));
-        TestCase.assertNotNull(url.getParameter(""pid""));
-        TestCase.assertNotNull(url.getParameter(""timestamp""));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkInterfaceAndMethods1() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(null, null);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkInterfaceAndMethods2() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(AbstractInterfaceConfigTest.class, null);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkInterfaceAndMethod3() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(Greeting.class, Collections.singletonList(methodConfig));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkInterfaceAndMethod4() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setName(""nihao"");
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(Greeting.class, Collections.singletonList(methodConfig));
-    }
-
-    @Test
-    public void checkInterfaceAndMethod5() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setName(""hello"");
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.checkInterfaceAndMethods(Greeting.class, Collections.singletonList(methodConfig));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock1() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLocal(GreetingLocal1.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock2() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLocal(GreetingLocal2.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test
-    public void checkStubAndMock3() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLocal(GreetingLocal3.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock4() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setStub(GreetingLocal1.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock5() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setStub(GreetingLocal2.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test
-    public void checkStubAndMock6() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setStub(GreetingLocal3.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock7() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setMock(""return {a, b}"");
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock8() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setMock(GreetingMock1.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void checkStubAndMock9() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setMock(GreetingMock2.class.getName());
-        interfaceConfig.checkStubAndMock(Greeting.class);
-    }
-
-    @Test
-    public void testLocal() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLocal((Boolean) null);
-        TestCase.assertNull(interfaceConfig.getLocal());
-        interfaceConfig.setLocal(true);
-        TestCase.assertEquals(""true"", interfaceConfig.getLocal());
-        interfaceConfig.setLocal(""GreetingMock"");
-        TestCase.assertEquals(""GreetingMock"", interfaceConfig.getLocal());
-    }
-
-    @Test
-    public void testStub() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setStub((Boolean) null);
-        TestCase.assertNull(interfaceConfig.getStub());
-        interfaceConfig.setStub(true);
-        TestCase.assertEquals(""true"", interfaceConfig.getStub());
-        interfaceConfig.setStub(""GreetingMock"");
-        TestCase.assertEquals(""GreetingMock"", interfaceConfig.getStub());
-    }
-
-    @Test
-    public void testCluster() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setCluster(""mockcluster"");
-        TestCase.assertEquals(""mockcluster"", interfaceConfig.getCluster());
-    }
-
-    @Test
-    public void testProxy() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setProxy(""mockproxyfactory"");
-        TestCase.assertEquals(""mockproxyfactory"", interfaceConfig.getProxy());
-    }
-
-    @Test
-    public void testConnections() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setConnections(1);
-        TestCase.assertEquals(1, interfaceConfig.getConnections().intValue());
-    }
-
-    @Test
-    public void testFilter() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setFilter(""mockfilter"");
-        TestCase.assertEquals(""mockfilter"", interfaceConfig.getFilter());
-    }
-
-    @Test
-    public void testListener() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setListener(""mockinvokerlistener"");
-        TestCase.assertEquals(""mockinvokerlistener"", interfaceConfig.getListener());
-    }
-
-    @Test
-    public void testLayer() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setLayer(""layer"");
-        TestCase.assertEquals(""layer"", interfaceConfig.getLayer());
-    }
-
-    @Test
-    public void testApplication() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        ApplicationConfig applicationConfig = new ApplicationConfig();
-        interfaceConfig.setApplication(applicationConfig);
-        TestCase.assertSame(applicationConfig, interfaceConfig.getApplication());
-    }
-
-    @Test
-    public void testModule() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        ModuleConfig moduleConfig = new ModuleConfig();
-        interfaceConfig.setModule(moduleConfig);
-        TestCase.assertSame(moduleConfig, interfaceConfig.getModule());
-    }
-
-    @Test
-    public void testRegistry() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        RegistryConfig registryConfig = new RegistryConfig();
-        interfaceConfig.setRegistry(registryConfig);
-        TestCase.assertSame(registryConfig, interfaceConfig.getRegistry());
-    }
-
-    @Test
-    public void testRegistries() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        RegistryConfig registryConfig = new RegistryConfig();
-        interfaceConfig.setRegistries(Collections.singletonList(registryConfig));
-        TestCase.assertEquals(1, interfaceConfig.getRegistries().size());
-        TestCase.assertSame(registryConfig, interfaceConfig.getRegistries().get(0));
-    }
-
-    @Test
-    public void testMonitor() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setMonitor(""monitor-addr"");
-        TestCase.assertEquals(""monitor-addr"", interfaceConfig.getMonitor().getAddress());
-        MonitorConfig monitorConfig = new MonitorConfig();
-        interfaceConfig.setMonitor(monitorConfig);
-        TestCase.assertSame(monitorConfig, interfaceConfig.getMonitor());
-    }
-
-    @Test
-    public void testOwner() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setOwner(""owner"");
-        TestCase.assertEquals(""owner"", interfaceConfig.getOwner());
-    }
-
-    @Test
-    public void testCallbacks() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setCallbacks(2);
-        TestCase.assertEquals(2, interfaceConfig.getCallbacks().intValue());
-    }
-
-    @Test
-    public void testOnconnect() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setOnconnect(""onConnect"");
-        TestCase.assertEquals(""onConnect"", interfaceConfig.getOnconnect());
-    }
-
-    @Test
-    public void testOndisconnect() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setOndisconnect(""onDisconnect"");
-        TestCase.assertEquals(""onDisconnect"", interfaceConfig.getOndisconnect());
-    }
-
-    @Test
-    public void testScope() throws Exception {
-        InterfaceConfig interfaceConfig = new InterfaceConfig();
-        interfaceConfig.setScope(""scope"");
-        TestCase.assertEquals(""scope"", interfaceConfig.getScope());
-    }
-
-    private void writeDubboProperties(String key, String value) {
-        OutputStream os = null;
-        try {
-            os = new BufferedOutputStream(new FileOutputStream(dubboProperties));
-            Properties properties = new Properties();
-            properties.put(key, value);
-            properties.store(os, """");
-            os.close();
-        } catch (IOException e) {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (IOException ioe) {
-                    // ignore
-                }
-            }
-        }
-    }
-
-    private static class InterfaceConfig extends AbstractInterfaceConfig {
-
-    }
-}
@@ -1,119 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.isEmptyOrNullString;
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertThat;
-
-public class AbstractMethodConfigTest {
-    @Test
-    public void testTimeout() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setTimeout(10);
-        assertThat(methodConfig.getTimeout(), equalTo(10));
-    }
-
-    @Test
-    public void testRetries() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setRetries(3);
-        assertThat(methodConfig.getRetries(), equalTo(3));
-    }
-
-    @Test
-    public void testLoadbalance() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setLoadbalance(""mockloadbalance"");
-        assertThat(methodConfig.getLoadbalance(), equalTo(""mockloadbalance""));
-    }
-
-    @Test
-    public void testAsync() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setAsync(true);
-        assertThat(methodConfig.isAsync(), is(true));
-    }
-
-    @Test
-    public void testActives() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setActives(10);
-        assertThat(methodConfig.getActives(), equalTo(10));
-    }
-
-    @Test
-    public void testSent() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setSent(true);
-        assertThat(methodConfig.getSent(), is(true));
-    }
-
-    @Test
-    public void testMock() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setMock((Boolean) null);
-        assertThat(methodConfig.getMock(), isEmptyOrNullString());
-        methodConfig.setMock(true);
-        assertThat(methodConfig.getMock(), equalTo(""true""));
-        methodConfig.setMock(""return null"");
-        assertThat(methodConfig.getMock(), equalTo(""return null""));
-        methodConfig.setMock(""mock"");
-        assertThat(methodConfig.getMock(), equalTo(""mock""));
-    }
-
-    @Test
-    public void testMerger() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setMerger(""merger"");
-        assertThat(methodConfig.getMerger(), equalTo(""merger""));
-    }
-
-    @Test
-    public void testCache() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setCache(""cache"");
-        assertThat(methodConfig.getCache(), equalTo(""cache""));
-    }
-
-    @Test
-    public void testValidation() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        methodConfig.setValidation(""validation"");
-        assertThat(methodConfig.getValidation(), equalTo(""validation""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        MethodConfig methodConfig = new MethodConfig();
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(""key"", ""value"");
-        methodConfig.setParameters(parameters);
-        assertThat(methodConfig.getParameters(), sameInstance(parameters));
-    }
-
-    private static class MethodConfig extends AbstractMethodConfig {
-
-    }
-}
@@ -1,157 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.hasValue;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class AbstractReferenceConfigTest {
-
-    @Test
-    public void testCheck() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setCheck(true);
-        assertThat(referenceConfig.isCheck(), is(true));
-    }
-
-    @Test
-    public void testInit() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setInit(true);
-        assertThat(referenceConfig.isInit(), is(true));
-    }
-
-    @Test
-    public void testGeneric() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setGeneric(true);
-        assertThat(referenceConfig.isGeneric(), is(true));
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        // FIXME: not sure why AbstractReferenceConfig has both isGeneric and getGeneric
-        assertThat(parameters, hasKey(""generic""));
-    }
-
-    @Test
-    public void testInjvm() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setInit(true);
-        assertThat(referenceConfig.isInit(), is(true));
-    }
-
-    @Test
-    public void testFilter() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setFilter(""mockfilter"");
-        assertThat(referenceConfig.getFilter(), equalTo(""mockfilter""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(Constants.REFERENCE_FILTER_KEY, ""prefilter"");
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(parameters, hasValue(""prefilter,mockfilter""));
-    }
-
-    @Test
-    public void testListener() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setListener(""mockinvokerlistener"");
-        assertThat(referenceConfig.getListener(), equalTo(""mockinvokerlistener""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(Constants.INVOKER_LISTENER_KEY, ""prelistener"");
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(parameters, hasValue(""prelistener,mockinvokerlistener""));
-    }
-
-    @Test
-    public void testLazy() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setLazy(true);
-        assertThat(referenceConfig.getLazy(), is(true));
-    }
-
-    @Test
-    public void testOnconnect() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setOnconnect(""onConnect"");
-        assertThat(referenceConfig.getOnconnect(), equalTo(""onConnect""));
-        assertThat(referenceConfig.getStubevent(), is(true));
-    }
-
-    @Test
-    public void testOndisconnect() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setOndisconnect(""onDisconnect"");
-        assertThat(referenceConfig.getOndisconnect(), equalTo(""onDisconnect""));
-        assertThat(referenceConfig.getStubevent(), is(true));
-    }
-
-    @Test
-    public void testStubevent() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setOnconnect(""onConnect"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(parameters, hasKey(Constants.STUB_EVENT_KEY));
-    }
-
-    @Test
-    public void testReconnect() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setReconnect(""reconnect"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(referenceConfig.getReconnect(), equalTo(""reconnect""));
-        assertThat(parameters, hasKey(Constants.RECONNECT_KEY));
-    }
-
-    @Test
-    public void testSticky() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setSticky(true);
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);
-        assertThat(referenceConfig.getSticky(), is(true));
-        assertThat(parameters, hasKey(Constants.CLUSTER_STICKY_KEY));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setVersion(""version"");
-        assertThat(referenceConfig.getVersion(), equalTo(""version""));
-    }
-
-    @Test
-    public void testGroup() throws Exception {
-        ReferenceConfig referenceConfig = new ReferenceConfig();
-        referenceConfig.setGroup(""group"");
-        assertThat(referenceConfig.getGroup(), equalTo(""group""));
-    }
-
-    private static class ReferenceConfig extends AbstractReferenceConfig {
-
-    }
-}
@@ -1,181 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasSize;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.notNullValue;
-import static org.hamcrest.Matchers.nullValue;
-import static org.junit.Assert.assertThat;
-
-public class AbstractServiceConfigTest {
-    @Test
-    public void testVersion() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setVersion(""version"");
-        assertThat(serviceConfig.getVersion(), equalTo(""version""));
-    }
-
-    @Test
-    public void testGroup() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setGroup(""group"");
-        assertThat(serviceConfig.getGroup(), equalTo(""group""));
-    }
-
-    @Test
-    public void testDelay() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setDelay(1000);
-        assertThat(serviceConfig.getDelay(), equalTo(1000));
-    }
-
-    @Test
-    public void testExport() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setExport(true);
-        assertThat(serviceConfig.getExport(), is(true));
-    }
-
-    @Test
-    public void testWeight() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setWeight(500);
-        assertThat(serviceConfig.getWeight(), equalTo(500));
-    }
-
-    @Test
-    public void testDocument() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setDocument(""http://dubbo.io"");
-        assertThat(serviceConfig.getDocument(), equalTo(""http://dubbo.io""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractServiceConfig.appendParameters(parameters, serviceConfig);
-        assertThat(parameters, hasEntry(""document"", ""http%3A%2F%2Fdubbo.io""));
-    }
-
-    @Test
-    public void testToken() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setToken(""token"");
-        assertThat(serviceConfig.getToken(), equalTo(""token""));
-        serviceConfig.setToken((Boolean) null);
-        assertThat(serviceConfig.getToken(), nullValue());
-        serviceConfig.setToken(true);
-        assertThat(serviceConfig.getToken(), is(""true""));
-    }
-
-    @Test
-    public void testDeprecated() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setDeprecated(true);
-        assertThat(serviceConfig.isDeprecated(), is(true));
-    }
-
-    @Test
-    public void testDynamic() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setDynamic(true);
-        assertThat(serviceConfig.isDynamic(), is(true));
-    }
-
-    @Test
-    public void testProtocol() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        assertThat(serviceConfig.getProtocol(), nullValue());
-        serviceConfig.setProtocol(new ProtocolConfig());
-        assertThat(serviceConfig.getProtocol(), notNullValue());
-        serviceConfig.setProtocols(Collections.singletonList(new ProtocolConfig()));
-        assertThat(serviceConfig.getProtocols(), hasSize(1));
-    }
-
-    @Test
-    public void testAccesslog() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setAccesslog(""access.log"");
-        assertThat(serviceConfig.getAccesslog(), equalTo(""access.log""));
-        serviceConfig.setAccesslog((Boolean) null);
-        assertThat(serviceConfig.getAccesslog(), nullValue());
-        serviceConfig.setAccesslog(true);
-        assertThat(serviceConfig.getAccesslog(), equalTo(""true""));
-    }
-
-    @Test
-    public void testExecutes() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setExecutes(10);
-        assertThat(serviceConfig.getExecutes(), equalTo(10));
-    }
-
-    @Test
-    public void testFilter() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setFilter(""mockfilter"");
-        assertThat(serviceConfig.getFilter(), equalTo(""mockfilter""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(Constants.SERVICE_FILTER_KEY, ""prefilter"");
-        AbstractServiceConfig.appendParameters(parameters, serviceConfig);
-        assertThat(parameters, hasEntry(Constants.SERVICE_FILTER_KEY, ""prefilter,mockfilter""));
-    }
-
-    @Test
-    public void testListener() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setListener(""mockexporterlistener"");
-        assertThat(serviceConfig.getListener(), equalTo(""mockexporterlistener""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(Constants.EXPORTER_LISTENER_KEY, ""prelistener"");
-        AbstractServiceConfig.appendParameters(parameters, serviceConfig);
-        assertThat(parameters, hasEntry(Constants.EXPORTER_LISTENER_KEY, ""prelistener,mockexporterlistener""));
-    }
-
-    @Test
-    public void testRegister() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setRegister(true);
-        assertThat(serviceConfig.isRegister(), is(true));
-    }
-
-    @Test
-    public void testWarmup() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setWarmup(100);
-        assertThat(serviceConfig.getWarmup(), equalTo(100));
-    }
-
-    @Test
-    public void testSerialization() throws Exception {
-        ServiceConfig serviceConfig = new ServiceConfig();
-        serviceConfig.setSerialization(""serialization"");
-        assertThat(serviceConfig.getSerialization(), equalTo(""serialization""));
-    }
-
-
-    private static class ServiceConfig extends AbstractServiceConfig {
-
-    }
-}
@@ -1,177 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.sameInstance;
-import static org.hamcrest.collection.IsCollectionWithSize.hasSize;
-import static org.junit.Assert.assertThat;
-
-public class ApplicationConfigTest {
-    @Test
-    public void testName() throws Exception {
-        ApplicationConfig application = new ApplicationConfig();
-        application.setName(""app"");
-        assertThat(application.getName(), equalTo(""app""));
-        application = new ApplicationConfig(""app2"");
-        assertThat(application.getName(), equalTo(""app2""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(Constants.APPLICATION_KEY, ""app2""));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setVersion(""1.0.0"");
-        assertThat(application.getVersion(), equalTo(""1.0.0""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(""application.version"", ""1.0.0""));
-    }
-
-    @Test
-    public void testOwner() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setOwner(""owner"");
-        assertThat(application.getOwner(), equalTo(""owner""));
-    }
-
-    @Test
-    public void testOrganization() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setOrganization(""org"");
-        assertThat(application.getOrganization(), equalTo(""org""));
-    }
-
-    @Test
-    public void testArchitecture() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setArchitecture(""arch"");
-        assertThat(application.getArchitecture(), equalTo(""arch""));
-    }
-
-    @Test
-    public void testEnvironment1() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setEnvironment(""develop"");
-        assertThat(application.getEnvironment(), equalTo(""develop""));
-        application.setEnvironment(""test"");
-        assertThat(application.getEnvironment(), equalTo(""test""));
-        application.setEnvironment(""product"");
-        assertThat(application.getEnvironment(), equalTo(""product""));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testEnvironment2() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setEnvironment(""illegal-env"");
-    }
-
-    @Test
-    public void testRegistry() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        RegistryConfig registry = new RegistryConfig();
-        application.setRegistry(registry);
-        assertThat(application.getRegistry(), sameInstance(registry));
-        application.setRegistries(Collections.singletonList(registry));
-        assertThat(application.getRegistries(), contains(registry));
-        assertThat(application.getRegistries(), hasSize(1));
-    }
-
-    @Test
-    public void testMonitor() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setMonitor(new MonitorConfig(""monitor-addr""));
-        assertThat(application.getMonitor().getAddress(), equalTo(""monitor-addr""));
-        application.setMonitor(""monitor-addr"");
-        assertThat(application.getMonitor().getAddress(), equalTo(""monitor-addr""));
-    }
-
-    @Test
-    public void testLogger() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setLogger(""log4j"");
-        assertThat(application.getLogger(), equalTo(""log4j""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setDefault(true);
-        assertThat(application.isDefault(), is(true));
-    }
-
-    @Test
-    public void testDumpDirectory() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setDumpDirectory(""/dump"");
-        assertThat(application.getDumpDirectory(), equalTo(""/dump""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(Constants.DUMP_DIRECTORY, ""/dump""));
-    }
-
-    @Test
-    public void testQosEnable() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setQosEnable(true);
-        assertThat(application.getQosEnable(), is(true));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(Constants.QOS_ENABLE, ""true""));
-    }
-
-    @Test
-    public void testQosPort() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setQosPort(8080);
-        assertThat(application.getQosPort(), equalTo(8080));
-    }
-
-    @Test
-    public void testQosAcceptForeignIp() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setQosAcceptForeignIp(true);
-        assertThat(application.getQosAcceptForeignIp(), is(true));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(Constants.ACCEPT_FOREIGN_IP, ""true""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        ApplicationConfig application = new ApplicationConfig(""app"");
-        application.setQosAcceptForeignIp(true);
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(""k1"", ""v1"");
-        ApplicationConfig.appendParameters(parameters, application);
-        assertThat(parameters, hasEntry(""k1"", ""v1""));
-        assertThat(parameters, hasEntry(Constants.ACCEPT_FOREIGN_IP, ""true""));
-    }
-}
@@ -1,63 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class ArgumentConfigTest {
-    @Test
-    public void testIndex() throws Exception {
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setIndex(1);
-        assertThat(argument.getIndex(), is(1));
-    }
-
-    @Test
-    public void testType() throws Exception {
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setType(""int"");
-        assertThat(argument.getType(), equalTo(""int""));
-    }
-
-    @Test
-    public void testCallback() throws Exception {
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setCallback(true);
-        assertThat(argument.isCallback(), is(true));
-    }
-
-    @Test
-    public void testArguments() throws Exception {
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setIndex(1);
-        argument.setType(""int"");
-        argument.setCallback(true);
-        Map<String, String> parameters = new HashMap<String, String>();
-        AbstractServiceConfig.appendParameters(parameters, argument);
-        assertThat(parameters, hasEntry(""callback"", ""true""));
-        assertThat(parameters.size(), is(1));
-    }
-}
@@ -1,81 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class ConsumerConfigTest {
-    @Test
-    public void testTimeout() throws Exception {
-        try {
-            System.clearProperty(""sun.rmi.transport.tcp.responseTimeout"");
-            ConsumerConfig consumer = new ConsumerConfig();
-            consumer.setTimeout(10);
-            assertThat(consumer.getTimeout(), is(10));
-            assertThat(System.getProperty(""sun.rmi.transport.tcp.responseTimeout""), equalTo(""10""));
-        } finally {
-            System.clearProperty(""sun.rmi.transport.tcp.responseTimeout"");
-        }
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setDefault(true);
-        assertThat(consumer.isDefault(), is(true));
-    }
-
-    @Test
-    public void testClient() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setClient(""client"");
-        assertThat(consumer.getClient(), equalTo(""client""));
-    }
-
-    @Test
-    public void testThreadpool() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setThreadpool(""fixed"");
-        assertThat(consumer.getThreadpool(), equalTo(""fixed""));
-    }
-
-    @Test
-    public void testCorethreads() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setCorethreads(10);
-        assertThat(consumer.getCorethreads(), equalTo(10));
-    }
-
-    @Test
-    public void testThreads() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setThreads(20);
-        assertThat(consumer.getThreads(), equalTo(20));
-    }
-
-    @Test
-    public void testQueues() throws Exception {
-        ConsumerConfig consumer = new ConsumerConfig();
-        consumer.setQueues(5);
-        assertThat(consumer.getQueues(), equalTo(5));
-    }
-}
@@ -1,315 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.beanutil.JavaBeanAccessor;
-import org.apache.dubbo.common.beanutil.JavaBeanDescriptor;
-import org.apache.dubbo.common.beanutil.JavaBeanSerializeUtil;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.common.serialize.Serialization;
-import org.apache.dubbo.common.utils.ReflectUtils;
-import org.apache.dubbo.config.api.DemoException;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.api.User;
-import org.apache.dubbo.config.provider.impl.DemoServiceImpl;
-import org.apache.dubbo.rpc.service.GenericException;
-import org.apache.dubbo.rpc.service.GenericService;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * GenericServiceTest
- */
-public class GenericServiceTest {
-
-    @Test
-    public void testGenericServiceException() {
-        ServiceConfig<GenericService> service = new ServiceConfig<GenericService>();
-        service.setApplication(new ApplicationConfig(""generic-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.setInterface(DemoService.class.getName());
-        service.setRef(new GenericService() {
-
-            public Object $invoke(String method, String[] parameterTypes, Object[] args)
-                    throws GenericException {
-                if (""sayName"".equals(method)) {
-                    return ""Generic "" + args[0];
-                }
-                if (""throwDemoException"".equals(method)) {
-                    throw new GenericException(DemoException.class.getName(), ""Generic"");
-                }
-                if (""getUsers"".equals(method)) {
-                    return args[0];
-                }
-                return null;
-            }
-        });
-        service.export();
-        try {
-            ReferenceConfig<DemoService> reference = new ReferenceConfig<DemoService>();
-            reference.setApplication(new ApplicationConfig(""generic-consumer""));
-            reference.setInterface(DemoService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29581?generic=true&timeout=3000"");
-            DemoService demoService = reference.get();
-            try {
-                // say name
-                Assert.assertEquals(""Generic Haha"", demoService.sayName(""Haha""));
-                // get users
-                List<User> users = new ArrayList<User>();
-                users.add(new User(""Aaa""));
-                users = demoService.getUsers(users);
-                Assert.assertEquals(""Aaa"", users.get(0).getName());
-                // throw demo exception
-                try {
-                    demoService.throwDemoException();
-                    Assert.fail();
-                } catch (DemoException e) {
-                    Assert.assertEquals(""Generic"", e.getMessage());
-                }
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @SuppressWarnings(""unchecked"")
-    @Test
-    public void testGenericReferenceException() {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setApplication(new ApplicationConfig(""generic-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.setInterface(DemoService.class.getName());
-        service.setRef(new DemoServiceImpl());
-        service.export();
-        try {
-            ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();
-            reference.setApplication(new ApplicationConfig(""generic-consumer""));
-            reference.setInterface(DemoService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29581?scope=remote&timeout=3000"");
-            reference.setGeneric(true);
-            GenericService genericService = reference.get();
-            try {
-                List<Map<String, Object>> users = new ArrayList<Map<String, Object>>();
-                Map<String, Object> user = new HashMap<String, Object>();
-                user.put(""class"", ""org.apache.dubbo.config.api.User"");
-                user.put(""name"", ""actual.provider"");
-                users.add(user);
-                users = (List<Map<String, Object>>) genericService.$invoke(""getUsers"", new String[]{List.class.getName()}, new Object[]{users});
-                Assert.assertEquals(1, users.size());
-                Assert.assertEquals(""actual.provider"", users.get(0).get(""name""));
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testGenericSerializationJava() throws Exception {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setApplication(new ApplicationConfig(""generic-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.setInterface(DemoService.class.getName());
-        DemoServiceImpl ref = new DemoServiceImpl();
-        service.setRef(ref);
-        service.export();
-        try {
-            ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();
-            reference.setApplication(new ApplicationConfig(""generic-consumer""));
-            reference.setInterface(DemoService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29581?scope=remote&timeout=3000"");
-            reference.setGeneric(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA);
-            GenericService genericService = reference.get();
-            try {
-                String name = ""kimi"";
-                ByteArrayOutputStream bos = new ByteArrayOutputStream(512);
-                ExtensionLoader.getExtensionLoader(Serialization.class)
-                        .getExtension(""nativejava"").serialize(null, bos).writeObject(name);
-                byte[] arg = bos.toByteArray();
-                Object obj = genericService.$invoke(""sayName"", new String[]{String.class.getName()}, new Object[]{arg});
-                Assert.assertTrue(obj instanceof byte[]);
-                byte[] result = (byte[]) obj;
-                Assert.assertEquals(ref.sayName(name), ExtensionLoader.getExtensionLoader(Serialization.class)
-                        .getExtension(""nativejava"").deserialize(null, new ByteArrayInputStream(result)).readObject().toString());
-
-                // getUsers
-                List<User> users = new ArrayList<User>();
-                User user = new User();
-                user.setName(name);
-                users.add(user);
-                bos = new ByteArrayOutputStream(512);
-                ExtensionLoader.getExtensionLoader(Serialization.class)
-                        .getExtension(""nativejava"").serialize(null, bos).writeObject(users);
-                obj = genericService.$invoke(""getUsers"",
-                        new String[]{List.class.getName()},
-                        new Object[]{bos.toByteArray()});
-                Assert.assertTrue(obj instanceof byte[]);
-                result = (byte[]) obj;
-                Assert.assertEquals(users,
-                        ExtensionLoader.getExtensionLoader(Serialization.class)
-                                .getExtension(""nativejava"")
-                                .deserialize(null, new ByteArrayInputStream(result))
-                                .readObject());
-
-                // echo(int)
-                bos = new ByteArrayOutputStream(512);
-                ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(""nativejava"")
-                        .serialize(null, bos).writeObject(Integer.MAX_VALUE);
-                obj = genericService.$invoke(""echo"", new String[]{int.class.getName()}, new Object[]{bos.toByteArray()});
-                Assert.assertTrue(obj instanceof byte[]);
-                Assert.assertEquals(Integer.MAX_VALUE,
-                        ExtensionLoader.getExtensionLoader(Serialization.class)
-                                .getExtension(""nativejava"")
-                                .deserialize(null, new ByteArrayInputStream((byte[]) obj))
-                                .readObject());
-
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testGenericInvokeWithBeanSerialization() throws Exception {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setApplication(new ApplicationConfig(""bean-provider""));
-        service.setInterface(DemoService.class);
-        service.setRegistry(new RegistryConfig(""N/A""));
-        DemoServiceImpl impl = new DemoServiceImpl();
-        service.setRef(impl);
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.export();
-        ReferenceConfig<GenericService> reference = null;
-        try {
-            reference = new ReferenceConfig<GenericService>();
-            reference.setApplication(new ApplicationConfig(""bean-consumer""));
-            reference.setInterface(DemoService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29581?scope=remote&timeout=3000"");
-            reference.setGeneric(Constants.GENERIC_SERIALIZATION_BEAN);
-            GenericService genericService = reference.get();
-            User user = new User();
-            user.setName(""zhangsan"");
-            List<User> users = new ArrayList<User>();
-            users.add(user);
-            Object result = genericService.$invoke(""getUsers"", new String[]{ReflectUtils.getName(List.class)}, new Object[]{JavaBeanSerializeUtil.serialize(users, JavaBeanAccessor.METHOD)});
-            Assert.assertTrue(result instanceof JavaBeanDescriptor);
-            JavaBeanDescriptor descriptor = (JavaBeanDescriptor) result;
-            Assert.assertTrue(descriptor.isCollectionType());
-            Assert.assertEquals(1, descriptor.propertySize());
-            descriptor = (JavaBeanDescriptor) descriptor.getProperty(0);
-            Assert.assertTrue(descriptor.isBeanType());
-            Assert.assertEquals(user.getName(), ((JavaBeanDescriptor) descriptor.getProperty(""name"")).getPrimitiveProperty());
-        } finally {
-            if (reference != null) {
-                reference.destroy();
-            }
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testGenericImplementationWithBeanSerialization() throws Exception {
-        final AtomicReference reference = new AtomicReference();
-        ServiceConfig<GenericService> service = new ServiceConfig<GenericService>();
-        service.setApplication(new ApplicationConfig(""bean-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29581));
-        service.setInterface(DemoService.class.getName());
-        service.setRef(new GenericService() {
-
-            public Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException {
-                if (""getUsers"".equals(method)) {
-                    GenericParameter arg = new GenericParameter();
-                    arg.method = method;
-                    arg.parameterTypes = parameterTypes;
-                    arg.arguments = args;
-                    reference.set(arg);
-                    return args[0];
-                }
-                if (""sayName"".equals(method)) {
-                    return null;
-                }
-                return args;
-            }
-        });
-        service.export();
-        ReferenceConfig<DemoService> ref = null;
-        try {
-            ref = new ReferenceConfig<DemoService>();
-            ref.setApplication(new ApplicationConfig(""bean-consumer""));
-            ref.setInterface(DemoService.class);
-            ref.setUrl(""dubbo://127.0.0.1:29581?scope=remote&generic=bean&timeout=3000"");
-            DemoService demoService = ref.get();
-            User user = new User();
-            user.setName(""zhangsan"");
-            List<User> users = new ArrayList<User>();
-            users.add(user);
-            List<User> result = demoService.getUsers(users);
-            Assert.assertEquals(users.size(), result.size());
-            Assert.assertEquals(user.getName(), result.get(0).getName());
-
-            GenericParameter gp = (GenericParameter) reference.get();
-            Assert.assertEquals(""getUsers"", gp.method);
-            Assert.assertEquals(1, gp.parameterTypes.length);
-            Assert.assertEquals(ReflectUtils.getName(List.class), gp.parameterTypes[0]);
-            Assert.assertEquals(1, gp.arguments.length);
-            Assert.assertTrue(gp.arguments[0] instanceof JavaBeanDescriptor);
-            JavaBeanDescriptor descriptor = (JavaBeanDescriptor) gp.arguments[0];
-            Assert.assertTrue(descriptor.isCollectionType());
-            Assert.assertEquals(ArrayList.class.getName(), descriptor.getClassName());
-            Assert.assertEquals(1, descriptor.propertySize());
-            descriptor = (JavaBeanDescriptor) descriptor.getProperty(0);
-            Assert.assertTrue(descriptor.isBeanType());
-            Assert.assertEquals(User.class.getName(), descriptor.getClassName());
-            Assert.assertEquals(user.getName(), ((JavaBeanDescriptor) descriptor.getProperty(""name"")).getPrimitiveProperty());
-            Assert.assertNull(demoService.sayName(""zhangsan""));
-        } finally {
-            if (ref != null) {
-                ref.destroy();
-            }
-            service.unexport();
-        }
-    }
-
-    protected static class GenericParameter {
-
-        String method;
-
-        String[] parameterTypes;
-
-        Object[] arguments;
-    }
-
-}
@@ -1,182 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.hamcrest.Matchers;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
-
-public class MethodConfigTest {
-    @Test
-    public void testName() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setName(""hello"");
-        assertThat(method.getName(), equalTo(""hello""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters, not(hasKey(""name"")));
-    }
-
-    @Test
-    public void testStat() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setStat(10);
-        assertThat(method.getStat(), equalTo(10));
-    }
-
-    @Test
-    public void testRetry() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setRetry(true);
-        assertThat(method.isRetry(), is(true));
-    }
-
-    @Test
-    public void testReliable() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setReliable(true);
-        assertThat(method.isReliable(), is(true));
-    }
-
-    @Test
-    public void testExecutes() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setExecutes(10);
-        assertThat(method.getExecutes(), equalTo(10));
-    }
-
-    @Test
-    public void testDeprecated() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setDeprecated(true);
-        assertThat(method.getDeprecated(), is(true));
-    }
-
-    @Test
-    public void testArguments() throws Exception {
-        MethodConfig method = new MethodConfig();
-        ArgumentConfig argument = new ArgumentConfig();
-        method.setArguments(Collections.singletonList(argument));
-        assertThat(method.getArguments(), contains(argument));
-        assertThat(method.getArguments(), Matchers.<ArgumentConfig>hasSize(1));
-    }
-
-    @Test
-    public void testSticky() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setSticky(true);
-        assertThat(method.getSticky(), is(true));
-    }
-
-    @Test
-    public void testOnreturn() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOnreturn(""on-return-object"");
-        assertThat(method.getOnreturn(), equalTo((Object) ""on-return-object""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_RETURN_INSTANCE_KEY, (Object) ""on-return-object""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOnreturnMethod() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOnreturnMethod(""on-return-method"");
-        assertThat(method.getOnreturnMethod(), equalTo(""on-return-method""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_RETURN_METHOD_KEY, (Object) ""on-return-method""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOnthrow() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOnthrow(""on-throw-object"");
-        assertThat(method.getOnthrow(), equalTo((Object) ""on-throw-object""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_THROW_INSTANCE_KEY, (Object) ""on-throw-object""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOnthrowMethod() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOnthrowMethod(""on-throw-method"");
-        assertThat(method.getOnthrowMethod(), equalTo(""on-throw-method""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_THROW_METHOD_KEY, (Object) ""on-throw-method""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOninvoke() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOninvoke(""on-invoke-object"");
-        assertThat(method.getOninvoke(), equalTo((Object) ""on-invoke-object""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_INVOKE_INSTANCE_KEY, (Object) ""on-invoke-object""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testOninvokeMethod() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setOninvokeMethod(""on-invoke-method"");
-        assertThat(method.getOninvokeMethod(), equalTo(""on-invoke-method""));
-        Map<String, Object> attribute = new HashMap<String, Object>();
-        MethodConfig.appendAttributes(attribute, method);
-        assertThat(attribute, hasEntry((Object) Constants.ON_INVOKE_METHOD_KEY, (Object) ""on-invoke-method""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MethodConfig.appendParameters(parameters, method);
-        assertThat(parameters.size(), is(0));
-    }
-
-    @Test
-    public void testReturn() throws Exception {
-        MethodConfig method = new MethodConfig();
-        method.setReturn(true);
-        assertThat(method.isReturn(), is(true));
-    }
-}
@@ -1,110 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.hamcrest.Matchers;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertThat;
-
-public class ModuleConfigTest {
-    @Test(expected = IllegalStateException.class)
-    public void testName1() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        Map<String, String> parameters = new HashMap<String, String>();
-        ModuleConfig.appendParameters(parameters, module);
-    }
-
-    @Test
-    public void testName2() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setName(""module-name"");
-        assertThat(module.getName(), equalTo(""module-name""));
-        assertThat(module.getId(), equalTo(""module-name""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ModuleConfig.appendParameters(parameters, module);
-        assertThat(parameters, hasEntry(""module"", ""module-name""));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setName(""module-name"");
-        module.setVersion(""1.0.0"");
-        assertThat(module.getVersion(), equalTo(""1.0.0""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        ModuleConfig.appendParameters(parameters, module);
-        assertThat(parameters, hasEntry(""module.version"", ""1.0.0""));
-    }
-
-    @Test
-    public void testOwner() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setOwner(""owner"");
-        assertThat(module.getOwner(), equalTo(""owner""));
-    }
-
-    @Test
-    public void testOrganization() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setOrganization(""org"");
-        assertThat(module.getOrganization(), equalTo(""org""));
-    }
-
-    @Test
-    public void testRegistry() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        RegistryConfig registry = new RegistryConfig();
-        module.setRegistry(registry);
-        assertThat(module.getRegistry(), sameInstance(registry));
-    }
-
-    @Test
-    public void testRegistries() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        RegistryConfig registry = new RegistryConfig();
-        module.setRegistries(Collections.singletonList(registry));
-        assertThat(module.getRegistries(), Matchers.<RegistryConfig>hasSize(1));
-        assertThat(module.getRegistries(), contains(registry));
-    }
-
-    @Test
-    public void testMonitor() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setMonitor(""monitor-addr1"");
-        assertThat(module.getMonitor().getAddress(), equalTo(""monitor-addr1""));
-        module.setMonitor(new MonitorConfig(""monitor-addr2""));
-        assertThat(module.getMonitor().getAddress(), equalTo(""monitor-addr2""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ModuleConfig module = new ModuleConfig();
-        module.setDefault(true);
-        assertThat(module.isDefault(), is(true));
-    }
-}
@@ -1,107 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class MonitorConfigTest {
-    @Test
-    public void testAddress() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setAddress(""monitor-addr"");
-        assertThat(monitor.getAddress(), equalTo(""monitor-addr""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MonitorConfig.appendParameters(parameters, monitor);
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testProtocol() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setProtocol(""protocol"");
-        assertThat(monitor.getProtocol(), equalTo(""protocol""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MonitorConfig.appendParameters(parameters, monitor);
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testUsername() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setUsername(""user"");
-        assertThat(monitor.getUsername(), equalTo(""user""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MonitorConfig.appendParameters(parameters, monitor);
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testPassword() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setPassword(""secret"");
-        assertThat(monitor.getPassword(), equalTo(""secret""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        MonitorConfig.appendParameters(parameters, monitor);
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testGroup() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setGroup(""group"");
-        assertThat(monitor.getGroup(), equalTo(""group""));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setVersion(""1.0.0"");
-        assertThat(monitor.getVersion(), equalTo(""1.0.0""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        Map<String, String> parameters = Collections.singletonMap(""k1"", ""v1"");
-        monitor.setParameters(parameters);
-        assertThat(monitor.getParameters(), hasEntry(""k1"", ""v1""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setDefault(true);
-        assertThat(monitor.isDefault(), is(true));
-    }
-
-    @Test
-    public void testInterval() throws Exception {
-        MonitorConfig monitor = new MonitorConfig();
-        monitor.setInterval(""100"");
-        assertThat(monitor.getInterval(), equalTo(""100""));
-    }
-}
@@ -1,217 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.config.mock.MockProtocol2;
-import org.apache.dubbo.rpc.Protocol;
-import org.junit.Test;
-import org.mockito.Mockito;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-
-public class ProtocolConfigTest {
-
-    @Test
-    public void testDestroy() throws Exception {
-        Protocol protocol = Mockito.mock(Protocol.class);
-        MockProtocol2.delegate = protocol;
-        ProtocolConfig protocolConfig = new ProtocolConfig();
-        protocolConfig.setName(""mockprotocol2"");
-        protocolConfig.destroy();
-        Mockito.verify(protocol).destroy();
-    }
-
-    @Test
-    public void testName() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(""name"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProtocolConfig.appendParameters(parameters, protocol);
-        assertThat(protocol.getName(), equalTo(""name""));
-        assertThat(protocol.getId(), equalTo(""name""));
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testHost() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setHost(""host"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProtocolConfig.appendParameters(parameters, protocol);
-        assertThat(protocol.getHost(), equalTo(""host""));
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testPort() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setPort(8080);
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProtocolConfig.appendParameters(parameters, protocol);
-        assertThat(protocol.getPort(), equalTo(8080));
-        assertThat(parameters.isEmpty(), is(true));
-    }
-
-    @Test
-    public void testPath() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setContextpath(""context-path"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProtocolConfig.appendParameters(parameters, protocol);
-        assertThat(protocol.getPath(), equalTo(""context-path""));
-        assertThat(protocol.getContextpath(), equalTo(""context-path""));
-        assertThat(parameters.isEmpty(), is(true));
-        protocol.setPath(""path"");
-        assertThat(protocol.getPath(), equalTo(""path""));
-        assertThat(protocol.getContextpath(), equalTo(""path""));
-    }
-
-    @Test
-    public void testCorethreads() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setCorethreads(10);
-        assertThat(protocol.getCorethreads(), is(10));
-    }
-
-    @Test
-    public void testThreads() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setThreads(10);
-        assertThat(protocol.getThreads(), is(10));
-    }
-
-    @Test
-    public void testIothreads() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setIothreads(10);
-        assertThat(protocol.getIothreads(), is(10));
-    }
-
-    @Test
-    public void testQueues() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setQueues(10);
-        assertThat(protocol.getQueues(), is(10));
-    }
-
-    @Test
-    public void testAccepts() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setAccepts(10);
-        assertThat(protocol.getAccepts(), is(10));
-    }
-
-    @Test
-    public void testCodec() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(""dubbo"");
-        protocol.setCodec(""mockcodec"");
-        assertThat(protocol.getCodec(), equalTo(""mockcodec""));
-    }
-
-    @Test
-    public void testAccesslog() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setAccesslog(""access.log"");
-        assertThat(protocol.getAccesslog(), equalTo(""access.log""));
-    }
-
-    @Test
-    public void testTelnet() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setTelnet(""mocktelnethandler"");
-        assertThat(protocol.getTelnet(), equalTo(""mocktelnethandler""));
-    }
-
-    @Test
-    public void testRegister() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setRegister(true);
-        assertThat(protocol.isRegister(), is(true));
-    }
-
-    @Test
-    public void testTransporter() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setTransporter(""mocktransporter"");
-        assertThat(protocol.getTransporter(), equalTo(""mocktransporter""));
-    }
-
-    @Test
-    public void testExchanger() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setExchanger(""mockexchanger"");
-        assertThat(protocol.getExchanger(), equalTo(""mockexchanger""));
-    }
-
-    @Test
-    public void testDispatcher() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setDispatcher(""mockdispatcher"");
-        assertThat(protocol.getDispatcher(), equalTo(""mockdispatcher""));
-    }
-
-    @Test
-    public void testNetworker() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setNetworker(""networker"");
-        assertThat(protocol.getNetworker(), equalTo(""networker""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setParameters(Collections.singletonMap(""k1"", ""v1""));
-        assertThat(protocol.getParameters(), hasEntry(""k1"", ""v1""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setDefault(true);
-        assertThat(protocol.isDefault(), is(true));
-    }
-
-    @Test
-    public void testKeepAlive() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setKeepAlive(true);
-        assertThat(protocol.getKeepAlive(), is(true));
-    }
-
-    @Test
-    public void testOptimizer() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setOptimizer(""optimizer"");
-        assertThat(protocol.getOptimizer(), equalTo(""optimizer""));
-    }
-
-    @Test
-    public void testExtension() throws Exception {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setExtension(""extension"");
-        assertThat(protocol.getExtension(), equalTo(""extension""));
-    }
-}
@@ -1,219 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
-
-public class ProviderConfigTest {
-    @Test
-    public void testProtocol() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setProtocol(""protocol"");
-        assertThat(provider.getProtocol().getName(), equalTo(""protocol""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setDefault(true);
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.isDefault(), is(true));
-        assertThat(parameters, not(hasKey(""default"")));
-    }
-
-    @Test
-    public void testHost() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setHost(""demo-host"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getHost(), equalTo(""demo-host""));
-        assertThat(parameters, not(hasKey(""host"")));
-    }
-
-    @Test
-    public void testPort() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setPort(8080);
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getPort(), is(8080));
-        assertThat(parameters, not(hasKey(""port"")));
-    }
-
-    @Test
-    public void testPath() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setPath(""/path"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getPath(), equalTo(""/path""));
-        assertThat(provider.getContextpath(), equalTo(""/path""));
-        assertThat(parameters, not(hasKey(""path"")));
-    }
-
-    @Test
-    public void testContextPath() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setContextpath(""/context-path"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getContextpath(), equalTo(""/context-path""));
-        assertThat(parameters, not(hasKey(""/context-path"")));
-    }
-
-    @Test
-    public void testThreadpool() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setThreadpool(""mockthreadpool"");
-        assertThat(provider.getThreadpool(), equalTo(""mockthreadpool""));
-    }
-
-    @Test
-    public void testThreads() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setThreads(10);
-        assertThat(provider.getThreads(), is(10));
-    }
-
-    @Test
-    public void testIothreads() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setIothreads(10);
-        assertThat(provider.getIothreads(), is(10));
-    }
-
-    @Test
-    public void testQueues() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setQueues(10);
-        assertThat(provider.getQueues(), is(10));
-    }
-
-    @Test
-    public void testAccepts() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setAccepts(10);
-        assertThat(provider.getAccepts(), is(10));
-    }
-
-    @Test
-    public void testCharset() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setCharset(""utf-8"");
-        assertThat(provider.getCharset(), equalTo(""utf-8""));
-    }
-
-    @Test
-    public void testPayload() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setPayload(10);
-        assertThat(provider.getPayload(), is(10));
-    }
-
-    @Test
-    public void testBuffer() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setBuffer(10);
-        assertThat(provider.getBuffer(), is(10));
-    }
-
-    @Test
-    public void testServer() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setServer(""demo-server"");
-        assertThat(provider.getServer(), equalTo(""demo-server""));
-    }
-
-    @Test
-    public void testClient() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setClient(""client"");
-        assertThat(provider.getClient(), equalTo(""client""));
-    }
-
-    @Test
-    public void testTelnet() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setTelnet(""mocktelnethandler"");
-        assertThat(provider.getTelnet(), equalTo(""mocktelnethandler""));
-    }
-
-    @Test
-    public void testPrompt() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setPrompt(""#"");
-        Map<String, String> parameters = new HashMap<String, String>();
-        ProviderConfig.appendParameters(parameters, provider);
-        assertThat(provider.getPrompt(), equalTo(""#""));
-        assertThat(parameters, hasEntry(""prompt"", ""%23""));
-    }
-
-    @Test
-    public void testStatus() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setStatus(""mockstatuschecker"");
-        assertThat(provider.getStatus(), equalTo(""mockstatuschecker""));
-    }
-
-    @Test
-    public void testTransporter() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setTransporter(""mocktransporter"");
-        assertThat(provider.getTransporter(), equalTo(""mocktransporter""));
-    }
-
-    @Test
-    public void testExchanger() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setExchanger(""mockexchanger"");
-        assertThat(provider.getExchanger(), equalTo(""mockexchanger""));
-    }
-
-    @Test
-    public void testDispatcher() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setDispatcher(""mockdispatcher"");
-        assertThat(provider.getDispatcher(), equalTo(""mockdispatcher""));
-    }
-
-    @Test
-    public void testNetworker() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setNetworker(""networker"");
-        assertThat(provider.getNetworker(), equalTo(""networker""));
-    }
-
-    @Test
-    public void testWait() throws Exception {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setWait(10);
-        assertThat(provider.getWait(), equalTo(10));
-    }
-}
@@ -1,108 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.provider.impl.DemoServiceImpl;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-public class ReferenceConfigTest {
-
-    @Test
-    public void testInjvm() throws Exception {
-        ApplicationConfig application = new ApplicationConfig();
-        application.setName(""test-protocol-random-port"");
-
-        RegistryConfig registry = new RegistryConfig();
-        registry.setAddress(""multicast://224.5.6.7:1234"");
-
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(""dubbo"");
-
-        ServiceConfig<DemoService> demoService;
-        demoService = new ServiceConfig<DemoService>();
-        demoService.setInterface(DemoService.class);
-        demoService.setRef(new DemoServiceImpl());
-        demoService.setApplication(application);
-        demoService.setRegistry(registry);
-        demoService.setProtocol(protocol);
-
-        ReferenceConfig<DemoService> rc = new ReferenceConfig<DemoService>();
-        rc.setApplication(application);
-        rc.setRegistry(registry);
-        rc.setInterface(DemoService.class.getName());
-        rc.setInjvm(false);
-
-        try {
-            demoService.export();
-            rc.get();
-            Assert.assertTrue(!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(
-                    rc.getInvoker().getUrl().getProtocol()));
-        } finally {
-            demoService.unexport();
-        }
-    }
-    /**
-     * unit test for dubbo-1765
-     */
-    @Test
-    public void testReferenceRetry() {
-        ApplicationConfig application = new ApplicationConfig();
-        application.setName(""test-reference-retry"");
-        RegistryConfig registry = new RegistryConfig();
-        registry.setAddress(""multicast://224.5.6.7:1234"");
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(""dubbo"");
-
-        ReferenceConfig<DemoService> rc = new ReferenceConfig<DemoService>();
-        rc.setApplication(application);
-        rc.setRegistry(registry);
-        rc.setInterface(DemoService.class.getName());
-
-        boolean success = false;
-        DemoService demoService = null;
-        try {
-            demoService = rc.get();
-            success = true;
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        Assert.assertFalse(success);
-        Assert.assertNull(demoService);
-
-        ServiceConfig<DemoService> sc = new ServiceConfig<DemoService>();
-        sc.setInterface(DemoService.class);
-        sc.setRef(new DemoServiceImpl());
-        sc.setApplication(application);
-        sc.setRegistry(registry);
-        sc.setProtocol(protocol);
-
-        try {
-            sc.export();
-            demoService = rc.get();
-            success = true;
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        Assert.assertTrue(success);
-        Assert.assertNotNull(demoService);
-
-    }
-}
\ No newline at end of file
@@ -1,178 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
-
-public class RegistryConfigTest {
-    @Test
-    public void testProtocol() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setProtocol(""protocol"");
-        assertThat(registry.getProtocol(), equalTo(registry.getProtocol()));
-    }
-
-    @Test
-    public void testAddress() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setAddress(""localhost"");
-        assertThat(registry.getAddress(), equalTo(""localhost""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        RegistryConfig.appendParameters(parameters, registry);
-        assertThat(parameters, not(hasKey(""address"")));
-    }
-
-    @Test
-    public void testUsername() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setUsername(""username"");
-        assertThat(registry.getUsername(), equalTo(""username""));
-    }
-
-    @Test
-    public void testPassword() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setPassword(""password"");
-        assertThat(registry.getPassword(), equalTo(""password""));
-    }
-
-    @Test
-    public void testWait() throws Exception {
-        try {
-            RegistryConfig registry = new RegistryConfig();
-            registry.setWait(10);
-            assertThat(registry.getWait(), is(10));
-            assertThat(System.getProperty(Constants.SHUTDOWN_WAIT_KEY), equalTo(""10""));
-        } finally {
-            System.clearProperty(Constants.SHUTDOWN_TIMEOUT_KEY);
-        }
-    }
-
-    @Test
-    public void testCheck() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setCheck(true);
-        assertThat(registry.isCheck(), is(true));
-    }
-
-    @Test
-    public void testFile() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setFile(""file"");
-        assertThat(registry.getFile(), equalTo(""file""));
-    }
-
-    @Test
-    public void testTransporter() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setTransporter(""transporter"");
-        assertThat(registry.getTransporter(), equalTo(""transporter""));
-    }
-
-    @Test
-    public void testClient() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setClient(""client"");
-        assertThat(registry.getClient(), equalTo(""client""));
-    }
-
-    @Test
-    public void testTimeout() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setTimeout(10);
-        assertThat(registry.getTimeout(), is(10));
-    }
-
-    @Test
-    public void testSession() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setSession(10);
-        assertThat(registry.getSession(), is(10));
-    }
-
-    @Test
-    public void testDynamic() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setDynamic(true);
-        assertThat(registry.isDynamic(), is(true));
-    }
-
-    @Test
-    public void testRegister() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setRegister(true);
-        assertThat(registry.isRegister(), is(true));
-    }
-
-    @Test
-    public void testSubscribe() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setSubscribe(true);
-        assertThat(registry.isSubscribe(), is(true));
-    }
-
-    @Test
-    public void testCluster() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setCluster(""cluster"");
-        assertThat(registry.getCluster(), equalTo(""cluster""));
-    }
-
-    @Test
-    public void testGroup() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setGroup(""group"");
-        assertThat(registry.getGroup(), equalTo(""group""));
-    }
-
-    @Test
-    public void testVersion() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setVersion(""1.0.0"");
-        assertThat(registry.getVersion(), equalTo(""1.0.0""));
-    }
-
-    @Test
-    public void testParameters() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setParameters(Collections.singletonMap(""k1"", ""v1""));
-        assertThat(registry.getParameters(), hasEntry(""k1"", ""v1""));
-        Map<String, String> parameters = new HashMap<String, String>();
-        RegistryConfig.appendParameters(parameters, registry);
-        assertThat(parameters, hasEntry(""k1"", ""v1""));
-    }
-
-    @Test
-    public void testDefault() throws Exception {
-        RegistryConfig registry = new RegistryConfig();
-        registry.setDefault(true);
-        assertThat(registry.isDefault(), is(true));
-    }
-}
@@ -1,205 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.api.Greeting;
-import org.apache.dubbo.config.mock.TestProxyFactory;
-import org.apache.dubbo.config.provider.impl.DemoServiceImpl;
-import org.apache.dubbo.config.mock.MockProtocol2;
-import org.apache.dubbo.config.mock.MockRegistryFactory2;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.service.GenericService;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.mockito.Mockito;
-
-import java.util.Collections;
-
-import static org.apache.dubbo.common.Constants.GENERIC_SERIALIZATION_BEAN;
-import static org.apache.dubbo.common.Constants.GENERIC_SERIALIZATION_DEFAULT;
-import static org.apache.dubbo.common.Constants.GENERIC_SERIALIZATION_NATIVE_JAVA;
-import static org.hamcrest.CoreMatchers.containsString;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.hasSize;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.withSettings;
-
-public class ServiceConfigTest {
-    private Protocol protocolDelegate = Mockito.mock(Protocol.class);
-    private Registry registryDelegate = Mockito.mock(Registry.class);
-    private Exporter exporter = Mockito.mock(Exporter.class);
-    private ServiceConfig<DemoServiceImpl> service = new ServiceConfig<DemoServiceImpl>();
-    private ServiceConfig<DemoServiceImpl> service2 = new ServiceConfig<DemoServiceImpl>();
-
-
-    @Before
-    public void setUp() throws Exception {
-        MockProtocol2.delegate = protocolDelegate;
-        MockRegistryFactory2.registry = registryDelegate;
-        Mockito.when(protocolDelegate.export(Mockito.any(Invoker.class))).thenReturn(exporter);
-
-        ApplicationConfig app = new ApplicationConfig(""app"");
-
-        ProtocolConfig protocolConfig = new ProtocolConfig();
-        protocolConfig.setName(""mockprotocol2"");
-
-        ProviderConfig provider = new ProviderConfig();
-        provider.setExport(true);
-        provider.setProtocol(protocolConfig);
-
-        RegistryConfig registry = new RegistryConfig();
-        registry.setProtocol(""mockprotocol2"");
-
-        ArgumentConfig argument = new ArgumentConfig();
-        argument.setIndex(0);
-        argument.setCallback(false);
-
-        MethodConfig method = new MethodConfig();
-        method.setName(""echo"");
-        method.setArguments(Collections.singletonList(argument));
-
-        service.setProvider(provider);
-        service.setApplication(app);
-        service.setRegistry(registry);
-        service.setInterface(DemoService.class);
-        service.setRef(new DemoServiceImpl());
-        service.setMethods(Collections.singletonList(method));
-
-        service2.setProvider(provider);
-        service2.setApplication(app);
-        service2.setRegistry(registry);
-        service2.setInterface(DemoService.class);
-        service2.setRef(new DemoServiceImpl());
-        service2.setMethods(Collections.singletonList(method));
-        service2.setProxy(""testproxyfactory"");
-    }
-
-    @Test
-    public void testExport() throws Exception {
-        service.export();
-
-        assertThat(service.getExportedUrls(), hasSize(1));
-        URL url = service.toUrl();
-        assertThat(url.getProtocol(), equalTo(""mockprotocol2""));
-        assertThat(url.getPath(), equalTo(DemoService.class.getName()));
-        assertThat(url.getParameters(), hasEntry(Constants.ANYHOST_KEY, ""true""));
-        assertThat(url.getParameters(), hasEntry(Constants.APPLICATION_KEY, ""app""));
-        assertThat(url.getParameters(), hasKey(Constants.BIND_IP_KEY));
-        assertThat(url.getParameters(), hasKey(Constants.BIND_PORT_KEY));
-        assertThat(url.getParameters(), hasEntry(Constants.DEFAULT_KEY + ""."" + Constants.EXPORT_KEY, ""true""));
-        assertThat(url.getParameters(), hasEntry(Constants.EXPORT_KEY, ""true""));
-        assertThat(url.getParameters(), hasEntry(""echo.0.callback"", ""false""));
-        assertThat(url.getParameters(), hasEntry(Constants.GENERIC_KEY, ""false""));
-        assertThat(url.getParameters(), hasEntry(Constants.INTERFACE_KEY, DemoService.class.getName()));
-        assertThat(url.getParameters(), hasKey(Constants.METHODS_KEY));
-        assertThat(url.getParameters().get(Constants.METHODS_KEY), containsString(""echo""));
-        assertThat(url.getParameters(), hasEntry(Constants.SIDE_KEY, Constants.PROVIDER));
-        Mockito.verify(protocolDelegate).export(Mockito.any(Invoker.class));
-    }
-
-    @Test
-    public void testProxy() throws Exception {
-        service2.export();
-
-        assertThat(service2.getExportedUrls(), hasSize(1));
-        assertEquals(2, TestProxyFactory.count); // local injvm and registry protocol, so expected is 2
-    }
-
-    @Test
-    @Ignore(""cannot pass in travis"")
-    public void testUnexport() throws Exception {
-        System.setProperty(Constants.SHUTDOWN_WAIT_KEY, ""0"");
-        try {
-            service.export();
-            service.unexport();
-            Thread.sleep(1000);
-            Mockito.verify(exporter, Mockito.atLeastOnce()).unexport();
-        } finally {
-            System.clearProperty(Constants.SHUTDOWN_TIMEOUT_KEY);
-        }
-    }
-
-    @Test
-    public void testInterfaceClass() throws Exception {
-        ServiceConfig<Greeting> service = new ServiceConfig<Greeting>();
-        service.setInterface(Greeting.class.getName());
-        service.setRef(Mockito.mock(Greeting.class));
-        assertThat(service.getInterfaceClass() == Greeting.class, is(true));
-        service = new ServiceConfig<Greeting>();
-        service.setRef(Mockito.mock(Greeting.class, withSettings().extraInterfaces(GenericService.class)));
-        assertThat(service.getInterfaceClass() == GenericService.class, is(true));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testInterface1() throws Exception {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setInterface(DemoServiceImpl.class);
-    }
-
-    @Test
-    public void testInterface2() throws Exception {
-        ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();
-        service.setInterface(DemoService.class);
-        assertThat(service.getInterface(), equalTo(DemoService.class.getName()));
-    }
-
-    @Test
-    public void testProvider() throws Exception {
-        ServiceConfig service = new ServiceConfig();
-        ProviderConfig provider = new ProviderConfig();
-        service.setProvider(provider);
-        assertThat(service.getProvider(), is(provider));
-    }
-
-    @Test
-    public void testGeneric1() throws Exception {
-        ServiceConfig service = new ServiceConfig();
-        service.setGeneric(GENERIC_SERIALIZATION_DEFAULT);
-        assertThat(service.getGeneric(), equalTo(GENERIC_SERIALIZATION_DEFAULT));
-        service.setGeneric(GENERIC_SERIALIZATION_NATIVE_JAVA);
-        assertThat(service.getGeneric(), equalTo(GENERIC_SERIALIZATION_NATIVE_JAVA));
-        service.setGeneric(GENERIC_SERIALIZATION_BEAN);
-        assertThat(service.getGeneric(), equalTo(GENERIC_SERIALIZATION_BEAN));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testGeneric2() throws Exception {
-        ServiceConfig service = new ServiceConfig();
-        service.setGeneric(""illegal"");
-    }
-
-    @Test
-    public void testUniqueServiceName() throws Exception {
-        ServiceConfig<Greeting> service = new ServiceConfig<Greeting>();
-        service.setGroup(""dubbo"");
-        service.setInterface(Greeting.class);
-        service.setVersion(""1.0.0"");
-        assertThat(service.getUniqueServiceName(), equalTo(""dubbo/"" + Greeting.class.getName() + "":1.0.0""));
-    }
-}
@@ -1,23 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-public interface Box {
-
-    String getName();
-
-}
\ No newline at end of file
@@ -1,42 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-/**
- * DemoException
- */
-public class DemoException extends Exception {
-
-    private static final long serialVersionUID = -8213943026163641747L;
-
-    public DemoException() {
-        super();
-    }
-
-    public DemoException(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-    public DemoException(String message) {
-        super(message);
-    }
-
-    public DemoException(Throwable cause) {
-        super(cause);
-    }
-
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-import java.util.List;
-
-
-/**
- * DemoService
- */
-public interface DemoService {
-
-    String sayName(String name);
-
-    Box getBox();
-
-    void throwDemoException() throws DemoException;
-
-    List<User> getUsers(List<User> users);
-
-    int echo(int i);
-
-}
\ No newline at end of file
@@ -1,24 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-import org.apache.dubbo.common.extension.SPI;
-
-@SPI
-public interface Greeting {
-    String hello();
-}
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.api;
-
-import java.io.Serializable;
-
-/**
- * User
- */
-public class User implements Serializable {
-
-    private static final long serialVersionUID = 1L;
-
-    private String name;
-
-    public User() {
-    }
-
-    public User(String name) {
-        this.name = name;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    @Override
-    public int hashCode() {
-        return name == null ? -1 : name.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (!(obj instanceof User)) {
-            return false;
-        }
-        User other = (User) obj;
-        if (this == other) {
-            return true;
-        }
-        if (name != null && other.name != null) {
-            return name.equals(other.name);
-        }
-        return false;
-    }
-
-}
@@ -1,26 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.cache;
-
-/**
- * ValidationService
- */
-public interface CacheService {
-
-    String findCache(String id);
-
-}
@@ -1,32 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.cache;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * ValidationServiceImpl
- */
-public class CacheServiceImpl implements CacheService {
-
-    private final AtomicInteger i = new AtomicInteger();
-
-    public String findCache(String id) {
-        return ""request: "" + id + "", response: "" + i.getAndIncrement();
-    }
-
-}
@@ -1,119 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.cache;
-
-import org.apache.dubbo.cache.Cache;
-import org.apache.dubbo.cache.CacheFactory;
-import org.apache.dubbo.cache.support.threadlocal.ThreadLocalCache;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.MethodConfig;
-import org.apache.dubbo.config.ProtocolConfig;
-import org.apache.dubbo.config.ReferenceConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.RpcInvocation;
-
-import junit.framework.TestCase;
-import org.junit.Test;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * CacheTest
- */
-public class CacheTest extends TestCase {
-
-    private void testCache(String type) throws Exception {
-        ServiceConfig<CacheService> service = new ServiceConfig<CacheService>();
-        service.setApplication(new ApplicationConfig(""cache-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""injvm""));
-        service.setInterface(CacheService.class.getName());
-        service.setRef(new CacheServiceImpl());
-        service.export();
-        try {
-            ReferenceConfig<CacheService> reference = new ReferenceConfig<CacheService>();
-            reference.setApplication(new ApplicationConfig(""cache-consumer""));
-            reference.setInterface(CacheService.class);
-            reference.setUrl(""injvm://127.0.0.1?scope=remote&cache=true"");
-
-            MethodConfig method = new MethodConfig();
-            method.setName(""findCache"");
-            method.setCache(type);
-            reference.setMethods(Arrays.asList(method));
-
-            CacheService cacheService = reference.get();
-            try {
-                // verify cache, same result is returned for multiple invocations (in fact, the return value increases
-                // on every invocation on the server side)
-                String fix = null;
-                for (int i = 0; i < 3; i++) {
-                    String result = cacheService.findCache(""0"");
-                    assertTrue(fix == null || fix.equals(result));
-                    fix = result;
-                    Thread.sleep(100);
-                }
-
-                if (""lru"".equals(type)) {
-                    // default cache.size is 1000 for LRU, should have cache expired if invoke more than 1001 times
-                    for (int n = 0; n < 1001; n++) {
-                        String pre = null;
-                        for (int i = 0; i < 10; i++) {
-                            String result = cacheService.findCache(String.valueOf(n));
-                            assertTrue(pre == null || pre.equals(result));
-                            pre = result;
-                        }
-                    }
-
-                    // verify if the first cache item is expired in LRU cache
-                    String result = cacheService.findCache(""0"");
-                    assertFalse(fix == null || fix.equals(result));
-                }
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testCache() throws Exception {
-        testCache(""lru"");
-        testCache(""threadlocal"");
-    }
-
-    @Test
-    public void testCacheProvider() throws Exception {
-        CacheFactory cacheFactory = ExtensionLoader.getExtensionLoader(CacheFactory.class).getAdaptiveExtension();
-
-        Map<String, String> parameters = new HashMap<String, String>();
-        parameters.put(""findCache.cache"", ""threadlocal"");
-        URL url = new URL(""dubbo"", ""127.0.0.1"", 29582, ""org.apache.dubbo.config.cache.CacheService"", parameters);
-
-        Invocation invocation = new RpcInvocation(""findCache"", new Class[]{String.class}, new String[]{""0""}, null, null);
-
-        Cache cache = cacheFactory.getCache(url, invocation);
-        assertTrue(cache instanceof ThreadLocalCache);
-    }
-
-}
@@ -1,35 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.consumer;
-
-import org.apache.dubbo.config.api.DemoService;
-
-import org.springframework.beans.factory.annotation.Autowired;
-
-/**
- * DemoAction
- */
-public class DemoActionByAnnotation {
-
-    @Autowired
-    private DemoService demoService;
-
-    public DemoService getDemoService() {
-        return demoService;
-    }
-
-}
\ No newline at end of file
@@ -1,36 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.consumer;
-
-import org.apache.dubbo.config.api.DemoService;
-
-/**
- * DemoAction
- */
-public class DemoActionBySetter {
-
-    private DemoService demoService;
-
-    public DemoService getDemoService() {
-        return demoService;
-    }
-
-    public void setDemoService(DemoService demoService) {
-        this.demoService = demoService;
-    }
-
-}
\ No newline at end of file
@@ -1,31 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.consumer;
-
-import org.aopalliance.intercept.MethodInterceptor;
-import org.aopalliance.intercept.MethodInvocation;
-
-/**
- * DemoInterceptor
- */
-public class DemoInterceptor implements MethodInterceptor {
-
-    public Object invoke(MethodInvocation invocation) throws Throwable {
-        return ""aop:"" + invocation.proceed();
-    }
-
-}
\ No newline at end of file
@@ -1,59 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.invoker;
-
-import org.apache.dubbo.config.api.Greeting;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mockito;
-
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertThat;
-
-public class DelegateProviderMetaDataInvokerTest {
-    private ServiceConfig service;
-    private Invoker<Greeting> invoker;
-
-    @Before
-    public void setUp() throws Exception {
-        service = Mockito.mock(ServiceConfig.class);
-        invoker = Mockito.mock(Invoker.class);
-    }
-
-    @Test
-    public void testDelegate() throws Exception {
-        DelegateProviderMetaDataInvoker<Greeting> delegate =
-                new DelegateProviderMetaDataInvoker<Greeting>(invoker, service);
-        delegate.getInterface();
-        Mockito.verify(invoker).getInterface();
-        delegate.getUrl();
-        Mockito.verify(invoker).getUrl();
-        delegate.isAvailable();
-        Mockito.verify(invoker).isAvailable();
-        Invocation invocation = Mockito.mock(Invocation.class);
-        delegate.invoke(invocation);
-        Mockito.verify(invoker).invoke(invocation);
-        delegate.destroy();
-        Mockito.verify(invoker).destroy();
-        assertThat(delegate.getMetadata(), sameInstance(service));
-    }
-
-}
@@ -1,21 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-public class GreetingLocal1 {
-
-}
@@ -1,26 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.config.api.Greeting;
-
-public class GreetingLocal2 implements Greeting {
-    @Override
-    public String hello() {
-        return ""local"";
-    }
-}
@@ -1,32 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.config.api.Greeting;
-
-public class GreetingLocal3 implements Greeting {
-    private Greeting greeting;
-
-    public GreetingLocal3(Greeting greeting) {
-        this.greeting = greeting;
-    }
-
-    @Override
-    public String hello() {
-        return null;
-    }
-}
@@ -1,20 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-public class GreetingMock1 {
-}
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.config.api.Greeting;
-
-public class GreetingMock2 implements Greeting {
-    private GreetingMock2() {
-    }
-
-    @Override
-    public String hello() {
-        return ""mock"";
-    }
-}
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.cluster.Cluster;
-import org.apache.dubbo.rpc.cluster.Directory;
-
-public class MockCluster implements Cluster {
-    @Override
-    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
-        return null;
-    }
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.remoting.Channel;
-import org.apache.dubbo.remoting.Codec;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-public class MockCodec implements Codec {
-    @Override
-    public void encode(Channel channel, OutputStream output, Object message) throws IOException {
-
-    }
-
-    @Override
-    public Object decode(Channel channel, InputStream input) throws IOException {
-        return null;
-    }
-}
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.remoting.ChannelHandler;
-import org.apache.dubbo.remoting.Dispatcher;
-
-public class MockDispatcher implements Dispatcher {
-    @Override
-    public ChannelHandler dispatch(ChannelHandler handler, URL url) {
-        return null;
-    }
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.remoting.RemotingException;
-import org.apache.dubbo.remoting.exchange.ExchangeClient;
-import org.apache.dubbo.remoting.exchange.ExchangeHandler;
-import org.apache.dubbo.remoting.exchange.ExchangeServer;
-import org.apache.dubbo.remoting.exchange.Exchanger;
-
-public class MockExchanger implements Exchanger {
-    @Override
-    public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
-        return null;
-    }
-
-    @Override
-    public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {
-        return null;
-    }
-}
@@ -1,34 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.ExporterListener;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockExporterListener implements ExporterListener  {
-    @Override
-    public void exported(Exporter<?> exporter) throws RpcException {
-
-    }
-
-    @Override
-    public void unexported(Exporter<?> exporter) {
-
-    }
-}
@@ -1,30 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.rpc.Filter;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockFilter implements Filter {
-    @Override
-    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        return null;
-    }
-}
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.InvokerListener;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockInvokerListener implements InvokerListener {
-    @Override
-    public void referred(Invoker<?> invoker) throws RpcException {
-
-    }
-
-    @Override
-    public void destroyed(Invoker<?> invoker) {
-
-    }
-}
@@ -1,32 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.cluster.LoadBalance;
-
-import java.util.List;
-
-public class MockLoadBalance implements LoadBalance {
-    @Override
-    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
-        return null;
-    }
-}
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockProtocol implements Protocol {
-
-    /* (non-Javadoc)
-     * @see org.apache.dubbo.rpc.Protocol#getDefaultPort()
-     */
-    @Override
-    public int getDefaultPort() {
-
-        return 0;
-    }
-
-    /* (non-Javadoc)
-     * @see org.apache.dubbo.rpc.Protocol#export(org.apache.dubbo.rpc.Invoker)
-     */
-    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
-        return null;
-    }
-
-    /* (non-Javadoc)
-     * @see org.apache.dubbo.rpc.Protocol#refer(java.lang.Class, org.apache.dubbo.common.URL)
-     */
-    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
-
-        final URL u = url;
-
-        return new Invoker<T>() {
-            @Override
-            public Class<T> getInterface() {
-                return null;
-            }
-
-            public URL getUrl() {
-                return u;
-            }
-
-            @Override
-            public boolean isAvailable() {
-                return true;
-            }
-
-            public Result invoke(Invocation invocation) throws RpcException {
-                return null;
-            }
-
-            @Override
-            public void destroy() {
-
-            }
-        };
-    }
-
-    /* (non-Javadoc)
-     * @see org.apache.dubbo.rpc.Protocol#destroy()
-     */
-    @Override
-    public void destroy() {
-
-    }
-
-}
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockProtocol2 implements Protocol {
-    public static Protocol delegate;
-
-    @Override
-    public int getDefaultPort() {
-        return delegate.getDefaultPort();
-    }
-
-    @Override
-    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
-        return delegate.export(invoker);
-    }
-
-    @Override
-    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
-        return delegate.refer(type, url);
-    }
-
-    @Override
-    public void destroy() {
-        delegate.destroy();
-    }
-}
@@ -1,39 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.ProxyFactory;
-import org.apache.dubbo.rpc.RpcException;
-
-public class MockProxyFactory implements ProxyFactory {
-    @Override
-    public <T> T getProxy(Invoker<T> invoker) throws RpcException {
-        return null;
-    }
-
-    @Override
-    public <T> T getProxy(Invoker<T> invoker, boolean generic) throws RpcException {
-        return null;
-    }
-
-    @Override
-    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException {
-        return null;
-    }
-}
@@ -1,108 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.registry.NotifyListener;
-import org.apache.dubbo.registry.Registry;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * TODO Comment of MockRegistry
- */
-public class MockRegistry implements Registry {
-
-    static URL subscribedUrl = new URL(""null"", ""0.0.0.0"", 0);
-
-    public static URL getSubscribedUrl() {
-        return subscribedUrl;
-    }
-
-    /* 
-     * @see org.apache.dubbo.common.Node#getUrl()
-     */
-    public URL getUrl() {
-        return null;
-    }
-
-    /* 
-     * @see org.apache.dubbo.common.Node#isAvailable()
-     */
-    @Override
-    public boolean isAvailable() {
-        return true;
-    }
-
-    /* 
-     * @see org.apache.dubbo.common.Node#destroy()
-     */
-    @Override
-    public void destroy() {
-
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#register(org.apache.dubbo.common.URL)
-     */
-    @Override
-    public void register(URL url) {
-
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#unregister(org.apache.dubbo.common.URL)
-     */
-    @Override
-    public void unregister(URL url) {
-
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#subscribe(org.apache.dubbo.common.URL, org.apache.dubbo.registry.NotifyListener)
-     */
-    @Override
-    public void subscribe(URL url, NotifyListener listener) {
-        this.subscribedUrl = url;
-        List<URL> urls = new ArrayList<URL>();
-
-        urls.add(url.setProtocol(""mockprotocol"")
-                .removeParameter(Constants.CATEGORY_KEY)
-                .addParameter(Constants.METHODS_KEY, ""sayHello""));
-
-        listener.notify(urls);
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#unsubscribe(org.apache.dubbo.common.URL, org.apache.dubbo.registry.NotifyListener)
-     */
-    @Override
-    public void unsubscribe(URL url, NotifyListener listener) {
-
-    }
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryService#lookup(org.apache.dubbo.common.URL)
-     */
-    @Override
-    public List<URL> lookup(URL url) {
-        return null;
-    }
-
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.registry.RegistryFactory;
-
-/**
- * TODO Comment of MockRegistryFactory
- */
-public class MockRegistryFactory implements RegistryFactory {
-
-    /* 
-     * @see org.apache.dubbo.registry.RegistryFactory#getRegistry(org.apache.dubbo.common.URL)
-     */
-    @Override
-    public Registry getRegistry(URL url) {
-
-        return new MockRegistry();
-    }
-
-}
@@ -1,31 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.registry.RegistryFactory;
-
-public class MockRegistryFactory2 implements RegistryFactory {
-    public static Registry registry;
-
-    @Override
-    public Registry getRegistry(URL url) {
-        return registry;
-    }
-}
@@ -1,28 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.status.Status;
-import org.apache.dubbo.common.status.StatusChecker;
-
-public class MockStatusChecker implements StatusChecker {
-    @Override
-    public Status check() {
-        return null;
-    }
-}
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.remoting.Channel;
-import org.apache.dubbo.remoting.RemotingException;
-import org.apache.dubbo.remoting.telnet.TelnetHandler;
-
-public class MockTelnetHandler implements TelnetHandler {
-    @Override
-    public String telnet(Channel channel, String message) throws RemotingException {
-        return null;
-    }
-}
@@ -1,30 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.threadpool.ThreadPool;
-
-import java.util.concurrent.Executor;
-
-public class MockThreadPool implements ThreadPool  {
-    @Override
-    public Executor getExecutor(URL url) {
-        return null;
-    }
-}
@@ -1,41 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.remoting.ChannelHandler;
-import org.apache.dubbo.remoting.Client;
-import org.apache.dubbo.remoting.RemotingException;
-import org.apache.dubbo.remoting.Server;
-import org.apache.dubbo.remoting.Transporter;
-import org.mockito.Mockito;
-
-public class MockTransporter implements Transporter {
-    private Server server = Mockito.mock(Server.class);
-    private Client client = Mockito.mock(Client.class);
-
-    @Override
-    public Server bind(URL url, ChannelHandler handler) throws RemotingException {
-        return server;
-    }
-
-    @Override
-    public Client connect(URL url, ChannelHandler handler) throws RemotingException {
-        return client;
-    }
-}
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.config.mock;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.proxy.jdk.JdkProxyFactory;
-
-public class TestProxyFactory extends JdkProxyFactory {
-    public static int count = 0;
-
-    @Override
-    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException {
-        count++;
-        return super.getInvoker(proxy, type, url);
-    }
-}
@@ -1,51 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.provider.impl;
-
-import org.apache.dubbo.config.api.Box;
-import org.apache.dubbo.config.api.DemoException;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.api.User;
-
-import java.util.List;
-
-/**
- * DemoServiceImpl
- */
-public class DemoServiceImpl implements DemoService {
-
-    public String sayName(String name) {
-        return ""say:"" + name;
-    }
-
-    public Box getBox() {
-        return null;
-    }
-
-    public void throwDemoException() throws DemoException {
-        throw new DemoException(""DemoServiceImpl"");
-    }
-
-    public List<User> getUsers(List<User> users) {
-        return users;
-    }
-
-    public int echo(int i) {
-        return i;
-    }
-
-}
\ No newline at end of file
@@ -1,99 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.url;
-
-
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
-
-public class ExporterSideConfigUrlTest extends UrlTestBase {
-
-    private static final Logger log = LoggerFactory.getLogger(ExporterSideConfigUrlTest.class);
-
-    // ======================================================
-    //   tests start
-    // ======================================================  
-    @BeforeClass
-    public static void start() {
-    }
-
-
-    @Before
-    public void setUp() {
-        initServConf();
-    }
-
-    @After()
-    public void teardown() {
-    }
-
-    @Test
-    public void exporterMethodConfigUrlTest() {
-        verifyExporterUrlGeneration(methodConfForService, methodConfForServiceTable);
-    }
-
-    @Test
-    public void exporterServiceConfigUrlTest() {
-        verifyExporterUrlGeneration(servConf, servConfTable);
-    }
-
-    @Test
-    public void exporterProviderConfigUrlTest() {
-
-        verifyExporterUrlGeneration(provConf, provConfTable);
-    }
-
-    @Test
-    public void exporterRegistryConfigUrlTest() {
-
-        //verifyExporterUrlGeneration(regConfForService, regConfForServiceTable);
-    }
-
-
-    protected <T> void verifyExporterUrlGeneration(T config, Object[][] dataTable) {
-
-        // 1. fill corresponding config with data
-        ////////////////////////////////////////////////////////////
-        fillConfigs(config, dataTable, TESTVALUE1);
-
-        // 2. export service and get url parameter string from db
-        ////////////////////////////////////////////////////////////
-        servConf.export();
-        String paramStringFromDb = getProviderParamString();
-        try {
-            paramStringFromDb = URLDecoder.decode(paramStringFromDb, ""UTF-8"");
-        } catch (UnsupportedEncodingException e) {
-            // impossible
-        }
-
-
-        assertUrlStringWithLocalTable(paramStringFromDb, dataTable, config.getClass().getName(), TESTVALUE1);
-
-
-        // 4. unexport service
-        ////////////////////////////////////////////////////////////
-        servConf.unexport();
-    }
-}
\ No newline at end of file
@@ -1,228 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.url;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.ConsumerConfig;
-import org.apache.dubbo.config.MethodConfig;
-import org.apache.dubbo.config.ReferenceConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.mock.MockRegistry;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import java.util.Arrays;
-
-
-public class InvokerSideConfigUrlTest extends UrlTestBase {
-    private static final Logger log = LoggerFactory.getLogger(InvokerSideConfigUrlTest.class);
-
-    // ======================================================
-    //   invoker related data preparing
-    // ======================================================  
-    private ApplicationConfig appConfForConsumer;
-    private ApplicationConfig appConfForReference;
-    private RegistryConfig regConfForConsumer;
-    private RegistryConfig regConfForReference;
-    private MethodConfig methodConfForReference;
-    private ConsumerConfig consumerConf;
-    private ReferenceConfig<DemoService> refConf;
-
-    private Object appConfForConsumerTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-
-    private Object appConfForReferenceTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-
-    private Object regConfForConsumerTable[][] = {
-//            {""timeout"", ""registry.timeout"", ""int"", 5000, 9000, """", """", """", """", """"}, 
-//            {""file"", ""registry.file"", ""string"", """", ""regConfForServiceTable.log"", """", """", """", """", """"}, 
-//            {""wait"", ""registry.wait"", ""int"", 0, 9000, """", """", """", """", """"}, 
-//            {""transport"", ""registry.transporter"", ""string"", ""netty"", ""mina"", """", """", """", """", """"}, 
-            {""subscribe"", ""subscribe"", ""boolean"", true, false, """", """", """", """", """"},
-            {""dynamic"", ""dynamic"", ""boolean"", true, false, """", """", """", """", """"},
-    };
-
-    private Object regConfForReferenceTable[][] = {
-            {""timeout"", ""registry.timeout"", ""int"", 5000, 9000, """", """", """", """", """"},
-            {""file"", ""registry.file"", ""string"", """", ""regConfForServiceTable.log"", """", """", """", """", """"},
-            {""wait"", ""registry.wait"", ""int"", 0, 9000, """", """", """", """", """"},
-            {""transport"", ""registry.transporter"", ""string"", ""netty"", ""mina"", """", """", """", """", """"},
-            {""subscribe"", ""subscribe"", ""boolean"", true, false, """", """", """", """", """"},
-            {""dynamic"", ""dynamic"", ""boolean"", true, false, """", """", """", """", """"},
-    };
-
-    private Object methodConfForReferenceTable[][] = {
-            {""actives"", ""eatTiger.actives"", ""int"", 0, 90, """", """", """", """", """"},
-            {""executes"", ""eatTiger.executes"", ""int"", 0, 90, """", """", """", """", """"},
-            {""deprecated"", ""eatTiger.deprecated"", ""boolean"", false, true, """", """", """", """", """"},
-            {""async"", ""eatTiger.async"", ""boolean"", false, true, """", """", """", """", """"},
-            {""timeout"", ""eatTiger.timeout"", ""int"", 0, 90, """", """", """", """", """"},
-    };
-
-    private Object refConfTable[][] = {
-//            {""version"", ""version"", ""string"", ""0.0.0"", ""1.2.3"", """", """", """", """", """"}, 
-//            {""group"", ""group"", ""string"", """", ""HaominTest"", """", """", """", """", """"}, 
-
-//            {""delay"", ""delay"", ""int"", 0, 5, """", """", """", """", """"}, // not boolean 
-            {""timeout"", ""timeout"", ""int"", 5000, 3000, """", """", """", """", """"},
-            {""retries"", ""retries"", ""int"", 2, 5, """", """", """", """", """"},
-            {""connections"", ""connections"", ""boolean"", 100, 20, """", """", """", """", """"},
-            {""loadbalance"", ""loadbalance"", ""string"", ""random"", ""roundrobin"", ""leastactive"", """", """", """"},
-            {""async"", ""async"", ""boolean"", false, true, """", """", """", """", """"},
-            //excluded = true
-//            {""generic"", ""generic"", ""boolean"", false, true, """", """", """", """", """"},  
-            {""check"", ""check"", ""boolean"", false, true, """", """", """", """", """"},
-            //{""local"", ""local"", ""string"", ""false"", ""HelloServiceLocal"", ""true"", """", """", """", """"}, 
-            //{""local"", ""local"", ""string"", ""false"", ""true"", """", """", """", """", """"}, 
-            //{""mock"", ""mock"", ""string"", ""false"", ""dubbo.test.HelloServiceMock"", ""true"", """", """", """", """"}, 
-            {""mock"", ""mock"", ""string"", ""false"", ""false"", """", """", """", """", """"},
-            {""proxy"", ""proxy"", ""boolean"", ""javassist"", ""jdk"", """", """", """", """", """"},
-            {""client"", ""client"", ""string"", ""netty"", ""mina"", """", """", """", """", """"},
-            {""client"", ""client"", ""string"", ""netty"", ""mina"", """", """", """", """", """"},
-            {""owner"", ""owner"", ""string"", """", ""haomin,ludvik"", """", """", """", """", """"},
-            {""actives"", ""actives"", ""int"", 0, 30, """", """", """", """", """"},
-            {""cluster"", ""cluster"", ""string"", ""failover"", ""failfast"", ""failsafe"", ""failback"", ""forking"", """", """"},
-            //excluded = true
-//            {""filter"", ""service.filter"", ""string"", ""default"", ""-generic"", """", """", """", """", """"}, 
-            //excluded = true
-//            {""listener"", ""exporter.listener"", ""string"", ""default"", ""-deprecated"", """", """", """", """", """"}, 
-            //{"""", """", """", """", """", """", """", """", """", """"}, 
-    };
-
-    private Object consumerConfTable[][] = {
-            {""timeout"", ""default.timeout"", ""int"", 5000, 8000, """", """", """", """", """"},
-            {""retries"", ""default.retries"", ""int"", 2, 5, """", """", """", """", """"},
-            {""loadbalance"", ""default.loadbalance"", ""string"", ""random"", ""leastactive"", """", """", """", """", """"},
-            {""async"", ""default.async"", ""boolean"", false, true, """", """", """", """", """"},
-            {""connections"", ""default.connections"", ""int"", 100, 5, """", """", """", """", """"},
-//            {""generic"", ""generic"", ""boolean"", false, false, """", """", """", """", """"}, 
-            {""check"", ""check"", ""boolean"", true, false, """", """", """", """", """"},
-            {""proxy"", ""proxy"", ""string"", ""javassist"", ""jdk"", ""javassist"", """", """", """", """"},
-            {""owner"", ""owner"", ""string"", """", ""haomin"", """", """", """", """", """"},
-            {""actives"", ""default.actives"", ""int"", 0, 5, """", """", """", """", """"},
-            {""cluster"", ""default.cluster"", ""string"", ""failover"", ""forking"", """", """", """", """", """"},
-            {""filter"", """", ""string"", """", """", """", """", """", """", """"},
-            {""listener"", """", ""string"", """", """", """", """", """", """", """"},
-//            {"""", """", """", """", """", """", """", """", """", """"}, 
-    };
-
-    // ======================================================
-    //   test Start
-    // ====================================================== 
-
-    @BeforeClass
-    public static void start() {
-        //RegistryController.startRegistryIfAbsence(1);
-    }
-
-
-    @Before
-    public void setUp() {
-        initServConf();
-        initRefConf();
-    }
-
-    @After()
-    public void teardown() {
-        //RegistryServer.reloadCache();
-    }
-
-
-    @Test
-    public void consumerConfUrlTest() {
-        verifyInvokerUrlGeneration(consumerConf, consumerConfTable);
-    }
-
-    @Test
-    public void refConfUrlTest() {
-        verifyInvokerUrlGeneration(refConf, refConfTable);
-    }
-
-    @Ignore(""parameter on register center will not be merged any longer with query parameter request from the consumer"")
-    @Test
-    public void regConfForConsumerUrlTest() {
-        verifyInvokerUrlGeneration(regConfForConsumer, regConfForConsumerTable);
-    }
-
-    // ======================================================
-    //   private helper
-    // ====================================================== 
-    private void initRefConf() {
-
-        appConfForConsumer = new ApplicationConfig();
-        appConfForReference = new ApplicationConfig();
-        regConfForConsumer = new RegistryConfig();
-        regConfForReference = new RegistryConfig();
-        methodConfForReference = new MethodConfig();
-
-        refConf = new ReferenceConfig<DemoService>();
-        consumerConf = new ConsumerConfig();
-
-        methodConfForReference.setName(""sayName"");
-        regConfForReference.setAddress(""127.0.0.1:9090"");
-        regConfForReference.setProtocol(""mockregistry"");
-        appConfForReference.setName(""ConfigTests"");
-        refConf.setInterface(""org.apache.dubbo.config.api.DemoService"");
-
-        refConf.setApplication(appConfForReference);
-        consumerConf.setApplication(appConfForConsumer);
-
-        refConf.setRegistry(regConfForReference);
-        consumerConf.setRegistry(regConfForConsumer);
-
-        refConf.setConsumer(consumerConf);
-
-        refConf.setMethods(Arrays.asList(new MethodConfig[]{methodConfForReference}));
-
-        refConf.setScope(Constants.SCOPE_REMOTE);
-    }
-
-    private <T> void verifyInvokerUrlGeneration(T config, Object[][] dataTable) {
-        servConf.export();
-
-        fillConfigs(config, dataTable, TESTVALUE1);
-        refConf.get();
-
-        String subScribedUrlStr = getSubscribedUrlString();
-
-        System.out.println(""url string=========:"" + subScribedUrlStr);
-        String configName = config.getClass().getName();
-        int column = TESTVALUE1;
-
-        assertUrlStringWithLocalTable(subScribedUrlStr, dataTable, configName, column);
-
-        try {
-            refConf.destroy();
-        } catch (Exception e) {
-        }
-    }
-
-    private String getSubscribedUrlString() {
-        return MockRegistry.getSubscribedUrl().toString();
-    }
-}
\ No newline at end of file
@@ -1,166 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.url;
-
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.config.AbstractConfig;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-
-public class RpcConfigGetSetProxy {
-
-    private static final String RPC_CONFIG_BASECLASS = AbstractConfig.class.getName();
-    private static final Logger log = LoggerFactory.getLogger(RpcConfigGetSetProxy.class);
-
-
-    private Object proxiee = null;
-    private Class<?> proxieeClass = null;
-    private Boolean isOk = false;
-
-    public RpcConfigGetSetProxy(Object p) {
-
-        if (p == null) {
-            return;
-        }
-
-        if (!isKindOf(p.getClass(), RPC_CONFIG_BASECLASS)) {
-            return;
-        }
-
-        proxiee = p;
-        //proxieeClass = c;
-        proxieeClass = p.getClass();
-        isOk = true;
-
-    }
-
-    public static boolean isKindOf(Class<?> c, String type) {
-
-        // get the class def for obj and type
-
-        Class<?> tClass;
-        try {
-            tClass = Class.forName(type);
-        } catch (ClassNotFoundException e) {
-            return false;
-        }
-
-        // check against type and superclasses
-        while (c != null) {
-            if (c == tClass) return true;
-            c = c.getSuperclass();
-        }
-
-        return false;
-    }
-
-    public boolean isOk() {
-        return isOk;
-    }
-
-    public Object setValue(String key, Object value) {
-
-        if (!isOk()) {
-            return null;
-        }
-
-        Method m = findSetMethod(key, value, proxieeClass);
-        return invoke(m, value);
-    }
-
-    public Object getValue(String key) {
-
-        if (!isOk()) {
-            return null;
-        }
-
-        Method m = findGetMethod(key, proxieeClass);
-        return invoke(m, null);
-    }
-
-    private Object invoke(Method m, Object value) {
-
-        if (m == null) {
-            return null;
-        }
-
-        try {
-            if (value == null) {
-                return m.invoke(proxiee, (Object[]) null);
-            } else {
-                return m.invoke(proxiee, value);
-            }
-        } catch (IllegalArgumentException e) {
-            log.error(""IllegalArgumentException"", e);
-            return null;
-        } catch (IllegalAccessException e) {
-            log.error(""IllegalAccessException"", e);
-            return null;
-        } catch (InvocationTargetException e) {
-            log.error(""InvocationTargetException"", e);
-            return null;
-        }
-    }
-
-    private Method findGetMethod(String key, Class<?> clazz) {
-
-        Method m = findMethod(key, null, ""get"", clazz);
-        if (m != null) {
-            return m;
-        }
-
-        return findMethod(key, null, ""is"", clazz);
-    }
-
-    private Method findSetMethod(String key, Object value, Class<?> clazz) {
-
-        return findMethod(key, value, ""set"", clazz);
-    }
-
-    private Method getMethod(String methodName, Object value, Class<?> clazz) {
-
-        try {
-            if (value == null) {
-                return clazz.getMethod(methodName, (Class<?>[]) null);
-            } else {
-                return clazz.getMethod(methodName, value.getClass());
-            }
-        } catch (SecurityException e) {
-            log.error(""SecurityException: "" + e.getMessage());
-            return null;
-        } catch (NoSuchMethodException e) {
-            log.error(""NoSuchMethodException: "" + e.getMessage());
-            return null;
-        }
-    }
-
-    private Method findMethod(String key, Object value, String prefix, Class<?> clazz) {
-
-        if (key.length() < 2) {
-            return null;
-        }
-
-        key = key.substring(0, 1).toUpperCase() + key.substring(1);
-        String methodName = prefix + key;
-
-        return getMethod(methodName, value, clazz);
-    }
-
-}
\ No newline at end of file
@@ -1,211 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.url;
-
-
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.MethodConfig;
-import org.apache.dubbo.config.ProtocolConfig;
-import org.apache.dubbo.config.ProviderConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.config.api.DemoService;
-import org.apache.dubbo.config.provider.impl.DemoServiceImpl;
-
-import java.util.Arrays;
-
-import static junit.framework.TestCase.fail;
-
-@SuppressWarnings(""unused"")
-public class UrlTestBase {
-
-    // ======================================================
-    //   data column definition
-    // ======================================================
-    protected static final int KEY = 0;
-    protected static final int URL_KEY = 1;
-    protected static final int TESTVALUE1 = 4;
-    private static final Logger log = LoggerFactory.getLogger(UrlTestBase.class);
-    private static final int TYPE = 2;
-    private static final int DEFAULT = 3;
-    private static final int TESTVALUE2 = 5;
-    private static final int TESTVALUE3 = 6;
-    private static final int TESTVALUE4 = 7;
-    private static final int TESTVALUE5 = 8;
-    private static final int TESTVALUE6 = 9;
-    private static final int TESTVALUE7 = 10;
-    protected ApplicationConfig appConfForProvider;
-    protected ApplicationConfig appConfForService;
-    protected RegistryConfig regConfForProvider;
-    protected RegistryConfig regConfForService;
-    protected ProviderConfig provConf;
-    protected ProtocolConfig protoConfForProvider;
-    protected ProtocolConfig protoConfForService;
-    protected MethodConfig methodConfForService;
-    protected ServiceConfig<DemoService> servConf;
-    protected Object servConfTable[][] = {
-            {""proxy"", ""proxy"", ""string"", ""javassist"", ""jdk"", ""javassist"", """", """", """", """"},
-            {""actives"", ""actives"", ""int"", 0, 90, """", """", """", """", """"},
-            {""executes"", ""executes"", ""int"", 0, 90, """", """", """", """", """"},
-            {""deprecated"", ""deprecated"", ""boolean"", false, true, """", """", """", """", """"},
-            {""dynamic"", ""dynamic"", ""boolean"", true, false, """", """", """", """", """"},
-            {""accesslog"", ""accesslog"", ""string"", """", ""haominTest"", """", """", """", """", """"},
-            {""document"", ""document"", ""string"", """", ""http://b2b-doc.alibaba-inc.com/display/RC/dubbo_devguide.htm?testquery=你好你好"", """", """", """", """", """"},
-            {""weight"", ""weight"", ""int"", 0, 90, """", """", """", """", """"},
-
-            //{""filter"", ""service.filter"", ""string"", """", """", """", """", """", """", """"},
-            //{""listener"", ""listener"", ""string"", """", """", """", """", """", """", """"},
-
-    };
-    protected Object regConfForServiceTable[][] = {
-            //            {""timeout"", ""registry.timeout"", ""int"", 5000, 9000, """", """", """", """", """"},
-            //            {""file"", ""registry.file"", ""string"", """", ""regConfForServiceTable.log"", """", """", """", """", """"},
-            //            {""wait"", ""registry.wait"", ""int"", 0, 9000, """", """", """", """", """"},
-            //            {""transport"", ""registry.transporter"", ""string"", ""netty"", ""mina"", """", """", """", """", """"},
-            //            {""subscribe"", ""subscribe"", ""boolean"", true, false, """", """", """", """", """"},
-            {""dynamic"", ""dynamic"", ""boolean"", true, false, """", """", """", """", """"},
-    };
-    protected Object provConfTable[][] = {
-            {""cluster"", ""default.cluster"", ""string"", ""string"", ""failover"", ""failfast"", ""failsafe"", """", """", """"},
-            {""async"", ""default.async"", ""boolean"", false, true, """", """", """", """", """"},
-            {""loadbalance"", ""default.loadbalance"", ""string"", ""random"", ""leastactive"", """", """", """", """", """"},
-            {""connections"", ""default.connections"", ""int"", 0, 60, """", """", """", """", """"},
-            {""retries"", ""default.retries"", ""int"", 2, 60, """", """", """", """", """"},
-            {""timeout"", ""default.timeout"", ""int"", 5000, 60, """", """", """", """", """"},
-            //change by fengting listener 没有缺省值
-            //{""listener"", ""exporter.listener"", ""string"", """", """", """", """", """", """", """"},
-            //{""filter"", ""service.filter"", ""string"", """", """", """", """", """", """", """"},
-
-    };
-    protected Object methodConfForServiceTable[][] = {
-            {""actives"", ""sayName.actives"", ""int"", 0, 90, """", """", """", """", """"},
-            {""executes"", ""sayName.executes"", ""int"", 0, 90, """", """", """", """", """"},
-            {""deprecated"", ""sayName.deprecated"", ""boolean"", false, true, """", """", """", """", """"},
-            {""async"", ""sayName.async"", ""boolean"", false, true, """", """", """", """", """"},
-            {""timeout"", ""sayName.timeout"", ""int"", 0, 90, """", """", """", """", """"},
-    };
-    protected DemoService demoService = new DemoServiceImpl();
-    private Object appConfForProviderTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-    private Object appConfForServiceTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-    private Object regConfForProviderTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-    private Object protoConfForProviderTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-    private Object protoConfForServiceTable[][] = {
-            {"""", """", """", """", """", """", """", """", """", """"},
-    };
-
-    // ======================================================
-    //   data table manipulation utils
-    // ====================================================== 
-    protected String genParamString(Object urlKey, Object value) {
-
-        return (String) urlKey + ""="" + value.toString();
-    }
-
-    protected <T> void fillConfigs(T conf, Object[][] table, int column) {
-
-        for (Object[] row : table) {
-            fillConfig(conf, row, column);
-        }
-    }
-
-    protected <T> void fillConfig(T conf, Object[] row, int column) {
-
-        RpcConfigGetSetProxy proxy = new RpcConfigGetSetProxy(conf);
-        proxy.setValue((String) row[KEY], row[column]);
-
-    }
-
-    @SuppressWarnings(""deprecation"")
-    protected void initServConf() {
-
-        appConfForProvider = new ApplicationConfig();
-        appConfForService = new ApplicationConfig();
-        regConfForProvider = new RegistryConfig();
-        regConfForService = new RegistryConfig();
-        provConf = new ProviderConfig();
-        protoConfForProvider = new ProtocolConfig();
-        protoConfForService = new ProtocolConfig();
-        methodConfForService = new MethodConfig();
-        servConf = new ServiceConfig<DemoService>();
-
-        provConf.setApplication(appConfForProvider);
-        servConf.setApplication(appConfForService);
-
-        provConf.setRegistry(regConfForProvider);
-        servConf.setRegistry(regConfForService);
-
-        provConf.setProtocols(Arrays.asList(new ProtocolConfig[]{protoConfForProvider}));
-        servConf.setProtocols(Arrays.asList(new ProtocolConfig[]{protoConfForService}));
-
-        servConf.setMethods(Arrays.asList(new MethodConfig[]{methodConfForService}));
-        servConf.setProvider(provConf);
-
-        servConf.setRef(demoService);
-        servConf.setInterfaceClass(DemoService.class);
-
-        methodConfForService.setName(""sayName"");
-        regConfForService.setAddress(""127.0.0.1:9090"");
-        regConfForService.setProtocol(""mockregistry"");
-        appConfForService.setName(""ConfigTests"");
-    }
-
-    protected String getProviderParamString() {
-        return servConf.getExportedUrls().get(0).toString();
-    }
-
-    /**
-     * @param paramStringFromDb
-     * @param dataTable
-     * @param configName
-     * @param column
-     */
-    protected void assertUrlStringWithLocalTable(String paramStringFromDb,
-                                                 Object[][] dataTable, String configName, int column) {
-        final String FAILLOG_HEADER = ""The following config items are not found in URLONE: "";
-
-        log.warn(""Verifying service url for "" + configName + ""... "");
-        log.warn(""Consumer url string: "" + paramStringFromDb);
-
-        String failLog = FAILLOG_HEADER;
-        for (Object[] row : dataTable) {
-
-            String targetString = genParamString(row[URL_KEY], row[column]);
-
-            log.warn(""Checking "" + (String) row[KEY] + ""for"" + targetString);
-            if (paramStringFromDb.contains(targetString)) {
-                log.warn((String) row[KEY] + "" --> "" + targetString + "" OK!"");
-            } else {
-                failLog += targetString + "", "";
-            }
-        }
-
-        if (!failLog.equals(FAILLOG_HEADER)) {
-            fail(failLog);
-        }
-    }
-
-}
\ No newline at end of file
@@ -1,53 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.utils;
-
-import org.apache.dubbo.config.ReferenceConfig;
-
-import java.util.concurrent.atomic.AtomicLong;
-
-public class MockReferenceConfig extends ReferenceConfig<String> {
-    static AtomicLong counter = new AtomicLong();
-
-    String value;
-    boolean destroyMethodRun = false;
-
-    public static void setCounter(long c) {
-        counter.set(c);
-    }
-
-    public boolean isGetMethodRun() {
-        return value != null;
-    }
-
-    public boolean isDestroyMethodRun() {
-        return destroyMethodRun;
-    }
-
-    @Override
-    public synchronized String get() {
-        if (value != null) return value;
-
-        value = """" + counter.getAndIncrement();
-        return value;
-    }
-
-    @Override
-    public synchronized void destroy() {
-        destroyMethodRun = true;
-    }
-}
@@ -1,114 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.utils;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public class ReferenceConfigCacheTest {
-    @Before
-    public void setUp() throws Exception {
-        MockReferenceConfig.setCounter(0);
-        ReferenceConfigCache.cacheHolder.clear();
-    }
-
-    @Test
-    public void testGetCacheSameReference() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        String value = cache.get(config);
-        assertTrue(config.isGetMethodRun());
-        assertEquals(""0"", value);
-
-        MockReferenceConfig configCopy = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        value = cache.get(configCopy);
-        assertFalse(configCopy.isGetMethodRun());
-        assertEquals(""0"", value);
-    }
-
-    @Test
-    public void testGetCacheDiffReference() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        String value = cache.get(config);
-        assertTrue(config.isGetMethodRun());
-        assertEquals(""0"", value);
-
-        MockReferenceConfig configCopy = buildMockReferenceConfig(""XxxService"", ""group1"", ""1.0.0"");
-        value = cache.get(configCopy);
-        assertTrue(configCopy.isGetMethodRun());
-        assertEquals(""1"", value);
-    }
-
-    @Test
-    public void testGetCacheDiffName() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        String value = cache.get(config);
-        assertTrue(config.isGetMethodRun());
-        assertEquals(""0"", value);
-
-        cache = ReferenceConfigCache.getCache(""foo"");
-        config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        value = cache.get(config);
-        // still init for the same ReferenceConfig if the cache is different
-        assertTrue(config.isGetMethodRun());
-        assertEquals(""1"", value);
-    }
-
-    @Test
-    public void testDestroy() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        cache.get(config);
-        MockReferenceConfig configCopy = buildMockReferenceConfig(""XxxService"", ""group1"", ""1.0.0"");
-        cache.get(configCopy);
-        assertEquals(2, cache.cache.size());
-        cache.destroy(config);
-        assertTrue(config.isDestroyMethodRun());
-        assertEquals(1, cache.cache.size());
-        cache.destroy(configCopy);
-        assertTrue(configCopy.isDestroyMethodRun());
-        assertEquals(0, cache.cache.size());
-    }
-
-    @Test
-    public void testDestroyAll() throws Exception {
-        ReferenceConfigCache cache = ReferenceConfigCache.getCache();
-        MockReferenceConfig config = buildMockReferenceConfig(""FooService"", ""group1"", ""1.0.0"");
-        cache.get(config);
-        MockReferenceConfig configCopy = buildMockReferenceConfig(""XxxService"", ""group1"", ""1.0.0"");
-        cache.get(configCopy);
-        assertEquals(2, cache.cache.size());
-        cache.destroyAll();
-        assertTrue(config.isDestroyMethodRun());
-        assertTrue(configCopy.isDestroyMethodRun());
-        assertEquals(0, cache.cache.size());
-    }
-
-    private MockReferenceConfig buildMockReferenceConfig(String service, String group, String version) {
-        MockReferenceConfig config = new MockReferenceConfig();
-        config.setInterface(service);
-        config.setGroup(group);
-        config.setVersion(version);
-        return config;
-    }
-}
@@ -1,106 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.validation;
-
-import javax.validation.constraints.Future;
-import javax.validation.constraints.Max;
-import javax.validation.constraints.Min;
-import javax.validation.constraints.NotNull;
-import javax.validation.constraints.Past;
-import javax.validation.constraints.Pattern;
-import javax.validation.constraints.Size;
-import java.io.Serializable;
-import java.util.Date;
-
-/**
- * ValidationParameter
- */
-public class ValidationParameter implements Serializable {
-
-    private static final long serialVersionUID = 7158911668568000392L;
-
-    @NotNull(groups = ValidationService.Update.class)
-    private Integer id;
-
-    @NotNull
-    @Size(min = 2, max = 20)
-    private String name;
-
-    // not allow to save null, but allow to update with null which means not update the field
-    @NotNull(groups = ValidationService.Save.class)
-    @Pattern(regexp = ""^\\s*\\w+(?:\\.{0,1}[\\w-]+)*@[a-zA-Z0-9]+(?:[-.][a-zA-Z0-9]+)*\\.[a-zA-Z]+\\s*$"")
-    private String email;
-
-    @Min(18)
-    @Max(100)
-    private int age;
-
-    @Past
-    private Date loginDate;
-
-    @Future
-    private Date expiryDate;
-
-    public Integer getId() {
-        return id;
-    }
-
-    public void setId(Integer id) {
-        this.id = id;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getEmail() {
-        return email;
-    }
-
-    public void setEmail(String email) {
-        this.email = email;
-    }
-
-    public int getAge() {
-        return age;
-    }
-
-    public void setAge(int age) {
-        this.age = age;
-    }
-
-    public Date getLoginDate() {
-        return loginDate;
-    }
-
-    public void setLoginDate(Date loginDate) {
-        this.loginDate = loginDate;
-    }
-
-    public Date getExpiryDate() {
-        return expiryDate;
-    }
-
-    public void setExpiryDate(Date expiryDate) {
-        this.expiryDate = expiryDate;
-    }
-
-}
@@ -1,70 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.validation;
-
-import org.apache.dubbo.validation.MethodValidated;
-
-import javax.validation.constraints.Min;
-import javax.validation.constraints.NotNull;
-import javax.validation.constraints.Pattern;
-import javax.validation.constraints.Size;
-
-
-/**
- * ValidationService
- * <p>
- * Use service interface to distinguish validation scenario, for example: @NotNull(groups = ValidationService.class)
- */
-public interface ValidationService {
-
-    /**
-     * The current logic will not verify 'groups = ValidationService.Save.class' if
-     * '@MethodValidated(ValidationService.Save.class)' is not present
-     *
-     * @param parameter
-     */
-    @MethodValidated(Save.class)
-    void save(ValidationParameter parameter);
-
-    void update(ValidationParameter parameter);
-
-    void delete(@Min(1) long id, @NotNull @Size(min = 2, max = 16) @Pattern(regexp = ""^[a-zA-Z]+$"") String operator);
-
-    /**
-     * Assume both id and email are needed to pass in, need to verify Save group and Update group.
-     *
-     * @param parameter
-     */
-    @MethodValidated({Save.class, Update.class})
-    void relatedQuery(ValidationParameter parameter);
-
-    /**
-     * annotation which has the same name with the method but has the first letter in capital
-     * used for distinguish validation scenario, for example: @NotNull(groups = ValidationService.Save.class)
-     * optional
-     */
-    @interface Save {
-    }
-
-    /**
-     * annotation which has the same name with the method but has the first letter in capital
-     * used for distinguish validation scenario, for example: @NotNull(groups = ValidationService.Update.class)
-     * optional
-     */
-    @interface Update {
-    }
-}
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.validation;
-
-/**
- * ValidationServiceImpl
- */
-public class ValidationServiceImpl implements ValidationService {
-
-    public void save(ValidationParameter parameter) {
-    }
-
-    public void update(ValidationParameter parameter) {
-    }
-
-    public void delete(long id, String operator) {
-    }
-
-    public void relatedQuery(ValidationParameter parameter){
-
-    }
-
-}
@@ -1,302 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.validation;
-
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.ProtocolConfig;
-import org.apache.dubbo.config.ReferenceConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.service.GenericException;
-import org.apache.dubbo.rpc.service.GenericService;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import javax.validation.ConstraintViolation;
-import javax.validation.ConstraintViolationException;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * GenericServiceTest
- */
-public class ValidationTest {
-
-    @Test
-    public void testValidation() {
-        ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();
-        service.setApplication(new ApplicationConfig(""validation-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29582));
-        service.setInterface(ValidationService.class.getName());
-        service.setRef(new ValidationServiceImpl());
-        service.setValidation(String.valueOf(true));
-        service.export();
-        try {
-            ReferenceConfig<ValidationService> reference = new ReferenceConfig<ValidationService>();
-            reference.setApplication(new ApplicationConfig(""validation-consumer""));
-            reference.setInterface(ValidationService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29582?scope=remote&validation=true"");
-            ValidationService validationService = reference.get();
-            try {
-                // Save OK
-                ValidationParameter parameter = new ValidationParameter();
-                parameter.setName(""liangfei"");
-                parameter.setEmail(""liangfei@liang.fei"");
-                parameter.setAge(50);
-                parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                validationService.save(parameter);
-
-                try {
-                    parameter = new ValidationParameter();
-                    parameter.setName(""l"");
-                    parameter.setEmail(""liangfei@liang.fei"");
-                    parameter.setAge(50);
-                    parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                    parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                    validationService.save(parameter);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                }
-
-                // verify save group, save error
-                try {
-                    parameter = new ValidationParameter();
-                    parameter.setName(""liangfei"");
-                    parameter.setAge(50);
-                    parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                    parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                    validationService.save(parameter);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                }
-
-                // relatedQuery error, no id and email is passed, will trigger validation exception for both Save
-                // and Update
-                try {
-                    parameter = new ValidationParameter();
-                    parameter.setName(""liangfei"");
-                    parameter.setAge(50);
-                    parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                    parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                    validationService.relatedQuery(parameter);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertEquals(violations.size(),2);
-                }
-
-                // Save Error
-                try {
-                    parameter = new ValidationParameter();
-                    validationService.save(parameter);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertTrue(violations.size() == 3);
-                    Assert.assertNotNull(violations);
-                }
-
-                // Delete OK
-                validationService.delete(2, ""abc"");
-
-                // Delete Error
-                try {
-                    validationService.delete(2, ""a"");
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                    Assert.assertEquals(1, violations.size());
-                }
-
-                // Delete Error
-                try {
-                    validationService.delete(0, ""abc"");
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                    Assert.assertEquals(1, violations.size());
-                }
-                try {
-                    validationService.delete(2, null);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                    Assert.assertEquals(1, violations.size());
-                }
-                try {
-                    validationService.delete(0, null);
-                    Assert.fail();
-                } catch (ConstraintViolationException ve) {
-                    Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
-                    Assert.assertNotNull(violations);
-                    Assert.assertEquals(2, violations.size());
-                }
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testProviderValidation() {
-        ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();
-        service.setApplication(new ApplicationConfig(""validation-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29582));
-        service.setInterface(ValidationService.class.getName());
-        service.setRef(new ValidationServiceImpl());
-        service.setValidation(String.valueOf(true));
-        service.export();
-        try {
-            ReferenceConfig<ValidationService> reference = new ReferenceConfig<ValidationService>();
-            reference.setApplication(new ApplicationConfig(""validation-consumer""));
-            reference.setInterface(ValidationService.class);
-            reference.setUrl(""dubbo://127.0.0.1:29582"");
-            ValidationService validationService = reference.get();
-            try {
-                // Save OK
-                ValidationParameter parameter = new ValidationParameter();
-                parameter.setName(""liangfei"");
-                parameter.setEmail(""liangfei@liang.fei"");
-                parameter.setAge(50);
-                parameter.setLoginDate(new Date(System.currentTimeMillis() - 1000000));
-                parameter.setExpiryDate(new Date(System.currentTimeMillis() + 1000000));
-                validationService.save(parameter);
-
-                // Save Error
-                try {
-                    parameter = new ValidationParameter();
-                    validationService.save(parameter);
-                    Assert.fail();
-                } catch (RpcException e) {
-                    Assert.assertTrue(e.getMessage().contains(""ConstraintViolation""));
-                }
-
-                // Delete OK
-                validationService.delete(2, ""abc"");
-
-                // Delete Error
-                try {
-                    validationService.delete(0, ""abc"");
-                    Assert.fail();
-                } catch (RpcException e) {
-                    Assert.assertTrue(e.getMessage().contains(""ConstraintViolation""));
-                }
-                try {
-                    validationService.delete(2, null);
-                    Assert.fail();
-                } catch (RpcException e) {
-                    Assert.assertTrue(e.getMessage().contains(""ConstraintViolation""));
-                }
-                try {
-                    validationService.delete(0, null);
-                    Assert.fail();
-                } catch (RpcException e) {
-                    Assert.assertTrue(e.getMessage().contains(""ConstraintViolation""));
-                }
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-    @Test
-    public void testGenericValidation() {
-        ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();
-        service.setApplication(new ApplicationConfig(""validation-provider""));
-        service.setRegistry(new RegistryConfig(""N/A""));
-        service.setProtocol(new ProtocolConfig(""dubbo"", 29582));
-        service.setInterface(ValidationService.class.getName());
-        service.setRef(new ValidationServiceImpl());
-        service.setValidation(String.valueOf(true));
-        service.export();
-        try {
-            ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();
-            reference.setApplication(new ApplicationConfig(""validation-consumer""));
-            reference.setInterface(ValidationService.class.getName());
-            reference.setUrl(""dubbo://127.0.0.1:29582?scope=remote&validation=true&timeout=9000000"");
-            reference.setGeneric(true);
-            GenericService validationService = reference.get();
-            try {
-                // Save OK
-                Map<String, Object> parameter = new HashMap<String, Object>();
-                parameter.put(""name"", ""liangfei"");
-                parameter.put(""Email"", ""liangfei@liang.fei"");
-                parameter.put(""Age"", 50);
-                parameter.put(""LoginDate"", new Date(System.currentTimeMillis() - 1000000));
-                parameter.put(""ExpiryDate"", new Date(System.currentTimeMillis() + 1000000));
-                validationService.$invoke(""save"", new String[]{ValidationParameter.class.getName()}, new Object[]{parameter});
-
-                // Save Error
-                try {
-                    parameter = new HashMap<String, Object>();
-                    validationService.$invoke(""save"", new String[]{ValidationParameter.class.getName()}, new Object[]{parameter});
-                    Assert.fail();
-                } catch (GenericException e) {
-                    Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-                }
-
-                // Delete OK
-                validationService.$invoke(""delete"", new String[]{long.class.getName(), String.class.getName()}, new Object[]{2, ""abc""});
-
-                // Delete Error
-                try {
-                    validationService.$invoke(""delete"", new String[]{long.class.getName(), String.class.getName()}, new Object[]{0, ""abc""});
-                    Assert.fail();
-                } catch (GenericException e) {
-                    Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-                }
-                try {
-                    validationService.$invoke(""delete"", new String[]{long.class.getName(), String.class.getName()}, new Object[]{2, null});
-                    Assert.fail();
-                } catch (GenericException e) {
-                    Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-                }
-                try {
-                    validationService.$invoke(""delete"", new String[]{long.class.getName(), String.class.getName()}, new Object[]{0, null});
-                    Assert.fail();
-                } catch (GenericException e) {
-                    Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-                }
-            } catch (GenericException e) {
-                Assert.assertTrue(e.getMessage().contains(""Failed to validate service""));
-            } finally {
-                reference.destroy();
-            }
-        } finally {
-            service.unexport();
-        }
-    }
-
-}
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockstatuschecker=org.apache.dubbo.config.mock.MockStatusChecker
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockthreadpool=org.apache.dubbo.config.mock.MockThreadPool
\ No newline at end of file
@@ -1,2 +0,0 @@
-mockregistry=org.apache.dubbo.config.mock.MockRegistryFactory
-mockprotocol2=org.apache.dubbo.config.mock.MockRegistryFactory2
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockcodec=org.apache.dubbo.config.mock.MockCodec
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockdispatcher=org.apache.dubbo.config.mock.MockDispatcher
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mocktransporter=org.apache.dubbo.config.mock.MockTransporter
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockexchanger=org.apache.dubbo.config.mock.MockExchanger
\ No newline at end of file
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-mocktelnethandler=org.apache.dubbo.config.mock.MockTelnetHandler
-
@@ -1,18 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the ""License""); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an ""AS IS"" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-mockexporterlistener=org.apache.dubbo.config.mock.MockExporterListener
\ No newline at end of file
@@ -1 +0,0 @@
-mockfilter=org.apache.dubbo.config.mock.MockFilter
\ No newline at end of file
@@ -1 +0,0 @@
-mockinvokerlistener=org.apache.dubbo.config.mock.MockInvokerListener
\ No newline at end of file
@@ -1,2 +0,0 @@
-mockprotocol=org.apache.dubbo.config.mock.MockProtocol
-mockprotocol2=org.apache.dubbo.config.mock.MockProtocol2
\ No newline at end of file
@@ -1,2 +0,0 @@
-mockproxyfactory=org.apache.dubbo.config.mock.MockProxyFactory
-testproxyfactory=org.apache.dubbo.config.mock.TestProxyFactory
\ No newline at end of file
@@ -1 +0,0 @@
-mockcluster=org.apache.dubbo.config.mock.MockCluster
\ No newline at end of file
@@ -1 +0,0 @@
-mockloadbalance=org.apache.dubbo.config.mock.MockLoadBalance
\ No newline at end of file
@@ -1,28 +0,0 @@
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the ""License""); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an ""AS IS"" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-  -->
-<!DOCTYPE log4j:configuration SYSTEM ""log4j.dtd"">
-<log4j:configuration xmlns:log4j=""http://jakarta.apache.org/log4j/"" debug=""false"">
-    <appender name=""CONSOLE"" class=""org.apache.log4j.ConsoleAppender"">
-        <layout class=""org.apache.log4j.PatternLayout"">
-            <param name=""ConversionPattern"" value=""[%d{dd/MM/yy hh:mm:ss:sss z}] %t %5p %c{2}: %m%n""/>
-        </layout>
-    </appender>
-    <root>
-        <level value=""INFO""/>
-        <appender-ref ref=""CONSOLE""/>
-    </root>
-</log4j:configuration>
\ No newline at end of file
",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71309 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71335 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71297 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71316 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71286 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71301 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71276 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71284 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}",,"Error: 400 - {""object"":""error"",""message"":""Prompt contains 71286 tokens, too large for model with 32768 maximum context length"",""type"":""invalid_request_error"",""param"":null,""code"":null}"
https://github.com/junit-team/junit4/commit/46036e7146f9dd0ca44baaec490692b967edd0ce,"javadoc'ed, and with better names ",https://api.github.com/repos/junit-team/junit4/commits/46036e7146f9dd0ca44baaec490692b967edd0ce,"@@ -0,0 +1,112 @@
+/**
+ * 
+ */
+package org.junit.experimental.categories;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import org.junit.runner.Description;
+import org.junit.runner.manipulation.Filter;
+import org.junit.runner.manipulation.NoTestsRemainException;
+import org.junit.runners.Suite;
+import org.junit.runners.model.InitializationError;
+import org.junit.runners.model.RunnerBuilder;
+
+/**
+ * From a given set of test classes, runs only the classes and methods
+ * that are annotated with either the category given with the @IncludeCategory
+ * annotation, or a subtype of that category.
+ * 
+ * Example:
+<pre>
+	public interface FastTests extends CategoryType {}
+	public interface SlowTests extends CategoryType {}
+
+	public static class A {
+		@Test
+		public void a() {
+			fail();
+		}
+
+		@Category(SlowTests.class)
+		@Test
+		public void b() {
+		}
+	}
+
+	@Category({SlowTests.class, FastTests.class})
+	public static class B {
+		@Test
+		public void c() {
+
+		}
+	}
+
+	@RunWith(Categories.class)
+	@IncludeCategory(SlowTests.class)
+	@SuiteClasses( { A.class, B.class }) // Note that Categories is a kind of Suite
+	public static class SlowTestSuite {}
+</pre>
+ */
+public class Categories extends Suite {
+	@Retention(RetentionPolicy.RUNTIME)
+	public @interface IncludeCategory {
+		public Class<? extends CategoryType> value();
+	}
+	
+	public static class CategoryFilter extends Filter {
+		public static CategoryFilter include(
+				Class<? extends CategoryType> categoryClass) {
+			return new CategoryFilter(categoryClass);
+		}
+
+		private final Class<? extends CategoryType> fCategoryClass;
+
+		public CategoryFilter(Class<? extends CategoryType> categoryClass) {
+			fCategoryClass= categoryClass;
+		}
+
+		@Override
+		public String describe() {
+			return ""category "" + fCategoryClass;
+		}
+
+		@Override
+		public boolean shouldRun(Description description) {
+			if (hasCorrectCategoryAnnotation(description))
+				return true;
+
+			// TODO: feels as if we've done this child crawl several times.
+			// Change design?
+			for (Description each : description.getChildren())
+				if (shouldRun(each))
+					return true;
+			return false;
+		}
+
+		private boolean hasCorrectCategoryAnnotation(Description description) {
+			Category annotation= description.getAnnotation(Category.class);
+			if (annotation == null)
+				return false;
+			for (Class<? extends CategoryType> each : annotation.value())
+				if (fCategoryClass.isAssignableFrom(each))
+					return true;
+			return false;
+		}
+	}
+
+	public Categories(Class<?> klass, RunnerBuilder builder)
+			throws InitializationError {
+		super(klass, builder);
+		try {
+			filter(new CategoryFilter(getCategory(klass)));
+		} catch (NoTestsRemainException e) {
+			throw new InitializationError(e);
+		}
+	}
+
+	private Class<? extends CategoryType> getCategory(Class<?> klass) {
+		return klass.getAnnotation(IncludeCategory.class).value();
+	}
+}
\ No newline at end of file
@@ -1,12 +1,44 @@
-/**
- * 
- */
 package org.junit.experimental.categories;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
+/**
+ * Marks a test class or test method as belonging to one or more categories of tests.
+ * The value is an array of interface classes that extend the {@link CategoryType}
+ * superinterface.
+ * 
+ * This annotation is only interpreted by the Categories runner (at present).
+ * 
+ * For example:
+<pre>
+	public interface FastTests extends CategoryType {}
+	public interface SlowTests extends CategoryType {}
+
+	public static class A {
+		@Test
+		public void a() {
+			fail();
+		}
+
+		@Category(SlowTests.class)
+		@Test
+		public void b() {
+		}
+	}
+
+	@Category({SlowTests.class, FastTests.class})
+	public static class B {
+		@Test
+		public void c() {
+
+		}
+	}
+</pre>
+ * 
+ * For more usage, see code example on {@link Categories}.
+ */
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Category {
-	Class<? extends CategoryClass>[] value();
+	Class<? extends CategoryType>[] value();
 }
\ No newline at end of file
@@ -0,0 +1,11 @@
+package org.junit.experimental.categories;
+
+/**
+ * Super-interface for all interface classes that are used to represent
+ * categories.  Representing categories as types allows compile-time
+ * checking of typos in category names, preventing accidental test
+ * exclusion.
+ */
+public interface CategoryType {
+
+}
\ No newline at end of file
@@ -8,10 +8,10 @@
 import static org.junit.experimental.results.ResultMatchers.isSuccessful;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import org.junit.experimental.categories.CategoryClass;
-import org.junit.experimental.categories.CategoryRunner;
-import org.junit.experimental.categories.CategoryRunner.CategoryFilter;
-import org.junit.experimental.categories.CategoryRunner.IncludeCategory;
+import org.junit.experimental.categories.CategoryType;
+import org.junit.experimental.categories.Categories;
+import org.junit.experimental.categories.Categories.CategoryFilter;
+import org.junit.experimental.categories.Categories.IncludeCategory;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Request;
 import org.junit.runner.Result;
@@ -23,11 +23,11 @@
 import org.junit.runners.model.InitializationError;
 
 public class CategoryTest {
-	public static interface FastTests extends CategoryClass {
+	public interface FastTests extends CategoryType {
 
 	}
 
-	public interface SlowTests extends CategoryClass {
+	public interface SlowTests extends CategoryType {
 
 	}
 
@@ -58,7 +58,13 @@ public void d() {
 		}
 	}
 
-	@RunWith(CategoryRunner.class)
+	@RunWith(Categories.class)
+	@IncludeCategory(SlowTests.class)
+	@SuiteClasses( { A.class, B.class, C.class })
+	public static class SlowTestSuite {
+	}
+
+	@RunWith(Categories.class)
 	@IncludeCategory(SlowTests.class)
 	@SuiteClasses( { A.class })
 	public static class JustA {
@@ -69,12 +75,6 @@ public void testCountOnJustA() {
 		assertThat(testResult(JustA.class), isSuccessful());
 	}
 
-	@RunWith(CategoryRunner.class)
-	@IncludeCategory(SlowTests.class)
-	@SuiteClasses( { A.class, B.class, C.class })
-	public static class SlowTestSuite {
-	}
-
 	@Test
 	public void testCount() {
 		assertThat(testResult(SlowTestSuite.class), isSuccessful());
@@ -134,7 +134,7 @@ public void a() {
 		}
 	}
 
-	@RunWith(CategoryRunner.class)
+	@RunWith(Categories.class)
 	@IncludeCategory(SlowTests.class)
 	@SuiteClasses( { OneFast.class })
 	public static class OneFastSuite {
@@ -161,7 +161,7 @@ public void a() {
 		}
 	}
 
-	@RunWith(CategoryRunner.class)
+	@RunWith(Categories.class)
 	@IncludeCategory(SlowTests.class)
 	@SuiteClasses( { OneThatIsBothFastAndSlow.class })
 	public static class ChooseSlowFromBoth {
@@ -183,7 +183,7 @@ public void a() {
 		}
 	}
 
-	@RunWith(CategoryRunner.class)
+	@RunWith(Categories.class)
 	@IncludeCategory(SlowTests.class)
 	@SuiteClasses( { OneVerySlowTest.class })
 	public static class RunSlowFromVerySlow {
",True,"The commit message 'javadoc'ed, and with better names' refers to the addition of Javadoc comments to the code, which is a common practice to improve code readability and maintainability. The commit also introduces a new interface 'CategoryType' and updates the 'Category' annotation to use this new interface, which can be seen as an improvement in prior commits. Additionally, the commit message does not explicitly mention any conventions or standards, but the changes made to the code, such as adding Javadoc comments and renaming classes and interfaces, can be interpreted as following best practices for code documentation and organization.",True,"The commit message 'javadoc'ed, and with better names' does not explicitly state the necessity of the changes, but it is easy to infer from the diff that the changes were made to add javadoc comments and improve the naming of classes and methods. This is a common practice in software development to improve code readability and maintainability, and it is not always necessary to explicitly state this in the commit message.",False,"The commit message does not explicitly describe the necessity of changes or the motivation behind the code change. It only mentions that the code has been javadoc'ed and that better names have been used. While these are improvements, they do not directly address any errors, issues, or shortcomings in the previous implementation.",True,"The commit message 'javadoc'ed, and with better names' indicates that the changes were made to improve the code readability and maintainability. The code diff shows that the developer added Javadoc comments to the code, which is a good practice to describe the purpose and functionality of the classes and methods. Additionally, the diff shows that the developer renamed some classes and interfaces to better represent their purpose, which can be seen as an improvement to make the code more understandable. However, the commit message does not explicitly mention any user requirements or problems in the software maintenance process. Therefore, while the changes may have been necessary, the message does not explicitly describe the source of the requirement.",True,"The commit message 'javadoc'ed, and with better names' does describe the objective of the change. The change adds Javadoc comments to the code, which is an improvement that makes the code more understandable and maintainable. Additionally, the change introduces a new interface 'CategoryType' and updates the 'Category' annotation to use this interface, which simplifies the categorization of tests and prevents accidental test exclusion due to typos in category names.",True,"The commit message 'javadoc'ed, and with better names' accurately summarizes the changes made to the code. The changes include adding Javadoc comments to the code, which improves its readability and maintainability. Additionally, the commit message mentions the use of better names for certain components, such as renaming 'CategoryClass' to 'CategoryType' and 'CategoryRunner' to 'Categories'. These changes enhance the clarity and consistency of the codebase.",True,"The commit message does not explicitly state the technical principle, but the code diff and the added documentation reveal that the changes are based on the concept of categorizing tests. The new classes and annotations allow for the organization of tests into different categories, and the Categories runner is then used to selectively run tests based on these categories.",True,"The commit message 'javadoc'ed, and with better names' does describe the changes made to the code. The code diff shows that new classes and methods have been added, and the commit message explains that these additions include the introduction of a new annotation (@Category) and a new interface (CategoryType) to represent categories of tests. This allows for compile-time checking of category names, preventing accidental test exclusion. The message also mentions the addition of javadoc comments to the code, which is a good practice for documenting code and explaining its functionality.",True,"The commit message 'javadoc'ed, and with better names' suggests that the changes made to the code are mostly related to adding or improving documentation and renaming variables or classes. The code diff shows that a new class 'Categories' has been added, which is a Suite that filters tests based on a given category. This class also includes a new annotation 'Category' and a 'CategoryType' interface. The changes are not trivial, but they are not complex either. The purpose of the commit can be easily inferred from the changes made, so there was no need for an explicit explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/9d4ada793902c15f6b62ae0dd4ad45ca0ef5b197,"Add Tomcat 7 and Jetty 8 samples  <enter> Switch the Tomcat 8 and Jetty 9 samples to Tomcat 7 and Jetty 8. Since Tomcat 8 and Jetty 9 are now the default versions the previous samples are no longer relevant, however, we do need integration tests to check that we remain compatible with Tomcat 7 and Jetty 8. <enter> See  <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/9d4ada793902c15f6b62ae0dd4ad45ca0ef5b197,"@@ -41,7 +41,7 @@
 		<module>spring-boot-sample-jersey</module>
 		<module>spring-boot-sample-jersey1</module>
 		<module>spring-boot-sample-jetty</module>
-		<module>spring-boot-sample-jetty9</module>
+		<module>spring-boot-sample-jetty8</module>
 		<module>spring-boot-sample-jta-atomikos</module>
 		<module>spring-boot-sample-jta-bitronix</module>
 		<module>spring-boot-sample-jta-jndi</module>
@@ -51,10 +51,11 @@
 		<module>spring-boot-sample-secure</module>
 		<module>spring-boot-sample-servlet</module>
 		<module>spring-boot-sample-simple</module>
+		<module>spring-boot-sample-tomcat-jsp</module>
 		<module>spring-boot-sample-tomcat-ssl</module>
 		<module>spring-boot-sample-tomcat</module>
 		<module>spring-boot-sample-tomcat-multi-connectors</module>
-		<module>spring-boot-sample-tomcat8-jsp</module>
+		<module>spring-boot-sample-tomcat7-jsp</module>
 		<module>spring-boot-sample-traditional</module>
 		<module>spring-boot-sample-velocity</module>
 		<module>spring-boot-sample-web-freemarker</module>
@@ -7,18 +7,19 @@
 		<artifactId>spring-boot-samples</artifactId>
 		<version>1.2.0.BUILD-SNAPSHOT</version>
 	</parent>
-	<artifactId>spring-boot-sample-jetty9</artifactId>
-	<name>Spring Boot Jetty Sample</name>
-	<description>Spring Boot Jetty 9 Sample</description>
+	<artifactId>spring-boot-sample-jetty8</artifactId>
+	<name>Spring Boot Jetty 8 Sample</name>
+	<description>Spring Boot Jetty 8 Sample</description>
 	<url>http://projects.spring.io/spring-boot/</url>
 	<organization>
 		<name>Pivotal Software, Inc.</name>
 		<url>http://www.spring.io</url>
 	</organization>
 	<properties>
 		<main.basedir>${basedir}/../..</main.basedir>
-		<jetty.version>9.2.3.v20140905</jetty.version>
-		<servlet-api.version>3.1.0</servlet-api.version>
+		<jetty.version>8.1.15.v20140411</jetty.version>
+		<jetty-jsp.version>2.2.0.v201112011158</jetty-jsp.version>
+		<servlet-api.version>3.0.1</servlet-api.version>
 	</properties>
 	<dependencies>
 		<dependency>
@@ -24,10 +24,10 @@
 @Configuration
 @EnableAutoConfiguration
 @ComponentScan
-public class SampleJetty9Application {
+public class SampleJetty8Application {
 
 	public static void main(String[] args) throws Exception {
-		SpringApplication.run(SampleJetty9Application.class, args);
+		SpringApplication.run(SampleJetty8Application.class, args);
 	}
 
 }
@@ -36,7 +36,7 @@
  * @author Dave Syer
  */
 @RunWith(SpringJUnit4ClassRunner.class)
-@SpringApplicationConfiguration(classes = SampleJetty9Application.class)
+@SpringApplicationConfiguration(classes = SampleJetty8Application.class)
 @WebAppConfiguration
 @IntegrationTest(""server.port:0"")
 @DirtiesContext
@@ -7,10 +7,10 @@
 		<artifactId>spring-boot-samples</artifactId>
 		<version>1.2.0.BUILD-SNAPSHOT</version>
 	</parent>
-	<artifactId>spring-boot-sample-tomcat8-jsp</artifactId>
+	<artifactId>spring-boot-sample-tomcat-jsp</artifactId>
 	<packaging>war</packaging>
-	<name>Spring Boot Tomcat 8 JSP Sample</name>
-	<description>Spring Boot Tomcat 8 JSP Sample</description>
+	<name>Spring Boot Tomcat JSP Sample</name>
+	<description>Spring Boot Tomcat JSP Sample</description>
 	<url>http://projects.spring.io/spring-boot/</url>
 	<organization>
 		<name>Pivotal Software, Inc.</name>
@@ -19,7 +19,8 @@
 	<properties>
 		<main.basedir>${basedir}/../..</main.basedir>
 		<m2eclipse.wtp.contextRoot>/</m2eclipse.wtp.contextRoot>
-		<tomcat.version>8.0.8</tomcat.version>
+		<tomcat.version>7.0.56</tomcat.version>
+		<servlet-api.version>3.0.1</servlet-api.version>
 		<java.version>1.7</java.version>
 	</properties>
 	<dependencies>
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2012-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package sample.jsp;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
+import org.springframework.boot.builder.SpringApplicationBuilder;
+import org.springframework.boot.context.web.SpringBootServletInitializer;
+import org.springframework.context.annotation.ComponentScan;
+import org.springframework.context.annotation.Configuration;
+
+@Configuration
+@EnableAutoConfiguration
+@ComponentScan
+public class SampleTomcatJspApplication extends SpringBootServletInitializer {
+
+	@Override
+	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
+		return application.sources(SampleTomcatJspApplication.class);
+	}
+
+	public static void main(String[] args) throws Exception {
+		SpringApplication.run(SampleTomcatJspApplication.class, args);
+	}
+
+}
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2012-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package sample.jsp;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.test.IntegrationTest;
+import org.springframework.boot.test.SpringApplicationConfiguration;
+import org.springframework.boot.test.TestRestTemplate;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.test.annotation.DirtiesContext;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+import org.springframework.test.context.web.WebAppConfiguration;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Basic integration tests for JSP application.
+ *
+ * @author Phillip Webb
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@SpringApplicationConfiguration(classes = SampleTomcatJspApplication.class)
+@WebAppConfiguration
+@IntegrationTest(""server.port:0"")
+@DirtiesContext
+public class SampleWebJspApplicationTests {
+
+	@Value(""${local.server.port}"")
+	private int port;
+
+	@Test
+	public void testJspWithEl() throws Exception {
+		ResponseEntity<String> entity = new TestRestTemplate().getForEntity(
+				""http://localhost:"" + this.port, String.class);
+		assertEquals(HttpStatus.OK, entity.getStatusCode());
+		assertTrue(""Wrong body:\n"" + entity.getBody(),
+				entity.getBody().contains(""/resources/text.txt""));
+	}
+
+}
@@ -0,0 +1,66 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<!-- Your own application should inherit from spring-boot-starter-parent -->
+		<groupId>org.springframework.boot</groupId>
+		<artifactId>spring-boot-samples</artifactId>
+		<version>1.2.0.BUILD-SNAPSHOT</version>
+	</parent>
+	<artifactId>spring-boot-sample-tomcat7-jsp</artifactId>
+	<packaging>war</packaging>
+	<name>Spring Boot Tomcat 7 JSP Sample</name>
+	<description>Spring Boot Tomcat 7 JSP Sample</description>
+	<url>http://projects.spring.io/spring-boot/</url>
+	<organization>
+		<name>Pivotal Software, Inc.</name>
+		<url>http://www.spring.io</url>
+	</organization>
+	<properties>
+		<main.basedir>${basedir}/../..</main.basedir>
+		<m2eclipse.wtp.contextRoot>/</m2eclipse.wtp.contextRoot>
+		<tomcat.version>7.0.56</tomcat.version>
+		<servlet-api.version>3.0.1</servlet-api.version>
+		<java.version>1.7</java.version>
+	</properties>
+	<dependencies>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-web</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-tomcat</artifactId>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.apache.tomcat.embed</groupId>
+			<artifactId>tomcat-embed-jasper</artifactId>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>javax.servlet</groupId>
+			<artifactId>jstl</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-test</artifactId>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
+	<build>
+		<plugins>
+			<plugin>
+				<groupId>org.springframework.boot</groupId>
+				<artifactId>spring-boot-maven-plugin</artifactId>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-surefire-plugin</artifactId>
+				<configuration>
+					<useSystemClassLoader>false</useSystemClassLoader>
+				</configuration>
+			</plugin>
+		</plugins>
+	</build>
+</project>
@@ -26,15 +26,15 @@
 @Configuration
 @EnableAutoConfiguration
 @ComponentScan
-public class SampleTomcat8JspApplication extends SpringBootServletInitializer {
+public class SampleTomcat7JspApplication extends SpringBootServletInitializer {
 
 	@Override
 	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
-		return application.sources(SampleTomcat8JspApplication.class);
+		return application.sources(SampleTomcat7JspApplication.class);
 	}
 
 	public static void main(String[] args) throws Exception {
-		SpringApplication.run(SampleTomcat8JspApplication.class, args);
+		SpringApplication.run(SampleTomcat7JspApplication.class, args);
 	}
 
 }
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2012-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package sample.jsp;
+
+import java.util.Date;
+import java.util.Map;
+
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.stereotype.Controller;
+import org.springframework.web.bind.annotation.RequestMapping;
+
+@Controller
+public class WelcomeController {
+
+	@Value(""${application.message:Hello World}"")
+	private String message = ""Hello World"";
+
+	@RequestMapping(""/"")
+	public String welcome(Map<String, Object> model) {
+		model.put(""time"", new Date());
+		model.put(""message"", this.message);
+		return ""welcome"";
+	}
+
+}
@@ -0,0 +1,3 @@
+spring.view.prefix: /WEB-INF/jsp/
+spring.view.suffix: .jsp
+application.message: Hello Phil
\ No newline at end of file
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+
+<%@ taglib prefix=""spring"" uri=""http://www.springframework.org/tags""%>
+<%@ taglib prefix=""c"" uri=""http://java.sun.com/jsp/jstl/core""%>
+
+<html lang=""en"">
+
+<body>
+	<c:url value=""/resources/text.txt"" var=""url""/>
+	<spring:url value=""/resources/text.txt"" htmlEscape=""true"" var=""springUrl"" />
+	Spring URL: ${springUrl} at ${time}
+	<br>
+	JSTL URL: ${url}
+	<br>
+	Message: ${message}
+</body>
+
+</html>
@@ -37,7 +37,7 @@
  * @author Phillip Webb
  */
 @RunWith(SpringJUnit4ClassRunner.class)
-@SpringApplicationConfiguration(classes = SampleTomcat8JspApplication.class)
+@SpringApplicationConfiguration(classes = SampleTomcat7JspApplication.class)
 @WebAppConfiguration
 @IntegrationTest(""server.port:0"")
 @DirtiesContext
",True,"The commit message refers to the necessity of changes by mentioning that Tomcat 8 and Jetty 9 are now the default versions, making the previous samples no longer relevant. However, the project still needs integration tests to check compatibility with Tomcat 7 and Jetty 8. This explains why the commit switches the Tomcat 8 and Jetty 9 samples to Tomcat 7 and Jetty 8, respectively.",True,"The commit message explains the necessity of changes by stating that Tomcat 8 and Jetty 9 are now the default versions, and the previous samples are no longer relevant. However, the project still needs integration tests to check compatibility with Tomcat 7 and Jetty 8. This is a clear and concise explanation of the changes being made.",True,"The commit message explains the motivation for the code change by mentioning that Tomcat 8 and Jetty 9 are now the default versions, and the previous samples are no longer relevant. However, the project still needs integration tests to check compatibility with Tomcat 7 and Jetty 8. This directly elaborates the necessity of the changes.",True,"The commit message indicates that the changes are being made because Tomcat 8 and Jetty 9 are now the default versions, and the previous samples are no longer relevant. This implies that the existing samples need to be updated to remain compatible with the older versions of Tomcat and Jetty.",True,"The commit message directly mentions the change made to the code, which is switching the Tomcat 8 and Jetty 9 samples to Tomcat 7 and Jetty 8. This change is made to ensure compatibility with older versions of Tomcat and Jetty, which are no longer the default versions.",True,"The commit message 'Add Tomcat 7 and Jetty 8 samples' summarizes the changes made by listing the new components added (Tomcat 7 and Jetty 8 samples) and contrasting them with the previous versions (Tomcat 8 and Jetty 9) that are no longer relevant. The message also explains the reason for the change, which is to ensure compatibility with older versions of Tomcat and Jetty.",False,"The commit message does not explicitly state or describe a technical principle underpinning the changes. It mainly focuses on the reasons for the changes (i.e., the need for compatibility with older versions of Tomcat and Jetty) rather than the technical principles or concepts being applied.",True,"The commit message 'Add Tomcat 7 and Jetty 8 samples' summarizes the changes by explaining that new samples for Tomcat 7 and Jetty 8 are being added. The message also mentions that the changes are necessary to maintain compatibility with these older versions of Tomcat and Jetty, which are no longer the default versions. The code diff supports this explanation by showing the addition of new modules for Tomcat 7 and Jetty 8, and the removal of modules for Tomcat 8 and Jetty 9. Additionally, the diff shows changes to the version numbers and dependencies in the pom.xml files, as well as changes to the main application class and test class names. Overall, the commit message and code diff both clearly describe the changes and their functional impact.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Tomcat 8 and Jetty 9 are now the default versions, so the previous samples are no longer relevant. However, we do need integration tests to check that we remain compatible with Tomcat 7 and Jetty 8.' This reason is not easily inferred from the code diff, which only shows the changes in the project structure and dependencies, not the reasons behind them."
https://github.com/apache/dubbo/commit/81e61cc5c3d83b716ca2e712ccdc444c0fff208a,remove unnecessary null check  before instance of (#4321) <enter>  <enter> Signed-off-by: jimin.jm <slievrly@163.com>,https://api.github.com/repos/apache/dubbo/commits/81e61cc5c3d83b716ca2e712ccdc444c0fff208a,"@@ -237,12 +237,12 @@ private static void deserializeInternal(Object result, JavaBeanDescriptor beanDe
             for (Map.Entry<Object, Object> entry : beanDescriptor) {
                 Object key = entry.getKey();
                 Object value = entry.getValue();
-                if (key != null && key instanceof JavaBeanDescriptor) {
+                if (key instanceof JavaBeanDescriptor) {
                     JavaBeanDescriptor keyDescriptor = (JavaBeanDescriptor) entry.getKey();
                     key = instantiateForDeserialize(keyDescriptor, loader, cache);
                     deserializeInternal(key, keyDescriptor, loader, cache);
                 }
-                if (value != null && value instanceof JavaBeanDescriptor) {
+                if (value instanceof JavaBeanDescriptor) {
                     JavaBeanDescriptor valueDescriptor = (JavaBeanDescriptor) entry.getValue();
                     value = instantiateForDeserialize(valueDescriptor, loader, cache);
                     deserializeInternal(value, valueDescriptor, loader, cache);
@@ -47,7 +47,7 @@ public Object get(int index) {
      */
     public boolean getBoolean(int index, boolean def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Boolean ? ((Boolean) tmp).booleanValue() : def;
+        return tmp instanceof Boolean ? ((Boolean) tmp).booleanValue() : def;
     }
 
     /**
@@ -59,7 +59,7 @@ public boolean getBoolean(int index, boolean def) {
      */
     public int getInt(int index, int def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).intValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).intValue() : def;
     }
 
     /**
@@ -71,7 +71,7 @@ public int getInt(int index, int def) {
      */
     public long getLong(int index, long def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).longValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).longValue() : def;
     }
 
     /**
@@ -83,7 +83,7 @@ public long getLong(int index, long def) {
      */
     public float getFloat(int index, float def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).floatValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).floatValue() : def;
     }
 
     /**
@@ -95,7 +95,7 @@ public float getFloat(int index, float def) {
      */
     public double getDouble(int index, double def) {
         Object tmp = mArray.get(index);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).doubleValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).doubleValue() : def;
     }
 
     /**
@@ -47,7 +47,7 @@ public Object get(String key) {
      */
     public boolean getBoolean(String key, boolean def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Boolean ? (Boolean) tmp : def;
+        return tmp instanceof Boolean ? (Boolean) tmp : def;
     }
 
     /**
@@ -59,7 +59,7 @@ public boolean getBoolean(String key, boolean def) {
      */
     public int getInt(String key, int def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).intValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).intValue() : def;
     }
 
     /**
@@ -71,7 +71,7 @@ public int getInt(String key, int def) {
      */
     public long getLong(String key, long def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).longValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).longValue() : def;
     }
 
     /**
@@ -83,7 +83,7 @@ public long getLong(String key, long def) {
      */
     public float getFloat(String key, float def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).floatValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).floatValue() : def;
     }
 
     /**
@@ -95,7 +95,7 @@ public float getFloat(String key, float def) {
      */
     public double getDouble(String key, double def) {
         Object tmp = mMap.get(key);
-        return tmp != null && tmp instanceof Number ? ((Number) tmp).doubleValue() : def;
+        return tmp instanceof Number ? ((Number) tmp).doubleValue() : def;
     }
 
     /**
@@ -90,7 +90,7 @@ public void setReg(boolean reg) {
 
     @Override
     public boolean equals(Object o) {
-        if (o == null || !(o instanceof ProviderInvokerWrapper)) {
+        if (!(o instanceof ProviderInvokerWrapper)) {
             return false;
         }
         ProviderInvokerWrapper other = (ProviderInvokerWrapper) o;
@@ -27,7 +27,7 @@ final class NettyHelper {
 
     public static void setNettyLoggerFactory() {
         InternalLoggerFactory factory = InternalLoggerFactory.getDefaultFactory();
-        if (factory == null || !(factory instanceof DubboLoggerFactory)) {
+        if (!(factory instanceof DubboLoggerFactory)) {
             InternalLoggerFactory.setDefaultFactory(new DubboLoggerFactory());
         }
     }
@@ -452,7 +452,7 @@ private ByteBuf createDubboByteBuf() throws IOException {
     }
 
     private static boolean checkTelnetDecoded(Object msg) {
-        if (msg != null && msg instanceof String && !msg.toString().contains(""Unsupported command:"")) {
+        if (msg instanceof String && !msg.toString().contains(""Unsupported command:"")) {
             return true;
         }
         return false;
",False,"The commit message does not contain an expression that describes the necessity of changes by referencing conventions, standards, improvements in prior commits, or implemented features. It simply states that a null check is being removed, but it does not explain why this is necessary or beneficial.",True,"The commit message 'remove unnecessary null check before instance of (#4321)' clearly describes the change made in the code diff. The null check was removed because it was not necessary, as the code already checks if the object is an instance of JavaBeanDescriptor. This is a common refactoring to simplify code and improve performance.",False,"The commit message does not directly elaborate the motivation of the code change. It only mentions the removal of an unnecessary null check and the issue number. However, the code diff suggests that the null check was removed because the instance of check was already being performed. This indicates that the value cannot be null at that point, making the null check redundant. Therefore, the commit message does not explicitly describe the necessity of the changes.",False,"The commit message 'remove unnecessary null check' does not explicitly describe the source of the requirements or problems in the process of software maintenance. While the code diff indicates that the null checks were removed, it does not provide context about why these checks were originally included or why they are no longer necessary.",False,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only mentions the removal of an unnecessary null check before an instance of check. However, the code diff shows that the null check was removed from multiple places where it was checking if an object was an instance of a certain class before performing an operation. This suggests that the change was made to simplify the code and improve readability, but the commit message does not explicitly state this.",True,"The commit message 'remove unnecessary null check' accurately describes the change made in the diff. The diff shows that null checks before 'instanceof' operations are removed, which is exactly what the commit message states. This is a clear and concise summary of the changes made in the code.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions removing an unnecessary null check, which is a common refactoring but does not necessarily imply a deeper understanding of the code or the system.",True,"The commit message 'remove unnecessary null check' does not explicitly describe the changes from a functional perspective or introduce new behaviors. However, the code diff shows that null checks are being removed from various methods, which could potentially lead to a change in behavior if the code was previously relying on these null checks. For example, the methods getBoolean, getInt, getLong, getFloat, and getDouble now directly cast the object to the expected type without checking if it is null, which could result in a NullPointerException if the object is null.",True,"The commit message 'remove unnecessary null check before instance of' clearly indicates that the change was made to simplify the code. The code diff shows that null checks were removed before the 'instanceof' operator, which were not necessary because the 'instanceof' operator already checks for null. This makes the commit message unnecessary, as the reason for the change is already clear from the code diff."
https://github.com/spring-projects/spring-boot/commit/9a9111af2132ff50afe4aa0704be4bce19cf76fa,"Support path discovery for main dispatcher servlet  <enter> Add an `DispatcherServletPath` interface which provides a much more consistent way to discover the path of the main dispatcher servet. <enter> Prior to this commit, auto-configurations would often make use of the `ServerProperties` class to discover the dispatcher servlet path. This mechanism isn't very explicit and also makes it hard for us to relocate that property in Spring Boot 2.1. <enter> This commit also reverts most of  <otherCommit_link>  since it is now clear that the supporting multiple dispatcher servlet paths will be much more involved that we originally anticipated. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/9a9111af2132ff50afe4aa0704be4bce19cf76fa,"@@ -16,9 +16,6 @@
 
 package org.springframework.boot.actuate.autoconfigure.endpoint.web;
 
-import java.util.Set;
-import java.util.stream.Collectors;
-
 import org.glassfish.jersey.server.ResourceConfig;
 
 import org.springframework.boot.actuate.autoconfigure.endpoint.ExposeExcludePropertyEndpointFilter;
@@ -30,11 +27,10 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
-import org.springframework.util.StringUtils;
 import org.springframework.web.servlet.DispatcherServlet;
 
 /**
@@ -72,27 +68,13 @@ public WebMvcServletEndpointManagementContextConfiguration(
 		public ServletEndpointRegistrar servletEndpointRegistrar(
 				WebEndpointProperties properties,
 				ServletEndpointsSupplier servletEndpointsSupplier) {
-			DispatcherServletPathProvider servletPathProvider = this.context
-					.getBean(DispatcherServletPathProvider.class);
-			Set<String> cleanedPaths = getServletPaths(properties, servletPathProvider);
-			return new ServletEndpointRegistrar(cleanedPaths,
+			DispatcherServletPath dispatcherServletPath = this.context
+					.getBean(DispatcherServletPath.class);
+			return new ServletEndpointRegistrar(
+					dispatcherServletPath.getRelativePath(properties.getBasePath()),
 					servletEndpointsSupplier.getEndpoints());
 		}
 
-		private Set<String> getServletPaths(WebEndpointProperties properties,
-				DispatcherServletPathProvider servletPathProvider) {
-			return servletPathProvider.getServletPaths().stream()
-					.map((p) -> cleanServletPath(p) + properties.getBasePath())
-					.collect(Collectors.toSet());
-		}
-
-		private String cleanServletPath(String servletPath) {
-			if (StringUtils.hasText(servletPath) && servletPath.endsWith(""/"")) {
-				return servletPath.substring(0, servletPath.length() - 1);
-			}
-			return servletPath;
-		}
-
 	}
 
 	@Configuration
@@ -33,7 +33,7 @@
 import org.springframework.boot.actuate.autoconfigure.endpoint.web.WebEndpointProperties;
 import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
 import org.springframework.boot.actuate.endpoint.web.PathMappedEndpoints;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.security.servlet.ApplicationContextRequestMatcher;
 import org.springframework.core.annotation.AnnotatedElementUtils;
 import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
@@ -137,23 +137,20 @@ protected final boolean matches(HttpServletRequest request,
 
 		private RequestMatcher createDelegate(WebApplicationContext context) {
 			try {
-				Set<String> servletPaths = getServletPaths(context);
-				RequestMatcherFactory requestMatcherFactory = new RequestMatcherFactory(
-						servletPaths);
-				return createDelegate(context, requestMatcherFactory);
+				String pathPrefix = getPathPrefix(context);
+				return createDelegate(context, new RequestMatcherFactory(pathPrefix));
 			}
 			catch (NoSuchBeanDefinitionException ex) {
 				return EMPTY_MATCHER;
 			}
 		}
 
-		private Set<String> getServletPaths(WebApplicationContext context) {
+		private String getPathPrefix(WebApplicationContext context) {
 			try {
-				return context.getBean(DispatcherServletPathProvider.class)
-						.getServletPaths();
+				return context.getBean(DispatcherServletPath.class).getPrefix();
 			}
 			catch (NoSuchBeanDefinitionException ex) {
-				return Collections.singleton("""");
+				return """";
 			}
 		}
 
@@ -225,7 +222,7 @@ protected RequestMatcher createDelegate(WebApplicationContext context,
 					requestMatcherFactory, paths);
 			if (this.includeLinks
 					&& StringUtils.hasText(pathMappedEndpoints.getBasePath())) {
-				delegateMatchers.addAll(
+				delegateMatchers.add(
 						requestMatcherFactory.antPath(pathMappedEndpoints.getBasePath()));
 			}
 			return new OrRequestMatcher(delegateMatchers);
@@ -258,8 +255,7 @@ private String getEndpointId(Class<?> source) {
 		private List<RequestMatcher> getDelegateMatchers(
 				RequestMatcherFactory requestMatcherFactory, Set<String> paths) {
 			return paths.stream()
-					.flatMap(
-							(path) -> requestMatcherFactory.antPath(path, ""/**"").stream())
+					.map((path) -> requestMatcherFactory.antPath(path, ""/**""))
 					.collect(Collectors.toList());
 		}
 
@@ -276,9 +272,7 @@ protected RequestMatcher createDelegate(WebApplicationContext context,
 			WebEndpointProperties properties = context
 					.getBean(WebEndpointProperties.class);
 			if (StringUtils.hasText(properties.getBasePath())) {
-				List<RequestMatcher> matchers = requestMatcherFactory
-						.antPath(properties.getBasePath());
-				return new OrRequestMatcher(matchers);
+				return requestMatcherFactory.antPath(properties.getBasePath());
 			}
 			return EMPTY_MATCHER;
 		}
@@ -290,19 +284,18 @@ protected RequestMatcher createDelegate(WebApplicationContext context,
 	 */
 	private static class RequestMatcherFactory {
 
-		private final Set<String> servletPaths = new LinkedHashSet<>();
+		private final String prefix;
 
-		RequestMatcherFactory(Set<String> servletPaths) {
-			this.servletPaths.addAll(servletPaths);
+		RequestMatcherFactory(String prefix) {
+			this.prefix = prefix;
 		}
 
-		List<RequestMatcher> antPath(String... parts) {
-			return this.servletPaths.stream()
-					.map((p) -> (StringUtils.hasText(p) && !p.equals(""/"") ? p : """"))
-					.distinct()
-					.map((path) -> Arrays.stream(parts)
-							.collect(Collectors.joining("""", path, """")))
-					.map(AntPathRequestMatcher::new).collect(Collectors.toList());
+		public RequestMatcher antPath(String... parts) {
+			String pattern = this.prefix;
+			for (String part : parts) {
+				pattern += part;
+			}
+			return new AntPathRequestMatcher(pattern);
 		}
 
 	}
@@ -16,8 +16,6 @@
 
 package org.springframework.boot.actuate.autoconfigure.web.servlet;
 
-import java.util.Collections;
-
 import org.springframework.beans.factory.ListableBeanFactory;
 import org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration;
 import org.springframework.boot.actuate.autoconfigure.web.ManagementContextType;
@@ -27,7 +25,7 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;
 import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;
 import org.springframework.boot.web.servlet.error.ErrorAttributes;
 import org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter;
 import org.springframework.context.annotation.Bean;
@@ -72,6 +70,12 @@ public DispatcherServlet dispatcherServlet() {
 		return dispatcherServlet;
 	}
 
+	@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
+	public DispatcherServletRegistrationBean dispatcherServletRegistrationBean(
+			DispatcherServlet dispatcherServlet) {
+		return new DispatcherServletRegistrationBean(dispatcherServlet, ""/"");
+	}
+
 	@Bean(name = DispatcherServlet.HANDLER_MAPPING_BEAN_NAME)
 	public CompositeHandlerMapping compositeHandlerMapping() {
 		return new CompositeHandlerMapping();
@@ -95,9 +99,4 @@ public RequestContextFilter requestContextFilter() {
 		return new OrderedRequestContextFilter();
 	}
 
-	@Bean
-	public DispatcherServletPathProvider childDispatcherServletPathProvider() {
-		return () -> Collections.singleton("""");
-	}
-
 }
@@ -17,15 +17,13 @@
 package org.springframework.boot.actuate.autoconfigure.endpoint.web;
 
 import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Set;
 
 import org.glassfish.jersey.server.ResourceConfig;
 import org.junit.Test;
 
 import org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar;
 import org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.boot.test.context.FilteredClassLoader;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;
@@ -50,32 +48,27 @@ public class ServletEndpointManagementContextConfigurationTests {
 			.withUserConfiguration(TestConfig.class);
 
 	@Test
-	@SuppressWarnings(""unchecked"")
 	public void contextShouldContainServletEndpointRegistrar() {
 		FilteredClassLoader classLoader = new FilteredClassLoader(ResourceConfig.class);
 		this.contextRunner.withClassLoader(classLoader).run((context) -> {
 			assertThat(context).hasSingleBean(ServletEndpointRegistrar.class);
 			ServletEndpointRegistrar bean = context
 					.getBean(ServletEndpointRegistrar.class);
-			Set<String> basePaths = (Set<String>) ReflectionTestUtils.getField(bean,
-					""basePaths"");
-			assertThat(basePaths).containsExactlyInAnyOrder(""/test/actuator"", ""/actuator"",
-					""/foo/actuator"");
+			String basePath = (String) ReflectionTestUtils.getField(bean, ""basePath"");
+			assertThat(basePath).isEqualTo(""/test/actuator"");
 		});
 	}
 
 	@Test
-	@SuppressWarnings(""unchecked"")
 	public void servletPathShouldNotAffectJerseyConfiguration() {
 		FilteredClassLoader classLoader = new FilteredClassLoader(
 				DispatcherServlet.class);
 		this.contextRunner.withClassLoader(classLoader).run((context) -> {
 			assertThat(context).hasSingleBean(ServletEndpointRegistrar.class);
 			ServletEndpointRegistrar bean = context
 					.getBean(ServletEndpointRegistrar.class);
-			Set<String> basePaths = (Set<String>) ReflectionTestUtils.getField(bean,
-					""basePaths"");
-			assertThat(basePaths).containsExactly(""/actuator"");
+			String basePath = (String) ReflectionTestUtils.getField(bean, ""basePath"");
+			assertThat(basePath).isEqualTo(""/actuator"");
 		});
 	}
 
@@ -97,14 +90,8 @@ public ServletEndpointsSupplier servletEndpointsSupplier() {
 		}
 
 		@Bean
-		public DispatcherServletPathProvider servletPathProvider() {
-			return () -> {
-				Set<String> paths = new LinkedHashSet<>();
-				paths.add(""/"");
-				paths.add(""/test"");
-				paths.add(""/foo/"");
-				return paths;
-			};
+		public DispatcherServletPath dispatcherServletPath() {
+			return () -> ""/test"";
 		}
 
 	}
@@ -17,8 +17,6 @@
 package org.springframework.boot.actuate.autoconfigure.security.servlet;
 
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
 import java.util.List;
 
 import javax.servlet.http.HttpServletRequest;
@@ -33,7 +31,7 @@
 import org.springframework.boot.actuate.endpoint.web.PathMappedEndpoint;
 import org.springframework.boot.actuate.endpoint.web.PathMappedEndpoints;
 import org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint;
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.mock.web.MockHttpServletRequest;
 import org.springframework.mock.web.MockServletContext;
 import org.springframework.security.web.util.matcher.RequestMatcher;
@@ -78,12 +76,11 @@ public void toAnyEndpointShouldNotMatchOtherPath() {
 	@Test
 	public void toAnyEndpointWhenServletPathNotEmptyShouldMatch() {
 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
-		assertMatcher(matcher, ""/actuator"", ""/spring"", ""/admin"")
-				.matches(Arrays.asList(""/spring"", ""/admin""), ""/actuator/foo"");
-		assertMatcher(matcher, ""/actuator"", ""/spring"", ""/admin"")
-				.matches(Arrays.asList(""/spring"", ""/admin""), ""/actuator/bar"");
-		assertMatcher(matcher, ""/actuator"", ""/spring"").matches(Arrays.asList(""/spring""),
-				""/actuator"");
+		assertMatcher(matcher, ""/actuator"", ""/spring"").matches(""/spring"",
+				""/actuator/foo"");
+		assertMatcher(matcher, ""/actuator"", ""/spring"").matches(""/spring"",
+				""/actuator/bar"");
+		assertMatcher(matcher, ""/actuator"", ""/spring"").matches(""/spring"", ""/actuator"");
 		assertMatcher(matcher, ""/actuator"", ""/spring"").doesNotMatch(""/spring"",
 				""/actuator/baz"");
 		assertMatcher(matcher, ""/actuator"", ""/spring"").doesNotMatch("""", ""/actuator/foo"");
@@ -92,10 +89,10 @@ public void toAnyEndpointWhenServletPathNotEmptyShouldMatch() {
 	@Test
 	public void toAnyEndpointWhenDispatcherServletPathProviderNotAvailableUsesEmptyPath() {
 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
-		assertMatcher(matcher, ""/actuator"", (String) null).matches(""/actuator/foo"");
-		assertMatcher(matcher, ""/actuator"", (String) null).matches(""/actuator/bar"");
-		assertMatcher(matcher, ""/actuator"", (String) null).matches(""/actuator"");
-		assertMatcher(matcher, ""/actuator"", (String) null).doesNotMatch(""/actuator/baz"");
+		assertMatcher(matcher, ""/actuator"", null).matches(""/actuator/foo"");
+		assertMatcher(matcher, ""/actuator"", null).matches(""/actuator/bar"");
+		assertMatcher(matcher, ""/actuator"", null).matches(""/actuator"");
+		assertMatcher(matcher, ""/actuator"", null).doesNotMatch(""/actuator/baz"");
 	}
 
 	@Test
@@ -222,8 +219,8 @@ private RequestMatcherAssert assertMatcher(RequestMatcher matcher, String basePa
 	}
 
 	private RequestMatcherAssert assertMatcher(RequestMatcher matcher, String basePath,
-			String... servletPaths) {
-		return assertMatcher(matcher, mockPathMappedEndpoints(basePath), servletPaths);
+			String servletPath) {
+		return assertMatcher(matcher, mockPathMappedEndpoints(basePath), servletPath);
 	}
 
 	private PathMappedEndpoints mockPathMappedEndpoints(String basePath) {
@@ -246,7 +243,7 @@ private RequestMatcherAssert assertMatcher(RequestMatcher matcher,
 	}
 
 	private RequestMatcherAssert assertMatcher(RequestMatcher matcher,
-			PathMappedEndpoints pathMappedEndpoints, String... servletPaths) {
+			PathMappedEndpoints pathMappedEndpoints, String dispatcherServletPath) {
 		StaticWebApplicationContext context = new StaticWebApplicationContext();
 		context.registerBean(WebEndpointProperties.class);
 		if (pathMappedEndpoints != null) {
@@ -257,10 +254,9 @@ private RequestMatcherAssert assertMatcher(RequestMatcher matcher,
 				properties.setBasePath(pathMappedEndpoints.getBasePath());
 			}
 		}
-		if (servletPaths != null) {
-			DispatcherServletPathProvider pathProvider = () -> new LinkedHashSet<>(
-					Arrays.asList(servletPaths));
-			context.registerBean(DispatcherServletPathProvider.class, () -> pathProvider);
+		if (dispatcherServletPath != null) {
+			DispatcherServletPath path = () -> dispatcherServletPath;
+			context.registerBean(DispatcherServletPath.class, () -> path);
 		}
 		return assertThat(new RequestMatcherAssert(context, matcher));
 	}
@@ -280,8 +276,8 @@ public void matches(String servletPath) {
 			matches(mockRequest(servletPath));
 		}
 
-		public void matches(List<String> servletPaths, String pathInfo) {
-			servletPaths.forEach((p) -> matches(mockRequest(p, pathInfo)));
+		public void matches(String servletPath, String pathInfo) {
+			matches(mockRequest(servletPath, pathInfo));
 		}
 
 		private void matches(HttpServletRequest request) {
@@ -18,7 +18,7 @@
 
 import org.junit.Test;
 
-import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPathProvider;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.test.context.runner.WebApplicationContextRunner;
 import org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter;
 import org.springframework.context.annotation.Bean;
@@ -64,12 +64,12 @@ public void contextShouldNotConfigureRequestContextFilterWhenRequestContextListe
 	}
 
 	@Test
-	public void contextShouldConfigureDispatcherServletPathProviderWithEmptyPath() {
+	public void contextShouldConfigureDispatcherServletPathWithRootPath() {
 		this.contextRunner
 				.withUserConfiguration(WebMvcEndpointChildContextConfiguration.class)
-				.run((context) -> assertThat(context
-						.getBean(DispatcherServletPathProvider.class).getServletPaths())
-								.containsExactly(""""));
+				.run((context) -> assertThat(
+						context.getBean(DispatcherServletPath.class).getPath())
+								.isEqualTo(""/""));
 	}
 
 	static class ExistingConfig {
@@ -16,10 +16,7 @@
 
 package org.springframework.boot.actuate.endpoint.web;
 
-import java.util.Arrays;
 import java.util.Collection;
-import java.util.LinkedHashSet;
-import java.util.Set;
 
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
@@ -30,7 +27,6 @@
 
 import org.springframework.boot.web.servlet.ServletContextInitializer;
 import org.springframework.util.Assert;
-import org.springframework.util.CollectionUtils;
 
 /**
  * {@link ServletContextInitializer} to register {@link ExposableServletEndpoint servlet
@@ -44,24 +40,14 @@ public class ServletEndpointRegistrar implements ServletContextInitializer {
 
 	private static final Log logger = LogFactory.getLog(ServletEndpointRegistrar.class);
 
-	private final Set<String> basePaths = new LinkedHashSet<>();
+	private final String basePath;
 
 	private final Collection<ExposableServletEndpoint> servletEndpoints;
 
 	public ServletEndpointRegistrar(String basePath,
 			Collection<ExposableServletEndpoint> servletEndpoints) {
 		Assert.notNull(servletEndpoints, ""ServletEndpoints must not be null"");
-		this.basePaths.add((basePath != null ? basePath : """"));
-		this.servletEndpoints = servletEndpoints;
-	}
-
-	public ServletEndpointRegistrar(Set<String> basePaths,
-			Collection<ExposableServletEndpoint> servletEndpoints) {
-		Assert.notNull(servletEndpoints, ""ServletEndpoints must not be null"");
-		this.basePaths.addAll(basePaths);
-		if (CollectionUtils.isEmpty(this.basePaths)) {
-			this.basePaths.add("""");
-		}
+		this.basePath = (basePath != null ? basePath : """");
 		this.servletEndpoints = servletEndpoints;
 	}
 
@@ -74,24 +60,14 @@ public void onStartup(ServletContext servletContext) throws ServletException {
 	private void register(ServletContext servletContext,
 			ExposableServletEndpoint endpoint) {
 		String name = endpoint.getId() + ""-actuator-endpoint"";
+		String path = this.basePath + ""/"" + endpoint.getRootPath();
+		String urlMapping = (path.endsWith(""/"") ? path + ""*"" : path + ""/*"");
 		EndpointServlet endpointServlet = endpoint.getEndpointServlet();
 		Dynamic registration = servletContext.addServlet(name,
 				endpointServlet.getServlet());
-		String[] urlMappings = getUrlMappings(endpoint.getRootPath());
-		registration.addMapping(urlMappings);
-		if (logger.isInfoEnabled()) {
-			Arrays.stream(urlMappings).forEach(
-					(mapping) -> logger.info(""Registered '"" + mapping + ""' to "" + name));
-		}
+		registration.addMapping(urlMapping);
 		registration.setInitParameters(endpointServlet.getInitParameters());
-	}
-
-	private String[] getUrlMappings(String endpointPath) {
-		return this.basePaths.stream()
-				.map((basePath) -> (basePath != null ? basePath + ""/"" + endpointPath
-						: ""/"" + endpointPath))
-				.distinct().map((path) -> (path.endsWith(""/"") ? path + ""*"" : path + ""/*""))
-				.toArray(String[]::new);
+		logger.info(""Registered '"" + path + ""' to "" + name);
 	}
 
 }
@@ -18,8 +18,6 @@
 
 import java.io.IOException;
 import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Set;
 
 import javax.servlet.GenericServlet;
 import javax.servlet.Servlet;
@@ -49,7 +47,6 @@
  * Tests for {@link ServletEndpointRegistrar}.
  *
  * @author Phillip Webb
- * @author Madhura Bhave
  */
 public class ServletEndpointRegistrarTests {
 
@@ -76,14 +73,14 @@ public void setup() {
 	public void createWhenServletEndpointsIsNullShouldThrowException() {
 		this.thrown.expect(IllegalArgumentException.class);
 		this.thrown.expectMessage(""ServletEndpoints must not be null"");
-		new ServletEndpointRegistrar((String) null, null);
+		new ServletEndpointRegistrar(null, null);
 	}
 
 	@Test
 	public void onStartupShouldRegisterServlets() throws Exception {
 		ExposableServletEndpoint endpoint = mockEndpoint(
 				new EndpointServlet(TestServlet.class));
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar((String) null,
+		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(null,
 				Collections.singleton(endpoint));
 		registrar.onStartup(this.servletContext);
 		verify(this.servletContext).addServlet(eq(""test-actuator-endpoint""),
@@ -105,64 +102,6 @@ public void onStartupWhenHasBasePathShouldIncludeBasePath() throws Exception {
 		verify(this.dynamic).addMapping(""/actuator/test/*"");
 	}
 
-	@Test
-	public void onStartupWhenHasMultipleBasePathsShouldIncludeAllBasePaths()
-			throws Exception {
-		ExposableServletEndpoint endpoint = mockEndpoint(
-				new EndpointServlet(TestServlet.class));
-		Set<String> basePaths = new LinkedHashSet<>();
-		basePaths.add(""/actuator"");
-		basePaths.add(""/admin"");
-		basePaths.add(""/application"");
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePaths,
-				Collections.singleton(endpoint));
-		registrar.onStartup(this.servletContext);
-		verify(this.servletContext).addServlet(eq(""test-actuator-endpoint""),
-				this.servlet.capture());
-		assertThat(this.servlet.getValue()).isInstanceOf(TestServlet.class);
-		ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
-		verify(this.dynamic).addMapping(captor.capture());
-		assertThat(captor.getAllValues()).containsExactlyInAnyOrder(""/application/test/*"",
-				""/admin/test/*"", ""/actuator/test/*"");
-	}
-
-	@Test
-	public void onStartupWhenHasEmptyBasePathsShouldIncludeRoot() throws Exception {
-		ExposableServletEndpoint endpoint = mockEndpoint(
-				new EndpointServlet(TestServlet.class));
-		Set<String> basePaths = Collections.emptySet();
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePaths,
-				Collections.singleton(endpoint));
-		registrar.onStartup(this.servletContext);
-		verify(this.dynamic).addMapping(""/test/*"");
-	}
-
-	@Test
-	public void onStartupWhenHasBasePathsHasNullValueShouldIncludeRoot()
-			throws Exception {
-		ExposableServletEndpoint endpoint = mockEndpoint(
-				new EndpointServlet(TestServlet.class));
-		Set<String> basePaths = new LinkedHashSet<>();
-		basePaths.add(null);
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePaths,
-				Collections.singleton(endpoint));
-		registrar.onStartup(this.servletContext);
-		verify(this.dynamic).addMapping(""/test/*"");
-	}
-
-	@Test
-	public void onStartupWhenDuplicateValuesShouldIncludeDistinct() throws Exception {
-		ExposableServletEndpoint endpoint = mockEndpoint(
-				new EndpointServlet(TestServlet.class));
-		Set<String> basePaths = new LinkedHashSet<>();
-		basePaths.add("""");
-		basePaths.add(null);
-		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePaths,
-				Collections.singleton(endpoint));
-		registrar.onStartup(this.servletContext);
-		verify(this.dynamic).addMapping(""/test/*"");
-	}
-
 	@Test
 	public void onStartupWhenHasInitParametersShouldRegisterInitParameters()
 			throws Exception {
@@ -27,7 +27,7 @@
 import javax.servlet.http.HttpServletRequest;
 
 import org.springframework.boot.autoconfigure.security.StaticResourceLocation;
-import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.security.servlet.ApplicationContextRequestMatcher;
 import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
 import org.springframework.security.web.util.matcher.OrRequestMatcher;
@@ -96,14 +96,14 @@ public StaticResourceRequestMatcher at(Set<StaticResourceLocation> locations) {
 	 * Locations}.
 	 */
 	public static final class StaticResourceRequestMatcher
-			extends ApplicationContextRequestMatcher<ServerProperties> {
+			extends ApplicationContextRequestMatcher<DispatcherServletPath> {
 
 		private final Set<StaticResourceLocation> locations;
 
 		private volatile RequestMatcher delegate;
 
 		private StaticResourceRequestMatcher(Set<StaticResourceLocation> locations) {
-			super(ServerProperties.class);
+			super(DispatcherServletPath.class);
 			this.locations = locations;
 		}
 
@@ -134,25 +134,26 @@ public StaticResourceRequestMatcher excluding(
 		}
 
 		@Override
-		protected void initialized(Supplier<ServerProperties> serverProperties) {
+		protected void initialized(
+				Supplier<DispatcherServletPath> dispatcherServletPath) {
 			this.delegate = new OrRequestMatcher(
-					getDelegateMatchers(serverProperties.get()));
+					getDelegateMatchers(dispatcherServletPath.get()));
 		}
 
 		private List<RequestMatcher> getDelegateMatchers(
-				ServerProperties serverProperties) {
-			return getPatterns(serverProperties).map(AntPathRequestMatcher::new)
+				DispatcherServletPath dispatcherServletPath) {
+			return getPatterns(dispatcherServletPath).map(AntPathRequestMatcher::new)
 					.collect(Collectors.toList());
 		}
 
-		private Stream<String> getPatterns(ServerProperties serverProperties) {
+		private Stream<String> getPatterns(DispatcherServletPath dispatcherServletPath) {
 			return this.locations.stream().flatMap(StaticResourceLocation::getPatterns)
-					.map(serverProperties.getServlet()::getPath);
+					.map(dispatcherServletPath::getRelativePath);
 		}
 
 		@Override
 		protected boolean matches(HttpServletRequest request,
-				Supplier<ServerProperties> context) {
+				Supplier<DispatcherServletPath> context) {
 			return this.delegate.matches(request);
 		}
 
@@ -269,6 +269,13 @@ public Session getSession() {
 			return this.session;
 		}
 
+		/**
+		 * Return the mapping used to map a servlet to the path.
+		 * @return the servlet mapping
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getServletUrlMapping}
+		 */
+		@Deprecated
 		public String getServletMapping() {
 			if (this.path.equals("""") || this.path.equals(""/"")) {
 				return ""/"";
@@ -282,6 +289,14 @@ public String getServletMapping() {
 			return this.path + ""/*"";
 		}
 
+		/**
+		 * Return a path relative to the servlet prefix.
+		 * @param path the path to make relative
+		 * @return the relative path
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getRelativePath(String)}
+		 */
+		@Deprecated
 		public String getPath(String path) {
 			String prefix = getServletPrefix();
 			if (!path.startsWith(""/"")) {
@@ -290,6 +305,13 @@ public String getPath(String path) {
 			return prefix + path;
 		}
 
+		/**
+		 * Return the servlet prefix.
+		 * @return the servlet prefix
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getPrefix()}
+		 */
+		@Deprecated
 		public String getServletPrefix() {
 			String result = this.path;
 			int index = result.indexOf('*');
@@ -302,6 +324,14 @@ public String getServletPrefix() {
 			return result;
 		}
 
+		/**
+		 * Create a array of relative paths from the given source.
+		 * @param paths the source paths
+		 * @return the relative paths
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getRelativePath(String)}
+		 */
+		@Deprecated
 		public String[] getPathsArray(Collection<String> paths) {
 			String[] result = new String[paths.size()];
 			int i = 0;
@@ -311,6 +341,14 @@ public String[] getPathsArray(Collection<String> paths) {
 			return result;
 		}
 
+		/**
+		 * Create a array of relative paths from the given source.
+		 * @param paths the source paths
+		 * @return the relative paths
+		 * @deprecated since 2.0.4 in favor of
+		 * {@link org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath#getRelativePath(String)}
+		 */
+		@Deprecated
 		public String[] getPathsArray(String[] paths) {
 			String[] result = new String[paths.length];
 			int i = 0;
@@ -17,7 +17,6 @@
 package org.springframework.boot.autoconfigure.web.servlet;
 
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import javax.servlet.MultipartConfigElement;
@@ -34,7 +33,6 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;
 import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
@@ -139,11 +137,10 @@ public DispatcherServletRegistrationConfiguration(
 
 		@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
 		@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
-		public ServletRegistrationBean<DispatcherServlet> dispatcherServletRegistration(
+		public DispatcherServletRegistrationBean dispatcherServletRegistration(
 				DispatcherServlet dispatcherServlet) {
-			ServletRegistrationBean<DispatcherServlet> registration = new ServletRegistrationBean<>(
-					dispatcherServlet,
-					this.serverProperties.getServlet().getServletMapping());
+			DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(
+					dispatcherServlet, this.serverProperties.getServlet().getPath());
 			registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
 			registration.setLoadOnStartup(
 					this.webMvcProperties.getServlet().getLoadOnStartup());
@@ -153,15 +150,6 @@ public ServletRegistrationBean<DispatcherServlet> dispatcherServletRegistration(
 			return registration;
 		}
 
-		@Bean
-		@ConditionalOnMissingBean(DispatcherServletPathProvider.class)
-		@ConditionalOnSingleCandidate(DispatcherServlet.class)
-		public DispatcherServletPathProvider dispatcherServletPathProvider() {
-			return () -> Collections.singleton(
-					DispatcherServletRegistrationConfiguration.this.serverProperties
-							.getServlet().getPath());
-		}
-
 	}
 
 	@Order(Ordered.LOWEST_PRECEDENCE - 10)
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.web.servlet;
+
+import org.springframework.boot.web.servlet.ServletRegistrationBean;
+import org.springframework.web.servlet.DispatcherServlet;
+
+/**
+ * Interface that can be used by auto-configurations that need path details for the
+ * {@link DispatcherServletAutoConfiguration#DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME
+ * default} {@link DispatcherServlet}.
+ *
+ * @author Madhura Bhave
+ * @author Stephane Nicoll
+ * @since 2.0.4
+ */
+@FunctionalInterface
+public interface DispatcherServletPath {
+
+	/**
+	 * Returns the configured path of the dispatcher servlet.
+	 * @return the configured path
+	 */
+	String getPath();
+
+	/**
+	 * Return a form of the given path that's relative to the dispatcher servlet path.
+	 * @param path the path to make relative
+	 * @return the relative path
+	 */
+	default String getRelativePath(String path) {
+		String prefix = getPrefix();
+		if (!path.startsWith(""/"")) {
+			path = ""/"" + path;
+		}
+		return prefix + path;
+	}
+
+	/**
+	 * Return a cleaned up version of the path that can be used as a prefix for URLs. The
+	 * resulting path will have path will not have a trailing slash.
+	 * @return the prefix
+	 * @see #getRelativePath(String)
+	 */
+	default String getPrefix() {
+		String result = getPath();
+		int index = result.indexOf('*');
+		if (index != -1) {
+			result = result.substring(0, index);
+		}
+		if (result.endsWith(""/"")) {
+			result = result.substring(0, result.length() - 1);
+		}
+		return result;
+	}
+
+	/**
+	 * Return a URL mapping pattern that can be used with a
+	 * {@link ServletRegistrationBean} to map the dispatcher servlet.
+	 * @return the path as a servlet URL mapping
+	 */
+	default String getServletUrlMapping() {
+		if (getPath().equals("""") || getPath().equals(""/"")) {
+			return ""/"";
+		}
+		if (getPath().contains(""*"")) {
+			return getPath();
+		}
+		if (getPath().endsWith(""/"")) {
+			return getPath() + ""*"";
+		}
+		return getPath() + ""/*"";
+	}
+
+}
@@ -16,8 +16,6 @@
 
 package org.springframework.boot.autoconfigure.web.servlet;
 
-import java.util.Set;
-
 import org.springframework.web.servlet.DispatcherServlet;
 
 /**
@@ -26,10 +24,13 @@
  *
  * @author Madhura Bhave
  * @since 2.0.2
+ * @deprecated since 2.0.4 in favor of {@link DispatcherServletPath} and
+ * {@link DispatcherServletRegistrationBean}
  */
+@Deprecated
 @FunctionalInterface
 public interface DispatcherServletPathProvider {
 
-	Set<String> getServletPaths();
+	String getServletPath();
 
 }
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.web.servlet;
+
+import java.util.Collection;
+
+import org.springframework.boot.web.servlet.ServletRegistrationBean;
+import org.springframework.util.Assert;
+import org.springframework.web.servlet.DispatcherServlet;
+
+/**
+ * {@link ServletRegistrationBean} for the auto-configured {@link DispatcherServlet}. Both
+ * registeres the servlet and exposes {@link DispatcherServletPath} information.
+ *
+ * @author Phillip Webb
+ * @since 2.0.4
+ */
+public class DispatcherServletRegistrationBean extends
+		ServletRegistrationBean<DispatcherServlet> implements DispatcherServletPath {
+
+	private final String path;
+
+	/**
+	 * Create a new {@link DispatcherServletRegistrationBean} instance for the given
+	 * servlet and path.
+	 * @param servlet the dispatcher servlet
+	 * @param path the dispatcher servlet path
+	 */
+	public DispatcherServletRegistrationBean(DispatcherServlet servlet, String path) {
+		super(servlet);
+		Assert.notNull(path, ""Path must not be null"");
+		this.path = path;
+		super.addUrlMappings(getServletUrlMapping());
+	}
+
+	@Override
+	public String getPath() {
+		return this.path;
+	}
+
+	@Override
+	public void setUrlMappings(Collection<String> urlMappings) {
+		throw new UnsupportedOperationException(
+				""URL Mapping cannot be changed on a DispatcherServlet registration"");
+	}
+
+	@Override
+	public void addUrlMappings(String... urlMappings) {
+		throw new UnsupportedOperationException(
+				""URL Mapping cannot be changed on a DispatcherServlet registration"");
+	}
+
+}
@@ -49,6 +49,7 @@
 import org.springframework.boot.autoconfigure.template.TemplateAvailabilityProviders;
 import org.springframework.boot.autoconfigure.web.ResourceProperties;
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.boot.web.server.ErrorPage;
@@ -94,11 +95,15 @@ public class ErrorMvcAutoConfiguration {
 
 	private final ServerProperties serverProperties;
 
+	private final DispatcherServletPath dispatcherServletPath;
+
 	private final List<ErrorViewResolver> errorViewResolvers;
 
 	public ErrorMvcAutoConfiguration(ServerProperties serverProperties,
+			DispatcherServletPath dispatcherServletPath,
 			ObjectProvider<List<ErrorViewResolver>> errorViewResolversProvider) {
 		this.serverProperties = serverProperties;
+		this.dispatcherServletPath = dispatcherServletPath;
 		this.errorViewResolvers = errorViewResolversProvider.getIfAvailable();
 	}
 
@@ -118,7 +123,7 @@ public BasicErrorController basicErrorController(ErrorAttributes errorAttributes
 
 	@Bean
 	public ErrorPageCustomizer errorPageCustomizer() {
-		return new ErrorPageCustomizer(this.serverProperties);
+		return new ErrorPageCustomizer(this.serverProperties, this.dispatcherServletPath);
 	}
 
 	@Bean
@@ -327,15 +332,18 @@ private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered
 
 		private final ServerProperties properties;
 
-		protected ErrorPageCustomizer(ServerProperties properties) {
+		private final DispatcherServletPath dispatcherServletPath;
+
+		protected ErrorPageCustomizer(ServerProperties properties,
+				DispatcherServletPath dispatcherServletPath) {
 			this.properties = properties;
+			this.dispatcherServletPath = dispatcherServletPath;
 		}
 
 		@Override
 		public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {
-			ErrorPage errorPage = new ErrorPage(
-					this.properties.getServlet().getServletPrefix()
-							+ this.properties.getError().getPath());
+			ErrorPage errorPage = new ErrorPage(this.dispatcherServletPath
+					.getRelativePath(this.properties.getError().getPath()));
 			errorPageRegistry.addErrorPages(errorPage);
 		}
 
@@ -25,6 +25,7 @@
 
 import org.springframework.boot.autoconfigure.security.StaticResourceLocation;
 import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.mock.web.MockHttpServletRequest;
 import org.springframework.mock.web.MockServletContext;
 import org.springframework.security.web.util.matcher.RequestMatcher;
@@ -96,15 +97,20 @@ public void excludeFromSetWhenSetIsNullShouldThrowException() {
 	}
 
 	private RequestMatcherAssert assertMatcher(RequestMatcher matcher) {
+		DispatcherServletPath dispatcherServletPath = () -> """";
 		StaticWebApplicationContext context = new StaticWebApplicationContext();
 		context.registerBean(ServerProperties.class);
+		context.registerBean(DispatcherServletPath.class, () -> dispatcherServletPath);
 		return assertThat(new RequestMatcherAssert(context, matcher));
 	}
 
 	private RequestMatcherAssert assertMatcher(RequestMatcher matcher,
 			ServerProperties serverProperties) {
+		DispatcherServletPath dispatcherServletPath = () -> serverProperties.getServlet()
+				.getPath();
 		StaticWebApplicationContext context = new StaticWebApplicationContext();
 		context.registerBean(ServerProperties.class, () -> serverProperties);
+		context.registerBean(DispatcherServletPath.class, () -> dispatcherServletPath);
 		return assertThat(new RequestMatcherAssert(context, matcher));
 	}
 
@@ -79,13 +79,15 @@ public void testConnectionTimeout() {
 	}
 
 	@Test
+	@Deprecated
 	public void testServletPathAsMapping() {
 		bind(""server.servlet.path"", ""/foo/*"");
 		assertThat(this.properties.getServlet().getServletMapping()).isEqualTo(""/foo/*"");
 		assertThat(this.properties.getServlet().getServletPrefix()).isEqualTo(""/foo"");
 	}
 
 	@Test
+	@Deprecated
 	public void testServletPathAsPrefix() {
 		bind(""server.servlet.path"", ""/foo"");
 		assertThat(this.properties.getServlet().getServletMapping()).isEqualTo(""/foo/*"");
@@ -66,8 +66,7 @@ public void registrationNonServletBean() {
 				.run((context) -> {
 					assertThat(context).doesNotHaveBean(ServletRegistrationBean.class);
 					assertThat(context).doesNotHaveBean(DispatcherServlet.class);
-					assertThat(context)
-							.doesNotHaveBean(DispatcherServletPathProvider.class);
+					assertThat(context).doesNotHaveBean(DispatcherServletPath.class);
 				});
 	}
 
@@ -77,7 +76,7 @@ public void registrationNonServletBean() {
 	public void registrationOverrideWithDispatcherServletWrongName() {
 		this.contextRunner
 				.withUserConfiguration(CustomDispatcherServletDifferentName.class,
-						CustomDispatcherServletPathProvider.class)
+						CustomDispatcherServletPath.class)
 				.run((context) -> {
 					ServletRegistrationBean<?> registration = context
 							.getBean(ServletRegistrationBean.class);
@@ -91,7 +90,7 @@ public void registrationOverrideWithDispatcherServletWrongName() {
 	@Test
 	public void registrationOverrideWithAutowiredServlet() {
 		this.contextRunner.withUserConfiguration(CustomAutowiredRegistration.class,
-				CustomDispatcherServletPathProvider.class).run((context) -> {
+				CustomDispatcherServletPath.class).run((context) -> {
 					ServletRegistrationBean<?> registration = context
 							.getBean(ServletRegistrationBean.class);
 					assertThat(registration.getUrlMappings()).containsExactly(""/foo"");
@@ -111,43 +110,35 @@ public void servletPath() {
 					assertThat(registration.getUrlMappings())
 							.containsExactly(""/spring/*"");
 					assertThat(registration.getMultipartConfig()).isNull();
-					assertThat(context.getBean(DispatcherServletPathProvider.class)
-							.getServletPaths()).containsExactly(""/spring"");
+					assertThat(context.getBean(DispatcherServletPath.class).getPath())
+							.isEqualTo(""/spring"");
 				});
 	}
 
 	@Test
-	public void pathProviderNotCreatedWhenMultipleDispatcherServletsPresent() {
-		this.contextRunner
-				.withUserConfiguration(CustomDispatcherServletDifferentName.class)
-				.run((context) -> assertThat(context)
-						.doesNotHaveBean(DispatcherServletPathProvider.class));
-	}
-
-	@Test
-	public void pathProviderWhenCustomDispatcherServletSameNameShouldReturnConfiguredServletPath() {
+	public void dispatcherServletPathWhenCustomDispatcherServletSameNameShouldReturnConfiguredServletPath() {
 		this.contextRunner.withUserConfiguration(CustomDispatcherServletSameName.class)
 				.withPropertyValues(""server.servlet.path:/spring"")
-				.run((context) -> assertThat(context
-						.getBean(DispatcherServletPathProvider.class).getServletPaths())
-								.containsExactly(""/spring""));
+				.run((context) -> assertThat(
+						context.getBean(DispatcherServletPath.class).getPath())
+								.isEqualTo(""/spring""));
 	}
 
 	@Test
-	public void pathProviderNotCreatedWhenDefaultDispatcherServletNotAvailable() {
+	public void dispatcherServletPathNotCreatedWhenDefaultDispatcherServletNotAvailable() {
 		this.contextRunner
 				.withUserConfiguration(CustomDispatcherServletDifferentName.class,
 						NonServletConfiguration.class)
 				.run((context) -> assertThat(context)
-						.doesNotHaveBean(DispatcherServletPathProvider.class));
+						.doesNotHaveBean(DispatcherServletPath.class));
 	}
 
 	@Test
-	public void pathProviderNotCreatedWhenCustomRegistrationBeanPresent() {
+	public void dispatcherServletPathNotCreatedWhenCustomRegistrationBeanPresent() {
 		this.contextRunner
 				.withUserConfiguration(CustomDispatcherServletRegistration.class)
 				.run((context) -> assertThat(context)
-						.doesNotHaveBean(DispatcherServletPathProvider.class));
+						.doesNotHaveBean(DispatcherServletPath.class));
 	}
 
 	@Test
@@ -237,11 +228,11 @@ public DispatcherServlet customDispatcherServlet() {
 	}
 
 	@Configuration
-	protected static class CustomDispatcherServletPathProvider {
+	protected static class CustomDispatcherServletPath {
 
 		@Bean
-		public DispatcherServletPathProvider dispatcherServletPathProvider() {
-			return mock(DispatcherServletPathProvider.class);
+		public DispatcherServletPath dispatcherServletPath() {
+			return mock(DispatcherServletPath.class);
 		}
 
 	}
@@ -259,8 +250,8 @@ public ServletRegistrationBean<?> dispatcherServletRegistration(
 		}
 
 		@Bean
-		public DispatcherServletPathProvider dispatcherServletPathProvider() {
-			return mock(DispatcherServletPathProvider.class);
+		public DispatcherServletPath dispatcherServletPath() {
+			return mock(DispatcherServletPath.class);
 		}
 
 	}
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.web.servlet;
+
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link DispatcherServletPath}.
+ *
+ * @author Phillip Webb
+ */
+public class DispatcherServletPathTests {
+
+	@Test
+	public void getRelativePathReturnsRelativePath() {
+		assertThat(((DispatcherServletPath) () -> ""spring"").getRelativePath(""boot""))
+				.isEqualTo(""spring/boot"");
+		assertThat(((DispatcherServletPath) () -> ""spring/"").getRelativePath(""boot""))
+				.isEqualTo(""spring/boot"");
+		assertThat(((DispatcherServletPath) () -> ""spring"").getRelativePath(""/boot""))
+				.isEqualTo(""spring/boot"");
+	}
+
+	@Test
+	public void getPrefixWhenHasSimplePathReturnPath() {
+		assertThat(((DispatcherServletPath) () -> ""spring"").getPrefix())
+				.isEqualTo(""spring"");
+	}
+
+	@Test
+	public void getPrefixWhenHasPatternRemovesPattern() {
+		assertThat(((DispatcherServletPath) () -> ""spring/*.do"").getPrefix())
+				.isEqualTo(""spring"");
+	}
+
+	@Test
+	public void getPathWhenPathEndsWithSlashRemovesSlash() {
+		assertThat(((DispatcherServletPath) () -> ""spring/"").getPrefix())
+				.isEqualTo(""spring"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenPathIsEmptyReturnsSlash() {
+		assertThat(((DispatcherServletPath) () -> """").getServletUrlMapping())
+				.isEqualTo(""/"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenPathIsSlashReturnsSlash() {
+		assertThat(((DispatcherServletPath) () -> ""/"").getServletUrlMapping())
+				.isEqualTo(""/"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenPathContainsStarReturnsPath() {
+		assertThat(((DispatcherServletPath) () -> ""spring/*.do"").getServletUrlMapping())
+				.isEqualTo(""spring/*.do"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenHasPathNotEndingSlashReturnsSlashStarPattern() {
+		assertThat(((DispatcherServletPath) () -> ""spring/boot"").getServletUrlMapping())
+				.isEqualTo(""spring/boot/*"");
+	}
+
+	@Test
+	public void getServletUrlMappingWhenHasPathEndingWithSlashReturnsSlashStarPattern() {
+		assertThat(((DispatcherServletPath) () -> ""spring/boot/"").getServletUrlMapping())
+				.isEqualTo(""spring/boot/*"");
+	}
+
+}
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.web.servlet;
+
+import java.util.Collections;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import org.springframework.web.servlet.DispatcherServlet;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link DispatcherServletRegistrationBean}.
+ *
+ * @author Phillip Webb
+ */
+public class DispatcherServletRegistrationBeanTests {
+
+	@Rule
+	public ExpectedException thrown = ExpectedException.none();
+
+	@Test
+	public void createWhenPathIsNullThrowsException() {
+		this.thrown.expect(IllegalArgumentException.class);
+		this.thrown.expectMessage(""Path must not be null"");
+		new DispatcherServletRegistrationBean(new DispatcherServlet(), null);
+	}
+
+	@Test
+	public void getPathReturnsPath() {
+		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(
+				new DispatcherServlet(), ""/test"");
+		assertThat(bean.getPath()).isEqualTo(""/test"");
+	}
+
+	@Test
+	public void getUrlMappingsReturnsSinglePathMappedPattern() {
+		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(
+				new DispatcherServlet(), ""/test"");
+		assertThat(bean.getUrlMappings()).containsOnly(""/test/*"");
+	}
+
+	@Test
+	public void setUrlMappingsCannotBeCalled() {
+		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(
+				new DispatcherServlet(), ""/test"");
+		this.thrown.expect(UnsupportedOperationException.class);
+		bean.setUrlMappings(Collections.emptyList());
+	}
+
+	@Test
+	public void addUrlMappingsCannotBeCalled() {
+		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(
+				new DispatcherServlet(), ""/test"");
+		this.thrown.expect(UnsupportedOperationException.class);
+		bean.addUrlMappings(""/test"");
+	}
+
+}
@@ -20,6 +20,7 @@
 import org.junit.Test;
 
 import org.springframework.boot.autoconfigure.AutoConfigurations;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;
 import org.springframework.boot.test.context.runner.WebApplicationContextRunner;
 import org.springframework.boot.test.rule.OutputCapture;
 import org.springframework.boot.web.servlet.error.ErrorAttributes;
@@ -39,7 +40,9 @@
 public class ErrorMvcAutoConfigurationTests {
 
 	private WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
-			.withConfiguration(AutoConfigurations.of(ErrorMvcAutoConfiguration.class));
+			.withConfiguration(
+					AutoConfigurations.of(DispatcherServletAutoConfiguration.class,
+							ErrorMvcAutoConfiguration.class));
 
 	@Rule
 	public OutputCapture outputCapture = new OutputCapture();
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,8 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;
+import org.springframework.boot.autoconfigure.web.ServerProperties;
+import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath;
 import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
 import org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
@@ -48,19 +50,28 @@
 @Configuration
 @ConditionalOnWebApplication(type = Type.SERVLET)
 @AutoConfigureAfter(WebMvcAutoConfiguration.class)
-@EnableConfigurationProperties(WebMvcProperties.class)
+@EnableConfigurationProperties({ ServerProperties.class, WebMvcProperties.class })
 public class MockMvcAutoConfiguration {
 
 	private final WebApplicationContext context;
 
+	private final ServerProperties serverProperties;
+
 	private final WebMvcProperties webMvcProperties;
 
 	MockMvcAutoConfiguration(WebApplicationContext context,
-			WebMvcProperties webMvcProperties) {
+			ServerProperties serverProperties, WebMvcProperties webMvcProperties) {
 		this.context = context;
+		this.serverProperties = serverProperties;
 		this.webMvcProperties = webMvcProperties;
 	}
 
+	@Bean
+	@ConditionalOnMissingBean
+	public DispatcherServletPath dispatcherServletPath() {
+		return () -> this.serverProperties.getServlet().getPath();
+	}
+
 	@Bean
 	@ConditionalOnMissingBean(MockMvcBuilder.class)
 	public DefaultMockMvcBuilder mockMvcBuilder(
",True,"The commit message refers to the need to provide a more consistent way to discover the path of the main dispatcher servlet, which was previously done using the `ServerProperties` class. This change is necessary to make it easier to relocate that property in Spring Boot 2.1 and to support multiple dispatcher servlet paths, which was not originally anticipated.",True,"The commit message refers to the need to discover the path of the main dispatcher servlet in a more consistent and explicit way. This is done by introducing a new `DispatcherServletPath` interface, which provides a method to retrieve the path. This change is necessary to make it easier to relocate the dispatcher servlet path in Spring Boot 2.1, and to avoid the use of the `ServerProperties` class, which was not very explicit and made it hard to relocate the property.",True,"The commit message explains that the previous implementation of supporting multiple dispatcher servlet paths was more complex than anticipated, and that the changes made in this commit are necessary to clarify the configuration and make it more explicit. Additionally, the message mentions that it is closing an issue, which suggests that there was a problem or feature request that this commit is addressing.",,,True,"The commit message directly mentions the change will provide a much more consistent way to discover the path of the main dispatcher servlet, which improves the code.",,,,,,,True,"The commit message does not explicitly state the reason for the change, but it can be inferred from the code diff. The change is removing the use of DispatcherServletPathProvider and replacing it with DispatcherServletPath. This is likely done to simplify the code and make it more consistent. Additionally, the commit message mentions that the supporting multiple dispatcher servlet paths will be much more involved than originally anticipated, which suggests that the change is being made to simplify the codebase and prepare for future changes."
https://github.com/spring-projects/spring-boot/commit/fcf468062602966c508c260ef54da55e2d48c49a,Polish 'Document how to add metadata for collection and enum default values' <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/fcf468062602966c508c260ef54da55e2d48c49a,"@@ -815,20 +815,21 @@ The annotation processor also supports the use of the `@Data`, `@Getter`, and `@
 lombok annotations.
 
 
-The annotation processor cannot auto-detect default values for ``Enum``s and ``Collections``s.
-In the cases where a `Collection` or `Enum` property has a non-empty default value,
-<<configuration-metadata-additional-metadata,manual metadata>> should be provided.
+The annotation processor cannot auto-detect default values for ``Enum``s and
+``Collections``s. In the cases where a `Collection` or `Enum` property has a non-empty
+default value, <<configuration-metadata-additional-metadata,manual metadata>> should be
+provided.
 
 Consider the following class:
 
 [source,java,indent=0,subs=""verbatim,quotes,attributes""]
 ----
-	@ConfigurationProperties(prefix=""rabbit"")
-	public class RabbitProperties {
+	@ConfigurationProperties(prefix=""acme.messaging"")
+	public class MessagingProperties {
 
 		private List<String> addresses = new ArrayList<>(Arrays.asList(""a"", ""b"")) ;
 
-		private ContainerType  = ContainerType.SIMPLE;
+		private ContainerType = ContainerType.SIMPLE;
 
 		// ... getter and setters
 
@@ -843,21 +844,27 @@ Consider the following class:
 	}
 ----
 
-In order to document default values for properties in the class above, you could add the following
-JSON to <<configuration-metadata-additional-metadata,the manual metadata of the module>>:
+In order to document default values for properties in the class above, you could add the
+following content to <<configuration-metadata-additional-metadata,the manual metadata of
+the module>>:
 
 [source,json,indent=0]
 ----
-	{
-		""name"": ""rabbit.addresses"",
-		""defaultValue"": ""a, b""
-	},
-	{
-		""name"": ""rabbit.container-type"",
-		""defaultValue"": ""simple""
-	}
+	{""properties"": [
+		{
+			""name"": ""acme.messaging.addresses"",
+			""defaultValue"": [""a, b""]
+		},
+		{
+			""name"": ""acme.messaging.container-type"",
+			""defaultValue"": ""simple""
+		}
+	]}
 ----
 
+Only the `name` of the property is required to document additional fields with manual
+metadata.
+
 
 [NOTE]
 ====
",True,"The commit message refers to the necessity of changes by referencing a convention. It mentions the need to document default values for properties in a class, which is a common practice to improve the understandability and usability of the code.",True,"The commit message 'Polish ...' does not explicitly state the necessity of changes, but it is easy to infer from the code diff that the changes are made to improve the documentation. Specifically, the commit message refers to 'Document how to add metadata for collection and enum default values', and the diff shows the addition of examples and explanations to clarify how to document default values for properties in a class.",True,"The commit message 'Polish ...' refers to the issue of documenting default values for Collections and Enums, which the diff shows is being addressed by providing manual metadata. This directly elaborates the motivation of the code change, which is to improve documentation and clarity.",True,"The commit message 'Polish 'Document how to add metadata for collection and enum default values'' indicates that the developer is addressing a need for better documentation. The code diff shows that the documentation is being updated to explain how to manually add metadata for default values of Collections and Enums, which are not automatically detected by the annotation processor. This suggests that there was a problem in the process of software maintenance, specifically the lack of clear documentation for a feature.",True,"The commit message 'Polish 'Document how to add metadata for collection and enum default values'' does contain an expression that describes the objective of the change. It mentions that the change is to document how to add metadata for collection and enum default values, which is an improvement to the codebase as it will make it easier for developers to understand and use these features.",True,"The commit message 'Polish ...' does indeed describe the changes made in the diff. It mentions the addition of manual metadata to document default values for properties in a class, which is a key component of the change. The diff also shows the specific changes made to the manual metadata, such as updating the property names and default values.",True,"The commit message and the code diff both explain that the annotation processor cannot automatically detect default values for Enums and Collections. This is a technical principle underpinning the changes, as the changes are made to provide manual metadata for these default values.",True,"The commit message 'Polish 'Document how to add metadata for collection and enum default values'' describes the changes made to the documentation, specifically how to add manual metadata for properties with non-empty default values for Collections and Enums. The code diff shows the addition of JSON content to the manual metadata of the module, which includes the 'name' of the property and its 'defaultValue'. This clearly explains the new behavior introduced, which is the ability to document default values for these types of properties.",True,"The commit message does not explicitly explain the reason for the change, but it can be inferred from the code diff. The change is to document the default values for the 'addresses' and 'container-type' properties in the 'MessagingProperties' class. The default values are 'a, b' and 'simple', respectively. The commit message only updates the documentation to reflect these default values, so there was no need for an explicit explanation of the change."
https://github.com/junit-team/junit4/commit/e15b287ccec2a1f4866a8bd1cd2a313a6163163d,"Only use a property where multiple entries need syncing  <enter> * The hamcrest version is only used in one place, i.e. the dependency. * Using properties to define dependency versions can cause issues for others. * Using properties to define a shared version across multiple dependencies causes less issues when you have multiple dependencies that need to be kept in sync. * We only have one dependency here and it doesn't need syncing to any other dependency * Therefore the right thing is to just specify the version in the dependency * End users can still override the dependency in their poms. ",https://api.github.com/repos/junit-team/junit4/commits/e15b287ccec2a1f4866a8bd1cd2a313a6163163d,"@@ -73,7 +73,6 @@
     </distributionManagement>
 
     <properties>
-        <hamcrestVersion>1.3</hamcrestVersion>
         <jdkVersion>1.5</jdkVersion>
         <project.build.sourceEncoding>ISO-8859-1</project.build.sourceEncoding>
     </properties>
@@ -82,7 +81,7 @@
         <dependency>
             <groupId>org.hamcrest</groupId>
             <artifactId>hamcrest-core</artifactId>
-            <version>${hamcrestVersion}</version>
+            <version>1.3</version>
         </dependency>
     </dependencies>
 
",True,"The commit message refers to a convention regarding the use of properties to define dependency versions. It explains that using properties can cause issues for others, especially when multiple dependencies need to be kept in sync. In this case, the hamcrest version is only used in one place and doesn't need to be synced with any other dependency, so it's appropriate to specify the version directly in the dependency. This change aligns with the convention of avoiding the use of properties for single-use dependencies.",True,"The commit message explains the necessity of changes by stating that using properties to define dependency versions can cause issues for others, especially when multiple dependencies need to be kept in sync. In this case, the hamcrest version is only used in one place, so it doesn't need to be defined as a property. The message also mentions that end users can still override the dependency in their poms, which further supports the decision to specify the version directly in the dependency.",True,"The commit message explains the motivation for the code change by mentioning that using properties to define dependency versions can cause issues for others, especially when multiple dependencies need to be kept in sync. In this case, the hamcrest version is only used in one place and doesn't need to be kept in sync with any other dependency, so it's more appropriate to specify the version directly in the dependency. This change is made to avoid potential issues that could arise from using properties to define dependency versions.",True,"The commit message indicates that the change was made to avoid potential issues that can arise when using properties to define dependency versions, especially when multiple dependencies need to be kept in sync. This suggests that the change was made to address a problem in the software maintenance process, specifically the potential for inconsistencies and issues that can arise when using properties to define shared versions across multiple dependencies.",True,The commit message directly mentions the issue of using properties to define dependency versions causing issues for others and the improvement of specifying the version directly in the dependency. It also explains that this change is made because there is only one dependency and it doesn't need syncing to any other dependency.,True,"The commit message accurately summarizes the changes made in the code diff. It explains that the hamcrest version was previously defined in the properties section and then directly used in the dependency section. However, since there's only one dependency and it doesn't need to be kept in sync with other dependencies, the hamcrest version was hardcoded directly into the dependency section, removing the need for the property definition. This is a clear and concise summary of the changes made in the code diff.",True,"The commit message explains the technical principle that using properties to define shared versions across multiple dependencies can cause less issues when those dependencies need to be kept in sync. In this case, since there's only one dependency and it doesn't need to be kept in sync with any other dependency, the right thing to do is to specify the version directly in the dependency, rather than using a property.",True,"The commit message expresses the change of removing the use of a property for the hamcrest version and specifying the version directly in the dependency. This change is made to avoid potential issues that can arise when using properties to define dependency versions, especially when multiple dependencies need to be kept in sync. In this case, since there is only one dependency and it doesn't need to be synced with any other dependency, the change is appropriate and it doesn't introduce any new behaviors. However, the message does describe the functional perspective of the change by explaining the potential issues with using properties and the reason for the specific change in this case.",False,"The commit message does not lack an explanation. It clearly states the reasons for the change: using properties to define dependency versions can cause issues, especially when multiple dependencies need to be kept in sync. In this case, there's only one dependency and it doesn't need to be kept in sync with any other dependency, so it's appropriate to specify the version directly in the dependency. This is a good practice to follow, as it makes the code more readable and less prone to errors."
https://github.com/junit-team/junit4/commit/fd2c4fbbf74f01eecef1680fa1365052d0302d19,Added some names to list of contributors ,https://api.github.com/repos/junit-team/junit4/commits/fd2c4fbbf74f01eecef1680fa1365052d0302d19,"@@ -110,6 +110,8 @@
 			<li><a href=""http://www.petrikainulainen.net/blog/"">Petri Kainulainen</a></li>
 			<li>Jean-Christophe Sirot</li>
       <li>Max Schwaab</li>
+      <li>Brian Clozel</li>
+      <li>Per-Ingemar Andersson</li>
 		</ul>
   </body>
 </html>
",False,"The commit message 'Added some names to list of contributors' does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features. It simply states what changes were made without providing a reason for the changes.",True,The commit message 'Added some names to list of contributors' clearly describes the changes made in the code diff. It is easy to infer that the changes are necessary to update the list of contributors. This is a common practice in open-source projects and does not require a detailed rationale.,False,"The commit message 'Added some names to list of contributors' does not directly elaborate the motivation of the code change. It does not mention any error scenario, issue report, or shortcoming of the previous implementation. Instead, it simply states what was done in the commit.",False,"The commit message 'Added some names to list of contributors' does not explicitly describe the necessity of changes. It does not mention any user requirements, problems in the software maintenance process, or changes in the development environment. The changes are simply adding names to the list of contributors, which is an administrative task and does not necessarily indicate a need for software development changes.",False,"The commit message 'Added some names to list of contributors' does not directly mention any defects it fixes or improvements it makes to the code. It only describes the action taken, which is adding names to a list. It does not provide any information about the purpose or outcome of the change.",True,"The commit message 'Added some names to list of contributors' accurately summarizes the changes made in the diff. It clearly states that new names were added to the list of contributors, which is exactly what the diff shows.",False,"The commit message 'Added some names to list of contributors' does not explicitly describe a technical principle underpinning the changes. It simply states what was done, not why it was done or what principle guided the decision to add these names to the list of contributors.",True,"The commit message 'Added some names to list of contributors' accurately summarizes the changes made in the code diff. It clearly explains that new names have been added to the list of contributors, which is a functional change that introduces new data to the application.",False,"The commit message does not lack an explanation because it clearly states the reason for the commit: 'Added some names to list of contributors'. Even though the change is small and simple, it is still important to include a clear and concise explanation in the commit message to make it easier for others to understand the purpose of the change."
https://github.com/square/retrofit/commit/eccfe208bcb7c54d357c60842aa6e33cc15424cd,"Switch to a better, custom validating subscriber.  <enter> TestSubscriber is a poor implementation for correctness testing. This new subscriber ensures all events are tested by being a JUnit rule. It also consumes events as they're validated so that assertion becomes more like a script than a ledger. <enter> This also switches tests to use unsafeSubscribe to ensure that any contract violations are not being suppressed. The latest version of RxJava is required for accessing this method on Completable. ",https://api.github.com/repos/square/retrofit/commits/eccfe208bcb7c54d357c60842aa6e33cc15424cd,"@@ -53,7 +53,7 @@
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.1.5</rxjava.version>
+    <rxjava.version>1.1.9</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.7</gson.version>
@@ -24,13 +24,13 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
-import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class CompletableTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Completable completable();
@@ -49,25 +49,24 @@ interface Service {
   @Test public void completableSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
     subscriber.assertCompleted();
   }
 
   @Test public void completableSuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
-    Throwable cause = subscriber.getOnErrorEvents().get(0);
-    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, ""HTTP 404 Client Error"");
   }
 
   @Test public void completableFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 }
@@ -23,11 +23,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
 public final class CompletableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Completable completable();
@@ -47,9 +47,9 @@ interface Service {
   @Test public void completableUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
     subscriber.assertCompleted();
@@ -25,13 +25,13 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ObservableTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Observable<String> body();
@@ -53,42 +53,37 @@ interface Service {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertValues(""Hi"");
-    subscriber.assertCompleted();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue(""Hi"").assertCompleted();
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    Throwable cause = subscriber.getOnErrorEvents().get(0);
-    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, ""HTTP 404 Client Error"");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 
   @Test public void bodyRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>(0);
-    Observable<String> o = service.body();
-
-    o.subscribe(subscriber);
+    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.body().unsafeSubscribe(subscriber);
     assertThat(server.getRequestCount()).isEqualTo(0);
 
     subscriber.requestMore(1);
     assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
@@ -97,45 +92,39 @@ interface Service {
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    Response<String> response = subscriber.getOnNextEvents().get(0);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo(""Hi"");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo(""Hi"");
     subscriber.assertCompleted();
   }
 
   @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+    server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    Response<String> response = subscriber.getOnNextEvents().get(0);
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
     subscriber.assertCompleted();
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 
   @Test public void responseRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>(0);
-    Observable<Response<String>> o = service.response();
-
-    o.subscribe(subscriber);
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.response().unsafeSubscribe(subscriber);
     assertThat(server.getRequestCount()).isEqualTo(0);
 
     subscriber.requestMore(1);
     assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
@@ -144,51 +133,40 @@ interface Service {
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo(""Hi"");
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo(""Hi"");
     subscriber.assertCompleted();
   }
 
   @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
-
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
     subscriber.assertCompleted();
   }
 
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
     subscriber.assertCompleted();
   }
 
   @Test public void resultRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>(0);
-    Observable<Result<String>> o = service.result();
-
-    o.subscribe(subscriber);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.result().unsafeSubscribe(subscriber);
     assertThat(server.getRequestCount()).isEqualTo(0);
 
     subscriber.requestMore(1);
     assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
@@ -24,11 +24,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
 public final class ObservableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Observable<String> body();
@@ -51,39 +51,33 @@ interface Service {
   @Test public void bodyUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void responseUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void resultUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 }
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import rx.Notification;
+import rx.Subscriber;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSubscriber<T> extends Subscriber<T> {
+  private final long initialRequest;
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingSubscriber(long initialRequest) {
+    this.initialRequest = initialRequest;
+  }
+
+  @Override public void onStart() {
+    request(initialRequest);
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onCompleted() {
+    events.add(Notification.<T>createOnCompleted());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError(""No event found!"");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .overridingErrorMessage(""Expected onNext event but was %s"", notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .overridingErrorMessage(""Expected onError event but was %s"", notification)
+        .isTrue();
+    return notification.getThrowable();
+  }
+
+  public RecordingSubscriber<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSubscriber<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertCompleted() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnCompleted())
+        .overridingErrorMessage(""Expected onCompleted event but was %s"", notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as(""Unconsumed events found!"").isEmpty();
+  }
+
+  public void requestMore(long amount) {
+    request(amount);
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSubscriber<T> create() {
+      return createWithInitialRequest(Long.MAX_VALUE);
+    }
+
+    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSubscriber<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
@@ -25,13 +25,13 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SingleTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Single<String> body();
@@ -53,87 +53,77 @@ interface Service {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertValue(""Hi"");
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue(""Hi"").assertCompleted();
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    Throwable cause = subscriber.getOnErrorEvents().get(0);
-    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, ""HTTP 404 Client Error"");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    Response<String> response = subscriber.getOnNextEvents().get(0);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo(""Hi"");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+    server.enqueue(new MockResponse().setResponseCode(404));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    Response<String> response = subscriber.getOnNextEvents().get(0);
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
+    subscriber.assertCompleted();
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
 
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo(""Hi"");
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
-
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+    subscriber.assertCompleted();
   }
 
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.getOnNextEvents().get(0);
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
   }
 }
@@ -24,11 +24,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
 public final class SingleWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET(""/"") Single<String> body();
@@ -51,36 +51,33 @@ interface Service {
   @Test public void bodyUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void responseUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void resultUsesScheduler() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 }
",True,"The commit message explains the necessity of changes by referencing the limitations of the previous implementation (TestSubscriber) and the improvements provided by the new implementation (RecordingSubscriber). It mentions that the new subscriber ensures all events are tested, consumes events as they're validated, and is a JUnit rule. This makes the assertion process more like a script than a ledger. Additionally, the message mentions that the latest version of RxJava is required for accessing the unsafeSubscribe method on Completable, which ensures that any contract violations are not being suppressed.",True,"The commit message explains the reason for the change by stating that the new subscriber is a better implementation for correctness testing. It also mentions that it ensures all events are tested by being a JUnit rule and consumes events as they're validated, making assertion more like a script than a ledger. This is a clear explanation of the necessity of the changes, as it highlights the improvements in functionality and correctness testing.",True,"The commit message explains the motivation for the change by mentioning that the previous implementation, TestSubscriber, is a poor implementation for correctness testing. The new subscriber, RecordingSubscriber, is introduced to ensure all events are tested by being a JUnit rule. This change is also made to switch tests to use unsafeSubscribe to ensure that any contract violations are not being suppressed. The message also mentions that the latest version of RxJava is required for accessing this method on Completable.",True,"The commit message mentions that the developer is switching to a better, custom validating subscriber because TestSubscriber is a poor implementation for correctness testing. This indicates that the change is being made to improve the quality of the codebase, which could be due to a requirement for more accurate testing or a problem with the existing testing implementation.",True,"The commit message directly mentions the improvements made to the code by switching to a better, custom validating subscriber. This change is made to ensure all events are tested by being a JUnit rule, which makes assertion more like a script than a ledger. Additionally, the message mentions that the change switches tests to use unsafeSubscribe to ensure that any contract violations are not being suppressed.",True,"The commit message describes the change by summarizing the key components of the change. It mentions switching to a better, custom validating subscriber, replacing TestSubscriber with RecordingSubscriber. It also mentions switching tests to use unsafeSubscribe to ensure that any contract violations are not being suppressed. The message also mentions the version upgrade of RxJava required for accessing this method on Completable.",True,"The commit message explains that the change is about switching to a better, custom validating subscriber for correctness testing. This new subscriber ensures all events are tested by being a JUnit rule. It also consumes events as they're validated, which makes assertion more like a script than a ledger. This change is based on the principle of using a more appropriate and effective tool for testing, which is a technical principle underpinning the changes.",True,"The commit message expresses a change in the testing strategy, stating that a better, custom validating subscriber is being used instead of TestSubscriber. It explains that this new subscriber ensures all events are tested by being a JUnit rule, and it also consumes events as they're validated, making assertions more like a script than a ledger. Additionally, it mentions that the unsafeSubscribe method is used to ensure any contract violations are not being suppressed, which is a new behavior introduced by the change.",False,"The commit message does not lack an explanation. It clearly states the reasons for the commit, such as improving correctness testing, consuming events as they're validated, and ensuring that any contract violations are not being suppressed. Additionally, the commit message mentions the use of a new subscriber and the upgrade of RxJava version, which are both relevant to the changes made in the code."
https://github.com/square/retrofit/commit/46cdff20b53a84e816d6022541347b3c06a5a52b,"Fatal errors should crash the dispatcher thread  <enter> This is an imperfect fix as uncaught exceptions reaching OkHttpCall which are not fatal still only log, but most of the adapters are defending against anything getting this far already. <enter> Also contained is a fix for the RxJava 2 async adapter. Non-200 responses delivered to the body observer would be forwarded to onError. If that callback threw a fatal exception, it would be re-delivered to the body observer despite it having already called a downstream terminal method. The fatal error should have been propagated by the async observer instead of attempting to make its way back downstream. ",https://api.github.com/repos/square/retrofit/commits/46cdff20b53a84e816d6022541347b3c06a5a52b,"@@ -64,6 +64,7 @@ private static final class CallCallback<T> implements Disposable, Callback<T> {
           observer.onComplete();
         }
       } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
         if (terminated) {
           RxJavaPlugins.onError(t);
         } else if (!disposed) {
@@ -22,10 +22,18 @@
 import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.Dispatcher;
+import okhttp3.OkHttpClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -36,7 +44,10 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 public final class AsyncTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -46,14 +57,36 @@ interface Service {
   }
 
   private Service service;
+  private List<Throwable> uncaughtExceptions = new ArrayList<>();
+
   @Before public void setUp() {
+    ExecutorService executorService = Executors.newCachedThreadPool(new ThreadFactory() {
+      @Override public Thread newThread(Runnable r) {
+        Thread thread = new Thread(r);
+        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+          @Override public void uncaughtException(Thread t, Throwable e) {
+            uncaughtExceptions.add(e);
+          }
+        });
+        return thread;
+      }
+    });
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .dispatcher(new Dispatcher(executorService))
+        .build();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url(""/""))
+        .client(client)
         .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
         .build();
     service = retrofit.create(Service.class);
   }
 
+  @After public void tearDown() {
+    assertTrue(""Uncaught exceptions: "" + uncaughtExceptions, uncaughtExceptions.isEmpty());
+  }
+
   @Test public void success() throws InterruptedException {
     TestObserver<Void> observer = new TestObserver<>();
     service.completable().subscribe(observer);
@@ -130,4 +163,23 @@ interface Service {
     CompositeException composite = (CompositeException) pluginRef.get();
     assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
   }
+
+  @Test public void bodyThrowingFatalInOnErrorPropagates() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final Error e = new OutOfMemoryError(""Not real"");
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+
+    assertEquals(1, uncaughtExceptions.size());
+    assertSame(e, uncaughtExceptions.remove(0));
+  }
 }
@@ -128,7 +128,8 @@ final class OkHttpCall<T> implements Call<T> {
         try {
           callback.onResponse(OkHttpCall.this, response);
         } catch (Throwable t) {
-          t.printStackTrace();
+          throwIfFatal(t);
+          t.printStackTrace(); // TODO this is not great
         }
       }
 
@@ -140,7 +141,8 @@ private void callFailure(Throwable e) {
         try {
           callback.onFailure(OkHttpCall.this, e);
         } catch (Throwable t) {
-          t.printStackTrace();
+          throwIfFatal(t);
+          t.printStackTrace(); // TODO this is not great
         }
       }
     });
",True,"The commit message refers to the necessity of changes by mentioning 'fatal errors' and 'uncaught exceptions'. It explains that these errors should crash the dispatcher thread, which is an improvement over the previous behavior of just logging the errors. The message also mentions a fix for the RxJava 2 async adapter, which is a specific feature of the codebase, and explains that non-200 responses were being delivered to the body observer despite a downstream terminal method having been called, which is a problem that the fix addresses.",True,"The commit message explains the necessity of changes by stating that 'Fatal errors should crash the dispatcher thread' and 'Non-200 responses delivered to the body observer would be forwarded to the onError. If that callback threw a fatal exception, it would be re-delivered to the body observer despite it having already called a downstream terminal method. The fatal error should have been propagated by the async observer instead of attempting to make its way back downstream.' This explains why the changes were made to the code, specifically to handle fatal errors and ensure they are properly propagated.",True,"The commit message explains the motivation for the changes by mentioning the issue of uncaught exceptions reaching OkHttpCall which are not fatal only logging, and the need for the dispatcher thread to crash in such cases. It also mentions a fix for the RxJava 2 async adapter where non-200 responses delivered to the body observer would be forwarded to onError, and if that callback threw a fatal exception, it would be re-delivered to the body observer despite it having already called a downstream terminal method. The commit message explains that the fatal error should have been propagated by the async observer instead of attempting to make its way back downstream.",True,"The commit message indicates that the changes were made to fix fatal errors that could crash the dispatcher thread. This suggests that the source of the requirements was a problem in the process of software maintenance, specifically the need to handle fatal errors properly to prevent crashes.",True,The commit message directly mentions the defects it fixes. It states that the change is an imperfect fix for fatal errors not crashing the dispatcher thread and also fixes a bug in the RxJava 2 async adapter where non-200 responses could cause fatal errors to be re-delivered to the body observer instead of being propagated by the async observer.,True,"The commit message does a good job of summarizing the changes. It mentions the fix for fatal errors causing the dispatcher thread to crash, the fix for the RxJava 2 async adapter where non-200 responses could lead to fatal errors being re-delivered to the body observer, and the addition of a test to ensure that body throwing fatal errors in onError are properly propagated.",True,"The commit message explains that the changes are made to ensure that fatal errors should crash the dispatcher thread. This is achieved by adding a check to throw an exception if it is fatal. This is a principle of fail-fast, which is a design philosophy that emphasizes the importance of detecting and handling errors as early as possible in the software development process.",True,"The commit message accurately describes the changes made to the code. It mentions that the commit contains a fix for fatal errors that should crash the dispatcher thread. This is reflected in the code diff where a new line is added to check if a throwable is fatal and throw it if it is. Additionally, the commit message mentions a fix for the RxJava 2 async adapter where non-200 responses delivered to the body observer would be forwarded to onError. If that callback threw a fatal exception, it would be re-delivered to the body observer despite it having already called a downstream terminal method. The commit message explains that the fatal error should have been propagated by the async observer instead of attempting to make its way back downstream, which is also reflected in the code diff.",False,"The commit message explains the reason for the change in detail. It mentions that fatal errors should crash the dispatcher thread, which is not the current behavior. It also explains the fix for the RxJava 2 async adapter, which was causing non-fatal exceptions to be delivered to the body observer instead of being propagated. The change is not small or simple, as it involves modifying multiple files and adding new functionality to handle uncaught exceptions."
https://github.com/spring-projects/spring-boot/commit/3b07e4e633ebcbdb0836ed7ad0b21fc8f0b42a9e,Fix typos in the documentation: though -> through  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/3b07e4e633ebcbdb0836ed7ad0b21fc8f0b42a9e,"@@ -265,7 +265,7 @@ to override version numbers if necessary.
 === Default exclude rules
 Gradle handles ``exclude rules'' in a slightly different way to Maven which can cause
 unexpected results when using the starter POMs. Specifically, exclusions declared on
-a dependency will not be applied when the dependency can be reached though a different
+a dependency will not be applied when the dependency can be reached through a different
 path. For example, if a starter POM declares the following:
 
 [source,xml,indent=0,subs=""verbatim,attributes""]
@@ -549,7 +549,7 @@ file named `src/main/java/Example.java`:
 	}
 ----
 
-Although there isn't much code here, quite a lot is going on. Let's step though the
+Although there isn't much code here, quite a lot is going on. Let's step through the
 important parts.
 
 
@@ -1504,7 +1504,7 @@ would only ever be a development time trick probably).
 
 [[howto-reload-springloaded-gradle-and-intellij]]
 ==== Configuring Spring Loaded for use with Gradle and IntelliJ
-You need to jump though a few hoops if you want to use Spring Loaded in combination with
+You need to jump through a few hoops if you want to use Spring Loaded in combination with
 Gradle and IntelliJ. By default, IntelliJ will compile classes into a different location
 than Gradle, causing Spring Loaded monitoring to fail.
 
",True,"The commit message refers to a common convention in documentation, specifically the correct usage of the word 'through' instead of 'though'. This is an improvement over the prior commit, which had a typo. The message also closes a pull request, which suggests that the changes were reviewed and approved by others, further indicating the necessity of the changes.",True,"The commit message 'Fix typos in the documentation' clearly describes the necessity of the changes, which are typographic fixes. The changes are not obvious from the code diff, so the commit message provides a clear explanation of the changes made.",True,"The commit message does not explicitly describe the necessity of changes by elaborating the motivation of a code change. However, it does mention the correction of typos in the documentation, which could potentially lead to misunderstandings or confusion. Additionally, the diff shows that the word 'though' has been corrected to 'through', which could indicate a typo that could have caused confusion or errors in understanding the documentation.",True,"The commit message 'Fix typos in the documentation' does not explicitly describe the necessity of changes. However, the code diff indicates that the changes were made to the documentation, which could imply that there were outdated or incorrect information that needed to be corrected. This suggests that the changes were made to address a problem in the process of software maintenance, specifically the need to update out-of-date documentation.",False,The commit message only mentions fixing typos in the documentation and closing a pull request. It does not directly mention any defects it fixes or improvements it makes to the code.,True,"The commit message 'Fix typos in the documentation: though -> through' accurately describes the change made in the diff, which is the correction of a typographical error. The message specifically points out the error and the correction, making it a clear and concise summary of the changes.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions fixing typos in the documentation, not any underlying technical concepts or principles.",True,"The commit message describes the changes made to the documentation, specifically fixing typos. The code diff shows that the word 'though' has been corrected to 'through' in two places. This change does not introduce new behaviors or functionalities, but it improves the clarity and accuracy of the documentation. Therefore, the message does not fully express a summary of the code changes from a functional perspective, as it does not describe any new behaviors introduced.",False,"The commit message does not explicitly state the reason for the change, but it does provide context by mentioning the documentation fix and the associated pull request. While the change is small and simple, it's not immediately clear from the diff that the change is a typo correction. Therefore, the commit message does not lack an explanation."
https://github.com/square/okhttp/commit/e3e829d2060542d50f33d1a9864f7ace82c9db5c,"API change: Make OkHttpClient accessors final  <enter> If we want these to be vals to Kotlin, they can't be open. I think the motivation to make these non-final was pretty weak, and I don't mind breaking API compatibility here. ",https://api.github.com/repos/square/okhttp/commits/e3e829d2060542d50f33d1a9864f7ace82c9db5c,"@@ -354,6 +354,33 @@ task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
       'okhttp3.Route#requiresTunnel()',
       'okhttp3.Route#socketAddress()',
       'okhttp3.TlsVersion#javaName()',
+      // Real API change! Became 'final' despite a non-final enclosing class in 4.0.0:
+      'okhttp3.OkHttpClient#authenticator()',
+      'okhttp3.OkHttpClient#cache()',
+      'okhttp3.OkHttpClient#callTimeoutMillis()',
+      'okhttp3.OkHttpClient#certificatePinner()',
+      'okhttp3.OkHttpClient#connectionPool()',
+      'okhttp3.OkHttpClient#connectionSpecs()',
+      'okhttp3.OkHttpClient#connectTimeoutMillis()',
+      'okhttp3.OkHttpClient#cookieJar()',
+      'okhttp3.OkHttpClient#dispatcher()',
+      'okhttp3.OkHttpClient#dns()',
+      'okhttp3.OkHttpClient#eventListenerFactory()',
+      'okhttp3.OkHttpClient#followRedirects()',
+      'okhttp3.OkHttpClient#followSslRedirects()',
+      'okhttp3.OkHttpClient#hostnameVerifier()',
+      'okhttp3.OkHttpClient#interceptors()',
+      'okhttp3.OkHttpClient#networkInterceptors()',
+      'okhttp3.OkHttpClient#pingIntervalMillis()',
+      'okhttp3.OkHttpClient#protocols()',
+      'okhttp3.OkHttpClient#proxy()',
+      'okhttp3.OkHttpClient#proxyAuthenticator()',
+      'okhttp3.OkHttpClient#proxySelector()',
+      'okhttp3.OkHttpClient#readTimeoutMillis()',
+      'okhttp3.OkHttpClient#retryOnConnectionFailure()',
+      'okhttp3.OkHttpClient#socketFactory()',
+      'okhttp3.OkHttpClient#sslSocketFactory()',
+      'okhttp3.OkHttpClient#writeTimeoutMillis()',
   ]
 }
 check.dependsOn(japicmp)
@@ -184,75 +184,75 @@ open class OkHttpClient internal constructor(
     }
   }
 
-  open fun dispatcher(): Dispatcher = dispatcher
+  fun dispatcher(): Dispatcher = dispatcher
 
-  open fun proxy(): Proxy? = proxy
+  fun proxy(): Proxy? = proxy
 
-  open fun protocols(): List<Protocol> = protocols
+  fun protocols(): List<Protocol> = protocols
 
-  open fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
+  fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
 
   /**
    * Returns an immutable list of interceptors that observe the full span of each call: from before
    * the connection is established (if any) until after the response source is selected (either the
    * origin server, cache, or both).
    */
-  open fun interceptors(): List<Interceptor> = interceptors
+  fun interceptors(): List<Interceptor> = interceptors
 
   /**
    * Returns an immutable list of interceptors that observe a single network request and response.
    * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for
    * a network interceptor to short-circuit or repeat a network request.
    */
-  open fun networkInterceptors(): List<Interceptor> = networkInterceptors
+  fun networkInterceptors(): List<Interceptor> = networkInterceptors
 
-  open fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
+  fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
 
-  open fun proxySelector(): ProxySelector = proxySelector
+  fun proxySelector(): ProxySelector = proxySelector
 
-  open fun cookieJar(): CookieJar = cookieJar
+  fun cookieJar(): CookieJar = cookieJar
 
-  open fun cache(): Cache? = cache
+  fun cache(): Cache? = cache
 
-  open fun socketFactory(): SocketFactory = socketFactory
+  fun socketFactory(): SocketFactory = socketFactory
 
-  open fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory!!
+  fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory!!
 
-  open fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
+  fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
 
-  open fun certificatePinner(): CertificatePinner = certificatePinner
+  fun certificatePinner(): CertificatePinner = certificatePinner
 
-  open fun proxyAuthenticator(): Authenticator = proxyAuthenticator
+  fun proxyAuthenticator(): Authenticator = proxyAuthenticator
 
-  open fun authenticator(): Authenticator = authenticator
+  fun authenticator(): Authenticator = authenticator
 
-  open fun connectionPool(): ConnectionPool = connectionPool
+  fun connectionPool(): ConnectionPool = connectionPool
 
-  open fun dns(): Dns = dns
+  fun dns(): Dns = dns
 
-  open fun followSslRedirects(): Boolean = followSslRedirects
+  fun followSslRedirects(): Boolean = followSslRedirects
 
-  open fun followRedirects(): Boolean = followRedirects
+  fun followRedirects(): Boolean = followRedirects
 
-  open fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
+  fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
 
   /**
    * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
    * there is for the connect, write, and read actions within a call.
    */
-  open fun callTimeoutMillis(): Int = callTimeout
+  fun callTimeoutMillis(): Int = callTimeout
 
   /** Default connect timeout (in milliseconds). The default is 10 seconds.  */
-  open fun connectTimeoutMillis(): Int = connectTimeout
+  fun connectTimeoutMillis(): Int = connectTimeout
 
   /** Default read timeout (in milliseconds). The default is 10 seconds. */
-  open fun readTimeoutMillis(): Int = readTimeout
+  fun readTimeoutMillis(): Int = readTimeout
 
   /** Default write timeout (in milliseconds). The default is 10 seconds. */
-  open fun writeTimeoutMillis(): Int = writeTimeout
+  fun writeTimeoutMillis(): Int = writeTimeout
 
   /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
-  open fun pingIntervalMillis(): Int = pingInterval
+  fun pingIntervalMillis(): Int = pingInterval
 
   internal fun internalCache(): InternalCache? {
     return cache?.internalCache ?: internalCache
",True,"The commit message explains the necessity of changes by referencing a convention or standard. The message mentions that the methods are being made final because they need to be vals in Kotlin, and they can't be open. This is a common convention in Kotlin to make properties final by default for immutability and interoperability with other languages.",True,"The commit message explains the necessity of changes by stating that the accessors need to be made final because they are being converted to vals in Kotlin, and open accessors are not compatible with vals. This is not a common sense or easy to infer change, as it is specific to the language conversion and the compatibility requirements of Kotlin.",True,"The commit message explains the motivation for the changes by mentioning that the methods were made non-final despite having a non-final enclosing class in the previous version. This could potentially break API compatibility for Kotlin users who expect these methods to be vals. The message also mentions that the motivation for making these methods non-final was weak, which further justifies the decision to break API compatibility.",True,"The commit message 'API change: Make OkHttpClient accessors final' indicates that the developer made changes to the OkHttpClient API due to a requirement. The explanation in the message, 'I think the motivation to make these non-final was pretty weak, and I don't mind breaking API compatibility here', suggests that the change was made to improve the API design, which could be a requirement from users or a problem in the maintenance process of the software.",True,"The commit message directly mentions the objective of the change by stating 'API change: Make OkHttpClient accessors final'. This change is made to allow these accessors to be vals in Kotlin, which requires them to be final. The message also explains the reason for making these changes, mentioning that the motivation to make these non-final was weak and that the decision was made to break API compatibility here.",True,"The commit message 'API change: Make OkHttpClient accessors final' accurately summarizes the changes made in the diff. It specifically mentions the change of OkHttpClient accessors from open to final, which is a significant modification to the API. The message also explains the reason for the change, stating that it was made to accommodate Kotlin's use of vals, which cannot be open. The message does not only list the changes but also provides a context and explanation for the change, making it a clear and descriptive summary of the diffs.",True,"The commit message explains that the changes made to the OkHttpClient accessors are to make them final, which is a technical principle that ensures the state of an object cannot be changed after it is created. This can improve performance and thread safety.",True,"The commit message 'API change: Make OkHttpClient accessors final' accurately summarizes the changes made in the code diff. It explains that the accessor methods in the OkHttpClient class have been changed from open (which allows overriding) to final, which means they cannot be overridden in subclasses. This is a significant change that could break API compatibility, but the commit message justifies this decision by stating that the motivation for making these methods non-final was weak and that breaking API compatibility here is acceptable.",False,"The commit message does not lack an explanation. It explicitly mentions the reason for the change: 'I think the motivation to make these non-final was pretty weak, and I don't mind breaking API compatibility here.' This is a valid reason for making these changes, and it is not easily inferred from the code diff alone."
https://github.com/square/retrofit/commit/d80636923c595ed665adc6066f1377a6a1304f6a,Move source/target config out of error-prone block  <enter> Error-prone only works on pre-12 at the moment and we need this configuration to apply for all JDKs. ,https://api.github.com/repos/square/retrofit/commits/d80636923c595ed665adc6066f1377a6a1304f6a,"@@ -59,6 +59,12 @@ subprojects {
     jcenter()
   }
 
+  tasks.withType(JavaCompile).configureEach { task ->
+    task.options.encoding = 'UTF-8'
+    task.sourceCompatibility = JavaVersion.VERSION_1_8
+    task.targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
   // Error-prone only works on JDK 11 or older currently.
   if (!Jvm.current().javaVersion.isJava12Compatible()) {
     apply plugin: 'net.ltgt.errorprone'
@@ -69,10 +75,6 @@ subprojects {
     }
 
     tasks.withType(JavaCompile).configureEach { task ->
-      task.options.encoding = 'UTF-8'
-      task.sourceCompatibility = JavaVersion.VERSION_1_8
-      task.targetCompatibility = JavaVersion.VERSION_1_8
-
       task.options.errorprone {
         excludedPaths = '.*/build/generated/source/proto/.*'
         check('MissingFail', CheckSeverity.ERROR)
",True,"The commit message refers to a limitation of Error-prone, which only works on pre-12 JDKs at the moment. The changes made in the commit are necessary to apply the source/target configuration for all JDKs, addressing the limitation mentioned in the commit message.",True,The commit message explains the necessity of changes by stating that 'Error-prone only works on pre-12 at the moment' and 'we need this configuration to apply for all JDKs'. This is a clear explanation of why the source/target configuration is being moved out of the error-prone block. The code diff also supports this explanation by showing the removal of the source/target configuration from the error-prone block and its addition outside of it.,True,The commit message directly elaborates the motivation of the code change by mentioning that 'Error-prone only works on pre-12 at the moment' and that 'we need this configuration to apply for all JDKs'. This clearly indicates that the changes are necessary to address a shortcoming in the previous implementation.,True,"The commit message 'Move source/target config out of error-prone block' indicates that the changes were made to accommodate the need for the configuration to apply for all JDKs. This is because the message states that 'Error-prone only works on pre-12 at the moment' and the changes were made to ensure the configuration works for all JDKs. This suggests that the changes were made to address a problem in the software maintenance process, specifically the limitation of a tool used in the process.",True,"The commit message 'Move source/target config out of error-prone block' directly mentions the change that it is making to the code. The message explains that the configuration for source and target compatibility is being moved out of the error-prone block to apply for all JDKs, which implies that the change is being made to address the issue that error-prone only works on pre-12 JDKs at the moment. This shows that the commit message is effectively describing the objective of the change and the improvement it makes to the code.",True,"The commit message 'Move source/target config out of error-prone block' accurately summarizes the key change in the diff, which is the relocation of the source and target compatibility configuration outside the error-prone block. This allows the configuration to apply to all JDKs, as stated in the message.",False,"The commit message does not explicitly state or describe a technical principle underpinning the changes. It mainly focuses on the reason for moving the source/target configuration out of the error-prone block, which is to make it applicable to all JDKs, not a specific technical principle.",True,"The commit message 'Move source/target config out of error-prone block' does describe a summary of the changes by explaining the code changes from a functional perspective. The message explains that the source and target compatibility configurations were moved out of the error-prone block to apply for all JDKs, not just pre-12. This change introduces new behaviors as it ensures that the configurations are applied regardless of the JDK version, which was not the case before.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Move source/target config out of error-prone block' and 'Error-prone only works on pre-12 at the moment and we need this configuration to apply for all JDKs.' This is necessary because the change is not just a simple fix, but a modification to accommodate a limitation in the 'error-prone' plugin."
https://github.com/junit-team/junit4/commit/6ee76dc22e56457cb5904eb6c5c0bf97939880cb,Update build_tests.sh to test 'ant profile' ,https://api.github.com/repos/junit-team/junit4/commits/6ee76dc22e56457cb5904eb6c5c0bf97939880cb,"@@ -11,3 +11,4 @@ MaxCore.max
 build
 out
 
+java.hprof.txt
@@ -14,6 +14,12 @@ function TEST_ant_dist {
   ls junit${version}/junit-${version}.jar
 }
 
+function TEST_ant_profile {
+  rm -rf java.hprof.txt
+  ant profile
+  ls java.hprof.txt
+}
+
 function get_junit_version {
   ant print.version | grep echo | sed 's/.*echo..\([1-9].*\)/\1/'
 }
@@ -0,0 +1,4 @@
+Can't open /Users/saff/git-repos/cry-overconfident-headline/junit/doc/ReleaseNotes4.9-RC1.txt: No such file or directory at buil
+d/Markdown.pl line 218.
+Use of uninitialized value $text in substitution (s///) at build/Markdown.pl line 245.
+Use of uninitialized value $text in substitution (s///) at build/Markdown.pl line 246.
@@ -9,7 +9,7 @@ private Version() {
 	}
 
 	public static String id() {
-		return ""4.9-SNAPSHOT-20100512-0041"";
+		return ""4.9-RC1"";
 	}
 	
 	public static void main(String[] args) {
",True,"The commit message 'Update build_tests.sh to test 'ant profile'' refers to the addition of a new test function 'TEST_ant_profile' in the code diff. This implies that the change is necessary to improve the testing capabilities of the project, specifically to test the 'ant profile' functionality.",True,"The commit message 'Update build_tests.sh to test 'ant profile'' clearly states the purpose of the changes, which is to add a new test case for the 'ant profile' command. This is a common practice in software development and the necessity of adding this test case is easily inferred from the changes made in the code diff.",True,"The commit message 'Update build_tests.sh to test 'ant profile'' does contain an expression that describes the necessity of changes. The code diff shows that a new function 'TEST_ant_profile' has been added to the script, which is likely to be a response to the error scenario mentioned in the diff. The error scenario is that the 'ant profile' command was not being tested previously, but now it is, which suggests that there was a problem with the previous implementation that this change aims to address.",True,The commit message 'Update build_tests.sh to test 'ant profile'' indicates that the changes were made to accommodate a new requirement. The addition of the 'TEST_ant_profile' function and the related changes in the diff suggest that this new function was added to test the 'ant profile' command. This implies that there was a new requirement or change in the software development process that necessitated these modifications.,True,"The commit message 'Update build_tests.sh to test 'ant profile'' directly mentions the improvement it makes to the code, which is adding a new test for the 'ant profile' command. This indicates that the change is likely related to fixing a defect or issue, as the addition of a new test suggests that there was previously a problem with the 'ant profile' command that is now being addressed.",True,"The commit message 'Update build_tests.sh to test 'ant profile'' accurately summarizes the changes made in the diff. It specifically mentions the addition of a new function 'TEST_ant_profile' and the modification of the 'Version' class in the 'junit/src/main/java/org/apache/tools/ant/util/Version.java' file. This shows that the commit message is a summary of the diffs, pointing out the key components of the change.",True,"The commit message 'Update build_tests.sh to test 'ant profile'' describes the technical principle underpinning the changes, which is the addition of a new test for the 'ant profile' command. This suggests that the changes are intended to improve the testing coverage of the build process, ensuring that the 'ant profile' command is functioning as expected.",True,"The commit message 'Update build_tests.sh to test 'ant profile'' accurately describes the changes made to the code. The code diff shows that a new function 'TEST_ant_profile' has been added to the script, which removes any existing 'java.hprof.txt' file, runs 'ant profile' to generate a new one, and then checks if the file has been created. This new function introduces a new behavior to the script, which is the ability to test the 'ant profile' command and generate a Java heap dump file.",False,"The commit message does not explicitly state the reason for the change. While it's clear that a new test function was added for 'ant profile', the commit message does not explain why this change was necessary. It could be due to a new feature, a bug fix, or other reasons. Therefore, a more detailed explanation would have been beneficial."
https://github.com/square/okhttp/commit/855c114f4f6fce3e0e1ae71479f89c9d5ad066d6,"Read/write access for byte, short and int.  <enter> This is big-endian only because that's all we use in OkHttp. ",https://api.github.com/repos/square/okhttp/commits/855c114f4f6fce3e0e1ae71479f89c9d5ad066d6,"@@ -51,6 +51,91 @@ public long byteCount() {
     return byteCount;
   }
 
+  /** Reads a byte from the front of this buffer and returns it. */
+  public byte readByte() {
+    if (byteCount < 1) throw new IllegalArgumentException(""byteCount < 1: "" + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    byte[] data = segment.data;
+    byte b = data[pos++];
+    byteCount -= 1;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return b;
+  }
+
+  /** Reads a Big-Endian short from the front of this buffer and returns it. */
+  public short readShort() {
+    if (byteCount < 2) throw new IllegalArgumentException(""byteCount < 2: "" + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the short is split across multiple segments, delegate to readByte().
+    if (limit - pos < 2) {
+      int s = (readByte() & 0xff) << 8
+          |   (readByte() & 0xff);
+      return (short) s;
+    }
+
+    byte[] data = segment.data;
+    int s = (data[pos++] & 0xff) << 8
+        |   (data[pos++] & 0xff);
+    byteCount -= 2;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return (short) s;
+  }
+
+  /** Reads a Big-Endian int from the front of this buffer and returns it. */
+  public int readInt() {
+    if (byteCount < 4) throw new IllegalArgumentException(""byteCount < 4: "" + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the int is split across multiple segments, delegate to readByte().
+    if (limit - pos < 4) {
+      return (readByte() & 0xff) << 24
+          |  (readByte() & 0xff) << 16
+          |  (readByte() & 0xff) << 8
+          |  (readByte() & 0xff);
+    }
+
+    byte[] data = segment.data;
+    int i = (data[pos++] & 0xff) << 24
+        |   (data[pos++] & 0xff) << 16
+        |   (data[pos++] & 0xff) << 8
+        |   (data[pos++] & 0xff);
+    byteCount -= 4;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return i;
+  }
+
   /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
   public ByteString readByteString(int byteCount) {
     return new ByteString(readBytes(byteCount));
@@ -87,20 +172,21 @@ private byte[] readBytes(int byteCount) {
 
   /** Appends {@code byteString} to this. */
   public void write(ByteString byteString) {
-    write(byteString.data);
+    write(byteString.data, 0, byteString.data.length);
   }
 
   /** Encodes {@code string} as UTF-8 and appends the bytes to this. */
   public void writeUtf8(String string) {
-    write(string.getBytes(Util.UTF_8));
+    byte[] data = string.getBytes(Util.UTF_8);
+    write(data, 0, data.length);
   }
 
-  private void write(byte[] data) {
-    int offset = 0;
-    while (offset < data.length) {
-      Segment tail = writableSegment();
+  void write(byte[] data, int offset, int byteCount) {
+    int limit = offset + byteCount;
+    while (offset < limit) {
+      Segment tail = writableSegment(1);
 
-      int toCopy = Math.min(data.length - offset, Segment.SIZE - tail.limit);
+      int toCopy = Math.min(limit - offset, Segment.SIZE - tail.limit);
       System.arraycopy(data, offset, tail.data, tail.limit, toCopy);
 
       offset += toCopy;
@@ -110,15 +196,54 @@ private void write(byte[] data) {
     this.byteCount += data.length;
   }
 
-  /** Returns a tail segment that we can write bytes to, creating it if necessary. */
-  Segment writableSegment() {
+  /** Appends a Big-Endian byte to the end of this buffer. */
+  public OkBuffer writeByte(int b) {
+    Segment tail = writableSegment(1);
+    tail.data[tail.limit++] = (byte) b;
+    byteCount += 1;
+    return this;
+  }
+
+  /** Appends a Big-Endian short to the end of this buffer. */
+  public OkBuffer writeShort(int s) {
+    Segment tail = writableSegment(2);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((s >> 8) & 0xff);
+    data[limit++] = (byte)  (s       & 0xff);
+    tail.limit = limit;
+    byteCount += 2;
+    return this;
+  }
+
+  /** Appends a Big-Endian int to the end of this buffer. */
+  public OkBuffer writeInt(int i) {
+    Segment tail = writableSegment(4);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((i >> 24) & 0xff);
+    data[limit++] = (byte) ((i >> 16) & 0xff);
+    data[limit++] = (byte) ((i >>  8) & 0xff);
+    data[limit++] = (byte)  (i        & 0xff);
+    tail.limit = limit;
+    byteCount += 4;
+    return this;
+  }
+
+  /**
+   * Returns a tail segment that we can write at least {@code minimumCapacity}
+   * bytes to, creating it if necessary.
+   */
+  Segment writableSegment(int minimumCapacity) {
+    if (minimumCapacity < 1 || minimumCapacity > Segment.SIZE) throw new IllegalArgumentException();
+
     if (head == null) {
       head = SegmentPool.INSTANCE.take(); // Acquire a first segment.
       return head.next = head.prev = head;
     }
 
     Segment tail = head.prev;
-    if (tail.limit == Segment.SIZE) {
+    if (tail.limit + minimumCapacity > Segment.SIZE) {
       tail = tail.push(SegmentPool.INSTANCE.take()); // Append a new empty segment to fill up.
     }
     return tail;
@@ -264,14 +389,14 @@ List<Integer> segmentSizes() {
    */
   @Override public String toString() {
     if (byteCount > 0x100000) return super.toString();
-    char[] result = new char[(int) (byteCount * 2)];
+    int charCount = (int) (byteCount * 2);
+    char[] result = new char[charCount];
     int offset = 0;
-    for (Segment s = head; offset < byteCount; s = s.next) {
+    for (Segment s = head; offset < charCount; s = s.next) {
       for (int i = s.pos; i < s.limit; i++) {
         result[offset++] = HEX_DIGITS[(s.data[i] >> 4) & 0xf];
         result[offset++] = HEX_DIGITS[s.data[i] & 0xf];
       }
-      offset += s.limit - s.pos;
     }
     return new String(result);
   }
@@ -67,7 +67,7 @@ public static Source source(final InputStream in) {
           OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
         if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
         deadline.throwIfReached();
-        Segment tail = sink.writableSegment();
+        Segment tail = sink.writableSegment(1);
         int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);
         int bytesRead = in.read(tail.data, tail.limit, maxToCopy);
         if (bytesRead == -1) return -1;
@@ -316,6 +316,106 @@ private List<Integer> moveBytesBetweenBuffers(String... contents) {
     assertEquals(-1, source.read(sink, 1, Deadline.NONE));
   }
 
+  @Test public void writeBytes() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeByte(0xab);
+    data.writeByte(0xcd);
+    assertEquals(""abcd"", data.toString());
+  }
+
+  @Test public void writeLastByteInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 1));
+    data.writeByte(0x20);
+    data.writeByte(0x21);
+    assertEquals(asList(Segment.SIZE, 1), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 1), data.readUtf8(Segment.SIZE - 1));
+    assertEquals(""2021"", data.toString());
+  }
+
+  @Test public void writeShort() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeShort(0xabcd);
+    data.writeShort(0x4321);
+    assertEquals(""abcd4321"", data.toString());
+  }
+
+  @Test public void writeInt() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(""abcdef0187654321"", data.toString());
+  }
+
+  @Test public void writeLastIntegerInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 4));
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(asList(Segment.SIZE, 4), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 4), data.readUtf8(Segment.SIZE - 4));
+    assertEquals(""abcdef0187654321"", data.toString());
+  }
+
+  @Test public void writeIntegerDoesntQuiteFitInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 3));
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(asList(Segment.SIZE - 3, 8), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 3), data.readUtf8(Segment.SIZE - 3));
+    assertEquals(""abcdef0187654321"", data.toString());
+  }
+
+  @Test public void readByte() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] { (byte) 0xab, (byte) 0xcd }));
+    assertEquals((byte) 0xab, data.readByte());
+    assertEquals((byte) 0xcd, data.readByte());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readShort() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
+    }));
+    assertEquals((short) 0xabcd, data.readShort());
+    assertEquals((short) 0xef01, data.readShort());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readShortSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 1));
+    data.write(new ByteString(new byte[] { (byte) 0xab, (byte) 0xcd }));
+    data.readUtf8(Segment.SIZE - 1);
+    assertEquals((short) 0xabcd, data.readShort());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readInt() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01,
+        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21
+    }));
+    assertEquals(0xabcdef01, data.readInt());
+    assertEquals(0x87654321, data.readInt());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readIntSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 3));
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
+    }));
+    data.readUtf8(Segment.SIZE - 3);
+    assertEquals(0xabcdef01, data.readInt());
+    assertEquals(0, data.byteCount());
+  }
+
   private String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
",True,"The commit message refers to the necessity of changes by mentioning that the changes are made because 'that's all we use in OkHttp'. This implies that the project has a standard of using big-endian only, and the commit is made to adhere to this standard.",True,The commit message ,False,"The commit message does not explicitly describe the necessity of changes by elaborating the motivation of a code change. It only mentions that the changes are for read/write access for byte, short, and int, and that it's big-endian only because that's all they use in OkHttp. However, it does not explain why these changes were needed, such as describing an error scenario, mentioning an issue report, or the shortcoming of the previous implementation.",True,"The commit message 'Read/write access for byte, short and int. This is big-endian only because that's all we use in OkHttp.' indicates that the developer added read and write access for byte, short, and int data types to match the requirements of the OkHttp library, which only uses big-endian data. This suggests that the change was made to meet a specific requirement or need, rather than due to a problem in the maintenance of the codebase or a change in the runtime or development environment.",True,"The commit message 'Read/write access for byte, short and int.' directly mentions the improvements it makes to the code by adding read/write access for byte, short, and int data types. This is a clear indication of the objective of the change.",True,"The commit message 'Read/write access for byte, short and int' accurately summarizes the changes made in the code diff. It highlights the addition of methods for reading and writing bytes, shorts, and ints, which are the key components of the change. The message also mentions that the implementation is big-endian only, which is a notable detail from the code diff.",True,"The commit message explains that the changes are implementing read/write access for byte, short, and int data types, and that the implementation is based on the big-endian byte order, which is a common and well-defined technique for representing binary data in computer systems.",True,"The commit message 'Read/write access for byte, short and int. This is big-endian only because that's all we use in OkHttp.' accurately describes the changes made in the code diff. The changes include the addition of methods to read and write bytes, shorts, and ints in big-endian format, which is a specific behavior introduced by the code changes.",False,"The commit message does not lack an explanation. While the change is relatively small and simple, the commit message explicitly mentions that the change is for read/write access for byte, short, and int, and that it's big-endian only because that's all they use in OkHttp. This provides a clear explanation of the reason for the commit."
https://github.com/square/okhttp/commit/37c01895cca5ec2bec26a3d381611f0938acd6d0,Define async APIs and switch Job to use HttpEngine directly.  <enter> Using HttpEngine directly introduces some duplicated code with HttpURLConnection. It also breaks the response cache. I think this is the best route going forward; and eventually we could invert this relationship to have HttpURLConnection depending on Job directly rather than vice versa. ,https://api.github.com/repos/square/okhttp/commits/37c01895cca5ec2bec26a3d381611f0938acd6d0,"@@ -15,9 +15,9 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.http.ResponseHeaders;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -33,8 +33,8 @@ final class Dispatcher {
   private final Map<Object, List<Job>> enqueuedJobs = new LinkedHashMap<Object, List<Job>>();
 
   public synchronized void enqueue(
-      HttpURLConnection connection, Request request, Response.Receiver responseReceiver) {
-    Job job = new Job(this, connection, request, responseReceiver);
+      OkHttpClient client, Request request, Response.Receiver responseReceiver) {
+    Job job = new Job(this, client, request, responseReceiver);
     List<Job> jobsForTag = enqueuedJobs.get(request.tag());
     if (jobsForTag == null) {
       jobsForTag = new ArrayList<Job>(2);
@@ -53,25 +53,30 @@ public synchronized void cancel(Object tag) {
   }
 
   synchronized void finished(Job job) {
-    List<Job> jobs = enqueuedJobs.get(job.request.tag());
+    List<Job> jobs = enqueuedJobs.get(job.tag());
     if (jobs != null) jobs.remove(job);
   }
 
   static class RealResponseBody extends Response.Body {
-    private final HttpURLConnection connection;
+    private final ResponseHeaders responseHeaders;
     private final InputStream in;
 
-    RealResponseBody(HttpURLConnection connection, InputStream in) {
-      this.connection = connection;
+    RealResponseBody(ResponseHeaders responseHeaders, InputStream in) {
+      this.responseHeaders = responseHeaders;
       this.in = in;
     }
 
-    @Override public String contentType() {
-      return connection.getHeaderField(""Content-Type"");
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
+
+    @Override public MediaType contentType() {
+      String contentType = responseHeaders.getContentType();
+      return contentType != null ? MediaType.parse(contentType) : null;
     }
 
     @Override public long contentLength() {
-      return connection.getContentLength(); // TODO: getContentLengthLong
+      return responseHeaders.getContentLength();
     }
 
     @Override public InputStream byteStream() throws IOException {
@@ -15,71 +15,218 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.http.HttpAuthenticator;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.HttpTransport;
+import com.squareup.okhttp.internal.http.HttpsEngine;
+import com.squareup.okhttp.internal.http.Policy;
+import com.squareup.okhttp.internal.http.RawHeaders;
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.URL;
 
-final class Job implements Runnable {
-  final HttpURLConnection connection;
-  final Request request;
-  final Response.Receiver responseReceiver;
-  final Dispatcher dispatcher;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_PERM;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_TEMP;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MULT_CHOICE;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_PROXY_AUTH;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_SEE_OTHER;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_TEMP_REDIRECT;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_UNAUTHORIZED;
 
-  public Job(Dispatcher dispatcher, HttpURLConnection connection, Request request,
+final class Job implements Runnable, Policy {
+  private final Dispatcher dispatcher;
+  private final OkHttpClient client;
+  private final Response.Receiver responseReceiver;
+
+  /** The request; possibly a consequence of redirects or auth headers. */
+  private Request request;
+
+  public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
       Response.Receiver responseReceiver) {
     this.dispatcher = dispatcher;
-    this.connection = connection;
+    this.client = client;
     this.request = request;
     this.responseReceiver = responseReceiver;
   }
 
+  @Override public int getChunkLength() {
+    return request.body().contentLength() == -1 ? HttpTransport.DEFAULT_CHUNK_LENGTH : -1;
+  }
+
+  @Override public long getFixedContentLength() {
+    return request.body().contentLength();
+  }
+
+  @Override public boolean getUseCaches() {
+    return false; // TODO.
+  }
+
+  @Override public HttpURLConnection getHttpConnectionToCache() {
+    return null;
+  }
+
+  @Override public URL getURL() {
+    return request.url();
+  }
+
+  @Override public long getIfModifiedSince() {
+    return 0; // For HttpURLConnection only. We let the cache drive this.
+  }
+
+  @Override public boolean usingProxy() {
+    return false; // We let the connection decide this.
+  }
+
+  @Override public void setSelectedProxy(Proxy proxy) {
+    // Do nothing.
+  }
+
+  Object tag() {
+    return request.tag();
+  }
+
   @Override public void run() {
     try {
-      sendRequest();
-      Response response = readResponse();
+      Response response = execute();
       responseReceiver.onResponse(response);
     } catch (IOException e) {
       responseReceiver.onFailure(new Failure.Builder()
           .request(request)
           .exception(e)
           .build());
     } finally {
-      connection.disconnect();
+      // TODO: close the response body
+      // TODO: release the HTTP engine (potentially multiple!)
       dispatcher.finished(this);
     }
   }
 
-  private HttpURLConnection sendRequest() throws IOException {
-    for (int i = 0; i < request.headerCount(); i++) {
-      connection.addRequestProperty(request.headerName(i), request.headerValue(i));
-    }
-    Request.Body body = request.body();
-    if (body != null) {
-      connection.setDoOutput(true);
-      long contentLength = body.contentLength();
-      if (contentLength == -1 || contentLength > Integer.MAX_VALUE) {
-        connection.setChunkedStreamingMode(0);
-      } else {
-        // Don't call setFixedLengthStreamingMode(long); that's only available on Java 1.7+.
-        connection.setFixedLengthStreamingMode((int) contentLength);
+  private Response execute() throws IOException {
+    Connection connection = null;
+    Response redirectedBy = null;
+
+    while (true) {
+      HttpEngine engine = newEngine(connection);
+
+      Request.Body body = request.body();
+      if (body != null) {
+        MediaType contentType = body.contentType();
+        if (contentType == null) throw new IllegalStateException(""contentType == null"");
+        if (engine.getRequestHeaders().getContentType() == null) {
+          engine.getRequestHeaders().setContentType(contentType.toString());
+        }
+      }
+
+      engine.sendRequest();
+
+      if (body != null) {
+        body.writeTo(engine.getRequestBody());
       }
-      body.writeTo(connection.getOutputStream());
+
+      engine.readResponse();
+
+      int responseCode = engine.getResponseCode();
+      Dispatcher.RealResponseBody responseBody = new Dispatcher.RealResponseBody(
+          engine.getResponseHeaders(), engine.getResponseBody());
+
+      Response response = new Response.Builder(request, responseCode)
+          .rawHeaders(engine.getResponseHeaders().getHeaders())
+          .body(responseBody)
+          .redirectedBy(redirectedBy)
+          .build();
+
+      Request redirect = processResponse(engine, response);
+
+      if (redirect == null) {
+        engine.automaticallyReleaseConnectionToPool();
+        return response;
+      }
+
+      // TODO: fail if too many redirects
+      // TODO: fail if not following redirects
+      // TODO: release engine
+
+      connection = sameConnection(request, redirect) ? engine.getConnection() : null;
+      redirectedBy = response;
+      request = redirect;
     }
-    return connection;
   }
 
-  private Response readResponse() throws IOException {
-    int responseCode = connection.getResponseCode();
-    Response.Builder responseBuilder = new Response.Builder(request, responseCode);
+  HttpEngine newEngine(Connection connection) throws IOException {
+    String protocol = request.url().getProtocol();
+    RawHeaders requestHeaders = request.rawHeaders();
+    if (protocol.equals(""http"")) {
+      return new HttpEngine(client, this, request.method(), requestHeaders, connection, null);
+    } else if (protocol.equals(""https"")) {
+      return new HttpsEngine(client, this, request.method(), requestHeaders, connection, null);
+    } else {
+      throw new AssertionError();
+    }
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving {@code
+   * response}. This will either add authentication headers or follow
+   * redirects. If a follow-up is either unnecessary or not applicable, this
+   * returns null.
+   */
+  private Request processResponse(HttpEngine engine, Response response) throws IOException {
+    Request request = response.request();
+    Proxy selectedProxy = engine.getConnection() != null
+        ? engine.getConnection().getRoute().getProxy()
+        : client.getProxy();
+    int responseCode = response.code();
+
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException(""Received HTTP_PROXY_AUTH (407) code while not using proxy"");
+        }
+        // fall-through
+      case HTTP_UNAUTHORIZED:
+        RawHeaders successorRequestHeaders = request.rawHeaders();
+        boolean credentialsFound = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
+            response.code(), response.rawHeaders(), successorRequestHeaders, selectedProxy,
+            this.request.url());
+        return credentialsFound
+            ? request.newBuilder().rawHeaders(successorRequestHeaders).build()
+            : null;
 
-    for (int i = 0; true; i++) {
-      String name = connection.getHeaderFieldKey(i);
-      if (name == null) break;
-      String value = connection.getHeaderField(i);
-      responseBuilder.addHeader(name, value);
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+      case HTTP_TEMP_REDIRECT:
+        String method = request.method();
+        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals(""GET"") && !method.equals(""HEAD"")) {
+          // ""If the 307 status code is received in response to a request other than GET or HEAD,
+          // the user agent MUST NOT automatically redirect the request""
+          return null;
+        }
+
+        String location = response.header(""Location"");
+        if (location == null) {
+          return null;
+        }
+
+        URL url = new URL(request.url(), location);
+        if (!url.getProtocol().equals(""https"") && !url.getProtocol().equals(""http"")) {
+          return null; // Don't follow redirects to unsupported protocols.
+        }
+
+        return this.request.newBuilder().url(url).build();
+
+      default:
+        return null;
     }
+  }
 
-    responseBuilder.body(new Dispatcher.RealResponseBody(connection, connection.getInputStream()));
-    // TODO: set redirectedBy
-    return responseBuilder.build();
+  private boolean sameConnection(Request a, Request b) {
+    return a.url().getHost().equals(b.url().getHost())
+        && getEffectivePort(a.url()) == getEffectivePort(b.url())
+        && a.url().getProtocol().equals(b.url().getProtocol());
   }
 }
@@ -324,7 +324,7 @@ public List<String> getTransports() {
     // Create the HttpURLConnection immediately so the enqueued job gets the current settings of
     // this client. Otherwise changes to this client (socket factory, redirect policy, etc.) may
     // incorrectly be reflected in the request when it is dispatched later.
-    dispatcher.enqueue(open(request.url()), request, responseReceiver);
+    dispatcher.enqueue(copyWithDefaults(), request, responseReceiver);
   }
 
   /**
@@ -74,6 +74,10 @@ public Set<String> headerNames() {
     return headers.names();
   }
 
+  RawHeaders rawHeaders() {
+    return new RawHeaders(headers);
+  }
+
   public int headerCount() {
     return headers.length();
   }
@@ -94,16 +98,21 @@ public Object tag() {
     return tag;
   }
 
+  Builder newBuilder() {
+    return new Builder(url)
+        .method(method, body)
+        .rawHeaders(headers)
+        .tag(tag);
+  }
+
   public abstract static class Body {
+    /** Returns the Content-Type header for this body. */
+    public abstract MediaType contentType();
+
     /**
-     * Returns the Content-Type header for this body, or null if the content
-     * type is unknown.
+     * Returns the number of bytes that will be written to {@code out} in a call
+     * to {@link #writeTo}, or -1 if that count is unknown.
      */
-    public MediaType contentType() {
-      return null;
-    }
-
-    /** Returns the number of bytes in this body, or -1 if that count is unknown. */
     public long contentLength() {
       return -1;
     }
@@ -183,7 +192,7 @@ public static Body create(final MediaType contentType, final File file) {
   public static class Builder {
     private URL url;
     private String method = ""GET"";
-    private final RawHeaders headers = new RawHeaders();
+    private RawHeaders headers = new RawHeaders();
     private Body body;
     private Object tag;
 
@@ -228,6 +237,11 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    Builder rawHeaders(RawHeaders rawHeaders) {
+      headers = new RawHeaders(rawHeaders);
+      return this;
+    }
+
     public Builder get() {
       return method(""GET"", null);
     }
@@ -22,9 +22,12 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.nio.charset.Charset;
 import java.util.List;
 import java.util.Set;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
+
 /**
  * An HTTP response. Instances of this class are not immutable: the response
  * body is a one-shot value that may be consumed only once. All other properties
@@ -93,6 +96,10 @@ public String headerName(int index) {
     return headers.getFieldName(index);
   }
 
+  RawHeaders rawHeaders() {
+    return new RawHeaders(headers);
+  }
+
   public String headerValue(int index) {
     return headers.getValue(index);
   }
@@ -112,17 +119,34 @@ public Response redirectedBy() {
   }
 
   public abstract static class Body {
-    public String contentType() {
-      return null;
-    }
+    /** Multiple calls to {@link #charStream()} must return the same instance. */
+    private Reader reader;
 
-    public long contentLength() {
-      return -1;
-    }
+    /**
+     * Returns true if further data from this response body should be read at
+     * this time. For asynchronous transports like SPDY and HTTP/2.0, this will
+     * return false once all locally-available body bytes have been read.
+     *
+     * <p>Clients with many concurrent downloads can use this method to reduce
+     * the number of idle threads blocking on reads. See {@link
+     * Receiver#onResponse} for details.
+     */
+    // <h3>Body.ready() vs. InputStream.available()</h3>
+    // TODO: Can we fix response bodies to implement InputStream.available well?
+    // The deflater implementation is broken by default but we could do better.
+    public abstract boolean ready() throws IOException;
+
+    public abstract MediaType contentType();
+
+    /**
+     * Returns the number of bytes in that will returned by {@link #bytes}, or
+     * {@link #byteStream}, or -1 if unknown.
+     */
+    public abstract long contentLength();
 
     public abstract InputStream byteStream() throws IOException;
 
-    public byte[] bytes() throws IOException {
+    public final byte[] bytes() throws IOException {
       long contentLength = contentLength();
       if (contentLength > Integer.MAX_VALUE) {
         throw new IOException(""Cannot buffer entire body for content length: "" + contentLength);
@@ -143,33 +167,77 @@ public byte[] bytes() throws IOException {
     }
 
     /**
-     * Returns the response bytes as a UTF-8 character stream. Do not call this
-     * method if the response content is not a UTF-8 character stream.
+     * Returns the response as a character stream decoded with the charset
+     * of the Content-Type header. If that header is either absent or lacks a
+     * charset, this will attempt to decode the response body as UTF-8.
      */
-    public Reader charStream() throws IOException {
-      // TODO: parse content-type.
-      return new InputStreamReader(byteStream(), ""UTF-8"");
+    public final Reader charStream() throws IOException {
+      if (reader == null) {
+        reader = new InputStreamReader(byteStream(), charset());
+      }
+      return reader;
     }
 
     /**
-     * Returns the response bytes as a UTF-8 string. Do not call this method if
-     * the response content is not a UTF-8 character stream.
+     * Returns the response as a string decoded with the charset of the
+     * Content-Type header. If that header is either absent or lacks a charset,
+     * this will attempt to decode the response body as UTF-8.
      */
-    public String string() throws IOException {
-      // TODO: parse content-type.
-      return new String(bytes(), ""UTF-8"");
+    public final String string() throws IOException {
+      return new String(bytes(), charset().name());
+    }
+
+    private Charset charset() {
+      MediaType contentType = contentType();
+      return contentType != null ? contentType.charset(UTF_8) : UTF_8;
     }
   }
 
   public interface Receiver {
+    /**
+     * Called when the request could not be executed due to a connectivity
+     * problem or timeout. Because networks can fail during an exchange, it is
+     * possible that the remote server accepted the request before the failure.
+     */
     void onFailure(Failure failure);
-    void onResponse(Response response) throws IOException;
+
+    /**
+     * Called when the HTTP response was successfully returned by the remote
+     * server. The receiver may proceed to read the response body with the
+     * response's {@link #body} method.
+     *
+     * <p>Note that transport-layer success (receiving a HTTP response code,
+     * headers and body) does not necessarily indicate application-layer
+     * success: {@code response} may still indicate an unhappy HTTP response
+     * code like 404 or 500.
+     *
+     * <h3>Non-blocking responses</h3>
+     *
+     * <p>Receivers do not need to block while waiting for the response body to
+     * download. Instead, they can get called back as data arrives. Use {@link
+     * Body#ready} to check if bytes should be read immediately. While there is
+     * data ready, read it. If there isn't, return false: receivers will be
+     * called back with {@code onResponse()} as additional data is downloaded.
+     *
+     * <p>Return true to indicate that the receiver has finished handling the
+     * response body. If the response body has unread data, it will be
+     * discarded.
+     *
+     * <p>When the response body has been fully consumed the returned value is
+     * undefined.
+     *
+     * <p>The current implementation of {@link Body#ready} always returns true
+     * when the underlying transport is HTTP/1. This results in blocking on that
+     * transport. For effective non-blocking your server must support SPDY or
+     * HTTP/2.
+     */
+    boolean onResponse(Response response) throws IOException;
   }
 
   public static class Builder {
     private final Request request;
     private final int code;
-    private final RawHeaders headers = new RawHeaders();
+    private RawHeaders headers = new RawHeaders();
     private Body body;
     private Response redirectedBy;
 
@@ -198,6 +266,11 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    Builder rawHeaders(RawHeaders rawHeaders) {
+      headers = new RawHeaders(rawHeaders);
+      return this;
+    }
+
     public Builder body(Body body) {
       this.body = body;
       return this;
@@ -370,10 +370,10 @@ private void writeBufferedChunkToSocket() throws IOException {
 
   /** An HTTP body with a fixed length specified in advance. */
   private static class FixedLengthInputStream extends AbstractHttpInputStream {
-    private int bytesRemaining;
+    private long bytesRemaining;
 
     public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine,
-        int length) throws IOException {
+        long length) throws IOException {
       super(is, httpEngine, cacheRequest);
       bytesRemaining = length;
       if (bytesRemaining == 0) {
@@ -387,7 +387,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
       if (bytesRemaining == 0) {
         return -1;
       }
-      int read = in.read(buffer, offset, Math.min(count, bytesRemaining));
+      int read = in.read(buffer, offset, (int) Math.min(count, bytesRemaining));
       if (read == -1) {
         unexpectedEndOfInput(); // the server didn't supply the promised content length
         throw new ProtocolException(""unexpected end of stream"");
@@ -402,7 +402,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
 
     @Override public int available() throws IOException {
       checkNotClosed();
-      return bytesRemaining == 0 ? 0 : Math.min(in.available(), bytesRemaining);
+      return bytesRemaining == 0 ? 0 : (int) Math.min(in.available(), bytesRemaining);
     }
 
     @Override public void close() throws IOException {
@@ -60,7 +60,7 @@
 public class HttpURLConnectionImpl extends HttpURLConnection implements Policy {
 
   /** Numeric status code, 307: Temporary Redirect. */
-  static final int HTTP_TEMP_REDIRECT = 307;
+  public static final int HTTP_TEMP_REDIRECT = 307;
 
   /**
    * How many redirects should we follow? Chrome follows 21; Firefox, curl,
@@ -311,7 +311,7 @@ private HttpEngine getResponse() throws IOException {
       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
       // redirect should keep the same method, Chrome, Firefox and the
       // RI all issue GETs when following any redirect.
-      int responseCode = getResponseCode();
+      int responseCode = httpEngine.getResponseCode();
       if (responseCode == HTTP_MULT_CHOICE
           || responseCode == HTTP_MOVED_PERM
           || responseCode == HTTP_MOVED_TEMP
@@ -321,8 +321,7 @@ private HttpEngine getResponse() throws IOException {
       }
 
       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {
-        throw new HttpRetryException(""Cannot retry streamed HTTP body"",
-            httpEngine.getResponseCode());
+        throw new HttpRetryException(""Cannot retry streamed HTTP body"", responseCode);
       }
 
       if (retry == Retry.DIFFERENT_CONNECTION) {
@@ -413,7 +412,7 @@ enum Retry {
 
   /**
    * Returns the retry action to take for the current response headers. The
-   * headers, proxy and target URL or this connection may be adjusted to
+   * headers, proxy and target URL for this connection may be adjusted to
    * prepare for a follow up request.
    */
   private Retry processResponseHeaders() throws IOException {
@@ -114,8 +114,9 @@ public final class ResponseHeaders {
 
   private String contentEncoding;
   private String transferEncoding;
-  private int contentLength = -1;
+  private long contentLength = -1;
   private String connection;
+  private String contentType;
 
   public ResponseHeaders(URI uri, RawHeaders headers) {
     this.uri = uri;
@@ -172,9 +173,11 @@ public ResponseHeaders(URI uri, RawHeaders headers) {
         transferEncoding = value;
       } else if (""Content-Length"".equalsIgnoreCase(fieldName)) {
         try {
-          contentLength = Integer.parseInt(value);
+          contentLength = Long.parseLong(value);
         } catch (NumberFormatException ignored) {
         }
+      } else if (""Content-Type"".equalsIgnoreCase(fieldName)) {
+        contentType = value;
       } else if (""Connection"".equalsIgnoreCase(fieldName)) {
         connection = value;
       } else if (SENT_MILLIS.equalsIgnoreCase(fieldName)) {
@@ -263,10 +266,14 @@ public String getContentEncoding() {
     return contentEncoding;
   }
 
-  public int getContentLength() {
+  public long getContentLength() {
     return contentLength;
   }
 
+  public String getContentType() {
+    return contentType;
+  }
+
   public String getConnection() {
     return connection;
   }
@@ -68,5 +68,6 @@ public final class AsyncApiTest {
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals(""def"", recordedRequest.getUtf8Body());
     assertEquals(""3"", recordedRequest.getHeader(""Content-Length""));
+    assertEquals(""text/plain; charset=utf-8"", recordedRequest.getHeader(""Content-Type""));
   }
 }
@@ -15,9 +15,12 @@
  */
 package com.squareup.okhttp;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -26,17 +29,40 @@
 public class RecordingReceiver implements Response.Receiver {
   public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
+  private final Map<Request, ByteArrayOutputStream> inFlightResponses
+      = new LinkedHashMap<Request, ByteArrayOutputStream>();
   private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
 
   @Override public synchronized void onFailure(Failure failure) {
     responses.add(new RecordedResponse(failure.request(), null, null, failure));
     notifyAll();
   }
 
-  @Override public synchronized void onResponse(Response response) throws IOException {
-    responses.add(new RecordedResponse(
-        response.request(), response, response.body().string(), null));
-    notifyAll();
+  @Override public synchronized boolean onResponse(Response response) throws IOException {
+    ByteArrayOutputStream out = inFlightResponses.get(response.request());
+    if (out == null) {
+      out = new ByteArrayOutputStream();
+      inFlightResponses.put(response.request(), out);
+    }
+
+    byte[] buffer = new byte[1024];
+    Response.Body body = response.body();
+
+    while (body.ready()) {
+      int c = body.byteStream().read(buffer);
+
+      if (c == -1) {
+        inFlightResponses.remove(response.request());
+        responses.add(new RecordedResponse(
+            response.request(), response, out.toString(""UTF-8""), null));
+        notifyAll();
+        return true;
+      }
+
+      out.write(buffer, 0, c);
+    }
+
+    return false;
   }
 
   /**
",True,The commit message refers to the necessity of changes by mentioning that using HttpEngine directly introduces some duplicated code with HttpURLConnection and breaks the response cache. This explains why the commit is made and the changes that are being introduced.,True,"The commit message does not explicitly state the reason for the changes, but it is clear from the code diff that the changes are being made to define async APIs and switch Job to use HttpEngine directly. This is likely to improve performance and functionality, but the exact reason is not explicitly stated in the commit message.",True,The commit message explains that the changes are being made to define async APIs and switch Job to use HttpEngine directly. This introduces some duplicated code with HttpURLConnection and breaks the response cache. The message mentions that this is the best route going forward and eventually they could invert this relationship to have HttpURLConnection depending on Job directly rather than vice versa. This elaborates on the motivation of the code change by explaining the problem that the previous implementation had with the response cache and the benefits of the new approach.,True,"The commit message indicates that the developer is defining async APIs and switching Job to use HttpEngine directly. This change is made to introduce some duplicated code with HttpURLConnection and to break the response cache. The developer mentions that this is the best route going forward and eventually they could invert this relationship to have HttpURLConnection depending on Job directly rather than vice versa. This suggests that the change is being made to improve the efficiency and functionality of the code, which is a requirement for software development.",True,"The commit message mentions that it 'Define async APIs and switch Job to use HttpEngine directly', which implies that the change is improving the code by introducing a new and more efficient way to handle HTTP requests.",True,"The commit message describes the changes made to the codebase by summarizing the diffs. It mentions the introduction of async APIs and the switch from using HttpURLConnection to using HttpEngine directly. This contrasts the before and after state of the codebase, highlighting the key components of the change.",True,"The commit message explains that the changes are made to define async APIs and switch Job to use HttpEngine directly. This introduces some duplicated code with HttpURLConnection but breaks the response cache. The message highlights the technical principle underpinning the changes, which is to use HttpEngine directly for better asynchronous handling and to break the response cache to improve performance and flexibility.",True,"The commit message expresses a change in the codebase that involves the introduction of asynchronous APIs and the direct use of HttpEngine. This change is described as a functional improvement, as it introduces some duplicated code with HttpURLConnection but also breaks the response cache. The message explains that this is the best route going forward and eventually, the relationship could be inverted to have HttpURLConnection depend on Job directly rather than vice versa. Additionally, the code diff provided supports this explanation by showing changes in the Job class, including the addition of new methods and parameters related to HttpEngine and the removal of HttpURLConnection. The changes also involve modifications to the Dispatcher and Response classes, further supporting the explanation that the commit message is describing a functional change related to the introduction of asynchronous APIs and the use of HttpEngine.",False,The commit message does not lack an explanation. It clearly states the reasons for defining async APIs and switching Job to use HttpEngine directly. These reasons include introducing some duplicated code with HttpURLConnection and breaking the response cache. The commit message also mentions that this is the best route going forward and eventually they could invert this relationship.
https://github.com/junit-team/junit4/commit/236e75bd968935cf8728c3f7aaaccaefd2f9c737,Adapt links to reflect repo rename ,https://api.github.com/repos/junit-team/junit4/commits/236e75bd968935cf8728c3f7aaaccaefd2f9c737,"@@ -11,4 +11,4 @@ BUILDING FROM JARS OR ZIPS:
 The contents of the zip and jar files are largely maintained for historical
 reasons.  We do not at this time have an official way to build from the src
 jar or zip.  If this is an important missing feature, please let us know
-at http://github.com/junit-team/junit/issues
+at http://github.com/junit-team/junit4/issues
@@ -2,9 +2,9 @@
 JUnit is a simple framework to write repeatable tests. It is an instance of the xUnit architecture for unit testing frameworks.
 
 For more information, please visit:
-* [Wiki](https://github.com/junit-team/junit/wiki)
-* [Download and Install guide](https://github.com/junit-team/junit/wiki/Download-and-Install)
-* [Getting Started](https://github.com/junit-team/junit/wiki/Getting-started)
+* [Wiki](https://github.com/junit-team/junit4/wiki)
+* [Download and Install guide](https://github.com/junit-team/junit4/wiki/Download-and-Install)
+* [Getting Started](https://github.com/junit-team/junit4/wiki/Getting-started)
 
 [![Latest Build Status](https://junit.ci.cloudbees.com/job/JUnit/badge/icon)](https://junit.ci.cloudbees.com/)
 
@@ -82,7 +82,7 @@
      reinholdfuereder@github For initial test for GH-39
 
 2011 Apr 15
-     ububenheimer@github for bug report https://github.com/junit-team/junit/issues/208
+     ububenheimer@github for bug report https://github.com/junit-team/junit4/issues/208
 
 2011 Apr 29
      reinholdfuereder@github: bug report, test, and fix for GH-38:
@@ -1,6 +1,6 @@
 <h2>Summary of Changes in version 4.10 [unreleased!]</h2>
 
-<p>A full summary of commits between 4.9 and 4.10 is on <a href=""https://github.com/junit-team/junit/compare/r4.9...4.10"">github</a></p>
+<p>A full summary of commits between 4.9 and 4.10 is on <a href=""https://github.com/junit-team/junit4/compare/r4.9...4.10"">github</a></p>
 
 <h3>junit-dep has correct contents</h3>
 
@@ -2,7 +2,7 @@
 
 Thanks to a full cast of contributors of bug fixes and new features.
 
-A full summary of commits between 4.9 and 4.10 is on [github](https://github.com/junit-team/junit/compare/r4.9...4.10)
+A full summary of commits between 4.9 and 4.10 is on [github](https://github.com/junit-team/junit4/compare/r4.9...4.10)
 
 ### junit-dep has correct contents ###
 
@@ -2,23 +2,23 @@
 
 # Assertions
 
-### [Pull request #611:](https://github.com/junit-team/junit/pull/611) Assert.assertNotEquals() for `float` parameters
+### [Pull request #611:](https://github.com/junit-team/junit4/pull/611) Assert.assertNotEquals() for `float` parameters
 
 Version 4.11 added `Assert.assertEquals()` for `float` parameters with a delta, and `Assert.assertNotEquals()`. This is the combination of those two features.
 
 
-### [Pull request #632:](https://github.com/junit-team/junit/pull/632) Assert.assertArrayEquals() for `boolean[]` parameters.
+### [Pull request #632:](https://github.com/junit-team/junit4/pull/632) Assert.assertArrayEquals() for `boolean[]` parameters.
 
 `Assert.assertArrayEquals()` previously existed for all primitive array types, except `boolean[]`. This has now been added for `boolean[]`.
 
 
-### [Pull request #918:](https://github.com/junit-team/junit/pull/918) Avoid potentially expensive reflection-based loop in Assert.assertArrayEquals()
+### [Pull request #918:](https://github.com/junit-team/junit4/pull/918) Avoid potentially expensive reflection-based loop in Assert.assertArrayEquals()
 
 In the usual case, where the array elements are in fact exactly equal, the potentially expensive reflection-based loop to compare them is avoided by using `Arrays.deepEquals()` first. The exact comparison is only executed when `deepEquals()` returns `false`.
 
 
 # Command-line options
-### [Pull request #647:](https://github.com/junit-team/junit/pull/647) Support command-line `--filter` param.
+### [Pull request #647:](https://github.com/junit-team/junit4/pull/647) Support command-line `--filter` param.
 
 When running JUnit from the command line, a command-line parameter can be supplied using `--filter`, which supplies a filter that will restrict which tests and subtests from the rest of the command will be run.  For example, this will run only the tests in ExampleTestSuite that are in categories Cat1 or Cat2:
 
@@ -33,12 +33,12 @@ In general, the argument to `--filter` should be `ClassName=param`, where `Class
 # Test Runners
 
 
-### [Pull request #763:](https://github.com/junit-team/junit/pull/763) Allow custom test runners to create their own TestClasses and customize the scanning of annotations.
+### [Pull request #763:](https://github.com/junit-team/junit4/pull/763) Allow custom test runners to create their own TestClasses and customize the scanning of annotations.
 
 This introduces some extension points to `ParentRunner` to allow subclasses to control creation
 of the `TestClass` instance and to scan for annotations.
 
-### [Pull request #817:](https://github.com/junit-team/junit/pull/817) Support for context hierarchies
+### [Pull request #817:](https://github.com/junit-team/junit4/pull/817) Support for context hierarchies
 
 The `AnnotatedBuilder` is a strategy for constructing runners for test classes that have been annotated with the `@RunWith` annotation. All tests within such a class will be executed using the runner that was specified within the annotation.
 
@@ -95,30 +95,30 @@ The key points to note here are:
 One example of a runner that makes use of this extension is the Hierarchical Context Runner (see https://github.com/bechte/junit-hierarchicalcontextrunner/wiki).
 
 
-### [Pull request #716:](https://github.com/junit-team/junit/pull/716) Fix annotation collection from superclasses of JUnit3 tests.
+### [Pull request #716:](https://github.com/junit-team/junit4/pull/716) Fix annotation collection from superclasses of JUnit3 tests.
 
 Previously `Description.getAnnotations()` would always return an empty list for _test*_ methods derived from superclasses. 
 
 
-### [Pull request #625 (commit 72af03c49f):](https://github.com/junit-team/junit/commit/72af03c49fdad5f10e36c7eb4e7045feb971d253) Make `RunNotifier` code concurrent.
+### [Pull request #625 (commit 72af03c49f):](https://github.com/junit-team/junit4/commit/72af03c49fdad5f10e36c7eb4e7045feb971d253) Make `RunNotifier` code concurrent.
 
 When running tests from multiple threads, JUnit will now call `RunListener` methods from multiple threads if the listener class is annotated with `@RunListener.ThreadSafe`. In addition, the code in `RunNotifier` has been modified to not use locks.
 
 
-### [Pull request #684:](https://github.com/junit-team/junit/pull/684) Adding `AnnotationValidator` framework and validation checks for `@Category`.
+### [Pull request #684:](https://github.com/junit-team/junit4/pull/684) Adding `AnnotationValidator` framework and validation checks for `@Category`.
 
 This allows for validation to be added to annotations. Validators should extend `AnnotationValidator` and be attached to annotations with the `@ValidateWith` annotation. `CategoryValidator` extends `AnnotationValidator` and ensures that incompatible annotations (`@BeforeClass`, `@AfterClass`, `@Before`, `@After`) are not used in conjunction with `@Category`.
 
 
 # Exception Testing
 
 
-### [Pull request #583:](https://github.com/junit-team/junit/pull/583) [Pull request #720:](https://github.com/junit-team/junit/pull/720) Fix handling of `AssertionError` and `AssumptionViolatedException` in `ExpectedException` rule.
+### [Pull request #583:](https://github.com/junit-team/junit4/pull/583) [Pull request #720:](https://github.com/junit-team/junit4/pull/720) Fix handling of `AssertionError` and `AssumptionViolatedException` in `ExpectedException` rule.
 
 `ExpectedException` didn't handle `AssertionError`s and `AssumptionViolatedException` well. This has been fixed. The new documentation explains the usage of `ExpectedException` for testing these exceptions. The two methods `handleAssertionErrors()` and `handleAssumptionViolatedExceptions()` are not needed anymore. If you have used them, just remove it and read `ExpectedException`'s documentation.
 
 
-### [Pull request #818:](https://github.com/junit-team/junit/pull/818) [Pull request #993:](https://github.com/junit-team/junit/pull/993) External version of AssumptionViolatedException
+### [Pull request #818:](https://github.com/junit-team/junit4/pull/818) [Pull request #993:](https://github.com/junit-team/junit4/pull/993) External version of AssumptionViolatedException
 
 In JUnit 4.11 and earlier, if you wanted to write a custom runner that handled
 `AssumptionViolatedException` or you needed to create an instance of `AssumptionViolatedException`
@@ -133,7 +133,7 @@ simpler than the ones in the internal version. That being said,
 it's recommended that you create `AssumptionViolatedException` via the methods in `Assume`.
 
 
-### [Pull request #985:](https://github.com/junit-team/junit/pull/985) Change AssumptionViolatedException to not set the cause to null; fixes issue #494
+### [Pull request #985:](https://github.com/junit-team/junit4/pull/985) Change AssumptionViolatedException to not set the cause to null; fixes issue #494
 
 Previously, the `AssumptionViolatedException` constructors would explicitly set the cause to `null`
 (unless you use a constructor where you provide a `Throwable`, in which case it would set that as
@@ -144,7 +144,7 @@ With this change, the cause is only set if you pass in a `Throwable`.
 It's recommended that you create `AssumptionViolatedException` via the methods in `Assume`.
 
 
-### [Pull request #542:](https://github.com/junit-team/junit/pull/542) Customized failure message for `ExpectedException`
+### [Pull request #542:](https://github.com/junit-team/junit4/pull/542) Customized failure message for `ExpectedException`
 
 `ExpectedException` now allows customization of the failure message when the test does not throw the expected exception. For example:
 
@@ -163,14 +163,14 @@ return type will match the type of the callable.
 
 
 # Timeout for Tests
-*See also [Timeout for tests](https://github.com/junit-team/junit/wiki/Timeout-for-tests)*
+*See also [Timeout for tests](https://github.com/junit-team/junit4/wiki/Timeout-for-tests)*
 
-### [Pull request #823:](https://github.com/junit-team/junit/pull/823) Throw `TestFailedOnTimeoutException` instead of plain `Exception` on timeout
+### [Pull request #823:](https://github.com/junit-team/junit4/pull/823) Throw `TestFailedOnTimeoutException` instead of plain `Exception` on timeout
 
 When a test times out, a `org.junit.runners.model.TestTimedOutException` is now thrown instead of a plain `java.lang.Exception`.
 
 
-### [Pull request #742:](https://github.com/junit-team/junit/pull/742) [Pull request #986:](https://github.com/junit-team/junit/pull/986) `Timeout` exceptions now include stack trace from stuck thread (experimental)
+### [Pull request #742:](https://github.com/junit-team/junit4/pull/742) [Pull request #986:](https://github.com/junit-team/junit4/pull/986) `Timeout` exceptions now include stack trace from stuck thread (experimental)
 
 `Timeout` exceptions try to determine if there is a child thread causing the problem, and if so its stack trace is included in the exception in addition to the one of the main thread. This feature must be enabled with the timeout rule by creating it through the new `Timeout.builder()` method:
 
@@ -190,7 +190,7 @@ public class HasGlobalTimeout {
 ```
 
 
-### [Pull request #544:](https://github.com/junit-team/junit/pull/544) New constructor and factories in `Timeout`
+### [Pull request #544:](https://github.com/junit-team/junit4/pull/544) New constructor and factories in `Timeout`
 
 `Timeout` deprecated the old constructor `Timeout(int millis)`.
 A new constructor is available: `Timeout(long timeout, TimeUnit unit)`. It enables you to use different granularities of time units like `NANOSECONDS`, `MICROSECONDS`, `MILLISECONDS`, and `SECONDS`. Examples:
@@ -216,7 +216,7 @@ and factory methods in `Timeout`:
 This usage avoids the truncation, which was the problem in the deprecated constructor `Timeout(int millis)` when casting `long` to `int`.
 
 
-### [Pull request #549:](https://github.com/junit-team/junit/pull/549) fixes for #544 and #545
+### [Pull request #549:](https://github.com/junit-team/junit4/pull/549) fixes for #544 and #545
 
 The `Timeout` rule applies the same timeout to all test methods in a class:
 
@@ -250,26 +250,26 @@ public class HasGlobalTimeout {
 ```
 Each test is run in a new _daemon_ thread. If the specified timeout elapses before the test completes, its execution is interrupted via `Thread#interrupt()`. This happens in interruptable I/O (operations throwing `java.io.InterruptedIOException` and `java.nio.channels.ClosedByInterruptException`), locks (package `java.util.concurrent`) and methods in `java.lang.Object` and `java.lang.Thread` throwing `java.lang.InterruptedException`.
 
-### [Pull request #876:](https://github.com/junit-team/junit/pull/876) The timeout rule never times out if you pass in a timeout of zero.
+### [Pull request #876:](https://github.com/junit-team/junit4/pull/876) The timeout rule never times out if you pass in a timeout of zero.
 
 
 # Parameterized Tests
 
 
-### [Pull request #702:](https://github.com/junit-team/junit/pull/702) Support more return types for the `@Parameters` method of the `Parameterized` runner
+### [Pull request #702:](https://github.com/junit-team/junit4/pull/702) Support more return types for the `@Parameters` method of the `Parameterized` runner
 
 The return types `Iterator<? extends Object>`, `Object[]` and `Object[][]` are now supported on methods annotated with `@Parameters`. You don't have to wrap arrays with `Iterable`s and single parameters with `Object` arrays.
 
 
-### [Pull request #773:](https://github.com/junit-team/junit/pull/773) Allow configurable creation of child runners of parameterized suites
+### [Pull request #773:](https://github.com/junit-team/junit4/pull/773) Allow configurable creation of child runners of parameterized suites
 
 The factory for creating the `Runner` instance of a single set of parameters is now configurable. It can be specified by the `@UseParametersRunnerFactory` annotation.
 
 
 # Rules
 
 
-### [Pull request #552:](https://github.com/junit-team/junit/pull/552) [Pull request #937:](https://github.com/junit-team/junit/pull/937) `Stopwatch` rule
+### [Pull request #552:](https://github.com/junit-team/junit4/pull/552) [Pull request #937:](https://github.com/junit-team/junit4/pull/937) `Stopwatch` rule
 
 The `Stopwatch` Rule notifies one of its own protected methods of the time spent by a test. Override them to get the time in nanoseconds. For example, this class will keep logging the time spent by each passed, failed, skipped, and finished test:
 
@@ -334,9 +334,9 @@ public void performanceTest() throws InterruptedException {
 }
 ```
 
-### [Pull request #932:](https://github.com/junit-team/junit/pull/932) Allow static `@Rule`s also annotated with `@ClassRule`
+### [Pull request #932:](https://github.com/junit-team/junit4/pull/932) Allow static `@Rule`s also annotated with `@ClassRule`
 
-JUnit 4.11 introduced restrictions requiring `@Rule` members to be non-static and `@ClassRule` members to be static. These restrictions have been relaxed slightly, in that a static member annotated with both `@Rule` and `@ClassRule` is now considered valid. This means a single rule may be used to perform actions both before/after a class (e.g. setup/tear down an external resource) and between tests (e.g. reset the external resource), without the need for any workarounds mentioned in issue [#793](https://github.com/junit-team/junit/issues/793).
+JUnit 4.11 introduced restrictions requiring `@Rule` members to be non-static and `@ClassRule` members to be static. These restrictions have been relaxed slightly, in that a static member annotated with both `@Rule` and `@ClassRule` is now considered valid. This means a single rule may be used to perform actions both before/after a class (e.g. setup/tear down an external resource) and between tests (e.g. reset the external resource), without the need for any workarounds mentioned in issue [#793](https://github.com/junit-team/junit4/issues/793).
 
 Note that a non-static `@ClassRule` annotated member is still considered invalid, even if annotated with `@Rule`.
 
@@ -350,7 +350,7 @@ public class CommonRuleTest {
 
 Be warned that if you have static methods or fields annotated with `@Rule` you will not be able to run your test methods in parallel.
 
-### [Pull request #956:](https://github.com/junit-team/junit/pull/956) `DisableOnDebug` rule
+### [Pull request #956:](https://github.com/junit-team/junit4/pull/956) `DisableOnDebug` rule
 
 The `DisableOnDebug` rule allows users to disable other rules when the JVM is launched in debug mode. Prior to this feature the common approach to disable rules that make debugging difficult was to comment them out and remember to revert the change. When using this feature users no longer have to modify their test code nor do they need to remember to revert changes.
 
@@ -361,15 +361,15 @@ This rule is particularly useful in combination with the `Timeout` rule.
 public DisableOnDebug timeout = new DisableOnDebug(Timeout.seconds(1));
 ```
 
-See the Javadoc for more detail and limitations. Related to https://github.com/junit-team/junit/issues/738
+See the Javadoc for more detail and limitations. Related to https://github.com/junit-team/junit4/issues/738
 
-### [Pull request #974:](https://github.com/junit-team/junit/pull/974) Updated `TemporaryFolder.newFolder()` to give an error message if a path contains a slash.
+### [Pull request #974:](https://github.com/junit-team/junit4/pull/974) Updated `TemporaryFolder.newFolder()` to give an error message if a path contains a slash.
 
 If you call `TemporaryFolder.newFolder(""foo/bar"")` in JUnit 4.10 the method returns a `File` object for the new folder but actually fails to create it. That is contrary to the expected behaviour of the method which is to actually create the folder. In JUnit 4.11 the same call throws an exception. Nowhere in the documentation does it explain that the String(s) passed to that method can only be single path components.
 
 With this fix, folder names are validated to contain single path name. If the folder name consists of multiple path names, an exception is thrown stating that usage of multiple path components in a string containing folder name is disallowed.
 
-### [Pull request #1015:](https://github.com/junit-team/junit/pull/1015) Methods annotated with `Rule` can return a `MethodRule`.
+### [Pull request #1015:](https://github.com/junit-team/junit4/pull/1015) Methods annotated with `Rule` can return a `MethodRule`.
 
 Methods annotated with `@Rule` can now return either a `TestRule` (or subclass) or a
 `MethodRule` (or subclass).
@@ -380,7 +380,7 @@ the method is only called if the return type could be assigned to `TestRule` or
 `MethodRule`. For methods annotated with `@Rule` that return other values, see the notes
 for pull request #1020.
 
-### [Pull request #1020:](https://github.com/junit-team/junit/pull/1020) Added validation that @ClassRule should only be implementation of TestRule.
+### [Pull request #1020:](https://github.com/junit-team/junit4/pull/1020) Added validation that @ClassRule should only be implementation of TestRule.
 
 Prior to this change, fields annotated with `@ClassRule` that did not have a type of `TestRule`
 (or a class that implements `TestRule`) were ignored. With this change, the test will fail
@@ -390,20 +390,20 @@ Prior to this change, methods annotated with `@ClassRule` that did specify a ret
 of `TestRule`(or a class that implements `TestRule`) were ignored. With this change, the test
 will fail with a validation error.
 
-### [Pull request #1021:](https://github.com/junit-team/junit/pull/1021) JavaDoc of TemporaryFolder: folder not guaranteed to be deleted.
+### [Pull request #1021:](https://github.com/junit-team/junit4/pull/1021) JavaDoc of TemporaryFolder: folder not guaranteed to be deleted.
 
 Adjusted JavaDoc of TemporaryFolder to reflect that temporary folders are not guaranteed to be
 deleted.
 
 # Theories
 
 
-### [Pull request #529:](https://github.com/junit-team/junit/pull/529) `@DataPoints`-annotated methods can now yield `null` values
+### [Pull request #529:](https://github.com/junit-team/junit4/pull/529) `@DataPoints`-annotated methods can now yield `null` values
 
 Up until JUnit 4.11 a `@DataPoints`-annotated array field could contain `null` values, but the array returned by a `@DataPoints`-annotated method could not. This asymmetry has been resolved: _both_ can now provide a `null` data point. 
 
 
-### [Pull request #572:](https://github.com/junit-team/junit/pull/572) Ensuring no-generic-type-parms validator called/tested for theories
+### [Pull request #572:](https://github.com/junit-team/junit4/pull/572) Ensuring no-generic-type-parms validator called/tested for theories
 
 The `Theories` runner now disallows `Theory` methods with parameters that have ""unresolved"" generic type parameters (e.g. `List<T>` where `T` is a type variable). It is exceedingly difficult for the `DataPoint(s)` scraper or other `ParameterSupplier`s to correctly decide values that can legitimately be assigned to such parameters in a type-safe way, so JUnit now disallows them altogether. Theory parameters such as `List<String>` and `Iterable<? extends Number>` are still allowed.
 
@@ -412,7 +412,7 @@ The machinery to perform this validation was in the code base for some time, but
 [junit.contrib](https://github.com/junit-team/junit.contrib)'s rendition of theories performs the same validation.
 
 
-### [Pull request #607:](https://github.com/junit-team/junit/pull/607) Improving theory failure messages
+### [Pull request #607:](https://github.com/junit-team/junit4/pull/607) Improving theory failure messages
 
 Theory failure messages previously were of the form: `ParameterizedAssertionError: theoryTest(badDatapoint, allValues[1], otherVar)`, where allValues, badDatapoint and otherVar were the variables the datapoints was sourced from. These messages are now of the form: 
 
@@ -422,7 +422,7 @@ ParameterizedAssertionError: theoryTest(null <from badDatapoint>, ""good value"" <
 ```
 
 
-### [Pull request #601:](https://github.com/junit-team/junit/pull/601) Allow use of `Assume` in tests run by `Theories` runner
+### [Pull request #601:](https://github.com/junit-team/junit4/pull/601) Allow use of `Assume` in tests run by `Theories` runner
 
 If, in a theory, all parameters were ""assumed"" away, the `Theories` runner would properly fail, informing you that no parameters were found to actually test something. However, if you had another method in that same class, that was not a theory (annotated with `@Test` only,) you could not use Assume in that test. Now, the `Theories` runner will verify the method is annotated with `@Theory` before failing due to no parameters being found.
 
@@ -447,12 +447,12 @@ public class TheoriesAndTestsTogether {
 ```
 
 
-### [Pull request #623:](https://github.com/junit-team/junit/pull/623) Ensure data points array fields and methods are `public` and `static` in Theory classes.
+### [Pull request #623:](https://github.com/junit-team/junit4/pull/623) Ensure data points array fields and methods are `public` and `static` in Theory classes.
 
 Previously if a data points array field or method was non-`static` or non-`public` it would be silently ignored and the data points not used. Now the `Theories` runner verifies that all `@DataPoint` or `@DataPoints` annotated fields or methods in classes are both `public` and `static`, and such classes will fail to run with `InitializationError`s if they are not.
 
 
-### [Pull request #621:](https://github.com/junit-team/junit/pull/621) Added mechanism for matching specific data points in theories to specific parameters, by naming data points.
+### [Pull request #621:](https://github.com/junit-team/junit4/pull/621) Added mechanism for matching specific data points in theories to specific parameters, by naming data points.
 
 `@DataPoints` fields or methods can now be given (one or more) names in the annotation, and `@Theory` method parameters can be annotated with `@FromDataPoints(name)`, to limit the data points considered for that parameter to only the data points with that name:
 
@@ -482,39 +482,39 @@ public void regexTheory(@FromDataPoints(""regexes"") String regex,
 ```
 
 
-### [Pull request #654:](https://github.com/junit-team/junit/pull/654) Auto-generation of `enum` and `boolean` data points
+### [Pull request #654:](https://github.com/junit-team/junit4/pull/654) Auto-generation of `enum` and `boolean` data points
 
 Any theory method parameters with `boolean` or `enum` types that cannot be supplied with values by any other sources will be automatically supplied with default values: `true` and `false`, or every value of the given `enum`. If other explicitly defined values are available (e.g. from a specified `ParameterSupplier` or some `DataPoints` method in the theory class), only those explicitly defined values will be used.
 
 
-### [Pull request #651:](https://github.com/junit-team/junit/pull/651) Improvements to Theory parameter and DataPoint type matching
+### [Pull request #651:](https://github.com/junit-team/junit4/pull/651) Improvements to Theory parameter and DataPoint type matching
 
  * Validity of `DataPoints` for theory parameters for all field data points and multi-valued method data points (i.e. not single-valued method data points) is now done on runtime type, not field/method return type (previously this was the case for multi-valued array methods only).
 
  * Validity of `DataPoints` for theory parameters for all data points now correctly handles boxing and unboxing for primitive and wrapper types; e.g. `int` values will be considered for theory parameters that are `Integer` assignable, and vice versa.
 
 
-### [Pull request #639:](https://github.com/junit-team/junit/pull/639) Failing theory datapoint methods now cause theory test failures
+### [Pull request #639:](https://github.com/junit-team/junit4/pull/639) Failing theory datapoint methods now cause theory test failures
 
 Previously `@DataPoint(s)` methods that threw exceptions were quietly ignored and if another `DataPoint` source was available then those values alone were used, leaving the theory passing using only a subset of the (presumably) intended input values. Now, any data point method failures during invocation of a theory will cause the theory being tested to fail immediately.
 
 *This is a non-backward-compatible change*, and could potentially break theory tests that depended on failing methods. If that was desired behavior, then the expected exceptions can instead be specifically ignored using the new `ignoredExceptions` array attribute on `@DataPoint` and `@DataPoints` methods. Adding an exception to this `ignoredExceptions` array will stop theory methods from failing if the given exception, or subclasses of it, are thrown in the annotated method. This attribute has no effect on data point fields.
 
 
-### [Pull request #658:](https://github.com/junit-team/junit/pull/658) `Iterable`s can now be used as data points
+### [Pull request #658:](https://github.com/junit-team/junit4/pull/658) `Iterable`s can now be used as data points
 
 Previously, when building sets of data points for theory parameters, the only valid multi-valued `@DataPoints` types were arrays. This has now been extended to also take parameters from `Iterable` `@DataPoints` methods and fields.
 
 
 # Categories
 
 
-### [Pull request #566:](https://github.com/junit-team/junit/pull/566) Enables inheritance on `Category` by adding `@Inherited`
+### [Pull request #566:](https://github.com/junit-team/junit4/pull/566) Enables inheritance on `Category` by adding `@Inherited`
 
 `@interface Category` now is annotated with `@Inherited` itself. This enables inheritance of categories from ancestors (e.g. abstract test-classes). Note that you are able to ""overwrite"" `@Category` on inheritors and that this has no effect on method-level categories (see [@Inherited](http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/annotation/Inherited.html)).
 
 
-### [Pull request #503:](https://github.com/junit-team/junit/pull/503) Configurable Categories
+### [Pull request #503:](https://github.com/junit-team/junit4/pull/503) Configurable Categories
 
 From a given set of test classes, the `Categories` runner runs only the classes and methods
 that are annotated with either the category given with the `@IncludeCategory` annotation, or a subtype of that category. Either classes or interfaces can be used as categories. Subtyping works, so if you say `@IncludeCategory(SuperClass.class)`, a test marked `@Category({SubClass.class})` will be run.
@@ -589,7 +589,7 @@ public class SlowTestSuiteWithoutFast {
 # Use with Maven
 
 
-### [Pull request #879:] (https://github.com/junit-team/junit/pull/879) Add the default 'Implementation-*' headers to the manifest
+### [Pull request #879:] (https://github.com/junit-team/junit4/pull/879) Add the default 'Implementation-*' headers to the manifest
 
 The default Maven-style 'Implementation-*' headers are now present in the manifest of `junit.jar`. Example:
 ```
@@ -600,7 +600,7 @@ Implementation-Vendor-Id: junit
 ```
 
 
-### [Pull request #511:](https://github.com/junit-team/junit/pull/511) Maven project junit:junit:jar
+### [Pull request #511:](https://github.com/junit-team/junit4/pull/511) Maven project junit:junit:jar
 
 
 #### How to install Maven
@@ -666,15 +666,15 @@ Follow this link for _IntelliJ IDEA_: [http://www.jetbrains.com/idea/webhelp/act
 # Miscellaneous
 
 
-### [Pull request #776:](https://github.com/junit-team/junit/pull/776) Add support for [Travis CI](http://travis-ci.org)
+### [Pull request #776:](https://github.com/junit-team/junit4/pull/776) Add support for [Travis CI](http://travis-ci.org)
 
 Travis CI is a free CI server for public Github repositories. Every pull request is run by Travis CI and Github's web interface shows the CI result for each pull request. Every user can use Travis CI for testing her branches, too.
 
-### [Pull request #921:](https://github.com/junit-team/junit/pull/921) Apply Google Code Style
+### [Pull request #921:](https://github.com/junit-team/junit4/pull/921) Apply Google Code Style
 
 JUnit is now using the well documented [Google Code Style](http://google-styleguide.googlecode.com/svn/trunk/javaguide.html)
 
-### [Pull request #939](https://github.com/junit-team/junit/pull/939) Renamed license file
+### [Pull request #939](https://github.com/junit-team/junit4/pull/939) Renamed license file
 
 While using JUnit in Android apps, if any other referenced library has a file named `LICENSE.txt`, the APK generation failed with the following error -
 
@@ -683,7 +683,7 @@ While using JUnit in Android apps, if any other referenced library has a file na
 To avoid this, the license file has been renamed to `LICENSE-junit.txt` 
 
 
-### [Pull request #962:](https://github.com/junit-team/junit/pull/962) Do not include thread start time in test timeout measurements.
+### [Pull request #962:](https://github.com/junit-team/junit4/pull/962) Do not include thread start time in test timeout measurements.
 
 The time it takes to start a thread can be surprisingly large.
 Especially in virtualized cloud environments where noisy neighbours.
@@ -700,31 +700,31 @@ The following section lists fixes to problems introduced in the first
 release candidates for JUnit 4.12. You can ignore this section if you are
 trying to understand the changes between 4.11 and 4.12.
 
-### [Pull request #961:](https://github.com/junit-team/junit/pull/961) Restore field names with f prefix.
+### [Pull request #961:](https://github.com/junit-team/junit4/pull/961) Restore field names with f prefix.
 
 In order to make the JUnit code more consistent with current coding practices, we changed
 a number of field names to not start with the prefix ""f"". Unfortunately, at least one IDE
 referenced a private field via reflection. This change reverts the field names for fields
 known to be read via reflection.
 
-### [Pull request #988:](https://github.com/junit-team/junit/pull/988) Revert ""Delete classes that are deprecated for six years.""
+### [Pull request #988:](https://github.com/junit-team/junit4/pull/988) Revert ""Delete classes that are deprecated for six years.""
 
-In [745ca05](https://github.com/junit-team/junit/commit/745ca05dccf5cc907e43a58142bb8be97da2b78f)
+In [745ca05](https://github.com/junit-team/junit4/commit/745ca05dccf5cc907e43a58142bb8be97da2b78f)
 we removed classes that were deprecated for many releases. There was some concern that people
 might not expect classes to be removed in a 4.x release. Even though we are not aware of any
 problems from the deletion, we decided to add them back.
 
 These classes may be removed in JUnit 5.0 or later.
 
-### [Pull request #989:](https://github.com/junit-team/junit/pull/989) Add JUnitSystem.exit() back.
+### [Pull request #989:](https://github.com/junit-team/junit4/pull/989) Add JUnitSystem.exit() back.
 
-In [917a88f](https://github.com/junit-team/junit/commit/917a88fad06ce108a596a8fdb4607b1a2fbb3f3e)
+In [917a88f](https://github.com/junit-team/junit4/commit/917a88fad06ce108a596a8fdb4607b1a2fbb3f3e)
 the exit() method in JUnit was removed. This caused problems for at least one user. Even
 though this class is in an internal package, we decided to add it back, and deprecated it.
 
 This method may be removed in JUnit 5.0 or later.
 
-### [Pull request #994:](https://github.com/junit-team/junit/pull/994) [Pull request #1000:](https://github.com/junit-team/junit/pull/1000) Ensure serialization compatibility where possible.
+### [Pull request #994:](https://github.com/junit-team/junit4/pull/994) [Pull request #1000:](https://github.com/junit-team/junit4/pull/1000) Ensure serialization compatibility where possible.
 
 JUnit 4.12 RC1 introduced serilization incompatibilities with some of the classes. For example,
 these pre-release versions of JUnit could not read instances of `Result` that were serialized
@@ -1,6 +1,6 @@
 ## Summary of changes in version 4.13 [unreleased!]
 
 We collect release notes in the wiki:
-https://github.com/junit-team/junit/wiki/4.13-release-notes
+https://github.com/junit-team/junit4/wiki/4.13-release-notes
 
 This file will be updated right before release.
@@ -49,7 +49,7 @@
             <name>JUnit contributors</name>
             <organization>JUnit</organization>
             <email>junit@yahoogroups.com</email>
-            <url>https://github.com/junit-team/junit/graphs/contributors</url>
+            <url>https://github.com/junit-team/junit4/graphs/contributors</url>
             <roles>
                 <role>developers</role>
             </roles>
@@ -71,19 +71,19 @@
     <scm>
         <connection>scm:git:git://github.com/junit-team/junit4.git</connection>
         <developerConnection>scm:git:git@github.com:junit-team/junit4.git</developerConnection>
-        <url>http://github.com/junit-team/junit/tree/master</url>
+        <url>http://github.com/junit-team/junit4/tree/master</url>
       <tag>HEAD</tag>
   </scm>
     <issueManagement>
         <system>github</system>
-        <url>https://github.com/junit-team/junit/issues</url>
+        <url>https://github.com/junit-team/junit4/issues</url>
     </issueManagement>
     <ciManagement>
         <system>jenkins</system>
         <url>https://junit.ci.cloudbees.com/</url>
     </ciManagement>
     <distributionManagement>
-        <downloadUrl>https://github.com/junit-team/junit/wiki/Download-and-Install</downloadUrl>
+        <downloadUrl>https://github.com/junit-team/junit4/wiki/Download-and-Install</downloadUrl>
         <snapshotRepository>
             <id>junit-snapshot-repo</id>
             <name>Nexus Snapshot Repository</name>
@@ -14,7 +14,7 @@
  * basically means ""don't run this test if these conditions don't apply"". The default JUnit runner skips tests with
  * failing assumptions. Custom runners may behave differently.
  * <p>
- *     A good example of using assumptions is in <a href=""https://github.com/junit-team/junit/wiki/Theories"">Theories</a> where they are needed to exclude certain datapoints that aren't suitable or allowed for a certain test case.
+ *     A good example of using assumptions is in <a href=""https://github.com/junit-team/junit4/wiki/Theories"">Theories</a> where they are needed to exclude certain datapoints that aren't suitable or allowed for a certain test case.
  * </p>
  * Failed assumptions are usually not logged, because there may be many tests that don't apply to certain
  * configurations.
@@ -29,7 +29,7 @@
  * </pre>
  * </p>
  *
- * @see <a href=""https://github.com/junit-team/junit/wiki/Theories"">Theories</a>
+ * @see <a href=""https://github.com/junit-team/junit4/wiki/Theories"">Theories</a>
  *
  * @since 4.4
  */
@@ -21,7 +21,7 @@ public class ComparisonFailure extends AssertionError {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private String fExpected;
     private String fActual;
@@ -35,7 +35,7 @@
  * If the exception's message or one of its properties should be verified, the
  * {@link org.junit.rules.ExpectedException ExpectedException} rule can be used. Further
  * information about exception testing can be found at the
- * <a href=""https://github.com/junit-team/junit/wiki/Exception-testing"">JUnit Wiki</a>.
+ * <a href=""https://github.com/junit-team/junit4/wiki/Exception-testing"">JUnit Wiki</a>.
  * <p>
  * The second optional parameter, <code>timeout</code>, causes a test to fail if it takes
  * longer than a specified amount of clock time (measured in milliseconds). The following test fails:
@@ -76,7 +76,7 @@
  * </pre>
  *
  * @version 4.12
- * @see <a href=""https://github.com/junit-team/junit/wiki/Categories"">Categories at JUnit wiki</a>
+ * @see <a href=""https://github.com/junit-team/junit4/wiki/Categories"">Categories at JUnit wiki</a>
  */
 public class Categories extends Suite {
 
@@ -64,7 +64,7 @@ private static MaxHistory readHistory(File storedResults)
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final Map<String, Long> fDurations = new HashMap<String, Long>();
     private final Map<String, Long> fFailureTimestamps = new HashMap<String, Long>();
@@ -17,7 +17,7 @@ public class ArrayComparisonFailure extends AssertionError {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final List<Integer> fIndices = new ArrayList<Integer>();
     private final String fMessage;
@@ -18,7 +18,7 @@ public class AssumptionViolatedException extends RuntimeException implements Sel
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final String fAssumption;
     private final boolean fValueMatcher;
@@ -10,7 +10,7 @@ public class ClassRequest extends Request {
     /*
      * We have to use the f prefix, because IntelliJ's JUnit4IdeaTestRunner uses
      * reflection to access this field. See
-     * https://github.com/junit-team/junit/issues/960
+     * https://github.com/junit-team/junit4/issues/960
      */
     private final Class<?> fTestClass;
     private final boolean canUseSuiteMethod;
@@ -14,7 +14,7 @@ public final class FilterRequest extends Request {
     /*
      * We have to use the f prefix, because IntelliJ's JUnit4IdeaTestRunner uses
      * reflection to access this field. See
-     * https://github.com/junit-team/junit/issues/960
+     * https://github.com/junit-team/junit4/issues/960
      */
     private final Filter fFilter;
 
@@ -15,7 +15,7 @@ public class InitializationError extends Exception {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final List<Throwable> fErrors;
 
@@ -139,7 +139,7 @@ public static Description createSuiteDescription(Class<?> testClass) {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final Collection<Description> fChildren = new ConcurrentLinkedQueue<Description>();
     private final String fDisplayName;
@@ -21,7 +21,7 @@ public class Failure implements Serializable {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final Description fDescription;
     private final Throwable fThrownException;
@@ -14,7 +14,7 @@ public class InitializationError extends Exception {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final List<Throwable> fErrors;
 
@@ -17,7 +17,7 @@ public class MultipleFailureException extends Exception {
     /*
      * We have to use the f prefix until the next major release to ensure
      * serialization compatibility. 
-     * See https://github.com/junit-team/junit/issues/976
+     * See https://github.com/junit-team/junit4/issues/976
      */
     private final List<Throwable> fErrors;
 
@@ -74,52 +74,52 @@
         <div class=""span4"" id=""welcome-section"">
           <p><b>Welcome</b></p>
           <ul>
-            <li><a href=""https://github.com/junit-team/junit/wiki/Download-and-Install"">Download and install</a></li>
-            <li><a href=""https://github.com/junit-team/junit/wiki/Getting-started"">Getting started</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki/Download-and-Install"">Download and install</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki/Getting-started"">Getting started</a></li>
             <li>Release Notes
               <ul>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.12.md"">4.12</a></li>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.11.md"">4.11</a></li>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.10.md"">4.10</a></li>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.9.1.md"">4.9.1</a></li>
-<li><a href=""https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.9.md"">4.9</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.12.md"">4.12</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.11.md"">4.11</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.10.md"">4.10</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.9.1.md"">4.9.1</a></li>
+<li><a href=""https://github.com/junit-team/junit4/blob/master/doc/ReleaseNotes4.9.md"">4.9</a></li>
               </ul>
             </li>
-            <li><a href=""https://github.com/junit-team/junit/wiki/Maintainer-documentation"">Maintainer Documentation</a></li>
-            <li><a href=""https://github.com/junit-team/junit/wiki/I-want-to-help%21"">I want to help!</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki/Maintainer-documentation"">Maintainer Documentation</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki/I-want-to-help%21"">I want to help!</a></li>
             <li><a href=""http://stackoverflow.com/questions/tagged/junit"">Latest JUnit Questions on StackOverflow</a></li>
             <li><a href=""javadoc/latest/index.html"">JavaDocs</a></li>
             <li><a href=""./faq.html"">Frequently asked questions</a></li>
-            <li><a href=""https://github.com/junit-team/junit/wiki"">Wiki</a></li>
+            <li><a href=""https://github.com/junit-team/junit4/wiki"">Wiki</a></li>
             <li><a href=""./license.html"">License</a></li>
           </ul>
         </div>
         <div class=""span4"" id=""concepts-section"">
           <p><b>Usage and Idioms</b></p>
           <ul>
-<li><a href=""https://github.com/junit-team/junit/wiki/Assertions"">Assertions</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Test-runners"">Test Runners</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Aggregating-tests-in-suites"">Aggregating tests in Suites</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Test-execution-order"">Test Execution Order</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Exception-testing"">Exception Testing</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Matchers-and-assertthat"">Matchers and assertThat</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Ignoring-tests"">Ignoring Tests</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Timeout-for-tests"">Timeout for Tests</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Parameterized-tests"">Parameterized Tests</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Assumptions-with-assume"">Assumptions with Assume</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Rules"">Rules</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Theories"">Theories</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Test-fixtures"">Test Fixtures</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Categories"">Categories</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Use-with-Maven"">Use with Maven</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Multithreaded-code-and-concurrency"">Multithreaded code and Concurrency</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Java-contract-test-helpers"">Java contract test helpers</a></li>
-<li><a href=""https://github.com/junit-team/junit/wiki/Continuous-testing"">Continuous Testing</a></li>          </ul>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Assertions"">Assertions</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Test-runners"">Test Runners</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites"">Aggregating tests in Suites</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Test-execution-order"">Test Execution Order</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Exception-testing"">Exception Testing</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Matchers-and-assertthat"">Matchers and assertThat</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Ignoring-tests"">Ignoring Tests</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Timeout-for-tests"">Timeout for Tests</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Parameterized-tests"">Parameterized Tests</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Assumptions-with-assume"">Assumptions with Assume</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Rules"">Rules</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Theories"">Theories</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Test-fixtures"">Test Fixtures</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Categories"">Categories</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Use-with-Maven"">Use with Maven</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Multithreaded-code-and-concurrency"">Multithreaded code and Concurrency</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Java-contract-test-helpers"">Java contract test helpers</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Continuous-testing"">Continuous Testing</a></li>          </ul>
         </div>
         <div class=""span4"" id=""thirdparty-section"">
           <p><b>Third-party extensions</b></p>
           <ul>
-<li><a href=""https://github.com/junit-team/junit/wiki/Custom-runners"">Custom Runners</a></li>
+<li><a href=""https://github.com/junit-team/junit4/wiki/Custom-runners"">Custom Runners</a></li>
 <li>
 <a href=""http://site.trajano.net/commons-testing/"">net.trajano.commons:commons-testing for UtilityClassTestUtil</a> per #646</li>
 <li>
@@ -252,7 +252,7 @@ public void throwsMore() {
         }
     }
 
-    //https://github.com/junit-team/junit/pull/583
+    //https://github.com/junit-team/junit4/pull/583
     public static class ExpectAssertionErrorWhichIsNotThrown {
         @Rule
         public ExpectedException thrown = none();
@@ -322,7 +322,7 @@ public void doNothing() {
      * then it should also be run.
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/589"">Issue #589</a> - 
+     * <a href=""https://github.com/junit-team/junit4/issues/589"">Issue #589</a> - 
      * Support @Rule for methods works only for TestRule but not for MethodRule
      */
     @Test
@@ -354,7 +354,7 @@ public void doNothing() {
      * then all the rules returned should be run.
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/589"">Issue #589</a> - 
+     * <a href=""https://github.com/junit-team/junit4/issues/589"">Issue #589</a> - 
      * Support @Rule for methods works only for TestRule but not for MethodRule
      */
     @Test
@@ -398,7 +398,7 @@ public void doNothing() {
      * then method should be called only once.
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/589"">Issue #589</a> - 
+     * <a href=""https://github.com/junit-team/junit4/issues/589"">Issue #589</a> - 
      * Support @Rule for methods works only for TestRule but not for MethodRule
      */
     @Test
@@ -76,7 +76,7 @@ static class NonPublicTestWithClassRule {
      * {@link TestRule}
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/1019"">Issue #1019</a>
+     * <a href=""https://github.com/junit-team/junit4/issues/1019"">Issue #1019</a>
      */
     @Test
     public void rejectClassRuleThatIsImplemetationOfMethodRule() {
@@ -100,7 +100,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
      * implementation of {@link TestRule}
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/1019"">Issue #1019</a>
+     * <a href=""https://github.com/junit-team/junit4/issues/1019"">Issue #1019</a>
      */
     @Test
     public void rejectClassRuleThatReturnsImplementationOfMethodRule() {
@@ -126,7 +126,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
      * {@link TestRule}
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/1019"">Issue #1019</a>
+     * <a href=""https://github.com/junit-team/junit4/issues/1019"">Issue #1019</a>
      */
     @Test
     public void rejectClassRuleIsAnArbitraryObject() throws Exception {
@@ -145,7 +145,7 @@ public static class TestWithClassRuleIsAnArbitraryObject {
      * implementation of {@link TestRule}
      * 
      * <p>This case has been added with 
-     * <a href=""https://github.com/junit-team/junit/issues/1019"">Issue #1019</a> 
+     * <a href=""https://github.com/junit-team/junit4/issues/1019"">Issue #1019</a> 
      */
     @Test
     public void rejectClassRuleMethodReturnsAnArbitraryObject() throws Exception {
",True,"The commit message refers to the necessity of the change by mentioning that the links to the repository have been renamed, which is a common practice to reflect changes in the project's structure. This change is necessary to ensure that the links continue to work and provide accurate information to the users.",True,"The commit message 'Adapt links to reflect repo rename' does not explicitly describe the necessity of the changes. However, it is clear from the context that the repository has been renamed, and the links in the README and other files need to be updated to reflect this. This is a common and necessary change that does not require a detailed explanation in the commit message.",True,"The commit message 'Adapt links to reflect repo rename' does not directly elaborate the necessity of changes by describing the error scenario, mentioning the issue report, or the shortcoming of the previous implementation. However, the diff provided shows that the links in the README and other files have been updated to reflect the new repository name. This suggests that the change was made to fix broken links due to the repository rename, which is a clear motivation for the code change.",True,"The commit message 'Adapt links to reflect repo rename' indicates that the changes were made to reflect the new name of the repository, which suggests a requirement for software development to maintain up-to-date documentation or resources.",True,"The commit message 'Adapt links to reflect repo rename' directly mentions the change made to the codebase, which is the renaming of the repository from 'junit' to 'junit4'. This change was necessary to reflect the actual name of the repository and to avoid any confusion or errors that could arise from the old repository name.",True,The commit message 'Adapt links to reflect repo rename' describes the changes made in the code diff by summarizing the main modification: updating the repository name in the links and URLs to reflect the new name of the repository.,False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on the renaming of the repository and updating links, which do not directly relate to the underlying technical changes.",True,"The commit message 'Adapt links to reflect repo rename' does describe a change in the code diff, which is the modification of links in the README and other files to reflect the new repository name. This change is functional and does not introduce new behaviors, but it does describe the purpose of the changes made in the code diff.",True,"The commit message 'Adapt links to reflect repo rename' clearly explains the reason for the change, which is the renaming of the repository. The diff shows that all the links in the README and other files have been updated to reflect the new repository name. This change was necessary to ensure that all the links continue to work after the repository was renamed."
https://github.com/junit-team/junit4/commit/bcf2c17851197328bb7bc008f916a6648de193aa,Converted tabs to spaces  <enter> Converted tabs to spaces for newly added code to be in line with guidelines. ,https://api.github.com/repos/junit-team/junit4/commits/bcf2c17851197328bb7bc008f916a6648de193aa,"@@ -119,8 +119,8 @@ public ExpectedException handleAssumptionViolatedExceptions() {
      * @return self
      */
     public ExpectedException reportMissingExceptionWithMessage(String providedMessage) {
-    	missingExceptionMessage = providedMessage;
-    	return this;
+        missingExceptionMessage = providedMessage;
+        return this;
     }
 
     public Statement apply(Statement base,
@@ -193,14 +193,14 @@ public void evaluate() throws Throwable {
     }
 
     private void failDueToMissingException() throws AssertionError {
-    	String failureMessage;
-    	
-    	if ( isMissingExceptionMessageEmpty() ) {
-    		String expectation = StringDescription.toString(fMatcherBuilder.build());
-    		failureMessage = ""Expected test to throw "" + expectation;
-    	} else {
-    		failureMessage = missingExceptionMessage;
-    	}
+        String failureMessage;
+        
+        if ( isMissingExceptionMessageEmpty() ) {
+            String expectation = StringDescription.toString(fMatcherBuilder.build());
+            failureMessage = ""Expected test to throw "" + expectation;
+        } else {
+            failureMessage = missingExceptionMessage;
+        }
 
         fail(failureMessage);
     }
@@ -223,6 +223,6 @@ private void handleException(Throwable e) throws Throwable {
     }
     
     private boolean isMissingExceptionMessageEmpty() {
-    	return missingExceptionMessage == null || missingExceptionMessage.isEmpty();
+        return missingExceptionMessage == null || missingExceptionMessage.isEmpty();
     }
 }
",True,"The commit message refers to a convention or guideline regarding the formatting of code. It mentions that the change is made to be in line with guidelines, which implies that there is a standard or convention that the code should adhere to. In this case, the guideline is to use spaces instead of tabs for indentation.",True,"The commit message 'Converted tabs to spaces' does not explicitly state the necessity of the change. However, it is common sense and easy to infer that the change was made to align with the project's coding guidelines, which often specify the use of spaces instead of tabs for indentation.",False,"The commit message does not directly elaborate the motivation of the code change. It only mentions that the change was made to be in line with guidelines, but it does not describe any error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message 'Converted tabs to spaces for newly added code to be in line with guidelines' indicates that the change was made to comply with the project's coding standards or guidelines. This can be considered a requirement source as it is a change made to maintain consistency and adhere to the project's standards, which can improve the maintainability and readability of the code.",False,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only mentions that the change was made to convert tabs to spaces to be in line with guidelines. The code diff shows that the change is a formatting change, not a functional change.",True,"The commit message 'Converted tabs to spaces' does not directly describe the changes made in the code diff. However, it does indicate a significant change in the codebase, which is the conversion of tabs to spaces. While it doesn't explicitly list or contrast the changes, it does provide a summary of the key component of the change, which is the formatting of the code.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions the conversion of tabs to spaces to align with guidelines, which is a stylistic change and does not necessarily involve a deeper technical principle.",False,"The commit message does not describe the functional changes made to the code. It only mentions the conversion of tabs to spaces, which is a formatting change and does not introduce any new behaviors or functionalities.",False,"The commit message does not lack an explanation. Although the change is small and simple, the message explicitly states the reason for the commit: 'Converted tabs to spaces for newly added code to be in line with guidelines.' This provides a clear explanation for the change, which is not easily inferred from the code diff."
https://github.com/spring-projects/spring-boot/commit/abd7bc0466722b2a6e2b145a630fdb342a7f1656,Add OAuth2 resource server sample  <enter> Shows how to use @EnableResourceServer in a pure resource server and configure the secure paths. ,https://api.github.com/repos/spring-projects/spring-boot/commits/abd7bc0466722b2a6e2b145a630fdb342a7f1656,"@@ -0,0 +1,57 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.security.oauth2.authserver;
+
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+/**
+ * @author Dave Syer
+ */
+@ConfigurationProperties(""security.oauth2.authorization"")
+public class AuthorizationServerProperties {
+
+	private String checkTokenAccess;
+
+	private String tokenKeyAccess;
+
+	private String realm;
+
+	public String getCheckTokenAccess() {
+		return this.checkTokenAccess;
+	}
+
+	public void setCheckTokenAccess(String checkTokenAccess) {
+		this.checkTokenAccess = checkTokenAccess;
+	}
+
+	public String getTokenKeyAccess() {
+		return this.tokenKeyAccess;
+	}
+
+	public void setTokenKeyAccess(String tokenKeyAccess) {
+		this.tokenKeyAccess = tokenKeyAccess;
+	}
+
+	public String getRealm() {
+		return this.realm;
+	}
+
+	public void setRealm(String realm) {
+		this.realm = realm;
+	}
+
+}
@@ -24,7 +24,6 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -44,6 +43,7 @@
 import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerEndpointsConfiguration;
 import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
 import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
+import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
 import org.springframework.security.oauth2.provider.client.BaseClientDetails;
 import org.springframework.security.oauth2.provider.token.TokenStore;
 
@@ -60,7 +60,7 @@
 @ConditionalOnClass(EnableAuthorizationServer.class)
 @ConditionalOnMissingBean(AuthorizationServerConfigurer.class)
 @ConditionalOnBean(AuthorizationServerEndpointsConfiguration.class)
-@EnableConfigurationProperties
+@EnableConfigurationProperties(AuthorizationServerProperties.class)
 public class OAuth2AuthorizationServerConfiguration
 		extends AuthorizationServerConfigurerAdapter {
 
@@ -76,6 +76,9 @@ public class OAuth2AuthorizationServerConfiguration
 	@Autowired(required = false)
 	private TokenStore tokenStore;
 
+	@Autowired
+	private AuthorizationServerProperties properties;
+
 	@Override
 	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
 		ClientDetailsServiceBuilder<InMemoryClientDetailsServiceBuilder>.ClientBuilder builder = clients
@@ -105,6 +108,20 @@ public void configure(AuthorizationServerEndpointsConfigurer endpoints)
 		}
 	}
 
+	@Override
+	public void configure(AuthorizationServerSecurityConfigurer security)
+			throws Exception {
+		if (this.properties.getCheckTokenAccess() != null) {
+			security.checkTokenAccess(this.properties.getCheckTokenAccess());
+		}
+		if (this.properties.getTokenKeyAccess() != null) {
+			security.tokenKeyAccess(this.properties.getTokenKeyAccess());
+		}
+		if (this.properties.getRealm() != null) {
+			security.realm(this.properties.getRealm());
+		}
+	}
+
 	@Configuration
 	protected static class ClientDetailsLogger {
 
@@ -0,0 +1,56 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<!-- Your own application should inherit from spring-boot-starter-parent -->
+		<groupId>org.springframework.boot</groupId>
+		<artifactId>spring-boot-samples</artifactId>
+		<version>1.3.0.BUILD-SNAPSHOT</version>
+	</parent>
+	<artifactId>spring-boot-sample-secure-oauth2-resource</artifactId>
+	<name>spring-boot-sample-secure-oauth2-resource</name>
+	<description>Spring Boot Security OAuth2 Sample</description>
+	<url>http://projects.spring.io/spring-boot/</url>
+	<organization>
+		<name>Pivotal Software, Inc.</name>
+		<url>http://www.spring.io</url>
+	</organization>
+	<properties>
+		<main.basedir>${basedir}/../..</main.basedir>
+	</properties>
+	<dependencies>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-security</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-data-jpa</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-data-rest</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>com.h2database</groupId>
+			<artifactId>h2</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.security.oauth</groupId>
+			<artifactId>spring-security-oauth2</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-test</artifactId>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
+	<build>
+		<plugins>
+			<plugin>
+				<groupId>org.springframework.boot</groupId>
+				<artifactId>spring-boot-maven-plugin</artifactId>
+			</plugin>
+		</plugins>
+	</build>
+</project>
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package sample.secure.oauth2;
+
+import java.util.Date;
+
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.GenerationType;
+import javax.persistence.Id;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+
+/**
+ * Domain object for tracking flights
+ *
+ * @author Craig Walls
+ * @author Greg Turnquist
+ */
+@Entity
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class Flight {
+
+	@Id
+	@GeneratedValue(strategy = GenerationType.AUTO)
+	private Long id;
+
+	private String origin;
+
+	private String destination;
+
+	private String airline;
+
+	private String flightNumber;
+
+	private Date date;
+
+	private String traveler;
+
+	public Long getId() {
+		return this.id;
+	}
+
+	public void setId(Long id) {
+		this.id = id;
+	}
+
+	public String getOrigin() {
+		return this.origin;
+	}
+
+	public void setOrigin(String origin) {
+		this.origin = origin;
+	}
+
+	public String getDestination() {
+		return this.destination;
+	}
+
+	public void setDestination(String destination) {
+		this.destination = destination;
+	}
+
+	public String getAirline() {
+		return this.airline;
+	}
+
+	public void setAirline(String airline) {
+		this.airline = airline;
+	}
+
+	public String getFlightNumber() {
+		return this.flightNumber;
+	}
+
+	public void setFlightNumber(String flightNumber) {
+		this.flightNumber = flightNumber;
+	}
+
+	public Date getDate() {
+		return this.date;
+	}
+
+	public void setDate(Date date) {
+		this.date = date;
+	}
+
+	public String getTraveler() {
+		return this.traveler;
+	}
+
+	public void setTraveler(String traveler) {
+		this.traveler = traveler;
+	}
+
+}
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package sample.secure.oauth2;
+
+import org.springframework.data.repository.CrudRepository;
+
+/**
+ * Spring Data interface with secured methods
+ *
+ * @author Craig Walls
+ * @author Greg Turnquist
+ */
+public interface FlightRepository extends CrudRepository<Flight, Long> {
+
+	@Override
+	Iterable<Flight> findAll();
+
+	@Override
+	Flight findOne(Long aLong);
+
+	@Override
+	<S extends Flight> S save(S entity);
+
+}
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package sample.secure.oauth2;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.autoconfigure.SpringBootApplication;
+import org.springframework.security.config.annotation.web.builders.HttpSecurity;
+import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
+import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
+
+@SpringBootApplication
+@EnableResourceServer
+public class SampleSecureOAuth2ResourceApplication extends ResourceServerConfigurerAdapter {
+	
+	@Override
+	public void configure(HttpSecurity http) throws Exception {
+		http.antMatcher(""/flights/**"").authorizeRequests().anyRequest().authenticated();
+	}
+
+	public static void main(String[] args) {
+		SpringApplication.run(SampleSecureOAuth2ResourceApplication.class, args);
+	}
+
+}
@@ -0,0 +1,6 @@
+server.port=8081
+spring.datasource.platform=h2
+security.basic.enabled=false
+security.oauth2.resource.id=service
+security.oauth2.resource.userInfoUri=http://localhost:8080/user
+logging.level.org.springframework.security=DEBUG
@@ -0,0 +1,4 @@
+insert into FLIGHT
+(id, origin, destination, airline, flight_number, traveler)
+values
+(1, 'Nashville', 'Dallas', 'Spring Ways', 'OAUTH2', 'Greg Turnquist');
@@ -0,0 +1,65 @@
+package sample.secure.oauth2;
+
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+import static org.springframework.test.web.servlet.setup.MockMvcBuilders.webAppContextSetup;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.SpringApplicationConfiguration;
+import org.springframework.boot.test.WebIntegrationTest;
+import org.springframework.hateoas.MediaTypes;
+import org.springframework.security.core.context.SecurityContextHolder;
+import org.springframework.security.web.FilterChainProxy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+import org.springframework.test.web.servlet.MockMvc;
+import org.springframework.web.context.WebApplicationContext;
+
+/**
+ * Series of automated integration tests to verify proper behavior of auto-configured,
+ * OAuth2-secured system
+ *
+ * @author Greg Turnquist
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@SpringApplicationConfiguration(SampleSecureOAuth2ResourceApplication.class)
+@WebIntegrationTest(randomPort = true)
+public class SampleSecureOAuth2ResourceApplicationTests {
+
+	@Autowired
+	WebApplicationContext context;
+
+	@Autowired
+	FilterChainProxy filterChain;
+
+	private MockMvc mvc;
+	@Before
+	public void setUp() {
+		this.mvc = webAppContextSetup(this.context).addFilters(this.filterChain).build();
+		SecurityContextHolder.clearContext();
+	}
+
+	@Test
+	public void homePageAvailable() throws Exception {
+		this.mvc.perform(get(""/"").accept(MediaTypes.HAL_JSON))
+				.andExpect(status().isOk()).andDo(print());
+	}
+
+	@Test
+	public void flightsSecuredByDefault() throws Exception {
+		this.mvc.perform(get(""/flights"").accept(MediaTypes.HAL_JSON))
+				.andExpect(status().isUnauthorized()).andDo(print());
+		this.mvc.perform(get(""/flights/1"").accept(MediaTypes.HAL_JSON))
+				.andExpect(status().isUnauthorized()).andDo(print());
+	}
+
+	@Test
+	public void profileAvailable() throws Exception {
+		this.mvc.perform(get(""/profile"").accept(MediaTypes.HAL_JSON))
+				.andExpect(status().isOk()).andDo(print());
+	}
+
+}
@@ -15,11 +15,15 @@
  */
 package sample.secure.oauth2;
 
+import java.security.Principal;
+
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.SpringBootApplication;
 import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
 import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
 import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RestController;
 
 /**
  * After you launch the app, you can seek a bearer token like this:
@@ -92,7 +96,13 @@
 @EnableAuthorizationServer
 @EnableResourceServer
 @EnableGlobalMethodSecurity(prePostEnabled = true)
+@RestController
 public class SampleSecureOAuth2Application {
+	
+	@RequestMapping(""/user"")
+	public Principal user(Principal user) {
+		return user;
+	}
 
 	public static void main(String[] args) {
 		SpringApplication.run(SampleSecureOAuth2Application.class, args);
@@ -4,5 +4,6 @@ security.user.name=greg
 security.user.password=turnquist
 security.oauth2.client.client-id=foo
 security.oauth2.client.client-secret=bar
+security.oauth2.authorization.checkTokenAccess=isAuthenticated()
 
 logging.level.org.springframework.security=DEBUG
",True,"The commit message 'Add OAuth2 resource server sample' refers to the addition of a new feature, which is the implementation of an OAuth2 resource server. The code diff shows the addition of a new class 'AuthorizationServerProperties' and modifications to 'OAuth2AuthorizationServerConfiguration' to configure the checkTokenAccess, tokenKeyAccess, and realm properties. These properties are used to secure the authorization server endpoints, which is a common practice in OAuth2 implementations. Therefore, the commit message expresses the necessity of changes by referencing a convention or standard (OAuth2) and the implemented feature (an OAuth2 resource server).",True,"The commit message 'Add OAuth2 resource server sample' does not explicitly state the reason for the changes, but the code diff shows that it adds a new resource server configuration and a new class for authorization server properties. This suggests that the changes are related to adding OAuth2 security to the application, which is a common reason for adding these types of configurations and classes.",True,"The commit message 'Add OAuth2 resource server sample' does not explicitly describe the necessity of changes, but the code diff shows that it adds a new configuration class 'AuthorizationServerProperties' and modifies 'OAuth2AuthorizationServerConfiguration' to use this new class. This suggests that the changes are related to adding or modifying OAuth2 resource server functionality, which could imply the need to enhance security or fix a bug related to OAuth2 token access.",True,"The commit message 'Add OAuth2 resource server sample' indicates that the developer is adding a new feature to the project. The code diff shows that a new class 'AuthorizationServerProperties' has been added, which suggests that the change is related to configuring OAuth2 authorization. Additionally, the diff shows that the 'configure' method of the 'OAuth2AuthorizationServerConfiguration' class has been modified to include configuration for checkTokenAccess, tokenKeyAccess, and realm, which are all related to OAuth2 security. Therefore, the commit message and the code diff both suggest that the changes are being made to implement OAuth2 security in the project, which is a requirement for the software development.",True,"The commit message 'Add OAuth2 resource server sample' indicates that the change is adding a new feature, and the code diff shows that it's configuring an OAuth2 resource server. Additionally, the code diff shows that the commit introduces a new class 'AuthorizationServerProperties' and modifies the 'OAuth2AuthorizationServerConfiguration' class to use this new class. This suggests that the change is related to configuring the OAuth2 authorization server, which is a common use case for this class. The modified 'configure' method in 'OAuth2AuthorizationServerConfiguration' class also sets the checkTokenAccess, tokenKeyAccess, and realm properties based on the values provided in the 'AuthorizationServerProperties' class. This indicates that the change is improving the security of the resource server by adding additional configuration options for token access and realm.",True,"The commit message 'Add OAuth2 resource server sample' summarizes the addition of a new OAuth2 resource server. The code diff shows the creation of a new Java class 'AuthorizationServerProperties' and modifications to 'OAuth2AuthorizationServerConfiguration' and 'SampleSecureOAuth2ResourceApplication' classes. These changes are related to configuring the OAuth2 authorization server and resource server, which aligns with the commit message.",True,"The commit message 'Add OAuth2 resource server sample' describes the addition of a new feature, which is the implementation of an OAuth2 resource server. The code diff shows the creation of a new class 'AuthorizationServerProperties' and the modification of 'OAuth2AuthorizationServerConfiguration' to use this new class. This modification allows for the configuration of the secure paths, as mentioned in the commit message. The changes in 'OAuth2AuthorizationServerConfiguration' specifically set the checkTokenAccess, tokenKeyAccess, and realm properties, which are related to the security configuration of the OAuth2 resource server.",True,"The commit message 'Add OAuth2 resource server sample' describes the addition of a new feature, which is a resource server that uses OAuth2 for authentication. The code changes introduce a new class 'AuthorizationServerProperties' and modify the 'OAuth2AuthorizationServerConfiguration' class to use this new property class. This change allows for the configuration of the secure paths for checking tokens and token keys, as well as the realm. This is a clear description of the new behavior introduced by the code changes.",False,The commit message does not lack an explanation. It clearly states that the commit is adding an OAuth2 resource server sample and explains how it uses '@EnableResourceServer' to configure the secure paths.
https://github.com/spring-projects/spring-boot/commit/8e8bf8e1779ffcef2ec35c6921b6b596c0c8353a,Uses the latest version of Tomcat 7 in the sample ,https://api.github.com/repos/spring-projects/spring-boot/commits/8e8bf8e1779ffcef2ec35c6921b6b596c0c8353a,"@@ -19,7 +19,7 @@
 	<properties>
 		<main.basedir>${basedir}/../..</main.basedir>
 		<m2eclipse.wtp.contextRoot>/</m2eclipse.wtp.contextRoot>
-		<tomcat.version>7.0.56</tomcat.version>
+		<tomcat.version>7.0.57</tomcat.version>
 		<java.version>1.7</java.version>
 	</properties>
 	<dependencies>
",True,"The commit message 'Uses the latest version of Tomcat 7 in the sample' does refer to an improvement in prior commits. It explains that the change is to update the version of Tomcat from 7.0.56 to 7.0.57, which implies that the newer version is an improvement over the previous one. This could be due to bug fixes, new features, or security updates in the newer version.",True,"The commit message 'Uses the latest version of Tomcat 7 in the sample' clearly states the reason for the change, which is to update the version of Tomcat to the latest stable release. This is a common practice to ensure the use of the most recent version for security updates, bug fixes, and new features. The code diff also supports this explanation by showing the change in the Tomcat version number.",True,"The commit message 'Uses the latest version of Tomcat 7 in the sample' does describe the necessity of changes. It mentions that the change is to use the latest version of Tomcat 7, which could potentially fix bugs or add new features that were not present in the previous version. This is a common motivation for updating dependencies in a project.",True,"The commit message 'Uses the latest version of Tomcat 7 in the sample' indicates that the developer is updating the version of Tomcat to the latest stable release. This is likely due to a requirement for software development to keep the sample project up-to-date and functioning correctly with the latest version of Tomcat. This could potentially address problems in the process of software maintenance, such as out-of-date code that may no longer be supported or may have security vulnerabilities.",True,"The commit message 'Uses the latest version of Tomcat 7 in the sample' directly mentions the improvement it makes to the code, which is updating the Tomcat version from 7.0.56 to 7.0.57. This change is likely to fix any bugs or issues present in the older version of Tomcat.",True,"The commit message 'Uses the latest version of Tomcat 7 in the sample' accurately summarizes the change in the code diff. It clearly points out the key component of the change, which is the update of the Tomcat version from 7.0.56 to 7.0.57. This is a direct reflection of the change in the code diff.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that the version of Tomcat 7 is being updated from 7.0.56 to 7.0.57. However, the technical principle could be 'keeping dependencies up-to-date' or 'using the latest stable version' but these are not explicitly stated in the commit message.",True,"The commit message 'Uses the latest version of Tomcat 7 in the sample' accurately summarizes the code change by explaining that the version of Tomcat used in the sample has been updated from 7.0.56 to 7.0.57. This change does not introduce any new behaviors or functionalities, but it does update the version of a dependency, which could potentially fix bugs or add new features from the updated version.",True,"The commit message 'Uses the latest version of Tomcat 7 in the sample' clearly explains the reason for the change, which is to update the Tomcat version from 7.0.56 to 7.0.57. Although the change is small and simple, it's still beneficial to have a clear explanation in the commit message for better understanding and traceability."
https://github.com/square/retrofit/commit/6108179c09dae0ccdd7e8d97d4a3b79f9f4443a4,"Use custom exception type when triggering mock failure.  <enter> Since we omit the stack trace, this more clearly indicates the source being from Retrofit's mock behavior. ",https://api.github.com/repos/square/retrofit/commits/6108179c09dae0ccdd7e8d97d4a3b79f9f4443a4,"@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+
+final class MockRetrofitIOException extends IOException {
+  MockRetrofitIOException() {
+    super(""Failure triggered by MockRetrofit's NetworkBehavior"");
+  }
+}
@@ -76,7 +76,7 @@ public static NetworkBehavior create(Random random) {
   private NetworkBehavior(Random random) {
     this.random = random;
 
-    failureException = new IOException(""Mock failure!"");
+    failureException = new MockRetrofitIOException();
     failureException.setStackTrace(new StackTraceElement[0]);
   }
 
@@ -33,7 +33,8 @@ public final class NetworkBehaviorTest {
 
   @Test public void defaultThrowable() {
     Throwable t = behavior.failureException();
-    assertThat(t).isExactlyInstanceOf(IOException.class).hasMessage(""Mock failure!"");
+    assertThat(t).isInstanceOf(IOException.class)
+        .isExactlyInstanceOf(MockRetrofitIOException.class);
     assertThat(t.getStackTrace()).isEmpty();
   }
 
",True,"The commit message refers to a convention regarding the use of exceptions. It mentions that the stack trace is omitted, which is not a common practice for exceptions. This is done to more clearly indicate that the source of the exception is from Retrofit's mock behavior. The code diff also supports this explanation by introducing a new custom exception type, MockRetrofitIOException, which is used instead of the standard IOException. This change improves the clarity and specificity of the exception, making it easier to identify the source of the error.",True,"The commit message explains the necessity of the changes by stating that using a custom exception type when triggering mock failure more clearly indicates the source being from Retrofit's mock behavior. This is because the stack trace is omitted, which makes it easier to identify the source of the error. The code diff also supports this explanation by adding a new custom exception type, MockRetrofitIOException, and using it in the NetworkBehavior class.",True,"The commit message explains the motivation for the code change by mentioning that the previous implementation omitted the stack trace, which could lead to confusion about the source of the error. The new implementation uses a custom exception type that more clearly indicates the source of the error as being from Retrofit's mock behavior.",True,"The commit message 'Use custom exception type when triggering mock failure' indicates that the change was made to improve the clarity of the source of errors. The message 'Since we omit the stack trace, this more clearly indicates the source being from Retrofit's mock behavior' further suggests that the change was made to better differentiate between errors originating from the mock environment and other errors. This implies a need for software development to meet the requirements of users or to improve the process of software maintenance, specifically addressing the issue of out-of-date code or runtime environment changes.",True,"The commit message 'Use custom exception type when triggering mock failure' directly mentions the improvement it makes to the code, which is the use of a custom exception type to more clearly indicate the source of the failure being from Retrofit's mock behavior. This change is also reflected in the code diff, where the IOException is replaced with a custom exception type MockRetrofitIOException.",True,"The commit message 'Use custom exception type when triggering mock failure' accurately summarizes the key component of the change, which is the replacement of the IOException with a custom exception type, MockRetrofitIOException. This change is clearly mentioned in the commit message and is also reflected in the diff. Additionally, the commit message explains the reason for the change, which is to more clearly indicate the source of the exception being from Retrofit's mock behavior.",True,"The commit message explains that the change is to use a custom exception type (MockRetrofitIOException) when triggering mock failure. This is a technical principle that highlights the use of custom exceptions to provide more specific and meaningful error messages, which can improve debugging and troubleshooting.",True,"The commit message 'Use custom exception type when triggering mock failure' accurately describes the code changes. The changes introduce a new custom exception type 'MockRetrofitIOException' which is used when triggering mock failures. This new exception type is used instead of the previous 'IOException' and it omits the stack trace, which more clearly indicates that the source of the failure is from Retrofit's mock behavior. The test code also verifies that the new exception type is being used correctly.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Use custom exception type when triggering mock failure. Since we omit the stack trace, this more clearly indicates the source being from Retrofit's mock behavior.' This is a meaningful explanation that adds context to the code change, even though the change itself is relatively small and simple."
https://github.com/square/retrofit/commit/49bba7d60f2a920e138e9388c515ee58fc8c4bcf,Rewrite RxJava call adapter tests to be more understandable. ,https://api.github.com/repos/square/retrofit/commits/49bba7d60f2a920e138e9388c515ee58fc8c4bcf,"@@ -39,5 +39,10 @@
       <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
@@ -17,124 +17,139 @@
 
 import com.google.gson.reflect.TypeToken;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.List;
+import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import retrofit.converter.Converter;
+import retrofit.http.GET;
 import rx.Observable;
+import rx.observables.BlockingObservable;
 
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ObservableCallAdapterFactoryTest {
-  private final ObservableCallAdapterFactory factory = ObservableCallAdapterFactory.create();
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  interface Service {
+    @GET(""/"") Observable<String> body();
+    @GET(""/"") Observable<Response<String>> response();
+    @GET(""/"") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    RestAdapter ra = new RestAdapter.Builder()
+        .endpoint(server.getUrl(""/"").toString())
+        .converter(new StringConverter())
+        .addCallAdapterFactory(ObservableCallAdapterFactory.create())
+        .build();
+    service = ra.create(Service.class);
+  }
 
   @Test public void bodySuccess200() {
-    Type type = new TypeToken<Observable<String>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    Observable<String> observable = (Observable<String>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.success(Response.fromBody(""Hi""));
-      }
-    });
-    String body = observable.toBlocking().first();
-    assertThat(body).isEqualTo(""Hi"");
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    assertThat(o.first()).isEqualTo(""Hi"");
   }
 
   @Test public void bodySuccess404() {
-    Type type = new TypeToken<Observable<String>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    Observable<String> observable = (Observable<String>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.success(
-            Response.fromError(404, ResponseBody.create(MediaType.parse(""application/json""), ""Hi"")));
-      }
-    });
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingObservable<String> o = service.body().toBlocking();
     try {
-      observable.toBlocking().first();
+      o.first();
       fail();
     } catch (RuntimeException e) {
       // TODO assert on some indicator of 404.
     }
   }
 
   @Test public void bodyFailure() {
-    Type type = new TypeToken<Observable<String>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Throwable throwable = new IOException();
-    Observable<String> observable = (Observable<String>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.failure(throwable);
-      }
-    });
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<String> o = service.body().toBlocking();
     try {
-      observable.toBlocking().first();
+      o.first();
       fail();
     } catch (RuntimeException e) {
-      assertThat(e.getCause()).isSameAs(throwable);
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
   }
 
-  @Test public void responseSuccess() {
-    Type type = new TypeToken<Observable<Response<String>>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Response<Object> response = Response.fromBody(""Hi"");
-    Observable<Response<String>> observable = (Observable<Response<String>>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.success(response);
-      }
-    });
-    Response<String> body = observable.toBlocking().first();
-    assertThat(body).isSameAs(response);
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo(""Hi"");
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
   }
 
   @Test public void responseFailure() {
-    Type type = new TypeToken<Observable<Response<String>>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Throwable throwable = new IOException();
-    Observable<Response<String>> observable = (Observable<Response<String>>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.failure(throwable);
-      }
-    });
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
     try {
-      observable.toBlocking().first();
+      o.first();
       fail();
     } catch (RuntimeException t) {
-      assertThat(t.getCause()).isSameAs(throwable);
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
     }
   }
 
-  @Test public void resultSuccess() {
-    Type type = new TypeToken<Observable<Result<String>>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Response<Object> response = Response.fromBody(""Hi"");
-    Observable<Result<String>> observable = (Observable<Result<String>>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.success(response);
-      }
-    });
-    Result<String> result = observable.toBlocking().first();
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody(""Hi""));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo(""Hi"");
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
-    assertThat(result.response()).isSameAs(response);
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo(""Hi"");
   }
 
   @Test public void resultFailure() {
-    Type type = new TypeToken<Observable<Result<String>>>() {}.getType();
-    CallAdapter adapter = factory.get(type);
-    final Throwable throwable = new IOException();
-    Observable<Result<String>> observable = (Observable<Result<String>>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<Object> callback) {
-        callback.failure(throwable);
-      }
-    });
-    Result<String> result = observable.toBlocking().first();
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
     assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isSameAs(throwable);
+    assertThat(result.error()).isInstanceOf(IOException.class);
   }
 
   @Test public void responseType() {
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     Type classType = new TypeToken<Observable<String>>() {}.getType();
     assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
     Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
@@ -150,6 +165,7 @@ public final class ObservableCallAdapterFactoryTest {
 
   @Test public void rawTypeThrows() {
     Type type = new TypeToken<Observable>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
       factory.get(type);
       fail();
@@ -160,6 +176,7 @@ public final class ObservableCallAdapterFactoryTest {
 
   @Test public void rawResponseTypeThrows() {
     Type type = new TypeToken<Observable<Response>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
       factory.get(type);
       fail();
@@ -170,6 +187,7 @@ public final class ObservableCallAdapterFactoryTest {
 
   @Test public void rawResultTypeThrows() {
     Type type = new TypeToken<Observable<Result>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
       factory.get(type);
       fail();
@@ -178,20 +196,13 @@ public final class ObservableCallAdapterFactoryTest {
     }
   }
 
-  static abstract class EmptyCall implements Call<Object> {
-    @Override public Response<Object> execute() throws IOException {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public void cancel() {
+  static class StringConverter implements Converter {
+    @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+      return body.string();
     }
 
-    @Override public Call<Object> clone() {
-      try {
-        return (Call<Object>) super.clone();
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
+    @Override public RequestBody toBody(Object object, Type type) {
+      return RequestBody.create(MediaType.parse(""text/plain""), String.valueOf(type));
     }
   }
 }
",True,"The commit message 'Rewrite RxJava call adapter tests to be more understandable' refers to the necessity of changes by mentioning that the tests are being rewritten to be more understandable. This could be due to the complexity of the existing tests, which are using RxJava, a library for composing asynchronous and event-based programs using observable sequences. The changes in the code diff, such as adding new dependencies and restructuring the test class, could be an improvement to make the tests more understandable and maintainable.",True,"The commit message 'Rewrite RxJava call adapter tests to be more understandable' describes the necessity of changes without explicitly stating the reason. The reason can be inferred from the code diff, which shows that the tests are being rewritten to use the MockWebServerRule from the OkHttp library. This is likely to make the tests more understandable and maintainable, as the MockWebServerRule provides a more realistic simulation of network requests than the previous approach.",False,"The commit message 'Rewrite RxJava call adapter tests to be more understandable' does not directly elaborate the motivation of the code change. It does not mention any error scenario, issue report, or shortcoming of the previous implementation. The code diff, however, shows that new dependencies were added to the project, which might indicate that the tests were rewritten to use new features or libraries.",False,"The commit message 'Rewrite RxJava call adapter tests to be more understandable' does not explicitly describe the necessity of changes. While the code diff indicates that additional dependencies were added to support mocking HTTP responses, the commit message does not explicitly state that this was done to address a problem or requirement.",False,"The commit message 'Rewrite RxJava call adapter tests to be more understandable' does not directly mention the defects it fixes or the improvements it makes to the code. It only mentions the goal of making the tests more understandable, which is not a specific change or improvement to the code.",True,"The commit message 'Rewrite RxJava call adapter tests to be more understandable' does describe the changes made in the diff. Specifically, it mentions the addition of new dependencies, such as 'com.squareup.okhttp:mockwebserver', which are used to rewrite the tests. This is a clear indication that the tests are being rewritten, which is reflected in the diff. Additionally, the diff shows the addition of new classes and methods, such as 'MockWebServerRule', 'Service', and 'StringConverter', which are used to set up and execute the tests. These changes are also mentioned in the commit message, further supporting the idea that the message accurately summarizes the changes.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on improving the understandability of the RxJava call adapter tests by adding a new dependency and rewriting the tests. While this could be related to a principle such as 'modularity' or 'separation of concerns', the message does not explicitly state this.",True,"The commit message 'Rewrite RxJava call adapter tests to be more understandable' does express a summary of the changes. The code changes involve refactoring the tests to use the MockWebServer from the OkHttp library, which makes the tests more understandable and maintainable. Additionally, the changes introduce new behaviors such as testing for successful and unsuccessful HTTP responses, and handling errors in a more robust way. The commit message does not explicitly mention these new behaviors, but they are clearly described in the code changes.",False,"The commit message does not explicitly explain the reason for the commit. While it's true that the changes are related to making the RxJava call adapter tests more understandable, the specific reason (like adding new dependencies for mocking HTTP requests) is not mentioned in the commit message. This could make it harder for others to understand the purpose of the changes."
https://github.com/square/okhttp/commit/32b7675b726a1ca62f5080581f6daaf9b7c6a48e,Use ResponseBody to model the response body everywhere.  <enter> This makes cache writing and gzip layering work a bit nicer because there are fewer fields in HttpEngine to track the various competing streams. ,https://api.github.com/repos/square/okhttp/commits/32b7675b726a1ca62f5080581f6daaf9b7c6a48e,"@@ -126,8 +126,9 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final InputStream getErrorStream() {
     try {
       HttpEngine response = getResponse();
-      if (response.hasResponseBody() && response.getResponse().code() >= HTTP_BAD_REQUEST) {
-        return response.getResponseBodyBytes();
+      if (HttpEngine.hasBody(response.getResponse())
+          && response.getResponse().code() >= HTTP_BAD_REQUEST) {
+        return response.getResponse().body().byteStream();
       }
       return null;
     } catch (IOException e) {
@@ -228,11 +229,7 @@ private static String responseSourceHeader(Response response) {
       throw new FileNotFoundException(url.toString());
     }
 
-    InputStream result = response.getResponseBodyBytes();
-    if (result == null) {
-      throw new ProtocolException(""No response body exists; responseCode="" + getResponseCode());
-    }
-    return result;
+    return response.getResponse().body().byteStream();
   }
 
   @Override public final OutputStream getOutputStream() throws IOException {
@@ -349,8 +346,8 @@ private HttpEngine newHttpEngine(String method, Connection connection,
       engineClient = client.clone().setCache(null);
     }
 
-    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody,
-        priorResponse);
+    return new HttpEngine(engineClient, request, bufferRequestBody, true, connection, null,
+        requestBody, priorResponse);
   }
 
   private String defaultUserAgent() {
@@ -426,7 +423,7 @@ private boolean execute(boolean readResponse) throws IOException {
           ? httpEngine.getConnection().getHandshake()
           : null;
       if (readResponse) {
-        httpEngine.readResponse(false);
+        httpEngine.readResponse(false, null);
       }
 
       return true;
@@ -17,14 +17,11 @@
 
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.OkHeaders;
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.URL;
 import java.util.logging.Level;
-import okio.BufferedSink;
-import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.Internal.logger;
 import static com.squareup.okhttp.internal.http.HttpEngine.MAX_REDIRECTS;
@@ -248,7 +245,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, null, null, null, null);
+    engine = new HttpEngine(client, request, false, false, null, null, null, null);
 
     int redirectionCount = 0;
     while (true) {
@@ -259,13 +256,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
 
       try {
         engine.sendRequest();
-
-        if (request.body() != null) {
-          BufferedSink sink = engine.getBufferedRequestBody();
-          request.body().writeTo(sink);
-        }
-
-        engine.readResponse(forWebSocket);
+        engine.readResponse(forWebSocket, request.body());
       } catch (IOException e) {
         HttpEngine retryEngine = engine.recover(e, null);
         if (retryEngine != null) {
@@ -281,12 +272,10 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
       Request followUp = engine.followUpRequest();
 
       if (followUp == null) {
-        Response.Builder builder = response.newBuilder();
         if (!forWebSocket) {
           engine.releaseConnection();
-          builder.body(new RealResponseBody(response, engine.getResponseBody()));
         }
-        return builder.build();
+        return response;
       }
 
       if (engine.getResponse().isRedirect() && ++redirectionCount > MAX_REDIRECTS) {
@@ -299,30 +288,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
 
       Connection connection = engine.close();
       request = followUp;
-      engine = new HttpEngine(client, request, false, connection, null, null, response);
-    }
-  }
-
-  private static class RealResponseBody extends ResponseBody {
-    private final Response response;
-    private final BufferedSource source;
-
-    RealResponseBody(Response response, BufferedSource source) {
-      this.response = response;
-      this.source = source;
-    }
-
-    @Override public MediaType contentType() {
-      String contentType = response.header(""Content-Type"");
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      return OkHeaders.contentLength(response);
-    }
-
-    @Override public BufferedSource source() {
-      return source;
+      engine = new HttpEngine(client, request, false, false, connection, null, null, response);
     }
   }
 }
@@ -33,7 +33,6 @@
 import java.security.cert.X509Certificate;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLSocket;
-
 import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
@@ -406,12 +405,12 @@ private void makeTunnel(Request request, int readTimeout, int writeTimeout)
       // The response body from a CONNECT should be empty, but if it is not then we should consume
       // it before proceeding.
       long contentLength = OkHeaders.contentLength(response);
-      if (contentLength != -1) {
-        Source body = tunnelConnection.newFixedLengthSource(contentLength);
-        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      } else {
-        tunnelConnection.emptyResponseBody();
+      if (contentLength == -1L) {
+        contentLength = 0L;
       }
+      Source body = tunnelConnection.newFixedLengthSource(contentLength);
+      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+      body.close();
 
       switch (response.code()) {
         case HTTP_OK:
@@ -23,6 +23,7 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.Route;
@@ -31,7 +32,6 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Proxy;
@@ -150,12 +150,6 @@ public final class HttpEngine {
    */
   private Response cacheResponse;
 
-  /**
-   * The response read from the network. Null if the network response hasn't
-   * been read yet, or if the network is not used. Never modified by OkHttp.
-   */
-  private Response networkResponse;
-
   /**
    * The user-visible response. This is derived from either the network
    * response, cache response, or both. It is customized to support OkHttp
@@ -165,33 +159,31 @@ public final class HttpEngine {
 
   private Sink requestBodyOut;
   private BufferedSink bufferedRequestBody;
-
-  /** Null until a response is received from the network or the cache. */
-  private Source responseTransferSource;
-  private BufferedSource responseBody;
-  private InputStream responseBodyBytes;
+  private final boolean callerWritesRequestBody;
 
   /** The cache request currently being populated from a network response. */
   private CacheRequest storeRequest;
   private CacheStrategy cacheStrategy;
 
   /**
-   * @param request the HTTP request without a body. The body must be
-   *     written via the engine's request body stream.
-   * @param connection the connection used for an intermediate response
-   *     immediately prior to this request/response pair, such as a same-host
-   *     redirect. This engine assumes ownership of the connection and must
-   *     release it when it is unneeded.
-   * @param routeSelector the route selector used for a failed attempt
-   *     immediately preceding this attempt, or null if this request doesn't
-   *     recover from a failure.
+   * @param request the HTTP request without a body. The body must be written via the engine's
+   *     request body stream.
+   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
+   *     model where control flow is returned to the calling application to write the request body
+   *     before the response body is readable.
+   * @param connection the connection used for an intermediate response immediately prior to this
+   *     request/response pair, such as a same-host redirect. This engine assumes ownership of the
+   *     connection and must release it when it is unneeded.
+   * @param routeSelector the route selector used for a failed attempt immediately preceding this
+   *     attempt, or null if this request doesn't
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut,
-      Response priorResponse) {
+      boolean callerWritesRequestBody, Connection connection, RouteSelector routeSelector,
+      RetryableSink requestBodyOut, Response priorResponse) {
     this.client = client;
     this.userRequest = request;
     this.bufferRequestBody = bufferRequestBody;
+    this.callerWritesRequestBody = callerWritesRequestBody;
     this.connection = connection;
     this.routeSelector = routeSelector;
     this.requestBodyOut = requestBodyOut;
@@ -242,9 +234,11 @@ public void sendRequest() throws IOException {
 
       transport = Internal.instance.newTransport(connection, this);
 
-      // Create a request body if we don't have one already. We'll already have
-      // one if we're retrying a failed POST.
-      if (permitsRequestBody() && requestBodyOut == null) {
+      // If the caller's control flow writes the request body, we need to create that stream
+      // immediately. And that means we need to immediately write the request headers, so we can
+      // start streaming the request body. (We may already have a request body if we're retrying a
+      // failed POST.)
+      if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
         long contentLength = OkHeaders.contentLength(request);
         if (bufferRequestBody) {
           if (contentLength > Integer.MAX_VALUE) {
@@ -254,7 +248,7 @@ public void sendRequest() throws IOException {
 
           if (contentLength != -1) {
             // Buffer a request body of a known length.
-            transport.writeRequestHeaders(request);
+            transport.writeRequestHeaders(networkRequest);
             requestBodyOut = new RetryableSink((int) contentLength);
           } else {
             // Buffer a request body of an unknown length. Don't write request
@@ -263,8 +257,8 @@ public void sendRequest() throws IOException {
             requestBodyOut = new RetryableSink();
           }
         } else {
-          transport.writeRequestHeaders(request);
-          requestBodyOut = transport.createRequestBody(request, contentLength);
+          transport.writeRequestHeaders(networkRequest);
+          requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
         }
       }
 
@@ -294,9 +288,7 @@ public void sendRequest() throws IOException {
             .build();
       }
 
-      if (userResponse.body() != null) {
-        initContentStream(userResponse.body().source());
-      }
+      userResponse = unzip(userResponse);
     }
   }
 
@@ -361,18 +353,6 @@ public Response getResponse() {
     return userResponse;
   }
 
-  public BufferedSource getResponseBody() {
-    if (userResponse == null) throw new IllegalStateException();
-    return responseBody;
-  }
-
-  public InputStream getResponseBodyBytes() {
-    InputStream result = responseBodyBytes;
-    return result != null
-        ? result
-        : (responseBodyBytes = Okio.buffer(getResponseBody()).inputStream());
-  }
-
   public Connection getConnection() {
     return connection;
   }
@@ -399,8 +379,8 @@ public HttpEngine recover(IOException e, Sink requestBodyOut) {
     Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, connection, routeSelector,
-        (RetryableSink) requestBodyOut, priorResponse);
+    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+        connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
   }
 
   public HttpEngine recover(IOException e) {
@@ -484,17 +464,14 @@ public Connection close() {
     }
 
     // If this engine never achieved a response body, its connection cannot be reused.
-    if (responseBody == null) {
+    if (userResponse == null) {
       if (connection != null) closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
       connection = null;
       return null;
     }
 
     // Close the response body. This will recycle the connection if it is eligible.
-    closeQuietly(responseBody);
-
-    // Clear the buffer held by the response body input stream adapter.
-    closeQuietly(responseBodyBytes);
+    closeQuietly(userResponse.body());
 
     // Close the connection if it cannot be reused.
     if (transport != null && connection != null && !transport.canReuseConnection()) {
@@ -514,45 +491,49 @@ public Connection close() {
   }
 
   /**
-   * Initialize the response content stream from the response transfer source.
-   * These two sources are the same unless we're doing transparent gzip, in
-   * which case the content source is decompressed.
+   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
+   * was both offered by OkHttp and used by the origin server.
    *
-   * <p>Whenever we do transparent gzip we also strip the corresponding headers.
-   * We strip the Content-Encoding header to prevent the application from
-   * attempting to double decompress. We strip the Content-Length header because
-   * it is the length of the compressed content, but the application is only
-   * interested in the length of the uncompressed content.
+   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
+   * Content-Encoding header to prevent the application from attempting to double decompress. We
+   * strip the Content-Length header because it is the length of the compressed content, but the
+   * application is only interested in the length of the uncompressed content.
    *
-   * <p>This method should only be used for non-empty response bodies. Response
-   * codes like ""304 Not Modified"" can include ""Content-Encoding: gzip"" without
-   * a response body and we will crash if we attempt to decompress the zero-byte
-   * source.
+   * <p>This method should only be used for non-empty response bodies. Response codes like ""304 Not
+   * Modified"" can include ""Content-Encoding: gzip"" without a response body and we will crash if we
+   * attempt to decompress the zero-byte source.
    */
-  private void initContentStream(Source transferSource) throws IOException {
-    responseTransferSource = transferSource;
-    if (transparentGzip && ""gzip"".equalsIgnoreCase(userResponse.header(""Content-Encoding""))) {
-      userResponse = userResponse.newBuilder()
-          .removeHeader(""Content-Encoding"")
-          .removeHeader(""Content-Length"")
-          .build();
-      responseBody = Okio.buffer(new GzipSource(transferSource));
-    } else {
-      responseBody = Okio.buffer(transferSource);
+  private Response unzip(final Response response) throws IOException {
+    if (!transparentGzip || !""gzip"".equalsIgnoreCase(userResponse.header(""Content-Encoding""))) {
+      return response;
+    }
+
+    if (response.body() == null) {
+      return response;
     }
+
+    GzipSource responseBody = new GzipSource(response.body().source());
+    Headers strippedHeaders = response.headers().newBuilder()
+        .removeAll(""Content-Encoding"")
+        .removeAll(""Content-Length"")
+        .build();
+    return response.newBuilder()
+        .headers(strippedHeaders)
+        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
+        .build();
   }
 
   /**
    * Returns true if the response must have a (possibly 0-length) body.
    * See RFC 2616 section 4.3.
    */
-  public boolean hasResponseBody() {
+  public static boolean hasBody(Response response) {
     // HEAD requests never yield a body regardless of the response headers.
-    if (userRequest.method().equals(""HEAD"")) {
+    if (response.request().method().equals(""HEAD"")) {
       return false;
     }
 
-    int responseCode = userResponse.code();
+    int responseCode = response.code();
     if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
         && responseCode != HTTP_NO_CONTENT
         && responseCode != HTTP_NOT_MODIFIED) {
@@ -562,8 +543,8 @@ public boolean hasResponseBody() {
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (OkHeaders.contentLength(networkResponse) != -1
-        || ""chunked"".equalsIgnoreCase(networkResponse.header(""Transfer-Encoding""))) {
+    if (OkHeaders.contentLength(response) != -1
+        || ""chunked"".equalsIgnoreCase(response.header(""Transfer-Encoding""))) {
       return true;
     }
 
@@ -623,7 +604,7 @@ public static String hostHeader(URL url) {
    * Flushes the remaining request header and body, parses the HTTP response
    * headers and starts reading the HTTP response body if it exists.
    */
-  public void readResponse(boolean forWebSocket) throws IOException {
+  public void readResponse(boolean forWebSocket, RequestBody requestBody) throws IOException {
     if (userResponse != null) {
       return; // Already ready.
     }
@@ -634,43 +615,60 @@ public void readResponse(boolean forWebSocket) throws IOException {
       return; // No network response to read.
     }
 
-    // Flush the request body if there's data outstanding.
-    if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
-      bufferedRequestBody.flush();
-    }
-
-    if (sentRequestMillis == -1) {
-      if (OkHeaders.contentLength(networkRequest) == -1
-          && requestBodyOut instanceof RetryableSink) {
-        // We might not learn the Content-Length until the request body has been buffered.
-        long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-        networkRequest = networkRequest.newBuilder()
-            .header(""Content-Length"", Long.toString(contentLength))
-            .build();
-      }
+    if (!callerWritesRequestBody) {
+      // If we haven't written the request body yet, write it now.
       transport.writeRequestHeaders(networkRequest);
-    }
-
-    if (requestBodyOut != null) {
-      if (bufferedRequestBody != null) {
-        // This also closes the wrapped requestBodyOut.
+      if (permitsRequestBody() && requestBody != null) {
+        requestBodyOut = transport.createRequestBody(networkRequest, requestBody.contentLength());
+        bufferedRequestBody = Okio.buffer(requestBodyOut);
+        requestBody.writeTo(bufferedRequestBody);
         bufferedRequestBody.close();
-      } else {
-        requestBodyOut.close();
       }
-      if (requestBodyOut instanceof RetryableSink) {
-        transport.writeRequestBody((RetryableSink) requestBodyOut);
+    } else {
+      // Emit the request body's buffer so that everything is in requestBodyOut.
+      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
+        bufferedRequestBody.emit();
+      }
+
+      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
+      if (sentRequestMillis == -1) {
+        if (OkHeaders.contentLength(networkRequest) == -1
+            && requestBodyOut instanceof RetryableSink) {
+          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
+          networkRequest = networkRequest.newBuilder()
+              .header(""Content-Length"", Long.toString(contentLength))
+              .build();
+        }
+        transport.writeRequestHeaders(networkRequest);
+      }
+
+      // Write the request body to the socket.
+      if (requestBodyOut != null) {
+        if (bufferedRequestBody != null) {
+          // This also closes the wrapped requestBodyOut.
+          bufferedRequestBody.close();
+        } else {
+          requestBodyOut.close();
+        }
+        if (requestBodyOut instanceof RetryableSink) {
+          transport.writeRequestBody((RetryableSink) requestBodyOut);
+        }
       }
     }
 
-    transport.flushRequest();
+    transport.finishRequest();
 
-    networkResponse = transport.readResponseHeaders()
+    Response networkResponse = transport.readResponseHeaders()
         .request(networkRequest)
         .handshake(connection.getHandshake())
         .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
         .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
         .build();
+    if (!forWebSocket) {
+      networkResponse = networkResponse.newBuilder()
+          .body(transport.openResponseBody(networkResponse))
+          .build();
+    }
     Internal.instance.setProtocol(connection, networkResponse.protocol());
     receiveHeaders(networkResponse.headers());
 
@@ -684,18 +682,15 @@ public void readResponse(boolean forWebSocket) throws IOException {
             .cacheResponse(stripBody(cacheResponse))
             .networkResponse(stripBody(networkResponse))
             .build();
-        transport.emptyTransferStream();
+        networkResponse.body().close();
         releaseConnection();
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
         InternalCache responseCache = Internal.instance.internalCache(client);
         responseCache.trackConditionalCacheHit();
         responseCache.update(cacheResponse, stripBody(userResponse));
-
-        if (cacheResponse.body() != null) {
-          initContentStream(cacheResponse.body().source());
-        }
+        userResponse = unzip(userResponse);
         return;
       } else {
         closeQuietly(cacheResponse.body());
@@ -709,34 +704,28 @@ public void readResponse(boolean forWebSocket) throws IOException {
         .networkResponse(stripBody(networkResponse))
         .build();
 
-    if (!hasResponseBody()) {
-      if (!forWebSocket) {
-        // Don't call initContentStream() when the response doesn't have any content.
-        responseTransferSource = transport.getTransferStream();
-        responseBody = Okio.buffer(responseTransferSource);
-      }
-      return;
+    if (hasBody(userResponse)) {
+      maybeCache();
+      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
     }
-
-    maybeCache();
-    initContentStream(cacheWritingSource(storeRequest, transport.getTransferStream()));
   }
 
   /**
    * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
    * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
    * may never exhaust the source stream and therefore not complete the cached response.
    */
-  private Source cacheWritingSource(final CacheRequest cacheRequest, final Source source)
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
       throws IOException {
     // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return source;
+    if (cacheRequest == null) return response;
     Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return source;
+    if (cacheBodyUnbuffered == null) return response;
 
+    final BufferedSource source = response.body().source();
     final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
 
-    return new Source() {
+    Source cacheWritingSource = new Source() {
       boolean cacheRequestClosed;
 
       @Override public long read(Buffer sink, long byteCount) throws IOException {
@@ -777,6 +766,10 @@ private Source cacheWritingSource(final CacheRequest cacheRequest, final Source
         source.close();
       }
     };
+
+    return response.newBuilder()
+        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+        .build();
   }
 
   /**
@@ -18,7 +18,9 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okio.Okio;
 import okio.Sink;
 import okio.Source;
 
@@ -46,7 +48,7 @@ public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
         ""Cannot stream a request body without chunked encoding or a known content length!"");
   }
 
-  @Override public void flushRequest() throws IOException {
+  @Override public void finishRequest() throws IOException {
     httpConnection.flush();
   }
 
@@ -104,20 +106,21 @@ public void writeRequestHeaders(Request request) throws IOException {
     return true;
   }
 
-  @Override public void emptyTransferStream() throws IOException {
-    httpConnection.emptyResponseBody();
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = getTransferStream(response);
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
   }
 
-  @Override public Source getTransferStream() throws IOException {
-    if (!httpEngine.hasResponseBody()) {
+  private Source getTransferStream(Response response) throws IOException {
+    if (!HttpEngine.hasBody(response)) {
       return httpConnection.newFixedLengthSource(0);
     }
 
-    if (""chunked"".equalsIgnoreCase(httpEngine.getResponse().header(""Transfer-Encoding""))) {
+    if (""chunked"".equalsIgnoreCase(response.header(""Transfer-Encoding""))) {
       return httpConnection.newChunkedSource(httpEngine);
     }
 
-    long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
+    long contentLength = OkHeaders.contentLength(response);
     if (contentLength != -1) {
       return httpConnection.newFixedLengthSource(contentLength);
     }
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import okio.BufferedSource;
+
+public final class RealResponseBody extends ResponseBody {
+  private final Headers headers;
+  private final BufferedSource source;
+
+  public RealResponseBody(Headers headers, BufferedSource source) {
+    this.headers = headers;
+    this.source = source;
+  }
+
+  @Override public MediaType contentType() {
+    String contentType = headers.get(""Content-Type"");
+    return contentType != null ? MediaType.parse(contentType) : null;
+  }
+
+  @Override public long contentLength() {
+    return OkHeaders.contentLength(headers);
+  }
+
+  @Override public BufferedSource source() {
+    return source;
+  }
+}
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
@@ -34,8 +35,8 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import okio.ByteString;
+import okio.Okio;
 import okio.Sink;
-import okio.Source;
 
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
@@ -95,7 +96,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     requestBody.writeToSocket(stream.getSink());
   }
 
-  @Override public void flushRequest() throws IOException {
+  @Override public void finishRequest() throws IOException {
     stream.getSink().close();
   }
 
@@ -204,12 +205,8 @@ public static Response.Builder readNameValueBlock(List<Header> headerBlock,
         .headers(headersBuilder.build());
   }
 
-  @Override public void emptyTransferStream() {
-    // Do nothing.
-  }
-
-  @Override public Source getTransferStream() throws IOException {
-    return stream.getSource();
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));
   }
 
   @Override public void releaseConnectionOnIdle() {
@@ -18,9 +18,9 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import okio.Sink;
-import okio.Source;
 
 public interface Transport {
   /**
@@ -42,16 +42,14 @@ public interface Transport {
    */
   void writeRequestBody(RetryableSink requestBody) throws IOException;
 
-  /** Flush the request body to the underlying socket. */
-  void flushRequest() throws IOException;
+  /** Flush the request to the underlying socket. */
+  void finishRequest() throws IOException;
 
-  /** Read response headers and update the cookie manager. */
+  /** Read and return response headers. */
   Response.Builder readResponseHeaders() throws IOException;
 
-  /** Notify the transport that no response body will be read. */
-  void emptyTransferStream() throws IOException;
-
-  Source getTransferStream() throws IOException;
+  /** Returns a stream that reads the response body. */
+  ResponseBody openResponseBody(Response response) throws IOException;
 
   /**
    * Configures the response body to pool or close the socket connection when
",True,"The commit message refers to the use of ResponseBody to model the response body everywhere. This is likely a change to improve code consistency and maintainability, as it ensures that the response body is always handled in a consistent way. This could be a reference to a convention or standard within the project, or it could be an improvement over prior commits that did not use ResponseBody consistently.",True,"The commit message 'Use ResponseBody to model the response body everywhere' indicates that the changes made are to standardize the way response bodies are handled throughout the codebase. This is a refactoring that improves code consistency and maintainability, but doesn't necessarily require a detailed explanation in the commit message.",True,"The commit message explains the necessity of changes by mentioning that the changes are made to 'make cache writing and gzip layering work a bit nicer'. This is because the changes are made to simplify the tracking of various competing streams in HttpEngine, which will make it easier to handle cache writing and gzip layering.",True,"The commit message 'Use ResponseBody to model the response body everywhere' indicates that the developer is refactoring the code to use a more consistent and efficient way of handling response bodies. This change is likely being made to improve the maintainability and performance of the codebase. It does not explicitly mention any specific requirements or problems, but it is a common practice in software development to refactor code for maintainability and performance reasons.",True,The commit message directly mentions the change to use ResponseBody to model the response body everywhere. This change is likely to make cache writing and gzip layering work a bit nicer because there are fewer fields in HttpEngine to track the various competing streams.,True,"The commit message 'Use ResponseBody to model the response body everywhere' accurately describes the change made in the code diff. The diff shows that the ResponseBody class is being used to model the response body, replacing the previous use of InputStream and BufferedSource. This change makes cache writing and gzip layering work a bit nicer because there are fewer fields in HttpEngine to track the various competing streams.",True,The commit message explains that the use of ResponseBody to model the response body everywhere makes cache writing and gzip layering work a bit nicer. This is because there are fewer fields in HttpEngine to track the various competing streams. The code diff supports this explanation by showing changes that involve the use of ResponseBody and the handling of gzip compression.,True,"The commit message expresses a change in how the response body is modeled, stating that it is now using ResponseBody to model the response body everywhere. This change is functional as it improves cache writing and gzip layering, making it work a bit nicer. The code diff supports this by showing changes in how the response body is handled, such as using ResponseBody.byteStream() instead of getResponseBodyBytes() and using ResponseBody.body().byteStream() instead of newFixedLengthSource().",False,"The commit message does not lack an explanation. It clearly states that the change was made to 'Use ResponseBody to model the response body everywhere' to make cache writing and gzip layering work a bit nicer. This is because there are fewer fields in HttpEngine to track the various competing streams. This explanation is sufficient to understand the reason behind the change, even though the change itself is not trivial."
https://github.com/square/okhttp/commit/59a6804c91328c2d1eb096054590b213ab711d22,Tests for canceling async requests. ,https://api.github.com/repos/square/okhttp/commits/59a6804c91328c2d1eb096054590b213ab711d22,"@@ -17,12 +17,16 @@
 
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.File;
+import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLContext;
 import org.junit.After;
 import org.junit.Before;
@@ -178,4 +182,59 @@ public final class AsyncApiTest {
         .assertCode(301)
         .assertContainsHeaders(""Test: Redirect from /a to /b"");
   }
+
+  @Test public void canceledBeforeResponseReadIsNeverDelivered() throws Exception {
+    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    server.setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel(""request A"");
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+    server.play();
+
+    // Canceling a request after the server has received a request but before
+    // it has delivered the response. That request will never be received to the
+    // client.
+    Request requestA = new Request.Builder().url(server.getUrl(""/a"")).tag(""request A"").build();
+    client.enqueue(requestA, receiver);
+    assertEquals(""/a"", server.takeRequest().getPath());
+
+    // We then make a second request (not canceled) to make sure the receiver
+    // has nothing left to wait for.
+    Request requestB = new Request.Builder().url(server.getUrl(""/b"")).tag(""request B"").build();
+    client.enqueue(requestB, receiver);
+    assertEquals(""/b"", server.takeRequest().getPath());
+    receiver.await(requestB.url()).assertBody(""B"");
+
+    // At this point we know the receiver is ready: if it hasn't received 'A'
+    // yet it never will.
+    receiver.assertNoResponse(requestA.url());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredDoesNothing() throws Exception {
+    server.enqueue(new MockResponse().setBody(""A""));
+    server.play();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+
+    Request request = new Request.Builder().url(server.getUrl(""/a"")).tag(""request A"").build();
+    client.enqueue(request, new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        throw new AssertionError();
+      }
+
+      @Override public boolean onResponse(Response response) throws IOException {
+        client.cancel(""request A"");
+        bodyRef.set(response.body().string());
+        latch.countDown();
+        return true;
+      }
+    });
+
+    latch.await();
+    assertEquals(""A"", bodyRef.get());
+  }
 }
@@ -86,4 +86,12 @@ public synchronized RecordedResponse await(URL url) throws Exception {
 
     throw new AssertionError(""Timed out waiting for response to "" + url);
   }
+
+  public synchronized void assertNoResponse(URL url) throws Exception {
+    for (RecordedResponse recordedResponse : responses) {
+      if (recordedResponse.request.url().equals(url)) {
+        throw new AssertionError(""Expected no response for "" + url);
+      }
+    }
+  }
 }
",True,"The commit message 'Tests for canceling async requests' refers to the necessity of changes by implementing new tests. The code diff shows the addition of new test methods that test the behavior of canceling async requests. This is done to improve the existing codebase by adding more test coverage, which is a common practice in software development.",True,"The commit message 'Tests for canceling async requests.' clearly describes the purpose of the changes, which is to add tests for canceling asynchronous requests. This is a common practice in software development and the necessity of adding these tests is not trivially inferable from the code diff. The diff shows the addition of new test methods and imports that are necessary for these tests, further supporting the need for the changes.",True,"The commit message 'Tests for canceling async requests.' does contain an expression that describes the necessity of changes. It mentions the scenario of canceling async requests, which is a common issue that can arise in asynchronous programming. The code diff adds tests to handle this scenario, which is a clear indication of the motivation for the code change.",True,"The commit message 'Tests for canceling async requests' indicates that the developer added tests to handle the scenario where asynchronous requests are canceled. This could be a requirement from users who may need to cancel ongoing operations, or it could be a problem in the process of software maintenance where the existing code did not handle this situation properly.",True,"The commit message 'Tests for canceling async requests.' does contain an expression that describes the objective of the change. Specifically, it mentions that the change is adding tests for canceling async requests, which implies that the code is being modified to handle or improve the functionality related to canceling asynchronous requests.",True,"The commit message 'Tests for canceling async requests' accurately summarizes the changes made in the diff. The diff adds tests for canceling async requests before and after response is delivered, which is clearly mentioned in the commit message. This makes the commit message a good summary of the changes, as it points out the key components of the change, which are the addition of tests for canceling async requests.",True,The commit message 'Tests for canceling async requests' does contain an expression that describes the technical principle underpinning the changes. The changes are related to handling asynchronous requests and their cancellation. The code diff shows that the tests have been added to cover scenarios where a request is canceled before the response is read and after the response is delivered. These scenarios demonstrate the principle of handling request cancellation in an asynchronous context.,True,"The commit message 'Tests for canceling async requests' does express a summary of the changes made in the code diff. The code diff adds tests for canceling asynchronous requests in two scenarios: when the request is canceled before the response is read, and when the request is canceled after the response is delivered. These tests describe new behaviors introduced by the changes, specifically the handling of canceled requests in these two scenarios.",True,"The commit message 'Tests for canceling async requests.' does not explicitly explain the reason for the commit, but the changes made in the diff are clear and straightforward. The added tests are for canceling asynchronous requests in different scenarios, such as when the request is canceled before the response is read, and when the request is canceled after the response is delivered. Therefore, the reason for the commit can be easily inferred from the changes made in the code."
https://github.com/square/okhttp/commit/40ff76547064c3fb5acb9047a6f679dd4379a4d0,Make HttpConnection.connect return full working connections.  <enter> Previously the returned connections required the caller to do extra work: setting up tunnels (which could require auth) and performing an SSL handshake. With this change we make a complete working connection in HttpConnection.connect(). <enter> This will make it easier to fix fallback when a single domain has multiple IP addresses and some of those addresses are not reachable. <enter> This will also make it easier to do SPDY through HTTP proxies. ,https://api.github.com/repos/square/okhttp/commits/40ff76547064c3fb5acb9047a6f679dd4379a4d0,"@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package libcore.net.http;
-
-/**
- * An RFC 2617 challenge.
- */
-final class Challenge {
-    final String scheme;
-    final String realm;
-
-    Challenge(String scheme, String realm) {
-        this.scheme = scheme;
-        this.realm = realm;
-    }
-
-    @Override public boolean equals(Object o) {
-        return o instanceof Challenge
-                && ((Challenge) o).scheme.equals(scheme)
-                && ((Challenge) o).realm.equals(realm);
-    }
-
-    @Override public int hashCode() {
-        return scheme.hashCode() + 31 * realm.hashCode();
-    }
-}
@@ -65,61 +65,12 @@ public static void parseCacheControl(String value, CacheControlHandler handler)
         }
     }
 
-    /**
-     * Parse RFC 2617 challenges. This API is only interested in the scheme
-     * name and realm.
-     */
-    public static List<Challenge> parseChallenges(
-            RawHeaders responseHeaders, String challengeHeader) {
-        /*
-         * auth-scheme = token
-         * auth-param  = token ""="" ( token | quoted-string )
-         * challenge   = auth-scheme 1*SP 1#auth-param
-         * realm       = ""realm"" ""="" realm-value
-         * realm-value = quoted-string
-         */
-        List<Challenge> result = new ArrayList<Challenge>();
-        for (int h = 0; h < responseHeaders.length(); h++) {
-            if (!challengeHeader.equalsIgnoreCase(responseHeaders.getFieldName(h))) {
-                continue;
-            }
-            String value = responseHeaders.getValue(h);
-            int pos = 0;
-            while (pos < value.length()) {
-                int tokenStart = pos;
-                pos = skipUntil(value, pos, "" "");
-
-                String scheme = value.substring(tokenStart, pos).trim();
-                pos = skipWhitespace(value, pos);
-
-                // TODO: This currently only handles schemes with a 'realm' parameter;
-                //       It needs to be fixed to handle any scheme and any parameters
-                //       http://code.google.com/p/android/issues/detail?id=11140
-
-                if (!value.regionMatches(pos, ""realm=\"""", 0, ""realm=\"""".length())) {
-                    break; // unexpected challenge parameter; give up
-                }
-
-                pos += ""realm=\"""".length();
-                int realmStart = pos;
-                pos = skipUntil(value, pos, ""\"""");
-                String realm = value.substring(realmStart, pos);
-                pos++; // consume '""' close quote
-                pos = skipUntil(value, pos, "","");
-                pos++; // consume ',' comma
-                pos = skipWhitespace(value, pos);
-                result.add(new Challenge(scheme, realm));
-            }
-        }
-        return result;
-    }
-
     /**
      * Returns the next index in {@code input} at or after {@code pos} that
      * contains a character from {@code characters}. Returns the input length if
      * none of the requested characters can be found.
      */
-    private static int skipUntil(String input, int pos, String characters) {
+    public static int skipUntil(String input, int pos, String characters) {
         for (; pos < input.length(); pos++) {
             if (characters.indexOf(input.charAt(pos)) != -1) {
                 break;
@@ -132,7 +83,7 @@ private static int skipUntil(String input, int pos, String characters) {
      * Returns the next non-whitespace character in {@code input} that is white
      * space. Result is undefined if input contains newline characters.
      */
-    private static int skipWhitespace(String input, int pos) {
+    public static int skipWhitespace(String input, int pos) {
         for (; pos < input.length(); pos++) {
             char c = input.charAt(pos);
             if (c != ' ' && c != '\t') {
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package libcore.net.http;
+
+import static com.squareup.okhttp.OkHttpConnection.HTTP_PROXY_AUTH;
+import static com.squareup.okhttp.OkHttpConnection.HTTP_UNAUTHORIZED;
+import java.io.IOException;
+import java.net.Authenticator;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.PasswordAuthentication;
+import java.net.Proxy;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import libcore.io.Base64;
+
+/**
+ * Handles HTTP authentication headers from origin and proxy servers.
+ */
+public final class HttpAuthenticator {
+    /**
+     * React to a failed authorization response by looking up new credentials.
+     *
+     * @return true if credentials have been added to successorRequestHeaders
+     *     and another request should be attempted.
+     */
+    public static final boolean processAuthHeader(int responseCode, RawHeaders responeHeaders,
+            RawHeaders successorRequestHeaders, Proxy proxy, URL url) throws IOException {
+        if (responseCode != HTTP_PROXY_AUTH && responseCode != HTTP_UNAUTHORIZED) {
+            throw new IllegalArgumentException();
+        }
+
+        // Keep asking for username/password until authorized.
+        String challengeHeader = responseCode == HTTP_PROXY_AUTH
+                ? ""Proxy-Authenticate""
+                : ""WWW-Authenticate"";
+        String credentials = getCredentials(responeHeaders, challengeHeader, proxy, url);
+        if (credentials == null) {
+            return false; // Could not find credentials so end the request cycle.
+        }
+
+        // Add authorization credentials, bypassing the already-connected check.
+        String fieldName = responseCode == HTTP_PROXY_AUTH
+                ? ""Proxy-Authorization""
+                : ""Authorization"";
+        successorRequestHeaders.set(fieldName, credentials);
+        return true;
+    }
+
+    /**
+     * Returns the authorization credentials that may satisfy the challenge.
+     * Returns null if a challenge header was not provided or if credentials
+     * were not available.
+     */
+    private static String getCredentials(RawHeaders responseHeaders,
+            String challengeHeader, Proxy proxy, URL url) throws IOException {
+        List<Challenge> challenges = parseChallenges(responseHeaders, challengeHeader);
+        if (challenges.isEmpty()) {
+            return null;
+        }
+
+        for (Challenge challenge : challenges) {
+            // Use the global authenticator to get the password.
+            PasswordAuthentication auth;
+            if (responseHeaders.getResponseCode() == HTTP_PROXY_AUTH) {
+                InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
+                auth = Authenticator.requestPasswordAuthentication(
+                        proxyAddress.getHostName(), getConnectToInetAddress(proxy, url),
+                        proxyAddress.getPort(), url.getProtocol(), challenge.realm,
+                        challenge.scheme, url, Authenticator.RequestorType.PROXY);
+            } else {
+                auth = Authenticator.requestPasswordAuthentication(
+                        url.getHost(), getConnectToInetAddress(proxy, url), url.getPort(),
+                        url.getProtocol(), challenge.realm, challenge.scheme, url,
+                        Authenticator.RequestorType.SERVER);
+            }
+            if (auth == null) {
+                continue;
+            }
+
+            // Use base64 to encode the username and password.
+            String usernameAndPassword = auth.getUserName() + "":"" + new String(auth.getPassword());
+            byte[] bytes = usernameAndPassword.getBytes(""ISO-8859-1"");
+            String encoded = Base64.encode(bytes);
+            return challenge.scheme + "" "" + encoded;
+        }
+
+        return null;
+    }
+
+    private static InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
+        return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+                ? ((InetSocketAddress) proxy.address()).getAddress()
+                : InetAddress.getByName(url.getHost());
+    }
+
+    /**
+     * Parse RFC 2617 challenges. This API is only interested in the scheme
+     * name and realm.
+     */
+    private static List<Challenge> parseChallenges(
+            RawHeaders responseHeaders, String challengeHeader) {
+        /*
+         * auth-scheme = token
+         * auth-param  = token ""="" ( token | quoted-string )
+         * challenge   = auth-scheme 1*SP 1#auth-param
+         * realm       = ""realm"" ""="" realm-value
+         * realm-value = quoted-string
+         */
+        List<Challenge> result = new ArrayList<Challenge>();
+        for (int h = 0; h < responseHeaders.length(); h++) {
+            if (!challengeHeader.equalsIgnoreCase(responseHeaders.getFieldName(h))) {
+                continue;
+            }
+            String value = responseHeaders.getValue(h);
+            int pos = 0;
+            while (pos < value.length()) {
+                int tokenStart = pos;
+                pos = HeaderParser.skipUntil(value, pos, "" "");
+
+                String scheme = value.substring(tokenStart, pos).trim();
+                pos = HeaderParser.skipWhitespace(value, pos);
+
+                // TODO: This currently only handles schemes with a 'realm' parameter;
+                //       It needs to be fixed to handle any scheme and any parameters
+                //       http://code.google.com/p/android/issues/detail?id=11140
+
+                if (!value.regionMatches(pos, ""realm=\"""", 0, ""realm=\"""".length())) {
+                    break; // Unexpected challenge parameter; give up!
+                }
+
+                pos += ""realm=\"""".length();
+                int realmStart = pos;
+                pos = HeaderParser.skipUntil(value, pos, ""\"""");
+                String realm = value.substring(realmStart, pos);
+                pos++; // Consume '""' close quote.
+                pos = HeaderParser.skipUntil(value, pos, "","");
+                pos++; // Consume ',' comma.
+                pos = HeaderParser.skipWhitespace(value, pos);
+                result.add(new Challenge(scheme, realm));
+            }
+        }
+        return result;
+    }
+
+    /**
+     * An RFC 2617 challenge.
+     */
+    private static final class Challenge {
+        final String scheme;
+        final String realm;
+
+        Challenge(String scheme, String realm) {
+            this.scheme = scheme;
+            this.realm = realm;
+        }
+
+        @Override public boolean equals(Object o) {
+            return o instanceof Challenge
+                    && ((Challenge) o).scheme.equals(scheme)
+                    && ((Challenge) o).realm.equals(realm);
+        }
+
+        @Override public int hashCode() {
+            return scheme.hashCode() + 31 * realm.hashCode();
+        }
+    }
+}
@@ -17,22 +17,26 @@
 
 package libcore.net.http;
 
+import static com.squareup.okhttp.OkHttpConnection.HTTP_PROXY_AUTH;
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import static java.net.HttpURLConnection.HTTP_OK;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.Socket;
 import java.net.SocketAddress;
-import java.net.SocketException;
 import java.net.URI;
+import java.net.URL;
 import java.net.UnknownHostException;
+import java.security.cert.CertificateException;
 import java.util.Arrays;
 import java.util.List;
 import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import libcore.io.IoUtils;
@@ -62,82 +66,50 @@ final class HttpConnection {
     };
 
     private final Address address;
-    private final Socket socket;
-    private InputStream inputStream;
-    private OutputStream outputStream;
-    private SSLSocket sslSocket;
-    private InputStream sslInputStream;
-    private OutputStream sslOutputStream;
+    private Socket socket;
+    private InputStream in;
+    private OutputStream out;
     private boolean recycled = false;
     private SpdyConnection spdyConnection;
 
+    HttpConnection(Address address, Socket socket, InputStream in, OutputStream out) {
+        this.address = address;
+        this.socket = socket;
+        this.in = in;
+        this.out = out;
+    }
+
     /**
      * The version this client will use. Either 0 for HTTP/1.0, or 1 for
      * HTTP/1.1. Upon receiving a non-HTTP/1.1 response, this client
      * automatically sets its version to HTTP/1.0.
      */
     int httpMinorVersion = 1; // Assume HTTP/1.1
 
-    private HttpConnection(Address config, int connectTimeout) throws IOException {
-        this.address = config;
-
-        /*
-         * Try each of the host's addresses for best behavior in mixed IPv4/IPv6
-         * environments. See http://b/2876927
-         * TODO: add a hidden method so that Socket.tryAllAddresses can does this for us
-         */
-        Socket socketCandidate = null;
-        InetAddress[] addresses = InetAddress.getAllByName(config.socketHost);
-        for (int i = 0; i < addresses.length; i++) {
-            socketCandidate = (config.proxy != null && config.proxy.type() != Proxy.Type.HTTP)
-                    ? new Socket(config.proxy)
-                    : new Socket();
-            try {
-                socketCandidate.connect(
-                        new InetSocketAddress(addresses[i], config.socketPort), connectTimeout);
-                break;
-            } catch (IOException e) {
-                if (i == addresses.length - 1) {
-                    throw e;
-                }
-            }
-        }
-
-        if (socketCandidate == null) {
-            throw new IOException();
-        }
-
-        this.socket = socketCandidate;
-
-        /*
-         * Buffer the socket stream to permit efficient parsing of HTTP headers
-         * and chunk sizes. Benchmarks suggest 128 is sufficient. We cannot
-         * buffer when setting up a tunnel because we may consume bytes intended
-         * for the SSL socket.
-         */
-        int bufferSize = 128;
-        inputStream = address.requiresTunnel()
-                ? socket.getInputStream()
-                : new BufferedInputStream(socket.getInputStream(), bufferSize);
-        outputStream = socket.getOutputStream();
+    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,
+            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,
+            TunnelConfig tunnelConfig) throws IOException {
+        HttpConnection result = getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,
+                connectTimeout, tunnelConfig);
+        result.socket.setSoTimeout(readTimeout);
+        return result;
     }
 
-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,
-            Proxy proxy, int connectTimeout) throws IOException {
-        /*
-         * Try an explicitly-specified proxy.
-         */
+    /**
+     * Selects a proxy and gets a connection with that proxy.
+     */
+    private static HttpConnection getConnection(URI uri, SSLSocketFactory sslSocketFactory,
+            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout,
+            TunnelConfig tunnelConfig) throws IOException {
+        // Try an explicitly-specified proxy.
         if (proxy != null) {
             Address address = (proxy.type() == Proxy.Type.DIRECT)
-                    ? new Address(uri, sslSocketFactory)
-                    : new Address(uri, sslSocketFactory, proxy);
-            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);
+                    ? new Address(uri, sslSocketFactory, hostnameVerifier)
+                    : new Address(uri, sslSocketFactory, hostnameVerifier, proxy);
+            return getConnectionToAddress(address, connectTimeout, tunnelConfig);
         }
 
-        /*
-         * Try connecting to each of the proxies provided by the ProxySelector
-         * until a connection succeeds.
-         */
+        // Try each proxy provided by the ProxySelector until a connection succeeds.
         ProxySelector selector = ProxySelector.getDefault();
         List<Proxy> proxyList = selector.select(uri);
         if (proxyList != null) {
@@ -148,58 +120,118 @@ public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,
                     continue;
                 }
                 try {
-                    Address address = new Address(uri, sslSocketFactory, selectedProxy);
-                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);
+                    return getConnectionToAddress(new Address(uri, sslSocketFactory,
+                            hostnameVerifier, selectedProxy), connectTimeout, tunnelConfig);
                 } catch (IOException e) {
                     // failed to connect, tell it to the selector
                     selector.connectFailed(uri, selectedProxy.address(), e);
                 }
             }
         }
 
+        // Try a direct connection. If this fails, this method will throw.
+        return getConnectionToAddress(new Address(uri, sslSocketFactory, hostnameVerifier),
+                connectTimeout, tunnelConfig);
+    }
+
+    /**
+     * Selects a proxy and gets a connection with that proxy.
+     */
+    private static HttpConnection getConnectionToAddress(Address address, int connectTimeout,
+            TunnelConfig tunnelConfig) throws IOException {
+        HttpConnection pooled = HttpConnectionPool.INSTANCE.get(address);
+        if (pooled != null) {
+            return pooled;
+        }
+
+        Socket socket = connectSocket(address, connectTimeout);
+        HttpConnection result = new HttpConnection(
+                address, socket, socket.getInputStream(), socket.getOutputStream());
+
+        if (address.sslSocketFactory != null) {
+            // First try an SSL connection with compression and various TLS
+            // extensions enabled, if it fails (and its not unheard of that it
+            // will) fallback to a barebones connection.
+            try {
+                result = new HttpConnection(
+                        address, socket, socket.getInputStream(), socket.getOutputStream());
+                result.upgradeToTls(true, tunnelConfig);
+            } catch (IOException e) {
+                // If the problem was a CertificateException from the X509TrustManager,
+                // do not retry, we didn't have an abrupt server initiated exception.
+                if (e instanceof SSLHandshakeException
+                        && e.getCause() instanceof CertificateException) {
+                    throw e;
+                }
+                result.closeSocketAndStreams();
+
+                socket = connectSocket(address, connectTimeout);
+                result = new HttpConnection(
+                        address, socket, socket.getInputStream(), socket.getOutputStream());
+                result.upgradeToTls(false, tunnelConfig);
+            }
+        }
+
         /*
-         * Try a direct connection. If this fails, this method will throw.
+         * Buffer the socket stream to permit efficient parsing of HTTP headers
+         * and chunk sizes. This also masks SSL InputStream's degenerate
+         * available() implementation. That way we can read the end of a chunked
+         * response without blocking and will recycle connections more reliably.
+         * http://code.google.com/p/android/issues/detail?id=38817
          */
-        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);
-    }
+        int bufferSize = 128;
+        result.in = new BufferedInputStream(result.in, bufferSize);
 
-    public void closeSocketAndStreams() {
-        IoUtils.closeQuietly(sslOutputStream);
-        IoUtils.closeQuietly(sslInputStream);
-        IoUtils.closeQuietly(sslSocket);
-        IoUtils.closeQuietly(outputStream);
-        IoUtils.closeQuietly(inputStream);
-        IoUtils.closeQuietly(socket);
+        return result;
     }
 
-    public void setSoTimeout(int readTimeout) throws SocketException {
-        socket.setSoTimeout(readTimeout);
-    }
+    /**
+     * Try each of the host's addresses for best behavior in mixed IPv4/IPv6
+     * environments. See http://b/2876927
+     */
+    private static Socket connectSocket(Address address, int connectTimeout) throws IOException {
+        Socket socket = null;
+        InetAddress[] addresses = InetAddress.getAllByName(address.socketHost);
+        for (int i = 0; i < addresses.length; i++) {
+            socket = (address.proxy != null && address.proxy.type() != Proxy.Type.HTTP)
+                    ? new Socket(address.proxy)
+                    : new Socket();
+            try {
+                socket.connect(
+                        new InetSocketAddress(addresses[i], address.socketPort), connectTimeout);
+                break;
+            } catch (IOException e) {
+                if (i == addresses.length - 1) {
+                    throw e;
+                }
+            }
+        }
 
-    Socket getSocket() {
-        return sslSocket != null ? sslSocket : socket;
-    }
+        if (socket == null) {
+            throw new IOException();
+        }
 
-    public Address getAddress() {
-        return address;
+        return socket;
     }
 
     /**
-     * Create an {@code SSLSocket} and perform the SSL handshake
-     * (performing certificate validation.
+     * Create an {@code SSLSocket} and perform the TLS handshake and certificate
+     * validation.
      *
-     * @param sslSocketFactory Source of new {@code SSLSocket} instances.
-     * @param tlsTolerant If true, assume server can handle common
+     * @param tlsTolerant If true, assume server can handle common TLS
+     *     extensions and SSL deflate compression. If false, use an SSL3 only
+     *     fallback mode without compression.
      */
-    public SSLSocket setupSecureSocket(SSLSocketFactory sslSocketFactory,
-            HostnameVerifier hostnameVerifier, boolean tlsTolerant) throws IOException {
-        if (spdyConnection != null || sslOutputStream != null || sslInputStream != null) {
-            throw new IllegalStateException();
+    private void upgradeToTls(boolean tlsTolerant, TunnelConfig tunnelConfig) throws IOException {
+        // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+        if (address.requiresTunnel()) {
+            makeTunnel(tunnelConfig);
         }
 
         // Create the wrapper over connected socket.
-        sslSocket = (SSLSocket) sslSocketFactory.createSocket(socket,
-                address.uriHost, address.uriPort, true /* autoClose */);
+        socket = address.sslSocketFactory.createSocket(
+                socket, address.uriHost, address.uriPort, true /* autoClose */);
+        SSLSocket sslSocket = (SSLSocket) socket;
         Libcore.makeTlsTolerant(sslSocket, address.uriHost, tlsTolerant);
 
         if (tlsTolerant) {
@@ -210,40 +242,38 @@ public SSLSocket setupSecureSocket(SSLSocketFactory sslSocketFactory,
         sslSocket.startHandshake();
 
         // Verify that the socket's certificates are acceptable for the target host.
-        if (!hostnameVerifier.verify(address.uriHost, sslSocket.getSession())) {
+        if (!address.hostnameVerifier.verify(address.uriHost, sslSocket.getSession())) {
             throw new IOException(""Hostname '"" + address.uriHost + ""' was not verified"");
         }
 
-        /*
-         * Buffer the input to mask SSL InputStream's degenerate available()
-         * implementation. That way we can read the end of a chunked response
-         * without blocking and will recycle the connection more reliably.
-         * http://code.google.com/p/android/issues/detail?id=38817
-         */
-        sslOutputStream = sslSocket.getOutputStream();
-        sslInputStream = new BufferedInputStream(sslSocket.getInputStream(), 128);
+        out = sslSocket.getOutputStream();
+        in = sslSocket.getInputStream();
 
         byte[] selectedProtocol;
         if (tlsTolerant
                 && (selectedProtocol = Libcore.getNpnSelectedProtocol(sslSocket)) != null) {
             if (Arrays.equals(selectedProtocol, SPDY2)) {
-                spdyConnection = new SpdyConnection.Builder(
-                        true, sslInputStream, sslOutputStream).build();
+                spdyConnection = new SpdyConnection.Builder(true, in, out).build();
                 HttpConnectionPool.INSTANCE.share(this);
             } else if (!Arrays.equals(selectedProtocol, HTTP_11)) {
                 throw new IOException(""Unexpected NPN transport ""
                         + new String(selectedProtocol, ""ISO-8859-1""));
             }
         }
+    }
 
-        return sslSocket;
+    public void closeSocketAndStreams() {
+        IoUtils.closeQuietly(out);
+        IoUtils.closeQuietly(in);
+        IoUtils.closeQuietly(socket);
     }
 
-    /**
-     * Return an {@code SSLSocket} if already connected, otherwise null.
-     */
-    public SSLSocket getSecureSocketIfConnected() {
-        return sslSocket;
+    public Socket getSocket() {
+        return socket;
+    }
+
+    public Address getAddress() {
+        return address;
     }
 
     /**
@@ -274,10 +304,8 @@ protected boolean isEligibleForRecycling() {
     public Transport newTransport(HttpEngine httpEngine) throws IOException {
         if (spdyConnection != null) {
             return new SpdyTransport(httpEngine, spdyConnection);
-        } else if (sslSocket != null) {
-            return new HttpTransport(httpEngine, sslOutputStream, sslInputStream);
         } else {
-            return new HttpTransport(httpEngine, outputStream, inputStream);
+            return new HttpTransport(httpEngine, out, in);
         }
     }
 
@@ -289,6 +317,76 @@ public boolean isSpdy() {
         return spdyConnection != null;
     }
 
+    public static final class TunnelConfig {
+        private final URL url;
+        private final String host;
+        private final String userAgent;
+        private final String proxyAuthorization;
+
+        public TunnelConfig(URL url, String host, String userAgent, String proxyAuthorization) {
+            if (url == null || host == null || userAgent == null) throw new NullPointerException();
+            this.url = url;
+            this.host = host;
+            this.userAgent = userAgent;
+            this.proxyAuthorization = proxyAuthorization;
+        }
+
+        /**
+         * If we're establishing an HTTPS tunnel with CONNECT (RFC 2817 5.2), send
+         * only the minimum set of headers. This avoids sending potentially
+         * sensitive data like HTTP cookies to the proxy unencrypted.
+         */
+        RawHeaders getRequestHeaders() {
+            RawHeaders result = new RawHeaders();
+            result.setRequestLine(""CONNECT "" + url.getHost() + "":""
+                    + Libcore.getEffectivePort(url) + "" HTTP/1.1"");
+
+            // Always set Host and User-Agent.
+            result.set(""Host"", host);
+            result.set(""User-Agent"", userAgent);
+
+            // Copy over the Proxy-Authorization header if it exists.
+            if (proxyAuthorization != null) {
+                result.set(""Proxy-Authorization"", proxyAuthorization);
+            }
+
+            // Always set the Proxy-Connection to Keep-Alive for the benefit of
+            // HTTP/1.0 proxies like Squid.
+            result.set(""Proxy-Connection"", ""Keep-Alive"");
+            return result;
+        }
+    }
+
+    /**
+     * To make an HTTPS connection over an HTTP proxy, send an unencrypted
+     * CONNECT request to create the proxy connection. This may need to be
+     * retried if the proxy requires authorization.
+     */
+    private void makeTunnel(TunnelConfig tunnelConfig) throws IOException {
+        RawHeaders requestHeaders = tunnelConfig.getRequestHeaders();
+        while (true) {
+            out.write(requestHeaders.toBytes());
+            RawHeaders responseHeaders = RawHeaders.fromBytes(in);
+
+            switch (responseHeaders.getResponseCode()) {
+            case HTTP_OK:
+                return;
+            case HTTP_PROXY_AUTH:
+                requestHeaders = new RawHeaders(requestHeaders);
+                boolean credentialsFound = HttpAuthenticator.processAuthHeader(HTTP_PROXY_AUTH,
+                        responseHeaders, requestHeaders, address.proxy, tunnelConfig.url);
+                if (credentialsFound) {
+                    continue;
+                } else {
+                    throw new IOException(""Failed to authenticate with proxy"");
+                }
+            default:
+                throw new IOException(""Unexpected response code for CONNECT: ""
+                        + responseHeaders.getResponseCode());
+            }
+        }
+    }
+
     /**
      * This address has two parts: the address we connect to directly and the
      * origin address of the resource. These are the same unless a proxy is
@@ -302,25 +400,29 @@ public static final class Address {
         private final String socketHost;
         private final int socketPort;
         private final SSLSocketFactory sslSocketFactory;
+        private final HostnameVerifier hostnameVerifier;
 
-        public Address(URI uri, SSLSocketFactory sslSocketFactory) throws UnknownHostException {
+        public Address(URI uri, SSLSocketFactory sslSocketFactory,
+                HostnameVerifier hostnameVerifier) throws UnknownHostException {
             this.proxy = null;
             this.uriHost = uri.getHost();
             this.uriPort = Libcore.getEffectivePort(uri);
             this.sslSocketFactory = sslSocketFactory;
+            this.hostnameVerifier = hostnameVerifier;
             this.socketHost = uriHost;
             this.socketPort = uriPort;
             if (uriHost == null) {
                 throw new UnknownHostException(uri.toString());
             }
         }
 
-        public Address(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy)
-                throws UnknownHostException {
+        public Address(URI uri, SSLSocketFactory sslSocketFactory,
+                HostnameVerifier hostnameVerifier, Proxy proxy) throws UnknownHostException {
             this.proxy = proxy;
             this.uriHost = uri.getHost();
             this.uriPort = Libcore.getEffectivePort(uri);
             this.sslSocketFactory = sslSocketFactory;
+            this.hostnameVerifier = hostnameVerifier;
 
             SocketAddress proxyAddress = proxy.address();
             if (!(proxyAddress instanceof InetSocketAddress)) {
@@ -345,7 +447,8 @@ public Proxy getProxy() {
                 return Objects.equal(this.proxy, that.proxy)
                         && this.uriHost.equals(that.uriHost)
                         && this.uriPort == that.uriPort
-                        && Objects.equal(this.sslSocketFactory, that.sslSocketFactory);
+                        && Objects.equal(this.sslSocketFactory, that.sslSocketFactory)
+                        && Objects.equal(this.hostnameVerifier, that.hostnameVerifier);
             }
             return false;
         }
@@ -355,14 +458,11 @@ public Proxy getProxy() {
             result = 31 * result + uriHost.hashCode();
             result = 31 * result + uriPort;
             result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
+            result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
             result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
             return result;
         }
 
-        public HttpConnection connect(int connectTimeout) throws IOException {
-            return new HttpConnection(this, connectTimeout);
-        }
-
         /**
          * Returns true if the HTTP connection needs to tunnel one protocol over
          * another, such as when using HTTPS through an HTTP proxy. When doing so,
@@ -17,7 +17,6 @@
 
 package libcore.net.http;
 
-import java.io.IOException;
 import java.net.Socket;
 import java.net.SocketException;
 import java.util.ArrayList;
@@ -59,8 +58,7 @@ private HttpConnectionPool() {
                 : 5;
     }
 
-    public HttpConnection get(HttpConnection.Address address, int connectTimeout)
-            throws IOException {
+    public HttpConnection get(HttpConnection.Address address) {
         // First try to reuse an existing HTTP connection.
         synchronized (connectionPool) {
             List<HttpConnection> connections = connectionPool.get(address);
@@ -81,12 +79,7 @@ public HttpConnection get(HttpConnection.Address address, int connectTimeout)
                 }
             }
         }
-
-        /*
-         * We couldn't find a reusable connection, so we need to create a new
-         * connection. We're careful not to do so while holding a lock!
-         */
-        return address.connect(connectTimeout);
+        return null;
     }
 
     /**
@@ -36,6 +36,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.zip.GZIPInputStream;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 import libcore.io.IoUtils;
 import libcore.util.EmptyArray;
@@ -86,7 +87,6 @@ public class HttpEngine {
     public static final String PUT = ""PUT"";
     public static final String DELETE = ""DELETE"";
     public static final String TRACE = ""TRACE"";
-    public static final String CONNECT = ""CONNECT"";
 
     public static final int HTTP_CONTINUE = 100;
 
@@ -274,22 +274,18 @@ private void sendSocketRequest() throws IOException {
      * Connect to the origin server either directly or via a proxy.
      */
     protected void connect() throws IOException {
-        if (connection == null) {
-            connection = openSocketConnection();
+        if (connection != null) {
+            return;
         }
-    }
-
-    protected final HttpConnection openSocketConnection() throws IOException {
-        HttpConnection result = HttpConnection.connect(uri, getSslSocketFactory(),
-                policy.getProxy(), policy.getConnectTimeout());
-        Proxy proxy = result.getAddress().getProxy();
+        connection = HttpConnection.connect(uri, getSslSocketFactory(), getHostnameVerifier(),
+                policy.getProxy(), policy.getConnectTimeout(), policy.getReadTimeout(),
+                getTunnelConfig());
+        Proxy proxy = connection.getAddress().getProxy();
         if (proxy != null) {
             policy.setProxy(proxy);
             // Add the authority to the request line when we're using a proxy.
             requestHeaders.getHeaders().setRequestLine(getRequestLine());
         }
-        result.setSoTimeout(policy.getReadTimeout());
-        return result;
     }
 
     /**
@@ -371,11 +367,6 @@ protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
     }
 
     private void maybeCache() throws IOException {
-        // Never cache responses to proxy CONNECT requests.
-        if (method == CONNECT) {
-            return;
-        }
-
         // Are we caching at all?
         if (!policy.getUseCaches() || responseCache == null) {
             return;
@@ -458,8 +449,7 @@ public final boolean hasResponseBody() {
             return false;
         }
 
-        if (method != CONNECT
-                && (responseCode < HTTP_CONTINUE || responseCode >= 200)
+        if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
                 && responseCode != HttpURLConnectionImpl.HTTP_NO_CONTENT
                 && responseCode != HttpURLConnectionImpl.HTTP_NOT_MODIFIED) {
             return true;
@@ -569,15 +559,23 @@ protected SSLSocketFactory getSslSocketFactory() {
         return null;
     }
 
-    protected final String getDefaultUserAgent() {
+    /**
+     * Returns the hostname verifier for connections created by this engine. We
+     * cannot reuse HTTPS connections if the hostname verifier has changed.
+     */
+    protected HostnameVerifier getHostnameVerifier() {
+        return null;
+    }
+
+    public static final String getDefaultUserAgent() {
         String agent = System.getProperty(""http.agent"");
         return agent != null ? agent : (""Java"" + System.getProperty(""java.version""));
     }
 
-    protected final String getOriginAddress(URL url) {
+    public static String getOriginAddress(URL url) {
         int port = url.getPort();
         String result = url.getHost();
-        if (port > 0 && port != policy.getDefaultPort()) {
+        if (port > 0 && port != Libcore.getDefaultPort(url.getProtocol())) {
             result = result + "":"" + port;
         }
         return result;
@@ -642,4 +640,8 @@ public final void readResponse() throws IOException {
 
         initContentStream(transport.getTransferStream(cacheRequest));
     }
+
+    protected HttpConnection.TunnelConfig getTunnelConfig() {
+        return null;
+    }
 }
@@ -23,7 +23,6 @@
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.CookieHandler;
-import java.net.URL;
 import libcore.io.Streams;
 import libcore.util.Libcore;
 
@@ -124,8 +123,8 @@ public void writeRequestHeaders() throws IOException {
         httpEngine.sentRequestMillis = System.currentTimeMillis();
 
         int contentLength = httpEngine.requestHeaders.getContentLength();
-        RawHeaders headersToSend = getNetworkRequestHeaders();
-        byte[] bytes = headersToSend.toRequestHeader().getBytes(""ISO-8859-1"");
+        RawHeaders headersToSend = httpEngine.requestHeaders.getHeaders();
+        byte[] bytes = headersToSend.toBytes();
 
         if (contentLength != -1 && bytes.length + contentLength <= MAX_REQUEST_BUFFER_LENGTH) {
             requestOut = new BufferedOutputStream(socketOut, bytes.length + contentLength);
@@ -134,71 +133,14 @@ public void writeRequestHeaders() throws IOException {
         requestOut.write(bytes);
     }
 
-    private RawHeaders getNetworkRequestHeaders() {
-        return httpEngine.method == HttpEngine.CONNECT
-                ? getTunnelNetworkRequestHeaders()
-                : httpEngine.requestHeaders.getHeaders();
-    }
-
-    /**
-     * If we're establishing an HTTPS tunnel with CONNECT (RFC 2817 5.2), send
-     * only the minimum set of headers. This avoids sending potentially
-     * sensitive data like HTTP cookies to the proxy unencrypted.
-     */
-    private RawHeaders getTunnelNetworkRequestHeaders() {
-        RequestHeaders privateHeaders = httpEngine.requestHeaders;
-        URL url = httpEngine.policy.getURL();
-
-        RawHeaders result = new RawHeaders();
-        result.setRequestLine(""CONNECT "" + url.getHost() + "":"" + Libcore.getEffectivePort(url)
-                + "" HTTP/1.1"");
-
-        // Always set Host and User-Agent.
-        String host = privateHeaders.getHost();
-        if (host == null) {
-            host = httpEngine.getOriginAddress(url);
-        }
-        result.set(""Host"", host);
-
-        String userAgent = privateHeaders.getUserAgent();
-        if (userAgent == null) {
-            userAgent = httpEngine.getDefaultUserAgent();
-        }
-        result.set(""User-Agent"", userAgent);
-
-        // Copy over the Proxy-Authorization header if it exists.
-        String proxyAuthorization = privateHeaders.getProxyAuthorization();
-        if (proxyAuthorization != null) {
-            result.set(""Proxy-Authorization"", proxyAuthorization);
-        }
-
-        // Always set the Proxy-Connection to Keep-Alive for the benefit of
-        // HTTP/1.0 proxies like Squid.
-        result.set(""Proxy-Connection"", ""Keep-Alive"");
-        return result;
-    }
-
     @Override public ResponseHeaders readResponseHeaders() throws IOException {
-        RawHeaders headers;
-        do {
-            headers = new RawHeaders();
-            headers.setStatusLine(Streams.readAsciiLine(socketIn));
-            httpEngine.connection.httpMinorVersion = headers.getHttpMinorVersion();
-            readHeaders(headers);
-        } while (headers.getResponseCode() == HttpEngine.HTTP_CONTINUE);
+        RawHeaders headers = RawHeaders.fromBytes(socketIn);
+        httpEngine.connection.httpMinorVersion = headers.getHttpMinorVersion();
+        receiveHeaders(headers);
         return new ResponseHeaders(httpEngine.uri, headers);
     }
 
-    /**
-     * Reads headers or trailers and updates the cookie store.
-     */
-    private void readHeaders(RawHeaders headers) throws IOException {
-        // parse the result headers until the first blank line
-        String line;
-        while ((line = Streams.readAsciiLine(socketIn)).length() != 0) {
-            headers.addLine(line);
-        }
-
+    private void receiveHeaders(RawHeaders headers) throws IOException {
         CookieHandler cookieHandler = CookieHandler.getDefault();
         if (cookieHandler != null) {
             cookieHandler.put(httpEngine.uri, headers.toMultimap(true));
@@ -211,11 +153,8 @@ public boolean makeReusable(OutputStream requestBodyOut, InputStream responseBod
             return false;
         }
 
-        // If the request specified that the connection shouldn't be reused,
-        // don't reuse it. This advice doesn't apply to CONNECT requests because
-        // the ""Connection: close"" header goes the origin server, not the proxy.
-        if (httpEngine.requestHeaders.hasConnectionClose()
-                && httpEngine.method != HttpEngine.CONNECT) {
+        // If the request specified that the connection shouldn't be reused, don't reuse it.
+        if (httpEngine.requestHeaders.hasConnectionClose()) {
             return false;
         }
 
@@ -531,7 +470,9 @@ private void readChunkSize() throws IOException {
             }
             if (bytesRemainingInChunk == 0) {
                 hasMoreChunks = false;
-                transport.readHeaders(httpEngine.responseHeaders.getHeaders());
+                RawHeaders rawResponseHeaders = httpEngine.responseHeaders.getHeaders();
+                RawHeaders.readHeaders(transport.socketIn, rawResponseHeaders);
+                transport.receiveHeaders(rawResponseHeaders);
                 endOfInput(true);
             }
         }
@@ -22,19 +22,15 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.Authenticator;
 import java.net.HttpRetryException;
-import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
 import java.security.Permission;
 import java.util.List;
 import java.util.Map;
-import libcore.io.Base64;
 import libcore.io.IoUtils;
 import libcore.util.Libcore;
 
@@ -367,8 +363,8 @@ private Retry processResponseHeaders() throws IOException {
             }
             // fall-through
         case HTTP_UNAUTHORIZED:
-            boolean credentialsFound = processAuthHeader(getResponseCode(),
-                    httpEngine.getResponseHeaders(), rawRequestHeaders);
+            boolean credentialsFound = HttpAuthenticator.processAuthHeader(getResponseCode(),
+                    httpEngine.getResponseHeaders().getHeaders(), rawRequestHeaders, proxy, url);
             return credentialsFound ? Retry.SAME_CONNECTION : Retry.NONE;
 
         case HTTP_MULT_CHOICE:
@@ -402,81 +398,6 @@ private Retry processResponseHeaders() throws IOException {
         }
     }
 
-    /**
-     * React to a failed authorization response by looking up new credentials.
-     *
-     * @return true if credentials have been added to successorRequestHeaders
-     *     and another request should be attempted.
-     */
-    final boolean processAuthHeader(int responseCode, ResponseHeaders response,
-            RawHeaders successorRequestHeaders) throws IOException {
-        if (responseCode != HTTP_PROXY_AUTH && responseCode != HTTP_UNAUTHORIZED) {
-            throw new IllegalArgumentException();
-        }
-
-        // keep asking for username/password until authorized
-        String challengeHeader = responseCode == HTTP_PROXY_AUTH
-                ? ""Proxy-Authenticate""
-                : ""WWW-Authenticate"";
-        String credentials = getAuthorizationCredentials(response.getHeaders(), challengeHeader);
-        if (credentials == null) {
-            return false; // could not find credentials, end request cycle
-        }
-
-        // add authorization credentials, bypassing the already-connected check
-        String fieldName = responseCode == HTTP_PROXY_AUTH
-                ? ""Proxy-Authorization""
-                : ""Authorization"";
-        successorRequestHeaders.set(fieldName, credentials);
-        return true;
-    }
-
-    /**
-     * Returns the authorization credentials that may satisfy the challenge.
-     * Returns null if a challenge header was not provided or if credentials
-     * were not available.
-     */
-    private String getAuthorizationCredentials(RawHeaders responseHeaders, String challengeHeader)
-            throws IOException {
-        List<Challenge> challenges = HeaderParser.parseChallenges(responseHeaders, challengeHeader);
-        if (challenges.isEmpty()) {
-            return null;
-        }
-
-        for (Challenge challenge : challenges) {
-            // use the global authenticator to get the password
-            PasswordAuthentication auth;
-            if (responseHeaders.getResponseCode() == HTTP_PROXY_AUTH) {
-                InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-                auth = Authenticator.requestPasswordAuthentication(
-                        proxyAddress.getHostName(), getConnectToInetAddress(),
-                        proxyAddress.getPort(), url.getProtocol(), challenge.realm,
-                        challenge.scheme, url, Authenticator.RequestorType.PROXY);
-            } else {
-                auth = Authenticator.requestPasswordAuthentication(
-                        url.getHost(), getConnectToInetAddress(), url.getPort(), url.getProtocol(),
-                        challenge.realm, challenge.scheme, url, Authenticator.RequestorType.SERVER);
-            }
-            if (auth == null) {
-                continue;
-            }
-
-            // base64 encode the username and password
-            String usernameAndPassword = auth.getUserName() + "":"" + new String(auth.getPassword());
-            byte[] bytes = usernameAndPassword.getBytes(""ISO-8859-1"");
-            String encoded = Base64.encode(bytes);
-            return challenge.scheme + "" "" + encoded;
-        }
-
-        return null;
-    }
-
-    private InetAddress getConnectToInetAddress() throws IOException {
-        return usingProxy()
-                ? ((InetSocketAddress) proxy.address()).getAddress()
-                : InetAddress.getByName(getURL().getHost());
-    }
-
     final int getDefaultPort() {
         return defaultPort;
     }
@@ -29,10 +29,9 @@
 import java.security.Permission;
 import java.security.Principal;
 import java.security.cert.Certificate;
-import java.security.cert.CertificateException;
 import java.util.List;
 import java.util.Map;
-import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
@@ -419,87 +418,10 @@ private HttpsEngine(HttpURLConnectionImpl policy, String method, RawHeaders requ
                 HttpConnection connection, RetryableOutputStream requestBody,
                 HttpsURLConnectionImpl enclosing) throws IOException {
             super(policy, method, requestHeaders, connection, requestBody);
-            this.sslSocket = connection != null ? connection.getSecureSocketIfConnected() : null;
+            this.sslSocket = connection != null ? (SSLSocket) connection.getSocket() : null;
             this.enclosing = enclosing;
         }
 
-        @Override protected void connect() throws IOException {
-            // First try an SSL connection with compression and various TLS
-            // extensions enabled, if it fails (and its not unheard of that it
-            // will) fallback to a barebones connection.
-            try {
-                makeSslConnection(true);
-            } catch (IOException e) {
-                // If the problem was a CertificateException from the X509TrustManager,
-                // do not retry, we didn't have an abrupt server initiated exception.
-                if (e instanceof SSLHandshakeException
-                        && e.getCause() instanceof CertificateException) {
-                    throw e;
-                }
-                release(false);
-                makeSslConnection(false);
-            }
-        }
-
-        /**
-         * Attempt to make an HTTPS connection.
-         *
-         * @param tlsTolerant If true, assume server can handle common
-         * TLS extensions and SSL deflate compression. If false, use
-         * an SSL3 only fallback mode without compression.
-         */
-        private void makeSslConnection(boolean tlsTolerant) throws IOException {
-            // Get a connection. This may return a pooled connection!
-            if (connection == null) {
-                connection = openSocketConnection();
-            }
-            sslSocket = connection.getSecureSocketIfConnected();
-
-            // If the TLS connection is ready, use it.
-            if (sslSocket != null) {
-                return;
-            }
-
-            // The TLS connection isn't ready. Build a tunnel if necessary and then handshake.
-            if (connection.getAddress().requiresTunnel()) {
-                makeTunnel(policy, connection, getRequestHeaders());
-            }
-            sslSocket = connection.setupSecureSocket(
-                    enclosing.getSSLSocketFactory(), enclosing.getHostnameVerifier(), tlsTolerant);
-        }
-
-        /**
-         * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-         * CONNECT request to create the proxy connection. This may need to be
-         * retried if the proxy requires authorization.
-         */
-        private void makeTunnel(HttpURLConnectionImpl policy, HttpConnection connection,
-                RequestHeaders requestHeaders) throws IOException {
-            RawHeaders rawRequestHeaders = requestHeaders.getHeaders();
-            while (true) {
-                HttpEngine connect = new ProxyConnectEngine(policy, rawRequestHeaders, connection);
-                connect.sendRequest();
-                connect.readResponse();
-
-                int responseCode = connect.getResponseCode();
-                switch (connect.getResponseCode()) {
-                case HTTP_OK:
-                    return;
-                case HTTP_PROXY_AUTH:
-                    rawRequestHeaders = new RawHeaders(rawRequestHeaders);
-                    boolean credentialsFound = policy.processAuthHeader(HTTP_PROXY_AUTH,
-                            connect.getResponseHeaders(), rawRequestHeaders);
-                    if (credentialsFound) {
-                        continue;
-                    } else {
-                        throw new IOException(""Failed to authenticate with proxy"");
-                    }
-                default:
-                    throw new IOException(""Unexpected response code for CONNECT: "" + responseCode);
-                }
-            }
-        }
-
         @Override protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
             return cacheResponse instanceof SecureCacheResponse;
         }
@@ -513,15 +435,28 @@ private void makeTunnel(HttpURLConnectionImpl policy, HttpConnection connection,
             return enclosing.getSSLSocketFactory();
         }
 
+        @Override protected HostnameVerifier getHostnameVerifier() {
+            return enclosing.getHostnameVerifier();
+        }
+
         @Override protected OkHttpConnection getHttpConnectionToCache() {
             return enclosing;
         }
-    }
 
-    private static class ProxyConnectEngine extends HttpEngine {
-        public ProxyConnectEngine(HttpURLConnectionImpl policy, RawHeaders requestHeaders,
-                HttpConnection connection) throws IOException {
-            super(policy, HttpEngine.CONNECT, requestHeaders, connection, null);
+        @Override protected HttpConnection.TunnelConfig getTunnelConfig() {
+            String host = requestHeaders.getHost();
+            if (host == null) {
+                host = HttpEngine.getOriginAddress(policy.getURL());
+            }
+
+            String userAgent = requestHeaders.getUserAgent();
+            if (userAgent == null) {
+                userAgent = HttpEngine.getDefaultUserAgent();
+            }
+
+            String proxyAuthorization = requestHeaders.getProxyAuthorization();
+            return new HttpConnection.TunnelConfig(
+                    policy.getURL(), host, userAgent, proxyAuthorization);
         }
     }
 }
@@ -18,6 +18,8 @@
 package libcore.net.http;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -28,6 +30,7 @@
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.TreeMap;
+import libcore.io.Streams;
 import libcore.util.Libcore;
 
 /**
@@ -74,6 +77,7 @@ public RawHeaders() {
 
     public RawHeaders(RawHeaders copyFrom) {
         namesAndValues.addAll(copyFrom.namesAndValues);
+        requestLine = copyFrom.requestLine;
         statusLine = copyFrom.statusLine;
         httpMinorVersion = copyFrom.httpMinorVersion;
         responseCode = copyFrom.responseCode;
@@ -284,15 +288,42 @@ public RawHeaders getAll(Set<String> fieldNames) {
         return result;
     }
 
-    public String toRequestHeader() {
+    /**
+     * Returns bytes of a request header for sending on an HTTP transport.
+     */
+    public byte[] toBytes() throws UnsupportedEncodingException {
         StringBuilder result = new StringBuilder(256);
         result.append(requestLine).append(""\r\n"");
         for (int i = 0; i < namesAndValues.size(); i += 2) {
             result.append(namesAndValues.get(i)).append("": "")
                     .append(namesAndValues.get(i + 1)).append(""\r\n"");
         }
         result.append(""\r\n"");
-        return result.toString();
+        return result.toString().getBytes(""ISO-8859-1"");
+    }
+
+    /**
+     * Parses bytes of a response header from an HTTP transport.
+     */
+    public static RawHeaders fromBytes(InputStream in) throws IOException {
+        RawHeaders headers;
+        do {
+            headers = new RawHeaders();
+            headers.setStatusLine(Streams.readAsciiLine(in));
+            readHeaders(in, headers);
+        } while (headers.getResponseCode() == HttpEngine.HTTP_CONTINUE);
+        return headers;
+    }
+
+    /**
+     * Reads headers or trailers into {@code out}.
+     */
+    public static void readHeaders(InputStream in, RawHeaders out) throws IOException {
+        // parse the result headers until the first blank line
+        String line;
+        while ((line = Streams.readAsciiLine(in)).length() != 0) {
+            out.addLine(line);
+        }
     }
 
     /**
@@ -197,10 +197,12 @@ public static int getEffectivePort(URL url) {
     }
 
     private static int getEffectivePort(String scheme, int specifiedPort) {
-        if (specifiedPort != -1) {
-            return specifiedPort;
-        }
+        return specifiedPort != -1
+                ? specifiedPort
+                : getDefaultPort(scheme);
+    }
 
+    public static int getDefaultPort(String scheme) {
         if (""http"".equalsIgnoreCase(scheme)) {
             return 80;
         } else if (""https"".equalsIgnoreCase(scheme)) {
@@ -20,6 +20,10 @@
 import com.google.mockwebserver.MockWebServer;
 import com.google.mockwebserver.RecordedRequest;
 import com.google.mockwebserver.SocketPolicy;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import com.squareup.okhttp.OkHttpConnection;
 import com.squareup.okhttp.OkHttpsConnection;
 import java.io.ByteArrayOutputStream;
@@ -69,11 +73,6 @@
 import junit.framework.TestCase;
 import libcore.net.ssl.SslContextBuilder;
 
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static com.google.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static com.google.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-
 /**
  * Android's URLConnectionTest.
  */
@@ -478,15 +477,16 @@ public void testConnectViaHttpsReusingConnections() throws IOException, Interrup
 
         // The pool will only reuse sockets if the SSL socket factories are the same.
         SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
+        RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
         OkHttpsConnection connection = (OkHttpsConnection) openConnection(server.getUrl(""/""));
         connection.setSSLSocketFactory(clientSocketFactory);
-        connection.setHostnameVerifier(new RecordingHostnameVerifier());
+        connection.setHostnameVerifier(hostnameVerifier);
         assertContent(""this response comes via HTTPS"", connection);
 
         connection = (OkHttpsConnection) openConnection(server.getUrl(""/""));
         connection.setSSLSocketFactory(clientSocketFactory);
-        connection.setHostnameVerifier(new RecordingHostnameVerifier());
+        connection.setHostnameVerifier(hostnameVerifier);
         assertContent(""another response via HTTPS"", connection);
 
         assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -516,7 +516,7 @@ public void testConnectViaHttpsReusingConnectionsDifferentFactories()
 
     public void testConnectViaHttpsWithSSLFallback() throws IOException, InterruptedException {
         server.useHttps(sslContext.getSocketFactory(), false);
-        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
         server.enqueue(new MockResponse().setBody(""this response comes via SSL""));
         server.play();
 
",True,"The commit message refers to the necessity of changes by mentioning that the previous implementation of HttpConnection.connect returned connections that required the caller to do extra work such as setting up tunnels and performing an SSL handshake. The new implementation makes a complete working connection in HttpConnection.connect(), which will make it easier to fix fallback when a single domain has multiple IP addresses and some of those addresses are not reachable. This will also make it easier to do SPDY through HTTP proxies.",True,"The commit message describes the necessity of changes by explaining that the previous implementation of HttpConnection.connect returned incomplete connections, requiring extra work from the caller to set up tunnels and perform SSL handshakes. The new implementation makes a complete working connection in HttpConnection.connect(), which will make it easier to fix fallback when a single domain has multiple IP addresses and some of those addresses are not reachable, and will also make it easier to do SPDY through HTTP proxies.",True,The commit message explains that the changes are made to handle HTTP authentication headers from origin and proxy servers. This is necessary to support scenarios where the server or proxy requires authentication before allowing the connection to proceed.,True,"The commit message mentions that the change is made to make a complete working connection in HttpConnection.connect(), which implies that the developer is addressing a problem with the existing code, such as the need to set up tunnels and perform an SSL handshake manually, which is a common issue in HTTPS connections.",True,"The commit message directly mentions the change will make a complete working connection in HttpConnection.connect(), which fixes the issue of requiring extra work such as setting up tunnels and performing an SSL handshake.",True,"The commit message describes the changes made to the HttpConnection class, specifically mentioning the addition of a new method called upgradeToTls that creates an SSLSocket and performs the TLS handshake and certificate validation. This is a significant change that is not mentioned in the code diff, which only shows modifications to the HttpAuthenticator class. Therefore, the commit message does express a summary of the changes by describing the new functionality added to the HttpConnection class.",True,"The commit message explains that the changes are made to handle HTTP authentication headers from origin and proxy servers. This indicates that the technical principle underpinning the changes is handling authentication, which is a fundamental aspect of HTTP communication.",True,"The commit message expresses that the HttpConnection.connect method now returns fully working connections. This means that the setup of tunnels (which could require authentication) and performing an SSL handshake are handled within this method. This change makes it easier to fix fallback when a single domain has multiple IP addresses and some of those addresses are not reachable, and it also makes it easier to do SPDY through HTTP proxies.",False,"The commit message does not lack an explanation because it clearly explains the reason for the commit. It mentions that the change is made to make a complete working connection in HttpConnection.connect(), which will make it easier to fix fallback when a single domain has multiple IP addresses and some of those addresses are not reachable. It will also make it easier to do SPDY through HTTP proxies."
https://github.com/apache/dubbo/commit/3308a197751eeb97baddf157f53813a3447d159f,fix typo:metodName ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/3308a197751eeb97baddf157f53813a3447d159f,"@@ -54,7 +54,6 @@ public ConsumerModel(String serviceKey
             , ReferenceConfigBase<?> referenceConfig) {
 
         Assert.notEmptyString(serviceKey, ""Service name can't be null or blank"");
-//        Assert.notNull(proxyObject, ""Proxy object can't be null"");
 
         this.serviceKey = serviceKey;
         this.proxyObject = proxyObject;
@@ -172,7 +171,7 @@ public ConsumerMethodModel getMethodModel(String method) {
     }
 
     /**
-     * @param method   metodName
+     * @param method   methodName
      * @param argsType method arguments type
      * @return
      */
",False,"The commit message only mentions a typo fix, but it does not reference any conventions, standards, improvements in prior commits, or implemented features. It does not explain why the change was necessary.",True,"The commit message 'fix typo:metodName' clearly describes the necessity of the change without providing a rationale. The change is a typographic fix, which is a common practice and easy to infer from the commit message. The code diff also supports this interpretation, showing the correction of a misspelled method name.",False,"The commit message only mentions a typo fix in the code, but it does not provide any explanation about the necessity of the change, such as describing an error scenario, mentioning an issue report, or highlighting a shortcoming of the previous implementation.",False,"The commit message 'fix typo:metodName' does not contain an expression that describes the necessity of changes. It only mentions a typo fix, which is a minor change and does not necessarily indicate a requirement from users, a problem in the process of software maintenance, or a change in the development environment.",True,"The commit message 'fix typo:metodName' directly mentions the change made to the code, which is fixing a typo in the method name from 'metodName' to 'methodName'. This change improves the readability and correctness of the code.",False,"The commit message only mentions a typo fix in the method name, but it does not provide a summary of the changes made in the code diff. The diff shows a removal of a line of code that checks if the proxy object is null, and a replacement of 'metodName' with 'methodName' in the documentation. However, the commit message does not mention these changes.",False,"The commit message only mentions a typo fix, but it does not explain any technical principle underpinning the changes. The code diff shows a change in a method name from 'metodName' to 'methodName', but the commit message does not provide any context or explanation about why this change was made or what it might imply about the underlying code or system.",False,"The commit message only mentions a typo fix, but it does not describe any functional changes or new behaviors introduced by the code changes. The code diff shows a typo correction in a method name, but it does not introduce any new functionalities or behaviors.",True,"The commit message 'fix typo:metodName' clearly indicates that the change was made to correct a typographical error. The code diff also shows that the word 'metodName' was changed to 'methodName'. This change is small and simple, and its purpose can be easily inferred from the commit message and the code diff. Therefore, there was no need for an additional explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/49ef93602e4db89944a5897fb250121186161d2c,Add external-file-property to LogFileMvcEndpoint  <enter> Add an additional property to LogFileMvcEndpoint to allow log files to be read from an external location. This is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr. <enter>  Fixes   <issue_link>   Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/49ef93602e4db89944a5897fb250121186161d2c,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2015 the original author or authors.
+ * Copyright 2012-2016 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -40,6 +40,7 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
+import org.springframework.boot.bind.RelaxedPropertyResolver;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.ConditionContext;
@@ -180,6 +181,12 @@ public ConditionOutcome getMatchOutcome(ConditionContext context,
 			if (StringUtils.hasText(config)) {
 				return ConditionOutcome.match(""Found logging.path: "" + config);
 			}
+			config = new RelaxedPropertyResolver(environment, ""endpoints.logfile."")
+					.getProperty(""external-file"");
+			if (StringUtils.hasText(config)) {
+				return ConditionOutcome
+						.match(""Found endpoints.logfile.external-file: "" + config);
+			}
 			return ConditionOutcome.noMatch(""Found no log file configuration"");
 		}
 
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.actuate.endpoint.mvc;
 
+import java.io.File;
 import java.io.IOException;
 
 import javax.servlet.ServletException;
@@ -72,6 +73,12 @@ public class LogFileMvcEndpoint implements MvcEndpoint, EnvironmentAware {
 	 */
 	private Boolean sensitive;
 
+	/**
+	 * External Logfile to be accessed. Can be used if the logfile is written by output
+	 * redirect and not by the logging-system itself.
+	 */
+	private File externalFile;
+
 	private Environment environment;
 
 	@Override
@@ -105,6 +112,14 @@ public void setSensitive(Boolean sensitive) {
 		this.sensitive = sensitive;
 	}
 
+	public File getExternalFile() {
+		return this.externalFile;
+	}
+
+	public void setExternalFile(File externalFile) {
+		this.externalFile = externalFile;
+	}
+
 	@Override
 	@SuppressWarnings(""rawtypes"")
 	public Class<? extends Endpoint> getEndpointType() {
@@ -119,23 +134,25 @@ public void invoke(HttpServletRequest request, HttpServletResponse response)
 			return;
 		}
 		Resource resource = getLogFileResource();
+		if (resource != null && !resource.exists()) {
+			if (logger.isDebugEnabled()) {
+				logger.debug(""Log file '"" + resource + ""' does not exist"");
+			}
+			resource = null;
+		}
 		new Handler(resource).handleRequest(request, response);
 	}
 
 	private Resource getLogFileResource() {
+		if (this.externalFile != null) {
+			return new FileSystemResource(this.externalFile);
+		}
 		LogFile logFile = LogFile.get(this.environment);
 		if (logFile == null) {
 			logger.debug(""Missing 'logging.file' or 'logging.path' properties"");
 			return null;
 		}
-		FileSystemResource resource = new FileSystemResource(logFile.toString());
-		if (!resource.exists()) {
-			if (logger.isDebugEnabled()) {
-				logger.debug(""Log file '"" + resource + ""' does not exist"");
-			}
-			return null;
-		}
-		return resource;
+		return new FileSystemResource(logFile.toString());
 	}
 
 	/**
@@ -110,4 +110,15 @@ public void invokeGetsContent() throws Exception {
 		assertThat(response.getContentAsString()).isEqualTo(""--TEST--"");
 	}
 
+	@Test
+	public void invokeGetsContentExternalFile() throws Exception {
+		this.mvc.setExternalFile(this.logFile);
+		MockHttpServletResponse response = new MockHttpServletResponse();
+		MockHttpServletRequest request = new MockHttpServletRequest(HttpMethod.GET.name(),
+				""/logfile"");
+		this.mvc.invoke(request, response);
+		assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value());
+		assertThat(""--TEST--"").isEqualTo(response.getContentAsString());
+	}
+
 }
",True,The commit message refers to the necessity of changes by mentioning that it adds an additional property to LogFileMvcEndpoint to allow log files to be read from an external location. This is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr. This explains why the commit is adding the functionality to handle external log files.,True,"The commit message explains the necessity of the changes by stating that the additional property is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr. This is not a common sense or easy to infer change, but rather a specific use case that the commit message clearly explains.",True,"The commit message explains the motivation for the change by mentioning that the log file can be read from an external location when a launch.script is used to start the boot-application and the log file is written by a redirect of stdout/stderr. This scenario describes a shortcoming of the previous implementation, which did not support reading the log file from an external location.",True,"The commit message 'Add external-file-property to LogFileMvcEndpoint' indicates that the change was made to accommodate a user requirement. The requirement is that log files should be read from an external location, which is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr. This suggests that the change was made to improve the functionality of the software to meet the needs of its users.",True,The commit message directly mentions the improvement it makes to the code by adding an additional property to LogFileMvcEndpoint to allow log files to be read from an external location. This is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr. This clearly describes the objective of the change and the problem it solves.,True,"The commit message 'Add external-file-property to LogFileMvcEndpoint' accurately describes the change made in the code diff. It specifically mentions the addition of a new property 'external-file' to the LogFileMvcEndpoint class, which allows log files to be read from an external location. This is further confirmed by the code diff, which shows the addition of a new private field 'externalFile' and its corresponding getter and setter methods. The commit message also contrasts the before and after state of the code by mentioning the new feature, which is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr.",True,"The commit message explains that the changes are made to allow log files to be read from an external location. This is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr. The code diff shows that a new property 'external-file' is added to LogFileMvcEndpoint, which is used to specify the external log file. This clearly describes the technical principle underpinning the changes, which is to enable the system to read log files from an external location.",True,"The commit message 'Add external-file-property to LogFileMvcEndpoint' clearly describes the change, which is the addition of a new property to the LogFileMvcEndpoint. This property allows log files to be read from an external location, which is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr. The code diff also supports this explanation by showing the addition of a new property 'externalFile' and the corresponding changes in the 'getLogFileResource' method to handle this new property.",False,The commit message does not lack an explanation. It clearly states the reason for the commit: 'Add an additional property to LogFileMvcEndpoint to allow log files to be read from an external location. This is helpful when a launch.script is used to start the boot-application and the logfile is written by a redirect of stdout/stderr.' The code diff also supports this explanation by adding a new property 'externalFile' and modifying the 'getLogFileResource' method to use this property if it is set.
https://github.com/spring-projects/spring-boot/commit/5b2de5c81dc1cc3ab4e8c21ae615bc4d19567347,"Configure PathPattern for RSocket routing  <enter> This commit configures a `PathPatternRouteMatcher` in the RSocket support if spring-web is on the classpath. This `RouteMatcher` implementation is more efficient than the `SimpleRouteMatcher`, which is based on the `AntPathMatcher`. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/5b2de5c81dc1cc3ab4e8c21ae615bc4d19567347,"@@ -28,6 +28,9 @@
 import org.springframework.messaging.rsocket.MessageHandlerAcceptor;
 import org.springframework.messaging.rsocket.RSocketRequester;
 import org.springframework.messaging.rsocket.RSocketStrategies;
+import org.springframework.util.ClassUtils;
+import org.springframework.web.util.pattern.PathPatternParser;
+import org.springframework.web.util.pattern.PathPatternRouteMatcher;
 
 /**
  * {@link EnableAutoConfiguration Auto-configuration} for Spring RSocket support in Spring
@@ -42,12 +45,19 @@
 @AutoConfigureAfter(RSocketStrategiesAutoConfiguration.class)
 public class RSocketMessagingAutoConfiguration {
 
+	private static String PATHPATTERN_ROUTEMATCHER_CLASS = ""org.springframework.web.util.pattern.PathPatternRouteMatcher"";
+
 	@Bean
 	@ConditionalOnMissingBean
 	public MessageHandlerAcceptor messageHandlerAcceptor(
 			RSocketStrategies rSocketStrategies) {
 		MessageHandlerAcceptor acceptor = new MessageHandlerAcceptor();
 		acceptor.setRSocketStrategies(rSocketStrategies);
+		if (ClassUtils.isPresent(PATHPATTERN_ROUTEMATCHER_CLASS, null)) {
+			PathPatternParser parser = new PathPatternParser();
+			parser.setSeparator('.');
+			acceptor.setRouteMatcher(new PathPatternRouteMatcher(parser));
+		}
 		return acceptor;
 	}
 
@@ -26,6 +26,7 @@
 import org.springframework.core.codec.StringDecoder;
 import org.springframework.messaging.rsocket.MessageHandlerAcceptor;
 import org.springframework.messaging.rsocket.RSocketStrategies;
+import org.springframework.web.util.pattern.PathPatternRouteMatcher;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -43,8 +44,11 @@ public class RSocketMessagingAutoConfigurationTests {
 
 	@Test
 	public void shouldCreateDefaultBeans() {
-		this.contextRunner.run((context) -> assertThat(context)
-				.getBeans(MessageHandlerAcceptor.class).hasSize(1));
+		this.contextRunner.run((context) -> {
+			assertThat(context).getBeans(MessageHandlerAcceptor.class).hasSize(1);
+			assertThat(context.getBean(MessageHandlerAcceptor.class).getRouteMatcher())
+					.isInstanceOf(PathPatternRouteMatcher.class);
+		});
 	}
 
 	@Test
",True,"The commit message explains the necessity of changes by referencing a convention (more efficient `PathPatternRouteMatcher` over `SimpleRouteMatcher`), and it also mentions that the change is made if spring-web is on the classpath. This implies that the change is made to improve the existing functionality.",True,"The commit message explains the necessity of the changes by stating that the `PathPatternRouteMatcher` is more efficient than the `SimpleRouteMatcher` and is configured if spring-web is on the classpath. This is not a common sense or easy to infer change, as it involves modifying the codebase to improve performance and functionality.",True,"The commit message explains the motivation for the code change by stating that the `PathPatternRouteMatcher` implementation is more efficient than the `SimpleRouteMatcher`, which is based on the `AntPathMatcher`. Additionally, the message mentions that the change is made if spring-web is on the classpath and closes an issue, which further elaborates the necessity of the changes.",True,"The commit message 'Configure PathPattern for RSocket routing' indicates that the changes were made to improve the efficiency of the RSocket support. The message mentions that a more efficient `PathPatternRouteMatcher` is being configured instead of the `SimpleRouteMatcher`. This could be a response to the need for software development to meet the requirements of users, as the new `PathPatternRouteMatcher` is likely to provide better performance and functionality.",True,"The commit message directly mentions the improvement it makes to the code by stating that it configures a `PathPatternRouteMatcher` which is more efficient than the `SimpleRouteMatcher`. Additionally, the code diff also supports this statement by adding the necessary imports and modifying the `messageHandlerAcceptor` method to use the `PathPatternRouteMatcher` if the `spring-web` library is present on the classpath.",True,"The commit message 'Configure PathPattern for RSocket routing' accurately summarizes the changes made in the code diff. It specifically mentions the addition of a `PathPatternRouteMatcher` and its benefits over the `SimpleRouteMatcher`. Additionally, it highlights the conditional creation of the `PathPatternRouteMatcher` based on the presence of the `spring-web` library, which is a key component of the change.",True,The commit message explains that it configures a `PathPatternRouteMatcher` which is more efficient than the `SimpleRouteMatcher`. This implies that the technical principle underpinning the changes is to improve performance by using a more efficient routing mechanism.,True,"The commit message 'Configure PathPattern for RSocket routing' accurately describes the code changes. It explains that the commit is configuring a `PathPatternRouteMatcher` in the RSocket support if spring-web is on the classpath. This change is functional as it introduces a new behavior: the use of a more efficient `RouteMatcher` implementation, `PathPatternRouteMatcher`, compared to the previous `SimpleRouteMatcher`. The code diff also supports this explanation, showing the addition of the necessary imports and the configuration of the `PathPatternRouteMatcher` in the `messageHandlerAcceptor` method.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit, which is to configure a more efficient `PathPatternRouteMatcher` in the RSocket support. The code diff also supports this explanation by showing the addition of the necessary imports and the configuration of the `PathPatternRouteMatcher` in the `MessageHandlerAcceptor` bean."
https://github.com/junit-team/junit4/commit/d3d7a8b1389e53055d4de9de3aa319053b4a5524,Identify reflection package jdk.internal.reflect  <enter> JDK 9 uses classes from the package jdk.internal.reflect instead of sun.reflect. ,https://api.github.com/repos/junit-team/junit4/commits/d3d7a8b1389e53055d4de9de3aa319053b4a5524,"@@ -247,6 +247,7 @@ private static boolean isTestFrameworkMethod(String methodName) {
     private static final String[] REFLECTION_METHOD_NAME_PREFIXES = {
         ""sun.reflect."",
         ""java.lang.reflect."",
+        ""jdk.internal.reflect."",
         ""org.junit.rules.RunRules.<init>("",
         ""org.junit.rules.RunRules.applyAll("", // calls TestRules
         ""org.junit.runners.RuleContainer.apply("", // calls MethodRules & TestRules
",True,"The commit message refers to a change in the JDK version, stating that JDK 9 uses classes from the package jdk.internal.reflect instead of sun.reflect. This is likely due to a change in the Java platform's internal structure, which is a significant improvement and a standard change in the Java ecosystem. The code diff also supports this, as it adds the new package to the list of packages that the method isTestFrameworkMethod checks.",True,"The commit message explicitly states the reason for the changes, which is the change in the package name from 'sun.reflect' to 'jdk.internal.reflect' in JDK 9. This is not a common sense or easy to infer change, as the package name is a significant part of the code structure and can cause errors if not updated correctly. Therefore, the commit message effectively describes the necessity of the changes.",False,"The commit message does not explicitly describe the necessity of changes or the motivation behind the code change. It only mentions that JDK 9 uses classes from the package jdk.internal.reflect instead of sun.reflect. This could be due to changes in the JDK's internal structure, but the message does not provide any context or explanation about why this change is necessary or beneficial.",True,"The commit message indicates that the changes are made due to the need for software development to meet the requirements of the new JDK version. Specifically, it mentions that JDK 9 uses classes from the package jdk.internal.reflect instead of sun.reflect, which is likely due to the removal or deprecation of the sun.reflect package in JDK 9. This change is necessary to ensure the software continues to function correctly in the new environment.",False,The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only states that JDK 9 uses classes from the package jdk.internal.reflect instead of sun.reflect. This change is more about adapting to the new JDK version's structure rather than fixing a specific defect or improving the code.,True,"The commit message accurately summarizes the change in the code diff. It clearly states that the change is from using classes from the 'sun.reflect' package to using classes from the 'jdk.internal.reflect' package, which is exactly what the diff shows.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that the code is being updated to use classes from the 'jdk.internal.reflect' package instead of 'sun.reflect' package due to changes in JDK 9. However, it does not explain why this change is necessary or what technical principle it is based on.",True,"The commit message accurately describes the code changes by explaining that the code is being updated to use classes from the package jdk.internal.reflect instead of sun.reflect. This change is functional as it modifies the behavior of the code to use a different package for reflection, which is a significant change in the code's functionality.",False,"The commit message does not lack an explanation. It clearly states the reason for the change, which is that JDK 9 uses classes from the package jdk.internal.reflect instead of sun.reflect. This is a significant change that could potentially break the code if not addressed, so an explanation is necessary."
https://github.com/spring-projects/spring-boot/commit/644ab5f3e4319610632b60cbbc4f9141f3ba3470,Align SessionsEndpoint with Spring Session API improvements  <enter> This commit aligns SessionsEndpoint with FindByIndexNameSessionRepository API improvements that simplifies retrieval of sessions by principal name. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/644ab5f3e4319610632b60cbbc4f9141f3ba3470,"@@ -89,9 +89,7 @@ public void sessionsForUsername() throws Exception {
 		sessions.put(sessionOne.getId(), sessionOne);
 		sessions.put(sessionTwo.getId(), sessionTwo);
 		sessions.put(sessionThree.getId(), sessionThree);
-		given(this.sessionRepository.findByIndexNameAndIndexValue(
-				FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, ""alice""))
-						.willReturn(sessions);
+		given(this.sessionRepository.findByPrincipalName(""alice"")).willReturn(sessions);
 		this.mockMvc.perform(get(""/actuator/sessions"").param(""username"", ""alice""))
 				.andExpect(status().isOk())
 				.andDo(document(""sessions/username"",
@@ -52,9 +52,7 @@ public SessionsEndpoint(
 	@ReadOperation
 	public SessionsReport sessionsForUsername(String username) {
 		Map<String, ? extends Session> sessions = this.sessionRepository
-				.findByIndexNameAndIndexValue(
-						FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME,
-						username);
+				.findByPrincipalName(username);
 		return new SessionsReport(sessions);
 	}
 
@@ -48,9 +48,8 @@ public class SessionsEndpointTests {
 
 	@Test
 	public void sessionsForUsername() {
-		given(this.repository.findByIndexNameAndIndexValue(
-				FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, ""user""))
-						.willReturn(Collections.singletonMap(session.getId(), session));
+		given(this.repository.findByPrincipalName(""user""))
+				.willReturn(Collections.singletonMap(session.getId(), session));
 		List<SessionDescriptor> result = this.endpoint.sessionsForUsername(""user"")
 				.getSessions();
 		assertThat(result).hasSize(1);
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -58,9 +58,7 @@ public void sessionsForUsernameWithoutUsernameParam() {
 
 	@Test
 	public void sessionsForUsernameNoResults() {
-		given(repository.findByIndexNameAndIndexValue(
-				FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, ""user""))
-						.willReturn(Collections.emptyMap());
+		given(repository.findByPrincipalName(""user"")).willReturn(Collections.emptyMap());
 		client.get()
 				.uri((builder) -> builder.path(""/actuator/sessions"")
 						.queryParam(""username"", ""user"").build())
@@ -70,9 +68,8 @@ public void sessionsForUsernameNoResults() {
 
 	@Test
 	public void sessionsForUsernameFound() {
-		given(repository.findByIndexNameAndIndexValue(
-				FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, ""user""))
-						.willReturn(Collections.singletonMap(session.getId(), session));
+		given(repository.findByPrincipalName(""user""))
+				.willReturn(Collections.singletonMap(session.getId(), session));
 		client.get()
 				.uri((builder) -> builder.path(""/actuator/sessions"")
 						.queryParam(""username"", ""user"").build())
",True,"The commit message 'Align SessionsEndpoint with Spring Session API improvements' refers to the improvements made in the Spring Session API, specifically the simplification of retrieval of sessions by principal name. This explains why the commit changes the method used to retrieve sessions from 'findByIndexNameAndIndexValue' to 'findByPrincipalName', which aligns the code with the improvements in the Spring Session API.",True,"The commit message 'Align SessionsEndpoint with Spring Session API improvements' does not explicitly state the reason for the changes, but it is easy to infer from the code diff. The changes are made to align SessionsEndpoint with the FindByIndexNameSessionRepository API improvements, specifically the simplification of retrieval of sessions by principal name. This is a common practice to improve code maintainability and consistency, and it is not necessarily a bug fix or a new feature, so it does not require an explicit rationale in the commit message.",True,"The commit message explains the motivation for the code change by mentioning the 'Spring Session API improvements' that simplify retrieval of sessions by principal name. This is a clear indication of the necessity for the changes, as it improves the functionality and simplifies the code.",True,"The commit message 'Align SessionsEndpoint with Spring Session API improvements' indicates that the changes were made to align the code with improvements in the Spring Session API. This suggests that the changes were made to improve the functionality or simplify the code, which could be due to the need for software development to meet the requirements of users or to address problems in the process of software maintenance, such as outdated code.",True,"The commit message 'Align SessionsEndpoint with Spring Session API improvements' directly mentions the improvement it makes to the code by aligning it with the Spring Session API improvements, which simplifies retrieval of sessions by principal name.",True,"The commit message 'Align SessionsEndpoint with Spring Session API improvements' does describe a summary of the changes made in the code diff. It mentions the alignment of SessionsEndpoint with the FindByIndexNameSessionRepository API improvements, which simplifies retrieval of sessions by principal name. This is reflected in the diff where the method calls to findByIndexNameAndIndexValue have been replaced with findByPrincipalName.",True,"The commit message explains that the changes are made to align SessionsEndpoint with Spring Session API improvements, specifically the simplification of retrieval of sessions by principal name. This is a technical principle underpinning the changes, as it improves the usability and efficiency of the code.",True,"The commit message 'Align SessionsEndpoint with Spring Session API improvements' does describe a summary of the changes. It explains that the changes are made to align SessionsEndpoint with the FindByIndexNameSessionRepository API improvements, which simplifies retrieval of sessions by principal name. The code diff also supports this explanation by showing the removal of the findByIndexNameAndIndexValue method and its replacement with the findByPrincipalName method.",False,"The commit message does not lack an explanation. It explicitly mentions the reason for the commit, which is to align SessionsEndpoint with Spring Session API improvements to simplify retrieval of sessions by principal name."
https://github.com/apache/dubbo/commit/a5cc7a26179aab97b3bee3fcc93fe90ac0ecb29f,reduce the level of request data in timeout log ( <pr_link> )  <enter> to control the size of log ,https://api.github.com/repos/apache/dubbo/commits/a5cc7a26179aab97b3bee3fcc93fe90ac0ecb29f,"@@ -225,10 +225,16 @@ private String getTimeoutMessage(boolean scan) {
                 + (sent > 0 ? "" client elapsed: "" + (sent - start)
                 + "" ms, server elapsed: "" + (nowTimestamp - sent)
                 : "" elapsed: "" + (nowTimestamp - start)) + "" ms, timeout: ""
-                + timeout + "" ms, request: "" + request + "", channel: "" + channel.getLocalAddress()
+                + timeout + "" ms, request: "" + (logger.isDebugEnabled() ? request : getRequestWithoutData()) + "", channel: "" + channel.getLocalAddress()
                 + "" -> "" + channel.getRemoteAddress();
     }
 
+    private Request getRequestWithoutData() {
+        Request newRequest = request;
+        newRequest.setData(null);
+        return newRequest;
+    }
+
     private static class TimeoutCheckTask implements TimerTask {
 
         private final Long requestID;
",True,"The commit message 'reduce the level of request data in timeout log' explains the necessity of changes by referencing the size of the log. The code diff shows that the request data is being reduced in size to control the size of the log. This is likely an improvement in prior commits, as the previous version of the code included the full request data in the log, which could have been causing performance issues or filling up logs unnecessarily.",True,"The commit message 'reduce the level of request data in timeout log' clearly explains the reason for the changes. The code diff shows that the request data is being reduced in size to control the size of the log. This is a common practice to prevent logs from becoming too large and causing performance issues. Therefore, the commit message does not need to provide a rationale, as it is easy to infer the necessity of the changes from the message and the code diff.",True,"The commit message 'reduce the level of request data in timeout log' indicates that the change was made to control the size of the log. The code diff shows that the request data is being reduced in size by setting it to null in the getRequestWithoutData() method when the logger is not in debug mode. This change is likely to have been made to prevent the log from becoming too large and potentially causing performance issues, which is a clear motivation for the code change.",True,"The commit message 'reduce the level of request data in timeout log' indicates that the developer made changes to control the size of the log. This could be due to the need to manage the size of the log files to prevent them from becoming too large and causing performance issues. This could be a problem in the process of software maintenance, as outdated or excessive log data can lead to issues with storage, performance, and debugging.",True,"The commit message 'reduce the level of request data in timeout log' directly mentions the improvement it makes to the code, which is reducing the size of the log by not including the full request data.",True,"The commit message 'reduce the level of request data in timeout log' accurately summarizes the change made in the diff. The diff shows that the request data in the timeout log is being reduced by checking if the logger is in debug mode before including the full request data. If the logger is not in debug mode, a new request object is created with the data field set to null, effectively reducing the amount of data logged.",True,"The commit message explains that the changes are made to control the size of the log. This is done by reducing the level of request data in the timeout log. The code diff shows that when the logger is not in debug mode, the request data is replaced with a null value to control the size of the log. This is a technical principle of logging where sensitive or large data is not logged in production environments to prevent performance issues and security risks.",True,"The commit message 'reduce the level of request data in timeout log' accurately summarizes the code changes. The code diff shows that the getTimeoutMessage method has been modified to control the size of the log. Specifically, it checks if the logger is in debug mode. If it is not, it replaces the full request data with a truncated version by calling the getRequestWithoutData method. This new behavior introduces a more concise log message when the logger is not in debug mode, which helps to control the size of the log.",False,"The commit message does not explicitly state the reason for the change, but it does provide context: 'to control the size of log'. However, the change is not just about controlling the size of the log. It's also about reducing the level of request data in the timeout log. The change is not straightforwardly inferable from the diff alone, as it involves adding a new method and modifying the existing one. Therefore, the commit message does not lack an explanation."
https://github.com/apache/dubbo/commit/9396ace4fc00ca8f2e331b49ddabcb1e138e9e1c,fix typo ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/9396ace4fc00ca8f2e331b49ddabcb1e138e9e1c,"@@ -75,39 +75,39 @@ public void setUp() {
     @Test
     public void testRegister() {
         dubboRegistry.register(serviceURL);
-        assertEquals(1, getRegistereds());
+        assertEquals(1, getRegisteredSize());
     }
 
     @Test
     public void testUnRegister() {
-        assertEquals(0, getRegistereds());
+        assertEquals(0, getRegisteredSize());
         dubboRegistry.register(serviceURL);
-        assertEquals(1, getRegistereds());
+        assertEquals(1, getRegisteredSize());
         dubboRegistry.unregister(serviceURL);
-        assertEquals(0, getRegistereds());
+        assertEquals(0, getRegisteredSize());
     }
 
     @Test
     public void testSubscribe() {
         dubboRegistry.register(serviceURL);
-        assertEquals(1, getRegistereds());
+        assertEquals(1, getRegisteredSize());
         dubboRegistry.subscribe(serviceURL, notifyListener);
-        assertEquals(1, getSubscribeds());
+        assertEquals(1, getSubscribedSize());
         assertEquals(1, getNotifiedListeners());
     }
 
     @Test
     public void testUnsubscribe() {
         dubboRegistry.subscribe(serviceURL, notifyListener);
-        assertEquals(1, getSubscribeds());
+        assertEquals(1, getSubscribedSize());
         assertEquals(1, getNotifiedListeners());
         dubboRegistry.unsubscribe(serviceURL, notifyListener);
         assertEquals(0, getNotifiedListeners());
     }
 
     private class MockDubboRegistry extends FailbackRegistry {
 
-        private volatile boolean isAvaliable = false;
+        private volatile boolean isAvailable = false;
 
         public MockDubboRegistry(URL url) {
             super(url);
@@ -116,13 +116,13 @@ public MockDubboRegistry(URL url) {
         @Override
         public void doRegister(URL url) {
             logger.info(""Begin to register: "" + url);
-            isAvaliable = true;
+            isAvailable = true;
         }
 
         @Override
         public void doUnregister(URL url) {
             logger.info(""Begin to ungister: "" + url);
-            isAvaliable = false;
+            isAvailable = false;
         }
 
         @Override
@@ -137,19 +137,19 @@ public void doUnsubscribe(URL url, NotifyListener listener) {
 
         @Override
         public boolean isAvailable() {
-            return isAvaliable;
+            return isAvailable;
         }
     }
 
     private int getNotifiedListeners() {
         return dubboRegistry.getSubscribed().get(serviceURL).size();
     }
 
-    private int getRegistereds() {
+    private int getRegisteredSize() {
         return dubboRegistry.getRegistered().size();
     }
 
-    private int getSubscribeds() {
+    private int getSubscribedSize() {
         return dubboRegistry.getSubscribed().size();
     }
 }
",False,"The commit message only mentions a typo fix without referring to any conventions, standards, improvements in prior commits, or implemented features. It does not provide a clear explanation for the necessity of the changes.",True,"The commit message 'fix typo' does not provide a rationale for the changes made. However, the changes are clear from the diff: the method names 'getRegistereds' and 'getSubscribeds' have been changed to 'getRegisteredSize' and 'getSubscribedSize' respectively, and 'isAvaliable' has been changed to 'isAvailable'. These changes are likely typographical fixes, which is a common reason for commits. Therefore, the commit message does not need to provide additional explanation.",False,"The commit message 'fix typo' does not provide any explanation about the necessity of the changes. It only mentions a typo fix, but it does not elaborate on the error scenario, mention an issue report, or explain any shortcomings of the previous implementation.",False,"The commit message 'fix typo' does not explicitly describe the necessity of changes. It does not mention any user requirements, problems in the process of software maintenance, or changes in the runtime or development environment. The changes in the code are simply fixing a typographical error.",False,"The commit message only mentions a typo fix, but it does not directly describe the objective of the change by mentioning the defects it fixes or the improvements it makes to the code. The code diff shows that the method names have been changed from 'getRegistereds' to 'getRegisteredSize', 'getSubscribeds' to 'getSubscribedSize', and 'isAvaliable' to 'isAvailable'. These changes are likely to improve code readability and consistency, but the commit message does not explicitly state this.",True,"The commit message 'fix typo' does not directly describe the changes made in the code diff. However, the diff shows that the method names 'getRegistereds' and 'getSubscribeds' have been changed to 'getRegisteredSize' and 'getSubscribedSize' respectively. This indicates a renaming of methods, which is a significant change. Additionally, the diff shows a typo correction in the variable name 'isAvaliable' to 'isAvailable'. Therefore, the commit message could be improved to more accurately describe these changes, such as 'Rename methods and correct typo'. However, it does indirectly describe the changes by mentioning the fix of a typo.",False,"The commit message only mentions a typo fix and does not describe any technical principle underpinning the changes. The changes are related to renaming methods and variables to improve code readability and consistency, but this is not explicitly stated in the commit message.",False,"The commit message 'fix typo' does not describe the changes made to the code from a functional perspective. It only mentions a typo fix, but it does not explain the new behaviors introduced by the changes. For example, the message could have mentioned the renaming of 'getRegistereds' to 'getRegisteredSize' and 'getSubscribeds' to 'getSubscribedSize', which would have described the functional changes more accurately.",True,"The commit message 'fix typo' does not provide a clear explanation of the reason for the commit. However, the change is small and simple, specifically correcting a typo in the variable name 'isAvaliable' to 'isAvailable'. This change is self-explanatory and does not require a detailed explanation in the commit message."
https://github.com/square/retrofit/commit/46598adb1da0f6d2498d9f8b815b170bf95fe1f8,Use the annotations directly for parameter handling.  <enter> Before we attempted to normalize the parameter annotations into a name and type model. The introduction of multi-part transfer encodings required something more expressive so the annotation instances themselves were used. This change removes the name and type in favor of using the annotation for everything. <enter> Deprecate the pre-encoded annotations in favor of boolean fields on the corresponding 'regular' annotation. ,https://api.github.com/repos/square/retrofit/commits/46598adb1da0f6d2498d9f8b815b170bf95fe1f8,"@@ -28,20 +28,24 @@
 import retrofit.client.Header;
 import retrofit.client.Request;
 import retrofit.converter.Converter;
+import retrofit.http.Body;
+import retrofit.http.EncodedPath;
+import retrofit.http.EncodedQuery;
+import retrofit.http.EncodedQueryMap;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
 import retrofit.http.Part;
 import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
 import retrofit.mime.FormUrlEncodedTypedOutput;
 import retrofit.mime.MultipartTypedOutput;
 import retrofit.mime.TypedOutput;
 import retrofit.mime.TypedString;
 
-import static retrofit.RestMethodInfo.ParamUsage.QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY_MAP;
-
 final class RequestBuilder implements RequestInterceptor.RequestFacade {
   private final Converter converter;
-  private final String[] paramNames;
-  private final RestMethodInfo.ParamUsage[] paramUsages;
   private final Annotation[] paramAnnotations;
   private final String requestMethod;
   private final boolean isSynchronous;
@@ -61,9 +65,7 @@ final class RequestBuilder implements RequestInterceptor.RequestFacade {
     this.apiUrl = apiUrl;
     this.converter = converter;
 
-    paramNames = methodInfo.requestParamNames;
-    paramUsages = methodInfo.requestParamUsage;
-    paramAnnotations = methodInfo.requestParamAnnotation;
+    paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
     isSynchronous = methodInfo.isSynchronous;
     isObservable = methodInfo.isObservable;
@@ -151,37 +153,75 @@ private void addPathParam(String name, String value, boolean urlEncodeValue) {
   }
 
   @Override public void addQueryParam(String name, String value) {
-    addQueryParam(name, value, true);
+    addQueryParam(name, value, false, true);
   }
 
   @Override public void addEncodedQueryParam(String name, String value) {
-    addQueryParam(name, value, false);
+    addQueryParam(name, value, false, false);
+  }
+
+  private void addQueryParam(String name, Object value, boolean encodeName, boolean encodeValue) {
+    if (value instanceof Iterable) {
+      for (Object iterableValue : (Iterable<?>) value) {
+        if (iterableValue != null) { // Skip null values
+          addQueryParam(name, iterableValue.toString(), encodeName, encodeValue);
+        }
+      }
+    } else if (value.getClass().isArray()) {
+      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+        Object arrayValue = Array.get(value, x);
+        if (arrayValue != null) { // Skip null values
+          addQueryParam(name, arrayValue.toString(), encodeName, encodeValue);
+        }
+      }
+    } else {
+      addQueryParam(name, value.toString(), encodeName, encodeValue);
+    }
   }
 
-  private void addQueryParam(String name, String value, boolean urlEncodeValue) {
+  private void addQueryParam(String name, String value, boolean encodeName, boolean encodeValue) {
     if (name == null) {
       throw new IllegalArgumentException(""Query param name must not be null."");
     }
     if (value == null) {
       throw new IllegalArgumentException(""Query param \"""" + name + ""\"" value must not be null."");
     }
     try {
-      if (urlEncodeValue) {
-        value = URLEncoder.encode(String.valueOf(value), ""UTF-8"");
-      }
       StringBuilder queryParams = this.queryParams;
       if (queryParams == null) {
         this.queryParams = queryParams = new StringBuilder();
       }
 
       queryParams.append(queryParams.length() > 0 ? '&' : '?');
+
+      if (encodeName) {
+        name = URLEncoder.encode(name, ""UTF-8"");
+      }
+      if (encodeValue) {
+        value = URLEncoder.encode(value, ""UTF-8"");
+      }
       queryParams.append(name).append('=').append(value);
     } catch (UnsupportedEncodingException e) {
       throw new RuntimeException(
           ""Unable to convert query parameter \"""" + name + ""\"" value to UTF-8: "" + value, e);
     }
   }
 
+  private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encodeNames,
+      boolean encodeValues) {
+    for (Map.Entry<?, ?> entry : map.entrySet()) {
+      Object entryKey = entry.getKey();
+      if (entryKey == null) {
+        throw new IllegalArgumentException(
+            ""Parameter #"" + (parameterNumber + 1) + "" query map contained null key."");
+      }
+      Object entryValue = entry.getValue();
+      if (entryValue != null) { // Skip null values.
+        addQueryParam(entryKey.toString(), entryValue.toString(), encodeNames, encodeValues);
+      }
+    }
+  }
+
   void setArguments(Object[] args) {
     if (args == null) {
       return;
@@ -191,137 +231,130 @@ void setArguments(Object[] args) {
       count -= 1;
     }
     for (int i = 0; i < count; i++) {
-      String name = paramNames[i];
-      Annotation annotation = paramAnnotations[i];
       Object value = args[i];
-      RestMethodInfo.ParamUsage paramUsage = paramUsages[i];
-      switch (paramUsage) {
-        case PATH:
-          if (value == null) {
-            throw new IllegalArgumentException(
-                ""Path parameter \"""" + name + ""\"" value must not be null."");
-          }
-          addPathParam(name, value.toString());
-          break;
-        case ENCODED_PATH:
-          if (value == null) {
-            throw new IllegalArgumentException(
-                ""Path parameter \"""" + name + ""\"" value must not be null."");
-          }
-          addEncodedPathParam(name, value.toString());
-          break;
-        case QUERY:
-        case ENCODED_QUERY:
-          if (value != null) { // Skip null values.
-            boolean urlEncodeValue = paramUsage == QUERY;
-            if (value instanceof Iterable) {
-              for (Object iterableValue : (Iterable<?>) value) {
-                if (iterableValue != null) { // Skip null values
-                  addQueryParam(name, iterableValue.toString(), urlEncodeValue);
-                }
-              }
-            } else if (value.getClass().isArray()) {
-              for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-                Object arrayValue = Array.get(value, x);
-                if (arrayValue != null) { // Skip null values
-                  addQueryParam(name, arrayValue.toString(), urlEncodeValue);
-                }
+
+      Annotation annotation = paramAnnotations[i];
+      Class<? extends Annotation> annotationType = annotation.annotationType();
+      if (annotationType == Path.class) {
+        Path path = (Path) annotation;
+        String name = path.value();
+        if (value == null) {
+          throw new IllegalArgumentException(
+              ""Path parameter \"""" + name + ""\"" value must not be null."");
+        }
+        addPathParam(name, value.toString(), path.encode());
+      } else if (annotationType == EncodedPath.class) {
+        String name = ((EncodedPath) annotation).value();
+        if (value == null) {
+          throw new IllegalArgumentException(
+              ""Path parameter \"""" + name + ""\"" value must not be null."");
+        }
+        addPathParam(name, value.toString(), false);
+      } else if (annotationType == Query.class) {
+        if (value != null) { // Skip null values.
+          Query query = (Query) annotation;
+          addQueryParam(query.value(), value, query.encodeName(), query.encodeValue());
+        }
+      } else if (annotationType == EncodedQuery.class) {
+        if (value != null) { // Skip null values.
+          EncodedQuery query = (EncodedQuery) annotation;
+          addQueryParam(query.value(), value, false, false);
+        }
+      } else if (annotationType == QueryMap.class) {
+        if (value != null) { // Skip null values.
+          QueryMap queryMap = (QueryMap) annotation;
+          addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
+        }
+      } else if (annotationType == EncodedQueryMap.class) {
+        if (value != null) { // Skip null values.
+          addQueryParamMap(i, (Map<?, ?>) value, false, false);
+        }
+      } else if (annotationType == retrofit.http.Header.class) {
+        if (value != null) { // Skip null values.
+          String name = ((retrofit.http.Header) annotation).value();
+          addHeader(name, value.toString());
+        }
+      } else if (annotationType == Field.class) {
+        String name = ((Field) annotation).value();
+        if (value != null) { // Skip null values.
+          if (value instanceof Iterable) {
+            for (Object iterableValue : (Iterable<?>) value) {
+              if (iterableValue != null) { // Skip null values.
+                formBody.addField(name, iterableValue.toString());
               }
-            } else {
-              addQueryParam(name, value.toString(), urlEncodeValue);
             }
-          }
-          break;
-        case QUERY_MAP:
-        case ENCODED_QUERY_MAP:
-          if (value != null) { // Skip null values.
-            boolean urlEncodeValue = paramUsage == QUERY_MAP;
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                addQueryParam(entry.getKey().toString(), entryValue.toString(), urlEncodeValue);
+          } else if (value.getClass().isArray()) {
+            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+              Object arrayValue = Array.get(value, x);
+              if (arrayValue != null) { // Skip null values.
+                formBody.addField(name, arrayValue.toString());
               }
             }
+          } else {
+            formBody.addField(name, value.toString());
           }
-          break;
-        case HEADER:
-          if (value != null) { // Skip null values.
-            addHeader(name, value.toString());
-          }
-          break;
-        case FIELD:
-          if (value != null) { // Skip null values.
-            if (value instanceof Iterable) {
-              for (Object iterableValue : (Iterable<?>) value) {
-                if (iterableValue != null) { // Skip null values.
-                  formBody.addField(name, iterableValue.toString());
-                }
-              }
-            } else if (value.getClass().isArray()) {
-              for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-                Object arrayValue = Array.get(value, x);
-                if (arrayValue != null) { // Skip null values.
-                  formBody.addField(name, arrayValue.toString());
-                }
-              }
-            } else {
-              formBody.addField(name, value.toString());
+        }
+      } else if (annotationType == FieldMap.class) {
+        if (value != null) { // Skip null values.
+          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+            Object entryKey = entry.getKey();
+            if (entryKey == null) {
+              throw new IllegalArgumentException(
+                  ""Parameter #"" + (i + 1) + "" field map contained null key."");
             }
-          }
-          break;
-        case FIELD_MAP:
-          if (value != null) { // Skip null values.
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                formBody.addField(entry.getKey().toString(), entryValue.toString());
-              }
+            Object entryValue = entry.getValue();
+            if (entryValue != null) { // Skip null values.
+              formBody.addField(entryKey.toString(), entryValue.toString());
             }
           }
-          break;
-        case PART:
-          if (value != null) { // Skip null values.
-            String transferEncoding = ((Part) annotation).encoding();
-            if (value instanceof TypedOutput) {
-              multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
-            } else if (value instanceof String) {
-              multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
-            } else {
-              multipartBody.addPart(name, transferEncoding, converter.toBody(value));
-            }
+        }
+      } else if (annotationType == Part.class) {
+        String name = ((Part) annotation).value();
+        if (value != null) { // Skip null values.
+          String transferEncoding = ((Part) annotation).encoding();
+          if (value instanceof TypedOutput) {
+            multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
+          } else if (value instanceof String) {
+            multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
+          } else {
+            multipartBody.addPart(name, transferEncoding, converter.toBody(value));
           }
-          break;
-        case PART_MAP:
-          if (value != null) { // Skip null values.
-            String transferEncoding = ((PartMap) annotation).encoding();
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              String entryName = entry.getKey().toString();
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                if (entryValue instanceof TypedOutput) {
-                  multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
-                } else if (entryValue instanceof String) {
-                  multipartBody.addPart(entryName, transferEncoding,
-                      new TypedString((String) entryValue));
-                } else {
-                  multipartBody.addPart(entryName, transferEncoding, converter.toBody(entryValue));
-                }
+        }
+      } else if (annotationType == PartMap.class) {
+        if (value != null) { // Skip null values.
+          String transferEncoding = ((PartMap) annotation).encoding();
+          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+            Object entryKey = entry.getKey();
+            if (entryKey == null) {
+              throw new IllegalArgumentException(
+                  ""Parameter #"" + (i + 1) + "" part map contained null key."");
+            }
+            String entryName = entryKey.toString();
+            Object entryValue = entry.getValue();
+            if (entryValue != null) { // Skip null values.
+              if (entryValue instanceof TypedOutput) {
+                multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
+              } else if (entryValue instanceof String) {
+                multipartBody.addPart(entryName, transferEncoding,
+                    new TypedString((String) entryValue));
+              } else {
+                multipartBody.addPart(entryName, transferEncoding, converter.toBody(entryValue));
               }
             }
           }
-          break;
-        case BODY:
-          if (value == null) {
-            throw new IllegalArgumentException(""Body parameter value must not be null."");
-          }
-          if (value instanceof TypedOutput) {
-            body = (TypedOutput) value;
-          } else {
-            body = converter.toBody(value);
-          }
-          break;
-        default:
-          throw new IllegalArgumentException(""Unknown parameter usage: "" + paramUsage);
+        }
+      } else if (annotationType == Body.class) {
+        if (value == null) {
+          throw new IllegalArgumentException(""Body parameter value must not be null."");
+        }
+        if (value instanceof TypedOutput) {
+          body = (TypedOutput) value;
+        } else {
+          body = converter.toBody(value);
+        }
+      } else {
+        throw new IllegalArgumentException(
+            ""Unknown annotation: "" + annotationType.getCanonicalName());
       }
     }
   }
@@ -54,9 +54,7 @@
  * Method parameters can be used to replace parts of the URL by annotating them with
  * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
  * by curly braces (e.g., ""{foo}""). To add items to the query string of a URL use
- * {@link retrofit.http.Query @Query}. If the path or query element has already been URI encoded
- * use {@link retrofit.http.EncodedPath @EncodedPath} or
- * {@link retrofit.http.EncodedQuery @EncodedQuery} to prevent repeated encoding.
+ * {@link retrofit.http.Query @Query}.
  * <p>
  * HTTP requests happen in one of two ways:
  * <ul>
@@ -61,21 +61,6 @@ private enum ResponseType {
   private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
   private static final Pattern PARAM_URL_REGEX = Pattern.compile(""\\{("" + PARAM + "")\\}"");
 
-  enum ParamUsage {
-    PATH,
-    ENCODED_PATH,
-    QUERY,
-    ENCODED_QUERY,
-    QUERY_MAP,
-    ENCODED_QUERY_MAP,
-    FIELD,
-    FIELD_MAP,
-    PART,
-    PART_MAP,
-    BODY,
-    HEADER
-  }
-
   enum RequestType {
     /** No content-specific logic required. */
     SIMPLE,
@@ -105,9 +90,7 @@ enum RequestType {
   boolean isStreaming;
 
   // Parameter-level details
-  String[] requestParamNames;
-  ParamUsage[] requestParamUsage;
-  Annotation[] requestParamAnnotation;
+  Annotation[] requestParamAnnotations;
 
   RestMethodInfo(Method method) {
     this.method = method;
@@ -321,8 +304,7 @@ private static Type getParameterUpperBound(ParameterizedType type) {
   }
 
   /**
-   * Loads {@link #requestParamNames}, {@link #requestParamUsage}, and
-   * {@link #requestParamAnnotation}. Must be called after {@link #parseMethodAnnotations()}.
+   * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
    */
   private void parseParameters() {
     Class<?>[] methodParameterTypes = method.getParameterTypes();
@@ -333,9 +315,7 @@ private void parseParameters() {
       count -= 1; // Callback is last argument when not a synchronous method.
     }
 
-    String[] requestParamNames = new String[count];
-    ParamUsage[] requestParamUsage = new ParamUsage[count];
-    Annotation[] requestParamAnnotation = new Annotation[count];
+    Annotation[] requestParamAnnotations = new Annotation[count];
 
     boolean gotField = false;
     boolean gotPart = false;
@@ -352,52 +332,31 @@ private void parseParameters() {
           if (methodAnnotationType == Path.class) {
             String name = ((Path) methodParameterAnnotation).value();
             validatePathName(i, name);
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.PATH;
           } else if (methodAnnotationType == EncodedPath.class) {
             String name = ((EncodedPath) methodParameterAnnotation).value();
             validatePathName(i, name);
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.ENCODED_PATH;
           } else if (methodAnnotationType == Query.class) {
-            String name = ((Query) methodParameterAnnotation).value();
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.QUERY;
+            // Nothing to do.
           } else if (methodAnnotationType == EncodedQuery.class) {
-            String name = ((EncodedQuery) methodParameterAnnotation).value();
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.ENCODED_QUERY;
+            // Nothing to do.
           } else if (methodAnnotationType == QueryMap.class) {
             if (!Map.class.isAssignableFrom(methodParameterType)) {
               throw parameterError(i, ""@QueryMap parameter type must be Map."");
             }
 
-            requestParamUsage[i] = ParamUsage.QUERY_MAP;
           } else if (methodAnnotationType == EncodedQueryMap.class) {
             if (!Map.class.isAssignableFrom(methodParameterType)) {
               throw parameterError(i, ""@EncodedQueryMap parameter type must be Map."");
             }
 
-            requestParamUsage[i] = ParamUsage.ENCODED_QUERY_MAP;
           } else if (methodAnnotationType == Header.class) {
-            String name = ((Header) methodParameterAnnotation).value();
-
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.HEADER;
+            // Nothing to do.
           } else if (methodAnnotationType == Field.class) {
             if (requestType != RequestType.FORM_URL_ENCODED) {
               throw parameterError(i, ""@Field parameters can only be used with form encoding."");
             }
 
-            String name = ((Field) methodParameterAnnotation).value();
-
             gotField = true;
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.FIELD;
           } else if (methodAnnotationType == FieldMap.class) {
             if (requestType != RequestType.FORM_URL_ENCODED) {
               throw parameterError(i, ""@FieldMap parameters can only be used with form encoding."");
@@ -407,17 +366,12 @@ private void parseParameters() {
             }
 
             gotField = true;
-            requestParamUsage[i] = ParamUsage.FIELD_MAP;
           } else if (methodAnnotationType == Part.class) {
             if (requestType != RequestType.MULTIPART) {
               throw parameterError(i, ""@Part parameters can only be used with multipart encoding."");
             }
 
-            String name = ((Part) methodParameterAnnotation).value();
-
             gotPart = true;
-            requestParamNames[i] = name;
-            requestParamUsage[i] = ParamUsage.PART;
           } else if (methodAnnotationType == PartMap.class) {
             if (requestType != RequestType.MULTIPART) {
               throw parameterError(i,
@@ -428,7 +382,6 @@ private void parseParameters() {
             }
 
             gotPart = true;
-            requestParamUsage[i] = ParamUsage.PART_MAP;
           } else if (methodAnnotationType == Body.class) {
             if (requestType != RequestType.SIMPLE) {
               throw parameterError(i,
@@ -439,23 +392,22 @@ private void parseParameters() {
             }
 
             gotBody = true;
-            requestParamUsage[i] = ParamUsage.BODY;
           } else {
             // This is a non-Retrofit annotation. Skip to the next one.
             continue;
           }
 
-          if (requestParamAnnotation[i] != null) {
+          if (requestParamAnnotations[i] != null) {
             throw parameterError(i,
                 ""Multiple Retrofit annotations found, only one allowed: @%s, @%s."",
-                requestParamAnnotation[i].annotationType().getSimpleName(),
+                requestParamAnnotations[i].annotationType().getSimpleName(),
                 methodAnnotationType.getSimpleName());
           }
-          requestParamAnnotation[i] = methodParameterAnnotation;
+          requestParamAnnotations[i] = methodParameterAnnotation;
         }
       }
 
-      if (requestParamUsage[i] == null) {
+      if (requestParamAnnotations[i] == null) {
         throw parameterError(i, ""No Retrofit annotation found."");
       }
     }
@@ -470,9 +422,7 @@ private void parseParameters() {
       throw methodError(""Multipart method must contain at least one @Part."");
     }
 
-    this.requestParamNames = requestParamNames;
-    this.requestParamUsage = requestParamUsage;
-    this.requestParamAnnotation = requestParamAnnotation;
+    this.requestParamAnnotations = requestParamAnnotations;
   }
 
   private void validatePathName(int index, String name) {
@@ -33,8 +33,12 @@
  * </pre>
  * <p>
  * Path parameters may not be {@code null}.
+ *
+ * @see Path
+ * @deprecated Use {@link Path} with {@link Path#encode() encode = false}.
  */
 @Documented
+@Deprecated
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface EncodedPath {
@@ -31,9 +31,10 @@
  *
  * @see Query
  * @see QueryMap
- * @see EncodedQueryMap
+ * @deprecated Use {@link Query} with {@link Query#encodeValue() encodeValue = false}.
  */
 @Documented
+@Deprecated
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface EncodedQuery {
@@ -31,9 +31,10 @@
  *
  * @see Query
  * @see QueryMap
- * @see EncodedQuery
+ * @deprecated Use {@link QueryMap} with {@link QueryMap#encodeValues() encodeValues = false}.
  */
 @Documented
+@Deprecated
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface EncodedQueryMap {
@@ -24,12 +24,25 @@
 
 /**
  * Named replacement in the URL path. Values are converted to string using
- * {@link String#valueOf(Object)}. Replaced values will be URL encoded.
+ * {@link String#valueOf(Object)} and URL encoded.
  * <p>
+ * Simple example:
  * <pre>
  * &#64;GET(""/image/{id}"")
- * void example(@Path(""id"") int id, ..);
+ * void example(@Path(""id"") int id);
  * </pre>
+ * Calling with {@code foo.example(1)} yields {@code /image/1}.
+ * <p>
+ * Values are URL encoded by default. Disable with {@code encode=false}.
+ * <pre>
+ * &#64;GET(""/user/{name}"")
+ * void encoded(@Path(""name"") String name);
+ *
+ * &#64;GET(""/user/{name}"")
+ * void notEncoded(@Path(value=""name"", encode=false) String name);
+ * </pre>
+ * Calling {@code foo.encoded(""John+Doe"")} yields {@code /user/John%2BDoe} whereas
+ * {@code foo.notEncoded(""John+Doe"")} yields {@code /user/John+Doe}.
  * <p>
  * Path parameters may not be {@code null}.
  */
@@ -38,4 +51,7 @@
 @Target(PARAMETER)
 public @interface Path {
   String value();
+
+  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
+  boolean encode() default true;
 }
@@ -50,14 +50,35 @@
  * </pre>
  * Calling with {@code foo.list(""bar"", ""baz"")} yields
  * {@code /list?category=foo&category=bar}.
+ * <p>
+ * Parameter names are not URL encoded. Specify {@link #encodeName() encodeName=true} to change
+ * this behavior.
+ * <pre>
+ * &#64;GET(""/search"")
+ * void list(@Query(value=""foo+bar"", encodeName=true) String foobar);
+ * </pre>
+ * Calling with {@code foo.list(""baz"")} yields {@code /search?foo%2Bbar=foo}.
+ * <p>
+ * Parameter values are URL encoded by default. Specify {@link #encodeValue() encodeValue=false} to
+ * change this behavior.
+ * <pre>
+ * &#64;GET(""/search"")
+ * void list(@Query(value=""foo"", encodeValue=false) String foo);
+ * </pre>
+ * Calling with {@code foo.list(""foo+foo""))} yields {@code /search?foo=foo+bar}.
  *
- * @see EncodedQuery
  * @see QueryMap
- * @see EncodedQueryMap
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Query {
+  /** The query parameter name. */
   String value();
+
+  /** Specifies whether {@link #value()} is URL encoded. */
+  boolean encodeName() default false;
+
+  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
+  boolean encodeValue() default true;
 }
@@ -26,7 +26,8 @@
  * Query parameter keys and values appended to the URL.
  * <p>
  * Both keys and values are converted to strings using {@link String#valueOf(Object)}. Values are
- * URL encoded and {@code null} will not include the query parameter in the URL.
+ * URL encoded and {@code null} will not include the query parameter in the URL. {@code null} keys
+ * are not allowed.
  * <p>
  * Simple Example:
  * <pre>
@@ -35,13 +36,34 @@
  * </pre>
  * Calling with {@code foo.list(ImmutableMap.of(""foo"", ""bar"", ""kit"", ""kat""))} yields
  * {@code /search?foo=bar&kit=kat}.
+ * <p>
+ * Map keys representing the parameter names are not URL encoded. Specify
+ * {@link #encodeNames() encodeNames=true} to change this behavior.
+ * <pre>
+ * &#64;GET(""/search"")
+ * void list(@QueryMap(encodeNames=true) Map&lt;String, String&gt; filters);
+ * </pre>
+ * Calling with {@code foo.list(ImmutableMap.of(""foo+bar"", ""foo+bar""))} yields
+ * {@code /search?foo%2Bbar=foo}.
+ * <p>
+ * Map values representing parameter values are URL encoded by default. Specify
+ * {@link #encodeValues() encodeValues=false} to change this behavior.
+ * <pre>
+ * &#64;GET(""/search"")
+ * void list(@QueryMap(encodeValues=false) Map&lt;String, String&gt; filters);
+ * </pre>
+ * Calling with {@code foo.list(ImmutableMap.of(""foo"", ""foo+foo""))} yields
+ * {@code /search?foo=foo%2Bbar}.
  *
  * @see Query
- * @see QueryMap
- * @see EncodedQueryMap
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface QueryMap {
+  /** Specifies whether parameter names (keys in the map) are URL encoded. */
+  boolean encodeNames() default false;
+
+  /** Specifies whether parameter values (values in the map) are URL encoded. */
+  boolean encodeValues() default true;
 }
@@ -579,6 +579,26 @@ Response method(@QueryMap List<String> a) {
     }
   }
 
+  @Test public void queryMapRejectsNullKeys() {
+    class Example {
+      @GET(""/"") //
+      Response method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Map<String, String> queryParams = new LinkedHashMap<String, String>();
+    queryParams.put(""ping"", ""pong"");
+    queryParams.put(null, ""kat"");
+
+    try {
+      buildRequest(Example.class, queryParams);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""Parameter #1 query map contained null key."");
+    }
+  }
+
   @Test public void twoBodies() {
     class Example {
       @PUT(""/"") //
@@ -710,6 +730,20 @@ Response method(@Path(""ping"") String ping) {
   }
 
   @Test public void getWithEncodedPathParam() {
+    class Example {
+      @GET(""/foo/bar/{ping}/"") //
+      Response method(@Path(value = ""ping"", encode = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, ""po%20ng"");
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/po%20ng/"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodedPathParamDeprecated() {
     class Example {
       @GET(""/foo/bar/{ping}/"") //
       Response method(@EncodedPath(""ping"") String ping) {
@@ -876,7 +910,7 @@ Response method(@Path(""ping"") String ping) {
   @Test public void getWithQueryParam() {
     class Example {
       @GET(""/foo/bar/"") //
-      Response method(@EncodedQuery(""ping"") String ping) {
+      Response method(@Query(""ping"") String ping) {
         return null;
       }
     }
@@ -888,6 +922,48 @@ Response method(@EncodedQuery(""ping"") String ping) {
   }
 
   @Test public void getWithEncodedQueryParam() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@Query(value = ""ping"", encodeValue = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, ""p+o+n+g"");
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?ping=p+o+n+g"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodeNameQueryParam() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@Query(value = ""pi ng"", encodeName = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, ""pong"");
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?pi+ng=pong"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodeNameEncodedValueQueryParam() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@Query(value = ""pi ng"", encodeName = true, encodeValue = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, ""po+ng"");
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?pi+ng=po+ng"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryParamDeprecated() {
     class Example {
       @GET(""/foo/bar/"") //
       Response method(@EncodedQuery(""ping"") String ping) {
@@ -1081,7 +1157,7 @@ Response method(@QueryMap Map<String, Object> query) {
     assertThat(request.getBody()).isNull();
   }
 
-  @Test public void getWithEncodedQueryParamMap() {
+  @Test public void getWithEncodedQueryParamMapDeprecated() {
     class Example {
       @GET(""/foo/bar/"") //
       Response method(@EncodedQueryMap Map<String, Object> query) {
@@ -1101,6 +1177,67 @@ Response method(@EncodedQueryMap Map<String, Object> query) {
     assertThat(request.getBody()).isNull();
   }
 
+  @Test public void getWithEncodedQueryParamMap() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@QueryMap(encodeValues = false) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put(""kit"", ""k%20t"");
+    params.put(""foo"", null);
+    params.put(""ping"", ""p%20g"");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?kit=k%20t&ping=p%20g"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodeNameQueryParamMap() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(@QueryMap(encodeNames = true) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put(""k it"", ""k t"");
+    params.put(""fo o"", null);
+    params.put(""pi ng"", ""p g"");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?k+it=k+t&pi+ng=p+g"");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithEncodeNameEncodedValueQueryParamMap() {
+    class Example {
+      @GET(""/foo/bar/"") //
+      Response method(
+          @QueryMap(encodeNames = true, encodeValues = false) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put(""k it"", ""k%20t"");
+    params.put(""fo o"", null);
+    params.put(""pi ng"", ""p%20g"");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.getMethod()).isEqualTo(""GET"");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo(""http://example.com/foo/bar/?k+it=k%20t&pi+ng=p%20g"");
+    assertThat(request.getBody()).isNull();
+  }
+
   @Test public void encodedQueryMapMustBeAMap() {
     class Example {
       @GET(""/"") //
@@ -1314,6 +1451,27 @@ Response method(@PartMap(encoding = ""8-bit"") Map<String, Object> parts) {
         .endsWith(""\r\nkat"");
   }
 
+  @Test public void multipartPartMapRejectsNullKeys() {
+    class Example {
+      @Multipart //
+      @POST(""/foo/bar/"") //
+      Response method(@PartMap Map<String, Object> parts) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put(""ping"", ""pong"");
+    params.put(null, ""kat"");
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""Parameter #1 part map contained null key."");
+    }
+  }
+
   @Test public void multipartNullRemovesPart() {
     class Example {
       @Multipart //
@@ -1438,6 +1596,28 @@ Response method(@FieldMap Map<String, Object> fieldMap) {
     assertTypedBytes(request.getBody(), ""kit=kat&ping=pong"");
   }
 
+  @Test public void fieldMapRejectsNullKeys() {
+    class Example {
+      @FormUrlEncoded //
+      @POST(""/"") //
+      Response method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+    fieldMap.put(""kit"", ""kat"");
+    fieldMap.put(""foo"", null);
+    fieldMap.put(null, ""pong"");
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""Parameter #1 field map contained null key."");
+    }
+  }
+
   @Test public void fieldMapMustBeAMap() {
     class Example {
       @FormUrlEncoded //
@@ -1633,12 +1813,8 @@ private static void assertTypedBytes(TypedOutput bytes, String expected) {
   private static final Converter GSON = new GsonConverter(new Gson());
 
   private Request buildRequest(Class<?> cls, Object... args) {
-    Method[] methods = cls.getDeclaredMethods();
-    if (methods.length != 1) {
-      throw new IllegalStateException(""More than one method declared."");
-    }
-
-    RestMethodInfo methodInfo = new RestMethodInfo(methods[0]);
+    Method method = TestingUtils.onlyMethod(cls);
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
     RequestBuilder builder = new RequestBuilder(""http://example.com/"", methodInfo, GSON);
@@ -51,7 +51,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -63,7 +63,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -75,7 +75,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -87,7 +87,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -99,7 +99,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -111,7 +111,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
 
@@ -129,7 +129,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.responseObjectType).isEqualTo(
@@ -143,7 +143,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isTrue();
     assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
@@ -156,7 +156,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isTrue();
 
@@ -171,7 +171,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
@@ -185,7 +185,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
@@ -200,7 +200,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.isObservable).isTrue();
@@ -214,7 +214,7 @@ class Example {
       }
     }
 
-    Method method = TestingUtils.getMethod(Example.class, ""a"");
+    Method method = TestingUtils.onlyMethod(Example.class);
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
     assertThat(methodInfo.isObservable).isTrue();
@@ -11,13 +11,12 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class TestingUtils {
-  public static Method getMethod(Class c, String name) {
-    for (Method method : c.getDeclaredMethods()) {
-      if (method.getName().equals(name)) {
-        return method;
-      }
+  public static Method onlyMethod(Class c) {
+    Method[] declaredMethods = c.getDeclaredMethods();
+    if (declaredMethods.length == 1) {
+      return declaredMethods[0];
     }
-    throw new IllegalArgumentException(""Unknown method '"" + name + ""' on "" + c);
+    throw new IllegalArgumentException(""More than one method declared."");
   }
 
   public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
",True,"The commit message refers to the necessity of changes by referencing the introduction of multi-part transfer encodings, which required a more expressive way of handling parameter annotations. The change described in the commit message is to use the annotation instances themselves for everything, instead of a name and type model, which is explained as a way to handle the new requirements.",True,"The commit message refers to the use of annotations directly for parameter handling, which implies that the changes made are necessary for the proper functioning of the code. This is inferred from the context of the message and the code diff, where the annotations are used to determine how to handle the parameters in the HTTP request.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that the introduction of multi-part transfer encodings required something more expressive, so the annotation instances themselves were used. This change removes the name and type in favor of using the annotation for everything, which is explained as a way to handle the new requirements.",True,The commit message mentions that the introduction of multi-part transfer encodings required a more expressive way of handling parameter annotations. This indicates that the changes were made to accommodate new requirements or changes in the environment.,True,"The commit message directly mentions the change that uses the annotations directly for parameter handling, which improves the expressiveness of the code by allowing for multi-part transfer encodings.",True,"The commit message 'Use the annotations directly for parameter handling' accurately describes the change in the code diff. The diff shows that the code is now using the annotations directly for parameter handling, instead of normalizing them into a name and type model. This change removes the need for the name and type in favor of using the annotation for everything.",True,"The commit message explains that the annotations themselves are now used for parameter handling, which is a technical principle underpinning the changes. This is evident in the code diff where the annotation instances are used to determine the type of parameter handling.",True,"The commit message expresses a change in the way parameters are handled, specifically mentioning the use of annotations directly and the removal of the name and type model. This change is also reflected in the code diff, where the annotations themselves are used for parameter handling instead of a separate name and type model.",False,"The commit message does not explicitly explain the reason for the change, but it can be inferred from the code diff. The change is removing the use of a name and type model for parameter annotations and instead using the annotation instances themselves. This is likely due to the introduction of multi-part transfer encodings, which require a more expressive way of handling parameter annotations."
https://github.com/junit-team/junit4/commit/7e77e49c40afb951ae5a5cbdf75ebb4a478e2bb7,Updated README.html ,https://api.github.com/repos/junit-team/junit4/commits/7e77e49c40afb951ae5a5cbdf75ebb4a478e2bb7,"@@ -12,14 +12,13 @@ <h1>
 <b><font color=""#00CC00"">J</font><font color=""#FF0000"">U</font><font color=""#000000"">nit
 4.5</b></h1> 
 <br>Brought to you by <a href=""http://www.threeriversinstitute.org"">Kent Beck</a>, Erich 
-
 Gamma, and <a href=""http://david.saff.net"">David Saff</a>. 
 <br>FAQ edited by <a href=""http://www.clarkware.com"">Mike Clark</a>. Web mastering by Erik 
 Meade.
 <br>(see also <a href=""http://www.junit.org"">JUnit.org</a>)
 
 <hr WIDTH=""100%"">
-<br>[old date] 18 July 2007
+<br>8 August 2008
 <p>JUnit is a simple framework to write repeatable tests. It is an instance
 of the xUnit architecture for unit testing frameworks.
 <ul>
@@ -44,6 +43,95 @@ <h1>
 <a NAME=""Summary of"">
 <h2>Summary of Changes in version 4.5</h2>
 
+<h3>Installation</h3>
+
+<ul>
+<li>We are releasing <code>junit-4.5.jar</code>, which contains all the classes
+necessary to run JUnit, and <code>junit-dep-4.5.jar</code>, which leaves out
+hamcrest classes, for developers who already use hamcrest outside of
+JUnit.</li>
+</ul>
+
+<h3>Basic JUnit operation</h3>
+
+<ul>
+<li><p>JUnitCore now more often exits with the correct exit code (0 for
+success, 1 for failure)</p></li>
+<li><p>Badly formed test classes (exceptions in constructors, classes
+without tests, multiple constructors, Suite without @SuiteClasses)
+produce more helpful error messages</p></li>
+<li><p>Test classes whose only test methods are inherited from superclasses
+now run.</p></li>
+<li><p>Optimization to annotation processing can cut JUnit overhead by more than half
+on large test classes, especially when using Theories.  [Bug 1796847]</p></li>
+<li><p>A failing assumption in a constructor ignores the class</p></li>
+<li><p>Correct results when comparing the string ""null"" with potentially
+null values.  [Bug 1857283]</p></li>
+<li><p>Annotating a class with <code>@RunWith(JUnit4.class)</code> will always invoke the
+default JUnit 4 runner in the current version of JUnit.  This default changed
+from <code>JUnit4ClassRunner</code> in 4.4 to <code>BlockJUnit4ClassRunner</code> in 4.5 (see below),
+and may change again.</p></li>
+</ul>
+
+<h3>Extension</h3>
+
+<ul>
+<li><p><code>BlockJUnit4Runner</code> is a new implementation of the standard JUnit 4
+test class functionality.  In contrast to <code>JUnit4ClassRunner</code> (the old
+implementation):</p>
+
+<ul>
+<li><p><code>BlockJUnit4Runner</code> has a much simpler implementation based on
+Statements, allowing new operations to be inserted into the
+appropriate point in the execution flow.</p></li>
+<li><p><code>BlockJUnit4Runner</code> is published, and extension and reuse are
+encouraged, whereas <code>JUnit4ClassRunner</code> was in an internal package,
+and is now deprecated.</p></li>
+</ul></li>
+<li><p><code>ParentRunner</code> is a base class for runners that iterate over
+a list of ""children"", each an object representing a test or suite to run.
+<code>ParentRunner</code> provides filtering, sorting, <code>@BeforeClass</code>, <code>@AfterClass</code>,
+and method validation to subclasses.</p></li>
+<li><p><code>TestClass</code> wraps a class to be run, providing efficient, repeated access
+to all methods with a given annotation.</p></li>
+<li><p>The new <code>RunnerBuilder</code> API allows extending the behavior of
+Suite-like custom runners.</p></li>
+<li><p><code>AssumptionViolatedException.toString()</code> is more informative</p></li>
+</ul>
+
+<h3>Extra Runners</h3>
+
+<ul>
+<li><p><code>Parameterized.eachOne()</code> has been removed</p></li>
+<li><p>New runner <code>Enclosed</code> runs all static inner classes of an outer class.</p></li>
+</ul>
+
+<h3>Theories</h3>
+
+<ul>
+<li><p><code>@Before</code> and <code>@After</code> methods are run before and after each set of attempted parameters
+on a Theory, and each set of parameters is run on a new instance of the test class.</p></li>
+<li><p>Exposed API's <code>ParameterSignature.getType()</code> and <code>ParameterSignature.getAnnotations()</code></p></li>
+<li><p>An array of data points can be introduced by a field or method
+marked with the new annotation <code>@DataPoints</code></p></li>
+<li><p>The Theories custom runner has been refactored to make it faster and
+easier to extend</p></li>
+</ul>
+
+<h3>Development</h3>
+
+<ul>
+<li><p>Source has been split into directories <code>src/main/java</code> and
+<code>src/test/java</code>, making it easier to exclude tests from builds, and
+making JUnit more maven-friendly</p></li>
+<li><p>Test classes in <code>org.junit.tests</code> have been organized into
+subpackages, hopefully making finding tests easier.</p></li>
+<li><p><code>ResultMatchers</code> has more informative descriptions.</p></li>
+<li><p><code>TestSystem</code> allows testing return codes and other system-level interactions.</p></li>
+</ul>
+
+<h2>Summary of Changes in version 4.4</h2>
+
 <p>JUnit is designed to efficiently capture developers' intentions about
 their code, and quickly check their code matches those intentions.
 Over the last year, we've been talking about what things developers
",True,"The commit message does not explicitly reference a convention, standard, or improvement in prior commits. However, it does describe the necessity of changes by referencing the updates made in the README.html file, specifically mentioning the changes in version 4.5. This includes new features, improvements, and bug fixes, which are all reasons for updating the README file to reflect these changes.",False,"The commit message 'Updated README.html' does not provide a clear explanation of the necessity of the changes made in the code diff. The diff shows updates to the README.html file, including changes to the date and a summary of changes in version 4.5. However, the commit message does not explain why these changes were made or what specific updates were included in version 4.5. Therefore, the commit message does not describe the necessity of the changes.",True,"The commit message does not explicitly describe the necessity of changes, but the code diff reveals that the README.html file has been updated to include a summary of changes in version 4.5. This summary describes various improvements and bug fixes made in the new version, such as more helpful error messages for badly formed test classes, optimizations to annotation processing, and new features like the BlockJUnit4Runner and ParentRunner classes. These changes are likely to improve the functionality and efficiency of JUnit, and the summary provides a clear explanation of these improvements. Therefore, the commit message indirectly elaborates the motivation of the code change by describing the benefits and improvements of the new version.",True,"The commit message 'Updated README.html' and the diff indicate that the changes were made to the README.html file. The diff shows that the date in the README.html file was updated from '18 July 2007' to '8 August 2008'. This could suggest that the change was made due to a requirement for software development to reflect the current date, which is a common practice to ensure the information in the documentation is up-to-date.",True,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. However, the code diff indicates that the README.html file has been updated to include a summary of changes in version 4.5. This summary includes several improvements and fixes, such as optimizations to annotation processing, more helpful error messages for badly formed test classes, and a new implementation of the standard JUnit 4 test class functionality. Therefore, the commit message indirectly describes the objective of the change by mentioning the updates to the README.html file, which in turn describes the improvements and fixes made to the code.",True,"The commit message 'Updated README.html' does contain an expression that describes a summary of what changes by being a summary of the diffs. The diff shows that the README.html file has been updated, specifically the date has been changed from '18 July 2007' to '8 August 2008'. Additionally, the diff includes a detailed summary of changes in version 4.5 of JUnit, which lists the key components of the change such as installation, basic JUnit operation, extension, extra runners, theories, and development. This summary provides a clear overview of the changes made in the commit.",False,"The commit message only mentions updating the README.html file and the changes in the diff are related to updating the version number, release date, and adding a summary of changes in version 4.5. However, the commit message does not contain an expression that describes a technical principle underpinning the changes.",True,"The commit message 'Updated README.html' does contain an expression that describes a summary of what changes. The code diff shows that the README.html file has been updated, and the changes include adding a section for version 4.5 of JUnit. This section summarizes the changes made in version 4.5, which include improvements to installation, basic JUnit operation, extension, extra runners, theories, and development. These changes are described in a functional perspective, explaining new behaviors introduced, such as the new BlockJUnit4Runner, ParentRunner, TestClass, RunnerBuilder, Enclosed runner, and @DataPoints annotation. Therefore, the commit message effectively summarizes the changes made to the README.html file.",True,"The commit message only mentions the update of the README.html file, but the diff shows that significant changes have been made to the file, including the addition of a new section summarizing changes in version 4.5. These changes are not just a simple update, such as removing a space, but rather they are substantial and require an explanation. Therefore, the commit message lacks an expression explaining the reason for the commit."
https://github.com/spring-projects/spring-boot/commit/a79f71cbe802a8d87bc22e6eba67553ccedd54a7,Add @IntegrationComponentScan auto-configuration  <enter> Update Spring Integration auto-configuration so that `@IntegrationComponentScan` from `AutoConfigurationPackages` is implicitly applied. Prior to this commit `@MessagingGateway` interfaces would only get picked up if `@IntegrationComponentScan` was added alongside with the `@SpringBootApplication`. <enter>  Fixes   <issue_link>   Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/a79f71cbe802a8d87bc22e6eba67553ccedd54a7,"@@ -16,11 +16,15 @@
 
 package org.springframework.boot.autoconfigure.integration;
 
+import java.util.Map;
+
 import javax.management.MBeanServer;
 
 import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
+import org.springframework.beans.factory.support.BeanDefinitionRegistry;
+import org.springframework.boot.autoconfigure.AutoConfigurationPackages;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
@@ -31,9 +35,15 @@
 import org.springframework.context.EnvironmentAware;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Import;
 import org.springframework.core.env.Environment;
+import org.springframework.core.type.AnnotationMetadata;
+import org.springframework.core.type.StandardAnnotationMetadata;
+import org.springframework.integration.annotation.IntegrationComponentScan;
 import org.springframework.integration.config.EnableIntegration;
 import org.springframework.integration.config.EnableIntegrationManagement;
+import org.springframework.integration.config.IntegrationComponentScanRegistrar;
+import org.springframework.integration.gateway.GatewayProxyFactoryBean;
 import org.springframework.integration.jmx.config.EnableIntegrationMBeanExport;
 import org.springframework.integration.monitor.IntegrationMBeanExporter;
 import org.springframework.integration.support.management.IntegrationManagementConfigurer;
@@ -107,6 +117,46 @@ protected static class IntegrationManagementConfiguration {
 		@Configuration
 		@EnableIntegrationManagement(defaultCountsEnabled = ""true"", defaultStatsEnabled = ""true"")
 		protected static class EnableIntegrationManagementConfiguration {
+		}
+
+	}
+
+	@ConditionalOnMissingBean(GatewayProxyFactoryBean.class)
+	@Import(AutoIntegrationComponentScanRegistrar.class)
+	protected static class IntegrationComponentScanAutoConfiguration {
+
+	}
+
+	private static class AutoIntegrationComponentScanRegistrar
+			extends IntegrationComponentScanRegistrar {
+
+		@Override
+		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
+				final BeanDefinitionRegistry registry) {
+			StandardAnnotationMetadata metadata = new StandardAnnotationMetadata(
+					IntegrationComponentScanConfiguration.class, true) {
+
+				@Override
+				public Map<String, Object> getAnnotationAttributes(
+						String annotationName) {
+					Map<String, Object> annotationAttributes = super.getAnnotationAttributes(
+							annotationName);
+					if (IntegrationComponentScan.class.getName().equals(annotationName)) {
+						BeanFactory beanFactory = (BeanFactory) registry;
+						if (AutoConfigurationPackages.has(beanFactory)) {
+							annotationAttributes.put(""value"",
+									AutoConfigurationPackages.get(beanFactory));
+						}
+					}
+					return annotationAttributes;
+				}
+
+			};
+			super.registerBeanDefinitions(metadata, registry);
+		}
+
+		@IntegrationComponentScan
+		private class IntegrationComponentScanConfiguration {
 
 		}
 
@@ -30,6 +30,9 @@
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Primary;
+import org.springframework.integration.annotation.IntegrationComponentScan;
+import org.springframework.integration.annotation.MessagingGateway;
+import org.springframework.integration.gateway.RequestReplyExchanger;
 import org.springframework.integration.support.channel.HeaderChannelRegistry;
 import org.springframework.integration.support.management.IntegrationManagementConfigurer;
 import org.springframework.jmx.export.MBeanExporter;
@@ -61,24 +64,34 @@ public void close() {
 	@Test
 	public void integrationIsAvailable() {
 		load();
-		assertThat(this.context.getBean(HeaderChannelRegistry.class)).isNotNull();
+		assertThat(this.context.getBean(TestGateway.class)).isNotNull();
+		assertThat(this.context.getBean(IntegrationAutoConfiguration.IntegrationComponentScanAutoConfiguration.class))
+				.isNotNull();
 	}
 
 	@Test
-	public void parentContext() {
+	public void explicitIntegrationComponentScan() {
 		this.context = new AnnotationConfigApplicationContext();
-		this.context.register(JmxAutoConfiguration.class,
+		this.context.register(IntegrationComponentScanConfiguration.class,
+				JmxAutoConfiguration.class,
 				IntegrationAutoConfiguration.class);
 		this.context.refresh();
+		assertThat(this.context.getBean(TestGateway.class)).isNotNull();
+		assertThat(this.context.getBeansOfType(IntegrationAutoConfiguration.IntegrationComponentScanAutoConfiguration.class))
+				.isEmpty();
+	}
+
+	@Test
+	public void parentContext() {
+		load();
 		AnnotationConfigApplicationContext parent = this.context;
 		this.context = new AnnotationConfigApplicationContext();
 		this.context.setParent(parent);
 		this.context.register(JmxAutoConfiguration.class,
 				IntegrationAutoConfiguration.class);
+		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, ""SPRING_JMX_DEFAULT_DOMAIN=org.foo"");
 		this.context.refresh();
 		assertThat(this.context.getBean(HeaderChannelRegistry.class)).isNotNull();
-		((ConfigurableApplicationContext) this.context.getParent()).close();
-		this.context.close();
 	}
 
 	@Test
@@ -151,4 +164,15 @@ public MBeanExporter myMBeanExporter() {
 
 	}
 
+	@Configuration
+	@IntegrationComponentScan
+	static class IntegrationComponentScanConfiguration {
+
+	}
+
+	@MessagingGateway
+	public interface TestGateway extends RequestReplyExchanger {
+
+	}
+
 }
",True,"The commit message refers to the necessity of changes by mentioning the issue that the `@MessagingGateway` interfaces would only get picked up if `@IntegrationComponentScan` was added alongside with the `@SpringBootApplication`. This is a standard practice in Spring Integration, and the commit message explains that the changes are being made to update the Spring Integration auto-configuration so that `@IntegrationComponentScan` from `AutoConfigurationPackages` is implicitly applied, thereby improving the usability and convenience of the framework.",True,"The commit message explains the necessity of changes by stating that prior to this commit, `@MessagingGateway` interfaces would only get picked up if `@IntegrationComponentScan` was added alongside with the `@SpringBootApplication`. This is not a common sense or easy to infer change, but rather a specific requirement of the Spring Integration auto-configuration. The code diff also supports this explanation by showing the addition of the `@IntegrationComponentScan` annotation to the `AutoIntegrationComponentScanRegistrar` class, which is used to implicitly apply `@IntegrationComponentScan` from `AutoConfigurationPackages`.",True,"The commit message explains the motivation for the code change by mentioning the issue that was being addressed. It states that prior to this commit, '@MessagingGateway' interfaces would only get picked up if '@IntegrationComponentScan' was added alongside with the '@SpringBootApplication'. This is a clear indication of a shortcoming in the previous implementation. The message also mentions the issue report and the pull request that it fixes, which further supports the necessity of the changes.",True,"The commit message indicates that the changes were made to update Spring Integration auto-configuration. The necessity of changes is described in the message itself, which states that prior to this commit, `@MessagingGateway` interfaces would only get picked up if `@IntegrationComponentScan` was added alongside with the `@SpringBootApplication`. This implies that the changes were made to address a problem in the software maintenance process, specifically to improve the usability and functionality of the software.",True,The commit message directly mentions the improvement it makes to the code by stating that it updates Spring Integration auto-configuration so that `@IntegrationComponentScan` from `AutoConfigurationPackages` is implicitly applied. This change ensures that `@MessagingGateway` interfaces are picked up even if `@IntegrationComponentScan` is not added alongside `@SpringBootApplication`.,True,"The commit message describes the changes made to the Spring Integration auto-configuration. It mentions the addition of '@IntegrationComponentScan' auto-configuration, which was previously only applied if '@IntegrationComponentScan' was added alongside '@SpringBootApplication'. This contrasts the behavior before and after the commit, making it a clear and accurate summary of the changes.",True,"The commit message explains that the changes are made to automatically apply `@IntegrationComponentScan` from `AutoConfigurationPackages` when `@SpringBootApplication` is used. This is a technical principle that allows for more convenient configuration of Spring Integration components, as it eliminates the need for explicit component scanning in certain scenarios.",True,"The commit message 'Add @IntegrationComponentScan auto-configuration' accurately summarizes the changes made to the code. It explains that the Spring Integration auto-configuration has been updated to implicitly apply `@IntegrationComponentScan` from `AutoConfigurationPackages`. This change ensures that `@MessagingGateway` interfaces are picked up even when `@IntegrationComponentScan` is not explicitly added alongside `@SpringBootApplication`. This introduces new behavior in the application, allowing for more seamless integration of components.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Update Spring Integration auto-configuration so that `@IntegrationComponentScan` from `AutoConfigurationPackages` is implicitly applied. Prior to this commit `@MessagingGateway` interfaces would only get picked up if `@IntegrationComponentScan` was added alongside with the `@SpringBootApplication`.' This is a significant change that requires explanation, even though the code diff might suggest it's a small change."
https://github.com/spring-projects/spring-boot/commit/b0579c1cf38aa6815ee180a2e61640cfbc2447d2,"Ensure JPA vendor properties are period separated  <enter> If you bind to Map<String,Object> you get a nested Map instead of period-separated keys. This change just makes JpaProperties expose a Map<String,String> so the keys are sane. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/b0579c1cf38aa6815ee180a2e61640cfbc2447d2,"@@ -137,7 +137,7 @@ public Builder persistenceUnit(String persistenceUnit) {
 		 * @param properties the properties to use
 		 * @return the builder for fluent usage
 		 */
-		public Builder properties(Map<String, Object> properties) {
+		public Builder properties(Map<String, String> properties) {
 			this.properties.putAll(properties);
 			return this;
 		}
@@ -71,13 +71,13 @@ protected AbstractJpaVendorAdapter createJpaVendorAdapter() {
 	}
 
 	@Override
-	protected Map<String, Object> getVendorProperties() {
+	protected Map<String, String> getVendorProperties() {
 		return this.properties.getInitialHibernateProperties(this.dataSource);
 	}
 
 	@Override
 	protected EntityManagerFactoryBeanCallback getVendorCallback() {
-		final Map<String, Object> map = this.properties
+		final Map<String, String> map = this.properties
 				.getHibernateProperties(this.dataSource);
 		return new EntityManagerFactoryBeanCallback() {
 			@Override
@@ -93,18 +93,18 @@ public void execute(
 	private static class DeferredSchemaAction implements
 			ApplicationListener<ContextRefreshedEvent> {
 
-		private Map<String, Object> map;
+		private Map<String, String> map;
 		private LocalContainerEntityManagerFactoryBean factory;
 
 		public DeferredSchemaAction(LocalContainerEntityManagerFactoryBean factory,
-				Map<String, Object> map) {
+				Map<String, String> map) {
 			this.factory = factory;
 			this.map = map;
 		}
 
 		@Override
 		public void onApplicationEvent(ContextRefreshedEvent event) {
-			String ddlAuto = (String) this.map.get(""hibernate.hbm2ddl.auto"");
+			String ddlAuto = this.map.get(""hibernate.hbm2ddl.auto"");
 			if (ddlAuto == null || ""none"".equals(ddlAuto)) {
 				return;
 			}
@@ -105,7 +105,7 @@ public LocalContainerEntityManagerFactoryBean entityManagerFactory(
 
 	protected abstract AbstractJpaVendorAdapter createJpaVendorAdapter();
 
-	protected abstract Map<String, Object> getVendorProperties();
+	protected abstract Map<String, String> getVendorProperties();
 
 	protected abstract EntityManagerFactoryBuilder.EntityManagerFactoryBeanCallback getVendorCallback();
 
@@ -40,7 +40,7 @@ public class JpaProperties {
 
 	private static final Log logger = LogFactory.getLog(JpaProperties.class);
 
-	private Map<String, Object> properties = new HashMap<String, Object>();
+	private Map<String, String> properties = new HashMap<String, String>();
 
 	private String databasePlatform;
 
@@ -52,11 +52,11 @@ public class JpaProperties {
 
 	private Hibernate hibernate = new Hibernate();
 
-	public Map<String, Object> getProperties() {
+	public Map<String, String> getProperties() {
 		return this.properties;
 	}
 
-	public void setProperties(Map<String, Object> properties) {
+	public void setProperties(Map<String, String> properties) {
 		this.properties = properties;
 	}
 
@@ -107,7 +107,7 @@ public void setHibernate(Hibernate hibernate) {
 	 * @param dataSource the DataSource in case it is needed to determine the properties
 	 * @return some Hibernate properties for configuration
 	 */
-	public Map<String, Object> getInitialHibernateProperties(DataSource dataSource) {
+	public Map<String, String> getInitialHibernateProperties(DataSource dataSource) {
 		return this.hibernate.getAdditionalProperties(this.properties);
 	}
 
@@ -116,7 +116,7 @@ public Map<String, Object> getInitialHibernateProperties(DataSource dataSource)
 	 * @param dataSource the DataSource in case it is needed to determine the properties
 	 * @return some Hibernate properties for configuration
 	 */
-	public Map<String, Object> getHibernateProperties(DataSource dataSource) {
+	public Map<String, String> getHibernateProperties(DataSource dataSource) {
 		return this.hibernate
 				.getDeferredAdditionalProperties(this.properties, dataSource);
 	}
@@ -158,7 +158,7 @@ public boolean isDeferDdl() {
 			return this.deferDdl;
 		}
 
-		private String getDeferredDdlAuto(Map<String, Object> existing,
+		private String getDeferredDdlAuto(Map<String, String> existing,
 				DataSource dataSource) {
 			if (!this.deferDdl) {
 				return ""none"";
@@ -169,7 +169,7 @@ private String getDeferredDdlAuto(Map<String, Object> existing,
 				return ddlAuto;
 			}
 			if (isAlreadyProvided(existing, ""hbm2ddl.auto"")) {
-				return (String) existing.get(""hibernate.hbm2ddl.auto"");
+				return existing.get(""hibernate.hbm2ddl.auto"");
 			}
 			return ""none"";
 		}
@@ -178,16 +178,16 @@ public void setDdlAuto(String ddlAuto) {
 			this.ddlAuto = ddlAuto;
 		}
 
-		private Map<String, Object> getDeferredAdditionalProperties(
-				Map<String, Object> properties, DataSource dataSource) {
-			Map<String, Object> deferred = getAdditionalProperties(properties);
+		private Map<String, String> getDeferredAdditionalProperties(
+				Map<String, String> properties, DataSource dataSource) {
+			Map<String, String> deferred = getAdditionalProperties(properties);
 			deferred.put(""hibernate.hbm2ddl.auto"",
 					getDeferredDdlAuto(properties, dataSource));
 			return deferred;
 		}
 
-		private Map<String, Object> getAdditionalProperties(Map<String, Object> existing) {
-			Map<String, Object> result = new HashMap<String, Object>();
+		private Map<String, String> getAdditionalProperties(Map<String, String> existing) {
+			Map<String, String> result = new HashMap<String, String>();
 			if (!isAlreadyProvided(existing, ""ejb.naming_strategy"")
 					&& this.namingStrategy != null) {
 				result.put(""hibernate.ejb.naming_strategy"", this.namingStrategy.getName());
@@ -205,7 +205,7 @@ else if (this.namingStrategy == null) {
 			return result;
 		}
 
-		private boolean isAlreadyProvided(Map<String, Object> existing, String key) {
+		private boolean isAlreadyProvided(Map<String, String> existing, String key) {
 			return existing.containsKey(""hibernate."" + key);
 		}
 
@@ -139,14 +139,15 @@ public void testOpenEntityManagerInViewInterceptorNotRegisteredWhenExplicitlyOff
 	@Test
 	public void customJpaProperties() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.context, ""spring.jpa.properties.a:b"",
-				""spring.jpa.properties.c:d"");
+				""spring.jpa.properties.a.b:c"", ""spring.jpa.properties.c:d"");
 		setupTestConfiguration();
 		this.context.refresh();
 		LocalContainerEntityManagerFactoryBean bean = this.context
 				.getBean(LocalContainerEntityManagerFactoryBean.class);
 		Map<String, Object> map = bean.getJpaPropertyMap();
 		assertThat(map.get(""a""), equalTo((Object) ""b""));
 		assertThat(map.get(""c""), equalTo((Object) ""d""));
+		assertThat(map.get(""a.b""), equalTo((Object) ""c""));
 	}
 
 	@Test
@@ -61,7 +61,7 @@ public void testDefaultDdlAutoForMySql() throws Exception {
 		this.context.refresh();
 		JpaProperties bean = this.context.getBean(JpaProperties.class);
 		DataSource dataSource = this.context.getBean(DataSource.class);
-		String actual = (String) bean.getHibernateProperties(dataSource).get(
+		String actual = bean.getHibernateProperties(dataSource).get(
 				""hibernate.hbm2ddl.auto"");
 		// Default is generic and safe
 		assertThat(actual, equalTo(""none""));
@@ -78,7 +78,7 @@ public void testDefaultDdlAutoForEmbedded() throws Exception {
 		this.context.refresh();
 		JpaProperties bean = this.context.getBean(JpaProperties.class);
 		DataSource dataSource = this.context.getBean(DataSource.class);
-		String actual = (String) bean.getHibernateProperties(dataSource).get(
+		String actual = bean.getHibernateProperties(dataSource).get(
 				""hibernate.hbm2ddl.auto"");
 		assertThat(actual, equalTo(""create-drop""));
 	}
@@ -47,7 +47,7 @@ public void entityManagerFactoryPropertiesNotOverwritingDefaults() {
 				new HibernateJpaVendorAdapter(), this.properties, null);
 		LocalContainerEntityManagerFactoryBean result1 = factory
 				.dataSource(this.dataSource1)
-				.properties(Collections.singletonMap(""foo"", (Object) ""spam"")).build();
+				.properties(Collections.singletonMap(""foo"", ""spam"")).build();
 		assertFalse(result1.getJpaPropertyMap().isEmpty());
 		assertTrue(this.properties.getProperties().isEmpty());
 	}
@@ -58,7 +58,7 @@ public void multipleEntityManagerFactoriesDoNotOverwriteEachOther() {
 				new HibernateJpaVendorAdapter(), this.properties, null);
 		LocalContainerEntityManagerFactoryBean result1 = factory
 				.dataSource(this.dataSource1)
-				.properties(Collections.singletonMap(""foo"", (Object) ""spam"")).build();
+				.properties(Collections.singletonMap(""foo"", ""spam"")).build();
 		assertFalse(result1.getJpaPropertyMap().isEmpty());
 		LocalContainerEntityManagerFactoryBean result2 = factory.dataSource(
 				this.dataSource2).build();
",True,"The commit message refers to a convention regarding the type of keys used in a Map. It explains why the commit changes the type of the Map from Map<String, Object> to Map<String, String>, as it is common to use period-separated keys in a Map for JPA vendor properties.",True,"The commit message explains the necessity of the changes by stating that the previous implementation was causing issues when binding to a Map<String,Object>, which resulted in a nested Map instead of period-separated keys. The change to Map<String,String> is made to ensure that the keys are sane and can be used correctly.",True,"The commit message explains the problem that arises when binding to Map<String,Object>, which results in a nested Map instead of period-separated keys. This change is made to ensure that JpaProperties expose a Map<String,String> so the keys are sane. Additionally, the message mentions that it fixes an issue, which is a common practice to reference the issue report or the shortcoming of the previous implementation.",True,"The commit message 'Ensure JPA vendor properties are period separated' indicates that the developer made changes to ensure that the JPA vendor properties are in a sane format. This change was likely necessary due to the requirement of having period-separated keys instead of a nested Map when binding to Map<String,Object>. This suggests that the changes were made to address a problem in the software maintenance process, specifically out-of-date code that was not handling the JPA vendor properties correctly.",True,"The commit message directly mentions the issue it fixes by stating that it changes JpaProperties to expose a Map<String,String> so the keys are sane. This is because when binding to Map<String,Object>, the keys were nested instead of being period-separated. This change improves the code by making the keys more manageable and easier to work with.",True,"The commit message 'Ensure JPA vendor properties are period separated' accurately summarizes the change made in the code diff. The change is the modification of the data type of the properties map from Map<String, Object> to Map<String, String> in various methods and classes. This change ensures that the keys in the map are period-separated, which is a more sane and expected format. The commit message clearly points out the key component of the change, which is the modification of the data type of the properties map, and contrasts the before and after state of the code.",True,"The commit message explains that the change is made to ensure that the JPA vendor properties are period separated. This is a technical principle that is being applied to make the keys in the Map sane. The code diff also supports this explanation by changing the type of the Map from Map<String, Object> to Map<String, String> in various places in the code.",True,"The commit message 'Ensure JPA vendor properties are period separated' accurately describes the code changes. The changes involve modifying the type of the properties map from Map<String, Object> to Map<String, String> in various methods and classes. This change ensures that the keys in the properties map are period-separated, which is a more sane and expected behavior. The commit message also mentions that this change fixes an issue where binding to Map<String,Object> resulted in a nested Map instead of period-separated keys.",False,"The commit message explains the reason for the change, which is to ensure that JPA vendor properties are period separated. This is necessary because binding to Map<String,Object> results in a nested Map instead of period-separated keys. The change is not just a simple type correction, but rather a modification to ensure the keys are sane and easier to work with."
https://github.com/junit-team/junit4/commit/2568203bdebd5a4a4ad9aa74b1d8369d22f668a3,Replaced IllegalArgumentException for IOException  <enter> It's more consistent to throw an IOException instead of an IllegalArgumentException ,https://api.github.com/repos/junit-team/junit4/commits/2568203bdebd5a4a4ad9aa74b1d8369d22f668a3,"@@ -61,7 +61,7 @@ public void create() throws IOException {
 	public File newFile(String fileName) throws IOException {
 		File file= new File(getRoot(), fileName);
 		if (!file.createNewFile())
-			throw new IllegalArgumentException(
+			throw new IOException(
 					""a file with the name \'"" + fileName + ""\' already exists in the test folder"");
 		return file;
 	}
@@ -77,21 +77,21 @@ public File newFile() throws IOException {
 	 * Returns a new fresh folder with the given name under the temporary
 	 * folder.
 	 */
-	public File newFolder(String folder) {
+	public File newFolder(String folder) throws IOException {
 		return newFolder(new String[]{folder});
 	}
 
 	/**
 	 * Returns a new fresh folder with the given name(s) under the temporary
 	 * folder.
 	 */
-	public File newFolder(String... folderNames) {
+	public File newFolder(String... folderNames) throws IOException {
 		File file= getRoot();
 		for (int i = 0; i < folderNames.length; i++) {
 			String folderName = folderNames[i];
 			file = new File(file, folderName);
 			if (!file.mkdir() && isLastElementInArray(i, folderNames))
-				throw new IllegalArgumentException(
+				throw new IOException(
 						""a folder with the name \'"" + folderName + ""\' already exists"");
 		}
 		return file;
@@ -217,7 +217,7 @@ public void testNewFile() throws IOException {
 		}
 
 		@Test
-		public void testNewFolder() {
+		public void testNewFolder() throws IOException {
 			folder.newFolder(NEW_FOLDER_DUMMY);
 		}
 	}
@@ -59,7 +59,7 @@ public void newFileWithGivenFilenameThrowsIllegalArgumentExceptionIfFileExists()
 		tempFolder.create();
 		tempFolder.newFile(""MyFile.txt"");
 
-		thrown.expect(IllegalArgumentException.class);
+		thrown.expect(IOException.class);
 		thrown.expectMessage(""a file with the name 'MyFile.txt' already exists in the test folder"");
 		tempFolder.newFile(""MyFile.txt"");
 	}
@@ -71,7 +71,7 @@ public void newFolderThrowsIllegalStateExceptionIfCreateWasNotInvoked()
 	}
 
 	@Test(expected= IllegalStateException.class)
-	public void newFolderWithGivenPathThrowsIllegalStateExceptionIfCreateWasNotInvoked() {
+	public void newFolderWithGivenPathThrowsIllegalStateExceptionIfCreateWasNotInvoked() throws IOException {
 		new TemporaryFolder().newFolder(""level1"", ""level2"", ""level3"");
 	}
 
@@ -80,7 +80,7 @@ public void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists
 		tempFolder.create();
 		tempFolder.newFolder(""level1"");
 
-		thrown.expect(IllegalArgumentException.class);
+		thrown.expect(IOException.class);
 		thrown.expectMessage(""a folder with the name 'level1' already exists"");
 		tempFolder.newFolder(""level1"");
 	}
@@ -90,7 +90,7 @@ public void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfPathExists() t
 		tempFolder.create();
 		tempFolder.newFolder(""level1"", ""level2"", ""level3"");
 
-		thrown.expect(IllegalArgumentException.class);
+		thrown.expect(IOException.class);
 		thrown.expectMessage(""a folder with the name 'level3' already exists"");
 		tempFolder.newFolder(""level1"", ""level2"", ""level3"");
 	}
",True,"The commit message refers to a convention regarding the type of exception to throw. It explains that it is more consistent to throw an IOException instead of an IllegalArgumentException, which is a clear reference to a standard or improvement in prior commits.",True,"The commit message explains the necessity of changes by stating that it is more consistent to throw an IOException instead of an IllegalArgumentException. This is because IOException is a checked exception, while IllegalArgumentException is an unchecked exception. By throwing a checked exception, the code becomes more robust and forces the caller to handle the potential error, which is a good practice in Java programming.",True,"The commit message explains the motivation for the code change by mentioning that it's more consistent to throw an IOException instead of an IllegalArgumentException. This is because the IOException is a checked exception, which means it needs to be declared in the method signature or caught, while IllegalArgumentException is an unchecked exception. By throwing a checked exception, the method is forcing the caller to handle the potential error, which can help prevent bugs and make the code more robust.",True,"The commit message 'Replaced IllegalArgumentException for IOException' indicates that the developer changed the exception type from IllegalArgumentException to IOException. This change was made to be more consistent with the rest of the codebase, which might have been throwing IOException for similar situations. This could be considered a change made due to the need for maintaining a consistent codebase, which is a common requirement in software development.",True,"The commit message directly mentions the change made to the code, which is replacing IllegalArgumentException with IOException. This is done to be more consistent in the codebase and to better handle potential errors. The message also explains why this change was made, stating that it's more consistent to throw an IOException instead of an IllegalArgumentException.",True,"The commit message 'Replaced IllegalArgumentException for IOException' accurately describes the change made in the code diff. It clearly states that the code is being modified to throw an IOException instead of an IllegalArgumentException. This is a significant change that is mentioned in the commit message and is also reflected in the code diff. The message provides a clear summary of the change, listing the key components of the change (IllegalArgumentException to IOException) and contrasting the before and after state of the code.",True,"The commit message explains that the change is made to be more consistent with the existing codebase. The code diff shows that IllegalArgumentExceptions are replaced with IOException. This is a technical principle underpinning the changes, as it ensures that the methods in the code consistently throw the same type of exception in similar situations, making the code easier to understand and maintain.",True,"The commit message expresses a change in exception handling and specifies that the behavior now applies to IOException. This is consistent with the code changes, where IllegalArgumentExceptions have been replaced with IOException. This change introduces a new behavior in the code: instead of throwing IllegalArgumentExceptions when a file or folder already exists, the code now throws IOException. This change makes the exception handling more consistent and accurate, as IOException is a more appropriate exception to throw in these situations.",False,"The commit message explains the reason for the change, which is to make the exception handling more consistent. The change is not just a simple replacement of one exception type with another, but it involves modifying multiple methods to throw the same type of exception. The explanation in the commit message clarifies this intent and provides context for the change."
https://github.com/square/retrofit/commit/1d64f9763e1f5aa3d049710df8366f425109672f,Use a dummy value to further validation optional delegation  <enter> Prior to this other things might cause a null value. This ensures the value can only come from only place. ,https://api.github.com/repos/square/retrofit/commits/1d64f9763e1f5aa3d049710df8366f425109672f,"@@ -68,6 +68,7 @@ interface Service {
   }
 
   @Test public void delegates() throws IOException {
+    final Object object = new Object();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url(""/""))
         .addConverterFactory(new Converter.Factory() {
@@ -78,7 +79,7 @@ interface Service {
             }
             return new Converter<ResponseBody, Object>() {
               @Override public Object convert(ResponseBody value) {
-                return null;
+                return object;
               }
             };
           }
@@ -91,6 +92,6 @@ interface Service {
     Service service = retrofit.create(Service.class);
     Optional<Object> optional = service.optional().execute().body();
     assertThat(optional).isNotNull();
-    assertThat(optional.isPresent()).isFalse();
+    assertThat(optional.get()).isSameAs(object);
   }
 }
@@ -68,6 +68,7 @@ interface Service {
   }
 
   @Test public void delegates() throws IOException {
+    Object object = new Object();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url(""/""))
         .addConverterFactory(new Converter.Factory() {
@@ -76,11 +77,7 @@ interface Service {
             if (getRawType(type) != Object.class) {
               return null;
             }
-            return new Converter<ResponseBody, Object>() {
-              @Override public Object convert(ResponseBody value) {
-                return null;
-              }
-            };
+            return value -> object;
           }
         })
         .addConverterFactory(Java8OptionalConverterFactory.create())
@@ -91,6 +88,6 @@ interface Service {
     Service service = retrofit.create(Service.class);
     Optional<Object> optional = service.optional().execute().body();
     assertThat(optional).isNotNull();
-    assertThat(optional.isPresent()).isFalse();
+    assertThat(optional.get()).isSameAs(object);
   }
 }
",True,"The commit message refers to the necessity of changes by mentioning that prior to this commit, other things might cause a null value. The commit introduces a dummy value to ensure the value can only come from one place, which is to further validate the optional delegation. This change improves the reliability and predictability of the code.",True,"The commit message explains the necessity of changes by stating that it uses a dummy value to further validation of optional delegation. This is done to ensure the value can only come from one place, which is necessary to avoid null values that might have been caused by other things. This explanation is sufficient to understand the purpose of the changes without needing additional context or code review.",True,"The commit message explains the necessity of changes by mentioning that 'Prior to this other things might cause a null value.' This indicates that the changes are being made to prevent potential null values from causing issues in the code. Additionally, the message explains that the changes are being made to ensure the value can only come from one place, which further highlights the motivation for the code change.",True,"The commit message 'Use a dummy value to further validation optional delegation' indicates that the developer is addressing a problem in the software maintenance process. The problem is that other things might cause a null value, which is undesirable. By using a dummy value, the developer ensures that the value can only come from one place, which improves the reliability and predictability of the code.",True,"The commit message mentions that it uses a dummy value for further validation of optional delegation. This change is made to ensure that the value can only come from one place, which is likely to fix a bug or improve the code by making it more predictable and less prone to errors.",True,"The commit message 'Use a dummy value to further validation optional delegation' accurately summarizes the changes made in the code diff. It highlights the key component of the change, which is the use of a dummy value instead of a null value for further validation of optional delegation. This contrasts the previous behavior of returning null, which is now replaced with a dummy object.",True,"The commit message explains that the changes are made to ensure the value can only come from a specific place, which is the technical principle of using a dummy value for validation. This is evident in the code diff where the null value is replaced with a new Object instance, ensuring that the value can only come from that specific object.",True,"The commit message expresses the introduction of a new behavior by using a dummy value for validation. It mentions that this change ensures the value can only come from one place, which is the newly introduced dummy value. The code diff supports this by replacing 'null' with a new instance of 'Object' in the converter function and asserting that the optional value is the same as the created object.",False,"The commit message does not lack an explanation. It explains that the change is made to use a dummy value for further validation of optional delegation. This is to ensure that the value can only come from one place, which is important to prevent null values from other sources. The change is not just a simple fix, but a modification to the codebase to improve its robustness and reliability."
https://github.com/apache/dubbo/commit/9157beac5da52530fc6336e419bf02d57e9cce6c,refactor package  <enter> git-svn-id:  http://code.alibabatech.com/svn/dubbo/trunk@1386  1a56cb94-b969-4eaa-88fa-be21384802f2 ,https://api.github.com/repos/apache/dubbo/commits/9157beac5da52530fc6336e419bf02d57e9cce6c,,False,"The commit message does not contain an expression that describes the necessity of changes by referencing conventions, standards, improvements in prior commits, or implemented features. The message only states that the package is being refactored, but it does not provide any context or explanation for why this refactoring is necessary.",True,"The commit message 'refactor package' does not provide a clear explanation for the necessity of the changes. However, it is common sense that refactoring a package might be done to improve the structure, readability, or maintainability of the code, without necessarily needing an explicit rationale in the commit message.",False,"The commit message does not contain any expression that directly elaborates the motivation of the code change. It only mentions the refactoring of a package and provides a git-svn-id, which is not related to the necessity or motivation of the changes.",False,"The commit message 'refactor package' does not explicitly describe the necessity of changes. It could be that the developer is reorganizing the code for better maintainability, but it does not indicate a user requirement, a problem in the software maintenance process, or a change in the development environment.",False,"The commit message does not contain any explicit mention of defects it fixes or improvements it makes to the code. It only states that it is a refactoring of the package, which is a general term that could mean various things, including code optimization, simplification, or reorganization, but it does not specify the exact objective or outcome of the change.",False,"The commit message 'refactor package' does not describe the changes made in the code diff. It only mentions the refactoring of the package without providing any specific details about the changes made. The diff is not mentioned in the commit message, so it cannot be used to determine the summary of the changes. Therefore, the commit message does not contain an expression that describes a summary of what changes by being a summary of the diffs, pointing out or listing the key components of the change, or contrasting the before and after.",False,"The commit message does not contain an expression that describes the technical principle underpinning the changes. It only mentions refactoring the package and provides a git-svn-id, which is not related to any technical principle.",False,"The commit message 'refactor package' does not provide a summary of the changes made in the code diff. It only mentions that the package is being refactored and provides a git-svn-id, which is not related to the functional changes in the code. The code diff does not provide any information either. Therefore, the commit message does not describe the code changes from a functional perspective or introduce any new behaviors.",True,"The commit message 'refactor package' is quite generic and doesn't provide a clear explanation of the changes made. However, the code diff isn't provided in the question. Without the diff, it's difficult to determine the exact nature of the changes. But, if the change was a simple refactoring like renaming a variable or reorganizing code, then the commit message might not need a detailed explanation. However, without more context, it's hard to definitively say that the explanation is unnecessary."
https://github.com/spring-projects/spring-boot/commit/1a764d9c06f2a96722c04b8d8bb1edf89e424628,Default Tomcat to not save SESSIONS.ser file  <enter> Update TomcatEmbeddedServletContainerFactory so that session data isn't serialized by default. Prior to this commit the SESSIONS.ser file would either be written to `/tmp` or into `baseDir` (if one was set). <enter> By not saving session data we align Tomcat with the other embedded servlet containers and reduce the risk of sensitive information being left in `/tmp`. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/1a764d9c06f2a96722c04b8d8bb1edf89e424628,"@@ -394,18 +394,31 @@ protected void configureContext(Context context,
 	private void configureSession(Context context) {
 		long sessionTimeout = getSessionTimeoutInMinutes();
 		context.setSessionTimeout((int) sessionTimeout);
+		Manager manager = context.getManager();
+		if (manager == null) {
+			manager = new StandardManager();
+			context.setManager(manager);
+		}
 		if (isPersistSession()) {
-			Manager manager = context.getManager();
-			if (manager == null) {
-				manager = new StandardManager();
-				context.setManager(manager);
-			}
-			Assert.state(manager instanceof StandardManager,
-					""Unable to persist HTTP session state using manager type ""
-							+ manager.getClass().getName());
-			File folder = new ApplicationTemp().getFolder(""tomcat-sessions"");
-			File file = new File(folder, ""SESSIONS.ser"");
-			((StandardManager) manager).setPathname(file.getAbsolutePath());
+			configurePersistSession(manager);
+		}
+		else {
+			disablePersistSession(manager);
+		}
+	}
+
+	private void configurePersistSession(Manager manager) {
+		Assert.state(manager instanceof StandardManager,
+				""Unable to persist HTTP session state using manager type ""
+						+ manager.getClass().getName());
+		File folder = new ApplicationTemp().getFolder(""tomcat-sessions"");
+		File file = new File(folder, ""SESSIONS.ser"");
+		((StandardManager) manager).setPathname(file.getAbsolutePath());
+	}
+
+	private void disablePersistSession(Manager manager) {
+		if (manager instanceof StandardManager) {
+			((StandardManager) manager).setPathname(null);
 		}
 	}
 
@@ -723,7 +723,7 @@ public void service(ServletRequest request, ServletResponse response)
 		return bean;
 	}
 
-	private ServletContextInitializer sessionServletRegistration() {
+	protected final ServletContextInitializer sessionServletRegistration() {
 		ServletRegistrationBean bean = new ServletRegistrationBean(new ExampleServlet() {
 
 			@Override
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.context.embedded.tomcat;
 
+import java.io.File;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.ServerSocket;
@@ -45,6 +46,7 @@
 
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.not;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
@@ -333,6 +335,31 @@ public void useForwardHeaders() throws Exception {
 		assertForwardHeaderIsUsed(factory);
 	}
 
+	@Test
+	public void disableDoesNotSaveSessionFiles() throws Exception {
+		File baseDir = this.temporaryFolder.newFolder();
+		TomcatEmbeddedServletContainerFactory factory = getFactory();
+		// If baseDir is not set SESSIONS.ser is written to a different temp folder
+		// each time. By setting it we can really ensure that data isn't saved
+		factory.setBaseDirectory(baseDir);
+		this.container = factory
+				.getEmbeddedServletContainer(sessionServletRegistration());
+		this.container.start();
+		String s1 = getResponse(getLocalUrl(""/session""));
+		String s2 = getResponse(getLocalUrl(""/session""));
+		this.container.stop();
+		this.container = factory
+				.getEmbeddedServletContainer(sessionServletRegistration());
+		this.container.start();
+		String s3 = getResponse(getLocalUrl(""/session""));
+		System.out.println(s1);
+		System.out.println(s2);
+		System.out.println(s3);
+		String message = ""Session error s1="" + s1 + "" s2="" + s2 + "" s3="" + s3;
+		assertThat(message, s2.split("":"")[0], equalTo(s1.split("":"")[1]));
+		assertThat(message, s3.split("":"")[0], not(equalTo(s2.split("":"")[1])));
+	}
+
 	@Override
 	protected Wrapper getJspServlet() {
 		Container context = ((TomcatEmbeddedServletContainer) this.container).getTomcat()
",True,"The commit message refers to the prior behavior of Tomcat saving the SESSIONS.ser file, which is no longer the case. It mentions that the change is made to align Tomcat with other embedded servlet containers and to reduce the risk of sensitive information being left in /tmp. This explains the necessity of the changes by referencing a convention (other embedded servlet containers do not save session data by default) and an improvement (reducing the risk of sensitive information being left in /tmp).",True,"The commit message 'Default Tomcat to not save SESSIONS.ser file' clearly explains the necessity of the changes. It explains that the SESSIONS.ser file was previously written to `/tmp` or into `baseDir`, and that by not saving session data, Tomcat is aligned with other embedded servlet containers and the risk of sensitive information being left in `/tmp` is reduced.",True,"The commit message explains the motivation for the change by mentioning that the SESSIONS.ser file would either be written to `/tmp` or into `baseDir` (if one was set) prior to this commit. This could potentially lead to sensitive information being left in `/tmp`. By not saving session data, the commit message aligns Tomcat with the other embedded servlet containers and reduces the risk of sensitive information being left in `/tmp`.",True,"The commit message 'Default Tomcat to not save SESSIONS.ser file' indicates that the change was made to address a problem in the software maintenance process. The problem is that the SESSIONS.ser file was being written to `/tmp` or into `baseDir`, which could potentially leave sensitive information exposed. By not saving session data, the developer is aligning Tomcat with other embedded servlet containers and reducing the risk of sensitive information being left in `/tmp`.",True,The commit message directly mentions the objective of the change by stating that it updates TomcatEmbeddedServletContainerFactory so that session data isn't serialized by default. This is done to align Tomcat with the other embedded servlet containers and reduce the risk of sensitive information being left in /tmp.,True,"The commit message 'Default Tomcat to not save SESSIONS.ser file' accurately summarizes the change made in the code diff. The diff shows that the code has been updated to disable the saving of session data by default, which aligns Tomcat with other embedded servlet containers and reduces the risk of sensitive information being left in '/tmp'. This is a clear and concise summary of the changes made in the code.",True,"The commit message explains that the changes are made to align Tomcat with other embedded servlet containers and to reduce the risk of sensitive information being left in `/tmp` by not saving session data. This is a clear expression of the technical principle underpinning the changes, which is to enhance security and consistency.",True,"The commit message 'Default Tomcat to not save SESSIONS.ser file' accurately summarizes the code changes. The code diff shows that the commit disables the saving of session data by default, which aligns Tomcat with other embedded servlet containers and reduces the risk of sensitive information being left in '/tmp'. This is a clear and functional explanation of the changes introduced by the commit.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Default Tomcat to not save SESSIONS.ser file' and provides additional context about the previous behavior, the issue it fixes, and the benefits of the change."
https://github.com/square/okhttp/commit/02b08fbde7b1726d7a4c0dc971152751ac82ca0a,"Allow HTAB in header values.  <enter> RFC 7230 section 3.2 allows HTAB ('	', 'u0009') inside header values as long as there is not more than one in a row:    https://tools.ietf.org/html/rfc7230#section-3.2  <enter> Before this CL, OkHttp previously disallowed HTAB in header values. This CL changes behavior to allow any number of consecutive HTABs inside a header value; this is more permissive than the RFC, but is consistent with how OkHttp currently treats space characters (' ', 'u0020'). ",https://api.github.com/repos/square/okhttp/commits/02b08fbde7b1726d7a4c0dc971152751ac82ca0a,"@@ -75,10 +75,12 @@ public final class HeadersTest {
         .add(""foo: bar"")
         .add("" foo: baz"") // Name leading whitespace is trimmed.
         .add(""foo : bak"") // Name trailing whitespace is trimmed.
+        .add(""\tkey\t:\tvalue\t"") // '\t' also counts as whitespace
         .add(""ping:  pong  "") // Value whitespace is trimmed.
         .add(""kit:kat"") // Space after colon is not required.
         .build();
     assertEquals(Arrays.asList(""bar"", ""baz"", ""bak""), headers.values(""foo""));
+    assertEquals(Arrays.asList(""value""), headers.values(""key""));
     assertEquals(Arrays.asList(""pong""), headers.values(""ping""));
     assertEquals(Arrays.asList(""kat""), headers.values(""kit""));
   }
@@ -198,11 +198,20 @@ public final class RequestTest {
     }
   }
 
+  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header(""key"", ""sample\tvalue"");
+    try {
+      builder.header(""sample\tkey"", ""value"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   @Test public void headerForbidsControlCharacters() throws Exception {
     assertForbiddenHeader(""\u0000"");
     assertForbiddenHeader(""\r"");
     assertForbiddenHeader(""\n"");
-    assertForbiddenHeader(""\t"");
     assertForbiddenHeader(""\u001f"");
     assertForbiddenHeader(""\u007f"");
     assertForbiddenHeader(""\u0080"");
@@ -316,7 +316,7 @@ private void checkNameAndValue(String name, String value) {
       if (value == null) throw new NullPointerException(""value == null"");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
-        if (c <= '\u001f' || c >= '\u007f') {
+        if ((c <= '\u001f' && c != '\u0009' /* htab */) || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               ""Unexpected char %#04x at %d in %s value: %s"", (int) c, i, name, value));
         }
",True,"The commit message refers to a convention from RFC 7230 section 3.2, which allows HTAB ('	', 'u0009') inside header values as long as there is not more than one in a row. The commit message explains that before this change, OkHttp disallowed HTAB in header values, but now it allows any number of consecutive HTABs inside a header value, which is more permissive than the RFC but consistent with how OkHttp currently treats space characters (' ', 'u0020'). This shows that the commit message is describing the necessity of changes by referencing a convention and explaining the improvement over the previous behavior.",True,"The commit message refers to a change in the behavior of the code, which is to allow HTAB ('	', 'u0009') inside header values. This change is made to be more permissive than the RFC, but it is consistent with how OkHttp currently treats space characters (' ', 'u0020'). This is a functional change that improves the code's ability to handle certain types of input, but the rationale for the change is not explicitly stated in the commit message. However, it can be inferred from the context that the change is necessary to align the code's behavior with the RFC, which allows HTAB in header values under certain conditions.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions the RFC 7230 section 3.2 that allows HTAB ('	', 'u0009') inside header values as long as there is not more than one in a row. It also mentions that before this CL, OkHttp previously disallowed HTAB in header values. This shows that the change is made to allow more permissive behavior that is consistent with how OkHttp currently treats space characters (' ', 'u0020'), but is more permissive than the RFC. This elaborates on the shortcoming of the previous implementation and the error scenario it addressed.",True,"The commit message indicates that the changes were made to allow HTAB ('	', 'u0009') inside header values, which is more permissive than the RFC. This is done to be consistent with how OkHttp currently treats space characters (' ', 'u0020'). The necessity of this change is described in the message as it is to allow any number of consecutive HTABs inside a header value, which was previously disallowed. This suggests that the change was made to meet the requirements of users or to address a problem in the process of software maintenance, specifically outdated code that did not allow HTAB in header values.",True,"The commit message directly mentions the change made to the code, which is allowing HTAB ('	', 'u0009') inside header values. This is done to be more permissive than the RFC, but consistent with how OkHttp currently treats space characters (' ', 'u0020'). The message also mentions that this change is to fix a previous behavior where HTAB in header values was disallowed.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions that the commit allows HTAB ('	', 'u0009') inside header values, which was previously disallowed. It also notes that this change is more permissive than the RFC but consistent with how OkHttp currently treats space characters. The code diff supports this by adding a test case that allows HTAB in header values and modifying the existing check to allow HTAB as well, as long as it's not the first or last character in the header name.",True,"The commit message explains that the changes are made to allow horizontal tab ('	', 'u0009') characters inside header values, which is more permissive than what is specified in RFC 7230. This is a technical principle that underpins the changes, as it involves modifying the parsing and handling of HTTP headers to accommodate a broader set of characters.",True,"The commit message expresses a change in behavior and describes the functional impact of the code changes. It mentions that the change allows HTAB ('	', 'u0009') inside header values, which was previously disallowed. The message also explains that this change is more permissive than the RFC, but is consistent with how OkHttp currently treats space characters. The code diff supports this explanation by showing the addition of a test case that checks if HTAB is allowed only in values, not keys, and by modifying the existing checkNameAndValue function to allow HTAB as long as it's not in a key.",False,"The commit message does explain the reason for the change, which is to allow HTAB characters in header values as per RFC 7230 section 3.2. The code diff also shows that the change is not just a simple removal of a space, but rather a modification of the code to allow HTAB characters in header values, which is a more significant change that requires an explanation."
https://github.com/spring-projects/spring-boot/commit/985c8f75982da4fabc1c8a5958a57706d4d4feab,Polish RSocket support ,https://api.github.com/repos/spring-projects/spring-boot/commits/985c8f75982da4fabc1c8a5958a57706d4d4feab,"@@ -44,7 +44,7 @@
 @AutoConfigureAfter(RSocketStrategiesAutoConfiguration.class)
 public class RSocketMessagingAutoConfiguration {
 
-	private static String PATHPATTERN_ROUTEMATCHER_CLASS = ""org.springframework.web.util.pattern.PathPatternRouteMatcher"";
+	private static final String PATHPATTERN_ROUTEMATCHER_CLASS = ""org.springframework.web.util.pattern.PathPatternRouteMatcher"";
 
 	@Bean
 	@ConditionalOnMissingBean
@@ -35,7 +35,7 @@ public Server getServer() {
 		return this.server;
 	}
 
-	static class Server {
+	public static class Server {
 
 		/**
 		 * Server port.
@@ -48,7 +48,7 @@ public class RSocketRequesterAutoConfiguration {
 	@Bean
 	@Scope(""prototype"")
 	@ConditionalOnMissingBean
-	public RSocketRequester.Builder rsocketRequesterBuilder(RSocketStrategies strategies) {
+	public RSocketRequester.Builder rSocketRequesterBuilder(RSocketStrategies strategies) {
 		return RSocketRequester.builder().rsocketStrategies(strategies);
 	}
 
@@ -81,7 +81,7 @@ static class EmbeddedServerAutoConfiguration {
 
 		@Bean
 		@ConditionalOnMissingBean
-		public ReactorResourceFactory reactorServerResourceFactory() {
+		public ReactorResourceFactory reactorResourceFactory() {
 			return new ReactorResourceFactory();
 		}
 
@@ -109,7 +109,7 @@ public RSocketServerBootstrap rSocketServerBootstrap(RSocketServerFactory rSocke
 	static class OnRSocketWebServerCondition extends AllNestedConditions {
 
 		OnRSocketWebServerCondition() {
-			super(ConfigurationPhase.REGISTER_BEAN);
+			super(ConfigurationPhase.PARSE_CONFIGURATION);
 		}
 
 		@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@@ -76,7 +76,7 @@ protected static class JacksonCborStrategyConfiguration {
 		@Bean
 		@Order(0)
 		@ConditionalOnBean(Jackson2ObjectMapperBuilder.class)
-		public RSocketStrategiesCustomizer jacksonCborStrategyCustomizer(Jackson2ObjectMapperBuilder builder) {
+		public RSocketStrategiesCustomizer jacksonCborRSocketStrategyCustomizer(Jackson2ObjectMapperBuilder builder) {
 			return (strategy) -> {
 				ObjectMapper objectMapper = builder.factory(new CBORFactory()).build();
 				strategy.decoder(new Jackson2CborDecoder(objectMapper, SUPPORTED_TYPES));
@@ -96,7 +96,7 @@ protected static class JacksonJsonStrategyConfiguration {
 		@Bean
 		@Order(1)
 		@ConditionalOnBean(ObjectMapper.class)
-		public RSocketStrategiesCustomizer jacksonJsonStrategyCustomizer(ObjectMapper objectMapper) {
+		public RSocketStrategiesCustomizer jacksonJsonRSocketStrategyCustomizer(ObjectMapper objectMapper) {
 			return (strategy) -> {
 				strategy.decoder(new Jackson2JsonDecoder(objectMapper, SUPPORTED_TYPES));
 				strategy.encoder(new Jackson2JsonEncoder(objectMapper, SUPPORTED_TYPES));
@@ -37,7 +37,7 @@
  */
 class RSocketMessagingAutoConfigurationTests {
 
-	private ApplicationContextRunner contextRunner = new ApplicationContextRunner()
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
 			.withConfiguration(AutoConfigurations.of(RSocketMessagingAutoConfiguration.class))
 			.withUserConfiguration(BaseConfiguration.class);
 
@@ -67,7 +67,7 @@ void shouldUseCustomMessageHandlerAcceptor() {
 						.containsOnly(""customMessageHandlerAcceptor""));
 	}
 
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class BaseConfiguration {
 
 		@Bean
@@ -78,7 +78,7 @@ public RSocketStrategies rSocketStrategies() {
 
 	}
 
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class CustomMessageHandlerAcceptor {
 
 		@Bean
@@ -34,7 +34,7 @@
  */
 class RSocketRequesterAutoConfigurationTests {
 
-	private ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
 			AutoConfigurations.of(RSocketStrategiesAutoConfiguration.class, RSocketRequesterAutoConfiguration.class));
 
 	@Test
@@ -42,22 +42,20 @@ class RSocketServerAutoConfigurationTests {
 
 	@Test
 	void shouldNotCreateBeansByDefault() {
-		ApplicationContextRunner contextRunner = createContextRunner();
-		contextRunner.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
+		contextRunner().run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
 				.doesNotHaveBean(RSocketServerFactory.class).doesNotHaveBean(RSocketServerBootstrap.class));
 	}
 
 	@Test
 	void shouldNotCreateDefaultBeansForReactiveWebAppWithoutMapping() {
-		ReactiveWebApplicationContextRunner contextRunner = createReactiveWebContextRunner();
-		contextRunner.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
-				.doesNotHaveBean(RSocketServerFactory.class).doesNotHaveBean(RSocketServerBootstrap.class));
+		reactiveWebContextRunner()
+				.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
+						.doesNotHaveBean(RSocketServerFactory.class).doesNotHaveBean(RSocketServerBootstrap.class));
 	}
 
 	@Test
 	void shouldNotCreateDefaultBeansForReactiveWebAppWithWrongTransport() {
-		ReactiveWebApplicationContextRunner contextRunner = createReactiveWebContextRunner();
-		contextRunner
+		reactiveWebContextRunner()
 				.withPropertyValues(""spring.rsocket.server.transport=tcp"",
 						""spring.rsocket.server.mapping-path=/rsocket"")
 				.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
@@ -66,31 +64,30 @@ void shouldNotCreateDefaultBeansForReactiveWebAppWithWrongTransport() {
 
 	@Test
 	void shouldCreateDefaultBeansForReactiveWebApp() {
-		ReactiveWebApplicationContextRunner contextRunner = createReactiveWebContextRunner();
-		contextRunner
+		reactiveWebContextRunner()
 				.withPropertyValues(""spring.rsocket.server.transport=websocket"",
 						""spring.rsocket.server.mapping-path=/rsocket"")
 				.run((context) -> assertThat(context).hasSingleBean(RSocketWebSocketNettyRouteProvider.class));
 	}
 
 	@Test
 	void shouldCreateDefaultBeansForRSocketServerWhenPortIsSet() {
-		ReactiveWebApplicationContextRunner contextRunner = createReactiveWebContextRunner();
-		contextRunner.withPropertyValues(""spring.rsocket.server.port=0"").run((context) -> assertThat(context)
-				.hasSingleBean(RSocketServerFactory.class).hasSingleBean(RSocketServerBootstrap.class));
+		reactiveWebContextRunner().withPropertyValues(""spring.rsocket.server.port=0"")
+				.run((context) -> assertThat(context).hasSingleBean(RSocketServerFactory.class)
+						.hasSingleBean(RSocketServerBootstrap.class));
 	}
 
-	private ApplicationContextRunner createContextRunner() {
+	private ApplicationContextRunner contextRunner() {
 		return new ApplicationContextRunner().withUserConfiguration(BaseConfiguration.class)
 				.withConfiguration(AutoConfigurations.of(RSocketServerAutoConfiguration.class));
 	}
 
-	private ReactiveWebApplicationContextRunner createReactiveWebContextRunner() {
+	private ReactiveWebApplicationContextRunner reactiveWebContextRunner() {
 		return new ReactiveWebApplicationContextRunner().withUserConfiguration(BaseConfiguration.class)
 				.withConfiguration(AutoConfigurations.of(RSocketServerAutoConfiguration.class));
 	}
 
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class BaseConfiguration {
 
 		@Bean
@@ -16,10 +16,10 @@
 
 package org.springframework.boot.autoconfigure.rsocket;
 
-import com.fasterxml.jackson.databind.ObjectMapper;
 import org.junit.jupiter.api.Test;
 
 import org.springframework.boot.autoconfigure.AutoConfigurations;
+import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;
 import org.springframework.boot.rsocket.messaging.RSocketStrategiesCustomizer;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;
 import org.springframework.context.annotation.Bean;
@@ -32,7 +32,6 @@
 import org.springframework.http.codec.cbor.Jackson2CborEncoder;
 import org.springframework.http.codec.json.Jackson2JsonDecoder;
 import org.springframework.http.codec.json.Jackson2JsonEncoder;
-import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
 import org.springframework.messaging.rsocket.RSocketStrategies;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -44,9 +43,8 @@
  */
 class RSocketStrategiesAutoConfigurationTests {
 
-	private ApplicationContextRunner contextRunner = new ApplicationContextRunner()
-			.withUserConfiguration(BaseConfiguration.class)
-			.withConfiguration(AutoConfigurations.of(RSocketStrategiesAutoConfiguration.class));
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
+			AutoConfigurations.of(JacksonAutoConfiguration.class, RSocketStrategiesAutoConfiguration.class));
 
 	@Test
 	void shouldCreateDefaultBeans() {
@@ -82,22 +80,7 @@ void shouldUseStrategiesCustomizer() {
 		});
 	}
 
-	@Configuration
-	static class BaseConfiguration {
-
-		@Bean
-		public ObjectMapper objectMapper() {
-			return new ObjectMapper();
-		}
-
-		@Bean
-		public Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder() {
-			return new Jackson2ObjectMapperBuilder();
-		}
-
-	}
-
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class UserStrategies {
 
 		@Bean
@@ -108,7 +91,7 @@ public RSocketStrategies customRSocketStrategies() {
 
 	}
 
-	@Configuration
+	@Configuration(proxyBeanMethods = false)
 	static class StrategiesCustomizer {
 
 		@Bean
",True,"The commit message 'Polish RSocket support' does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features. However, the changes made in the code diff suggest that the commit is likely improving the code style and readability, which could be considered an improvement. For example, the changes include adding 'final' to a variable declaration and changing the access modifier of a class from 'static' to 'public static', which could improve the code's clarity and maintainability.",True,"The commit message 'Polish RSocket support' does not explicitly describe the necessity of the changes. However, the changes made in the code diff are mostly typographic fixes and refactorings, such as adding 'final' to a variable declaration and changing the access modifier of a class from 'static' to 'public'. These changes are not likely to introduce new functionality or fix any bugs, but rather improve the code style and maintainability. Therefore, it can be inferred that the commit message describes the necessity of changes by not offering a rationale.",False,"The commit message 'Polish RSocket support' does not directly elaborate the motivation of the code change. It does not mention any error scenario, issue report, or shortcoming of the previous implementation. The code diff suggests some minor changes such as adding 'final' to a variable declaration and changing the visibility of a class, but these changes do not necessarily indicate a necessity for the changes.",True,"The commit message 'Polish RSocket support' does not explicitly describe the necessity of changes. However, the code diff indicates that the changes are likely made to improve the code quality and maintainability, such as adding 'final' modifier to a constant, changing the access modifier of a class, and renaming a method. These changes are not necessarily driven by user requirements or problems in the software maintenance process, but they could be considered as improvements to enhance the codebase.",True,"The commit message 'Polish RSocket support' does contain an expression that describes the objective of the change. Specifically, the changes made in the code diff are improvements to the RSocket support, such as making a private field final, changing the visibility of a class from private to public, and renaming a method. These changes likely enhance the functionality, readability, and maintainability of the RSocket support in the codebase.",True,"The commit message 'Polish RSocket support' does contain an expression that describes a summary of what changes by being a summary of the diffs. The message highlights the changes made to the codebase, such as renaming a class from 'Server' to 'public static class Server', renaming a method from 'jacksonCborStrategyCustomizer' to 'jacksonCborRSocketStrategyCustomizer', and changing the value of a constant from 'REGISTER_BEAN' to 'PARSE_CONFIGURATION'. These changes are all mentioned in the commit message, which provides a clear and concise summary of the changes made to the codebase.",False,"The commit message 'Polish RSocket support' does not contain an expression that describes the technical principle underpinning the changes. The changes in the code diff are mostly related to code formatting and naming conventions, such as adding 'final' to a variable declaration and changing the visibility of a class from 'static' to 'public'. These changes do not reveal any underlying technical principles.",True,"The commit message 'Polish RSocket support' does express a summary of the changes by explaining the code changes from a functional perspective. The code diff shows several changes, such as adding the 'final' keyword to a variable declaration, changing the access modifier of a class from 'static' to 'public static', and renaming a method. These changes could potentially introduce new behaviors, such as limiting the scope of the variable or making the class or method accessible to other parts of the application. Additionally, the renaming of the method could indicate that the method's functionality has been changed or expanded.",True,"The commit message 'Polish RSocket support' does not explicitly explain the reason for the commit, but the changes made in the code diff are small and simple. Specifically, the changes are adding 'final' to a variable declaration, changing the access modifier of a class from 'static' to 'public static', and renaming a method. These changes are likely cosmetic or refactoring in nature, and do not introduce any new functionality or behavior. Therefore, it is reasonable to infer that the commit message lacks an explicit explanation because the reason for the commit is already clear from the changes made in the code."
https://github.com/square/okhttp/commit/0137eb9dbad165caea7189c5c3e09382563ef8bd,Remove unnecessary use of grouping parentheses  <enter> Let's remove warnings found by errorprone. <enter> - attempt ``` okhttp/okhttp/src/test/java/okhttp3/CallTest.java:2056: warning: [UnnecessaryParentheses] Unnecessary use of grouping parentheses             sink.writeUtf8('attempt ' + (attempt++));                                         ^     (see  https://errorprone.info/bugpattern/UnnecessaryParentheses )   Did you mean 'sink.writeUtf8('attempt ' + attempt++);'? ``` <enter> - isEaualTo ``` okhttp/src/test/java/okhttp3/OkHttpClientTest.java:287: warning: [UnnecessaryParentheses] Unnecessary use of grouping parentheses       assertThat(expected.getMessage()).isEqualTo(('protocols must not contain null'));                                                   ^     (see  https://errorprone.info/bugpattern/UnnecessaryParentheses ) ``` ,https://api.github.com/repos/square/okhttp/commits/0137eb9dbad165caea7189c5c3e09382563ef8bd,"@@ -2022,7 +2022,7 @@ public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exceptio
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8(""attempt "" + (attempt++));
+            sink.writeUtf8(""attempt "" + attempt++);
           }
         })
         .build();
@@ -2053,7 +2053,7 @@ public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exceptio
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8(""attempt "" + (attempt++));
+            sink.writeUtf8(""attempt "" + attempt++);
           }
 
           @Override public boolean isOneShot() {
@@ -284,7 +284,7 @@ public final class OkHttpClientTest {
       new OkHttpClient.Builder().protocols(protocols);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo((""protocols must not contain null""));
+      assertThat(expected.getMessage()).isEqualTo(""protocols must not contain null"");
     }
   }
 
",True,"The commit message refers to the warning found by errorprone, which is a tool that helps catch common mistakes as compile-time errors. The warning is about unnecessary use of grouping parentheses. By removing these parentheses, the commit message is implying that the changes are being made to improve code readability and adhere to best practices, as suggested by the errorprone tool.",True,"The commit message does not explicitly state the reason for the changes, but it does provide a clear explanation of the issue and the solution. The changes are made to remove unnecessary grouping parentheses, which is a common practice to improve code readability and maintainability. The commit message also references 'errorprone', a tool that likely found these warnings, which adds context to the changes.",True,"The commit message explains the motivation for the changes by mentioning the warnings found by errorprone, which is a tool that helps catch common programming mistakes. The warnings specifically mention 'UnnecessaryParentheses', which is the issue that the commit is addressing. By removing the unnecessary parentheses, the code becomes cleaner and easier to read, which can potentially improve maintainability and reduce the likelihood of future errors.",True,"The commit message mentions the use of errorprone, which is a static analysis tool for Java. The warnings found by errorprone indicate unnecessary use of grouping parentheses in the code. This could be a result of outdated code or a change in the development environment, as the tool's rules might have been updated. However, without more context, it's difficult to definitively say that the changes were necessitated by user requirements or a problem in the software maintenance process.",True,"The commit message directly mentions the changes made to remove unnecessary use of grouping parentheses, which is an improvement to the code. It also references the warnings found by errorprone, indicating that the change is to address these warnings and potentially improve the code's readability and maintainability.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions the removal of unnecessary use of grouping parentheses in two specific files and locations, which is exactly what the code diff shows. This makes the commit message a good summary of the changes, as it points out the key components of the change and describes the before and after state of the code.",False,The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions removing unnecessary use of grouping parentheses to address warnings found by errorprone. It does not explain why the parentheses were unnecessary or what principle they were violating.,True,"The commit message 'Remove unnecessary use of grouping parentheses' accurately describes the changes made in the code diff. The changes involve removing unnecessary parentheses in two lines of code, which improves the readability and efficiency of the code. This does not introduce any new behaviors or functional changes to the code.",False,"The commit message does not explicitly state the reason for the change, but it does provide a clear explanation of the warning found by errorprone and the suggested fix. While the change is small and simple, the commit message could still benefit from a brief explanation of why the parentheses were unnecessary."
https://github.com/spring-projects/spring-boot/commit/123ffd736c0a435f24f8d9c647e5d384de8cab4a,Exclude @ManagedResources from Endpoint MBeans  <enter> If an Endpoint is already @ManagedResource then it doesn't need an additional (probably wrong) MBEan registration based on the invoke() method. ,https://api.github.com/repos/spring-projects/spring-boot/commits/123ffd736c0a435f24f8d9c647e5d384de8cab4a,"@@ -38,9 +38,11 @@
 import org.springframework.context.ApplicationContextAware;
 import org.springframework.context.ApplicationListener;
 import org.springframework.context.SmartLifecycle;
+import org.springframework.core.annotation.AnnotationUtils;
 import org.springframework.jmx.export.MBeanExportException;
 import org.springframework.jmx.export.MBeanExporter;
 import org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource;
+import org.springframework.jmx.export.annotation.ManagedResource;
 import org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler;
 import org.springframework.jmx.export.naming.MetadataNamingStrategy;
 import org.springframework.jmx.export.naming.SelfNaming;
@@ -144,6 +146,18 @@ protected void locateAndRegisterEndpoints() {
 	}
 
 	protected void registerEndpoint(String beanName, Endpoint<?> endpoint) {
+		@SuppressWarnings(""rawtypes"")
+		Class<? extends Endpoint> type = endpoint.getClass();
+		if (AnnotationUtils.findAnnotation(type, ManagedResource.class) != null) {
+			// Already managed
+			return;
+		}
+		if (type.isMemberClass()
+				&& AnnotationUtils.findAnnotation(type.getEnclosingClass(),
+						ManagedResource.class) != null) {
+			// Nested class with @ManagedResource in parent
+			return;
+		}
 		try {
 			registerBeanNameOrInstance(getEndpointMBean(beanName, endpoint), beanName);
 		}
@@ -19,12 +19,14 @@
 import org.springframework.boot.actuate.endpoint.Endpoint;
 import org.springframework.boot.actuate.endpoint.ShutdownEndpoint;
 import org.springframework.jmx.export.annotation.ManagedOperation;
+import org.springframework.jmx.export.annotation.ManagedResource;
 
 /**
  * Special endpoint wrapper for {@link ShutdownEndpoint}.
  * 
  * @author Christian Dupuis
  */
+@ManagedResource
 public class ShutdownEndpointMBean extends EndpointMBean {
 
 	public ShutdownEndpointMBean(String beanName, Endpoint<?> endpoint) {
@@ -25,18 +25,26 @@
 import org.junit.After;
 import org.junit.Test;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
+import org.springframework.boot.actuate.endpoint.AbstractEndpoint;
+import org.springframework.boot.actuate.endpoint.Endpoint;
 import org.springframework.boot.actuate.endpoint.jmx.EndpointMBeanExporter;
+import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
 import org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.EnableMBeanExport;
 import org.springframework.jmx.export.MBeanExporter;
+import org.springframework.jmx.export.annotation.ManagedResource;
 import org.springframework.jmx.support.ObjectNameManager;
 import org.springframework.mock.env.MockEnvironment;
+import org.springframework.stereotype.Component;
 import org.springframework.util.ObjectUtils;
 
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
@@ -55,13 +63,51 @@ public void close() {
 	}
 
 	@Test
-	public void testEndpointMBeanExporterIsInstalled() {
+	public void testEndpointMBeanExporterIsInstalled() throws Exception {
 		this.context = new AnnotationConfigApplicationContext();
 		this.context.register(TestConfiguration.class, JmxAutoConfiguration.class,
 				EndpointAutoConfiguration.class,
-				EndpointMBeanExportAutoConfiguration.class);
+				EndpointMBeanExportAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
+		this.context.refresh();
+		assertNotNull(this.context.getBean(EndpointMBeanExporter.class));
+		MBeanExporter mbeanExporter = this.context.getBean(EndpointMBeanExporter.class);
+
+		assertFalse(mbeanExporter.getServer()
+				.queryNames(getObjectName(""*"", ""*,*"", this.context), null).isEmpty());
+	}
+
+	@Test
+	public void testEndpointMBeanExporterIsNotInstalledIfManagedResource()
+			throws Exception {
+		this.context = new AnnotationConfigApplicationContext();
+		this.context.register(TestConfiguration.class, JmxAutoConfiguration.class,
+				ManagedEndpoint.class, EndpointMBeanExportAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
+		this.context.refresh();
+		assertNotNull(this.context.getBean(EndpointMBeanExporter.class));
+
+		MBeanExporter mbeanExporter = this.context.getBean(EndpointMBeanExporter.class);
+
+		assertTrue(mbeanExporter.getServer()
+				.queryNames(getObjectName(""*"", ""*,*"", this.context), null).isEmpty());
+	}
+
+	@Test
+	public void testEndpointMBeanExporterIsNotInstalledIfNestedInManagedResource()
+			throws Exception {
+		this.context = new AnnotationConfigApplicationContext();
+		this.context.register(TestConfiguration.class, JmxAutoConfiguration.class,
+				NestedInManagedEndpoint.class,
+				EndpointMBeanExportAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
 		this.context.refresh();
 		assertNotNull(this.context.getBean(EndpointMBeanExporter.class));
+
+		MBeanExporter mbeanExporter = this.context.getBean(EndpointMBeanExporter.class);
+
+		assertTrue(mbeanExporter.getServer()
+				.queryNames(getObjectName(""*"", ""*,*"", this.context), null).isEmpty());
 	}
 
 	@Test(expected = NoSuchBeanDefinitionException.class)
@@ -125,21 +171,23 @@ public void testEndpointMBeanExporterInParentChild() throws IntrospectionExcepti
 
 	private ObjectName getObjectName(String domain, String beanKey,
 			ApplicationContext applicationContext) throws MalformedObjectNameException {
+		String name = ""%s:type=Endpoint,name=%s"";
+		if (applicationContext.getParent() != null) {
+			name = name + "",context=%s"";
+		}
+		if (applicationContext.getEnvironment().getProperty(""endpoints.jmx.unique_names"",
+				Boolean.class, false)) {
+			name = name
+					+ "",identity=""
+					+ ObjectUtils.getIdentityHexString(applicationContext
+							.getBean(beanKey));
+		}
 		if (applicationContext.getParent() != null) {
-			return ObjectNameManager
-					.getInstance(String.format(
-							""%s:type=Endpoint,name=%s,context=%s,identity=%s"", domain,
-							beanKey,
-							ObjectUtils.getIdentityHexString(applicationContext),
-							ObjectUtils.getIdentityHexString(applicationContext
-									.getBean(beanKey))));
+			return ObjectNameManager.getInstance(String.format(name, domain, beanKey,
+					ObjectUtils.getIdentityHexString(applicationContext)));
 		}
 		else {
-			return ObjectNameManager
-					.getInstance(String.format(""%s:type=Endpoint,name=%s,identity=%s"",
-							domain, beanKey, ObjectUtils
-									.getIdentityHexString(applicationContext
-											.getBean(beanKey))));
+			return ObjectNameManager.getInstance(String.format(name, domain, beanKey));
 		}
 	}
 
@@ -148,4 +196,43 @@ private ObjectName getObjectName(String domain, String beanKey,
 	public static class TestConfiguration {
 
 	}
+
+	@Component
+	@ManagedResource
+	protected static class ManagedEndpoint extends AbstractEndpoint<Boolean> {
+
+		public ManagedEndpoint() {
+			super(""managed"", true, true);
+		}
+
+		@Override
+		public Boolean invoke() {
+			return true;
+		}
+
+	}
+
+	@Configuration
+	@ManagedResource
+	protected static class NestedInManagedEndpoint {
+
+		@Bean
+		public Endpoint<Boolean> nested() {
+			return new Nested();
+		}
+
+		class Nested extends AbstractEndpoint<Boolean> {
+
+			public Nested() {
+				super(""managed"", true, true);
+			}
+
+			@Override
+			public Boolean invoke() {
+				return true;
+			}
+		}
+
+	}
+
 }
",True,"The commit message refers to a convention regarding the use of @ManagedResource annotation. It explains that if an Endpoint is already annotated with @ManagedResource, it doesn't need an additional MBean registration. This is to prevent potentially wrong MBean registrations based on the invoke() method.",True,"The commit message explains the necessity of changes by stating that if an Endpoint is already annotated with @ManagedResource, then it doesn't need an additional MBEan registration based on the invoke() method. This is because the @ManagedResource annotation is used to expose a Spring bean to JMX, and if the Endpoint is already managed, then registering it again would be redundant and potentially incorrect.",True,"The commit message directly elaborates the motivation of the code change by mentioning the issue that arises if an Endpoint is already @ManagedResource. This means that it doesn't need an additional MBEan registration based on the invoke() method, which could potentially be wrong.",True,The commit message 'Exclude @ManagedResources from Endpoint MBeans' indicates that the developer is making changes to address the need to avoid unnecessary or incorrect MBean registrations for Endpoints that are already annotated with @ManagedResource. This suggests that the change is being made to improve the software maintenance process and to address a problem with out-of-date code.,True,"The commit message directly mentions the objective of the change by stating that it excludes '@ManagedResources' from Endpoint MBeans. This is because if an Endpoint is already '@ManagedResource', then it doesn't need an additional MBean registration based on the invoke() method. This change is likely to prevent unnecessary or incorrect MBean registrations, which could improve the code.",True,"The commit message 'Exclude @ManagedResources from Endpoint MBeans' effectively summarizes the change made in the code diff. It highlights the key component of the change, which is the exclusion of Endpoints that are already annotated with @ManagedResource from additional MBean registration. This contrasts the before state (where all Endpoints were registered) and the after state (where only Endpoints not already annotated with @ManagedResource are registered).",True,"The commit message explains that the changes are made to prevent additional MBean registration for Endpoints that are already annotated with @ManagedResource. This highlights the principle of avoiding redundant or unnecessary operations, which is a common technical principle in software development.",True,"The commit message 'Exclude @ManagedResources from Endpoint MBeans' clearly explains the functional change made in the code. It states that if an Endpoint is already annotated with @ManagedResource, it doesn't need an additional MBean registration based on the invoke() method. This is consistent with the code changes, where the commit adds checks to see if the Endpoint class or its enclosing class is annotated with @ManagedResource. If so, the Endpoint is not registered as an MBean.",False,"The commit message explains the reason for the change, which is to prevent duplicate and potentially incorrect MBean registrations for Endpoints that are already annotated with @ManagedResource. This is not something that can be easily inferred from the code diff alone."
https://github.com/junit-team/junit4/commit/13bda470bfa1fe989ce80d616fb096af1b937146,Make ParallelComputer more beautiful by creating a Decorator  <enter> extension point in ParentRunner <enter> Signed-off-by: Kent Beck <kent@threeriversinstitute.org> ,https://api.github.com/repos/junit-team/junit4/commits/13bda470bfa1fe989ce80d616fb096af1b937146,"@@ -8,14 +8,9 @@
 import java.util.concurrent.Future;
 
 import org.junit.runner.Computer;
-import org.junit.runner.Description;
 import org.junit.runner.Runner;
-import org.junit.runner.notification.RunNotifier;
-import org.junit.runners.BlockJUnit4ClassRunner;
 import org.junit.runners.ParentRunner;
-import org.junit.runners.Suite;
-import org.junit.runners.model.InitializationError;
-import org.junit.runners.model.RunnerBuilder;
+import org.junit.tests.SafeStatement;
 
 public class ParallelComputer extends Computer {
 	private final boolean fClasses;
@@ -35,69 +30,50 @@ public static Computer methods() {
 		return new ParallelComputer(false, true);
 	}
 
-	private static <T> Runner parallelize(ParentRunner<T> runner)
-			throws InitializationError {
-		return new ParallelParentRunner<T>(runner);
+	private static void parallelize(Runner runner) {
+		((ParentRunner<?>) runner).installDecorator(new ParentRunner.Decorator() {
+			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();
+
+			private final ExecutorService fService= Executors
+					.newCachedThreadPool();
+
+			public void runAll(SafeStatement statement) {
+				statement.execute();
+				for (Future<Object> each : fResults)
+					try {
+						each.get();
+					} catch (Exception e) {
+						e.printStackTrace();
+					}
+
+			}
+
+			public void runChild(final SafeStatement statement) {
+				fResults.add(fService.submit(new Callable<Object>() {
+					public Object call() throws Exception {
+						statement.execute();
+						return null;
+					}
+				}));
+			}
+		});
 	}
-
-	private static class ParallelParentRunner<T> extends ParentRunner<T> {
-		private final ParentRunner<T> fDelegate;
-
-		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();
-
-		private final ExecutorService fService= Executors.newCachedThreadPool();
-
-		public ParallelParentRunner(ParentRunner<T> delegate)
-				throws InitializationError {
-			super(delegate.getTestClass().getJavaClass());
-			fDelegate= delegate;
-		}
-
-		@Override
-		public Description describeChild(T child) {
-			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
-			return fDelegate.internalDescribeChild(child);
-		}
-
-		@Override
-		public List<T> getChildren() {
-			return fDelegate.internalGetChildren();
-		}
-
-		@Override
-		public void runChild(final T child, final RunNotifier notifier) {
-			fResults.add(fService.submit(new Callable<Object>() {
-				public Object call() throws Exception {
-					fDelegate.internalRunChild(child, notifier);
-					return null;
-				}
-			}));
-		}
-
-		@Override
-		public void run(RunNotifier notifier) {
-			super.run(notifier);
-			for (Future<Object> each : fResults)
-				try {
-					each.get();
-				} catch (Exception e) {
-					e.printStackTrace();
-				}
-		}
-	}
-
+	
 	@Override
-	public Runner getSuite(RunnerBuilder builder, java.lang.Class<?>[] classes)
-			throws InitializationError {
-		Suite suite= (Suite) super.getSuite(builder, classes);
-		return fClasses ? parallelize(suite) : suite;
+	protected Runner modify(Runner runner) {
+		if (shouldParallelize(runner))
+			parallelize(runner);
+		return runner;
 	}
 
-	@Override
-	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
-			throws Throwable {
-		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
-		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super.getRunner(builder, testClass);
-		return fMethods ? parallelize(runner) : runner;
+	private boolean shouldParallelize(Runner runner) {
+		if (runner instanceof ParentRunner) {
+			ParentRunner<?> parentRunner= (ParentRunner<?>) runner;
+			if (fClasses && parentRunner.isSuite())
+				return true;
+			if (fMethods && !parentRunner.isSuite())
+				return true;
+		}
+		return false;
 	}
 }
@@ -11,15 +11,19 @@ public static Computer serial() {
 
 	public Runner getSuite(final RunnerBuilder builder,
 			Class<?>[] classes) throws InitializationError {
-		return new Suite(new RunnerBuilder() {
+		return modify(new Suite(new RunnerBuilder() {
 			@Override
 			public Runner runnerForClass(Class<?> testClass) throws Throwable {
 				return getRunner(builder, testClass);
 			}
-		}, classes);
+		}, classes));
+	}
+
+	protected Runner modify(Runner runner) {
+		return runner;
 	}
 
 	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {
-		return builder.runnerForClass(testClass);
+		return modify(builder.runnerForClass(testClass));
 	}
 }
@@ -27,6 +27,7 @@
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.Statement;
 import org.junit.runners.model.TestClass;
+import org.junit.tests.SafeStatement;
 
 /**
  * Provides most of the functionality specific to a Runner that implements a
@@ -40,15 +41,32 @@
  */
 public abstract class ParentRunner<T> extends Runner implements Filterable,
 		Sortable {
+	public interface Decorator {
+		void runChild(SafeStatement statement);
+
+		void runAll(SafeStatement statement);
+	}
+
 	private final TestClass fTestClass;
 
 	private Filter fFilter= null;
 
 	private Sorter fSorter= Sorter.NULL;
 
+	private Decorator fDecorator= new Decorator() {
+		public void runAll(SafeStatement statement) {
+			statement.execute();
+		}
+
+		public void runChild(SafeStatement statement) {
+			statement.execute();
+		}
+	};
+
 	/**
 	 * Constructs a new {@code ParentRunner} that will run {@code @TestClass}
-	 * @throws InitializationError 
+	 * 
+	 * @throws InitializationError
 	 */
 	protected ParentRunner(Class<?> testClass) throws InitializationError {
 		fTestClass= new TestClass(testClass);
@@ -77,38 +95,40 @@ protected ParentRunner(Class<?> testClass) throws InitializationError {
 	 * reported through {@code notifier}
 	 */
 	protected abstract void runChild(T child, RunNotifier notifier);
-	
-	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows delegation without breaking subclasses
+
+	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows
+	// delegation without breaking subclasses
 	/**
-	 * Interim interface during 4.7 development.  _Very_ likely to go away.
+	 * Interim interface during 4.7 development. _Very_ likely to go away.
 	 */
 	public List<T> internalGetChildren() {
 		return getChildren();
 	}
 
 	/**
-	 * Interim interface during 4.7 development.  _Very_ likely to go away.
+	 * Interim interface during 4.7 development. _Very_ likely to go away.
 	 */
 	public Description internalDescribeChild(T child) {
 		return describeChild(child);
 	}
 
 	/**
-	 * Interim interface during 4.7 development.  _Very_ likely to go away.
+	 * Interim interface during 4.7 development. _Very_ likely to go away.
 	 */
 	public void internalRunChild(T child, RunNotifier notifier) {
 		runChild(child, notifier);
 	}
-	
+
 	//
 	// May be overridden
 	//
-	
+
 	/**
-	 * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).
-	 * Default implementation adds an error for each method annotated with
-	 * {@code @BeforeClass} or {@code @AfterClass} that is not
-	 * {@code public static void} with no arguments.
+	 * Adds to {@code errors} a throwable for each problem noted with the test
+	 * class (available from {@link #getTestClass()}). Default implementation
+	 * adds an error for each method annotated with {@code @BeforeClass} or
+	 * {@code @AfterClass} that is not {@code public static void} with no
+	 * arguments.
 	 */
 	protected void collectInitializationErrors(List<Throwable> errors) {
 		validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);
@@ -125,28 +145,33 @@ protected void collectInitializationErrors(List<Throwable> errors) {
 	 * <li>is static (given {@code isStatic is false}), or
 	 * <li>is not static (given {@code isStatic is true}).
 	 */
-	protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,
-			boolean isStatic, List<Throwable> errors) {
-		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(annotation);
+	protected void validatePublicVoidNoArgMethods(
+			Class<? extends Annotation> annotation, boolean isStatic,
+			List<Throwable> errors) {
+		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(
+				annotation);
 
 		for (FrameworkMethod eachTestMethod : methods)
 			eachTestMethod.validatePublicVoidNoArg(isStatic, errors);
 	}
 
-	/** 
-	 * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing. 
-	 * Here is an outline of the implementation:
+	/**
+	 * Constructs a {@code Statement} to run all of the tests in the test class.
+	 * Override to add pre-/post-processing. Here is an outline of the
+	 * implementation:
 	 * <ul>
-	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).</li>
-	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class
-	 * and superclasses before the previous step; if any throws an
+	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned
+	 * by {@link #getChildren()} (subject to any imposed filter and sort).</li>
+	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this
+	 * class and superclasses before the previous step; if any throws an
 	 * Exception, stop execution and pass the exception on.
-	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class
-	 * and superclasses before any of the previous steps; all AfterClass methods are
-	 * always executed: exceptions thrown by previous steps are combined, if
-	 * necessary, with exceptions from AfterClass methods into a
+	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this
+	 * class and superclasses before any of the previous steps; all AfterClass
+	 * methods are always executed: exceptions thrown by previous steps are
+	 * combined, if necessary, with exceptions from AfterClass methods into a
 	 * {@link MultipleFailureException}.
 	 * </ul>
+	 * 
 	 * @param notifier
 	 * @return {@code Statement}
 	 */
@@ -158,9 +183,9 @@ protected Statement classBlock(final RunNotifier notifier) {
 	}
 
 	/**
-	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class
-	 * and superclasses before executing {@code statement}; if any throws an
-	 * Exception, stop execution and pass the exception on.
+	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass}
+	 * methods on this class and superclasses before executing {@code statement}
+	 * ; if any throws an Exception, stop execution and pass the exception on.
 	 */
 	protected Statement withBeforeClasses(Statement statement) {
 		List<FrameworkMethod> befores= fTestClass
@@ -170,11 +195,11 @@ protected Statement withBeforeClasses(Statement statement) {
 	}
 
 	/**
-	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class
-	 * and superclasses before executing {@code statement}; all AfterClass methods are
-	 * always executed: exceptions thrown by previous steps are combined, if
-	 * necessary, with exceptions from AfterClass methods into a
-	 * {@link MultipleFailureException}.
+	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass}
+	 * methods on this class and superclasses before executing {@code statement}
+	 * ; all AfterClass methods are always executed: exceptions thrown by
+	 * previous steps are combined, if necessary, with exceptions from
+	 * AfterClass methods into a {@link MultipleFailureException}.
 	 */
 	protected Statement withAfterClasses(Statement statement) {
 		List<FrameworkMethod> afters= fTestClass
@@ -198,8 +223,16 @@ public void evaluate() {
 	}
 
 	private void runChildren(final RunNotifier notifier) {
-		for (T each : getFilteredChildren())
-			runChild(each, notifier);
+		fDecorator.runAll(new SafeStatement() {
+			public void execute() {
+				for (final T each : getFilteredChildren())
+					fDecorator.runChild(new SafeStatement() {
+						public void execute() {
+							runChild(each, notifier);
+						}
+					});
+			}
+		});
 	}
 
 	/**
@@ -223,7 +256,7 @@ public final TestClass getTestClass() {
 	//
 	// Implementation of Runner
 	// 
-	
+
 	@Override
 	public Description getDescription() {
 		Description description= Description.createSuiteDescription(getName(),
@@ -248,7 +281,7 @@ public void run(final RunNotifier notifier) {
 			testNotifier.addFailure(e);
 		}
 	}
-	
+
 	//
 	// Implementation of Filterable and Sortable
 	//
@@ -265,7 +298,7 @@ public void filter(Filter filter) throws NoTestsRemainException {
 	public void sort(Sorter sorter) {
 		fSorter= sorter;
 	}
-	
+
 	//
 	// Private implementation
 	// 
@@ -312,4 +345,14 @@ public int compare(T o1, T o2) {
 			}
 		};
 	}
+
+	// TODO (May 11, 2009 2:53:54 PM): complex
+	public void installDecorator(Decorator decorator) {
+		this.fDecorator= decorator;
+	}
+
+	// TODO (May 11, 2009 4:19:18 PM): move?
+	public boolean isSuite() {
+		return false;
+	}
 }
\ No newline at end of file
@@ -118,4 +118,9 @@ protected Description describeChild(Runner child) {
 	protected void runChild(Runner runner, final RunNotifier notifier) {
 		runner.run(notifier);
 	}
+	
+	@Override
+	public boolean isSuite() {
+		return true;
+	}
 }
@@ -124,7 +124,8 @@
 	InterceptorTest.class,
 	TimeoutInterceptorTest.class,
 	ParallelClassTest.class,
-	ParallelMethodTest.class
+	ParallelMethodTest.class,
+	ParentRunnerTest.class
 })
 public class AllTests {
 	public static Test suite() {
@@ -0,0 +1,68 @@
+package org.junit.tests;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.Comparator;
+
+import org.junit.Test;
+import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
+import org.junit.runner.Description;
+import org.junit.runner.manipulation.Sorter;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.BlockJUnit4ClassRunner;
+import org.junit.runners.ParentRunner;
+import org.junit.runners.model.FrameworkMethod;
+
+// TODO (May 11, 2009 2:42:38 PM): move package
+
+public class ParentRunnerTest {
+	private static StringBuffer log= new StringBuffer();
+
+	public static class FruitTests {
+		@Test
+		public void apple() {
+			log.append(""apple "");
+		}
+
+		@Test
+		public void banana() {
+			log.append(""banana "");
+		}
+
+		@Test
+		public void pear() {
+			log.append(""pear "");
+		}
+	}
+
+	@Test
+	public void installDecorator() throws Throwable {
+		log.setLength(0);
+		ParentRunner<FrameworkMethod> runner= (BlockJUnit4ClassRunner) new AllDefaultPossibilitiesBuilder(
+				true).runnerForClass(FruitTests.class);
+		// TODO (May 11, 2009 2:58:11 PM): DUP?
+		runner.sort(new Sorter(new Comparator<Description>() {
+			public int compare(Description o1, Description o2) {
+				return o1.toString().compareTo(o2.toString());
+			}
+		}));
+		runner.installDecorator(new ParentRunner.Decorator() {
+			public void runChild(SafeStatement statement) {
+				log.append(""before "");
+				statement.execute();
+				log.append(""after "");
+			}
+
+			public void runAll(SafeStatement statement) {
+				log.append(""beforeAll "");
+				statement.execute();
+				log.append(""afterAll "");
+			}
+		});
+
+		runner.run(new RunNotifier());
+		assertEquals(
+				""beforeAll before apple after before banana after before pear after afterAll "",
+				log.toString());
+	}
+}
@@ -0,0 +1,8 @@
+package org.junit.tests;
+
+// TODO (May 11, 2009 2:54:22 PM): move elsewhere
+public interface SafeStatement {
+
+	void execute();
+
+}
@@ -15,7 +15,6 @@
 
 
 public class ParallelClassTest {
-
 	public static class Example1 {
 		@Test public void one() throws InterruptedException {
 			Thread.sleep(1000);
@@ -30,7 +29,7 @@ public static class Example2 {
 	@RunWith(Suite.class)
 	@SuiteClasses({Example1.class, Example2.class})
 	public static class ExampleSuite {}
-	
+
 	// TODO(parallel) we need to push parallel execution down through suites (i.e. run a Suite with a parallel executioner and you get parallel execution)
 	@Test(timeout=1500) public void testsRunInParallel() {
 		long start= System.currentTimeMillis();
@@ -39,6 +38,15 @@ public static class ExampleSuite {}
 		long end= System.currentTimeMillis();
 		assertThat(end - start, greaterThan(999)); // Overhead could be less than half a millisecond
 	}
+	
+	// TODO(parallel) we need to push parallel execution down through suites (i.e. run a Suite with a parallel executioner and you get parallel execution)
+	@Test(timeout=2500) public void testsDontRunInParallelIfOnlyMethods() {
+		long start= System.currentTimeMillis();
+		Result result= JUnitCore.runClasses(ParallelComputer.methods(), Example1.class, Example2.class);
+		assertTrue(result.wasSuccessful());
+		long end= System.currentTimeMillis();
+		assertThat(end - start, greaterThan(1999)); // Overhead could be less than half a millisecond
+	}
 
 	private Matcher<Long> greaterThan(final long l) {
 		return new TypeSafeMatcher<Long>() {
",True,"The commit message refers to the creation of a Decorator extension point in ParentRunner, which is likely to improve the flexibility and extensibility of the code. This change is likely to be made to support parallel execution of tests, as indicated by the name of the class being modified (ParallelComputer) and the addition of a new Decorator interface and its implementation in the ParallelComputer class.",True,"The commit message 'Make ParallelComputer more beautiful by creating a Decorator extension point in ParentRunner' does not explicitly state the necessity of the changes. However, the changes made in the code diff indicate that the commit is adding a decorator pattern to the ParentRunner class to make it more flexible and extensible. This is a common practice in software development to improve code maintainability and add new features without modifying existing code. Therefore, the commit message can be considered to contain an expression that describes the necessity of changes.",True,"The commit message 'Make ParallelComputer more beautiful by creating a Decorator extension point in ParentRunner' does not explicitly describe the necessity of changes by directly elaborating the motivation of a code change. However, the code diff indicates that the changes are made to improve the structure and functionality of the ParallelComputer class by introducing a Decorator pattern in the ParentRunner class. This suggests that the changes are likely made to address the shortcoming of the previous implementation, which might have been less flexible and extensible. Therefore, the commit message could have been more descriptive about the need for these changes to improve the design and functionality of the code.",True,"The commit message 'Make ParallelComputer more beautiful by creating a Decorator extension point in ParentRunner' indicates that the developer is improving the code structure and design for better extensibility and maintainability. This could be a response to the need for software development to meet the requirements of users or to improve the process of software maintenance, as it allows for easier addition of new functionality without modifying existing code.",True,"The commit message 'Make ParallelComputer more beautiful by creating a Decorator extension point in ParentRunner' directly mentions the improvement made to the code, which is the addition of a Decorator extension point in the ParentRunner class. This allows for more flexibility and customization in the execution of tests.",True,"The commit message 'Make ParallelComputer more beautiful by creating a Decorator extension point in ParentRunner' describes the change made in the code diff. The change is the creation of a Decorator extension point in the ParentRunner class, which allows for the parallel execution of tests by installing a decorator. This is a clear and concise summary of the changes made in the code diff.",True,"The commit message 'Make ParallelComputer more beautiful by creating a Decorator extension point in ParentRunner' suggests that the technical principle underpinning the changes is the use of the Decorator pattern. This pattern allows behavior to be added to an existing object dynamically, without changing its interface. In this case, the Decorator pattern is used to add parallel execution behavior to the ParentRunner class.",True,"The commit message 'Make ParallelComputer more beautiful by creating a Decorator extension point in ParentRunner' describes the changes made to the code. The changes involve creating a Decorator interface in the ParentRunner class, which allows for the addition of pre- and post-processing to the execution of tests. This introduces new behavior to the code, enabling parallel execution of tests with the ability to customize the execution flow.",False,"The commit message does not explicitly explain the reason for the commit, but the change is not trivial. The code diff shows that a Decorator extension point has been created in ParentRunner, which allows for the parallelization of test execution. This is a significant change that could potentially improve performance, but it also introduces new complexity and could potentially break existing code. Therefore, a commit message that explains this change and its potential benefits and drawbacks would be appropriate."
https://github.com/apache/dubbo/commit/243e57130646c69c047910dd079f19cbadc57613,Remove unnecessary null check. ,https://api.github.com/repos/apache/dubbo/commits/243e57130646c69c047910dd079f19cbadc57613,"@@ -338,7 +338,7 @@ public synchronized void unexport() {
         if (unexported) {
             return;
         }
-        if (exporters != null && !exporters.isEmpty()) {
+        if (!exporters.isEmpty()) {
             for (Exporter<?> exporter : exporters) {
                 try {
                     exporter.unexport();
",False,"The commit message does not reference any conventions, standards, improvements in prior commits, or implemented features. It simply states that a null check is being removed, which does not necessarily imply a need for the change.",True,"The commit message 'Remove unnecessary null check' does not explicitly explain why the change is necessary. However, it is easy to infer from the code diff that the null check was unnecessary because it is checking if 'exporters' is null and then if it's empty. If 'exporters' is null, it would throw a NullPointerException before reaching the check for emptiness. Therefore, the null check is redundant and can be removed.",False,"The commit message does not explicitly describe the necessity of the changes. It only states that the null check is unnecessary, but it does not elaborate on why this null check was previously necessary or what problem it was intended to solve. The code diff shows that the null check and the subsequent check for an empty list have been removed, but the commit message does not provide any context or explanation for this change.",False,"The commit message 'Remove unnecessary null check' does not explicitly describe the source of the requirements or the necessity of the changes. It simply states what the change is, but it does not provide any context about why the change was made. The code diff shows that a null check was removed, but it does not indicate any issues with outdated code, runtime or development environment changes, or user requirements.",False,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only states that a null check is being removed. While this can be an improvement, it does not explicitly describe the reason for the change or the potential benefits.",True,"The commit message 'Remove unnecessary null check' accurately summarizes the change in the diff. It points out the key component of the change, which is the removal of a null check on the 'exporters' variable. This change simplifies the code and makes it more efficient by directly checking if 'exporters' is empty, instead of checking if it's null and then if it's empty.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only states that a null check is being removed, but it does not explain why this is a good practice or what principle it is based on.",True,"The commit message 'Remove unnecessary null check' describes a change in the code where a null check for the 'exporters' variable is removed. This change does not introduce new behaviors, but it simplifies the code and improves its readability. However, it does describe a functional change as it removes a condition that was previously necessary but is no longer needed due to the code changes.",True,"The commit message 'Remove unnecessary null check' clearly indicates that the change was made to simplify the code. The diff shows that a null check for the 'exporters' variable was removed, and the check was replaced with a check for the 'exporters' list being empty. This change was made to make the code cleaner and more efficient, and the reason for the change is clearly explained in the commit message. Therefore, there was no need for an additional explanation of the change in the commit message."
https://github.com/spring-projects/spring-boot/commit/e3899df22c1f8de17081fababcbd5c406a3c8541,"Configure Spring Data Couchbase explicitly  <enter> This commit configures Spring Data Couchbase explicitly rather than relying on the abstract configuration class. This has the advantage of simplifying the auto-configuration and let it us proxy-free configuration classes. <enter> Spring Boot no longer uses or interacts with CouchbaseConfigurer. Users relying on that to teach Spring Boot which components to use should rely on `@Primary` flag instead in case of multiple beans of the same type. <enter> `CouchbaseConfiguration` is no longer public as extending from it is no longer necessary. If the `CouchbaseEnvironment` has to be customized, a `CouchbaseEnvironmentBuilderCustomizer` bean can be registered to tune the auto-configured environment. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/e3899df22c1f8de17081fababcbd5c406a3c8541,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -16,18 +16,28 @@
 
 package org.springframework.boot.autoconfigure.couchbase;
 
+import com.couchbase.client.core.env.KeyValueServiceConfig;
+import com.couchbase.client.core.env.QueryServiceConfig;
+import com.couchbase.client.core.env.ViewServiceConfig;
+import com.couchbase.client.java.Bucket;
 import com.couchbase.client.java.Cluster;
 import com.couchbase.client.java.CouchbaseBucket;
+import com.couchbase.client.java.CouchbaseCluster;
+import com.couchbase.client.java.cluster.ClusterInfo;
+import com.couchbase.client.java.env.CouchbaseEnvironment;
+import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;
+import com.couchbase.client.java.env.DefaultCouchbaseEnvironment.Builder;
 
+import org.springframework.beans.factory.ObjectProvider;
 import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
-import org.springframework.boot.autoconfigure.condition.AnyNestedCondition;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties.Endpoints;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Conditional;
 import org.springframework.context.annotation.Configuration;
-import org.springframework.context.annotation.Import;
+import org.springframework.context.annotation.DependsOn;
 
 /**
  * {@link EnableAutoConfiguration Auto-configuration} for Couchbase.
@@ -39,42 +49,105 @@
  */
 @Configuration(proxyBeanMethods = false)
 @ConditionalOnClass({ CouchbaseBucket.class, Cluster.class })
-@Conditional(CouchbaseAutoConfiguration.CouchbaseCondition.class)
+@Conditional(OnBootstrapHostsCondition.class)
 @EnableConfigurationProperties(CouchbaseProperties.class)
 public class CouchbaseAutoConfiguration {
 
-	@Configuration(proxyBeanMethods = false)
-	@ConditionalOnMissingBean(value = CouchbaseConfiguration.class,
-			type = ""org.springframework.data.couchbase.config.CouchbaseConfigurer"")
-	@Import(CouchbaseConfiguration.class)
-	static class DefaultCouchbaseConfiguration {
-
+	@Bean
+	@ConditionalOnMissingBean(CouchbaseEnvironment.class)
+	public DefaultCouchbaseEnvironment couchbaseEnvironment(CouchbaseProperties properties,
+			ObjectProvider<CouchbaseEnvironmentBuilderCustomizer> customizers) {
+		Builder builder = initializeEnvironmentBuilder(properties);
+		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
+		return builder.build();
 	}
 
-	/**
-	 * Determine if Couchbase should be configured. This happens if either the
-	 * user-configuration defines a {@code CouchbaseConfigurer} or if at least the
-	 * ""bootstrapHosts"" property is specified.
-	 * <p>
-	 * The reason why we check for the presence of {@code CouchbaseConfigurer} is that it
-	 * might use {@link CouchbaseProperties} for its internal customization.
-	 */
-	static class CouchbaseCondition extends AnyNestedCondition {
-
-		CouchbaseCondition() {
-			super(ConfigurationPhase.REGISTER_BEAN);
+	@Bean
+	@ConditionalOnMissingBean(Cluster.class)
+	public CouchbaseCluster couchbaseCluster(CouchbaseProperties properties,
+			CouchbaseEnvironment couchbaseEnvironment) {
+		CouchbaseCluster couchbaseCluster = CouchbaseCluster.create(couchbaseEnvironment,
+				properties.getBootstrapHosts());
+		if (isRoleBasedAccessControlEnabled(properties)) {
+			return couchbaseCluster.authenticate(properties.getUsername(), properties.getPassword());
 		}
+		return couchbaseCluster;
+	}
 
-		@Conditional(OnBootstrapHostsCondition.class)
-		static class BootstrapHostsProperty {
+	@Bean
+	@ConditionalOnMissingBean
+	@DependsOn(""couchbaseClient"")
+	public ClusterInfo couchbaseClusterInfo(CouchbaseProperties properties, Cluster couchbaseCluster) {
+		if (isRoleBasedAccessControlEnabled(properties)) {
+			return couchbaseCluster.clusterManager().info();
+		}
+		return couchbaseCluster.clusterManager(properties.getBucket().getName(), properties.getBucket().getPassword())
+				.info();
+	}
 
+	@Bean
+	@ConditionalOnMissingBean
+	public Bucket couchbaseClient(CouchbaseProperties properties, Cluster couchbaseCluster) {
+		if (isRoleBasedAccessControlEnabled(properties)) {
+			return couchbaseCluster.openBucket(properties.getBucket().getName());
 		}
+		return couchbaseCluster.openBucket(properties.getBucket().getName(), properties.getBucket().getPassword());
+	}
 
-		@ConditionalOnBean(type = ""org.springframework.data.couchbase.config.CouchbaseConfigurer"")
-		static class CouchbaseConfigurerAvailable {
+	private boolean isRoleBasedAccessControlEnabled(CouchbaseProperties properties) {
+		return properties.getUsername() != null && properties.getPassword() != null;
+	}
 
+	private DefaultCouchbaseEnvironment.Builder initializeEnvironmentBuilder(CouchbaseProperties properties) {
+		CouchbaseProperties.Endpoints endpoints = properties.getEnv().getEndpoints();
+		CouchbaseProperties.Timeouts timeouts = properties.getEnv().getTimeouts();
+		CouchbaseProperties.Bootstrap bootstrap = properties.getEnv().getBootstrap();
+		DefaultCouchbaseEnvironment.Builder builder = DefaultCouchbaseEnvironment.builder();
+		if (bootstrap.getHttpDirectPort() != null) {
+			builder.bootstrapHttpDirectPort(bootstrap.getHttpDirectPort());
+		}
+		if (bootstrap.getHttpSslPort() != null) {
+			builder.bootstrapHttpSslPort(bootstrap.getHttpSslPort());
+		}
+		if (timeouts.getConnect() != null) {
+			builder = builder.connectTimeout(timeouts.getConnect().toMillis());
 		}
+		builder = builder.keyValueServiceConfig(KeyValueServiceConfig.create(endpoints.getKeyValue()));
+		if (timeouts.getKeyValue() != null) {
+			builder = builder.kvTimeout(timeouts.getKeyValue().toMillis());
+		}
+		if (timeouts.getQuery() != null) {
+			builder = builder.queryTimeout(timeouts.getQuery().toMillis());
+			builder = builder.queryServiceConfig(getQueryServiceConfig(endpoints));
+			builder = builder.viewServiceConfig(getViewServiceConfig(endpoints));
+		}
+		if (timeouts.getSocketConnect() != null) {
+			builder = builder.socketConnectTimeout((int) timeouts.getSocketConnect().toMillis());
+		}
+		if (timeouts.getView() != null) {
+			builder = builder.viewTimeout(timeouts.getView().toMillis());
+		}
+		CouchbaseProperties.Ssl ssl = properties.getEnv().getSsl();
+		if (ssl.getEnabled()) {
+			builder = builder.sslEnabled(true);
+			if (ssl.getKeyStore() != null) {
+				builder = builder.sslKeystoreFile(ssl.getKeyStore());
+			}
+			if (ssl.getKeyStorePassword() != null) {
+				builder = builder.sslKeystorePassword(ssl.getKeyStorePassword());
+			}
+		}
+		return builder;
+	}
+
+	private QueryServiceConfig getQueryServiceConfig(Endpoints endpoints) {
+		return QueryServiceConfig.create(endpoints.getQueryservice().getMinEndpoints(),
+				endpoints.getQueryservice().getMaxEndpoints());
+	}
 
+	private ViewServiceConfig getViewServiceConfig(Endpoints endpoints) {
+		return ViewServiceConfig.create(endpoints.getViewservice().getMinEndpoints(),
+				endpoints.getViewservice().getMaxEndpoints());
 	}
 
 }
@@ -1,159 +0,0 @@
-/*
- * Copyright 2012-2020 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.couchbase;
-
-import java.util.List;
-
-import com.couchbase.client.core.env.KeyValueServiceConfig;
-import com.couchbase.client.core.env.QueryServiceConfig;
-import com.couchbase.client.core.env.ViewServiceConfig;
-import com.couchbase.client.java.Bucket;
-import com.couchbase.client.java.Cluster;
-import com.couchbase.client.java.CouchbaseCluster;
-import com.couchbase.client.java.cluster.ClusterInfo;
-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;
-
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties.Endpoints;
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.context.annotation.DependsOn;
-import org.springframework.context.annotation.Primary;
-
-/**
- * Support class to configure Couchbase based on {@link CouchbaseProperties}.
- *
- * @author Stephane Nicoll
- * @author Brian Clozel
- * @since 2.1.0
- */
-@Configuration
-public class CouchbaseConfiguration {
-
-	private final CouchbaseProperties properties;
-
-	public CouchbaseConfiguration(CouchbaseProperties properties) {
-		this.properties = properties;
-	}
-
-	@Bean
-	@Primary
-	public DefaultCouchbaseEnvironment couchbaseEnvironment() {
-		return initializeEnvironmentBuilder(this.properties).build();
-	}
-
-	@Bean
-	@Primary
-	public Cluster couchbaseCluster() {
-		CouchbaseCluster couchbaseCluster = CouchbaseCluster.create(couchbaseEnvironment(), determineBootstrapHosts());
-		if (isRoleBasedAccessControlEnabled()) {
-			return couchbaseCluster.authenticate(this.properties.getUsername(), this.properties.getPassword());
-		}
-		return couchbaseCluster;
-	}
-
-	/**
-	 * Determine the Couchbase nodes to bootstrap from.
-	 * @return the Couchbase nodes to bootstrap from
-	 */
-	protected List<String> determineBootstrapHosts() {
-		return this.properties.getBootstrapHosts();
-	}
-
-	@Bean
-	@Primary
-	@DependsOn(""couchbaseClient"")
-	public ClusterInfo couchbaseClusterInfo() {
-		if (isRoleBasedAccessControlEnabled()) {
-			return couchbaseCluster().clusterManager().info();
-		}
-		return couchbaseCluster()
-				.clusterManager(this.properties.getBucket().getName(), this.properties.getBucket().getPassword())
-				.info();
-	}
-
-	@Bean
-	@Primary
-	public Bucket couchbaseClient() {
-		if (isRoleBasedAccessControlEnabled()) {
-			return couchbaseCluster().openBucket(this.properties.getBucket().getName());
-		}
-		return couchbaseCluster().openBucket(this.properties.getBucket().getName(),
-				this.properties.getBucket().getPassword());
-	}
-
-	private boolean isRoleBasedAccessControlEnabled() {
-		return this.properties.getUsername() != null && this.properties.getPassword() != null;
-	}
-
-	/**
-	 * Initialize an environment builder based on the specified settings.
-	 * @param properties the couchbase properties to use
-	 * @return the {@link DefaultCouchbaseEnvironment} builder.
-	 */
-	protected DefaultCouchbaseEnvironment.Builder initializeEnvironmentBuilder(CouchbaseProperties properties) {
-		CouchbaseProperties.Endpoints endpoints = properties.getEnv().getEndpoints();
-		CouchbaseProperties.Timeouts timeouts = properties.getEnv().getTimeouts();
-		CouchbaseProperties.Bootstrap bootstrap = properties.getEnv().getBootstrap();
-		DefaultCouchbaseEnvironment.Builder builder = DefaultCouchbaseEnvironment.builder();
-		if (bootstrap.getHttpDirectPort() != null) {
-			builder.bootstrapHttpDirectPort(bootstrap.getHttpDirectPort());
-		}
-		if (bootstrap.getHttpSslPort() != null) {
-			builder.bootstrapHttpSslPort(bootstrap.getHttpSslPort());
-		}
-		if (timeouts.getConnect() != null) {
-			builder = builder.connectTimeout(timeouts.getConnect().toMillis());
-		}
-		builder = builder.keyValueServiceConfig(KeyValueServiceConfig.create(endpoints.getKeyValue()));
-		if (timeouts.getKeyValue() != null) {
-			builder = builder.kvTimeout(timeouts.getKeyValue().toMillis());
-		}
-		if (timeouts.getQuery() != null) {
-			builder = builder.queryTimeout(timeouts.getQuery().toMillis());
-			builder = builder.queryServiceConfig(getQueryServiceConfig(endpoints));
-			builder = builder.viewServiceConfig(getViewServiceConfig(endpoints));
-		}
-		if (timeouts.getSocketConnect() != null) {
-			builder = builder.socketConnectTimeout((int) timeouts.getSocketConnect().toMillis());
-		}
-		if (timeouts.getView() != null) {
-			builder = builder.viewTimeout(timeouts.getView().toMillis());
-		}
-		CouchbaseProperties.Ssl ssl = properties.getEnv().getSsl();
-		if (ssl.getEnabled()) {
-			builder = builder.sslEnabled(true);
-			if (ssl.getKeyStore() != null) {
-				builder = builder.sslKeystoreFile(ssl.getKeyStore());
-			}
-			if (ssl.getKeyStorePassword() != null) {
-				builder = builder.sslKeystorePassword(ssl.getKeyStorePassword());
-			}
-		}
-		return builder;
-	}
-
-	private QueryServiceConfig getQueryServiceConfig(Endpoints endpoints) {
-		return QueryServiceConfig.create(endpoints.getQueryservice().getMinEndpoints(),
-				endpoints.getQueryservice().getMaxEndpoints());
-	}
-
-	private ViewServiceConfig getViewServiceConfig(Endpoints endpoints) {
-		return ViewServiceConfig.create(endpoints.getViewservice().getMinEndpoints(),
-				endpoints.getViewservice().getMaxEndpoints());
-	}
-
-}
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2012-2020 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.couchbase;
+
+import com.couchbase.client.java.env.CouchbaseEnvironment;
+import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;
+
+/**
+ * Callback interface that can be implemented by beans wishing to customize the
+ * {@link CouchbaseEnvironment} via a {@link DefaultCouchbaseEnvironment.Builder} whilst
+ * retaining default auto-configuration.
+ *
+ * @author Stephane Nicoll
+ * @since 2.3.0
+ */
+@FunctionalInterface
+public interface CouchbaseEnvironmentBuilderCustomizer {
+
+	/**
+	 * Customize the {@link DefaultCouchbaseEnvironment.Builder}.
+	 * @param builder the builder to customize
+	 */
+	void customize(DefaultCouchbaseEnvironment.Builder builder);
+
+}
@@ -1,52 +0,0 @@
-/*
- * Copyright 2012-2019 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.data.couchbase;
-
-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseConfiguration;
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-
-/**
- * Adapt the core Couchbase configuration to an expected {@link CouchbaseConfigurer} if
- * necessary.
- *
- * @author Stephane Nicoll
- */
-@Configuration(proxyBeanMethods = false)
-@ConditionalOnClass(CouchbaseConfigurer.class)
-@ConditionalOnBean(CouchbaseConfiguration.class)
-class CouchbaseConfigurerAdapterConfiguration {
-
-	private final CouchbaseConfiguration configuration;
-
-	CouchbaseConfigurerAdapterConfiguration(CouchbaseConfiguration configuration) {
-		this.configuration = configuration;
-	}
-
-	@Bean
-	@ConditionalOnMissingBean
-	CouchbaseConfigurer springBootCouchbaseConfigurer() throws Exception {
-		return new SpringBootCouchbaseConfigurer(this.configuration.couchbaseEnvironment(),
-				this.configuration.couchbaseCluster(), this.configuration.couchbaseClusterInfo(),
-				this.configuration.couchbaseClient());
-	}
-
-}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -44,7 +44,7 @@
 @ConditionalOnClass({ Bucket.class, CouchbaseRepository.class })
 @AutoConfigureAfter({ CouchbaseAutoConfiguration.class, ValidationAutoConfiguration.class })
 @EnableConfigurationProperties(CouchbaseDataProperties.class)
-@Import({ CouchbaseConfigurerAdapterConfiguration.class, SpringBootCouchbaseDataConfiguration.class })
+@Import(CouchbaseDataConfiguration.class)
 public class CouchbaseDataAutoConfiguration {
 
 	@Configuration(proxyBeanMethods = false)
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2012-2020 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.data.couchbase;
+
+import java.util.Collections;
+
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.cluster.ClusterInfo;
+
+import org.springframework.beans.BeanUtils;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;
+import org.springframework.boot.autoconfigure.domain.EntityScanner;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.data.annotation.Persistent;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions;
+import org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;
+import org.springframework.data.couchbase.core.convert.translation.JacksonTranslationService;
+import org.springframework.data.couchbase.core.convert.translation.TranslationService;
+import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
+import org.springframework.data.couchbase.core.mapping.Document;
+import org.springframework.data.couchbase.repository.config.RepositoryOperationsMapping;
+import org.springframework.data.couchbase.repository.support.IndexManager;
+import org.springframework.data.mapping.model.FieldNamingStrategy;
+
+/**
+ * Configuration for Spring Data's couchbase support.
+ *
+ * @author Stephane Nicoll
+ */
+@Configuration(proxyBeanMethods = false)
+class CouchbaseDataConfiguration {
+
+	@Bean(name = BeanNames.COUCHBASE_MAPPING_CONVERTER)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_MAPPING_CONVERTER)
+	MappingCouchbaseConverter couchbaseMappingConverter(CouchbaseDataProperties properties,
+			CouchbaseMappingContext couchbaseMappingContext, CouchbaseCustomConversions couchbaseCustomConversions) {
+		MappingCouchbaseConverter converter = new MappingCouchbaseConverter(couchbaseMappingContext,
+				properties.getTypeKey());
+		converter.setCustomConversions(couchbaseCustomConversions);
+		return converter;
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_TRANSLATION_SERVICE)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_TRANSLATION_SERVICE)
+	TranslationService couchbaseTranslationService() {
+		return new JacksonTranslationService();
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_MAPPING_CONTEXT)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_MAPPING_CONTEXT)
+	CouchbaseMappingContext couchbaseMappingContext(CouchbaseDataProperties properties,
+			ApplicationContext applicationContext, CouchbaseCustomConversions couchbaseCustomConversions)
+			throws Exception {
+		CouchbaseMappingContext mappingContext = new CouchbaseMappingContext();
+		mappingContext
+				.setInitialEntitySet(new EntityScanner(applicationContext).scan(Document.class, Persistent.class));
+		mappingContext.setSimpleTypeHolder(couchbaseCustomConversions.getSimpleTypeHolder());
+		Class<?> fieldNamingStrategy = properties.getFieldNamingStrategy();
+		if (fieldNamingStrategy != null) {
+			mappingContext
+					.setFieldNamingStrategy((FieldNamingStrategy) BeanUtils.instantiateClass(fieldNamingStrategy));
+		}
+		return mappingContext;
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
+	CouchbaseCustomConversions couchbaseCustomConversions() {
+		return new CouchbaseCustomConversions(Collections.emptyList());
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_INDEX_MANAGER)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_INDEX_MANAGER)
+	IndexManager indexManager(CouchbaseDataProperties properties) {
+		if (properties.isAutoIndex()) {
+			return new IndexManager(true, true, true);
+		}
+		return new IndexManager(false, false, false);
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_TEMPLATE)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_TEMPLATE)
+	@ConditionalOnBean({ ClusterInfo.class, Bucket.class })
+	CouchbaseTemplate couchbaseTemplate(CouchbaseDataProperties properties, ClusterInfo clusterInfo, Bucket bucket,
+			MappingCouchbaseConverter mappingCouchbaseConverter, TranslationService translationService) {
+		CouchbaseTemplate template = new CouchbaseTemplate(clusterInfo, bucket, mappingCouchbaseConverter,
+				translationService);
+		template.setDefaultConsistency(properties.getConsistency());
+		return template;
+	}
+
+	@Bean(name = BeanNames.COUCHBASE_OPERATIONS_MAPPING)
+	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_OPERATIONS_MAPPING)
+	@ConditionalOnSingleCandidate(CouchbaseTemplate.class)
+	RepositoryOperationsMapping repositoryOperationsMapping(CouchbaseTemplate couchbaseTemplate) {
+		return new RepositoryOperationsMapping(couchbaseTemplate);
+	}
+
+}
@@ -39,6 +39,11 @@ public class CouchbaseDataProperties {
 	 */
 	private Consistency consistency = Consistency.READ_YOUR_OWN_WRITES;
 
+	/**
+	 * Fully qualified name of the FieldNamingStrategy to use.
+	 */
+	private Class<?> fieldNamingStrategy;
+
 	/**
 	 * Name of the field that stores the type information for complex types when using
 	 * ""MappingCouchbaseConverter"".
@@ -61,6 +66,14 @@ public void setConsistency(Consistency consistency) {
 		this.consistency = consistency;
 	}
 
+	public Class<?> getFieldNamingStrategy() {
+		return this.fieldNamingStrategy;
+	}
+
+	public void setFieldNamingStrategy(Class<?> fieldNamingStrategy) {
+		this.fieldNamingStrategy = fieldNamingStrategy;
+	}
+
 	public String getTypeKey() {
 		return this.typeKey;
 	}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -36,7 +36,7 @@
 @Configuration(proxyBeanMethods = false)
 @ConditionalOnClass({ Bucket.class, ReactiveCouchbaseRepository.class, Flux.class })
 @AutoConfigureAfter(CouchbaseDataAutoConfiguration.class)
-@Import(SpringBootCouchbaseReactiveDataConfiguration.class)
+@Import(CouchbaseReactiveDataConfiguration.class)
 public class CouchbaseReactiveDataAutoConfiguration {
 
 }
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2012-2020 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.autoconfigure.data.couchbase;
+
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.cluster.ClusterInfo;
+
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.RxJavaCouchbaseTemplate;
+import org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;
+import org.springframework.data.couchbase.core.convert.translation.TranslationService;
+import org.springframework.data.couchbase.repository.config.ReactiveRepositoryOperationsMapping;
+
+/**
+ * Configuration for Spring Data's couchbase reactive support.
+ *
+ * @author Stephane Nicoll
+ */
+@Configuration(proxyBeanMethods = false)
+class CouchbaseReactiveDataConfiguration {
+
+	@Bean(name = BeanNames.RXJAVA1_COUCHBASE_TEMPLATE)
+	@ConditionalOnMissingBean(name = BeanNames.RXJAVA1_COUCHBASE_TEMPLATE)
+	@ConditionalOnBean({ ClusterInfo.class, Bucket.class })
+	RxJavaCouchbaseTemplate reactiveCouchbaseTemplate(CouchbaseDataProperties properties, ClusterInfo clusterInfo,
+			Bucket bucket, MappingCouchbaseConverter mappingCouchbaseConverter, TranslationService translationService) {
+		RxJavaCouchbaseTemplate template = new RxJavaCouchbaseTemplate(clusterInfo, bucket, mappingCouchbaseConverter,
+				translationService);
+		template.setDefaultConsistency(properties.getConsistency());
+		return template;
+	}
+
+	@Bean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
+	@ConditionalOnMissingBean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
+	@ConditionalOnSingleCandidate(RxJavaCouchbaseTemplate.class)
+	ReactiveRepositoryOperationsMapping reactiveRepositoryOperationsMapping(
+			RxJavaCouchbaseTemplate reactiveCouchbaseTemplate) {
+		return new ReactiveRepositoryOperationsMapping(reactiveCouchbaseTemplate);
+	}
+
+}
@@ -1,70 +0,0 @@
-/*
- * Copyright 2012-2019 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.data.couchbase;
-
-import com.couchbase.client.java.Bucket;
-import com.couchbase.client.java.Cluster;
-import com.couchbase.client.java.cluster.ClusterInfo;
-import com.couchbase.client.java.env.CouchbaseEnvironment;
-
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-
-/**
- * A simple {@link CouchbaseConfigurer} implementation.
- *
- * @author Stephane Nicoll
- * @since 1.4.0
- */
-public class SpringBootCouchbaseConfigurer implements CouchbaseConfigurer {
-
-	private final CouchbaseEnvironment env;
-
-	private final Cluster cluster;
-
-	private final ClusterInfo clusterInfo;
-
-	private final Bucket bucket;
-
-	public SpringBootCouchbaseConfigurer(CouchbaseEnvironment env, Cluster cluster, ClusterInfo clusterInfo,
-			Bucket bucket) {
-		this.env = env;
-		this.cluster = cluster;
-		this.clusterInfo = clusterInfo;
-		this.bucket = bucket;
-	}
-
-	@Override
-	public CouchbaseEnvironment couchbaseEnvironment() throws Exception {
-		return this.env;
-	}
-
-	@Override
-	public Cluster couchbaseCluster() throws Exception {
-		return this.cluster;
-	}
-
-	@Override
-	public ClusterInfo couchbaseClusterInfo() throws Exception {
-		return this.clusterInfo;
-	}
-
-	@Override
-	public Bucket couchbaseClient() throws Exception {
-		return this.bucket;
-	}
-
-}
@@ -1,105 +0,0 @@
-/*
- * Copyright 2012-2020 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.data.couchbase;
-
-import java.util.Set;
-
-import org.springframework.beans.factory.ObjectProvider;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.boot.autoconfigure.domain.EntityScanner;
-import org.springframework.context.ApplicationContext;
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.data.annotation.Persistent;
-import org.springframework.data.convert.CustomConversions;
-import org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration;
-import org.springframework.data.couchbase.config.BeanNames;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-import org.springframework.data.couchbase.core.CouchbaseTemplate;
-import org.springframework.data.couchbase.core.mapping.Document;
-import org.springframework.data.couchbase.core.query.Consistency;
-import org.springframework.data.couchbase.repository.support.IndexManager;
-
-/**
- * Configure Spring Data's couchbase support.
- *
- * @author Stephane Nicoll
- */
-@Configuration
-@ConditionalOnMissingBean(AbstractCouchbaseDataConfiguration.class)
-@ConditionalOnBean(CouchbaseConfigurer.class)
-class SpringBootCouchbaseDataConfiguration extends AbstractCouchbaseDataConfiguration {
-
-	private final ApplicationContext applicationContext;
-
-	private final CouchbaseDataProperties properties;
-
-	private final CouchbaseConfigurer couchbaseConfigurer;
-
-	SpringBootCouchbaseDataConfiguration(ApplicationContext applicationContext, CouchbaseDataProperties properties,
-			ObjectProvider<CouchbaseConfigurer> couchbaseConfigurer) {
-		this.applicationContext = applicationContext;
-		this.properties = properties;
-		this.couchbaseConfigurer = couchbaseConfigurer.getIfAvailable();
-	}
-
-	@Override
-	protected CouchbaseConfigurer couchbaseConfigurer() {
-		return this.couchbaseConfigurer;
-	}
-
-	@Override
-	protected Consistency getDefaultConsistency() {
-		return this.properties.getConsistency();
-	}
-
-	@Override
-	protected Set<Class<?>> getInitialEntitySet() throws ClassNotFoundException {
-		return new EntityScanner(this.applicationContext).scan(Document.class, Persistent.class);
-	}
-
-	@Override
-	public String typeKey() {
-		return this.properties.getTypeKey();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_TEMPLATE)
-	@Bean(name = BeanNames.COUCHBASE_TEMPLATE)
-	public CouchbaseTemplate couchbaseTemplate() throws Exception {
-		return super.couchbaseTemplate();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
-	@Bean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
-	public CustomConversions customConversions() {
-		return super.customConversions();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_INDEX_MANAGER)
-	@Bean(name = BeanNames.COUCHBASE_INDEX_MANAGER)
-	public IndexManager indexManager() {
-		if (this.properties.isAutoIndex()) {
-			return new IndexManager(true, true, true);
-		}
-		return new IndexManager(false, false, false);
-	}
-
-}
@@ -1,75 +0,0 @@
-/*
- * Copyright 2012-2019 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.boot.autoconfigure.data.couchbase;
-
-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.data.couchbase.config.AbstractReactiveCouchbaseDataConfiguration;
-import org.springframework.data.couchbase.config.BeanNames;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-import org.springframework.data.couchbase.core.RxJavaCouchbaseTemplate;
-import org.springframework.data.couchbase.core.query.Consistency;
-import org.springframework.data.couchbase.repository.config.ReactiveRepositoryOperationsMapping;
-
-/**
- * Configure Spring Data's reactive couchbase support.
- *
- * @author Alex Derkach
- */
-@Configuration
-@ConditionalOnMissingBean(AbstractReactiveCouchbaseDataConfiguration.class)
-@ConditionalOnBean(CouchbaseConfigurer.class)
-class SpringBootCouchbaseReactiveDataConfiguration extends AbstractReactiveCouchbaseDataConfiguration {
-
-	private final CouchbaseDataProperties properties;
-
-	private final CouchbaseConfigurer couchbaseConfigurer;
-
-	SpringBootCouchbaseReactiveDataConfiguration(CouchbaseDataProperties properties,
-			CouchbaseConfigurer couchbaseConfigurer) {
-		this.properties = properties;
-		this.couchbaseConfigurer = couchbaseConfigurer;
-	}
-
-	@Override
-	protected CouchbaseConfigurer couchbaseConfigurer() {
-		return this.couchbaseConfigurer;
-	}
-
-	@Override
-	protected Consistency getDefaultConsistency() {
-		return this.properties.getConsistency();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.RXJAVA1_COUCHBASE_TEMPLATE)
-	@Bean(name = BeanNames.RXJAVA1_COUCHBASE_TEMPLATE)
-	public RxJavaCouchbaseTemplate reactiveCouchbaseTemplate() throws Exception {
-		return super.reactiveCouchbaseTemplate();
-	}
-
-	@Override
-	@ConditionalOnMissingBean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
-	@Bean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
-	public ReactiveRepositoryOperationsMapping reactiveRepositoryOperationsMapping(
-			RxJavaCouchbaseTemplate reactiveCouchbaseTemplate) throws Exception {
-		return super.reactiveRepositoryOperationsMapping(reactiveCouchbaseTemplate);
-	}
-
-}
@@ -22,24 +22,21 @@
 
 import com.couchbase.client.java.Bucket;
 import com.couchbase.client.java.Cluster;
-import com.couchbase.client.java.CouchbaseBucket;
 import com.couchbase.client.java.bucket.BucketType;
 import com.couchbase.client.java.cluster.BucketSettings;
 import com.couchbase.client.java.cluster.ClusterInfo;
 import com.couchbase.client.java.cluster.DefaultBucketSettings;
 import com.couchbase.client.java.cluster.UserRole;
 import com.couchbase.client.java.cluster.UserSettings;
 import com.couchbase.client.java.env.CouchbaseEnvironment;
-import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.testcontainers.couchbase.CouchbaseContainer;
 import org.testcontainers.junit.jupiter.Container;
 import org.testcontainers.junit.jupiter.Testcontainers;
 
-import org.springframework.boot.test.util.TestPropertyValues;
-import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.boot.autoconfigure.AutoConfigurations;
+import org.springframework.boot.test.context.runner.ApplicationContextRunner;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -59,7 +56,12 @@ class CouchbaseAutoConfigurationIntegrationTests {
 	static final CouchbaseContainer couchbase = new CouchbaseContainer().withClusterAdmin(""spring"", ""password"")
 			.withStartupAttempts(5).withStartupTimeout(Duration.ofMinutes(10));
 
-	private AnnotationConfigApplicationContext context;
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
+			.withConfiguration(AutoConfigurations.of(CouchbaseAutoConfiguration.class))
+			.withPropertyValues(""spring.couchbase.bootstrap-hosts=localhost"",
+					""spring.couchbase.env.bootstrap.http-direct-port:"" + couchbase.getMappedPort(8091),
+					""spring.couchbase.username:spring"", ""spring.couchbase.password:password"",
+					""spring.couchbase.bucket.name:default"");
 
 	@BeforeAll
 	static void createBucket() {
@@ -70,40 +72,10 @@ static void createBucket() {
 				UserSettings.build().password(bucketSettings.password()).roles(userSettings), true);
 	}
 
-	@BeforeEach
-	void setUp() {
-		this.context = new AnnotationConfigApplicationContext();
-		this.context.register(CouchbaseAutoConfiguration.class);
-		TestPropertyValues.of(""spring.couchbase.bootstrap-hosts=localhost"",
-				""spring.couchbase.env.bootstrap.http-direct-port:"" + couchbase.getMappedPort(8091),
-				""spring.couchbase.username:spring"", ""spring.couchbase.password:password"",
-				""spring.couchbase.bucket.name:default"").applyTo(this.context.getEnvironment());
-	}
-
-	@AfterEach
-	void close() {
-		if (this.context != null) {
-			this.context.close();
-		}
-	}
-
 	@Test
 	void defaultConfiguration() {
-		this.context.refresh();
-		assertThat(this.context.getBeansOfType(Cluster.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(ClusterInfo.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(CouchbaseEnvironment.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(Bucket.class)).hasSize(1);
-	}
-
-	@Test
-	void customConfiguration() {
-		this.context.register(CustomConfiguration.class);
-		this.context.refresh();
-		assertThat(this.context.getBeansOfType(Cluster.class)).hasSize(2);
-		assertThat(this.context.getBeansOfType(ClusterInfo.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(CouchbaseEnvironment.class)).hasSize(1);
-		assertThat(this.context.getBeansOfType(Bucket.class)).hasSize(2);
+		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(CouchbaseEnvironment.class)
+				.hasSingleBean(Cluster.class).hasSingleBean(ClusterInfo.class).hasSingleBean(Bucket.class));
 	}
 
 	@Configuration(proxyBeanMethods = false)
@@ -116,7 +88,7 @@ Cluster myCustomCouchbaseCluster() {
 
 		@Bean
 		Bucket myCustomCouchbaseClient() {
-			return mock(CouchbaseBucket.class);
+			return mock(Bucket.class);
 		}
 
 	}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -18,22 +18,17 @@
 
 import java.util.function.Consumer;
 
-import com.couchbase.client.java.Bucket;
 import com.couchbase.client.java.Cluster;
-import com.couchbase.client.java.CouchbaseBucket;
-import com.couchbase.client.java.cluster.ClusterInfo;
 import com.couchbase.client.java.env.CouchbaseEnvironment;
 import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;
 import org.junit.jupiter.api.Test;
 
 import org.springframework.boot.autoconfigure.AutoConfigurations;
-import org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration;
-import org.springframework.boot.test.context.assertj.AssertableApplicationContext;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
 
 /**
  * Tests for {@link CouchbaseAutoConfiguration}.
@@ -43,38 +38,25 @@
  */
 class CouchbaseAutoConfigurationTests {
 
-	private ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
-			AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class, CouchbaseAutoConfiguration.class));
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
+			.withConfiguration(AutoConfigurations.of(CouchbaseAutoConfiguration.class));
 
 	@Test
 	void bootstrapHostsIsRequired() {
-		this.contextRunner.run(this::assertNoCouchbaseBeans);
+		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(CouchbaseEnvironment.class)
+				.doesNotHaveBean(Cluster.class));
 	}
 
 	@Test
-	void bootstrapHostsNotRequiredIfCouchbaseConfigurerIsSet() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class).run((context) -> {
-			assertThat(context).hasSingleBean(CouchbaseTestConfigurer.class);
-			// No beans are going to be created
-			assertNoCouchbaseBeans(context);
-		});
-	}
-
-	@Test
-	void bootstrapHostsIgnoredIfCouchbaseConfigurerIsSet() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
-				.withPropertyValues(""spring.couchbase.bootstrapHosts=localhost"").run((context) -> {
-					assertThat(context).hasSingleBean(CouchbaseTestConfigurer.class);
-					assertNoCouchbaseBeans(context);
+	void bootstrapHostsCreateEnvironmentAndCluster() {
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
+				.withPropertyValues(""spring.couchbase.bootstrap-hosts=localhost"").run((context) -> {
+					assertThat(context).hasSingleBean(CouchbaseEnvironment.class).hasSingleBean(Cluster.class);
+					assertThat(context.getBean(Cluster.class))
+							.isSameAs(context.getBean(CouchbaseTestConfiguration.class).couchbaseCluster());
 				});
 	}
 
-	private void assertNoCouchbaseBeans(AssertableApplicationContext context) {
-		// No beans are going to be created
-		assertThat(context).doesNotHaveBean(CouchbaseEnvironment.class).doesNotHaveBean(ClusterInfo.class)
-				.doesNotHaveBean(Cluster.class).doesNotHaveBean(Bucket.class);
-	}
-
 	@Test
 	void customizeEnvEndpoints() {
 		testCouchbaseEnv((env) -> {
@@ -147,53 +129,32 @@ void disableSslEvenWithKeyStore() {
 	}
 
 	private void testCouchbaseEnv(Consumer<DefaultCouchbaseEnvironment> environmentConsumer, String... environment) {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class).withPropertyValues(environment)
-				.run((context) -> {
-					CouchbaseProperties properties = context.getBean(CouchbaseProperties.class);
-					DefaultCouchbaseEnvironment env = new CouchbaseConfiguration(properties)
-							.initializeEnvironmentBuilder(properties).build();
-					environmentConsumer.accept(env);
-				});
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
+				.withPropertyValues(""spring.couchbase.bootstrap-hosts=localhost"").withPropertyValues(environment)
+				.run((context) -> environmentConsumer.accept(context.getBean(DefaultCouchbaseEnvironment.class)));
 	}
 
 	@Test
 	void customizeEnvWithCustomCouchbaseConfiguration() {
-		this.contextRunner.withUserConfiguration(CustomCouchbaseConfiguration.class)
+		this.contextRunner
+				.withUserConfiguration(CouchbaseTestConfiguration.class,
+						CouchbaseEnvironmentCustomizerConfiguration.class)
 				.withPropertyValues(""spring.couchbase.bootstrap-hosts=localhost"",
 						""spring.couchbase.env.timeouts.connect=100"")
 				.run((context) -> {
-					assertThat(context).hasSingleBean(CouchbaseConfiguration.class);
+					assertThat(context).hasSingleBean(DefaultCouchbaseEnvironment.class);
 					DefaultCouchbaseEnvironment env = context.getBean(DefaultCouchbaseEnvironment.class);
 					assertThat(env.socketConnectTimeout()).isEqualTo(5000);
 					assertThat(env.connectTimeout()).isEqualTo(2000);
 				});
 	}
 
-	@Configuration
-	static class CustomCouchbaseConfiguration extends CouchbaseConfiguration {
-
-		CustomCouchbaseConfiguration(CouchbaseProperties properties) {
-			super(properties);
-		}
-
-		@Override
-		protected DefaultCouchbaseEnvironment.Builder initializeEnvironmentBuilder(CouchbaseProperties properties) {
-			return super.initializeEnvironmentBuilder(properties).socketConnectTimeout(5000).connectTimeout(2000);
-		}
-
-		@Override
-		public Cluster couchbaseCluster() {
-			return mock(Cluster.class);
-		}
-
-		@Override
-		public ClusterInfo couchbaseClusterInfo() {
-			return mock(ClusterInfo.class);
-		}
+	@Configuration(proxyBeanMethods = false)
+	static class CouchbaseEnvironmentCustomizerConfiguration {
 
-		@Override
-		public Bucket couchbaseClient() {
-			return mock(CouchbaseBucket.class);
+		@Bean
+		CouchbaseEnvironmentBuilderCustomizer couchbaseEnvironmentBuilderCustomizer() {
+			return (builder) -> builder.socketConnectTimeout(5000).connectTimeout(2000);
 		}
 
 	}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors.
+ * Copyright 2012-2020 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -20,37 +20,33 @@
 import com.couchbase.client.java.Cluster;
 import com.couchbase.client.java.CouchbaseBucket;
 import com.couchbase.client.java.cluster.ClusterInfo;
-import com.couchbase.client.java.env.CouchbaseEnvironment;
 
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
-import org.springframework.stereotype.Component;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
 
 import static org.mockito.Mockito.mock;
 
 /**
- * Test configurer for couchbase that mocks access.
+ * Test configuration for couchbase that mocks access.
  *
  * @author Stephane Nicoll
  */
-@Component
-public class CouchbaseTestConfigurer implements CouchbaseConfigurer {
+@Configuration(proxyBeanMethods = false)
+public class CouchbaseTestConfiguration {
 
-	@Override
-	public CouchbaseEnvironment couchbaseEnvironment() throws Exception {
-		return mock(CouchbaseEnvironment.class);
-	}
+	private final Cluster cluster = mock(Cluster.class);
 
-	@Override
-	public Cluster couchbaseCluster() throws Exception {
-		return mock(Cluster.class);
+	@Bean
+	public Cluster couchbaseCluster() {
+		return this.cluster;
 	}
 
-	@Override
+	@Bean
 	public ClusterInfo couchbaseClusterInfo() {
 		return mock(ClusterInfo.class);
 	}
 
-	@Override
+	@Bean
 	public Bucket couchbaseClient() {
 		return mock(CouchbaseBucket.class);
 	}
@@ -24,7 +24,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.couchbase.city.City;
 import org.springframework.boot.autoconfigure.domain.EntityScan;
 import org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration;
@@ -33,12 +33,11 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Import;
 import org.springframework.core.convert.converter.Converter;
-import org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration;
 import org.springframework.data.couchbase.config.BeanNames;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
 import org.springframework.data.couchbase.core.CouchbaseTemplate;
 import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions;
 import org.springframework.data.couchbase.core.convert.DefaultCouchbaseTypeMapper;
+import org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;
 import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
 import org.springframework.data.couchbase.core.mapping.event.ValidatingCouchbaseEventListener;
 import org.springframework.data.couchbase.core.query.Consistency;
@@ -60,26 +59,17 @@ class CouchbaseDataAutoConfigurationTests {
 
 	@Test
 	void disabledIfCouchbaseIsNotConfigured() {
-		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(IndexManager.class));
-	}
-
-	@Test
-	void customConfiguration() {
-		this.contextRunner.withUserConfiguration(CustomCouchbaseConfiguration.class).run((context) -> {
-			CouchbaseTemplate couchbaseTemplate = context.getBean(CouchbaseTemplate.class);
-			assertThat(couchbaseTemplate.getDefaultConsistency()).isEqualTo(Consistency.STRONGLY_CONSISTENT);
-		});
+		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(CouchbaseTemplate.class));
 	}
 
 	@Test
 	void validatorIsPresent() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
-				.run((context) -> assertThat(context).hasSingleBean(ValidatingCouchbaseEventListener.class));
+		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ValidatingCouchbaseEventListener.class));
 	}
 
 	@Test
 	void autoIndexIsDisabledByDefault() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class).run((context) -> {
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class).run((context) -> {
 			IndexManager indexManager = context.getBean(IndexManager.class);
 			assertThat(indexManager.isIgnoreViews()).isTrue();
 			assertThat(indexManager.isIgnoreN1qlPrimary()).isTrue();
@@ -89,7 +79,7 @@ void autoIndexIsDisabledByDefault() {
 
 	@Test
 	void enableAutoIndex() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
 				.withPropertyValues(""spring.data.couchbase.auto-index=true"").run((context) -> {
 					IndexManager indexManager = context.getBean(IndexManager.class);
 					assertThat(indexManager.isIgnoreViews()).isFalse();
@@ -100,11 +90,10 @@ void enableAutoIndex() {
 
 	@Test
 	void changeConsistency() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
 				.withPropertyValues(""spring.data.couchbase.consistency=eventually-consistent"").run((context) -> {
-					SpringBootCouchbaseDataConfiguration configuration = context
-							.getBean(SpringBootCouchbaseDataConfiguration.class);
-					assertThat(configuration.getDefaultConsistency()).isEqualTo(Consistency.EVENTUALLY_CONSISTENT);
+					CouchbaseTemplate couchbaseTemplate = context.getBean(CouchbaseTemplate.class);
+					assertThat(couchbaseTemplate.getDefaultConsistency()).isEqualTo(Consistency.EVENTUALLY_CONSISTENT);
 				});
 	}
 
@@ -121,16 +110,16 @@ void entityScanShouldSetInitialEntitySet() {
 
 	@Test
 	void typeKeyDefault() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
-				.run((context) -> assertThat(context.getBean(AbstractCouchbaseDataConfiguration.class).typeKey())
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
+				.run((context) -> assertThat(context.getBean(MappingCouchbaseConverter.class).getTypeKey())
 						.isEqualTo(DefaultCouchbaseTypeMapper.DEFAULT_TYPE_KEY));
 	}
 
 	@Test
 	void typeKeyCanBeCustomized() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
 				.withPropertyValues(""spring.data.couchbase.type-key=_custom"")
-				.run((context) -> assertThat(context.getBean(AbstractCouchbaseDataConfiguration.class).typeKey())
+				.run((context) -> assertThat(context.getBean(MappingCouchbaseConverter.class).getTypeKey())
 						.isEqualTo(""_custom""));
 	}
 
@@ -144,23 +133,8 @@ void customConversions() {
 		});
 	}
 
-	@Configuration
-	static class CustomCouchbaseConfiguration extends AbstractCouchbaseDataConfiguration {
-
-		@Override
-		protected CouchbaseConfigurer couchbaseConfigurer() {
-			return new CouchbaseTestConfigurer();
-		}
-
-		@Override
-		protected Consistency getDefaultConsistency() {
-			return Consistency.STRONGLY_CONSISTENT;
-		}
-
-	}
-
 	@Configuration(proxyBeanMethods = false)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class CustomConversionsConfig {
 
 		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
@@ -172,7 +146,7 @@ CouchbaseCustomConversions myCustomConversions() {
 
 	@Configuration(proxyBeanMethods = false)
 	@EntityScan(""org.springframework.boot.autoconfigure.data.couchbase.city"")
-	@Import(CustomCouchbaseConfiguration.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class EntityScanConfig {
 
 	}
@@ -23,7 +23,7 @@
 
 import org.springframework.boot.autoconfigure.TestAutoConfigurationPackage;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.couchbase.city.CityRepository;
 import org.springframework.boot.autoconfigure.data.couchbase.city.ReactiveCityRepository;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;
@@ -62,7 +62,7 @@ static class ImperativeAndReactiveConfiguration {
 	}
 
 	@Configuration(proxyBeanMethods = false)
-	@Import({ CouchbaseTestConfigurer.class, Registrar.class })
+	@Import({ CouchbaseTestConfiguration.class, Registrar.class })
 	static class BaseConfiguration {
 
 	}
@@ -24,7 +24,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.couchbase.city.City;
 import org.springframework.boot.autoconfigure.domain.EntityScan;
 import org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration;
@@ -33,15 +33,11 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Import;
 import org.springframework.core.convert.converter.Converter;
-import org.springframework.data.couchbase.config.AbstractReactiveCouchbaseDataConfiguration;
 import org.springframework.data.couchbase.config.BeanNames;
-import org.springframework.data.couchbase.config.CouchbaseConfigurer;
 import org.springframework.data.couchbase.core.RxJavaCouchbaseTemplate;
 import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions;
 import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
 import org.springframework.data.couchbase.core.mapping.event.ValidatingCouchbaseEventListener;
-import org.springframework.data.couchbase.core.query.Consistency;
-import org.springframework.data.couchbase.repository.support.IndexManager;
 import org.springframework.test.util.ReflectionTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -60,20 +56,12 @@ class CouchbaseReactiveDataAutoConfigurationTests {
 
 	@Test
 	void disabledIfCouchbaseIsNotConfigured() {
-		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(IndexManager.class));
-	}
-
-	@Test
-	void customConfiguration() {
-		this.contextRunner.withUserConfiguration(CustomCouchbaseConfiguration.class).run((context) -> {
-			RxJavaCouchbaseTemplate rxJavaCouchbaseTemplate = context.getBean(RxJavaCouchbaseTemplate.class);
-			assertThat(rxJavaCouchbaseTemplate.getDefaultConsistency()).isEqualTo(Consistency.STRONGLY_CONSISTENT);
-		});
+		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(RxJavaCouchbaseTemplate.class));
 	}
 
 	@Test
 	void validatorIsPresent() {
-		this.contextRunner.withUserConfiguration(CouchbaseTestConfigurer.class)
+		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
 				.run((context) -> assertThat(context).hasSingleBean(ValidatingCouchbaseEventListener.class));
 	}
 
@@ -98,23 +86,8 @@ void customConversions() {
 		});
 	}
 
-	@Configuration
-	static class CustomCouchbaseConfiguration extends AbstractReactiveCouchbaseDataConfiguration {
-
-		@Override
-		protected CouchbaseConfigurer couchbaseConfigurer() {
-			return new CouchbaseTestConfigurer();
-		}
-
-		@Override
-		protected Consistency getDefaultConsistency() {
-			return Consistency.STRONGLY_CONSISTENT;
-		}
-
-	}
-
 	@Configuration(proxyBeanMethods = false)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class CustomConversionsConfig {
 
 		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
@@ -126,7 +99,7 @@ CouchbaseCustomConversions myCustomConversions() {
 
 	@Configuration(proxyBeanMethods = false)
 	@EntityScan(""org.springframework.boot.autoconfigure.data.couchbase.city"")
-	@Import(CustomCouchbaseConfiguration.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class EntityScanConfig {
 
 	}
@@ -21,7 +21,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.autoconfigure.TestAutoConfigurationPackage;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.alt.couchbase.CityCouchbaseRepository;
 import org.springframework.boot.autoconfigure.data.alt.couchbase.ReactiveCityCouchbaseRepository;
 import org.springframework.boot.autoconfigure.data.couchbase.city.City;
@@ -86,22 +86,22 @@ void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(City.class)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class DefaultConfiguration {
 
 	}
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(EmptyDataPackage.class)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class NoRepositoryConfiguration {
 
 	}
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(CouchbaseReactiveRepositoriesAutoConfigurationTests.class)
 	@EnableCouchbaseRepositories(basePackageClasses = CityCouchbaseRepository.class)
-	@Import(CouchbaseDataAutoConfigurationTests.CustomCouchbaseConfiguration.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class CustomizedConfiguration {
 
 	}
@@ -21,7 +21,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.autoconfigure.TestAutoConfigurationPackage;
 import org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration;
-import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfigurer;
+import org.springframework.boot.autoconfigure.couchbase.CouchbaseTestConfiguration;
 import org.springframework.boot.autoconfigure.data.couchbase.city.City;
 import org.springframework.boot.autoconfigure.data.couchbase.city.CityRepository;
 import org.springframework.boot.autoconfigure.data.empty.EmptyDataPackage;
@@ -82,14 +82,14 @@ static class CouchbaseNotAvailableConfiguration {
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(City.class)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class DefaultConfiguration {
 
 	}
 
 	@Configuration(proxyBeanMethods = false)
 	@TestAutoConfigurationPackage(EmptyDataPackage.class)
-	@Import(CouchbaseTestConfigurer.class)
+	@Import(CouchbaseTestConfiguration.class)
 	static class NoRepositoryConfiguration {
 
 	}
@@ -4485,7 +4485,6 @@ Generally, you provide the bootstrap hosts, bucket name, and password, as shown
 ----
 
 TIP: You need to provide _at least_ the bootstrap host(s), in which case the bucket name is `default` and the password is an empty String.
-Alternatively, you can define your own `org.springframework.data.couchbase.config.CouchbaseConfigurer` `@Bean` to take control over the whole configuration.
 
 It is also possible to customize some of the `CouchbaseEnvironment` settings.
 For instance, the following configuration changes the timeout to use to open a new `Bucket` and enables SSL support:
@@ -4497,7 +4496,8 @@ For instance, the following configuration changes the timeout to use to open a n
 	spring.couchbase.env.ssl.key-store-password=secret
 ----
 
-Check the `spring.couchbase.env.*` properties for more details.
+TIP: Check the `spring.couchbase.env.*` properties for more details.
+To take more control, one or more `CouchbaseEnvironmentBuilderCustomizer` beans can be used.
 
 
 
",True,"The commit message refers to the necessity of changes by mentioning that it configures Spring Data Couchbase explicitly rather than relying on the abstract configuration class. This has the advantage of simplifying the auto-configuration and let it us proxy-free configuration classes. This is done to address the issue of Spring Boot no longer using or interacting with CouchbaseConfigurer, which was used to teach Spring Boot which components to use. The message also mentions that the `CouchbaseConfiguration` class is no longer public and extending from it is no longer necessary, which is a change made to simplify the configuration.",,,,,True,"The commit message mentions that it configures Spring Data Couchbase explicitly rather than relying on the abstract configuration class. This indicates that the developer is making a conscious decision to customize the configuration to meet specific requirements, which is a clear expression of the necessity of changes.",True,The commit message explicitly mentions that it configures Spring Data Couchbase explicitly rather than relying on the abstract configuration class. This change is made to simplify the auto-configuration and let it use proxy-free configuration classes. This directly addresses the objective of the change by improving the configuration process.,,,True,"The commit message explains that the configuration is being explicitly set for Spring Data Couchbase, rather than relying on the abstract configuration class. This has the advantage of simplifying the auto-configuration and allowing for proxy-free configuration classes. Additionally, the message mentions that the `CouchbaseConfiguration` class is no longer public and extending from it is no longer necessary. Instead, a `CouchbaseEnvironmentBuilderCustomizer` bean can be registered to tune the auto-configured environment.",,,,
https://github.com/apache/dubbo/commit/09722e3a93ad4ba40edf38ebdbfd7afee4977ee6,Remove unnecessary dependencies ,https://api.github.com/repos/apache/dubbo/commits/09722e3a93ad4ba40edf38ebdbfd7afee4977ee6,"@@ -35,20 +35,6 @@ limitations under the License.
             <artifactId>dubbo-common</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
-        <dependency>
-            <groupId>org.mortbay.jetty</groupId>
-            <artifactId>jetty</artifactId>
-            <exclusions>
-                <exclusion>
-                    <groupId>org.mortbay.jetty</groupId>
-                    <artifactId>servlet-api</artifactId>
-                </exclusion>
-            </exclusions>
-        </dependency>
-        <dependency>
-            <groupId>javax.servlet</groupId>
-            <artifactId>javax.servlet-api</artifactId>
-        </dependency>
     </dependencies>
     <build>
         <plugins>
",False,"The commit message 'Remove unnecessary dependencies' does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states the action taken, without providing a reason or context for why these dependencies were removed.",True,"The commit message 'Remove unnecessary dependencies' clearly and concisely describes the changes made in the code diff. The diff shows that several dependencies have been removed, which is likely done to reduce the size of the project, improve build times, or address potential conflicts. This is a common practice in software development and does not require a detailed explanation in the commit message.",False,"The commit message 'Remove unnecessary dependencies' does not explicitly describe the necessity of changes. It only states the action taken, but it does not elaborate on the motivation or the problem that the changes are intended to solve. The code diff shows that certain dependencies have been removed, but the message does not provide any context or explanation for why these dependencies were no longer needed.",True,"The commit message 'Remove unnecessary dependencies' indicates that the developer has identified the need to streamline the project by eliminating dependencies that are no longer required. This could be due to changes in the project's requirements, the removal of unused features, or the deprecation of certain libraries. This suggests a need for software development to improve the project's efficiency and maintainability.",True,"The commit message 'Remove unnecessary dependencies' directly mentions the change that is being made to the code. In this case, the change is removing dependencies that are no longer needed, which can improve the performance and maintainability of the code.",True,"The commit message 'Remove unnecessary dependencies' accurately summarizes the changes in the diff. The diff shows the removal of several dependencies, including 'org.mortbay.jetty:jetty' and 'javax.servlet:javax.servlet-api', which are no longer needed in the project. The commit message clearly states the purpose of the change, which is to simplify the project's dependencies.",False,"The commit message 'Remove unnecessary dependencies' does not explicitly describe a technical principle underpinning the changes. It only states the reason for the changes, which is to simplify the project by removing dependencies that are no longer needed. However, it does not explain any underlying technical principle that guided the decision to remove these specific dependencies.",False,"The commit message 'Remove unnecessary dependencies' does not describe the code changes from a functional perspective. It only mentions the removal of dependencies, but it does not explain what these dependencies were used for or how their removal affects the functionality of the code.",False,"The commit message does not explicitly explain the reason for removing the dependencies. While it's clear from the diff that the dependencies are no longer needed, it's good practice to include an explanation in the commit message to help others understand the context and purpose of the change."
https://github.com/spring-projects/spring-boot/commit/12bfca56d617f935e0a53760bf18f300eba8a430,Remove unnecessary null check  <enter> See  <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/12bfca56d617f935e0a53760bf18f300eba8a430,"@@ -34,7 +34,6 @@
 import org.springframework.context.annotation.Conditional;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.core.env.Environment;
-import org.springframework.core.io.DefaultResourceLoader;
 import org.springframework.core.io.Resource;
 import org.springframework.core.io.ResourceLoader;
 import org.springframework.core.io.support.EncodedResource;
@@ -95,12 +94,9 @@ private Properties loadSource(Resource location, Charset encoding) throws IOExce
 
 	static class GitResourceAvailableCondition extends SpringBootCondition {
 
-		private final ResourceLoader defaultResourceLoader = new DefaultResourceLoader();
-
 		@Override
 		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
 			ResourceLoader loader = context.getResourceLoader();
-			loader = (loader != null) ? loader : this.defaultResourceLoader;
 			Environment environment = context.getEnvironment();
 			String location = environment.getProperty(""spring.info.git.location"");
 			if (location == null) {
",True,"The commit message 'Remove unnecessary null check' does reference an improvement in prior commits. The code diff shows that a null check for the ResourceLoader has been removed, which was previously initialized with a DefaultResourceLoader instance. This change simplifies the code and removes unnecessary lines, improving the readability and maintainability of the code.",True,"The commit message 'Remove unnecessary null check' clearly describes the change made in the code diff. The change is a refactoring that removes a null check that is no longer necessary because the ResourceLoader is guaranteed to be non-null by the context. This is a common sense change that improves the code without affecting its functionality, and it doesn't require a detailed explanation.",False,"The commit message does not explicitly describe the necessity of changes. It only mentions the removal of an unnecessary null check without elaborating on the error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message 'Remove unnecessary null check' does not explicitly describe the source of the requirements or the problem that necessitated the changes. However, the code diff indicates that a null check and an import statement for DefaultResourceLoader have been removed. This suggests that the change was made to simplify the code and potentially improve performance, which could be considered a maintenance issue related to outdated or unnecessary code.",True,"The commit message 'Remove unnecessary null check' directly mentions the change made to the code, which is the removal of an unnecessary null check. This change improves the code by simplifying it and potentially improving performance.",True,"The commit message 'Remove unnecessary null check' accurately summarizes the change made in the code diff. The diff shows that a line of code importing 'DefaultResourceLoader' has been removed, which is consistent with the message. Additionally, the message does not contrast the before and after, but it does point out the key component of the change, which is the removal of the unnecessary null check.",True,"The commit message 'Remove unnecessary null check' suggests that the change is based on the principle of simplifying the code and removing redundant checks. In this case, the removed null check for the ResourceLoader in the GitResourceAvailableCondition class is unnecessary because it's already been checked in the previous line. This change follows the principle of keeping the codebase clean and efficient, which is a common technical principle.",True,"The commit message 'Remove unnecessary null check' does express a summary of the changes made in the code diff. The code diff shows that a null check for a DefaultResourceLoader instance has been removed. This change does not introduce new behaviors, but rather simplifies the existing code by removing an unnecessary check. However, the message could be more descriptive by mentioning the removal of the null check for DefaultResourceLoader, which would make it clearer that the change is about code simplification and not about introducing new functionalities.",False,"The commit message does not explicitly explain the reason for the change. While the change is small and simple (removing an unnecessary null check and import), it could potentially impact the functionality of the application if the default resource loader is not properly handled. Therefore, a more detailed explanation of the change and its potential implications would be beneficial."
https://github.com/spring-projects/spring-boot/commit/036aace2cca7f33c0e96d3b222376b48947b735f,Add details in Jest ElasticSearch HealthIndicator  <enter> This commit polishes the previous one and aligns the Jest HealthIndicator with the changes made for the REST variant. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/036aace2cca7f33c0e96d3b222376b48947b735f,"@@ -16,14 +16,16 @@
 
 package org.springframework.boot.actuate.elasticsearch;
 
-import com.google.gson.JsonElement;
-import com.google.gson.JsonParser;
+import java.util.Map;
+
 import io.searchbox.client.JestClient;
 import io.searchbox.client.JestResult;
 
 import org.springframework.boot.actuate.health.AbstractHealthIndicator;
 import org.springframework.boot.actuate.health.Health;
 import org.springframework.boot.actuate.health.HealthIndicator;
+import org.springframework.boot.json.JsonParser;
+import org.springframework.boot.json.JsonParserFactory;
 
 /**
  * {@link HealthIndicator} for Elasticsearch using a {@link JestClient}.
@@ -37,7 +39,7 @@ public class ElasticsearchJestHealthIndicator extends AbstractHealthIndicator {
 
 	private final JestClient jestClient;
 
-	private final JsonParser jsonParser = new JsonParser();
+	private final JsonParser jsonParser = JsonParserFactory.getJsonParser();
 
 	public ElasticsearchJestHealthIndicator(JestClient jestClient) {
 		super(""Elasticsearch health check failed"");
@@ -50,17 +52,19 @@ protected void doHealthCheck(Health.Builder builder) throws Exception {
 				.execute(new io.searchbox.cluster.Health.Builder().build());
 		if (healthResult.getResponseCode() != 200 || !healthResult.isSucceeded()) {
 			builder.down();
+			builder.withDetail(""statusCode"", healthResult.getResponseCode());
 		}
 		else {
-			JsonElement root = this.jsonParser.parse(healthResult.getJsonString());
-			JsonElement status = root.getAsJsonObject().get(""status"");
-			if (status.getAsString()
-					.equals(io.searchbox.cluster.Health.Status.RED.getKey())) {
+			Map<String, Object> response = this.jsonParser
+					.parseMap(healthResult.getJsonString());
+			String status = (String) response.get(""status"");
+			if (status.equals(io.searchbox.cluster.Health.Status.RED.getKey())) {
 				builder.outOfService();
 			}
 			else {
 				builder.up();
 			}
+			builder.withDetails(response);
 		}
 	}
 
@@ -17,6 +17,7 @@
 package org.springframework.boot.actuate.elasticsearch;
 
 import java.io.IOException;
+import java.util.Map;
 
 import com.google.gson.Gson;
 import com.google.gson.JsonParser;
@@ -31,6 +32,7 @@
 import org.springframework.boot.actuate.health.Status;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.entry;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
@@ -56,6 +58,16 @@ public void elasticsearchIsUp() throws IOException {
 				.willReturn(createJestResult(200, true, ""green""));
 		Health health = this.healthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.UP);
+		assertHealthDetailsWithStatus(health.getDetails(), ""green"");
+	}
+
+	@Test
+	public void elasticsearchWithYellowStatusIsUp() throws IOException {
+		given(this.jestClient.execute(any(Action.class)))
+				.willReturn(createJestResult(200, true, ""yellow""));
+		Health health = this.healthIndicator.health();
+		assertThat(health.getStatus()).isEqualTo(Status.UP);
+		assertHealthDetailsWithStatus(health.getDetails(), ""yellow"");
 	}
 
 	@SuppressWarnings(""unchecked"")
@@ -83,6 +95,7 @@ public void elasticsearchIsDownByResponseCode() throws IOException {
 				.willReturn(createJestResult(500, false, """"));
 		Health health = this.healthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
+		assertThat(health.getDetails()).contains(entry(""statusCode"", 500));
 	}
 
 	@SuppressWarnings(""unchecked"")
@@ -92,6 +105,21 @@ public void elasticsearchIsOutOfServiceByStatus() throws IOException {
 				.willReturn(createJestResult(200, true, ""red""));
 		Health health = this.healthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
+		assertHealthDetailsWithStatus(health.getDetails(), ""red"");
+	}
+
+	private void assertHealthDetailsWithStatus(Map<String, Object> details,
+			String status) {
+		assertThat(details).contains(entry(""cluster_name"", ""elasticsearch""),
+				entry(""status"", status), entry(""timed_out"", false),
+				entry(""number_of_nodes"", 1), entry(""number_of_data_nodes"", 1),
+				entry(""active_primary_shards"", 0), entry(""active_shards"", 0),
+				entry(""relocating_shards"", 0), entry(""initializing_shards"", 0),
+				entry(""unassigned_shards"", 0), entry(""delayed_unassigned_shards"", 0),
+				entry(""number_of_pending_tasks"", 0),
+				entry(""number_of_in_flight_fetch"", 0),
+				entry(""task_max_waiting_in_queue_millis"", 0),
+				entry(""active_shards_percent_as_number"", 100.0));
 	}
 
 	private static JestResult createJestResult(int responseCode, boolean succeeded,
@@ -18,6 +18,7 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.util.Map;
 
 import org.apache.http.StatusLine;
 import org.apache.http.entity.BasicHttpEntity;
@@ -64,17 +65,7 @@ public void elasticsearchIsUp() throws IOException {
 
 		Health health = this.elasticsearchRestHealthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.UP);
-
-		assertThat(health.getDetails()).contains(entry(""cluster_name"", ""elasticsearch""),
-				entry(""status"", ""green""), entry(""timed_out"", false),
-				entry(""number_of_nodes"", 1), entry(""number_of_data_nodes"", 1),
-				entry(""active_primary_shards"", 0), entry(""active_shards"", 0),
-				entry(""relocating_shards"", 0), entry(""initializing_shards"", 0),
-				entry(""unassigned_shards"", 0), entry(""delayed_unassigned_shards"", 0),
-				entry(""number_of_pending_tasks"", 0),
-				entry(""number_of_in_flight_fetch"", 0),
-				entry(""task_max_waiting_in_queue_millis"", 0),
-				entry(""active_shards_percent_as_number"", 100.0));
+		assertHealthDetailsWithStatus(health.getDetails(), ""green"");
 	}
 
 	@Test
@@ -93,17 +84,7 @@ public void elasticsearchWithYellowStatusIsUp() throws IOException {
 
 		Health health = this.elasticsearchRestHealthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.UP);
-
-		assertThat(health.getDetails()).contains(entry(""cluster_name"", ""elasticsearch""),
-				entry(""status"", ""yellow""), entry(""timed_out"", false),
-				entry(""number_of_nodes"", 1), entry(""number_of_data_nodes"", 1),
-				entry(""active_primary_shards"", 0), entry(""active_shards"", 0),
-				entry(""relocating_shards"", 0), entry(""initializing_shards"", 0),
-				entry(""unassigned_shards"", 0), entry(""delayed_unassigned_shards"", 0),
-				entry(""number_of_pending_tasks"", 0),
-				entry(""number_of_in_flight_fetch"", 0),
-				entry(""task_max_waiting_in_queue_millis"", 0),
-				entry(""active_shards_percent_as_number"", 100.0));
+		assertHealthDetailsWithStatus(health.getDetails(), ""yellow"");
 	}
 
 	@Test
@@ -119,7 +100,6 @@ public void elasticsearchIsDown() throws IOException {
 
 	@Test
 	public void elasticsearchIsDownByResponseCode() throws IOException {
-
 		Response response = mock(Response.class);
 		StatusLine statusLine = mock(StatusLine.class);
 
@@ -150,8 +130,13 @@ public void elasticsearchIsOutOfServiceByStatus() throws IOException {
 
 		Health health = this.elasticsearchRestHealthIndicator.health();
 		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
-		assertThat(health.getDetails()).contains(entry(""cluster_name"", ""elasticsearch""),
-				entry(""status"", ""red""), entry(""timed_out"", false),
+		assertHealthDetailsWithStatus(health.getDetails(), ""red"");
+	}
+
+	private void assertHealthDetailsWithStatus(Map<String, Object> details,
+			String status) {
+		assertThat(details).contains(entry(""cluster_name"", ""elasticsearch""),
+				entry(""status"", status), entry(""timed_out"", false),
 				entry(""number_of_nodes"", 1), entry(""number_of_data_nodes"", 1),
 				entry(""active_primary_shards"", 0), entry(""active_shards"", 0),
 				entry(""relocating_shards"", 0), entry(""initializing_shards"", 0),
",True,The commit message refers to the necessity of changes by referencing the prior commit and the changes made for the REST variant. It explains that this commit polishes the previous one and aligns the Jest HealthIndicator with the changes made for the REST variant. This shows that the changes are made to improve the consistency and coherence of the codebase.,True,"The commit message 'Add details in Jest ElasticSearch HealthIndicator' does not explicitly state the necessity of the changes, but the changes made in the code diff are clear improvements. The changes align the Jest HealthIndicator with the changes made for the REST variant, which suggests that the changes are likely to improve the functionality or consistency of the code. Additionally, the changes include adding more details to the health indicator, such as the status code and response details, which suggests that the changes are likely to improve the diagnostic capabilities of the health indicator. Therefore, the commit message can be considered to contain an expression that describes the necessity of the changes.",True,The commit message explains the motivation for the changes by mentioning that it is polishing the previous commit and aligning the Jest HealthIndicator with the changes made for the REST variant. This implies that there might have been some issues or shortcomings in the previous implementation that this commit aims to address.,True,"The commit message 'Add details in Jest ElasticSearch HealthIndicator' indicates that the changes were made to align the Jest HealthIndicator with the changes made for the REST variant. This suggests that the changes were made to address the need for software development to meet the requirements of users or to maintain the software, as the REST variant may have introduced new features or changes that the Jest HealthIndicator needed to incorporate.",True,"The commit message 'Add details in Jest ElasticSearch HealthIndicator' indicates that the change is adding more details to the health indicator, which could be interpreted as improving the code by providing more information about the health status of Elasticsearch.",True,"The commit message 'Add details in Jest ElasticSearch HealthIndicator' does describe the changes made in the code diff. It mentions the addition of details to the Jest HealthIndicator, which aligns with the changes made in the code diff. Specifically, the diff shows the addition of a status code and details to the health check response, which is mentioned in the commit message.",True,"The commit message explains that the changes made to the Jest ElasticSearch HealthIndicator are aligning it with the changes made for the REST variant. This suggests that the technical principle underpinning the changes is the use of a consistent and standardized approach to handling health checks, regardless of the underlying technology used to interact with Elasticsearch.",True,"The commit message 'Add details in Jest ElasticSearch HealthIndicator' describes the changes made to the code in a functional perspective. It mentions that the commit polishes the previous one and aligns the Jest HealthIndicator with the changes made for the REST variant. The code diff shows that the JsonParser has been replaced with a different implementation, and additional details are now included in the health check results. This allows for more comprehensive status reporting, including the status code and detailed cluster information.",False,"The commit message does not explicitly explain the reason for the commit. While it mentions aligning the Jest HealthIndicator with changes made for the REST variant, it does not provide specific details about the changes or improvements made. A more descriptive commit message could have been beneficial to understand the context and purpose of the changes."
https://github.com/square/retrofit/commit/a19609a16359af66aec5410459899291b2c45cf1,Add example of using JSON converter as a String converter.  <enter> This also adds the Retrofit instance as a param to the string converter to allow it to delegate to others directly. This brings it into parity with the method signatures of the other converter methods anyway. ,https://api.github.com/repos/square/retrofit/commits/a19609a16359af66aec5410459899291b2c45cf1,"@@ -47,7 +47,8 @@ public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] an
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     if (type == String.class) {
       return StringConverter.INSTANCE;
     }
@@ -69,7 +69,8 @@ public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] an
      * {@link Header @Header}, {@link Path @Path}, {@link Query @Query}, and
      * {@link QueryMap @QueryMap} values.
      */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
       return null;
     }
   }
@@ -343,7 +343,7 @@ public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotati
 
     for (int i = 0, count = converterFactories.size(); i < count; i++) {
       Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations);
+          converterFactories.get(i).stringConverter(type, annotations, this);
       if (converter != null) {
         //noinspection unchecked
         return (Converter<T, String>) converter;
@@ -354,7 +354,8 @@ public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] an
   @Test public void parameterAnnotationsPassedToStringConverter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         annotationsRef.set(annotations);
 
         return new Converter<Object, String>() {
@@ -377,7 +378,8 @@ class MyConverterFactory extends Converter.Factory {
 
   @Test public void stringConverterNotCalledForString() {
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         throw new AssertionError();
       }
     }
@@ -394,7 +396,8 @@ class MyConverterFactory extends Converter.Factory {
   @Test public void stringConverterReturningNullResultsInDefault() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -945,12 +948,12 @@ class MyConverterFactory extends Converter.Factory {
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations);
+    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
 
     Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
-    verify(factory).stringConverter(type, annotations);
+    verify(factory).stringConverter(type, annotations, retrofit);
     verifyNoMoreInteractions(factory);
   }
 
@@ -39,7 +39,8 @@ public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] an
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     called = true;
     return null;
   }
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.http.GET;
+import retrofit2.http.Query;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+public final class JsonQueryParameters {
+  @Retention(RUNTIME)
+  @interface Json {
+  }
+
+  static class JsonStringConverterFactory extends Converter.Factory {
+    private final Converter.Factory delegateFactory;
+
+    JsonStringConverterFactory(Converter.Factory delegateFactory) {
+      this.delegateFactory = delegateFactory;
+    }
+
+    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        if (annotation instanceof Json) {
+          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+          // reference to it explicitly as a field.
+          Converter<?, RequestBody> delegate =
+              delegateFactory.requestBodyConverter(type, annotations, retrofit);
+          return new DelegateToStringConverter<>(delegate);
+        }
+      }
+      return null;
+    }
+
+    static class DelegateToStringConverter<T> implements Converter<T, String> {
+      private final Converter<T, RequestBody> delegate;
+
+      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override public String convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        delegate.convert(value).writeTo(buffer);
+        return buffer.readUtf8();
+      }
+    }
+  }
+
+  static class Filter {
+    public final String userId;
+
+    public Filter(String userId) {
+      this.userId = userId;
+    }
+  }
+
+  interface Service {
+    @GET(""/filter"")
+    Call<ResponseBody> example(@Json @Query(""value"") Filter value);
+  }
+
+  public static void main(String... args) throws IOException, InterruptedException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse());
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url(""/""))
+        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Call<ResponseBody> call = service.example(new Filter(""123""));
+    Response<ResponseBody> response = call.execute();
+    // TODO handle user response...
+
+    // Print the request path that the server saw to show the JSON query param:
+    RecordedRequest recordedRequest = server.takeRequest();
+    System.out.println(recordedRequest.getPath());
+
+    server.shutdown();
+  }
+}
",True,"The commit message refers to the necessity of changes by mentioning the addition of the Retrofit instance as a parameter to the string converter. This is done to allow the string converter to delegate to others directly, which brings it into parity with the method signatures of the other converter methods. This change is likely made to improve the functionality and consistency of the codebase.",True,"The commit message explains the necessity of changes by stating that it adds an example of using JSON converter as a String converter. This is not a common sense or easy to infer change, as it involves modifying the code to support a new use case for the JSON converter. Additionally, the commit message explains that it adds the Retrofit instance as a parameter to the string converter to allow it to delegate to others directly, which is a specific change that may not be immediately obvious from the code diff.",True,"The commit message explains the motivation for the change by mentioning that it adds an example of using JSON converter as a String converter. This is done to allow the Retrofit instance to be passed to the string converter, which allows it to delegate to others directly. This change is made to bring the method signatures of the string converter into parity with the method signatures of the other converter methods. This explains the shortcoming of the previous implementation, which did not allow for this delegation, and the necessity of the change to improve the functionality of the code.",True,"The commit message indicates that the changes were made to bring the string converter into parity with the method signatures of the other converter methods. This suggests that the change was made to address a problem in the software maintenance process, specifically out of date code that needed to be updated to match the current requirements or standards.",True,"The commit message mentions that the change adds an example of using JSON converter as a String converter. This implies that the change is intended to improve the code by adding a new feature or functionality. Additionally, the commit message mentions that it adds the Retrofit instance as a param to the string converter to allow it to delegate to others directly. This suggests that the change is related to fixing a defect or issue in the code, as the addition of the Retrofit instance as a parameter may be necessary to resolve a problem with the existing implementation.",True,"The commit message accurately summarizes the changes made to the code. It mentions the addition of an example of using JSON converter as a String converter and the modification of the stringConverter method to accept a Retrofit instance as a parameter. This allows the method to delegate to others directly, which is mentioned in the commit message. The message also notes that this change brings the method signatures into parity with the other converter methods, which is a result of the code changes.",True,"The commit message explains that the changes are made to allow the use of the JSON converter as a String converter. This is a technical principle that underpins the changes, as it allows for more flexibility and interoperability in the system.",True,"The commit message describes the changes made to the code by explaining that it adds an example of using the JSON converter as a String converter. This is done by modifying the stringConverter method to accept a Retrofit instance as a parameter, which allows it to delegate to others directly. This change brings the method signature into parity with the other converter methods and enables the use of JSON as a query parameter in Retrofit.",False,"The commit message does not explicitly explain the reason for the change, but it does provide context about the modification. The change is not just a simple addition of an example, but rather a significant modification to the stringConverter method to include a Retrofit instance as a parameter. This change is not trivial and could potentially break existing code, so a more detailed explanation of the reason for the change would be beneficial."
https://github.com/apache/dubbo/commit/8b6f4456d5664f4e7f32b0e772befc4b12086aaa,Minor improvement on test cases: <pr_link> <enter> 1. Use org.junit.Assert instead of junit.framework.Assert(@Deprecated since Junit 4) <enter> 2. Use assertTrue and other assert methods through static import to make codes easier to read,https://api.github.com/repos/apache/dubbo/commits/8b6f4456d5664f4e7f32b0e772befc4b12086aaa,"@@ -19,8 +19,8 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class StatItemTest {
 
@@ -21,12 +21,16 @@
 import com.alibaba.dubbo.rpc.Invocation;
 import com.alibaba.dubbo.rpc.RpcInvocation;
 
-import junit.framework.Assert;
 import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.Map;
 
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+
 public class RpcUtilsTest {
 
     /**
@@ -43,9 +47,9 @@ public void testAttachInvocationIdIfAsync_normal() {
         long id1 = RpcUtils.getInvocationId(inv);
         RpcUtils.attachInvocationIdIfAsync(url, inv);
         long id2 = RpcUtils.getInvocationId(inv);
-        Assert.assertTrue(id1 == id2); // verify if it's idempotent
-        Assert.assertTrue(id1 >= 0);
-        Assert.assertEquals(""bb"", attachments.get(""aa""));
+        assertTrue(id1 == id2); // verify if it's idempotent
+        assertTrue(id1 >= 0);
+        assertEquals(""bb"", attachments.get(""aa""));
     }
 
     /**
@@ -57,7 +61,7 @@ public void testAttachInvocationIdIfAsync_sync() {
         URL url = URL.valueOf(""dubbo://localhost/"");
         Invocation inv = new RpcInvocation(""test"", new Class[]{}, new String[]{});
         RpcUtils.attachInvocationIdIfAsync(url, inv);
-        Assert.assertNull(RpcUtils.getInvocationId(inv));
+        assertNull(RpcUtils.getInvocationId(inv));
     }
 
     /**
@@ -69,7 +73,7 @@ public void testAttachInvocationIdIfAsync_nullAttachments() {
         URL url = URL.valueOf(""dubbo://localhost/?test.async=true"");
         Invocation inv = new RpcInvocation(""test"", new Class[]{}, new String[]{});
         RpcUtils.attachInvocationIdIfAsync(url, inv);
-        Assert.assertTrue(RpcUtils.getInvocationId(inv) >= 0l);
+        assertTrue(RpcUtils.getInvocationId(inv) >= 0l);
     }
 
     /**
@@ -81,7 +85,7 @@ public void testAttachInvocationIdIfAsync_forceNotAttache() {
         URL url = URL.valueOf(""dubbo://localhost/?test.async=true&"" + Constants.AUTO_ATTACH_INVOCATIONID_KEY + ""=false"");
         Invocation inv = new RpcInvocation(""test"", new Class[]{}, new String[]{});
         RpcUtils.attachInvocationIdIfAsync(url, inv);
-        Assert.assertNull(RpcUtils.getInvocationId(inv));
+        assertNull(RpcUtils.getInvocationId(inv));
     }
 
     /**
@@ -93,6 +97,6 @@ public void testAttachInvocationIdIfAsync_forceAttache() {
         URL url = URL.valueOf(""dubbo://localhost/?"" + Constants.AUTO_ATTACH_INVOCATIONID_KEY + ""=true"");
         Invocation inv = new RpcInvocation(""test"", new Class[]{}, new String[]{});
         RpcUtils.attachInvocationIdIfAsync(url, inv);
-        Assert.assertNotNull(RpcUtils.getInvocationId(inv));
+        assertNotNull(RpcUtils.getInvocationId(inv));
     }
 }
",True,"The commit message refers to the use of deprecated methods and classes in the test cases, which is a convention. It explains why the changes are made: to use the recommended methods and classes instead of the deprecated ones. Additionally, the commit message mentions the use of static imports to make the code easier to read, which is an improvement in code style.",True,The commit message clearly states the reasons for the changes: deprecation of junit.framework.Assert and use of static imports for better readability. This is a common practice in code refactoring and does not require a detailed explanation.,True,"The commit message explains the motivation for the code change by mentioning that it is a minor improvement on test cases. Specifically, it mentions that the change is to use org.junit.Assert instead of junit.framework.Assert because the latter is deprecated since Junit 4. This change is made to make the codes easier to read by using static import for assertTrue and other assert methods. The code diff also supports this explanation by showing the actual changes made in the code.",True,"The commit message mentions the use of deprecated classes (junit.framework.Assert) and suggests improvements for readability. This indicates that the changes are made to improve the maintainability of the codebase, addressing the need for software development to meet the requirements of modern development practices and to update out-of-date code.",True,"The commit message mentions the change is a minor improvement on test cases. Specifically, it mentions the use of org.junit.Assert instead of junit.framework.Assert, which is a deprecated class since Junit 4. This change is likely to fix the deprecation warning and improve the code. Additionally, the use of assertTrue and other assert methods through static import is mentioned to make the codes easier to read, which could be considered an improvement in code readability and maintainability.",True,The commit message accurately summarizes the changes made to the test cases. It mentions the use of org.junit.Assert instead of junit.framework.Assert and the use of static import for assert methods to make the code easier to read. These changes are also reflected in the diff provided.,True,The commit message explains that the changes are made to improve the test cases by using more modern and recommended assert methods from org.junit.Assert instead of the deprecated ones from junit.framework.Assert. This change is based on the principle of using updated and recommended libraries and methods to ensure code maintainability and compatibility with newer versions of the framework.,True,"The commit message describes the changes made to the test cases. It mentions the use of org.junit.Assert instead of junit.framework.Assert, which is a deprecated version. It also mentions the use of static import for assert methods to make the code easier to read. The code diff supports this explanation by showing the changes in the import statements. Additionally, the code diff shows the use of assertTrue and assertEquals methods from org.junit.Assert, which aligns with the commit message.",False,The commit message does not lack an explanation. It clearly states the reasons for the changes: using the newer and recommended JUnit Assert methods and making the code easier to read through static imports.
https://github.com/junit-team/junit4/commit/a3e01b1ebea12f5fdfb6349e9e72623ac1f3b232,Cleaning up indentation  <enter> The inline method refactoring conducted by eclipse introduced some extra tabs. <enter> Incomplete - task : Issue 551: Resolve sensitive equality in MethodSorter test. ,https://api.github.com/repos/junit-team/junit4/commits/a3e01b1ebea12f5fdfb6349e9e72623ac1f3b232,"@@ -54,18 +54,18 @@ void subBowser() {
     }
 
     private List<String> getDeclaredFilteredMethods(Class<?> clazz, List<String> ofInterest) {
-    	// the method under test.
-		Method[] actualMethods = MethodSorter.getDeclaredMethods(clazz);
-		
-		// obtain just the names instead of the full methods.
-		List<String> names = new ArrayList<String>();
-		for (Method m : actualMethods) {
-			names.add(m.toString().replace(clazz.getName() + '.', """"));
-		}
-		
-		// filter to just the methods of interest
-    	names.retainAll(ofInterest);   	
-    	return names;
+        // the method under test.
+	    Method[] actualMethods = MethodSorter.getDeclaredMethods(clazz);
+
+        // obtain just the names instead of the full methods.
+        List<String> names = new ArrayList<String>();
+        for (Method m : actualMethods) {
+            names.add(m.toString().replace(clazz.getName() + '.', """"));
+        }
+
+        // filter to just the methods of interest
+        names.retainAll(ofInterest);   	
+        return names;
     }
 
 	@Test
@@ -142,7 +142,7 @@ void delta() {
         void epsilon() {
         }
     }
-    
+
     @Test
     public void testJvmMethodSorter() {
     	Method[] fromJvm = DummySortJvm.class.getDeclaredMethods();
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply mentions the need for cleaning up indentation and that it was caused by a previous refactoring. However, it does not explain why the indentation changes are necessary or beneficial.",True,"The commit message 'Cleaning up indentation' does not explicitly state the necessity of the changes. However, the changes made in the code diff are cosmetic and do not affect the functionality of the code. This is a common practice in software development to improve readability and consistency, and it is easy to infer that the changes were made to clean up the code and improve its appearance.",True,"The commit message mentions the issue report (Issue 551: Resolve sensitive equality in MethodSorter test) which could be the motivation for the code change. However, the code diff provided does not directly relate to this issue. However, the message does imply that the changes are being made to improve the readability and maintainability of the code, which could be a result of addressing a problem or shortcoming in the previous implementation.",False,"The commit message does not explicitly describe the necessity of changes by referring to user requirements, problems in the process of software maintenance, or changes in the runtime or development environment. The message mainly focuses on cleaning up indentation and refactoring, which are more about code quality and style, rather than addressing a specific issue or requirement.",True,"The commit message mentions the issue it is addressing, which is 'Issue 551: Resolve sensitive equality in MethodSorter test'. However, the code diff provided does not directly relate to this issue. Instead, it shows a clean-up of indentation and a refactoring of the 'getDeclaredFilteredMethods' method. While this change does not directly address the mentioned issue, it does improve the readability and maintainability of the code, which can indirectly contribute to resolving the issue in the future.",False,"The commit message does not directly describe the changes made in the code diff. While it mentions cleaning up indentation and refactoring, it does not summarize or list the key components of the change, such as the refactoring of the getDeclaredFilteredMethods method. Additionally, it does not contrast the before and after state of the code.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on cleaning up indentation and mentioning an incomplete task related to resolving sensitive equality in a test method. The code diff, however, shows a refactoring of the getDeclaredFilteredMethods method, which involves obtaining the declared methods of a class, extracting their names, and filtering them based on a list of interest. This could be considered as a form of separation of concerns, where the method is responsible for a single task, but the message does not explicitly state this.",False,"The commit message does not describe the code changes from a functional perspective. It only mentions cleaning up indentation and an incomplete task related to resolving sensitive equality in a test. The code diff shows that no new behaviors have been introduced, only the formatting of the code has been changed.",False,"The commit message does not explicitly explain the reason for the change, even though it's a small and simple one. The message mentions cleaning up indentation and refactoring, but it does not clarify why the extra tabs were introduced or why they needed to be removed. Additionally, the message mentions an incomplete task related to Issue 551, which is not directly related to the changes in the code diff."
https://github.com/junit-team/junit4/commit/638e82435a01af83e77c23e9f8d7b658a89eb4bf,"Use %n in string.format() ( <pr_link> )  <enter> In format strings, it is generally preferable better to use %n, which will produce the platform-specific line separator. ",https://api.github.com/repos/junit-team/junit4/commits/638e82435a01af83e77c23e9f8d7b658a89eb4bf,"@@ -40,7 +40,7 @@ public String getMessage() {
         StringBuilder sb = new StringBuilder(
                 String.format(""There were %d errors:"", fErrors.size()));
         for (Throwable e : fErrors) {
-            sb.append(String.format(""\n  %s(%s)"", e.getClass().getName(), e.getMessage()));
+            sb.append(String.format(""%n  %s(%s)"", e.getClass().getName(), e.getMessage()));
         }
         return sb.toString();
     }
",True,"The commit message refers to a convention regarding the use of %n in string.format(), which will produce the platform-specific line separator. This is a good practice as it ensures the code is portable across different platforms. The code diff also shows the change being made, which is replacing \n with %n in the string.format() method.",True,"The commit message explains the necessity of the change by stating that it is generally preferable to use %n in format strings, which will produce the platform-specific line separator. This is a common best practice to ensure that the code is portable across different operating systems.",True,"The commit message explains the motivation for the change by stating that it is generally preferable to use %n in format strings, which will produce the platform-specific line separator. This is done to avoid potential problems that could arise if the exceptions were kept unchecked, such as inconsistent line separators across different platforms.",True,"The commit message mentions that it is generally preferable to use %n in format strings, which will produce the platform-specific line separator. This change is likely made to improve the software's compatibility and usability across different platforms, which can be seen as a requirement from users or a problem in the software maintenance process, such as the need to support multiple operating systems.",True,The commit message directly mentions the improvement it makes to the code. It states that using %n in string.format() is preferable because it will produce the platform-specific line separator. This is a clear indication that the change is being made to improve the code.,True,"The commit message 'Use %n in string.format()' accurately summarizes the change in the code diff. It specifically mentions the change from using '
' to using '%n' in the string.format() method, which is the key component of the change. The message also contrasts the before and after by mentioning the use of '
' and '%n' respectively.",True,"The commit message explains that it is preferable to use %n in string.format() instead of \n. This is because %n will produce the platform-specific line separator, which is a technical principle underpinning the change. This ensures that the output is consistent and appropriate for the platform it is being run on.",True,"The commit message 'Use %n in string.format()' accurately summarizes the change in the code. The change is a modification in the string formatting, where the line separator is being changed from '
' to '%n'. This change will ensure that the platform-specific line separator is used, as stated in the commit message. This introduces a new behavior in the code, making it more adaptable to different operating systems.",False,"The commit message does not lack an explanation. It explicitly states the reason for the change: 'In format strings, it is generally preferable to use %n, which will produce the platform-specific line separator.' This is a significant change that could affect the output of the program, especially in multi-platform environments. Therefore, the explanation in the commit message is necessary and appropriate."
https://github.com/spring-projects/spring-boot/commit/7019894f0ec7f6fd27121d94aa08022bd3040af9,"Clarify the role of spring-boot-starter-cache  <enter> The cache abstraction is a core feature of the Spring Framework. Basic features such as `@EnableCaching` are therefore available by default with no extra dependencies necessary. <enter> However, the actual cache adapters for JCache, Ehcache 2.x, Caffeine and Guava are located in a separated module, `spring-context-support`. Spring Boot provides that artifact via the `spring-boot-starter-cache` starter. <enter> It is quite easy to 'only' add the cache library dependencies and forget about this extra dependencies since `@EnableCaching` is available by default. This commit clarifies the role of the starer in each section so that it is more obvious. We're already explaining this at the beginning of the section but it seems that's not enough. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/7019894f0ec7f6fd27121d94aa08022bd3040af9,"@@ -3782,9 +3782,10 @@ enabled via the `@EnableCaching` annotation.
 NOTE: If you are using the cache infrastructure with beans that are not interface-based,
 make sure to enable the `proxyTargetClass` attribute of `@EnableCaching`.
 
-TIP: Use the `spring-boot-starter-cache` '`Starter`' to quickly add required caching
-dependencies. If you are adding dependencies manually you should note that certain
-implementations are only provided by the `spring-context-support` jar.
+TIP: Use the `spring-boot-starter-cache` '`Starter`' to quickly add basic caching
+dependencies. The starter brings `spring-context-support`: if you are adding dependencies
+manually, you must include it if you intend to use the JCache, EhCache 2.x or Guava
+support.
 
 If you haven't defined a bean of type `CacheManager` or a `CacheResolver` named
 `cacheResolver` (see `CachingConfigurer`), Spring Boot tries to detect the following
@@ -3842,9 +3843,10 @@ Generic caching is used if the context defines _at least_ one
 [[boot-features-caching-provider-jcache]]
 ==== JCache (JSR-107)
 JCache is bootstrapped via the presence of a `javax.cache.spi.CachingProvider` on the
-classpath (i.e. a JSR-107 compliant caching library). There are various compliant
+classpath (i.e. a JSR-107 compliant caching library) and the `JCacheCacheManager`
+provided by the `spring-boot-starter-cache` '`Starter`'. There are various compliant
 libraries out there and Spring Boot provides dependency management for Ehcache 3,
-Hazelcast and Infinispan). Any other compliant library can be added as well.
+Hazelcast and Infinispan. Any other compliant library can be added as well.
 
 It might happen that more than one provider is present, in which case the provider must
 be explicitly specified. Even if the JSR-107 standard does not enforce a standardized
@@ -3879,8 +3881,9 @@ abstraction expects. No further customization is applied on it.
 [[boot-features-caching-provider-ehcache2]]
 ==== EhCache 2.x
 EhCache 2.x is used if a file named `ehcache.xml` can be found at the root of the
-classpath. If EhCache 2.x and such file is present it is used to bootstrap the cache
-manager. An alternate configuration file can be provide a well using:
+classpath. If EhCache 2.x, the `EhCacheCacheManager` provided by the
+`spring-boot-starter-cache` '`Starter`' and such file is present it is used to bootstrap
+the cache manager. An alternate configuration file can be provide a well using:
 
 [source,properties,indent=0]
 ----
@@ -3994,9 +3997,10 @@ recommend to keep this setting enabled if you create your own `RedisCacheManager
 [[boot-features-caching-provider-caffeine]]
 ==== Caffeine
 Caffeine is a Java 8 rewrite of Guava’s cache and will supersede the Guava support in
-Spring Boot 2.0. If Caffeine is present, a `CaffeineCacheManager` is auto-configured.
-Caches can be created on startup using the `spring.cache.cache-names` property and
-customized by one of the following (in this order):
+Spring Boot 2.0. If Caffeine is present, a `CaffeineCacheManager` (provided by the
+`spring-boot-starter-cache` '`Starter`') is auto-configured. Caches can be created on
+startup using the `spring.cache.cache-names` property and customized by one of the
+following (in this order):
 
 1. A cache spec defined by `spring.cache.caffeine.spec`
 2. A `com.github.benmanes.caffeine.cache.CaffeineSpec` bean is defined
",True,"The commit message explains the necessity of changes by referencing the role of the `spring-boot-starter-cache` starter. It clarifies that the starter is not just for adding basic caching dependencies, but also includes `spring-context-support` which provides additional cache adapters. This is important to note as it can easily be overlooked if only the basic caching dependencies are added manually.",True,"The commit message explains the necessity of changes by clarifying the role of the `spring-boot-starter-cache` starter. It explains that the starter is needed for certain cache implementations (JCache, Ehcache 2.x, Guava) that are only provided by the `spring-context-support` jar. This is not immediately obvious from the code diff, as the changes are mainly about updating documentation and examples, not actual code changes.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that the cache abstraction is a core feature of the Spring Framework and that basic features such as `@EnableCaching` are available by default with no extra dependencies necessary. However, the actual cache adapters for JCache, Ehcache 2.x, Caffeine and Guava are located in a separated module, `spring-context-support`. The commit message clarifies the role of the `spring-boot-starter-cache` starter in providing these additional dependencies, which are necessary for using these specific cache implementations. The message also mentions that it is easy to forget about these extra dependencies, which can lead to errors. The message also mentions that it is closing an issue, which further elaborates the necessity of the changes.",True,"The commit message describes the necessity of changes by explaining that the role of the spring-boot-starter-cache is not clear to users, which could lead to them forgetting to include the extra dependencies necessary for certain cache adapters. This indicates that the changes are being made to improve the user experience and clarify the documentation, which is a common requirement in software development.",True,"The commit message directly mentions the improvement it makes to the code by clarifying the role of the 'spring-boot-starter-cache' starter. It explains that the starter is necessary for certain cache implementations, such as JCache, EhCache 2.x, and Guava, which are only provided by the 'spring-context-support' jar. This clarification aims to prevent users from forgetting to include this extra dependency when using the cache abstraction.",True,The commit message does a good job of summarizing the changes made in the diff. It explains that the message clarifies the role of the spring-boot-starter-cache by highlighting the need for additional dependencies for certain cache implementations. This is a clear and concise summary of the changes made in the diff.,True,"The commit message explains that the `spring-boot-starter-cache` starter is not just for adding basic caching dependencies, but it also brings `spring-context-support` which is necessary for certain cache implementations like JCache, EhCache 2.x, and Guava. This highlights the technical principle that the starter provides more than just basic caching dependencies, it also ensures that all necessary dependencies for various cache implementations are available.",True,"The commit message explains that the `spring-boot-starter-cache` starter is necessary for certain cache implementations, such as JCache, EhCache 2.x, and Guava. This clarifies the role of the starter and highlights the need to include `spring-context-support` if adding dependencies manually. Additionally, the code diff shows changes that further clarify the need for the starter and the specific cache implementations it supports.",False,"The commit message does not lack an explanation for the change. It clarifies the role of the spring-boot-starter-cache by explaining that it provides certain cache adapters that are not available by default. This is not something that can be easily inferred from the code diff, which only modifies a tip about using the starter."
https://github.com/square/retrofit/commit/8eed9f264c13710fc0ac8251b3c5382a129a10ce,Add missing Call wrappers as return type ,https://api.github.com/repos/square/retrofit/commits/8eed9f264c13710fc0ac8251b3c5382a129a10ce,"@@ -80,13 +80,13 @@ <h4>Request Method</h4>
               <h4>URL Manipulation</h4>
               <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
               <pre class=""prettyprint"">@GET(""/group/{id}/users"")
-List&lt;User> groupList(@Path(""id"") int groupId);</pre>
+Call&lt;List&lt;User>> groupList(@Path(""id"") int groupId);</pre>
               <p>Query parameters can also be added.</p>
               <pre class=""prettyprint"">@GET(""/group/{id}/users"")
-List&lt;User> groupList(@Path(""id"") int groupId, @Query(""sort"") String sort);</pre>
+Call&lt;List&lt;User>> groupList(@Path(""id"") int groupId, @Query(""sort"") String sort);</pre>
               <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
               <pre class=""prettyprint"">@GET(""/group/{id}/users"")
-List&lt;User> groupList(@Path(""id"") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
+Call&lt;List&lt;User>> groupList(@Path(""id"") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
               <h4>Request Body</h4>
               <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
",True,"The commit message 'Add missing Call wrappers as return type' explains the necessity of changes by referencing a convention or standard. In this case, the convention is to wrap the return type of the methods with 'Call' to handle asynchronous network operations. This is a common practice in Retrofit, a popular HTTP client for Android and Java, to allow for non-blocking network calls.",True,"The commit message 'Add missing Call wrappers as return type' does not provide a rationale for the changes, but it is easy to infer from the code diff that the changes are being made to ensure that the return type of the methods is a Call object, which is likely used for asynchronous network requests. This is a common practice in many applications, and the commit message does not need to provide a detailed explanation of this.",False,"The commit message does not explicitly describe the necessity of changes. It only states what changes were made without explaining why these changes were needed. The code diff shows that the return type of the methods has been changed from List<User> to Call<List<User>>. However, the commit message does not explain why this change was necessary, such as mentioning an error scenario, an issue report, or a shortcoming of the previous implementation.",True,"The commit message 'Add missing Call wrappers as return type' indicates that the developer made changes to the return type of the methods to match a change in the API. This could be due to a requirement change from the users or a problem in the maintenance of the software, such as outdated code that no longer matches the API.",True,"The commit message 'Add missing Call wrappers as return type' directly mentions the improvement it makes to the code, which is adding missing Call wrappers to the return type of the methods. This change is likely to simplify the handling of asynchronous network requests in the code.",True,"The commit message 'Add missing Call wrappers as return type' accurately summarizes the changes in the diff. The diff shows that the return type of several methods has been changed from 'List<User>' to 'Call<List<User>>'. This change is explicitly mentioned in the commit message, making it a clear and accurate summary of the changes.",False,"The commit message does not explicitly state or describe the technical principle underpinning the changes. It simply states that missing Call wrappers are being added as the return type. However, the technical principle could be that the code is being updated to use asynchronous calls (since Call is a common type for representing asynchronous operations in many programming languages), but this is not explicitly stated in the commit message.",True,"The commit message 'Add missing Call wrappers as return type' accurately describes the code changes. The changes involve wrapping the return type of the methods in a Call object. This introduces new behavior as it changes the way the methods handle asynchronous operations. The methods now return a Call object, which can be used to send the network request and handle the response asynchronously.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'Add missing Call wrappers as return type'. This is necessary because the change is not as simple as removing a space. The change involves modifying the return type of the methods, which could potentially break the code if not handled correctly. Therefore, an explanation of the change is necessary to understand the purpose and potential impact of the commit."
https://github.com/square/okhttp/commit/99f2bafe1c0abb2791131dde5a702d3bb3ba28f3,"Fix isClosed() when a cache has not been initialized  <enter> isClosed() now means 'has close() been called', after commit  <otherCommit_link>  it meant 'has not been initialized or close() has been called'. <enter> Introduced explicit closed state. Minor tweak to use initialized state to determine whether cleanup will do anything. Added a test. ",https://api.github.com/repos/square/okhttp/commits/99f2bafe1c0abb2791131dde5a702d3bb3ba28f3,"@@ -1081,6 +1081,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertFalse(iterator.hasNext());
   }
 
+  @Test public void isClosed_uninitializedCache() throws Exception {
+    // Create an uninitialized cache.
+    cache = new DiskLruCache(cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    assertFalse(cache.isClosed());
+    cache.close();
+    assertTrue(cache.isClosed());
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -152,6 +152,7 @@ public final class DiskLruCache implements Closeable {
 
   // Must be read and written when synchronized on 'this'.
   private boolean initialized;
+  private boolean closed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given
@@ -165,8 +166,8 @@ public final class DiskLruCache implements Closeable {
   private final Runnable cleanupRunnable = new Runnable() {
     public void run() {
       synchronized (DiskLruCache.this) {
-        if (isClosed()) {
-          return; // Closed.
+        if (!initialized | closed) {
+          return; // Nothing to do
         }
         try {
           trimToSize();
@@ -221,6 +222,7 @@ void initialize() throws IOException {
         Platform.get().logW(""DiskLruCache "" + directory + "" is corrupt: ""
             + journalIsCorrupt.getMessage() + "", removing"");
         delete();
+        closed = false;
       }
     }
 
@@ -490,7 +492,9 @@ public synchronized long getMaxSize() {
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
-    executor.execute(cleanupRunnable);
+    if (initialized) {
+      executor.execute(cleanupRunnable);
+    }
   }
 
   /**
@@ -615,7 +619,7 @@ private boolean removeEntry(Entry entry) throws IOException {
 
   /** Returns true if this cache has been closed. */
   public synchronized boolean isClosed() {
-    return journalWriter == null;
+    return closed;
   }
 
   private synchronized void checkNotClosed() {
@@ -635,8 +639,9 @@ public synchronized void flush() throws IOException {
 
   /** Closes this cache. Stored values will remain on the filesystem. */
   public synchronized void close() throws IOException {
-    if (isClosed()) {
-      return; // Already closed.
+    if (!initialized || closed) {
+      closed = true;
+      return;
     }
     // Copying for safe iteration.
     for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
@@ -647,6 +652,7 @@ public synchronized void close() throws IOException {
     trimToSize();
     journalWriter.close();
     journalWriter = null;
+    closed = true;
   }
 
   private void trimToSize() throws IOException {
@@ -726,7 +732,7 @@ public synchronized Iterator<Snapshot> snapshots() throws IOException {
 
         synchronized (DiskLruCache.this) {
           // If the cache is closed, truncate the iterator.
-          if (isClosed()) return false;
+          if (closed) return false;
 
           while (delegate.hasNext()) {
             Entry entry = delegate.next();
",True,"The commit message refers to a convention regarding the behavior of the isClosed() method. Prior to the commit, it meant 'has not been initialized or close() has been called'. However, the commit changes this to mean 'has close() been called'. This change is explained in the commit message as an improvement to clarify the method's behavior.",True,"The commit message 'Fix isClosed() when a cache has not been initialized' clearly explains the necessity of the changes. It mentions that the function isClosed() previously meant 'has not been initialized or close() has been called', but now it means 'has close() been called'. This change is made to introduce an explicit closed state and to fix a bug that occurred when a cache had not been initialized. The commit also adds a test case to ensure that the fix works as intended.",True,"The commit message explains the motivation for the change by mentioning that 'isClosed()' used to mean 'has not been initialized or close() has been called', but now it means 'has close() been called'. This change was made to fix a bug where the function would return the wrong value when a cache had not been initialized. The commit message also mentions the introduction of an explicit closed state and a test to ensure the fix works as intended.",True,"The commit message 'Fix isClosed() when a cache has not been initialized' indicates that the changes were made to address a problem in the software maintenance. The problem is that the isClosed() method was not correctly determining the state of the cache when it had not been initialized. This suggests that the code was out of date or not functioning as intended, which is a common issue in software maintenance.",True,The commit message directly mentions the defect it fixes by stating 'Fix isClosed() when a cache has not been initialized'. This indicates that the change was made to address a specific issue in the code.,True,"The commit message accurately summarizes the changes made in the code diff. It mentions the fix for the isClosed() method when a cache has not been initialized, explaining that it now means 'has close() been called' instead of 'has not been initialized or close() has been called'. This is a clear contrast between the before and after state of the method. Additionally, the message mentions the introduction of an explicit closed state and a minor tweak to use the initialized state to determine whether cleanup will do anything. These are all key components of the change listed in the commit message.",True,"The commit message explains that the changes were made to ensure that the isClosed() method accurately reflects whether the close() method has been called. This is a clear explanation of the technical principle underpinning the changes, which is to maintain the consistency and correctness of the state of the DiskLruCache object.",True,"The commit message accurately describes the changes made to the code. It explains that the function isClosed() now means 'has close() been called' after the commit, which was previously interpreted as 'has not been initialized or close() has been called'. The commit also introduced an explicit closed state and modified the use of the initialized state to determine whether cleanup will do anything. Additionally, a new test was added to verify the changes.",False,"The commit message does not lack an explanation. It clearly states that the change was made to fix the behavior of the isClosed() method when a cache has not been initialized. The explanation also mentions the introduction of an explicit closed state and a minor tweak to use the initialized state to determine whether cleanup will do anything. Additionally, the commit message mentions the addition of a test to ensure the fix works as intended."
https://github.com/square/retrofit/commit/6f8a9a664c0198992b8478e0671cc4a7db4f1d8e,Add missing import. ,https://api.github.com/repos/square/retrofit/commits/6f8a9a664c0198992b8478e0671cc4a7db4f1d8e,"@@ -24,6 +24,7 @@
 import retrofit2.http.Field;
 import retrofit2.http.FieldMap;
 import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
 import retrofit2.http.Part;
 import retrofit2.http.PartMap;
 import retrofit2.http.Path;
",False,"The commit message 'Add missing import' does not reference any conventions, standards, improvements in prior commits, or implemented features. It simply states that a missing import was added to the code, but it does not explain why this change was necessary.",True,"The commit message 'Add missing import' does not provide a rationale for the change. It is easy to infer that the import was missing because the code diff shows a new line of code being added, which is the missing import statement. This is a common practice in coding where missing imports can cause compilation errors. Therefore, the commit message does not offer a clear explanation of the necessity of the changes.",False,"The commit message 'Add missing import' does not explicitly describe the necessity of the changes. It only states what was done, not why it was necessary. The code diff shows that a new import statement was added, but it does not explain why this was needed, such as mentioning an error scenario, an issue report, or a shortcoming of the previous implementation.",False,"The commit message 'Add missing import' does not explicitly describe the necessity of changes. It simply states that an import was missing, which could have been due to a variety of reasons such as a new feature being added, a refactoring, or a mistake. It does not indicate a user requirement, a problem in the maintenance process, or a change in the development environment.",False,The commit message 'Add missing import' does not directly mention the defects it fixes or the improvements it makes to the code. It only states that a missing import was added. This does not provide a clear indication of the purpose or objective of the change.,False,"The commit message 'Add missing import' does not describe the changes made in the diff. The diff shows that a new import statement for 'retrofit2.http.HeaderMap' has been added, but the commit message does not mention this. Therefore, the commit message does not provide a summary of the changes made in the diff.",False,"The commit message 'Add missing import' does not describe a technical principle underpinning the changes. It simply states that a necessary import was missing from the code, which is a basic coding practice and not a principle.",False,"The commit message 'Add missing import' does not describe the code changes from a functional perspective. It only mentions that a new import statement was added to the code. However, it does not explain what the new import is for, how it affects the existing behavior, or what new behaviors it introduces.",True,"The commit message 'Add missing import' clearly explains the reason for the commit. The code diff shows that a single line was added to import the 'HeaderMap' class from the 'retrofit2.http' package. This change is straightforward and does not require a detailed explanation. Therefore, the commit message is sufficient and does not lack an expression explaining the reason for the commit."
https://github.com/junit-team/junit4/commit/5785d9df8fe25f68567272850cd65b4dc07da617,Deprecate rule ExpectedException ( <pr_link> )  <enter> The method Assert.assertThrows provides a nicer way for verifying exceptions. In addition the use of ExpectedException is error-prone when used with other rules like TestWatcher because the order of rules is important in that case. ,https://api.github.com/repos/junit-team/junit4/commits/5785d9df8fe25f68567272850cd65b4dc07da617,"@@ -14,11 +14,7 @@
 
 /**
  * The {@code ExpectedException} rule allows you to verify that your code
- * throws a specific exception. Note that, starting with Java 8,
- * {@link org.junit.Assert#assertThrows(java.lang.Class, org.junit.function.ThrowingRunnable)
- * Assert.assertThrows}
- * is often a better choice since it allows you to express exactly where you
- * expect the exception to be thrown.
+ * throws a specific exception.
  *
  * <h3>Usage</h3>
  *
@@ -110,6 +106,10 @@
  * exception. E.g. ""Test doesn't throw %s."" will fail with the error message
  * ""Test doesn't throw an instance of foo."".
  *
+ * @deprecated Since 4.13
+ * {@link org.junit.Assert#assertThrows(Class, org.junit.function.ThrowingRunnable)
+ * Assert.assertThrows} can be used to verify that your code throws a specific
+ * exception.
  * @since 4.7
  */
 public class ExpectedException implements TestRule {
",True,"The commit message refers to the deprecation of the ExpectedException rule, explaining that the method Assert.assertThrows provides a nicer way for verifying exceptions. This is a reference to a convention or standard (using Assert.assertThrows instead of ExpectedException) and it also mentions a potential issue with the ExpectedException rule when used with other rules like TestWatcher, explaining why the change is necessary.",True,"The commit message explains the necessity of changes by stating that the method Assert.assertThrows provides a nicer way for verifying exceptions and that the use of ExpectedException is error-prone when used with other rules like TestWatcher because the order of rules is important in that case. Additionally, the code diff shows that the ExpectedException class is being deprecated in favor of Assert.assertThrows, which further supports the explanation provided in the commit message.",True,The commit message directly elaborates the motivation of the code change by mentioning that the method Assert.assertThrows provides a nicer way for verifying exceptions and that the use of ExpectedException is error-prone when used with other rules like TestWatcher because the order of rules is important in that case. This clearly describes the shortcoming of the previous implementation and the necessity of the changes.,True,"The commit message indicates that the changes are made due to the need for software development for requirements of users. The message mentions that the method Assert.assertThrows provides a nicer way for verifying exceptions, which is likely to improve the user experience. Additionally, the message mentions that the use of ExpectedException is error-prone when used with other rules like TestWatcher because the order of rules is important in that case. This could potentially lead to bugs and issues in the software maintenance process. The code diff also supports this by deprecating the ExpectedException class and suggesting the use of Assert.assertThrows instead.",True,The commit message directly mentions the defects it fixes by stating that the use of ExpectedException is error-prone when used with other rules like TestWatcher because the order of rules is important. It also mentions the improvement it makes to the code by suggesting the use of Assert.assertThrows as a better choice for verifying exceptions.,True,The commit message does express a summary of what changes by describing the deprecation of the rule ExpectedException and mentioning the use of Assert.assertThrows as a better alternative. It also highlights the error-prone nature of ExpectedException when used with other rules like TestWatcher. The diff supports this by showing the removal of the explanation about Assert.assertThrows and the addition of a deprecation notice.,True,"The commit message explains that the changes are being made to deprecate the rule ExpectedException because the method Assert.assertThrows provides a nicer way for verifying exceptions. This highlights the technical principle of using more modern and efficient methods to achieve the same result, which is the principle underpinning the changes.",True,"The commit message expresses a deprecation of the ExpectedException rule and mentions that the method Assert.assertThrows provides a nicer way for verifying exceptions. This indicates that the code changes are functional in nature, as they are introducing a new behavior (the use of Assert.assertThrows) and deprecating an old one (ExpectedException). The message also explains the reason for the change, which is to improve the usability and reliability of the exception verification process.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: the deprecation of the rule ExpectedException due to the availability of a nicer way to verify exceptions using Assert.assertThrows. Additionally, it mentions that the use of ExpectedException is error-prone when used with other rules like TestWatcher because the order of rules is important in that case. The code diff also supports this explanation by removing the documentation that suggests using Assert.assertThrows instead of ExpectedException."
https://github.com/square/okhttp/commit/6909923b89d98fef39600a170aa50e566dbb730a,Update CHANGELOG.md ,https://api.github.com/repos/square/okhttp/commits/6909923b89d98fef39600a170aa50e566dbb730a,"@@ -35,7 +35,7 @@ _2014-12-30_
  *  Fix: Cache 302s and 308s that include appropriate response headers.
  *  Fix: Improve pooling of connections that use proxy selectors.
  *  Fix: Don't leak connections when using ALPN on the desktop.
- *  Fix: Update Jetty ALPN to `7.1.2.v20141202` (Java 7) and 8.1.2.v20141202 (Java 8).
+ *  Fix: Update Jetty ALPN to `7.1.2.v20141202` (Java 7) and `8.1.2.v20141202` (Java 8).
     This fixes a bug in resumed TLS sessions where the wrong protocol could be
     selected.
  *  Fix: Don't crash in SPDY and HTTP/2 when disconnecting before connecting.
",True,"The commit message refers to a fix in the codebase, specifically updating Jetty ALPN to a newer version. This update is likely necessary to address a bug in resumed TLS sessions where the wrong protocol could be selected. The reference to a specific version and the issue it resolves suggests that the change is being made to improve the functionality of the codebase.",True,"The commit message 'Update CHANGELOG.md' does not explicitly describe the necessity of the changes. However, it is common sense and easy to infer that the change is to update the changelog with the new version of Jetty ALPN. This is a standard practice in software development to keep track of changes and updates.",True,The commit message 'Update CHANGELOG.md' does contain an expression that describes the necessity of changes. It mentions that the Jetty ALPN is being updated to fix a bug in resumed TLS sessions where the wrong protocol could be selected. This directly elaborates the motivation of the code change by describing the issue that was being fixed.,True,"The commit message 'Update CHANGELOG.md' and the diff indicate that the developer is updating the Jetty ALPN version to '7.1.2.v20141202' (Java 7) and '8.1.2.v20141202' (Java 8). This update is likely due to the need to fix a bug in resumed TLS sessions where the wrong protocol could be selected. This is an indication of a problem in the software maintenance process, specifically outdated code that needs to be updated to fix a bug.",True,"The commit message directly mentions the fix for a bug in resumed TLS sessions where the wrong protocol could be selected. This clearly describes the objective of the change, which is to fix a defect in the code.",True,"The commit message 'Update CHANGELOG.md' does contain an expression that describes a summary of what changes by being a summary of the diffs. Specifically, it mentions the update of Jetty ALPN to a new version for both Java 7 and Java 8. This is a clear indication of the change made in the code diff.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that a version update has been made to Jetty ALPN for Java 7 and Java 8, which is a fix for a bug in resumed TLS sessions. However, it does not explain why this update is necessary or what technical principle it is based on.",True,"The commit message 'Update CHANGELOG.md' does contain an expression that describes a summary of what changes by explaining the code changes from a functional perspective. The code diff shows that a version number in the CHANGELOG.md file has been updated. This change indicates that a new version of Jetty ALPN has been integrated into the project, which is a functional change. The message also mentions that this update fixes a bug in resumed TLS sessions where the wrong protocol could be selected. This provides a clear explanation of the new behavior introduced by the change, which is to ensure that the correct protocol is selected during resumed TLS sessions.",True,"The commit message only updates the version number of Jetty ALPN in the CHANGELOG.md file. The change is small and simple, and the reason for the update is clearly stated in the diff. The commit message does not need to provide additional explanation."
https://github.com/square/retrofit/commit/fb746cb2f67a51c100e368844ac26dedb9e8eac4,"Expose success type on RetrofitError.  <enter> There's a bit of a test gap going on for all the variants of successful and erroneous handling of sync, async, and rx. This new behavior is fully tested in all three but more general behavior testing for them will be needed in in a follow-up. ",https://api.github.com/repos/square/retrofit/commits/fb746cb2f67a51c100e368844ac26dedb9e8eac4,"@@ -8,7 +8,7 @@ class MockHttpRetrofitError extends RetrofitError {
   private final Object body;
 
   MockHttpRetrofitError(String message, String url, Response response, Object body) {
-    super(message, url, response, null, null, false, null);
+    super(message, url, response, null, body.getClass(), false, null);
     this.body = body;
   }
 
@@ -37,7 +37,7 @@ interface SyncExample {
   }
 
   interface AsyncExample {
-    @GET(""/"") void doStuff(Callback<Object> cb);
+    @GET(""/"") void doStuff(Callback<String> cb);
   }
 
   interface AsyncCallbackSubtypeExample {
@@ -47,7 +47,7 @@ abstract class Foo implements Callback<String> {}
   }
 
   interface ObservableExample {
-    @GET(""/"") Observable<Object> doStuff();
+    @GET(""/"") Observable<String> doStuff();
   }
 
   private Executor httpExecutor;
@@ -242,16 +242,16 @@ class MockSyncExample implements SyncExample {
     mockRestAdapter.setErrorPercentage(100);
 
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw new AssertionError();
       }
     }
 
     AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
 
     final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -298,9 +298,11 @@ class MockSyncExample implements SyncExample {
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Hi"");
+
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         cb.success(expected, null);
       }
     }
@@ -310,8 +312,8 @@ class MockAsyncExample implements AsyncExample {
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
     final AtomicReference<Object> actual = new AtomicReference<Object>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object result, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String result, Response response) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         actual.set(result);
       }
@@ -333,9 +335,11 @@ class MockAsyncExample implements AsyncExample {
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Hello"");
+
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         return Observable.from(expected);
       }
     }
@@ -373,9 +377,11 @@ class MockObservableExample implements ObservableExample {
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Hello"");
+
     class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
+      @Override public String doStuff() {
         throw new MockHttpException(404, ""Not Found"", expected);
       }
     }
@@ -393,6 +399,7 @@ class MockSyncExample implements SyncExample {
       assertThat(e.getResponse().getStatus()).isEqualTo(404);
       assertThat(e.getResponse().getReason()).isEqualTo(""Not Found"");
       assertThat(e.getBody()).isSameAs(expected);
+      assertThat(e.getSuccessType()).isEqualTo(String.class);
     }
   }
 
@@ -401,9 +408,11 @@ class MockSyncExample implements SyncExample {
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Greetings"");
+
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw new MockHttpException(404, ""Not Found"", expected);
       }
     }
@@ -413,8 +422,8 @@ class MockAsyncExample implements AsyncExample {
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
     final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -433,16 +442,19 @@ class MockAsyncExample implements AsyncExample {
     assertThat(error.getResponse().getStatus()).isEqualTo(404);
     assertThat(error.getResponse().getReason()).isEqualTo(""Not Found"");
     assertThat(error.getBody()).isSameAs(expected);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void observableHttpExceptionBecomesError() {
     mockRestAdapter.setDelay(100);
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
+    final String expected = new String(""Hi"");
+
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         throw new MockHttpException(404, ""Not Found"", expected);
       }
     }
@@ -474,6 +486,7 @@ class MockObservableExample implements ObservableExample {
     assertThat(error.getResponse().getStatus()).isEqualTo(404);
     assertThat(error.getResponse().getReason()).isEqualTo(""Not Found"");
     assertThat(error.getBody()).isSameAs(expected);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void syncErrorUsesErrorHandler() {
@@ -504,7 +517,7 @@ class MockSyncExample implements SyncExample {
     mockRestAdapter.setErrorPercentage(0);
 
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw MockHttpException.newNotFound(new Object());
       }
     }
@@ -513,8 +526,8 @@ class MockAsyncExample implements AsyncExample {
     nextError = new IllegalArgumentException(""Test"");
 
     final CountDownLatch latch = new CountDownLatch(1);
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -532,7 +545,7 @@ class MockAsyncExample implements AsyncExample {
     mockRestAdapter.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         throw MockHttpException.newNotFound(new Object());
       }
     }
@@ -349,6 +349,9 @@ private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodIn
 
           TypedInput body = response.getBody();
           if (body == null) {
+            if (methodInfo.isSynchronous) {
+              return null;
+            }
             return new ResponseWrapper(response, null);
           }
 
@@ -83,6 +83,14 @@ public Object getBody() {
     return getBodyAs(successType);
   }
 
+  /**
+   * The type declared by either the interface method return type or the generic type of the
+   * supplied {@link Callback} parameter.
+   */
+  public Type getSuccessType() {
+    return successType;
+  }
+
   /**
    * HTTP response body converted to specified {@code type}. {@code null} if there is no response.
    */
@@ -34,9 +34,7 @@
 import static org.assertj.core.api.Assertions.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
 import static org.mockito.Matchers.same;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doReturn;
@@ -68,16 +66,16 @@ public class RestAdapterTest {
     }
 
     @Override public InputStream in() throws IOException {
-      return new ByteArrayInputStream(""{}"".getBytes(""UTF-8""));
+      return new ByteArrayInputStream(""Hi"".getBytes(""UTF-8""));
     }
   };
 
   private interface Example {
     @Headers(""Foo: Bar"")
-    @GET(""/"") Object something();
+    @GET(""/"") String something();
     @Headers(""Foo: Bar"")
     @POST(""/"") Object something(@Body TypedOutput body);
-    @GET(""/"") void something(Callback<Object> callback);
+    @GET(""/"") void something(Callback<String> callback);
     @GET(""/"") Response direct();
     @GET(""/"") void direct(Callback<Response> callback);
     @POST(""/"") Observable<String> observable(@Body String body);
@@ -127,7 +125,7 @@ private interface InvalidExample extends Example {
     Object data = new Object();
     when(mockProfiler.beforeCall()).thenReturn(data);
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, null));
+        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hey"")));
 
     example.something();
 
@@ -155,7 +153,7 @@ public void log(String message) {
         .create(Example.class);
 
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", TWO_HEADERS, new TypedString(""{}"")));
+        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", TWO_HEADERS, new TypedString(""Hi"")));
 
     example.something();
     assertThat(logMessages).hasSize(2);
@@ -182,7 +180,7 @@ public void log(String message) {
         .create(Example.class);
 
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", TWO_HEADERS, new TypedString(""{}"")));
+        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", TWO_HEADERS, new TypedString(""Hi"")));
 
     example.something();
     assertThat(logMessages).hasSize(7);
@@ -302,13 +300,13 @@ public void log(String message) {
     assertThat(logMessages.get(4)).isEqualTo(""Content-Type: application/json"");
     assertThat(logMessages.get(5)).isEqualTo(""Content-Length: 42"");
     assertThat(logMessages.get(6)).isEqualTo("""");
-    assertThat(logMessages.get(7)).isEqualTo(""{}"");
+    assertThat(logMessages.get(7)).isEqualTo(""Hi"");
     assertThat(logMessages.get(8)).isEqualTo(""<--- END HTTP (2-byte body)"");
   }
 
   @Test public void synchronousDoesNotUseExecutors() throws Exception {
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, null));
+        .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hi"")));
 
     example.something();
 
@@ -317,15 +315,15 @@ public void log(String message) {
   }
 
   @Test public void asynchronousUsesExecutors() throws Exception {
-    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""{}""));
+    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hey""));
     when(mockClient.execute(any(Request.class))).thenReturn(response);
-    Callback<Object> callback = mock(Callback.class);
+    Callback<String> callback = mock(Callback.class);
 
     example.something(callback);
 
     verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
     verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(anyString(), same(response));
+    verify(callback).success(eq(""Hey""), same(response));
   }
 
   @Test public void malformedResponseThrowsConversionException() throws Exception {
@@ -351,6 +349,7 @@ public void log(String message) {
       fail(""RetrofitError expected on non-2XX response code."");
     } catch (RetrofitError e) {
       assertThat(e.getResponse().getStatus()).isEqualTo(500);
+      assertThat(e.getSuccessType()).isEqualTo(String.class);
     }
   }
 
@@ -392,7 +391,7 @@ public void log(String message) {
     assertThat(logMessages.get(4)).isEqualTo(""Content-Type: application/json"");
     assertThat(logMessages.get(5)).isEqualTo(""Content-Length: 42"");
     assertThat(logMessages.get(6)).isEqualTo("""");
-    assertThat(logMessages.get(7)).isEqualTo(""{}"");
+    assertThat(logMessages.get(7)).isEqualTo(""Hi"");
     assertThat(logMessages.get(8)).isEqualTo(""<--- END HTTP (2-byte body)"");
   }
 
@@ -510,7 +509,7 @@ public void log(String message) {
   }
 
   @Test public void getResponseDirectlyAsync() throws Exception {
-    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, null);
+    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hey""));
     when(mockClient.execute(any(Request.class))) //
         .thenReturn(response);
     Callback<Response> callback = mock(Callback.class);
@@ -522,6 +521,43 @@ public void log(String message) {
     verify(callback).success(eq(response), same(response));
   }
 
+  @Test public void getAsync() throws Exception {
+    Response response = new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""Hey""));
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(response);
+    Callback<String> callback = mock(Callback.class);
+
+    example.something(callback);
+
+    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+    verify(mockCallbackExecutor).execute(any(Runnable.class));
+
+    ArgumentCaptor<String> responseCaptor = ArgumentCaptor.forClass(String.class);
+    verify(callback).success(responseCaptor.capture(), same(response));
+    assertThat(responseCaptor.getValue()).isEqualTo(""Hey"");
+  }
+
+
+  @Test public void errorAsync() throws Exception {
+    Response response = new Response(""http://example.com/"", 500, ""Broken!"", NO_HEADERS, new TypedString(""Hey""));
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(response);
+    Callback<String> callback = mock(Callback.class);
+
+    example.something(callback);
+
+    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+    verify(mockCallbackExecutor).execute(any(Runnable.class));
+
+    ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
+    verify(callback).failure(errorCaptor.capture());
+    RetrofitError error = errorCaptor.getValue();
+    assertThat(error.getResponse().getStatus()).isEqualTo(500);
+    assertThat(error.getResponse().getReason()).isEqualTo(""Broken!"");
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
+    assertThat(error.getBody()).isEqualTo(""Hey"");
+  }
+
   @Test public void observableCallsOnNext() throws Exception {
     when(mockClient.execute(any(Request.class))) //
         .thenReturn(new Response(""http://example.com/"", 200, ""OK"", NO_HEADERS, new TypedString(""hello"")));
@@ -537,7 +573,11 @@ public void log(String message) {
     Action1<Throwable> onError = mock(Action1.class);
     example.observable(""Howdy"").subscribe(onSuccess, onError);
     verifyZeroInteractions(onSuccess);
-    verify(onError).call(isA(RetrofitError.class));
+
+    ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
+    verify(onError).call(errorCaptor.capture());
+    RetrofitError value = errorCaptor.getValue();
+    assertThat(value.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void observableHandlesParams() throws Exception {
",True,"The commit message refers to the necessity of changes by mentioning the 'test gap' for all the variants of successful and erroneous handling of sync, async, and rx. This indicates that the changes are being made to improve the testing coverage and ensure the correct behavior of the code.",True,"The commit message explains the necessity of changes by mentioning that there's a test gap for all the variants of successful and erroneous handling of sync, async, and rx. The changes are made to expose the success type on RetrofitError, which is necessary to fully test the behavior in all three variants.",True,"The commit message explains the motivation for the changes by mentioning the need for more general behavior testing for successful and erroneous handling of sync, async, and rx. This is done to address the current test gap that exists for all the variants of successful and erroneous handling. Additionally, the commit message mentions that the new behavior is fully tested in all three categories, which indicates that the changes were made to improve the testing coverage and reliability of the code.",True,"The commit message mentions the need for more general behavior testing for successful and erroneous handling of sync, async, and rx. This indicates that the changes are being made to address a problem or requirement, in this case, to improve the testing coverage for different types of API calls.",True,"The commit message mentions that it 'Expose success type on RetrofitError', which directly relates to the changes made in the code diff. This change improves the code by providing more information about the type of success that was expected, which can be useful for debugging and error handling.",True,"The commit message 'Expose success type on RetrofitError' accurately describes the change made in the code diff. The change involves adding a new method 'getSuccessType()' to the RetrofitError class, which returns the type declared by either the interface method return type or the generic type of the supplied Callback parameter. This addition allows for better error handling and more specific type information in case of errors.",True,"The commit message explains that the changes are exposing the success type on RetrofitError, which is a technical principle that allows the handling of successful and erroneous responses in a more explicit and type-safe manner.",True,"The commit message 'Expose success type on RetrofitError' accurately describes the changes made in the code diff. The changes include adding a new method 'getSuccessType()' to the RetrofitError class, which returns the type declared by either the interface method return type or the generic type of the supplied Callback parameter. This allows for better handling of successful responses in asynchronous and observable calls, as demonstrated in the test cases added for these scenarios.",False,"The commit message explains the reason for the change, which is to expose the success type on RetrofitError. This is necessary because the code diff shows changes to the type of the success object in various parts of the code, such as changing the type from Object to String in the Callback and Observable interfaces. Without this change, the success type would not be correctly reflected in the RetrofitError object, which could lead to errors or unexpected behavior."
https://github.com/square/okhttp/commit/2ec2027fc00e24a83cd7bb7fef8b11e7c751bc13,Add missing copyright headers.  <enter> <issue_link> ,https://api.github.com/repos/square/okhttp/commits/2ec2027fc00e24a83cd7bb7fef8b11e7c751bc13,"@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 // http://tools.ietf.org/html/draft-ietf-httpbis-http2-12#section-7
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 import java.io.IOException;
",True,"The commit message 'Add missing copyright headers' explicitly refers to a convention or standard (the Apache License, Version 2.0) that requires the inclusion of copyright headers in the code. This explains the necessity of the changes made in the diff, which is the addition of copyright headers to the files.",True,"The commit message 'Add missing copyright headers' clearly and explicitly states the reason for the changes. It is not common sense or easy to infer that the copyright headers need to be added, as they are a legal requirement and not automatically included in the code.",True,"The commit message 'Add missing copyright headers' directly elaborates the motivation of the code change. It mentions that the copyright headers are missing, which could potentially lead to legal issues if not included. This is a clear indication of the necessity of the changes.",True,"The commit message 'Add missing copyright headers' indicates that the changes were made to comply with the requirements of the Apache License, which is a legal requirement. This suggests that the source of the requirements was the need to comply with the license terms for the software.",True,"The commit message 'Add missing copyright headers' directly mentions the improvement it makes to the code, which is adding the missing copyright headers to comply with the Apache License, Version 2.0.",True,"The commit message 'Add missing copyright headers' accurately summarizes the changes made in the diff. The diff shows the addition of a copyright header at the beginning of the file, which is exactly what the commit message describes.",False,"The commit message 'Add missing copyright headers' does not describe a technical principle underpinning the changes. It simply states that the changes were made to add missing copyright headers to the files, which is a legal and administrative requirement, not a technical principle.",True,"The commit message 'Add missing copyright headers' clearly describes the changes made to the code. The code diff shows that copyright headers have been added to the file, which is a common practice to ensure that the license and ownership of the code is clear. This change does not introduce any new behaviors or functional changes to the code.",False,"The commit message does not explicitly explain the reason for the change. Although the change is adding copyright headers, it's not immediately clear from the diff that this is the case. The commit message should have explicitly stated that it's adding missing copyright headers to comply with the Apache License."
https://github.com/square/okhttp/commit/aaf2695b00dfd69df6fd915ba16665eee8c1962d,"Fix ResponseCacheTest for Android  <enter> Pull  <pr_link>  broke ResponseCacheTest on Android. <enter> The test was asserting a header generated using a copy of the old broken implementation. <enter> The test now just uses HttpDate, which now has its own tests. ",https://api.github.com/repos/square/okhttp/commits/aaf2695b00dfd69df6fd915ba16665eee8c1962d,"@@ -21,6 +21,7 @@
 import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
@@ -911,7 +912,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     connection.setIfModifiedSince(since.getTime());
     assertEquals(""A"", readAscii(connection));
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeaders().contains(""If-Modified-Since: "" + formatDate(since)));
+    assertTrue(request.getHeaders().contains(""If-Modified-Since: "" + HttpDate.format(since)));
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
@@ -1262,13 +1263,7 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
    * future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss zzz"", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone(""GMT""));
-    return rfc1123.format(date);
+    return HttpDate.format(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
   }
 
   private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
",True,"The commit message refers to a convention regarding the use of tested and reliable code. It mentions that the test was previously asserting a header generated using a copy of the old broken implementation. However, the test now uses HttpDate, which has its own tests, implying that the changes were made to improve the reliability and maintainability of the codebase.",True,"The commit message explains that the changes were made to fix a broken test on Android. The test was previously asserting a header generated using a copy of the old broken implementation. Now, the test uses HttpDate, which has its own tests. This change was made to ensure that the test works correctly on Android, which is a necessary change to maintain the functionality of the codebase.",True,"The commit message explains the problem that occurred when a pull request broke the ResponseCacheTest on Android. It mentions that the test was asserting a header generated using a copy of the old broken implementation. The commit message also explains that the test now just uses HttpDate, which has its own tests, implying that the previous implementation had issues. This directly elaborates the motivation of the code change and describes the shortcoming of the previous implementation.",True,"The commit message indicates that the changes were made to fix a broken test on Android. The message mentions that the test was asserting a header generated using a copy of the old broken implementation. This suggests that the old implementation was out of date or no longer functioning correctly, which is a common problem in software maintenance.",True,"The commit message directly mentions the defect it fixes, which is the broken ResponseCacheTest on Android. It also mentions the improvement made to the code, which is the use of HttpDate instead of a copy of the old broken implementation. This change simplifies the test and ensures that HttpDate is tested separately.",True,"The commit message describes the changes made to the ResponseCacheTest, specifically mentioning that the test was using a broken implementation of a header and has been updated to use HttpDate instead. This directly relates to the code diff, where the import of HttpDate has been added and the usage of a custom date formatting method has been replaced with HttpDate.format.",True,"The commit message explains that the changes were made to fix a test that was using a broken implementation of date formatting. The test now uses HttpDate, which is a separate class with its own tests. This indicates that the principle underpinning the changes is to use a well-tested and reliable library for date formatting, rather than relying on a broken implementation.",True,"The commit message describes the issue that the test was asserting a header generated using a copy of the old broken implementation. The fix involves using HttpDate, which now has its own tests. This change introduces new behavior in the test, which now uses HttpDate to generate the header instead of the old broken implementation.",False,"The commit message does not explicitly state that the change was made to fix a date formatting issue, which is a significant change. While the code diff may suggest this, it's not explicitly stated in the commit message. Therefore, the commit message lacks an explanation of the reason for the change."
https://github.com/spring-projects/spring-boot/commit/5e9b8c3340d25fbf0e7d64b306ae7b3557188b9a,Add missing depdendency ,https://api.github.com/repos/spring-projects/spring-boot/commits/5e9b8c3340d25fbf0e7d64b306ae7b3557188b9a,"@@ -49,8 +49,8 @@
 		</dependency>
 		<dependency>
 			<groupId>org.springframework</groupId>
-			<artifactId>spring-test</artifactId>
-			<scope>test</scope>
+			<artifactId>spring-jdbc</artifactId>
+			<optional>true</optional>
 		</dependency>
 		<dependency>
 			<groupId>org.springframework</groupId>
@@ -73,6 +73,11 @@
 			<optional>true</optional>
 		</dependency>
 		<!-- Test -->
+		<dependency>
+			<groupId>org.springframework</groupId>
+			<artifactId>spring-test</artifactId>
+			<scope>test</scope>
+		</dependency>
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>spring-boot</artifactId>
",False,"The commit message 'Add missing dependency' does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features. It simply states that a dependency was added, but it does not explain why this dependency was necessary or how it improves the project.",True,"The commit message 'Add missing dependency' does not provide a rationale for the change. It is easy to infer from the code diff that the 'spring-test' dependency was missing in the project's configuration, which is commonly used for testing Spring applications. Therefore, the commit message could have been more descriptive by mentioning the purpose of adding the dependency, such as 'Add missing spring-test dependency for testing'.",False,"The commit message 'Add missing dependency' does not explicitly describe the necessity of the changes. It only states what has been done, not why it was necessary. The code diff shows that a dependency has been replaced and another one has been added, but the commit message does not explain why these changes were made. For example, it could have mentioned a problem that arose due to the missing dependency or an issue report that prompted the change.",True,"The commit message 'Add missing dependency' indicates that a necessary change was made to the project. The code diff shows that a dependency for 'spring-test' was missing in the project's configuration, which could have caused runtime errors or failed tests. This suggests that the change was made to address a problem in the software development process, specifically to ensure that all necessary dependencies are included in the project.",False,"The commit message 'Add missing dependency' does not explicitly mention the defects it fixes or the improvements it makes to the code. It only states that a dependency was added, but it does not explain why this dependency was added or what problem it solves.",True,"The commit message 'Add missing dependency' does describe a summary of what changes by being a summary of the diffs. It accurately points out the key component of the change, which is the addition of a new dependency (spring-test) and the modification of an existing dependency (spring-jdbc). The message does not contrast the before and after explicitly, but the diff clearly shows the changes made to the dependencies.",False,"The commit message 'Add missing dependency' does not explicitly describe a technical principle underpinning the changes. It only states that a dependency was added, but it does not explain why this dependency was added or what problem it solves. The code diff shows that 'spring-test' dependency was removed and then added back, but the commit message does not explain why this was necessary.",False,"The commit message 'Add missing dependency' does not describe the changes made in the code diff from a functional perspective. It only mentions adding a dependency, but it does not explain what the new dependency is for or how it affects the behavior of the code. The code diff shows that the 'spring-test' dependency was removed and replaced with 'spring-jdbc' with an optional scope, and then 'spring-test' was added back. However, the commit message does not mention these changes or their implications.",True,"The commit message 'Add missing dependency' clearly explains the reason for the commit. The code diff shows that a dependency was added to the project. The change is not trivial as it involves modifying the project's build configuration. However, the reason for the change is clearly stated in the commit message, which is 'Add missing dependency'. The specific dependency and its changes are also mentioned in the diff, making it unnecessary to provide further explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/e370b592d66ad9b01ff2bfff4b5991f0ac3a9751,"Introduce defined extension point for modifying the environment  <enter> The commit introduces a new extension point, EnvironmentPostProcessor, that can be implemented by classes that want to modify the environment. Implementations of EnvironmentPostProcessor are loaded via spring.factories and called in response to the ApplicationEnvironmentPreparedEvent. Application listeners that wish to work with the post-processed environment can continue to listen to ApplicationEnvironmentPreparedEvent and order themselves to run after EnvironmentPostProcessingApplicationListener. <enter> Existing ApplicationListeners that modify the environment have, where possible, been updated to implement EnvironmentPostProcessor instead. <enter>  Closes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/e370b592d66ad9b01ff2bfff4b5991f0ac3a9751,"@@ -455,7 +455,7 @@ protected void configurePropertySources(ConfigurableEnvironment environment,
 	 * @param environment this application's environment
 	 * @param args arguments passed to the {@code run} method
 	 * @see #configureEnvironment(ConfigurableEnvironment, String[])
-	 * @see org.springframework.boot.context.config.ConfigFileApplicationListener
+	 * @see org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor
 	 */
 	protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {
 		environment.getActiveProfiles(); // ensure they are initialized
@@ -25,11 +25,11 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.springframework.boot.context.config.ConfigFileApplicationListener;
-import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor;
+import org.springframework.boot.env.EnvironmentPostProcessor;
 import org.springframework.boot.json.JsonParser;
 import org.springframework.boot.json.JsonParserFactory;
-import org.springframework.context.ApplicationListener;
 import org.springframework.core.Ordered;
 import org.springframework.core.env.CommandLinePropertySource;
 import org.springframework.core.env.ConfigurableEnvironment;
@@ -39,8 +39,8 @@
 import org.springframework.util.StringUtils;
 
 /**
- * An {@link ApplicationListener} that knows where to find VCAP (a.k.a. Cloud Foundry)
- * meta data in the existing environment. It parses out the VCAP_APPLICATION and
+ * An {@link EnvironmentPostProcessor} that knows where to find VCAP (a.k.a. Cloud
+ * Foundry) meta data in the existing environment. It parses out the VCAP_APPLICATION and
  * VCAP_SERVICES meta data and dumps it in a form that is easily consumed by
  * {@link Environment} users. If the app is running in Cloud Foundry then both meta data
  * items are JSON objects encoded in OS environment variables. VCAP_APPLICATION is a
@@ -86,18 +86,19 @@
  * Cloud is more convenient and more robust against potential changes in Cloud Foundry.
  *
  * @author Dave Syer
+ * @author Andy Wilkinson
  */
-public class VcapApplicationListener implements
-		ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {
+public class VcapEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
 
-	private static final Log logger = LogFactory.getLog(VcapApplicationListener.class);
+	private static final Log logger = LogFactory
+			.getLog(VcapEnvironmentPostProcessor.class);
 
 	private static final String VCAP_APPLICATION = ""VCAP_APPLICATION"";
 
 	private static final String VCAP_SERVICES = ""VCAP_SERVICES"";
 
 	// Before ConfigFileApplicationListener so values there can use these ones
-	private int order = ConfigFileApplicationListener.DEFAULT_ORDER - 1;
+	private int order = ConfigFileEnvironmentPostProcessor.DEFAULT_ORDER - 1;
 
 	private final JsonParser parser = JsonParserFactory.getJsonParser();
 
@@ -111,8 +112,8 @@ public int getOrder() {
 	}
 
 	@Override
-	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
-		ConfigurableEnvironment environment = event.getEnvironment();
+	public void postProcessEnvironment(ConfigurableEnvironment environment,
+			SpringApplication application) {
 		if (!environment.containsProperty(VCAP_APPLICATION)
 				&& !environment.containsProperty(VCAP_SERVICES)) {
 			return;
@@ -20,6 +20,7 @@
 import org.springframework.boot.ansi.AnsiOutput.Enabled;
 import org.springframework.boot.bind.RelaxedPropertyResolver;
 import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
+import org.springframework.boot.env.EnvironmentPostProcessingApplicationListener;
 import org.springframework.context.ApplicationListener;
 import org.springframework.core.Ordered;
 
@@ -51,8 +52,9 @@ public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
 
 	@Override
 	public int getOrder() {
-		// Apply after the ConfigFileApplicationListener
-		return ConfigFileApplicationListener.DEFAULT_ORDER + 1;
+		// Apply after the EnvironmentPostProcessingApplicationListener has called all
+		// EnvironmentPostProcessors
+		return EnvironmentPostProcessingApplicationListener.ORDER + 1;
 	}
 
 }
@@ -33,12 +33,11 @@
 import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.bind.PropertiesConfigurationFactory;
-import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
 import org.springframework.boot.context.event.ApplicationPreparedEvent;
 import org.springframework.boot.env.EnumerableCompositePropertySource;
+import org.springframework.boot.env.EnvironmentPostProcessor;
 import org.springframework.boot.env.PropertySourcesLoader;
 import org.springframework.boot.logging.DeferredLog;
-import org.springframework.context.ApplicationEvent;
 import org.springframework.context.ApplicationListener;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.context.annotation.ConfigurationClassPostProcessor;
@@ -47,7 +46,6 @@
 import org.springframework.core.convert.support.DefaultConversionService;
 import org.springframework.core.env.ConfigurableEnvironment;
 import org.springframework.core.env.EnumerablePropertySource;
-import org.springframework.core.env.Environment;
 import org.springframework.core.env.MutablePropertySources;
 import org.springframework.core.env.PropertySource;
 import org.springframework.core.io.DefaultResourceLoader;
@@ -59,7 +57,7 @@
 import org.springframework.validation.BindException;
 
 /**
- * {@link ApplicationListener} that configures the context environment by loading
+ * {@link EnvironmentPostProcessor} that configures the context environment by loading
  * properties from well known file locations. By default properties will be loaded from
  * 'application.properties' and/or 'application.yml' files in the following locations:
  * <ul>
@@ -89,9 +87,10 @@
  * @author Dave Syer
  * @author Phillip Webb
  * @author Stephane Nicoll
+ * @author Andy Wilkinson
  */
-public class ConfigFileApplicationListener implements
-		ApplicationListener<ApplicationEvent>, Ordered {
+public class ConfigFileEnvironmentPostProcessor implements EnvironmentPostProcessor,
+		ApplicationListener<ApplicationPreparedEvent>, Ordered {
 
 	private static final String DEFAULT_PROPERTIES = ""defaultProperties"";
 
@@ -121,34 +120,15 @@ public class ConfigFileApplicationListener implements
 	private final ConversionService conversionService = new DefaultConversionService();
 
 	@Override
-	public void onApplicationEvent(ApplicationEvent event) {
-		if (event instanceof ApplicationEnvironmentPreparedEvent) {
-			onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);
-		}
-		if (event instanceof ApplicationPreparedEvent) {
-			onApplicationPreparedEvent((ApplicationPreparedEvent) event);
-		}
-	}
-
-	private void onApplicationEnvironmentPreparedEvent(
-			ApplicationEnvironmentPreparedEvent event) {
-		Environment environment = event.getEnvironment();
-		if (environment instanceof ConfigurableEnvironment) {
-			onApplicationEnvironmentPreparedEvent((ConfigurableEnvironment) environment,
-					event.getSpringApplication());
-		}
-	}
-
-	private void onApplicationEnvironmentPreparedEvent(
-			ConfigurableEnvironment environment, SpringApplication application) {
+	public void postProcessEnvironment(ConfigurableEnvironment environment,
+			SpringApplication application) {
 		addPropertySources(environment, application.getResourceLoader());
 		bindToSpringApplication(environment, application);
 	}
 
-	private void onApplicationPreparedEvent(ApplicationPreparedEvent event) {
-		// logging is deferred because the Logging initialization might not have
-		// run at the time that config file decisions are taken
-		this.logger.replayTo(ConfigFileApplicationListener.class);
+	@Override
+	public void onApplicationEvent(ApplicationPreparedEvent event) {
+		this.logger.replayTo(ConfigFileEnvironmentPostProcessor.class);
 		addPostProcessors(event.getApplicationContext());
 	}
 
@@ -272,7 +252,7 @@ private void reorderSources(ConfigurableEnvironment environment) {
 	 */
 	private class Loader {
 
-		private final Log logger = ConfigFileApplicationListener.this.logger;
+		private final Log logger = ConfigFileEnvironmentPostProcessor.this.logger;
 
 		private final ConfigurableEnvironment environment;
 
@@ -472,7 +452,7 @@ private Set<String> getSearchLocations() {
 				}
 			}
 			locations.addAll(asResolvedSet(
-					ConfigFileApplicationListener.this.searchLocations,
+					ConfigFileEnvironmentPostProcessor.this.searchLocations,
 					DEFAULT_SEARCH_LOCATIONS));
 			return locations;
 		}
@@ -482,7 +462,8 @@ private Set<String> getSearchNames() {
 				return asResolvedSet(this.environment.getProperty(CONFIG_NAME_PROPERTY),
 						null);
 			}
-			return asResolvedSet(ConfigFileApplicationListener.this.names, DEFAULT_NAMES);
+			return asResolvedSet(ConfigFileEnvironmentPostProcessor.this.names,
+					DEFAULT_NAMES);
 		}
 
 		private Set<String> asResolvedSet(String value, String fallback) {
@@ -18,7 +18,7 @@
  * External configuration support allowing 'application.properties' to be loaded
  * and used within a Spring Boot application.
  *
- * @see org.springframework.boot.context.config.ConfigFileApplicationListener
+ * @see org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor
  */
 package org.springframework.boot.context.config;
 
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.env;
+
+import java.util.List;
+
+import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
+import org.springframework.context.ApplicationListener;
+import org.springframework.core.Ordered;
+import org.springframework.core.annotation.AnnotationAwareOrderComparator;
+import org.springframework.core.io.support.SpringFactoriesLoader;
+
+/**
+ * An {@link ApplicationListener} that responds to an
+ * {@link ApplicationEnvironmentPreparedEvent} and calls all
+ * {@link EnvironmentPostProcessor EnvironmentPostProcessors} that are available via
+ * {@code spring.factories}.
+ * <p>
+ * Post-processors are called in the order defined by
+ * {@link AnnotationAwareOrderComparator}.
+ *
+ * @author Andy Wilkinson
+ * @since 1.3.0
+ * @see SpringFactoriesLoader#loadFactories(Class, ClassLoader)
+ */
+public class EnvironmentPostProcessingApplicationListener implements
+		ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {
+
+	public static final int ORDER = Ordered.HIGHEST_PRECEDENCE + 10;
+
+	@Override
+	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
+		List<EnvironmentPostProcessor> postProcessors = SpringFactoriesLoader
+				.loadFactories(EnvironmentPostProcessor.class, getClass()
+						.getClassLoader());
+		for (EnvironmentPostProcessor postProcessor : postProcessors) {
+			postProcessor.postProcessEnvironment(event.getEnvironment(),
+					event.getSpringApplication());
+		}
+	}
+
+	@Override
+	public int getOrder() {
+		return ORDER;
+	}
+
+}
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2012-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.env;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.core.env.ConfigurableEnvironment;
+import org.springframework.core.env.Environment;
+
+/**
+ * Allows for customization of the application's {@link Environment} prior to the
+ * application context being refreshed.
+ *
+ * @author Andy Wilkinson
+ * @since 1.3.0
+ */
+public interface EnvironmentPostProcessor {
+
+	/**
+	 * Post-process the given {@code environment}
+	 *
+	 * @param environment the environment to post-process
+	 * @param application the application to which the environment belongs
+	 */
+	void postProcessEnvironment(ConfigurableEnvironment environment,
+			SpringApplication application);
+
+}
@@ -16,7 +16,7 @@
 
 package org.springframework.boot.test;
 
-import org.springframework.boot.context.config.ConfigFileApplicationListener;
+import org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor;
 import org.springframework.context.ApplicationContextInitializer;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.test.context.ContextConfiguration;
@@ -27,14 +27,14 @@
  * {@literal application.properties}.
  *
  * @author Phillip Webb
- * @see ConfigFileApplicationListener
+ * @see ConfigFileEnvironmentPostProcessor
  */
 public class ConfigFileApplicationContextInitializer implements
 		ApplicationContextInitializer<ConfigurableApplicationContext> {
 
 	@Override
 	public void initialize(final ConfigurableApplicationContext applicationContext) {
-		new ConfigFileApplicationListener() {
+		new ConfigFileEnvironmentPostProcessor() {
 			public void apply() {
 				addPropertySources(applicationContext.getEnvironment(),
 						applicationContext);
@@ -17,11 +17,16 @@ org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer
 # Application Listeners
 org.springframework.context.ApplicationListener=\
 org.springframework.boot.builder.ParentContextCloserApplicationListener,\
-org.springframework.boot.cloudfoundry.VcapApplicationListener,\
 org.springframework.boot.context.FileEncodingApplicationListener,\
 org.springframework.boot.context.config.AnsiOutputApplicationListener,\
-org.springframework.boot.context.config.ConfigFileApplicationListener,\
+org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor,\
 org.springframework.boot.context.config.DelegatingApplicationListener,\
+org.springframework.boot.env.EnvironmentPostProcessingApplicationListener,\
 org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\
 org.springframework.boot.logging.ClasspathLoggingApplicationListener,\
 org.springframework.boot.logging.LoggingApplicationListener
+
+# Environment Post Processors
+org.springframework.boot.env.EnvironmentPostProcessor=\
+org.springframework.boot.cloudfoundry.VcapEnvironmentPostProcessor,\
+org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor
\ No newline at end of file
@@ -17,8 +17,6 @@
 package org.springframework.boot.cloudfoundry;
 
 import org.junit.Test;
-import org.springframework.boot.SpringApplication;
-import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
 import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
@@ -27,19 +25,17 @@
 import static org.junit.Assert.assertNull;
 
 /**
- * Tests for {@link VcapApplicationListener}.
+ * Tests for {@link VcapEnvironmentPostProcessor}.
  *
  * @author Dave Syer
+ * @author Andy Wilkinson
  */
-public class VcapApplicationListenerTests {
+public class VcapEnvironmentPostProcessorTests {
 
-	private final VcapApplicationListener initializer = new VcapApplicationListener();
+	private final VcapEnvironmentPostProcessor initializer = new VcapEnvironmentPostProcessor();
 
 	private final ConfigurableApplicationContext context = new AnnotationConfigApplicationContext();
 
-	private final ApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(
-			new SpringApplication(), new String[0], this.context.getEnvironment());
-
 	@Test
 	public void testApplicationProperties() {
 		EnvironmentTestUtils
@@ -57,7 +53,7 @@ public void testApplicationProperties() {
 								+ ""\""name\"":\""dsyerenv\"",\""uris\"":[\""dsyerenv.cfapps.io\""],""
 								+ ""\""users\"":[],\""start\"":\""2013-05-29 02:37:59 +0000\"",""
 								+ ""\""state_timestamp\"":1369795079}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertEquals(""bb7935245adf3e650dfb7c58a06e9ece"", this.context.getEnvironment()
 				.getProperty(""vcap.application.instance_id""));
 	}
@@ -68,15 +64,15 @@ public void testApplicationUris() {
 				.addEnvironment(
 						this.context,
 						""VCAP_APPLICATION:{\""instance_id\"":\""bb7935245adf3e650dfb7c58a06e9ece\"",\""instance_index\"":0,\""uris\"":[\""foo.cfapps.io\""]}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertEquals(""foo.cfapps.io"",
 				this.context.getEnvironment().getProperty(""vcap.application.uris[0]""));
 	}
 
 	@Test
 	public void testUnparseableApplicationProperties() {
 		EnvironmentTestUtils.addEnvironment(this.context, ""VCAP_APPLICATION:"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertNull(getProperty(""vcap""));
 	}
 
@@ -97,7 +93,7 @@ public void testNullApplicationProperties() {
 								+ ""\""name\"":\""dsyerenv\"",\""uris\"":[\""dsyerenv.cfapps.io\""],""
 								+ ""\""users\"":[],\""start\"":\""2013-05-29 02:37:59 +0000\"",""
 								+ ""\""state_timestamp\"":1369795079}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertNull(getProperty(""vcap""));
 	}
 
@@ -115,7 +111,7 @@ public void testServiceProperties() {
 								+ ""\""host\"":\""mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\"",""
 								+ ""\""port\"":3306,\""user\"":\""urpRuqTf8Cpe6\"",\""username\"":""
 								+ ""\""urpRuqTf8Cpe6\"",\""password\"":\""pxLsGVpsC9A5S\""}}]}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertEquals(""mysql"", getProperty(""vcap.services.mysql.name""));
 		assertEquals(""3306"", getProperty(""vcap.services.mysql.credentials.port""));
 		assertEquals(""true"", getProperty(""vcap.services.mysql.credentials.ssl""));
@@ -135,7 +131,7 @@ public void testServicePropertiesWithoutNA() {
 								+ ""\""port\"":3306,\""user\"":\""urpRuqTf8Cpe6\"",""
 								+ ""\""username\"":\""urpRuqTf8Cpe6\"",""
 								+ ""\""password\"":\""pxLsGVpsC9A5S\""}}]}"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
 		assertEquals(""mysql"", getProperty(""vcap.services.mysql.name""));
 		assertEquals(""3306"", getProperty(""vcap.services.mysql.credentials.port""));
 	}
@@ -35,8 +35,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.springframework.boot.SpringApplication;
-import org.springframework.boot.context.config.ConfigFileApplicationListener.ConfigurationPropertySources;
-import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
+import org.springframework.boot.context.config.ConfigFileEnvironmentPostProcessor.ConfigurationPropertySources;
 import org.springframework.boot.env.EnumerableCompositePropertySource;
 import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.ConfigurableApplicationContext;
@@ -63,19 +62,18 @@
 import static org.junit.Assert.assertThat;
 
 /**
- * Tests for {@link ConfigFileApplicationListener}.
+ * Tests for {@link ConfigFileEnvironmentPostProcessor}.
  *
  * @author Phillip Webb
  * @author Dave Syer
  */
-public class ConfigFileApplicationListenerTests {
+public class ConfigFileEnvironmentPostProcessorTests {
 
 	private final StandardEnvironment environment = new StandardEnvironment();
 
-	private final ApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(
-			new SpringApplication(), new String[0], this.environment);
+	private final SpringApplication application = new SpringApplication();
 
-	private final ConfigFileApplicationListener initializer = new ConfigFileApplicationListener();
+	private final ConfigFileEnvironmentPostProcessor initializer = new ConfigFileEnvironmentPostProcessor();
 
 	@Rule
 	public ExpectedException expected = ExpectedException.none();
@@ -89,7 +87,7 @@ public void cleanup() {
 
 	@Test
 	public void loadCustomResource() throws Exception {
-		this.event.getSpringApplication().setResourceLoader(new ResourceLoader() {
+		this.application.setResourceLoader(new ResourceLoader() {
 			@Override
 			public Resource getResource(final String location) {
 				if (location.equals(""classpath:/custom.properties"")) {
@@ -110,15 +108,15 @@ public ClassLoader getClassLoader() {
 			}
 		});
 		this.initializer.setSearchNames(""custom"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromcustom""));
 	}
 
 	@Test
 	public void loadPropertiesFile() throws Exception {
 		this.initializer.setSearchNames(""testproperties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""frompropertiesfile""));
 	}
@@ -127,7 +125,7 @@ public void loadPropertiesFile() throws Exception {
 	public void loadDefaultPropertiesFile() throws Exception {
 		this.environment.setDefaultProfiles(""thedefault"");
 		this.initializer.setSearchNames(""testprofiles"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromdefaultpropertiesfile""));
 	}
@@ -136,7 +134,7 @@ public void loadDefaultPropertiesFile() throws Exception {
 	public void loadTwoPropertiesFile() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ ""classpath:application.properties,classpath:testproperties.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""frompropertiesfile""));
 	}
@@ -145,7 +143,7 @@ public void loadTwoPropertiesFile() throws Exception {
 	public void loadTwoPropertiesFilesWithProfiles() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ ""classpath:enableprofile.properties,classpath:enableother.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertEquals(""other"", StringUtils.arrayToCommaDelimitedString(this.environment
 				.getActiveProfiles()));
 		String property = this.environment.getProperty(""my.property"");
@@ -157,7 +155,7 @@ public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() throws Exception
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ ""classpath:enabletwoprofiles.properties,""
 				+ ""classpath:enableprofile.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertEquals(""myprofile"",
 				StringUtils.arrayToCommaDelimitedString(this.environment
 						.getActiveProfiles()));
@@ -173,7 +171,7 @@ public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOffFromSpecificLocatio
 		EnvironmentTestUtils.addEnvironment(this.environment,
 				""spring.config.name:enabletwoprofiles"",
 				""spring.config.location:classpath:enableprofile.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertEquals(""myprofile"",
 				StringUtils.arrayToCommaDelimitedString(this.environment
 						.getActiveProfiles()));
@@ -197,7 +195,7 @@ public void localFileTakesPrecedenceOverClasspath() throws Exception {
 			finally {
 				out.close();
 			}
-			this.initializer.onApplicationEvent(this.event);
+			this.initializer.postProcessEnvironment(this.environment, this.application);
 			String property = this.environment.getProperty(""the.property"");
 			assertThat(property, equalTo(""fromlocalfile""));
 		}
@@ -210,7 +208,7 @@ public void localFileTakesPrecedenceOverClasspath() throws Exception {
 	public void moreSpecificLocationTakesPrecedenceOverRoot() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment,
 				""spring.config.name:specific"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""specific""));
 	}
@@ -221,22 +219,22 @@ public void loadTwoOfThreePropertiesFile() throws Exception {
 				+ ""classpath:application.properties,""
 				+ ""classpath:testproperties.properties,""
 				+ ""classpath:nonexistent.properties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""frompropertiesfile""));
 	}
 
 	@Test
 	public void randomValue() throws Exception {
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""random.value"");
 		assertThat(property, notNullValue());
 	}
 
 	@Test
 	public void loadTwoPropertiesFiles() throws Exception {
 		this.initializer.setSearchNames(""moreproperties,testproperties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		// The search order has highest precedence last (like merging a map)
 		assertThat(property, equalTo(""frompropertiesfile""));
@@ -245,7 +243,7 @@ public void loadTwoPropertiesFiles() throws Exception {
 	@Test
 	public void loadYamlFile() throws Exception {
 		this.initializer.setSearchNames(""testyaml"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromyamlfile""));
 		assertThat(this.environment.getProperty(""my.array[0]""), equalTo(""1""));
@@ -255,7 +253,7 @@ public void loadYamlFile() throws Exception {
 	@Test
 	public void loadProfileEmptySameAsNotSpecified() throws Exception {
 		this.initializer.setSearchNames(""testprofilesempty"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromemptyprofile""));
 	}
@@ -264,7 +262,7 @@ public void loadProfileEmptySameAsNotSpecified() throws Exception {
 	public void loadDefaultYamlDocument() throws Exception {
 		this.environment.setDefaultProfiles(""thedefault"");
 		this.initializer.setSearchNames(""testprofilesdocument"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromdefaultprofile""));
 	}
@@ -274,7 +272,7 @@ public void loadDefaultYamlDocumentNotActivated() throws Exception {
 		this.environment.setDefaultProfiles(""thedefault"");
 		this.environment.setActiveProfiles(""other"");
 		this.initializer.setSearchNames(""testprofilesdocument"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromotherprofile""));
 	}
@@ -284,7 +282,7 @@ public void commandLineWins() throws Exception {
 		this.environment.getPropertySources().addFirst(
 				new SimpleCommandLinePropertySource(""--the.property=fromcommandline""));
 		this.initializer.setSearchNames(""testproperties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromcommandline""));
 	}
@@ -293,34 +291,27 @@ public void commandLineWins() throws Exception {
 	public void systemPropertyWins() throws Exception {
 		System.setProperty(""the.property"", ""fromsystem"");
 		this.initializer.setSearchNames(""testproperties"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromsystem""));
 	}
 
 	@Test
 	public void defaultPropertyAsFallback() throws Exception {
-		this.event
-				.getEnvironment()
-				.getPropertySources()
-				.addLast(
-						new MapPropertySource(""defaultProperties"", Collections
-								.singletonMap(""my.fallback"", (Object) ""foo"")));
-		this.initializer.onApplicationEvent(this.event);
+		this.environment.getPropertySources().addLast(
+				new MapPropertySource(""defaultProperties"", Collections.singletonMap(
+						""my.fallback"", (Object) ""foo"")));
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.fallback"");
 		assertThat(property, equalTo(""foo""));
 	}
 
 	@Test
 	public void defaultPropertyAsFallbackDuringFileParsing() throws Exception {
-		this.event
-				.getEnvironment()
-				.getPropertySources()
-				.addLast(
-						new MapPropertySource(""defaultProperties"", Collections
-								.singletonMap(""spring.config.name"",
-										(Object) ""testproperties"")));
-		this.initializer.onApplicationEvent(this.event);
+		this.environment.getPropertySources().addLast(
+				new MapPropertySource(""defaultProperties"", Collections.singletonMap(
+						""spring.config.name"", (Object) ""testproperties"")));
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""frompropertiesfile""));
 	}
@@ -331,7 +322,7 @@ public void loadPropertiesThenProfilePropertiesActivatedInSpringApplication()
 		// This should be the effect of calling
 		// SpringApplication.setAdditionalProfiles(""other"")
 		this.environment.setActiveProfiles(""other"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		// The ""other"" profile is activated in SpringApplication so it should take
 		// precedence over the default profile
@@ -343,7 +334,7 @@ public void twoProfilesFromProperties() throws Exception {
 		// This should be the effect of calling
 		// SpringApplication.setAdditionalProfiles(""other"", ""dev"")
 		this.environment.setActiveProfiles(""other"", ""dev"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		// The ""dev"" profile is activated in SpringApplication so it should take
 		// precedence over the default profile
@@ -353,7 +344,7 @@ public void twoProfilesFromProperties() throws Exception {
 	@Test
 	public void loadPropertiesThenProfilePropertiesActivatedInFirst() throws Exception {
 		this.initializer.setSearchNames(""enableprofile"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		// The ""myprofile"" profile is activated in enableprofile.properties so its value
 		// should show up here
@@ -366,7 +357,7 @@ public void loadPropertiesThenProfilePropertiesWithOverride() throws Exception {
 		// EnvironmentTestUtils.addEnvironment(this.environment,
 		// ""spring.profiles.active:other"");
 		this.initializer.setSearchNames(""enableprofile"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""other.property"");
 		// The ""other"" profile is activated before any processing starts
 		assertThat(property, equalTo(""fromotherpropertiesfile""));
@@ -380,7 +371,7 @@ public void loadPropertiesThenProfilePropertiesWithOverride() throws Exception {
 	@Test
 	public void profilePropertiesUsedInPlaceholders() throws Exception {
 		this.initializer.setSearchNames(""enableprofile"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""one.more"");
 		assertThat(property, equalTo(""fromprofilepropertiesfile""));
 	}
@@ -389,7 +380,7 @@ public void profilePropertiesUsedInPlaceholders() throws Exception {
 	public void yamlProfiles() throws Exception {
 		this.initializer.setSearchNames(""testprofiles"");
 		this.environment.setActiveProfiles(""dev"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromdevprofile""));
 		property = this.environment.getProperty(""my.other"");
@@ -400,7 +391,7 @@ public void yamlProfiles() throws Exception {
 	public void yamlTwoProfiles() throws Exception {
 		this.initializer.setSearchNames(""testprofiles"");
 		this.environment.setActiveProfiles(""other"", ""dev"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromdevprofile""));
 		property = this.environment.getProperty(""my.other"");
@@ -410,7 +401,7 @@ public void yamlTwoProfiles() throws Exception {
 	@Test
 	public void yamlSetsProfiles() throws Exception {
 		this.initializer.setSearchNames(""testsetprofiles"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertEquals(""dev"", StringUtils.arrayToCommaDelimitedString(this.environment
 				.getActiveProfiles()));
 		String property = this.environment.getProperty(""my.property"");
@@ -444,7 +435,7 @@ public void yamlProfileCanBeChanged() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment,
 				""spring.profiles.active:prod"");
 		this.initializer.setSearchNames(""testsetprofiles"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertThat(this.environment.getActiveProfiles(), equalTo(new String[] { ""prod"" }));
 	}
 
@@ -453,7 +444,7 @@ public void specificNameAndProfileFromExistingSource() throws Exception {
 		EnvironmentTestUtils.addEnvironment(this.environment,
 				""spring.profiles.active=specificprofile"",
 				""spring.config.name=specificfile"");
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""my.property"");
 		assertThat(property, equalTo(""fromspecificpropertiesfile""));
 	}
@@ -463,7 +454,7 @@ public void specificResource() throws Exception {
 		String location = ""classpath:specificlocation.properties"";
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ location);
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		String property = this.environment.getProperty(""the.property"");
 		assertThat(property, equalTo(""fromspecificlocation""));
 		assertThat(this.environment, containsPropertySource(""applicationConfig: ""
@@ -479,7 +470,7 @@ public void specificResourceAsFile() throws Exception {
 		String location = ""file:src/test/resources/specificlocation.properties"";
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ location);
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertThat(this.environment, containsPropertySource(""applicationConfig: [""
 				+ location + ""]""));
 	}
@@ -489,7 +480,7 @@ public void specificResourceDefaultsToFile() throws Exception {
 		String location = ""src/test/resources/specificlocation.properties"";
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ location);
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertThat(this.environment, containsPropertySource(""applicationConfig: [file:""
 				+ location + ""]""));
 	}
@@ -500,7 +491,7 @@ public void absoluteResourceDefaultsToFile() throws Exception {
 				.getAbsolutePath();
 		EnvironmentTestUtils.addEnvironment(this.environment, ""spring.config.location:""
 				+ location);
-		this.initializer.onApplicationEvent(this.event);
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		assertThat(this.environment, containsPropertySource(""applicationConfig: [file:""
 				+ location.replace(File.separatorChar, '/') + ""]""));
 	}
@@ -633,22 +624,20 @@ public void profileSubDocumentInProfileSpecificFile() throws Exception {
 	public void bindsToSpringApplication() throws Exception {
 		// gh-346
 		this.initializer.setSearchNames(""bindtoapplication"");
-		this.initializer.onApplicationEvent(this.event);
-		SpringApplication application = this.event.getSpringApplication();
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		Field field = ReflectionUtils.findField(SpringApplication.class, ""showBanner"");
 		field.setAccessible(true);
-		assertThat((Boolean) field.get(application), equalTo(false));
+		assertThat((Boolean) field.get(this.application), equalTo(false));
 	}
 
 	@Test
 	public void bindsSystemPropertyToSpringApplication() throws Exception {
 		// gh-951
 		System.setProperty(""spring.main.showBanner"", ""false"");
-		this.initializer.onApplicationEvent(this.event);
-		SpringApplication application = this.event.getSpringApplication();
+		this.initializer.postProcessEnvironment(this.environment, this.application);
 		Field field = ReflectionUtils.findField(SpringApplication.class, ""showBanner"");
 		field.setAccessible(true);
-		assertThat((Boolean) field.get(application), equalTo(false));
+		assertThat((Boolean) field.get(this.application), equalTo(false));
 	}
 
 	private static Matcher<? super ConfigurableEnvironment> containsPropertySource(
",True,"The commit message refers to the introduction of a new extension point, EnvironmentPostProcessor, which allows classes to modify the environment. This is a clear reference to a convention or standard within the project, as it allows for customization and extension of the application's environment.",True,"The commit message refers to the introduction of a new extension point, EnvironmentPostProcessor, which allows classes to modify the environment. This is a significant change that requires additional configuration and could potentially break existing code. The message does not explicitly state the reason for the change, but it is likely that the change is necessary to support new features or to improve the flexibility and extensibility of the application.",True,"The commit message explains that the commit introduces a new extension point, EnvironmentPostProcessor, that can be implemented by classes that want to modify the environment. This extension point allows for customization of the application's environment prior to the application context being refreshed. This is a clear and direct explanation of the necessity of the changes and the motivation behind them.",True,"The commit message mentions the introduction of a new extension point, EnvironmentPostProcessor, which allows classes to modify the environment. This indicates that the changes are being made to accommodate new requirements or to address issues in the software development process, such as the need to customize the environment.",True,"The commit message mentions the introduction of a new extension point, EnvironmentPostProcessor, which allows classes to modify the environment. This directly describes the objective of the change, which is to enable customization of the application's environment.",True,"The commit message describes the introduction of a new extension point, EnvironmentPostProcessor, which allows classes to modify the environment. This is a clear summary of the changes made in the code diff, as the diff shows the addition of this new extension point and the modification of existing classes to implement it.",True,"The commit message explains that the new extension point, EnvironmentPostProcessor, allows classes to modify the environment. This is a clear expression of the technical principle underpinning the changes, which is the ability to customize and extend the application's environment.",True,"The commit message describes the introduction of a new extension point, EnvironmentPostProcessor, which allows classes to modify the environment. This is done by implementing the EnvironmentPostProcessor interface and loading the implementations via spring.factories. The commit also mentions that existing ApplicationListeners that modify the environment have been updated to implement EnvironmentPostProcessor instead. This indicates that the new extension point is being used to provide a more flexible and extensible way to modify the environment.",False,"The commit message does a good job of explaining the reason for the commit. It introduces a new extension point, EnvironmentPostProcessor, that allows classes to modify the environment. This is a significant change that justifies the need for a clear commit message."
https://github.com/apache/dubbo/commit/b0064d78a3b929eb3b25e0de9055412cb61f48ce,Make code of process callback of method cleaner in DubboBeanDefinitionParser ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/b0064d78a3b929eb3b25e0de9055412cb61f48ce,"@@ -62,6 +62,10 @@ public class DubboBeanDefinitionParser implements BeanDefinitionParser {
 
     private static final Logger logger = LoggerFactory.getLogger(DubboBeanDefinitionParser.class);
     private static final Pattern GROUP_AND_VERION = Pattern.compile(""^[\\-.0-9_a-zA-Z]+(\\:[\\-.0-9_a-zA-Z]+)?$"");
+    private static final String ONRETURN = ""onreturn"";
+    private static final String ONTHROW = ""onthrow"";
+    private static final String ONINVOKE = ""oninvoke"";
+    private static final String METHOD = ""Method"";
     private final Class<?> beanClass;
     private final boolean required;
 
@@ -190,24 +194,12 @@ private static BeanDefinition parse(Element element, ParserContext parserContext
                                         value = null;
                                     }
                                     reference = value;
-                                } else if (""onreturn"".equals(property)) {
+                                } else if(ONRETURN.equals(property) || ONTHROW.equals(property) || ONINVOKE.equals(property)) {
                                     int index = value.lastIndexOf(""."");
-                                    String returnRef = value.substring(0, index);
-                                    String returnMethod = value.substring(index + 1);
-                                    reference = new RuntimeBeanReference(returnRef);
-                                    beanDefinition.getPropertyValues().addPropertyValue(""onreturnMethod"", returnMethod);
-                                } else if (""onthrow"".equals(property)) {
-                                    int index = value.lastIndexOf(""."");
-                                    String throwRef = value.substring(0, index);
-                                    String throwMethod = value.substring(index + 1);
-                                    reference = new RuntimeBeanReference(throwRef);
-                                    beanDefinition.getPropertyValues().addPropertyValue(""onthrowMethod"", throwMethod);
-                                } else if (""oninvoke"".equals(property)) {
-                                    int index = value.lastIndexOf(""."");
-                                    String invokeRef = value.substring(0, index);
-                                    String invokeRefMethod = value.substring(index + 1);
-                                    reference = new RuntimeBeanReference(invokeRef);
-                                    beanDefinition.getPropertyValues().addPropertyValue(""oninvokeMethod"", invokeRefMethod);
+                                    String ref = value.substring(0, index);
+                                    String method = value.substring(index + 1);
+                                    reference = new RuntimeBeanReference(ref);
+                                    beanDefinition.getPropertyValues().addPropertyValue(property + METHOD, method);
                                 } else {
                                     if (""ref"".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {
                                         BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);
",True,"The commit message 'Make code of process callback of method cleaner in DubboBeanDefinitionParser' does contain an expression that describes the necessity of changes. The changes made in the code diff are to refactor and simplify the code that handles the 'onreturn', 'onthrow', and 'oninvoke' properties. By introducing constants for these property names and refactoring the code to use these constants, the commit message is describing an improvement in the codebase, specifically making it cleaner and more maintainable.",True,"The commit message 'Make code of process callback of method cleaner in DubboBeanDefinitionParser' does not explicitly state the reason for the changes, but the code diff suggests that the changes are made to refactor and simplify the code. Specifically, the commit introduces constants for 'onreturn', 'onthrow', and 'oninvoke' properties, which were previously hardcoded as strings. This simplifies the code and makes it easier to understand and maintain. Additionally, the code diff shows that the commit consolidates the logic for handling 'onreturn', 'onthrow', and 'oninvoke' properties into a single block of code, which further simplifies the code and reduces redundancy. Therefore, the commit message can be considered to contain an expression that describes the necessity of changes, as it is common sense that refactoring code to make it cleaner and easier to understand and maintain is a good practice.",False,"The commit message does not explicitly describe the necessity of changes or the motivation behind the code change. It only mentions making the code cleaner, but it does not elaborate on any specific errors, issues, or shortcomings in the previous implementation that the changes are addressing.",True,"The commit message 'Make code of process callback of method cleaner in DubboBeanDefinitionParser' does not explicitly state the source of the requirements or the problem that necessitated the changes. However, the code diff suggests that the changes were made to simplify and optimize the code, which could indicate that the existing code was complex or difficult to understand, possibly due to outdated or inefficient code.",True,"The commit message 'Make code of process callback of method cleaner in DubboBeanDefinitionParser' does contain an expression that describes the objective of the change. Specifically, it mentions that the change is to make the code 'cleaner', which could imply that the change is intended to improve the readability, maintainability, or efficiency of the code. The code diff also supports this interpretation, as it simplifies the handling of 'onreturn', 'onthrow', and 'oninvoke' properties by consolidating similar logic into a single block of code.",True,"The commit message 'Make code of process callback of method cleaner in DubboBeanDefinitionParser' does describe a summary of the changes made in the code diff. The changes in the diff involve simplifying the code for processing callback methods such as 'onreturn', 'onthrow', and 'oninvoke'. The commit message highlights this by mentioning the 'process callback of method' and the 'cleaner' code. Additionally, the message does not explicitly mention the renaming of any methods, so it does not contrast the before and after in that sense.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on making the code cleaner, but it does not explain why the changes were made in the way they were, such as improving performance, security, or maintainability.",True,"The commit message 'Make code of process callback of method cleaner in DubboBeanDefinitionParser' does describe the changes made to the code. The code diff shows that several hardcoded strings ('onreturn', 'onthrow', 'oninvoke') have been replaced with constants, which makes the code cleaner and more maintainable. Additionally, the changes introduce a new behavior where the 'onreturn', 'onthrow', and 'oninvoke' properties can be handled in a more generic way, which is described in the code diff as well.",False,"The commit message does not explicitly state the reason for the change, but the code diff shows that the commit is refactoring the code to make it cleaner and more efficient. The changes involve replacing hardcoded strings with constants and simplifying the if-else conditions. While the reason for the change can be inferred from the diff, the commit message could have been more explicit about the refactoring to improve code readability and maintainability."
https://github.com/square/retrofit/commit/7e31520f844b5c8eedc3b8fe82e2e48c79e47a5a,Get rid of the now-useless HttpServiceMethod.Builder  <enter> A simple static factory will do. ,https://api.github.com/repos/square/retrofit/commits/7e31520f844b5c8eedc3b8fe82e2e48c79e47a5a,"@@ -25,79 +25,69 @@
 
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
-  private final RequestFactory requestFactory;
-  private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<ResponseT, ReturnT> callAdapter;
-  private final Converter<ResponseBody, ResponseT> responseConverter;
-
-  HttpServiceMethod(Builder<ResponseT, ReturnT> builder) {
-    requestFactory = builder.requestFactory;
-    callFactory = builder.retrofit.callFactory();
-    callAdapter = builder.callAdapter;
-    responseConverter = builder.responseConverter;
-  }
-
-  @Override ReturnT invoke(@Nullable Object[] args) {
-    return callAdapter.adapt(
-        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
-  }
-
   /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
+   * Inspects the annotations on an interface method to construct a reusable service method that
+   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
+   * method only once and reuse it.
    */
-  static final class Builder<ResponseT, ReturnT> {
-    final Retrofit retrofit;
-    final Method method;
-
-    RequestFactory requestFactory;
-    Type responseType;
-    Converter<ResponseBody, ResponseT> responseConverter;
-    CallAdapter<ResponseT, ReturnT> callAdapter;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
+  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
+      Retrofit retrofit, Method method, RequestFactory requestFactory) {
+    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);
+    Type responseType = callAdapter.responseType();
+    if (responseType == Response.class || responseType == okhttp3.Response.class) {
+      throw methodError(method, ""'""
+          + Utils.getRawType(responseType).getName()
+          + ""' is not a valid response body type. Did you mean ResponseBody?"");
+    }
+    if (requestFactory.httpMethod.equals(""HEAD"") && !Void.class.equals(responseType)) {
+      throw methodError(method, ""HEAD method must use Void as response type."");
     }
 
-    HttpServiceMethod<ResponseT, ReturnT> build() {
-      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
-
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError(method, ""'""
-            + Utils.getRawType(responseType).getName()
-            + ""' is not a valid response body type. Did you mean ResponseBody?"");
-      }
-      responseConverter = createResponseConverter();
+    Converter<ResponseBody, ResponseT> responseConverter =
+        createResponseConverter(retrofit, method, responseType);
 
-      if (requestFactory.httpMethod.equals(""HEAD"") && !Void.class.equals(responseType)) {
-        throw methodError(method, ""HEAD method must use Void as response type."");
-      }
+    okhttp3.Call.Factory callFactory = retrofit.callFactory;
+    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);
+  }
 
-      return new HttpServiceMethod<>(this);
+  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
+      Retrofit retrofit, Method method) {
+    Type returnType = method.getGenericReturnType();
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      //noinspection unchecked
+      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, ""Unable to create call adapter for %s"", returnType);
     }
+  }
 
-    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(method, e, ""Unable to create call adapter for %s"", returnType);
-      }
+  private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
+      Retrofit retrofit, Method method, Type responseType) {
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.responseBodyConverter(responseType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, ""Unable to create converter for %s"", responseType);
     }
+  }
 
-    private Converter<ResponseBody, ResponseT> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(method, e, ""Unable to create converter for %s"", responseType);
-      }
-    }
+  private final RequestFactory requestFactory;
+  private final okhttp3.Call.Factory callFactory;
+  private final CallAdapter<ResponseT, ReturnT> callAdapter;
+  private final Converter<ResponseBody, ResponseT> responseConverter;
+
+  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+      CallAdapter<ResponseT, ReturnT> callAdapter,
+      Converter<ResponseBody, ResponseT> responseConverter) {
+    this.requestFactory = requestFactory;
+    this.callFactory = callFactory;
+    this.callAdapter = callAdapter;
+    this.responseConverter = responseConverter;
+  }
+
+  @Override ReturnT invoke(@Nullable Object[] args) {
+    return callAdapter.adapt(
+        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
   }
 }
@@ -23,6 +23,8 @@
 
 abstract class ServiceMethod<T> {
   static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
     Type returnType = method.getGenericReturnType();
     if (Utils.hasUnresolvableType(returnType)) {
       throw methodError(method,
@@ -32,7 +34,7 @@ static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
       throw methodError(method, ""Service methods cannot return void."");
     }
 
-    return new HttpServiceMethod.Builder<Object, T>(retrofit, method).build();
+    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
   }
 
   abstract T invoke(@Nullable Object[] args);
",True,"The commit message refers to the necessity of changes by mentioning that the now-useless HttpServiceMethod.Builder is being removed and a simple static factory will be used instead. This is done to improve the codebase and make it more efficient. The code diff also supports this explanation, as it shows the removal of the HttpServiceMethod.Builder class and the replacement with a static factory method.",True,"The commit message 'Get rid of the now-useless HttpServiceMethod.Builder' clearly explains the necessity of changes. The message refers to the Builder class, which is no longer needed because a simple static factory will be used instead. This is a common refactoring to simplify code and improve performance, and the message makes it clear that this change is being made for that reason.",True,The commit message explains the motivation for the change by stating that the now-useless HttpServiceMethod.Builder is being removed and a simple static factory will be used instead. This is likely due to the simplification and efficiency gained from using a static factory method. The code diff also supports this explanation by showing the removal of the Builder class and the use of a static factory method in its place.,True,"The commit message 'Get rid of the now-useless HttpServiceMethod.Builder. A simple static factory will do.' indicates that the developer is removing the Builder class from HttpServiceMethod because it is no longer necessary. This could be due to a change in the requirements or design of the software, which might have made the Builder class redundant. This could also be a result of refactoring to simplify the codebase, which is a common practice in software maintenance to improve maintainability and readability.",True,The commit message 'Get rid of the now-useless HttpServiceMethod.Builder. A simple static factory will do.' directly mentions the objective of the change by stating that the Builder class is now useless and will be replaced with a simple static factory. This change is likely to simplify the code and improve its maintainability.,True,The commit message 'Get rid of the now-useless HttpServiceMethod.Builder. A simple static factory will do.' accurately summarizes the change in the code diff. It points out that the Builder class is being removed and replaced with a static factory method. This is a clear and concise summary of the changes made in the code.,True,"The commit message explains that the changes are being made to simplify the code by getting rid of the HttpServiceMethod.Builder class and replacing it with a static factory method. This is based on the principle of 'Simplicity' or 'KISS' (Keep It Simple, Stupid), which suggests that simpler solutions are often better than more complex ones, as long as they meet the requirements.",True,"The commit message 'Get rid of the now-useless HttpServiceMethod.Builder' describes the removal of a builder class that was used to create HttpServiceMethod instances. This change simplifies the code by replacing the builder with a static factory method. The code diff supports this explanation by showing the removal of the builder class and the addition of a static factory method. The static factory method 'parseAnnotations' constructs a reusable service method that speaks HTTP, which is a new behavior introduced by the changes.",True,"The commit message 'Get rid of the now-useless HttpServiceMethod.Builder' clearly explains the reason for the change. The code diff shows that the HttpServiceMethod.Builder class has been removed and replaced with a static factory method in the HttpServiceMethod class. This change simplifies the code and makes it easier to understand, so there was no need for an additional explanation in the commit message."
https://github.com/junit-team/junit4/commit/0733bbffdadf05a6ebe0c38942904071a4060af4,<pr_link> Fix many warnings (Eclipse 4.2/Juno based)  <enter> - Enh: add new 'staticondemandthreshold' setting to eclipse project jdt.ui preference settings file (although this is in fact not related to kcooney's import ordering change comment) ,https://api.github.com/repos/junit-team/junit4/commits/0733bbffdadf05a6ebe0c38942904071a4060af4,"@@ -1,13 +1,13 @@
-#Tue Jul 22 09:31:38 PDT 2008
-eclipse.preferences.version=1
-formatter_profile=_junit
-formatter_settings_version=11
-internal.default.compliance=default
-org.eclipse.jdt.ui.exception.name=e
-org.eclipse.jdt.ui.gettersetter.use.is=true
-org.eclipse.jdt.ui.ignorelowercasenames=true
-org.eclipse.jdt.ui.importorder=java;javax;com;
-org.eclipse.jdt.ui.keywordthis=false
-org.eclipse.jdt.ui.ondemandthreshold=99
-org.eclipse.jdt.ui.overrideannotation=true
-org.eclipse.jdt.ui.text.custom_code_templates=<?xml version\=""1.0"" encoding\=""UTF-8"" standalone\=""no""?><templates/>
+eclipse.preferences.version=1
+formatter_profile=_junit
+formatter_settings_version=12
+internal.default.compliance=default
+org.eclipse.jdt.ui.exception.name=e
+org.eclipse.jdt.ui.gettersetter.use.is=true
+org.eclipse.jdt.ui.ignorelowercasenames=true
+org.eclipse.jdt.ui.importorder=java;javax;com;
+org.eclipse.jdt.ui.keywordthis=false
+org.eclipse.jdt.ui.ondemandthreshold=99
+org.eclipse.jdt.ui.overrideannotation=true
+org.eclipse.jdt.ui.staticondemandthreshold=99
+org.eclipse.jdt.ui.text.custom_code_templates=<?xml version\=""1.0"" encoding\=""UTF-8"" standalone\=""no""?><templates/>
",True,"The commit message refers to the addition of a new setting 'staticondemandthreshold' to the eclipse project jdt.ui preference settings file. This change is not directly related to the import ordering change mentioned in a prior commit, but it does indicate an enhancement to the project's configuration options, which could potentially improve functionality or usability.",True,"The commit message mentions 'Fix many warnings' which is a common reason for changes. Additionally, the diff shows that a new setting 'staticondemandthreshold' is added to the eclipse project jdt.ui preference settings file. This change is not directly related to the import ordering change mentioned in the commit message, but it is a common practice to fix warnings and improve settings in the development environment. Therefore, the necessity of the changes is implied in the commit message and the code diff.",True,"The commit message explains the necessity of the changes by mentioning that it is fixing many warnings (Eclipse 4.2/Juno based). Additionally, it mentions the addition of a new 'staticondemandthreshold' setting, which is not directly related to the import ordering change but is still a modification to the Eclipse project jdt.ui preference settings file. This indicates that the changes are being made to improve the functionality and stability of the project.",True,"The commit message indicates that the changes were made to fix many warnings in the Eclipse 4.2/Juno based environment. This suggests that the changes were made to address issues or problems in the development environment, specifically to improve code quality and adhere to the new standards or requirements of the updated Eclipse version.",True,"The commit message mentions the change of adding a new 'staticondemandthreshold' setting to the eclipse project jdt.ui preference settings file. This directly relates to the code change, which is adding a new line in the preferences file. This change improves the functionality of the code by adding a new setting that was not present before.",True,"The commit message does contain an expression that describes a summary of what changes by being a summary of the diffs. It mentions the addition of a new 'staticondemandthreshold' setting to the eclipse project jdt.ui preference settings file, which is also reflected in the diff. The diff shows that a new line has been added to the file, which corresponds to the new setting mentioned in the commit message.",True,"The commit message explains that a new setting 'staticondemandthreshold' is being added to the eclipse project jdt.ui preference settings file. This setting is not directly related to the import ordering change, but it does describe a technical principle: the ability to customize and configure the behavior of the Eclipse IDE through the addition of new settings.",True,"The commit message expresses a change in the Eclipse project settings, specifically adding a new setting 'staticondemandthreshold'. This change does not directly relate to the import ordering change mentioned in the message, but it does introduce a new behavior into the Eclipse project settings. The code diff shows that a new line has been added to the preferences file, which adds the 'staticondemandthreshold' setting with a value of 99.",True,"The commit message does not explicitly explain the reason for the change, but the change is small and simple: it's adding a new setting 'staticondemandthreshold' to the eclipse project jdt.ui preference settings file. This change is not related to the initial warning fix mentioned in the commit message, but it's a logical addition to the existing settings. Therefore, the reason for the change can be easily inferred from the code diff, and there was no need for an explicit explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/4f9258a345130a5b031a3c4170dcb7046a1bd9b8,Fixup version numbers following release ,https://api.github.com/repos/spring-projects/spring-boot/commits/4f9258a345130a5b031a3c4170dcb7046a1bd9b8,"@@ -1,5 +1,4 @@
-<?xml version=""1.0"" encoding=""UTF-8""?>
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+<?xml version=""1.0"" encoding=""UTF-8""?><project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
 	<groupId>org.springframework.boot</groupId>
 	<artifactId>spring-boot-dependencies</artifactId>
@@ -45,7 +44,7 @@
 	</developers>
 	<properties>
 		<!-- Spring Boot -->
-		<spring-boot.version>1.1.7.BUILD-SNAPSHOT</spring-boot.version>
+		<spring-boot.version>1.1.8.BUILD-SNAPSHOT</spring-boot.version>
 		<!-- Third Party -->
 		<activemq.version>5.9.1</activemq.version>
 		<aspectj.version>1.8.2</aspectj.version>
@@ -1296,4 +1295,4 @@
 			</plugins>
 		</pluginManagement>
 	</build>
-</project>
+</project>
\ No newline at end of file
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 	}
 	repositories {
 		// NOTE: You should declare only repositories that you need here
@@ -5,7 +5,7 @@
 		'$ ant -lib ivy-2.2.jar' (substitute the location of your actual ivy jar). Run with '$ java -jar target/*.jar'. 
 	</description>
 
-	<property name=""spring-boot.version"" value=""1.1.7.BUILD-SNAPSHOT"" />
+	<property name=""spring-boot.version"" value=""1.1.8.BUILD-SNAPSHOT"" />
 	<property name=""start-class"" value=""org.springframework.boot.sample.actuator.SampleActuatorApplication"" />
 
 	<target name=""resolve"" description=""--> retrieve dependencies with ivy"">
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 	}
 	repositories {
 		// NOTE: You should declare only repositories that you need here
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 	}
 	repositories {
 		// NOTE: You should declare only repositories that you need here
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 	}
 	repositories {
 		// NOTE: You should declare only repositories that you need here
@@ -1,6 +1,6 @@
 buildscript {
 	ext {
-		springBootVersion = '1.1.7.BUILD-SNAPSHOT'
+		springBootVersion = '1.1.8.BUILD-SNAPSHOT'
 		springLoadedVersion = '1.2.0.RELEASE'
 	}
 	repositories {
",True,"The commit message 'Fixup version numbers following release' refers to the need for changes to update the version numbers after a release. This is a common practice to ensure that the version numbers accurately reflect the current state of the project. The code diff also shows that the version numbers have been updated, which supports the necessity of the changes mentioned in the commit message.",True,"The commit message 'Fixup version numbers following release' clearly describes the necessity of the changes. It is common practice to update version numbers after a release, and the diff shows exactly where and how the version numbers were updated. Therefore, the commit message does not require additional explanation.",False,"The commit message 'Fixup version numbers following release' does not explicitly describe the necessity of changes. It only mentions that the version numbers are being updated following a release, but it does not elaborate on any errors, issues, or shortcomings that the previous implementation had.",True,"The commit message 'Fixup version numbers following release' indicates that the changes were made to update the version numbers after a new release. This suggests that the changes were necessary to keep the project in sync with the latest version of the Spring Boot framework, which is a requirement for the proper functioning of the software. Therefore, the commit message does express the necessity of the changes.",True,"The commit message 'Fixup version numbers following release' directly mentions the change made to the code, which is updating the version numbers. This implies that the change is likely related to a release or a version update, which often involves fixing issues or making improvements to the codebase.",True,"The commit message 'Fixup version numbers following release' accurately describes the changes made in the diff. It mentions the update of version numbers, which is a key component of the change. The diff shows that the version numbers for Spring Boot have been updated from '1.1.7.BUILD-SNAPSHOT' to '1.1.8.BUILD-SNAPSHOT' in multiple files, which is consistent with the message.",False,"The commit message 'Fixup version numbers following release' does not explicitly describe a technical principle underpinning the changes. It simply states that version numbers are being updated, but it does not explain why this is necessary or what principle is being followed.",True,"The commit message 'Fixup version numbers following release' does express a change and it specifically mentions that the version numbers are being updated. The code diff also shows that the version numbers for Spring Boot have been updated from '1.1.7.BUILD-SNAPSHOT' to '1.1.8.BUILD-SNAPSHOT' in multiple files. This change updates the version of Spring Boot that the project is using, which is a functional change that introduces new behaviors and features from the updated version of Spring Boot.",False,"The commit message does not lack an explanation. It explicitly mentions 'Fixup version numbers following release', which clearly indicates the reason for the commit. The change in version numbers from '1.1.7.BUILD-SNAPSHOT' to '1.1.8.BUILD-SNAPSHOT' is not immediately obvious from the diff, so the commit message provides necessary context."
https://github.com/apache/dubbo/commit/5b4816dfa6ae92d0b94af4ed41c07ca6c9d0fcb9,fix:Remove unused variable parameters in AbstractProxyInvoker ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/5b4816dfa6ae92d0b94af4ed41c07ca6c9d0fcb9,"@@ -82,7 +82,7 @@ public void destroy() {
     public Result invoke(Invocation invocation) throws RpcException {
         try {
             Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());
-            CompletableFuture<Object> future = wrapWithFuture(value, invocation);
+			CompletableFuture<Object> future = wrapWithFuture(value);
             CompletableFuture<AppResponse> appResponseFuture = future.handle((obj, t) -> {
                 AppResponse result = new AppResponse();
                 if (t != null) {
@@ -107,7 +107,7 @@ public Result invoke(Invocation invocation) throws RpcException {
         }
     }
 
-    private CompletableFuture<Object> wrapWithFuture (Object value, Invocation invocation) {
+	private CompletableFuture<Object> wrapWithFuture(Object value) {
         if (RpcContext.getContext().isAsyncStarted()) {
             return ((AsyncContextImpl)(RpcContext.getContext().getAsyncContext())).getInternalFuture();
         } else if (value instanceof CompletableFuture) {
",True,"The commit message 'fix:Remove unused variable parameters in AbstractProxyInvoker' explains the necessity of changes by referencing the presence of an unused variable parameter in the 'wrapWithFuture' method. This is an improvement over the prior commit, as it removes unnecessary code and potential sources of errors.",True,"The commit message 'fix:Remove unused variable parameters in AbstractProxyInvoker' clearly describes the necessity of the changes. The code diff shows that the 'invocation' parameter is no longer used in the 'wrapWithFuture' method, so it is being removed. This is a common refactoring to improve code quality and maintainability, and it does not require a detailed explanation in the commit message.",False,"The commit message does not explicitly describe the necessity of changes. It only mentions the removal of unused variable parameters, but it does not elaborate on any error scenario, issue report, or shortcoming of the previous implementation.",True,The commit message 'fix:Remove unused variable parameters in AbstractProxyInvoker' indicates that the developer made changes to remove unused variable parameters. This can be seen in the code diff where the 'wrapWithFuture' method is changed from taking two arguments to only one. This change was likely made to improve the maintainability of the code and to reduce unnecessary complexity.,True,"The commit message 'fix:Remove unused variable parameters in AbstractProxyInvoker' directly mentions the change made to the code, which is removing unused variable parameters. This can improve the code by reducing complexity and potentially fixing bugs related to these unused parameters.",True,"The commit message 'fix:Remove unused variable parameters in AbstractProxyInvoker' accurately summarizes the key component of the change, which is the removal of an unused variable parameter from the 'wrapWithFuture' method. This change is also reflected in the diff, where the 'Invocation invocation' parameter is removed from the method signature.",True,The commit message describes the technical principle of 'Simplifying Interfaces' underpinning the changes. The unused variable parameters in the 'AbstractProxyInvoker' class were removed to simplify the interface and make the code cleaner and more efficient.,True,"The commit message 'fix:Remove unused variable parameters in AbstractProxyInvoker' does express a change in the code by describing the removal of an unused parameter from the 'wrapWithFuture' method. This change simplifies the method signature and improves code readability. The change does not introduce any new behaviors, but it does improve the efficiency of the code by reducing unnecessary parameters.",False,The commit message does not lack an explanation. It explicitly states the reason for the commit: 'Remove unused variable parameters in AbstractProxyInvoker'. The code diff also supports this explanation by showing that the 'invocation' parameter is no longer used in the 'wrapWithFuture' method.
https://github.com/square/okhttp/commit/59b1c1dc5290b9f96ebeefb7ea2369d58042fed3,Pom version updates. Drop unused dependencies. ,https://api.github.com/repos/square/okhttp/commits/59b1c1dc5290b9f96ebeefb7ea2369d58042fed3,"@@ -31,10 +31,8 @@
     <java.version>1.6</java.version>
     <npn.version>8.1.2.v20120308</npn.version>
     <mockwebserver.version>20130122</mockwebserver.version>
-    <bouncycastle.version>1.47</bouncycastle.version>
-    <android.version>4.1.1.4</android.version>
-    <dagger.version>0.9.1</dagger.version>
-    <gson.version>2.2.2</gson.version>
+    <bouncycastle.version>1.48</bouncycastle.version>
+    <gson.version>2.2.3</gson.version>
     <apache.http.version>4.2.2</apache.http.version>
 
     <!-- Test Dependencies -->
@@ -81,21 +79,11 @@
         <artifactId>bcprov-jdk15on</artifactId>
         <version>${bouncycastle.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
       <dependency>
         <groupId>com.google.code.gson</groupId>
         <artifactId>gson</artifactId>
         <version>${gson.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.squareup</groupId>
-        <artifactId>dagger</artifactId>
-        <version>${dagger.version}</version>
-      </dependency>
       <dependency>
         <groupId>org.apache.httpcomponents</groupId>
         <artifactId>httpclient</artifactId>
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply mentions updating the Pom version and dropping unused dependencies, but it does not provide a clear explanation for why these changes are necessary.",True,"The commit message 'Pom version updates. Drop unused dependencies.' does not explicitly explain the necessity of the changes. However, it is common sense and easy to infer from the code diff that the outdated versions of the dependencies (bouncycastle, android, dagger, gson) are being updated to newer versions and the unused dependencies are being removed. This is a common practice to keep the project up-to-date and optimize its dependencies.",False,"The commit message only mentions updating the versions of Pom and dropping unused dependencies. It does not elaborate on any errors, issues, or shortcomings of the previous implementation that necessitated the changes.",True,"The commit message 'Pom version updates. Drop unused dependencies.' indicates that the developer is updating the versions of certain dependencies to the latest stable versions. This could be due to the need to maintain up-to-date code to ensure security, compatibility, or to take advantage of new features. Additionally, the removal of unused dependencies could be a result of the need to optimize the project and reduce its size or complexity.",True,"The commit message 'Pom version updates. Drop unused dependencies.' does contain an expression that describes the objective of the change. Specifically, it mentions that the change is to update the versions of certain dependencies and to drop unused dependencies. This implies that the change is being made to improve the codebase by removing unnecessary dependencies and keeping the software up-to-date.",True,"The commit message 'Pom version updates. Drop unused dependencies.' does describe a summary of what changes by listing the key components of the change, which are the updates of the versions of Bouncycastle and Gson, and the removal of unused dependencies such as Android, Dagger, and another version of Bouncycastle. This message does not explicitly contrast the before and after versions, but it does imply this by listing the changes made.",False,"The commit message only mentions updating the versions of Pom and dropping unused dependencies. It does not explicitly describe a technical principle underpinning the changes. For example, it does not explain why the versions of certain dependencies were updated or why certain dependencies were removed.",True,"The commit message 'Pom version updates. Drop unused dependencies.' does express a summary of the changes made in the code diff. It describes that the versions of certain dependencies (BouncyCastle and Gson) have been updated, and that unused dependencies (Android, Dagger) have been removed. This implies that the behavior of the application may have changed due to the updated versions of these libraries, as new features or bug fixes may have been introduced.",True,"The commit message 'Pom version updates. Drop unused dependencies.' clearly states that the changes are updates to the versions of certain dependencies and the removal of unused dependencies. The code diff also clearly shows which dependencies are being updated and which are being removed. Therefore, there is no need for an additional explanation in the commit message about the reason for the change."
https://github.com/junit-team/junit4/commit/5ea3196f1cdbc32bc3a91b96bedc1964d3bb76d1,Used assertArrayEquals to avoid converting an array to a list.  <enter> Incomplete - task : Issue 551: Resolve sensitive equality in MethodSorter test. ,https://api.github.com/repos/junit-team/junit4/commits/5ea3196f1cdbc32bc3a91b96bedc1964d3bb76d1,"@@ -1,6 +1,7 @@
 package org.junit.internal;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertArrayEquals;
 
 import java.lang.reflect.Method;
 import java.util.ArrayList;
@@ -145,9 +146,9 @@ void epsilon() {
 
     @Test
     public void testJvmMethodSorter() {
-    	Method[] fromJvm = DummySortJvm.class.getDeclaredMethods();
-    	Method[] sorted = MethodSorter.getDeclaredMethods(DummySortJvm.class);
-    	assertEquals( Arrays.asList(fromJvm), Arrays.asList(sorted));
+        Method[] fromJvm = DummySortJvm.class.getDeclaredMethods();
+        Method[] sorted = MethodSorter.getDeclaredMethods(DummySortJvm.class);
+        assertArrayEquals(fromJvm, sorted);
     }
 
     @FixMethodOrder(MethodSorters.NAME_ASCENDING)
",True,"The commit message refers to a convention regarding the use of assertions. It mentions using assertArrayEquals instead of converting an array to a list, which is a common practice to avoid potential issues with equality checks. This change is likely made to improve the test's accuracy and efficiency, as assertArrayEquals compares the arrays directly, while converting an array to a list and then comparing could lead to false positives or negatives.",True,"The commit message 'Used assertArrayEquals to avoid converting an array to a list' clearly explains the reason for the change in the code diff. The change is made to improve the efficiency of the test case by directly comparing arrays instead of converting them to lists. This is a common practice to avoid unnecessary overhead and improve performance, especially when dealing with large arrays.",True,"The commit message 'Used assertArrayEquals to avoid converting an array to a list' does not explicitly mention the error scenario or the issue report, but it does describe the motivation for the code change. By using assertArrayEquals instead of converting an array to a list, the commit message implies that there was a problem with the previous implementation that could lead to incorrect results when comparing arrays. Additionally, the message mentions 'Issue 551: Resolve sensitive equality in MethodSorter test', which suggests that there is a known issue that the change is addressing.",True,"The commit message 'Used assertArrayEquals to avoid converting an array to a list' indicates that the developer made the change to resolve an issue with sensitive equality in the MethodSorter test, as mentioned in the commit message. The issue is that the assertEquals method was converting an array to a list for comparison, which could lead to incorrect results. By using assertArrayEquals instead, the developer is ensuring that the arrays are compared correctly, which is a requirement to resolve the issue mentioned in the commit message.",True,"The commit message directly mentions the change made to the code, which is using assertArrayEquals instead of converting an array to a list. This change is likely made to resolve the issue of sensitive equality in the MethodSorter test, as mentioned in the incomplete task note. Therefore, the commit message does describe the objective of the change by mentioning the defect it fixes.",True,"The commit message 'Used assertArrayEquals to avoid converting an array to a list' accurately summarizes the change made in the code diff. It specifically points out the key component of the change, which is the replacement of the assertEquals method with assertArrayEquals. This change is also contrasted in the diff, where the assertEquals method is removed and assertArrayEquals is added.",False,"The commit message does not explicitly state or describe a technical principle underpinning the changes. It mainly focuses on the code changes made, such as using assertArrayEquals instead of converting an array to a list. However, it does not explain why this change is beneficial or what principle it follows.",True,The commit message expresses a change in the testing method used to compare arrays. It mentions the use of 'assertArrayEquals' instead of converting an array to a list. This change improves the efficiency and accuracy of the test. The code diff also supports this explanation by showing the addition of 'assertArrayEquals' and the modification of the test method to use it.,False,"The commit message does not fully explain the reason for the commit. While it mentions the use of assertArrayEquals instead of converting an array to a list, it does not explain why this change was necessary. The code diff shows that the change was made to resolve a sensitive equality issue in the MethodSorter test, but this is not explicitly stated in the commit message. Therefore, the commit message could be improved to provide a clearer explanation of the change."
https://github.com/square/retrofit/commit/365a0cd97bd8ee597e937ebf88170b30685047f4,Add UrlConnection Client.  <enter> Use this on Android 2.2 and prior and when on the JVM. <enter> Also update our sample to use GitHub contributors rather than the Twitter API because the latter is shutting down and subject to lame rate limiting when on common networks. <enter> Bump some dependencies to their latest versions. ,https://api.github.com/repos/square/retrofit/commits/365a0cd97bd8ee597e937ebf88170b30685047f4,"@@ -44,21 +44,21 @@
     <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
     <!-- Compilation -->
-    <android-maven.version>3.4.0</android-maven.version>
+    <android-maven.version>3.5.1</android-maven.version>
     <java.version>1.6</java.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.2.3-SNAPSHOT</gson.version>
-    <httpcomponents.version>4.0.1</httpcomponents.version>
+    <gson.version>2.2.2</gson.version>
+    <httpmime.version>4.2.3</httpmime.version>
     <javax.inject.version>1</javax.inject.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
-    <fest.version>2.0M8</fest.version>
+    <fest.version>2.0M10</fest.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>14.0-rc3</guava.version>
+    <guava.version>14.0</guava.version>
   </properties>
 
   <scm>
@@ -114,12 +114,7 @@
       <dependency>
         <groupId>org.apache.httpcomponents</groupId>
         <artifactId>httpmime</artifactId>
-        <version>${httpcomponents.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.httpcomponents</groupId>
-        <artifactId>httpclient</artifactId>
-        <version>${httpcomponents.version}</version>
+        <version>${httpmime.version}</version>
       </dependency>
 
       <dependency>
@@ -20,18 +20,14 @@
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpclient</artifactId>
-    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpmime</artifactId>
     </dependency>
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
 
     <dependency>
@@ -1,5 +1,6 @@
 package retrofit.http;
 
+import android.os.Build;
 import android.os.Process;
 import com.google.gson.Gson;
 import java.util.concurrent.Executor;
@@ -8,10 +9,11 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import retrofit.http.android.AndroidApacheClient;
 import retrofit.http.android.MainThreadExecutor;
-import retrofit.http.client.ApacheClient;
 import retrofit.http.client.Client;
+import retrofit.http.client.UrlConnectionClient;
 
 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
+import static java.lang.Thread.MIN_PRIORITY;
 import static retrofit.http.RestAdapter.THREAD_PREFIX;
 import static retrofit.http.Utils.SynchronousExecutor;
 
@@ -41,7 +43,7 @@ Converter defaultConverter() {
   /** Provides sane defaults for operation on the JVM. */
   private static class Base extends Platform {
     @Override Client.Provider defaultClient() {
-      final Client client = new ApacheClient();
+      final Client client = new UrlConnectionClient();
       return new Client.Provider() {
         @Override public Client get() {
           return client;
@@ -56,7 +58,7 @@ private static class Base extends Platform {
         @Override public Thread newThread(final Runnable r) {
           return new Thread(new Runnable() {
             @Override public void run() {
-              Thread.currentThread().setPriority(THREAD_PRIORITY_BACKGROUND);
+              Thread.currentThread().setPriority(MIN_PRIORITY);
               r.run();
             }
           }, THREAD_PREFIX + threadCounter.getAndIncrement());
@@ -72,7 +74,12 @@ private static class Base extends Platform {
   /** Provides sane defaults for operation on Android. */
   private static class Android extends Platform {
     @Override Client.Provider defaultClient() {
-      final Client client = new AndroidApacheClient();
+      final Client client;
+      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+        client = new AndroidApacheClient();
+      } else {
+        client = new UrlConnectionClient();
+      }
       return new Client.Provider() {
         @Override public Client get() {
           return client;
@@ -18,15 +18,14 @@
 import org.apache.http.entity.AbstractHttpEntity;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HTTP;
 import org.apache.http.util.EntityUtils;
 import retrofit.http.Header;
 import retrofit.http.mime.TypedByteArray;
 import retrofit.http.mime.TypedOutput;
 
 /** A {@link Client} which uses an implementation of Apache's {@link HttpClient}. */
 public class ApacheClient implements Client {
-  private static final String HEADER_CONTENT_TYPE = ""Content-Type"";
-
   private final HttpClient client;
 
   /** Creates an instance backed by {@link DefaultHttpClient}. */
@@ -68,11 +67,11 @@ static Response parseResponse(HttpResponse response) throws IOException {
     String reason = statusLine.getReasonPhrase();
 
     List<Header> headers = new ArrayList<Header>();
-    String contentType = ""application/octet-stream"";
+    String contentType = HTTP.OCTET_STREAM_TYPE;
     for (org.apache.http.Header header : response.getAllHeaders()) {
       String name = header.getName();
       String value = header.getValue();
-      if (name.equalsIgnoreCase(HEADER_CONTENT_TYPE)) {
+      if (name.equalsIgnoreCase(HTTP.CONTENT_TYPE)) {
         contentType = value;
       }
       headers.add(new Header(name, value));
@@ -0,0 +1,93 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import retrofit.http.Header;
+import retrofit.http.mime.TypedInput;
+import retrofit.http.mime.TypedOutput;
+
+public class UrlConnectionClient implements Client {
+  @Override public Response execute(Request request) throws IOException {
+    HttpURLConnection connection = openConnection(request);
+    prepareRequest(connection, request);
+    return readResponse(connection);
+  }
+
+  protected HttpURLConnection openConnection(Request request) throws IOException {
+    return (HttpURLConnection) new URL(request.getUrl()).openConnection();
+  }
+
+  void prepareRequest(HttpURLConnection connection, Request request) throws IOException {
+    connection.setRequestMethod(request.getMethod());
+    connection.setDoInput(true);
+
+    for (Header header : request.getHeaders()) {
+      connection.addRequestProperty(header.getName(), header.getValue());
+    }
+
+    TypedOutput body = request.getBody();
+    if (body != null) {
+      connection.setDoOutput(true);
+      connection.addRequestProperty(""Content-Type"", body.mimeType());
+      long length = body.length();
+      if (length != -1) {
+        connection.addRequestProperty(""Content-Length"", String.valueOf(length));
+      }
+      body.writeTo(connection.getOutputStream());
+    }
+  }
+
+  Response readResponse(HttpURLConnection connection) throws IOException {
+    int status = connection.getResponseCode();
+    String reason = connection.getResponseMessage();
+
+    List<Header> headers = new ArrayList<Header>();
+    for (Map.Entry<String, List<String>> field : connection.getHeaderFields().entrySet()) {
+      String name = field.getKey();
+      for (String value : field.getValue()) {
+        headers.add(new Header(name, value));
+      }
+    }
+
+    String mimeType = connection.getContentType();
+    int length = connection.getContentLength();
+    InputStream stream;
+    if (status == 200) {
+      stream = connection.getInputStream();
+    } else {
+      stream = connection.getErrorStream();
+    }
+    TypedInput responseBody = new TypedInputStream(mimeType, length, stream);
+    return new Response(status, reason, headers, responseBody);
+  }
+
+  private static class TypedInputStream implements TypedInput {
+    private final String mimeType;
+    private final long length;
+    private final InputStream stream;
+
+    private TypedInputStream(String mimeType, long length, InputStream stream) {
+      this.mimeType = mimeType;
+      this.length = length;
+      this.stream = stream;
+    }
+
+    @Override public String mimeType() {
+      return mimeType;
+    }
+
+    @Override public long length() {
+      return length;
+    }
+
+    @Override public InputStream in() throws IOException {
+      return stream;
+    }
+  }
+}
@@ -42,4 +42,8 @@ public static HttpMultipart extractEntity(TypedOutput output)
   public static void assertMultipart(TypedOutput typedOutput) {
     assertThat(typedOutput).isInstanceOf(MultipartTypedOutput.class);
   }
+
+  public static void assertBytes(byte[] bytes, String expected) throws Exception {
+    assertThat(new String(bytes, ""UTF-8"")).isEqualTo(expected);
+  }
 }
@@ -21,6 +21,7 @@
 import retrofit.http.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static retrofit.http.TestingUtils.assertBytes;
 import static retrofit.http.TestingUtils.assertMultipart;
 import static retrofit.http.client.ApacheClient.TypedOutputEntity;
 
@@ -123,8 +124,4 @@ public class ApacheClientTest {
         .containsExactly(new Header(""foo"", ""bar""), new Header(""kit"", ""kat""));
     assertThat(response.getBody()).isNull();
   }
-
-  private static void assertBytes(byte[] bytes, String expected) throws Exception {
-    assertThat(new String(bytes, ""UTF-8"")).isEqualTo(expected);
-  }
 }
@@ -0,0 +1,115 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Provides POJO behavior for all of the APIs {@link retrofit.http.client.UrlConnectionClient}
+ * interacts with.
+ */
+public class DummyHttpUrlConnection extends HttpURLConnection {
+  private final Map<String, List<String>> responseHeaders =
+      new LinkedHashMap<String, List<String>>();
+  private final Map<String, List<String>> requestHeaders =
+      new LinkedHashMap<String, List<String>>();
+  private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+  private int responseCode;
+  private String responseMessage;
+  private InputStream inputStream;
+  private InputStream errorStream;
+
+  protected DummyHttpUrlConnection(String url) throws MalformedURLException {
+    super(new URL(url));
+  }
+
+  public void setResponseCode(int responseCode) {
+    this.responseCode = responseCode;
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return responseCode;
+  }
+
+  public void setResponseMessage(String responseMessage) {
+    this.responseMessage = responseMessage;
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return responseMessage;
+  }
+
+  @Override public ByteArrayOutputStream getOutputStream() throws IOException {
+    return outputStream;
+  }
+
+  public void setInputStream(InputStream inputStream) {
+    this.inputStream = inputStream;
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return inputStream;
+  }
+
+  public void setErrorStream(InputStream errorStream) {
+    this.errorStream = errorStream;
+  }
+
+  @Override public InputStream getErrorStream() {
+    return errorStream;
+  }
+
+  public void addResponseHeader(String name, String value) {
+    List<String> values = responseHeaders.get(name);
+    if (values == null) {
+      values = new ArrayList<String>();
+      responseHeaders.put(name, values);
+    }
+    values.add(value);
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    return responseHeaders;
+  }
+
+  @Override public void addRequestProperty(String name, String value) {
+    List<String> values = requestHeaders.get(name);
+    if (values == null) {
+      values = new ArrayList<String>();
+      requestHeaders.put(name, values);
+    }
+    values.add(value);
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    return requestHeaders;
+  }
+
+  @Override public String getRequestProperty(String name) {
+    List<String> values = requestHeaders.get(name);
+    if (values == null || values.isEmpty()) {
+      return null;
+    }
+    return values.get(0);
+  }
+
+  @Override public void disconnect() {
+    throw new AssertionError(""Not implemented."");
+  }
+
+  @Override public boolean usingProxy() {
+    return false;
+  }
+
+  @Override public void connect() throws IOException {
+    throw new AssertionError(""Not implemented."");
+  }
+}
@@ -0,0 +1,132 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import org.junit.Test;
+import retrofit.http.Header;
+import retrofit.http.TestingUtils;
+import retrofit.http.mime.TypedOutput;
+import retrofit.http.mime.TypedString;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static retrofit.http.TestingUtils.assertBytes;
+
+public class UrlConnectionClientTest {
+  private static final String HOST = ""http://example.com"";
+
+  private UrlConnectionClient client = new UrlConnectionClient() {
+    @Override protected HttpURLConnection openConnection(Request request) throws IOException {
+      return new DummyHttpUrlConnection(request.getUrl());
+    }
+  };
+
+  @Test public void get() throws Exception {
+    Request request = new Request(""GET"", HOST + ""/foo/bar/?kit=kat"", null, null);
+
+    HttpURLConnection connection = client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo(""GET"");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + ""/foo/bar/?kit=kat"");
+    assertThat(connection.getHeaderFields()).isEmpty();
+  }
+
+  @Test public void post() throws Exception {
+    TypedString body = new TypedString(""hi"");
+    Request request = new Request(""POST"", HOST + ""/foo/bar/"", null, body);
+
+    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo(""POST"");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + ""/foo/bar/"");
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty(""Content-Type"")) //
+        .isEqualTo(""text/plain; charset=UTF-8"");
+    assertThat(connection.getRequestProperty(""Content-Length"")).isEqualTo(""2"");
+    assertBytes(connection.getOutputStream().toByteArray(), ""hi"");
+  }
+
+  @Test public void multipart() throws Exception {
+    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
+    bodyParams.put(""foo"", new TypedString(""bar""));
+    bodyParams.put(""ping"", new TypedString(""pong""));
+    TypedOutput body = TestingUtils.createMultipart(bodyParams);
+    Request request = new Request(""POST"", HOST + ""/that/"", null, body);
+
+    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo(""POST"");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + ""/that/"");
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty(""Content-Type"")).startsWith(""multipart/form-data;"");
+    assertThat(connection.getRequestProperty(""Content-Length"")).isNotNull();
+    assertThat(connection.getOutputStream().toByteArray().length).isGreaterThan(0);
+  }
+
+  @Test public void headers() throws Exception {
+    List<Header> headers = new ArrayList<Header>();
+    headers.add(new Header(""kit"", ""kat""));
+    headers.add(new Header(""foo"", ""bar""));
+    Request request = new Request(""GET"", HOST + ""/this/"", headers, null);
+
+    HttpURLConnection connection = client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty(""kit"")).isEqualTo(""kat"");
+    assertThat(connection.getRequestProperty(""foo"")).isEqualTo(""bar"");
+  }
+
+  @Test public void response() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(200);
+    connection.setResponseMessage(""OK"");
+    connection.addResponseHeader(""Content-Type"", ""text/plain"");
+    connection.addResponseHeader(""foo"", ""bar"");
+    connection.addResponseHeader(""kit"", ""kat"");
+    connection.setInputStream(new ByteArrayInputStream(""hello"".getBytes(""UTF-8"")));
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getReason()).isEqualTo(""OK"");
+    assertThat(response.getHeaders()).hasSize(3) //
+        .containsOnly(new Header(""foo"", ""bar""), new Header(""kit"", ""kat""),
+            new Header(""Content-Type"", ""text/plain""));
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), ""hello"");
+  }
+
+  @Test public void errorResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(401);
+    connection.setResponseMessage(""Not Authorized"");
+    connection.addResponseHeader(""Content-Type"", ""text/plain"");
+    connection.setInputStream(new ByteArrayInputStream(""input"".getBytes(""UTF-8"")));
+    connection.setErrorStream(new ByteArrayInputStream(""error"".getBytes(""UTF-8"")));
+    Response response = client.readResponse(connection);
+
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), ""error"");
+  }
+
+  @Test public void emptyResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(200);
+    connection.setResponseMessage(""OK"");
+    connection.addResponseHeader(""foo"", ""bar"");
+    connection.addResponseHeader(""kit"", ""kat"");
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getReason()).isEqualTo(""OK"");
+    assertThat(response.getHeaders()).hasSize(2) //
+        .containsExactly(new Header(""foo"", ""bar""), new Header(""kit"", ""kat""));
+  }
+}
@@ -7,30 +7,34 @@
 import retrofit.http.RestAdapter;
 
 public class Client {
-  private static final String API_URL = ""https://api.twitter.com/1/"";
+  private static final String API_URL = ""https://api.github.com"";
 
-  class Tweet {
-    String text;
+  class Contributor {
+    String login;
+    int contributions;
   }
 
-  interface Twitter {
-    @GET(""/statuses/user_timeline.json"")
-    List<Tweet> tweets(@Name(""screen_name"") String user);
+  interface GitHub {
+    @GET(""/repos/{owner}/{repo}/contributors"")
+    List<Contributor> contributors(
+        @Name(""owner"") String owner,
+        @Name(""repo"") String repo
+    );
   }
 
   public static void main(String... args) {
-    // Create a very simple REST adapter which points the Twitter API endpoint.
+    // Create a very simple REST adapter which points the GitHub API endpoint.
     RestAdapter restAdapter = new RestAdapter.Builder()
         .setServer(API_URL)
         .build();
 
-    // Create an instance of our Twitter API interface.
-    Twitter twitter = restAdapter.create(Twitter.class);
+    // Create an instance of our GitHub API interface.
+    GitHub github = restAdapter.create(GitHub.class);
 
-    // Fetch and print a list of the 20 most recent tweets for a user.
-    List<Tweet> tweets = twitter.tweets(""horse_ebooks"");
-    for (Tweet tweet : tweets) {
-      System.out.println(tweet.text);
+    // Fetch and print a list of the contributors to this library.
+    List<Contributor> contributors = github.contributors(""square"", ""retrofit"");
+    for (Contributor contributor : contributors) {
+      System.out.println(contributor.login + "" ("" + contributor.contributions + "")"");
     }
   }
 }
",True,The commit message explains the necessity of changes by referencing a convention (using UrlConnectionClient on Android 2.2 and prior and when on the JVM) and an improvement in prior commits (updating the sample to use GitHub contributors rather than the Twitter API because the latter is shutting down and subject to lame rate limiting when on common networks).,True,"The commit message does not explicitly state the reason for the changes, but it is clear from the diff that the changes are being made to update the URL connection client and dependencies. This is likely due to the deprecation of the Twitter API and the need to use a different API for the sample. Additionally, the message mentions updating dependencies to their latest versions, which is a common reason for changes in a project's build configuration.",True,The commit message explains the motivation for the changes by mentioning that the UrlConnection Client is being added for use on Android 2.2 and prior and when on the JVM. It also mentions that the sample is being updated to use GitHub contributors rather than the Twitter API because the latter is shutting down and subject to lame rate limiting when on common networks. This directly elaborates the need for the code change and provides context for the changes made.,True,The commit message mentions the need for software development for requirements of users by updating the sample to use GitHub contributors rather than the Twitter API because the latter is shutting down and subject to lame rate limiting when on common networks. This indicates a change to meet user requirements.,True,The commit message mentions the change to use GitHub contributors instead of the Twitter API because the latter is shutting down and subject to lame rate limiting when on common networks. This directly describes the improvement made to the code by addressing a specific issue (the Twitter API shutting down) and the change made to accommodate it (using GitHub contributors).,True,"The commit message summarizes the changes made in the code diff. It mentions the addition of a UrlConnection Client, updates to the sample code to use GitHub contributors instead of the Twitter API, and the bumping of some dependencies to their latest versions. These changes are all reflected in the code diff provided.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on the updates made to the project, such as adding a new UrlConnection Client, updating dependencies, and changing the sample to use GitHub contributors. However, it does not explain why the UrlConnection Client was chosen over the ApacheClient or provide any insight into the reasoning behind the changes to the dependencies or the sample.",True,"The commit message describes the addition of a new UrlConnection Client and its usage on Android 2.2 and prior and when on the JVM. It also mentions the update of the sample to use GitHub contributors instead of the Twitter API due to its shutdown and subject to lame rate limiting when on common networks. The code changes reflect these updates, such as the modification of the default client to use UrlConnectionClient on Android versions greater than GINGERBREAD and the update of the sample API to use GitHub contributors. Additionally, the commit message mentions the bumping of some dependencies to their latest versions, which is also reflected in the code changes.",False,"The commit message does not lack an explanation. It explains the reason for adding the UrlConnection Client, updating the sample to use GitHub contributors, and bumping some dependencies to their latest versions. The code diff also supports these explanations."
https://github.com/spring-projects/spring-boot/commit/a9c9c383f4c7afe0119bded0d005d1481acf71ed,"Polish pom.xml  <enter> Aplly consistent formatting, drop JDK 8 support and cleanup repo locations to use spring.io. ",https://api.github.com/repos/spring-projects/spring-boot/commits/a9c9c383f4c7afe0119bded0d005d1481acf71ed,"@@ -116,11 +116,11 @@
 			<artifactId>spring-security-acl</artifactId>
 			<optional>true</optional>
 		</dependency>
-        <dependency>
-            <groupId>org.springframework.amqp</groupId>
-            <artifactId>spring-rabbit</artifactId>
-            <optional>true</optional>
-        </dependency>
+		<dependency>
+			<groupId>org.springframework.amqp</groupId>
+			<artifactId>spring-rabbit</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>org.springframework.mobile</groupId>
 			<artifactId>spring-mobile-device</artifactId>
@@ -152,9 +152,9 @@
 			<optional>true</optional>
 		</dependency>
 		<dependency>
-			 <groupId>org.apache.geronimo.specs</groupId>
-			 <artifactId>geronimo-jms_1.1_spec</artifactId>
-			 <optional>true</optional>
+			<groupId>org.apache.geronimo.specs</groupId>
+			<artifactId>geronimo-jms_1.1_spec</artifactId>
+			<optional>true</optional>
 		</dependency>
 		<dependency>
 			<groupId>org.aspectj</groupId>
@@ -71,7 +71,7 @@
 			<groupId>org.eclipse.aether</groupId>
 			<artifactId>aether-util</artifactId>
 		</dependency>
-		<!--  Test -->
+		<!-- Test -->
 		<dependency>
 			<groupId>junit</groupId>
 			<artifactId>junit</artifactId>
@@ -134,7 +134,8 @@
 		</plugins>
 		<pluginManagement>
 			<plugins>
-				<!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build itself.-->
+				<!--This plugin's configuration is used to store Eclipse m2e settings
+					only. It has no influence on the Maven build itself. -->
 				<plugin>
 					<groupId>org.eclipse.m2e</groupId>
 					<artifactId>lifecycle-mapping</artifactId>
@@ -152,7 +153,7 @@
 										</goals>
 									</pluginExecutionFilter>
 									<action>
-										<execute/>
+										<execute />
 									</action>
 								</pluginExecution>
 							</pluginExecutions>
@@ -51,7 +51,7 @@
 			<artifactId>groovy-templates</artifactId>
 			<optional>true</optional>
 		</dependency>
-		<!--  Provided -->
+		<!-- Provided -->
 		<dependency>
 			<groupId>${project.groupId}</groupId>
 			<artifactId>spring-boot-cli-grape</artifactId>
@@ -93,9 +93,9 @@
 			<resource>
 				<directory>src/main/resources</directory>
 				<filtering>true</filtering>
-                <excludes>
-                    <exclude>**/*.vpp</exclude>
-                </excludes>
+				<excludes>
+					<exclude>**/*.vpp</exclude>
+				</excludes>
 			</resource>
 			<resource>
 				<directory>src/main/groovy</directory>
@@ -216,7 +216,8 @@
 		</plugins>
 		<pluginManagement>
 			<plugins>
-				<!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build itself.-->
+				<!--This plugin's configuration is used to store Eclipse m2e settings
+					only. It has no influence on the Maven build itself. -->
 				<plugin>
 					<groupId>org.eclipse.m2e</groupId>
 					<artifactId>lifecycle-mapping</artifactId>
@@ -234,7 +235,7 @@
 										</goals>
 									</pluginExecutionFilter>
 									<action>
-										<execute/>
+										<execute />
 									</action>
 								</pluginExecution>
 							</pluginExecutions>
@@ -8,7 +8,6 @@
 	<packaging>pom</packaging>
 	<properties>
 		<activemq.version>5.4.0</activemq.version>
-		<aether.version>0.9.0.M3</aether.version>
 		<aspectj.version>1.7.3</aspectj.version>
 		<commons-dbcp.version>1.4</commons-dbcp.version>
 		<commons-httpclient.version>3.1</commons-httpclient.version>
@@ -441,11 +440,11 @@
 				<artifactId>spring-security-acl</artifactId>
 				<version>${spring-security.version}</version>
 			</dependency>
-            <dependency>
-                <groupId>org.springframework.amqp</groupId>
-                <artifactId>spring-rabbit</artifactId>
-                <version>${spring-rabbit.version}</version>
-            </dependency>
+			<dependency>
+				<groupId>org.springframework.amqp</groupId>
+				<artifactId>spring-rabbit</artifactId>
+				<version>${spring-rabbit.version}</version>
+			</dependency>
 			<dependency>
 				<groupId>org.springframework.mobile</groupId>
 				<artifactId>spring-mobile-device</artifactId>
@@ -11,6 +11,7 @@
 	<artifactId>spring-boot-parent</artifactId>
 	<packaging>pom</packaging>
 	<properties>
+		<aether.version>0.9.0.M3</aether.version>
 		<java.version>1.6</java.version>
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
@@ -253,6 +254,57 @@
 					<artifactId>sonar-maven-plugin</artifactId>
 					<version>2.0</version>
 				</plugin>
+				<!--This plugin's configuration is used to store Eclipse m2e settings
+					only. It has no influence on the Maven build itself. -->
+				<plugin>
+					<groupId>org.eclipse.m2e</groupId>
+					<artifactId>lifecycle-mapping</artifactId>
+					<version>1.0.0</version>
+					<configuration>
+						<lifecycleMappingMetadata>
+							<pluginExecutions>
+								<pluginExecution>
+									<pluginExecutionFilter>
+										<groupId>
+											org.apache.maven.plugins
+										</groupId>
+										<artifactId>
+											maven-enforcer-plugin
+										</artifactId>
+										<versionRange>
+											[1.3.1,)
+										</versionRange>
+										<goals>
+											<goal>enforce-once</goal>
+										</goals>
+									</pluginExecutionFilter>
+									<action>
+										<ignore></ignore>
+									</action>
+								</pluginExecution>
+								<pluginExecution>
+									<pluginExecutionFilter>
+										<groupId>
+											org.apache.maven.plugins
+										</groupId>
+										<artifactId>
+											maven-dependency-plugin
+										</artifactId>
+										<versionRange>
+											[2.8,)
+										</versionRange>
+										<goals>
+											<goal>copy</goal>
+										</goals>
+									</pluginExecutionFilter>
+									<action>
+										<ignore></ignore>
+									</action>
+								</pluginExecution>
+							</pluginExecutions>
+						</lifecycleMappingMetadata>
+					</configuration>
+				</plugin>
 			</plugins>
 		</pluginManagement>
 		<plugins>
@@ -281,7 +333,21 @@
 			</plugin>
 			<plugin>
 				<artifactId>maven-enforcer-plugin</artifactId>
-				<version>1.3.1</version>
+				<executions>
+					<execution>
+						<id>enforce-rules</id>
+						<goals>
+							<goal>enforce-once</goal>
+						</goals>
+						<configuration>
+							<rules>
+								<requireJavaVersion>
+									<version>(1.7,1.8)</version>
+								</requireJavaVersion>
+							</rules>
+						</configuration>
+					</execution>
+				</executions>
 			</plugin>
 			<plugin>
 				<artifactId>maven-jar-plugin</artifactId>
@@ -406,15 +472,15 @@
 				<repository>
 					<id>spring-milestones</id>
 					<name>Spring Milestones</name>
-					<url>http://maven.springframework.org/milestone</url>
+					<url>http://repo.spring.io/milestone</url>
 					<snapshots>
 						<enabled>false</enabled>
 					</snapshots>
 				</repository>
 				<repository>
 					<id>spring-snapshots</id>
 					<name>Spring Snapshots</name>
-					<url>http://maven.springframework.org/snapshot</url>
+					<url>http://repo.spring.io/snapshot</url>
 					<snapshots>
 						<enabled>true</enabled>
 					</snapshots>
@@ -424,15 +490,15 @@
 				<pluginRepository>
 					<id>spring-milestones</id>
 					<name>Spring Milestones</name>
-					<url>http://maven.springframework.org/milestone</url>
+					<url>http://repo.spring.io/milestone</url>
 					<snapshots>
 						<enabled>false</enabled>
 					</snapshots>
 				</pluginRepository>
 				<pluginRepository>
 					<id>spring-snapshots</id>
 					<name>Spring Snapshots</name>
-					<url>http://maven.springframework.org/snapshot</url>
+					<url>http://repo.spring.io/snapshot</url>
 					<snapshots>
 						<enabled>true</enabled>
 					</snapshots>
@@ -447,7 +513,7 @@
 				<repository>
 					<id>spring-milestones</id>
 					<name>Spring Milestones</name>
-					<url>http://maven.springframework.org/milestone</url>
+					<url>http://repo.spring.io/milestone</url>
 					<snapshots>
 						<enabled>false</enabled>
 					</snapshots>
@@ -457,7 +523,7 @@
 				<pluginRepository>
 					<id>spring-milestones</id>
 					<name>Spring Milestones</name>
-					<url>http://maven.springframework.org/milestone</url>
+					<url>http://repo.spring.io/snapshot</url>
 					<snapshots>
 						<enabled>false</enabled>
 					</snapshots>
@@ -488,8 +554,6 @@
 		</profile>
 		<profile>
 			<id>release</id>
-			<activation>
-			</activation>
 			<build>
 				<plugins>
 					<plugin>
@@ -513,21 +577,5 @@
 				</plugins>
 			</build>
 		</profile>
-		<profile>
-			<id>jdk8</id>
-			<activation>
-				<jdk>1.8</jdk>
-			</activation>
-			<build>
-				<plugins>
-					<plugin>
-						<artifactId>maven-javadoc-plugin</artifactId>
-						<configuration>
-							<additionalparam>-Xdoclint:none -quiet</additionalparam>
-						</configuration>
-					</plugin>
-				</plugins>
-			</build>
-		</profile>
 	</profiles>
 </project>
@@ -1,5 +1,6 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
 	<modelVersion>4.0.0</modelVersion>
 	<parent>
 		<groupId>org.springframework.boot</groupId>
@@ -258,17 +259,22 @@
 							</goals>
 							<configuration>
 								<transformers>
-									<transformer implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
+									<transformer
+										implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
 										<resource>META-INF/spring.handlers</resource>
 									</transformer>
-									<transformer implementation=""org.springframework.maven.packaging.PropertiesMergingResourceTransformer"">
+									<transformer
+										implementation=""org.springframework.maven.packaging.PropertiesMergingResourceTransformer"">
 										<resource>META-INF/spring.factories</resource>
 									</transformer>
-									<transformer implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
+									<transformer
+										implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
 										<resource>META-INF/spring.schemas</resource>
 									</transformer>
-									<transformer implementation=""org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"" />
-									<transformer implementation=""org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"">
+									<transformer
+										implementation=""org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"" />
+									<transformer
+										implementation=""org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"">
 										<mainClass>${start-class}</mainClass>
 									</transformer>
 								</transformers>
@@ -29,7 +29,7 @@
 		</dependency>
 		<dependency>
 			<groupId>org.apache.maven</groupId>
-			<artifactId>maven-core</artifactId>			
+			<artifactId>maven-core</artifactId>
 		</dependency>
 		<dependency>
 			<groupId>org.apache.maven</groupId>
@@ -65,7 +65,7 @@
 		<dependency>
 			<groupId>org.apache.maven.plugins</groupId>
 			<artifactId>maven-shade-plugin</artifactId>
-			<optional>true</optional>			
+			<optional>true</optional>
 		</dependency>
 		<!-- Provided -->
 		<dependency>
",True,"The commit message refers to the necessity of changes by mentioning 'Aplly consistent formatting', 'drop JDK 8 support', and 'cleanup repo locations to use spring.io'. These expressions describe the need for changes to improve code quality, adhere to standards, and maintain the project's structure.",True,"The commit message 'Polish pom.xml' does not explicitly state the necessity of the changes. However, the changes made in the diff include applying consistent formatting, dropping JDK 8 support, and cleaning up repository locations to use spring.io. These changes are likely to improve the maintainability and compatibility of the project, which is a common reason for modifying a pom.xml file.",True,"The commit message 'Polish pom.xml' does not explicitly describe the necessity of changes. However, the changes made in the diff suggest that the commit is related to cleaning up the pom.xml file, dropping JDK 8 support, and updating repository locations to use spring.io. This indicates that the changes are likely made to improve the project's build configuration, which could be motivated by the need to modernize the project, improve compatibility, or simplify the build process.",True,"The commit message 'Polish pom.xml' indicates that the changes made are not due to a new requirement or problem, but rather to improve the existing codebase. However, the message does mention 'drop JDK 8 support', which suggests that the changes are being made to accommodate a change in the development environment. This could be due to the end of support for JDK 8, or a decision to standardize on a different version of Java.",True,"The commit message mentions the changes made to the pom.xml file, such as applying consistent formatting, dropping JDK 8 support, and cleaning up repository locations to use spring.io. This indicates that the changes are being made to improve the code and its maintainability, which is a positive improvement.",True,"The commit message 'Polish pom.xml' describes the changes made to the pom.xml file, which is a summary of the diffs. The message also mentions applying consistent formatting, dropping JDK 8 support, and cleaning up repository locations to use spring.io, which are all key components of the change. Additionally, the message does not contrast the before and after, but the diff shows that there are no major changes to the pom.xml file that would require such a contrast.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on formatting, dropping JDK 8 support, and cleaning up repository locations. While these are important changes, they do not directly relate to a specific technical principle.",True,"The commit message 'Polish pom.xml' does describe the changes made to the file. It mentions applying consistent formatting, dropping JDK 8 support, and cleaning up repository locations to use spring.io. These changes do not introduce new behaviors but rather improve the structure and maintainability of the project. However, the changes do describe a modification to the project's configuration, which could potentially have functional implications.",True,"The commit message does not explicitly explain the reason for the commit, but the change is straightforward and easy to infer. The removed dependency for 'spring-rabbit' and 'geronimo-jms_1.1_spec' is not mentioned in the commit message, but it can be inferred from the code diff. Additionally, the commit message mentions dropping JDK 8 support, which is not reflected in the code diff provided, but it suggests that the removal of the 'aether-util' dependency might be related to this."
https://github.com/spring-projects/spring-boot/commit/7c13c01cb6a62b86478aa53d3516ae8aaea48bca,Fix mapping of Cassandra's idle-timeout and heartbeat-interval  <enter> Previous to this commit the connection idle timeout and heartbeat interval were mapped to seconds whereas Cassandra expects ms for all duration types. <enter> This commit fixes the mapping and removes the default duration unit since it should be considered ms like every other duration properties. <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/7c13c01cb6a62b86478aa53d3516ae8aaea48bca,"@@ -146,11 +146,11 @@ private void mapConnectionOptions(CassandraProperties properties, CassandraDrive
 	}
 
 	private void mapPoolingOptions(CassandraProperties properties, CassandraDriverOptions options) {
-		PropertyMapper map = PropertyMapper.get();
+		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
 		CassandraProperties.Pool poolProperties = properties.getPool();
-		map.from(poolProperties::getIdleTimeout).whenNonNull().asInt(Duration::getSeconds)
+		map.from(poolProperties::getIdleTimeout).asInt(Duration::toMillis)
 				.to((idleTimeout) -> options.add(DefaultDriverOption.HEARTBEAT_TIMEOUT, idleTimeout));
-		map.from(poolProperties::getHeartbeatInterval).whenNonNull().asInt(Duration::getSeconds)
+		map.from(poolProperties::getHeartbeatInterval).asInt(Duration::toMillis)
 				.to((heartBeatInterval) -> options.add(DefaultDriverOption.HEARTBEAT_INTERVAL, heartBeatInterval));
 	}
 
@@ -17,7 +17,6 @@
 package org.springframework.boot.autoconfigure.cassandra;
 
 import java.time.Duration;
-import java.time.temporal.ChronoUnit;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -26,7 +25,6 @@
 
 import org.springframework.boot.context.properties.ConfigurationProperties;
 import org.springframework.boot.context.properties.DeprecatedConfigurationProperty;
-import org.springframework.boot.convert.DurationUnit;
 
 /**
  * Configuration properties for Cassandra.
@@ -360,18 +358,14 @@ public Throttler getThrottler() {
 	public static class Pool {
 
 		/**
-		 * Idle timeout before an idle connection is removed. If a duration suffix is not
-		 * specified, seconds will be used.
+		 * Idle timeout before an idle connection is removed.
 		 */
-		@DurationUnit(ChronoUnit.SECONDS)
 		private Duration idleTimeout = Duration.ofSeconds(120);
 
 		/**
 		 * Heartbeat interval after which a message is sent on an idle connection to make
-		 * sure it's still alive. If a duration suffix is not specified, seconds will be
-		 * used.
+		 * sure it's still alive.
 		 */
-		@DurationUnit(ChronoUnit.SECONDS)
 		private Duration heartbeatInterval = Duration.ofSeconds(30);
 
 		public Duration getIdleTimeout() {
",True,"The commit message explains the necessity of changes by referencing a convention in the previous commits. It mentions that previously, the connection idle timeout and heartbeat interval were mapped to seconds, whereas Cassandra expects milliseconds for all duration types. This commit fixes the mapping to use milliseconds, which is a standard in Cassandra for duration types. The message also removes the default duration unit since it should be considered milliseconds like every other duration property.",True,"The commit message clearly explains the necessity of the changes by stating that the connection idle timeout and heartbeat interval were previously mapped to seconds, whereas Cassandra expects milliseconds for all duration types. This makes it clear that the changes are necessary to correct a bug or inconsistency in the code.",True,"The commit message directly elaborates the motivation of the code change by explaining the error scenario where the connection idle timeout and heartbeat interval were mapped to seconds, whereas Cassandra expects milliseconds for all duration types. This error could have resulted in incorrect behavior or timeouts. The message also mentions that it closes an issue, which adds further context to the change.",True,"The commit message describes the necessity of changes by mentioning that the connection idle timeout and heartbeat interval were mapped to seconds whereas Cassandra expects ms for all duration types. This indicates that the changes were made to fix a problem in the software maintenance process, specifically outdated code that was not compatible with the updated Cassandra API.",True,The commit message directly mentions the defect it fixes by stating that 'previous to this commit the connection idle timeout and heartbeat interval were mapped to seconds whereas Cassandra expects ms for all duration types'. This clearly indicates that the change is made to fix a bug or issue in the code.,True,"The commit message accurately summarizes the changes made in the diff. It mentions the mapping of Cassandra's idle-timeout and heartbeat-interval, explaining that previously these were mapped to seconds but Cassandra expects milliseconds. The message also mentions the removal of the default duration unit as it is no longer necessary since all duration properties are expected to be in milliseconds.",True,"The commit message explains that the changes were made to fix the mapping of Cassandra's idle-timeout and heartbeat-interval. It states that previously, these were mapped to seconds, but Cassandra expects milliseconds for all duration types. This clearly describes the technical principle underpinning the changes, which is the need to use the correct unit of time for the configuration.",True,"The commit message accurately describes the changes made to the code. It explains that the connection idle timeout and heartbeat interval were previously mapped to seconds, but Cassandra expects milliseconds for all duration types. The commit message also mentions that the default duration unit is removed since it should be considered milliseconds like every other duration property. This change introduces new behavior where the idle timeout and heartbeat interval are now correctly mapped to milliseconds.",False,"The commit message does not lack an explanation. It clearly states that the previous mapping was in seconds, whereas Cassandra expects milliseconds. This is a significant change that could potentially cause issues if not properly addressed. The commit message also mentions that it closes an issue, which suggests that there was a problem or a feature request that this commit is addressing."
https://github.com/square/okhttp/commit/e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab,"Move cache writing out of the transport.  <enter> This is necessary to unblock network interceptors, where the interceptor may elect to rewrite the response body. If we've already cached the original response body, we're too late. ",https://api.github.com/repos/square/okhttp/commits/e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab,"@@ -660,9 +660,11 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         .method(requestMethod, requestBodyOrNull(requestMethod))
         .build();
     Response response1 = client.newCall(request).execute();
+    response1.body().close();
     assertEquals(""1"", response1.header(""X-Response-ID""));
 
     Response response2 = get(url);
+    response2.body().close();
     if (expectCached) {
       assertEquals(""1"", response2.header(""X-Response-ID""));
     } else {
@@ -629,9 +629,11 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     HttpURLConnection request1 = client.open(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
     assertEquals(""1"", request1.getHeaderField(""X-Response-ID""));
 
     URLConnection request2 = client.open(url);
+    request2.getInputStream().close();
     if (expectCached) {
       assertEquals(""1"", request2.getHeaderField(""X-Response-ID""));
     } else {
@@ -556,9 +556,11 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     HttpURLConnection request1 = openConnection(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
     assertEquals(""1"", request1.getHeaderField(""X-Response-ID""));
 
     URLConnection request2 = openConnection(url);
+    request2.getInputStream().close();
     if (expectCached) {
       assertEquals(""1"", request2.getHeaderField(""X-Response-ID""));
     } else {
@@ -169,7 +169,7 @@ Call get() {
           // Do not signal the callback twice!
           logger.log(Level.INFO, ""Callback failure for "" + toLoggableString(), e);
         } else {
-          responseCallback.onFailure(originalRequest, e);
+          responseCallback.onFailure(engine.getRequest(), e);
         }
       } finally {
         client.getDispatcher().finished(this);
@@ -31,6 +31,7 @@
 import java.net.Socket;
 import java.net.URL;
 import java.security.cert.X509Certificate;
+import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLSocket;
 
 import okio.Source;
@@ -406,8 +407,8 @@ private void makeTunnel(Request request, int readTimeout, int writeTimeout)
       // it before proceeding.
       long contentLength = OkHeaders.contentLength(response);
       if (contentLength != -1) {
-        Source body = tunnelConnection.newFixedLengthSource(null, contentLength);
-        Util.skipAll(body, Integer.MAX_VALUE);
+        Source body = tunnelConnection.newFixedLengthSource(contentLength);
+        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
       } else {
         tunnelConnection.emptyResponseBody();
       }
@@ -21,6 +21,7 @@
 import java.io.EOFException;
 import java.io.File;
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.io.UnsupportedEncodingException;
 import java.net.ServerSocket;
 import java.net.Socket;
@@ -37,13 +38,12 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Source;
 
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
 /** Junk drawer of utility methods. */
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
@@ -174,17 +174,44 @@ public static void deleteContents(File dir) throws IOException {
     }
   }
 
-  /** Reads until {@code in} is exhausted or the timeout has elapsed. */
-  public static boolean skipAll(Source in, int timeoutMillis) throws IOException {
-    // TODO: Implement deadlines everywhere so they can do this work.
-    long startNanos = System.nanoTime();
-    Buffer skipBuffer = new Buffer();
-    while (NANOSECONDS.toMillis(System.nanoTime() - startNanos) < timeoutMillis) {
-      long read = in.read(skipBuffer, 2048);
-      if (read == -1) return true; // Successfully exhausted the stream.
-      skipBuffer.clear();
+  /**
+   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
+   * a complete source is helpful, such as when doing so completes a cache body or frees a socket
+   * connection for reuse.
+   */
+  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
+    try {
+      return skipAll(source, timeout, timeUnit);
+    } catch (IOException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
+   * extend the deadline if one exists already.
+   */
+  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
+    long now = System.nanoTime();
+    long originalDuration = source.timeout().hasDeadline()
+        ? source.timeout().deadlineNanoTime() - now
+        : Long.MAX_VALUE;
+    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
+    try {
+      Buffer skipBuffer = new Buffer();
+      while (source.read(skipBuffer, 2048) != -1) {
+        skipBuffer.clear();
+      }
+      return true; // Success! The source has been exhausted.
+    } catch (InterruptedIOException e) {
+      return false; // We ran out of time before exhausting the source.
+    } finally {
+      if (originalDuration == Long.MAX_VALUE) {
+        source.timeout().clearDeadline();
+      } else {
+        source.timeout().deadlineNanoTime(now + originalDuration);
+      }
     }
-    return false; // Ran out of time.
   }
 
   /** Returns a 32 character string containing an MD5 hash of {@code s}. */
@@ -26,7 +26,6 @@
 import java.net.ProtocolException;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
-import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -38,6 +37,7 @@
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
 import static com.squareup.okhttp.internal.http.Transport.DISCARD_STREAM_TIMEOUT_MILLIS;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 /**
  * A socket connection that can be used to send HTTP/1.1 messages. This class
@@ -90,10 +90,10 @@ public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
 
   public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
     if (readTimeoutMillis != 0) {
-      source.timeout().timeout(readTimeoutMillis, TimeUnit.MILLISECONDS);
+      source.timeout().timeout(readTimeoutMillis, MILLISECONDS);
     }
     if (writeTimeoutMillis != 0) {
-      sink.timeout().timeout(writeTimeoutMillis, TimeUnit.MILLISECONDS);
+      sink.timeout().timeout(writeTimeoutMillis, MILLISECONDS);
     }
   }
 
@@ -211,26 +211,6 @@ public void readHeaders(Headers.Builder builder) throws IOException {
     }
   }
 
-  /**
-   * Discards the response body so that the connection can be reused and the
-   * cache entry can be completed. This needs to be done judiciously, since it
-   * delays the current request in order to speed up a potential future request
-   * that may never occur.
-   */
-  public boolean discard(Source in, int timeoutMillis) {
-    try {
-      int socketTimeout = socket.getSoTimeout();
-      socket.setSoTimeout(timeoutMillis);
-      try {
-        return Util.skipAll(in, timeoutMillis);
-      } finally {
-        socket.setSoTimeout(socketTimeout);
-      }
-    } catch (IOException e) {
-      return false;
-    }
-  }
-
   public Sink newChunkedSink() {
     if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_WRITING_REQUEST_BODY;
@@ -249,32 +229,30 @@ public void writeRequestBody(RetryableSink requestBody) throws IOException {
     requestBody.writeToSocket(sink);
   }
 
-  public Source newFixedLengthSource(CacheRequest cacheRequest, long length)
-      throws IOException {
+  public Source newFixedLengthSource(long length) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthSource(cacheRequest, length);
+    return new FixedLengthSource(length);
   }
 
   /**
    * Call this to advance past a response body for HTTP responses that do not
    * have a response body.
    */
   public void emptyResponseBody() throws IOException {
-    newFixedLengthSource(null, 0L); // Transition to STATE_IDLE.
+    newFixedLengthSource(0L); // Transition to STATE_IDLE.
   }
 
-  public Source newChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine)
-      throws IOException {
+  public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(cacheRequest, httpEngine);
+    return new ChunkedSource(httpEngine);
   }
 
-  public Source newUnknownLengthSource(CacheRequest cacheRequest) throws IOException {
+  public Source newUnknownLengthSource() throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new UnknownLengthSource(cacheRequest);
+    return new UnknownLengthSource();
   }
 
   /** An HTTP body with a fixed length known in advance. */
@@ -370,40 +348,15 @@ private void writeHex(long i) throws IOException {
   }
 
   private class AbstractSource {
-    private final CacheRequest cacheRequest;
-    protected final BufferedSink cacheBody;
     protected boolean closed;
 
-    AbstractSource(CacheRequest cacheRequest) throws IOException {
-      // Some apps return a null body; for compatibility we treat that like a null cache request.
-      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
-      if (cacheBody == null) {
-        cacheRequest = null;
-      }
-
-      this.cacheBody = cacheBody != null ? Okio.buffer(cacheBody) : null;
-      this.cacheRequest = cacheRequest;
-    }
-
-    /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
-    protected final void cacheWrite(Buffer source, long byteCount) throws IOException {
-      if (cacheBody != null) {
-        source.copyTo(cacheBody.buffer(), source.size() - byteCount, byteCount);
-        cacheBody.emitCompleteSegments();
-      }
-    }
-
     /**
      * Closes the cache entry and makes the socket available for reuse. This
      * should be invoked when the end of the body has been reached.
      */
     protected final void endOfInput(boolean recyclable) throws IOException {
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException(""state: "" + state);
 
-      if (cacheRequest != null) {
-        cacheBody.close();
-      }
-
       state = STATE_IDLE;
       if (recyclable && onIdle == ON_IDLE_POOL) {
         onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
@@ -427,9 +380,6 @@ protected final void endOfInput(boolean recyclable) throws IOException {
      * to cancel the transfer, closing the connection is the only solution.
      */
     protected final void unexpectedEndOfInput() {
-      if (cacheRequest != null) {
-        cacheRequest.abort();
-      }
       Util.closeQuietly(connection.getSocket());
       state = STATE_CLOSED;
     }
@@ -439,28 +389,25 @@ protected final void unexpectedEndOfInput() {
   private class FixedLengthSource extends AbstractSource implements Source {
     private long bytesRemaining;
 
-    public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOException {
-      super(cacheRequest);
+    public FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
         endOfInput(true);
       }
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
       if (closed) throw new IllegalStateException(""closed"");
       if (bytesRemaining == 0) return -1;
 
       long read = source.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised content length
+        unexpectedEndOfInput(); // The server didn't supply the promised content length.
         throw new ProtocolException(""unexpected end of stream"");
       }
 
       bytesRemaining -= read;
-      cacheWrite(sink, read);
       if (bytesRemaining == 0) {
         endOfInput(true);
       }
@@ -474,7 +421,8 @@ public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOExcept
     @Override public void close() throws IOException {
       if (closed) return;
 
-      if (bytesRemaining != 0 && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
+      if (bytesRemaining != 0
+          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
         unexpectedEndOfInput();
       }
 
@@ -489,13 +437,11 @@ private class ChunkedSource extends AbstractSource implements Source {
     private boolean hasMoreChunks = true;
     private final HttpEngine httpEngine;
 
-    ChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
-      super(cacheRequest);
+    ChunkedSource(HttpEngine httpEngine) throws IOException {
       this.httpEngine = httpEngine;
     }
 
-    @Override public long read(
-        Buffer sink, long byteCount) throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
       if (closed) throw new IllegalStateException(""closed"");
       if (!hasMoreChunks) return -1;
@@ -507,16 +453,15 @@ private class ChunkedSource extends AbstractSource implements Source {
 
       long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised chunk length
+        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
         throw new IOException(""unexpected end of stream"");
       }
       bytesRemainingInChunk -= read;
-      cacheWrite(sink, read);
       return read;
     }
 
     private void readChunkSize() throws IOException {
-      // read the suffix of the previous chunk
+      // Read the suffix of the previous chunk.
       if (bytesRemainingInChunk != NO_CHUNK_YET) {
         source.readUtf8LineStrict();
       }
@@ -545,7 +490,7 @@ private void readChunkSize() throws IOException {
 
     @Override public void close() throws IOException {
       if (closed) return;
-      if (hasMoreChunks && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
+      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
         unexpectedEndOfInput();
       }
       closed = true;
@@ -556,10 +501,6 @@ private void readChunkSize() throws IOException {
   class UnknownLengthSource extends AbstractSource implements Source {
     private boolean inputExhausted;
 
-    UnknownLengthSource(CacheRequest cacheRequest) throws IOException {
-      super(cacheRequest);
-    }
-
     @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
@@ -572,7 +513,6 @@ class UnknownLengthSource extends AbstractSource implements Source {
         endOfInput(false);
         return -1;
       }
-      cacheWrite(sink, read);
       return read;
     }
 
@@ -582,7 +522,6 @@ class UnknownLengthSource extends AbstractSource implements Source {
 
     @Override public void close() throws IOException {
       if (closed) return;
-      // TODO: discard unknown length streams for best caching?
       if (!inputExhausted) {
         unexpectedEndOfInput();
       }
@@ -28,6 +28,7 @@
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
 import java.io.InputStream;
@@ -48,6 +49,7 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Timeout;
 
 import static com.squareup.okhttp.internal.Util.closeQuietly;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
@@ -63,6 +65,7 @@
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -709,14 +712,71 @@ public void readResponse(boolean forWebSocket) throws IOException {
     if (!hasResponseBody()) {
       if (!forWebSocket) {
         // Don't call initContentStream() when the response doesn't have any content.
-        responseTransferSource = transport.getTransferStream(storeRequest);
+        responseTransferSource = transport.getTransferStream();
         responseBody = Okio.buffer(responseTransferSource);
       }
       return;
     }
 
     maybeCache();
-    initContentStream(transport.getTransferStream(storeRequest));
+    initContentStream(cacheWritingSource(storeRequest, transport.getTransferStream()));
+  }
+
+  /**
+   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+   * may never exhaust the source stream and therefore not complete the cached response.
+   */
+  private Source cacheWritingSource(final CacheRequest cacheRequest, final Source source)
+      throws IOException {
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
+    if (cacheRequest == null) return source;
+    Sink cacheBodyUnbuffered = cacheRequest.body();
+    if (cacheBodyUnbuffered == null) return source;
+
+    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+    return new Source() {
+      boolean cacheRequestClosed;
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        long bytesRead;
+        try {
+          bytesRead = source.read(sink, byteCount);
+        } catch (IOException e) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheRequest.abort(); // Failed to write a complete cache response.
+          }
+          throw e;
+        }
+
+        if (bytesRead == -1) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheBody.close(); // The cache response is complete!
+          }
+          return -1;
+        }
+
+        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+        cacheBody.emitCompleteSegments();
+        return bytesRead;
+      }
+
+      @Override public Timeout timeout() {
+        return source.timeout();
+      }
+
+      @Override public void close() throws IOException {
+        if (!cacheRequestClosed
+            && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+          cacheRequestClosed = true;
+          cacheRequest.abort();
+        }
+        source.close();
+      }
+    };
   }
 
   /**
@@ -108,24 +108,24 @@ public void writeRequestHeaders(Request request) throws IOException {
     httpConnection.emptyResponseBody();
   }
 
-  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
+  @Override public Source getTransferStream() throws IOException {
     if (!httpEngine.hasResponseBody()) {
-      return httpConnection.newFixedLengthSource(cacheRequest, 0);
+      return httpConnection.newFixedLengthSource(0);
     }
 
     if (""chunked"".equalsIgnoreCase(httpEngine.getResponse().header(""Transfer-Encoding""))) {
-      return httpConnection.newChunkedSource(cacheRequest, httpEngine);
+      return httpConnection.newChunkedSource(httpEngine);
     }
 
     long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
     if (contentLength != -1) {
-      return httpConnection.newFixedLengthSource(cacheRequest, contentLength);
+      return httpConnection.newFixedLengthSource(contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
     // ""socketIn"" directly here), so that we can control its use after the
     // reference escapes.
-    return httpConnection.newUnknownLengthSource(cacheRequest);
+    return httpConnection.newUnknownLengthSource();
   }
 
   @Override public void disconnect(HttpEngine engine) throws IOException {
@@ -33,13 +33,9 @@
 import java.util.Locale;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.BufferedSink;
 import okio.ByteString;
-import okio.Okio;
 import okio.Sink;
 import okio.Source;
-import okio.Timeout;
 
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
@@ -212,8 +208,8 @@ public static Response.Builder readNameValueBlock(List<Header> headerBlock,
     // Do nothing.
   }
 
-  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
-    return new SpdySource(stream, cacheRequest);
+  @Override public Source getTransferStream() throws IOException {
+    return stream.getSource();
   }
 
   @Override public void releaseConnectionOnIdle() {
@@ -237,86 +233,4 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       throw new AssertionError(protocol);
     }
   }
-
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private static class SpdySource implements Source {
-    private final SpdyStream stream;
-    private final Source source;
-    private final CacheRequest cacheRequest;
-    private final BufferedSink cacheBody;
-
-    private boolean inputExhausted;
-    private boolean closed;
-
-    SpdySource(SpdyStream stream, CacheRequest cacheRequest) throws IOException {
-      this.stream = stream;
-      this.source = stream.getSource();
-
-      // Some apps return a null body; for compatibility we treat that like a null cache request.
-      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
-      if (cacheBody == null) {
-        cacheRequest = null;
-      }
-
-      this.cacheBody = cacheBody != null ? Okio.buffer(cacheBody) : null;
-      this.cacheRequest = cacheRequest;
-    }
-
-    @Override public long read(Buffer buffer, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException(""byteCount < 0: "" + byteCount);
-      if (closed) throw new IllegalStateException(""closed"");
-      if (inputExhausted) return -1;
-
-      long read = source.read(buffer, byteCount);
-      if (read == -1) {
-        inputExhausted = true;
-        if (cacheRequest != null) {
-          cacheBody.close();
-        }
-        return -1;
-      }
-
-      if (cacheBody != null) {
-        buffer.copyTo(cacheBody.buffer(), buffer.size() - read, read);
-        cacheBody.emitCompleteSegments();
-      }
-
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-
-      if (!inputExhausted && cacheBody != null) {
-        discardStream(); // Could make inputExhausted true!
-      }
-
-      closed = true;
-
-      if (!inputExhausted) {
-        stream.closeLater(ErrorCode.CANCEL);
-        if (cacheRequest != null) {
-          cacheRequest.abort();
-        }
-      }
-    }
-
-    private boolean discardStream() {
-      long oldTimeoutNanos = stream.readTimeout().timeoutNanos();
-      stream.readTimeout().timeout(DISCARD_STREAM_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      try {
-        Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
-        return true;
-      } catch (IOException e) {
-        return false;
-      } finally {
-        stream.readTimeout().timeout(oldTimeoutNanos, TimeUnit.NANOSECONDS);
-      }
-    }
-  }
 }
@@ -51,8 +51,7 @@ public interface Transport {
   /** Notify the transport that no response body will be read. */
   void emptyTransferStream() throws IOException;
 
-  // TODO: make this the content stream?
-  Source getTransferStream(CacheRequest cacheRequest) throws IOException;
+  Source getTransferStream() throws IOException;
 
   /**
    * Configures the response body to pool or close the socket connection when
",True,"The commit message refers to the necessity of moving the cache writing out of the transport due to the presence of network interceptors. Network interceptors may elect to rewrite the response body, and if the original response body has already been cached, it's too late to make these changes. This explains the reason for the changes made in the code diff.",True,"The commit message describes the necessity of changes by stating that moving the cache writing out of the transport is necessary to unblock network interceptors. This is because the interceptor may elect to rewrite the response body, and if the response body has already been cached, it is too late to do so. The code diff also supports this explanation by showing that the response body is being closed after it is read, which is necessary to allow the interceptor to rewrite the response body.",True,"The commit message directly elaborates the motivation of the code change by mentioning the issue of network interceptors rewriting the response body. It explains that if the original response body has already been cached, it's too late to make changes. This clearly describes the problem that the changes are addressing and the necessity of the changes.",True,"The commit message indicates that the changes were made to unblock network interceptors, where the interceptor may elect to rewrite the response body. If they've already cached the original response body, they're too late. This suggests that the changes were made in response to a requirement or problem, specifically the need to handle response body rewriting by network interceptors.",True,The commit message directly mentions the objective of the change by stating that it is moving the cache writing out of the transport to unblock network interceptors. This implies that the change is improving the code by allowing for more flexibility and customization in handling network requests and responses.,True,"The commit message describes the change of moving the cache writing out of the transport. This is reflected in the code diff where the response body is closed after it is received, which was not present in the previous version of the code.",True,"The commit message explains that the cache writing out of the transport is necessary to unblock network interceptors. This is because if the original response body has already been cached, it's too late to intercept and rewrite the response body. This highlights the technical principle of 'caching early' to improve performance and efficiency.",True,"The commit message expresses the change of moving the cache writing out of the transport. This is done to unblock network interceptors, where the interceptor may elect to rewrite the response body. If we've already cached the original response body, we're too late. The code changes add lines to close the response body after it has been used, which aligns with the functional perspective described in the commit message.",False,"The commit message does not lack an explanation. While the change is small and simple, the explanation provided in the commit message clarifies the reason for the change, which is to unblock network interceptors. This is important because the interceptor may elect to rewrite the response body, and if the response body has already been cached, it's too late to do so."
https://github.com/spring-projects/spring-boot/commit/15de956566b0737d3e53a816a6be60ed3e41c759,Fix typo `Assert4J` -> `AssertJ`  <enter> See  <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/15de956566b0737d3e53a816a6be60ed3e41c759,"@@ -7468,7 +7468,7 @@ TIP: If multiple auto-configurations have to be defined, there is no need to ord
 
 Each test can use the runner to represent a particular use case.
 For instance, the sample below invokes a user configuration (`UserConfiguration`) and checks that the auto-configuration backs off properly.
-Invoking `run` provides a callback context that can be used with `Assert4J`.
+Invoking `run` provides a callback context that can be used with `AssertJ`.
 
 [source,java,indent=0]
 ----
",False,"The commit message only mentions a typo fix and does not reference any conventions, standards, improvements in prior commits, or implemented features. It does not explain why the change is necessary or beneficial.",True,"The commit message 'Fix typo `Assert4J` -> `AssertJ`' clearly describes the necessity of the change. The typo in the code is a mistake that needs to be corrected, and it's easy to infer that the change is made to fix an error in the code. This is a common case where the rationale for the change is not explicitly stated in the commit message.",False,"The commit message only mentions a typo fix and a pull request link, but it does not elaborate on the necessity of the change, such as describing an error scenario, mentioning an issue report, or discussing the shortcomings of the previous implementation.",True,"The commit message 'Fix typo `Assert4J` -> `AssertJ`' indicates that the change was made due to a typographical error in the code. This could be considered a problem in the process of software maintenance, as outdated or incorrect code can lead to runtime errors or unexpected behavior. In this case, the typo was causing a reference to a non-existent library, which would have resulted in a compilation error.",False,The commit message only mentions a typo fix from 'Assert4J' to 'AssertJ'. It does not directly mention any defects it fixes or improvements it makes to the code.,True,"The commit message accurately summarizes the change made in the code diff. It specifically mentions the correction of a typo, 'Assert4J' to 'AssertJ', which is also reflected in the code diff. This is a clear and concise summary of the change, pointing out the key component that was modified.",False,The commit message only mentions a typo fix and does not explain any technical principle underpinning the changes. The code diff does not provide any context to infer a technical principle.,False,The commit message only mentions a typo fix from 'Assert4J' to 'AssertJ' and does not describe any functional changes or new behaviors introduced by the code changes.,True,"The commit message clearly states that a typo was fixed, changing 'Assert4J' to 'AssertJ'. This change is small and simple, and the reason for the commit can be easily inferred from the change itself. Therefore, there was no need for an additional explanation in the commit message."
https://github.com/square/retrofit/commit/9b6bd6bbbe752fceaa4517b3eda7cd678679198d,"Use ServerError directly in sessionExpired and serverError.  <enter> This is a short step on the road to HTTP body format agnostic support. And it's not a pretty step, either. ",https://api.github.com/repos/square/retrofit/commits/9b6bd6bbbe752fceaa4517b3eda7cd678679198d,"@@ -7,7 +7,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -21,8 +21,10 @@ public interface Callback<T> {
   /**
    * The session expired or the account has been disabled. Prompt the user to
    * log in again.
+   *
+   * @param error message to show user, or null if no message was returned
    */
-  void sessionExpired();
+  void sessionExpired(ServerError error);
 
   /**
    * Couldn't reach the server. Check network settings and try again.
@@ -43,10 +45,10 @@ public interface Callback<T> {
    * We reached the server, but it encountered an error (5xx) or its response
    * was unparseable. Please try again later.
    *
-   * @param message to show user, or null if no message was returned
+   * @param error message to show user, or null if no message was returned
    * @param statusCode the HTTP response code
    */
-  void serverError(String message, int statusCode);
+  void serverError(ServerError error, int statusCode);
 
   /**
    * An unexpected error occurred. Called if the framework throws an unexpected
@@ -55,4 +57,14 @@ public interface Callback<T> {
    * would have been caught sooner. The user should try updating their client.
    */
   void unexpectedError(Throwable t);
+
+
+  /** JSON object for parsing server error responses. */
+  static class ServerError {
+    public final String message;
+
+    public ServerError(String message) {
+      this.message = message;
+    }
+  }
 }
@@ -2,15 +2,17 @@
 package retrofit.http;
 
 import com.google.gson.Gson;
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpStatus;
 import org.apache.http.StatusLine;
 import org.apache.http.client.ResponseHandler;
 import org.apache.http.entity.BufferedHttpEntity;
+import retrofit.http.Callback.ServerError;
+
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * Support for response handlers that invoke {@link Callback}.
@@ -63,14 +65,21 @@ public Void handleResponse(HttpResponse response) throws IOException {
 
     StatusLine statusLine = response.getStatusLine();
     int statusCode = statusLine.getStatusCode();
+    HttpEntity entity = response.getEntity();
 
     if (statusCode == HttpStatus.SC_UNAUTHORIZED) {
-      LOGGER.fine(""Session expired.  Request url "" + requestUrl);
-      callback.sessionExpired();
+      if (entity != null) {
+        // TODO: Use specified encoding.
+        String body = new String(HttpClients.entityToBytes(entity), ""UTF-8"");
+        LOGGER.fine(""Session expired. Body: "" + body + "". Request url "" + requestUrl);
+        callback.sessionExpired(parseServerMessage(statusCode, body));
+      } else {
+        LOGGER.fine(""Session expired.  Request url "" + requestUrl);
+        callback.sessionExpired(null);
+      }
       return null;
     }
 
-    HttpEntity entity = response.getEntity();
 
     // 2XX == successful request
     if (statusCode >= 200 && statusCode < 300) {
@@ -131,24 +140,16 @@ public Void handleResponse(HttpResponse response) throws IOException {
   /**
    * Parses a server error message.
    */
-  private String parseServerMessage(int statusCode, String body) {
+  private ServerError parseServerMessage(int statusCode, String body) {
     if (statusCode == HttpStatus.SC_BAD_GATEWAY || statusCode == HttpStatus.SC_GATEWAY_TIMEOUT
         || statusCode < 500) {
       try {
-        ServerError serverError = gson.fromJson(body, ServerError.class);
-        if (serverError != null) return serverError.message;
+        return gson.fromJson(body, ServerError.class);
       } catch (Throwable t) {
         // The server error takes precedence.
         LOGGER.log(Level.WARNING, t.getMessage(), t);
       }
     }
     return null;
   }
-
-  /**
-   * Gson POJO for parsing server error messages.
-   */
-  static class ServerError {
-    String message;
-  }
 }
@@ -1,6 +1,17 @@
 package retrofit.http;
 
 import com.google.gson.Gson;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.ResponseHandler;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Singleton;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -14,16 +25,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.ResponseHandler;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpUriRequest;
 
 /**
  * Converts Java method calls to Rest calls.
@@ -108,8 +109,8 @@ private class RestHandler implements InvocationHandler {
         url = request.getURI().toString();
 
         // The last parameter should be of type Callback<T>. Determine T.
-        Type[] genericParameterTypes = method.getGenericParameterTypes();
-        final Type resultType = getCallbackParameterType(method, genericParameterTypes);
+        Type[] resultTypes = getCallbackParameterTypes(method);
+        final Type resultType = resultTypes[resultTypes.length - 1];
         LOGGER.fine(""Sending "" + request.getMethod() + "" to "" + request.getURI());
         final Date start = new Date();
         startTime = dateFormat.get().format(start);
@@ -183,44 +184,36 @@ private <T> ProfilingResponseHandler<T> createProfiler(ResponseHandler<Void> han
 
       return responseHandler;
     }
+  }
 
-    private static final String NOT_CALLBACK =
-        ""Last parameter of %s must be"" + "" of type Callback<X> or Callback<? super X>."";
-
-    /** Gets the callback parameter type. */
-    private Type getCallbackParameterType(Method method, Type[] parameterTypes) {
-      Type lastType = parameterTypes[parameterTypes.length - 1];
-
-      /*
-       * Note: When more than one parameter is present, we seem to get
-       * ParameterizedType Callback<? extends Object> instead of
-       * WilcardType Callback<? super Foo> like we expected. File a bug.
-       */
-      if (lastType instanceof ParameterizedType) {
-        ParameterizedType pType = (ParameterizedType) lastType;
-        if (pType.getRawType() != Callback.class) {
-          throw notCallback(method);
-        }
-        return pType.getActualTypeArguments()[0];
-      }
-
-      if (lastType instanceof WildcardType) {
-        // Example: ? super SimpleResponse
-        // Use the lower bound.
-        WildcardType wildcardType = (WildcardType) lastType;
-        Type[] lowerBounds = wildcardType.getLowerBounds();
-        if (lowerBounds.length != 1) {
-          throw notCallback(method);
+  /** Get the callback parameter types. */
+  static Type[] getCallbackParameterTypes(Method method) {
+    Type[] parameterTypes = method.getGenericParameterTypes();
+    Type callbackType = parameterTypes[parameterTypes.length - 1];
+    Class<?> callbackClass;
+    if (callbackType instanceof Class) {
+      callbackClass = (Class<?>) callbackType;
+    } else if (callbackType instanceof ParameterizedType) {
+      callbackClass = (Class<?>) ((ParameterizedType) callbackType).getRawType();
+    } else {
+      throw new ClassCastException(
+          String.format(""Last parameter of %s must be a Class or ParameterizedType"", method));
+    }
+    if (Callback.class.isAssignableFrom(callbackClass)) {
+      callbackType = Types.getGenericSupertype(callbackType, callbackClass, Callback.class);
+      if (callbackType instanceof ParameterizedType) {
+        Type[] types = ((ParameterizedType) callbackType).getActualTypeArguments();
+        for (int i = 0; i < types.length; i++) {
+          Type type = types[i];
+          if (type instanceof WildcardType) {
+            types[i] = ((WildcardType) type).getUpperBounds()[0];
+          }
         }
-        return lowerBounds[0];
+        return types;
       }
-
-      throw notCallback(method);
-    }
-
-    private IllegalArgumentException notCallback(Method method) {
-      return new IllegalArgumentException(String.format(NOT_CALLBACK, method));
     }
+    throw new IllegalArgumentException(
+        String.format(""Last parameter of %s must be of type Callback<X,Y,Z> or Callback<? super X,..,..>."", method));
   }
 
   /** Sends server call times and response status codes to {@link HttpProfiler}. */
@@ -0,0 +1,52 @@
+// Copyright 2012 Square, Inc.
+package retrofit.http;
+
+/**
+ * Helper methods for dealing with generic types via reflection.
+ *
+ * @author Jake Wharton (jw@squareup.com)
+ */
+import java.lang.reflect.Type;
+
+class Types {
+  /**
+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   * <p/>
+   * NOTE: This method is copied from Guice's {@code MoreTypes} class.
+   */
+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+    if (toResolve == rawType) {
+      return context;
+    }
+
+    // we skip searching through interfaces if unknown is an interface
+    if (toResolve.isInterface()) {
+      Class<?>[] interfaces = rawType.getInterfaces();
+      for (int i = 0, length = interfaces.length; i < length; i++) {
+        if (interfaces[i] == toResolve) {
+          return rawType.getGenericInterfaces()[i];
+        } else if (toResolve.isAssignableFrom(interfaces[i])) {
+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+        }
+      }
+    }
+
+    // check our supertypes
+    if (!rawType.isInterface()) {
+      while (rawType != Object.class) {
+        Class<?> rawSupertype = rawType.getSuperclass();
+        if (rawSupertype == toResolve) {
+          return rawType.getGenericSuperclass();
+        } else if (toResolve.isAssignableFrom(rawSupertype)) {
+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+        }
+        rawType = rawSupertype;
+      }
+    }
+
+    // we can't resolve this further
+    return toResolve;
+  }
+}
\ No newline at end of file
@@ -29,10 +29,10 @@ public void run() {
     });
   }
 
-  public void sessionExpired() {
+  public void sessionExpired(final ServerError error) {
     mainThread.execute(new Runnable() {
       public void run() {
-        delegate.sessionExpired();
+        delegate.sessionExpired(error);
       }
     });
   }
@@ -53,10 +53,10 @@ public void run() {
     });
   }
 
-  public void serverError(final String message, final int statusCode) {
+  public void serverError(final ServerError error, final int statusCode) {
     mainThread.execute(new Runnable() {
       public void run() {
-        delegate.serverError(message, statusCode);
+        delegate.serverError(error, statusCode);
       }
     });
   }
@@ -224,7 +224,7 @@ private class MyCallback implements Callback<SimpleResponse> {
     @Override public void call(SimpleResponse simpleResponse) {
     }
 
-    @Override public void sessionExpired() {
+    @Override public void sessionExpired(ServerError error) {
     }
 
     @Override public void networkError() {
@@ -233,7 +233,7 @@ private class MyCallback implements Callback<SimpleResponse> {
     @Override public void clientError(SimpleResponse response, int statusCode) {
     }
 
-    @Override public void serverError(String message, int statusCode) {
+    @Override public void serverError(ServerError error, int statusCode) {
     }
 
     @Override public void unexpectedError(Throwable t) {
@@ -1,6 +1,7 @@
 package retrofit.http;
 
 import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
 import org.apache.http.HttpMessage;
 import org.apache.http.HttpResponse;
 import org.apache.http.ProtocolVersion;
@@ -15,12 +16,16 @@
 import org.easymock.Capture;
 import org.easymock.IAnswer;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import javax.inject.Named;
 import javax.inject.Provider;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.List;
 import java.util.concurrent.Executor;
 
 import static org.easymock.EasyMock.capture;
@@ -251,6 +256,47 @@ public class RestAdapterTest {
     verifyAll();
   }
 
+  @Test public void testConcreteCallbackTypes() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""a""))).as(""a"").isEqualTo(expected);
+  }
+
+  @Test public void testConcreteCallbackTypesWithParams() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""b""))).as(""b"").isEqualTo(expected);
+  }
+
+  @Test public void testGenericCallbackTypes() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""c""))).as(""c"").isEqualTo(expected);
+  }
+
+  @Test public void testGenericCallbackTypesWithParams() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""d""))).as(""d"").isEqualTo(expected);
+  }
+
+  @Test public void testWildcardGenericCallbackTypes() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""e""))).as(""e"").isEqualTo(expected);
+  }
+
+  @Test public void testGenericCallbackWithGenericType() {
+    Type[] expected = new Type[] { new TypeToken<List<String>>() {}.getType() };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""f""))).as(""f"").isEqualTo(expected);
+  }
+
+  @Ignore // TODO support this case!
+  @Test public void testExtendingGenericCallback() {
+    Type[] expected = new Type[] { Response.class };
+    assertThat(RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""g""))).as(""g"").isEqualTo(expected);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testMissingCallbackTypes() {
+    RestAdapter.getCallbackParameterTypes(getTypeTestMethod(""h""));
+  }
+
   //
   // Utility Methods:
   //
@@ -432,6 +478,33 @@ public Response(String text) {
     @Override public boolean equals(Object obj) {
       return obj instanceof Response && text.equals(((Response)obj).text);
     }
+  }
+
+  @SuppressWarnings(""UnusedDeclaration"")
+  private interface TypeTestService {
+    @GET(ENTITY) void a(ResponseCallback c);
+    @GET(ENTITY) void b(@Named(""id"") String id, ResponseCallback c);
+    @GET(ENTITY) void c(Callback<Response> c);
+    @GET(ENTITY) void d(@Named(""id"") String id, Callback<Response> c);
+    @GET(ENTITY) void e(Callback<? extends Response> c);
+    @GET(ENTITY) void f(Callback<List<String>> c);
+    @GET(ENTITY) void g(ExtendingCallback<Response> callback);
+    @GET(ENTITY) void h(@Named(""id"") String id);
+  }
+
+  private static Method getTypeTestMethod(String name) {
+    Method[] methods = TypeTestService.class.getDeclaredMethods();
+    for (Method method : methods) {
+      if (method.getName().equals(name)) {
+        return method;
+      }
+    }
+    throw new IllegalArgumentException(""Unknown method '"" + name + ""' on "" + TypeTestService.class.getSimpleName());
+  }
+
+  private interface ResponseCallback extends Callback<Response> {
+  }
 
+  private interface ExtendingCallback<T> extends Callback<T> {
   }
 }
@@ -7,7 +7,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -26,7 +26,7 @@
 
   <groupId>com.squareup</groupId>
   <artifactId>retrofit</artifactId>
-  <version>0.7.0-SNAPSHOT</version>
+  <version>0.8.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit</name>
@@ -7,7 +7,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -7,7 +7,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -7,7 +7,7 @@
   <parent>
     <artifactId>retrofit</artifactId>
     <groupId>com.squareup</groupId>
-    <version>0.7.0-SNAPSHOT</version>
+    <version>0.8.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>retrofit-sync</artifactId>
",True,The commit message refers to the necessity of changes by mentioning the need for HTTP body format agnostic support. This is a reference to a convention or standard that the changes are being made to comply with.,True,"The commit message refers to the necessity of changes by mentioning the need for 'HTTP body format agnostic support'. This is not a common sense or easy to infer change, but rather a specific requirement for the project. The changes made in the code diff are directly related to this requirement.",True,The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that the changes are a 'short step' on the road to 'HTTP body format agnostic support' and that this is not a 'pretty step'. This implies that the previous implementation had some shortcomings or limitations that the changes are addressing.,True,"The commit message indicates that the developer is updating the version of a dependency (Retrofit) to a newer version (0.8.0-SNAPSHOT). This is likely due to the need for software development to incorporate new features or updates from the dependency. Additionally, the message mentions that this is a step towards HTTP body format agnostic support, which could imply that the new version of Retrofit has improved support for handling different HTTP body formats. This suggests that the change is being made to address a problem or requirement in the software maintenance process.",True,"The commit message directly mentions the change that it is making to the code. Specifically, it states that the change is 'a short step on the road to HTTP body format agnostic support' and that it is 'not a pretty step, either'. This implies that the change is being made to improve the codebase and to address a specific issue or limitation.",True,"The commit message describes the changes made to the codebase by summarizing the key components of the change. Specifically, it mentions that the ServerError class is now being used directly in the sessionExpired and serverError methods. This is a clear and concise summary of the changes made in the code diff.",True,"The commit message explains that the change is a step towards HTTP body format agnostic support. This is a technical principle underpinning the changes, as it involves modifying the way the server error messages are handled to make the system more flexible and adaptable to different data formats.",True,"The commit message expresses a change in the usage of ServerError directly in sessionExpired and serverError methods. It also mentions that this is a step towards HTTP body format agnostic support, which implies that the ServerError class is now being used to parse server error responses. This change introduces new behaviors, such as the ability to handle server error messages in a more structured way.",False,"The commit message does not lack an explanation. While the change is small and simple, the commit message explains that this is a step towards HTTP body format agnostic support, which is a significant change that requires explanation."
https://github.com/square/retrofit/commit/3bdad39745db76928fce0f31b3c2a8e8922c40b3,Properly name ignored exception in 'catch' block. ,https://api.github.com/repos/square/retrofit/commits/3bdad39745db76928fce0f31b3c2a8e8922c40b3,"@@ -173,7 +173,7 @@ private static boolean hasRxJavaOnClasspath() {
     try {
       Class.forName(""rx.Observable"");
       return true;
-    } catch (ClassNotFoundException e) {
+    } catch (ClassNotFoundException ignored) {
     }
     return false;
   }
",True,"The commit message 'Properly name ignored exception in 'catch' block' refers to a convention or standard, which is to name exceptions that are intentionally ignored. In this case, the exception 'ignored' is named appropriately to indicate that it is not being used in any way, which is a common convention to improve code readability and maintainability.",True,"The commit message 'Properly name ignored exception in 'catch' block.' clearly describes the necessity of the change. It is common sense that ignoring exceptions without proper naming can lead to confusion and potential bugs. The code diff also supports this, as it shows that the exception was previously named 'e' and is now named 'ignored', which makes it clear that the exception is intentionally being ignored.",True,"The commit message 'Properly name ignored exception in 'catch' block.' directly elaborates the motivation of the code change. It mentions that the exception in the 'catch' block was previously named 'e' but is now named 'ignored'. This change likely improves the readability of the code, making it clear that the exception is intentionally ignored.",True,"The commit message 'Properly name ignored exception in 'catch' block' indicates that the developer made a change to improve the code readability and maintainability. The change from 'e' to 'ignored' suggests that the exception was previously unintentionally ignored, which could potentially lead to unnoticed errors or bugs in the software. This could be considered a problem in the process of software maintenance, as unintentionally ignored exceptions can make debugging and troubleshooting more difficult.",True,"The commit message 'Properly name ignored exception in 'catch' block.' directly mentions the change made to the code, which is to properly name the ignored exception. This change improves the readability and clarity of the code, as it makes it clear that the exception is intentionally ignored.",True,"The commit message 'Properly name ignored exception in 'catch' block.' accurately summarizes the change in the diff. It clearly points out that the exception in the 'catch' block has been renamed from 'e' to 'ignored', which indicates that the exception is intentionally being ignored.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that the exception is being properly named. The code diff shows that the exception was previously named 'e' and has been renamed to 'ignored'. However, this does not necessarily imply any underlying technical principle.",True,"The commit message 'Properly name ignored exception in 'catch' block.' accurately summarizes the code change. It explains that the change is a renaming of an exception variable from 'e' to 'ignored' in a 'catch' block. This change does not introduce new behaviors or functionalities, but it improves the code readability by clearly indicating that the exception is intentionally ignored.",False,"The commit message does not lack an explanation. Even though the change is small and simple, the reason for the change is not immediately clear from the diff. The variable name 'e' was changed to 'ignored', which could imply that the exception is no longer being handled, but the commit message explicitly states that it is being properly named. This shows that the commit message is providing additional context beyond what can be inferred from the code diff."
https://github.com/square/okhttp/commit/abb0a790802996d1039c35424b70b0f3f06b94b7,First step towards HTTP/2 automatic pings. ( <pr_link> )  <enter> This changes the executor services in HTTP/2 connection to split up listener executors (of which there may be many threads) from writer executors (of which there is one per connection). <enter> This adds a scheduled executor job to send pings on an interval. We don't yet fail the connection if pongs are not received. <enter> For follow-up there's some work to remove exising APIs to send pings through the HTTP/2 APIs. These are unused and make it awkard to confirm that only the automatic pings are being replied to. <enter> See  <issue_link> ,https://api.github.com/repos/square/okhttp/commits/abb0a790802996d1039c35424b70b0f3f06b94b7,"@@ -28,6 +28,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.net.ssl.HostnameVerifier;
@@ -54,20 +55,19 @@
 import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.PushPromise;
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.mockwebserver.internal.tls.SslClient;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
-import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -922,15 +922,52 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertThat(""data logged"", firstFrame(logs, ""DATA""), containsString(""0 DATA          END_STREAM""));
   }
 
+  @Test public void pingsTransmitted() throws Exception {
+    // Ping every 500 ms, starting at 500 ms.
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    // Delay the response to give 1 ping enough time to be sent and replied to.
+    server.enqueue(new MockResponse()
+        .setBodyDelay(750, TimeUnit.MILLISECONDS)
+        .setBody(""ABC""));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url(""/""))
+        .build());
+    Response response = call.execute();
+    assertEquals(""ABC"", response.body().string());
+
+    assertEquals(Protocol.HTTP_2, response.protocol());
+
+    // Confirm a single ping was sent and received, and its reply was sent and received.
+    List<String> logs = http2Handler.takeAll();
+    assertEquals(1, countFrames(logs, ""FINE: >> 0x00000000     8 PING          ""));
+    assertEquals(1, countFrames(logs, ""FINE: << 0x00000000     8 PING          ""));
+    assertEquals(1, countFrames(logs, ""FINE: >> 0x00000000     8 PING          ACK""));
+    assertEquals(1, countFrames(logs, ""FINE: << 0x00000000     8 PING          ACK""));
+  }
+
   private String firstFrame(List<String> logs, String type) {
-    for (String l: logs) {
-      if (l.contains(type)) {
-        return l;
+    for (String log: logs) {
+      if (log.contains(type)) {
+        return log;
       }
     }
     return null;
   }
 
+  private int countFrames(List<String> logs, String message) {
+    int result = 0;
+    for (String log: logs) {
+      if (log.equals(message)) {
+        result++;
+      }
+    }
+    return result;
+  }
+
   /**
    * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
    * confirm that the third concurrent request prepared a new connection.
@@ -568,14 +568,15 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
     }
 
     /**
-     * Sets the interval between web socket pings initiated by this client. Use this to
-     * automatically send web socket ping frames until either the web socket fails or it is closed.
-     * This keeps the connection alive and may detect connectivity failures.
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
      *
      * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens the connection is
-     * canceled and its listener is {@linkplain WebSocketListener#onFailure notified of the
-     * failure}.
+     * client will assume that connectivity has been lost. When this happens on a web socket the
+     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
      *
      * <p>The default value of 0 disables client-initiated pings.
      */
@@ -128,7 +128,8 @@ public static RealConnection testConnection(
   }
 
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled, Call call, EventListener eventListener) {
+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,
+      EventListener eventListener) {
     if (protocol != null) throw new IllegalStateException(""already connected"");
 
     RouteException routeException = null;
@@ -158,7 +159,7 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         } else {
           connectSocket(connectTimeout, readTimeout, call, eventListener);
         }
-        establishProtocol(connectionSpecSelector, call, eventListener);
+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
         break;
       } catch (IOException e) {
@@ -257,8 +258,8 @@ private void connectSocket(int connectTimeout, int readTimeout, Call call,
     }
   }
 
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Call call,
-      EventListener eventListener) throws IOException {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
+      int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
     if (route.address().sslSocketFactory() == null) {
       protocol = Protocol.HTTP_1_1;
       socket = rawSocket;
@@ -274,6 +275,7 @@ private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Ca
       http2Connection = new Http2Connection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
           .listener(this)
+          .pingIntervalMillis(pingIntervalMillis)
           .build();
       http2Connection.start();
     }
@@ -107,11 +107,12 @@ public HttpCodec newStream(
     int connectTimeout = chain.connectTimeoutMillis();
     int readTimeout = chain.readTimeoutMillis();
     int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
     boolean connectionRetryEnabled = client.retryOnConnectionFailure();
 
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
       HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
 
       synchronized (connectionPool) {
@@ -128,11 +129,11 @@ public HttpCodec newStream(
    * until a healthy connection is found.
    */
   private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException {
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
     while (true) {
       RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          connectionRetryEnabled);
+          pingIntervalMillis, connectionRetryEnabled);
 
       // If this is a brand new connection, we can skip the extensive health checks.
       synchronized (connectionPool) {
@@ -157,7 +158,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    * then the pool, finally building a new connection.
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException {
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
     boolean foundPooledConnection = false;
     RealConnection result = null;
     Route selectedRoute = null;
@@ -253,8 +254,8 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     }
 
     // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(
-        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
     routeDatabase().connected(result.route());
 
     Socket socket = null;
@@ -27,6 +27,8 @@
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -40,6 +42,7 @@
 import okio.ByteString;
 import okio.Okio;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.http2.ErrorCode.REFUSED_STREAM;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.platform.Platform.INFO;
@@ -67,7 +70,13 @@ public final class Http2Connection implements Closeable {
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  static final ExecutorService executor = new ThreadPoolExecutor(0,
+  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+
+  /**
+   * Shared executor to send notifications of incoming streams. This executor requires multiple
+   * threads because listeners are not required to return promptly.
+   */
+  private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory(""OkHttp Http2Connection"", true));
 
@@ -76,7 +85,7 @@ public final class Http2Connection implements Closeable {
 
   /**
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on {@link #executor}.
+   * on {@link #listenerExecutor}.
    */
   final Listener listener;
   final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
@@ -85,6 +94,9 @@ public final class Http2Connection implements Closeable {
   int nextStreamId;
   boolean shutdown;
 
+  /** Asynchronously writes frames to the outgoing socket. */
+  private final ScheduledExecutorService writerExecutor;
+
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
 
@@ -110,8 +122,6 @@ public final class Http2Connection implements Closeable {
   /** Settings we communicate to the peer. */
   Settings okHttpSettings = new Settings();
 
-  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
-
   /** Settings we receive from the peer. */
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
@@ -145,6 +155,13 @@ public final class Http2Connection implements Closeable {
 
     hostname = builder.hostname;
 
+    writerExecutor = new ScheduledThreadPoolExecutor(1,
+        Util.threadFactory(Util.format(""OkHttp %s Writer"", hostname), false));
+    if (builder.pingIntervalMillis != 0) {
+      writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0, null),
+          builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
+    }
+
     // Like newSingleThreadExecutor, except lazy creates the thread.
     pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(),
@@ -305,11 +322,12 @@ void addBytesToWriteWindow(long delta) {
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.execute(new NamedRunnable(""OkHttp %s stream %d"", hostname, streamId) {
+    writerExecutor.execute(new NamedRunnable(""OkHttp %s stream %d"", hostname, streamId) {
       @Override public void execute() {
         try {
           writeSynReset(streamId, errorCode);
-        } catch (IOException ignored) {
+        } catch (IOException e) {
+          failConnection();
         }
       }
     });
@@ -320,14 +338,16 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.execute(new NamedRunnable(""OkHttp Window Update %s stream %d"", hostname, streamId) {
-      @Override public void execute() {
-        try {
-          writer.windowUpdate(streamId, unacknowledgedBytesRead);
-        } catch (IOException ignored) {
-        }
-      }
-    });
+    writerExecutor.execute(
+        new NamedRunnable(""OkHttp Window Update %s stream %d"", hostname, streamId) {
+          @Override public void execute() {
+            try {
+              writer.windowUpdate(streamId, unacknowledgedBytesRead);
+            } catch (IOException e) {
+              failConnection();
+            }
+          }
+        });
   }
 
   /**
@@ -350,17 +370,28 @@ public Ping ping() throws IOException {
     return ping;
   }
 
-  void writePingLater(
-      final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.execute(new NamedRunnable(""OkHttp %s ping %08x%08x"",
-        hostname, payload1, payload2) {
-      @Override public void execute() {
-        try {
-          writePing(reply, payload1, payload2, ping);
-        } catch (IOException ignored) {
-        }
+  final class PingRunnable extends NamedRunnable {
+    final boolean reply;
+    final int payload1;
+    final int payload2;
+    final Ping ping;
+
+    PingRunnable(boolean reply, int payload1, int payload2, Ping ping) {
+      super(""OkHttp %s ping %08x%08x"", hostname, payload1, payload2);
+      this.reply = reply;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
+      this.ping = ping;
+    }
+
+    @Override public void execute() {
+      try {
+        // TODO(jwilson): fail the connection if replies are missing (and this is not a reply).
+        writePing(reply, payload1, payload2, ping);
+      } catch (IOException e) {
+        failConnection();
       }
-    });
+    }
   }
 
   void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
@@ -463,6 +494,13 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     if (thrown != null) throw thrown;
   }
 
+  private void failConnection() {
+    try {
+      close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR);
+    } catch (IOException ignored) {
+    }
+  }
+
   /**
    * Sends any initial frames and starts reading frames from the remote peer. This should be called
    * after {@link Builder#build} for all new connections.
@@ -512,6 +550,7 @@ public static class Builder {
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     PushObserver pushObserver = PushObserver.CANCEL;
     boolean client;
+    int pingIntervalMillis;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -545,6 +584,11 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
+    public Builder pingIntervalMillis(int pingIntervalMillis) {
+      this.pingIntervalMillis = pingIntervalMillis;
+      return this;
+    }
+
     public Http2Connection build() {
       return new Http2Connection(this);
     }
@@ -626,7 +670,7 @@ class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
               false, inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.execute(new NamedRunnable(""OkHttp %s stream %d"", hostname, streamId) {
+          listenerExecutor.execute(new NamedRunnable(""OkHttp %s stream %d"", hostname, streamId) {
             @Override public void execute() {
               try {
                 listener.onStream(newStream);
@@ -678,7 +722,7 @@ class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
             streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
           }
         }
-        executor.execute(new NamedRunnable(""OkHttp %s settings"", hostname) {
+        listenerExecutor.execute(new NamedRunnable(""OkHttp %s settings"", hostname) {
           @Override public void execute() {
             listener.onSettings(Http2Connection.this);
           }
@@ -694,11 +738,12 @@ class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
     }
 
     private void applyAndAckSettings(final Settings peerSettings) {
-      executor.execute(new NamedRunnable(""OkHttp %s ACK Settings"", hostname) {
+      writerExecutor.execute(new NamedRunnable(""OkHttp %s ACK Settings"", hostname) {
         @Override public void execute() {
           try {
             writer.applyAndAckSettings(peerSettings);
-          } catch (IOException ignored) {
+          } catch (IOException e) {
+            failConnection();
           }
         }
       });
@@ -716,7 +761,7 @@ private void applyAndAckSettings(final Settings peerSettings) {
         }
       } else {
         // Send a reply to a client ping if this is a server and vice versa.
-        writePingLater(true, payload1, payload2, null);
+        writerExecutor.execute(new PingRunnable(true, payload1, payload2, null));
       }
     }
 
",True,The commit message refers to the necessity of changes by mentioning the need to 'send pings on an interval' and 'remove existing APIs to send pings through the HTTP/2 APIs' to 'confirm that only the automatic pings are being replied to'. This highlights the importance of implementing automatic pings and removing unnecessary APIs to ensure the correct functionality of HTTP/2 connections.,True,"The commit message 'First step towards HTTP/2 automatic pings' does not explicitly describe the necessity of changes, but it is clear from the code diff and the message that the changes are being made to implement automatic pings in HTTP/2 connections. This is a significant change that improves the functionality and reliability of the HTTP/2 connections, and it is not a trivial or obvious change that can be easily inferred from the context.",True,"The commit message explains the motivation for the changes by mentioning the need to send pings on an interval to keep the connection alive and detect connectivity failures. It also mentions that the changes are part of a larger effort to remove existing APIs to send pings through the HTTP/2 APIs, which are unused and make it awkward to confirm that only the automatic pings are being replied to.",True,"The commit message indicates the necessity of changes by describing the source of the requirements. The message mentions the need for HTTP/2 automatic pings, which suggests that the developer is implementing a new feature to improve the functionality of the software. This is likely in response to user requirements or to address a problem in the process of software maintenance, such as the need to keep the connection alive and detect connectivity failures.",True,"The commit message mentions the objective of the change by directly mentioning the improvements it makes to the code. Specifically, it states that the change 'adds a scheduled executor job to send pings on an interval' and 'removes existing APIs to send pings through the HTTP/2 APIs'. These changes are related to the implementation of HTTP/2 automatic pings, which is the main focus of the commit.",True,"The commit message 'First step towards HTTP/2 automatic pings' summarizes the changes made in the code diff. It mentions the modification of executor services to split up listener executors from writer executors, the addition of a scheduled executor job to send pings on an interval, and the need for follow-up work to remove existing APIs to send pings through the HTTP/2 APIs. This highlights the key components of the change and provides a clear summary of the changes made.",True,The commit message explains that it adds a scheduled executor job to send pings on an interval. This change is a technical implementation of the principle of keeping the connection alive and detecting connectivity failures by sending periodic pings.,True,"The commit message expresses a change in the HTTP/2 connection handling, specifically splitting up listener executors from writer executors and adding a scheduled executor job to send pings on an interval. This change introduces new behaviors such as automatic pings being sent and received, which is described in the commit message and further explained in the code diff.",False,The commit message does not lack an explanation. It clearly states the reason for the commit as 'First step towards HTTP/2 automatic pings'. The commit message explains the changes made to the executor services and the addition of a scheduled executor job to send pings on an interval. It also mentions that the connection will not yet fail if pongs are not received.
https://github.com/spring-projects/spring-boot/commit/26345d39003514348ca0be2f9c350c92b5cf3ef7,Polish docs  <enter> This commit replaces tabs to spaces in a yaml example for configuring endpoint web exposure include. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/26345d39003514348ca0be2f9c350c92b5cf3ef7,"@@ -349,10 +349,10 @@ exclude) all endpoints, as shown in the following example:
 [source,yaml,indent=0]
 ----
 	management:
-		endpoints:
-			web:
-				exposure:
-					include: ""*""
+	  endpoints:
+	    web:
+	      exposure:
+	        include: ""*""
 ----
 ====
 
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that the commit replaces tabs with spaces in a yaml example, which is a formatting change and not a functional or structural change.",True,"The commit message 'Polish docs' does not explicitly explain the necessity of the changes made in the code diff. The changes are a simple formatting adjustment, replacing tabs with spaces in a YAML example. This is a common practice to ensure consistency and readability in code, and it is easy to infer that the change was made to improve the documentation's formatting.",False,"The commit message does not explicitly describe the necessity of changes. It only mentions the reason for the change as 'replacing tabs to spaces' in a yaml example. It does not elaborate on any error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message 'Polish docs' and the code diff indicate that the changes were made to improve the readability and consistency of the documentation. The use of tabs instead of spaces in the YAML example could potentially cause issues in some environments, so the change to use spaces is likely to address a problem in the software maintenance process, specifically out-of-date code that could cause inconsistencies or errors.",True,"The commit message does not explicitly mention the defects it fixes or the improvements it makes to the code. However, it does describe the change made in the code diff, which is replacing tabs with spaces in a YAML example. This change could potentially improve the readability and consistency of the code, making it easier to understand and maintain.",True,"The commit message 'Polish docs' does contain an expression that describes a summary of what changes by being a summary of the diffs. It specifically mentions the replacement of tabs to spaces in a yaml example for configuring endpoint web exposure include. This directly relates to the changes in the diff, which are the modifications made to the indentation of the yaml example.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions the replacement of tabs with spaces in a YAML example, which is a formatting change and does not involve any underlying technical principles.",True,"The commit message does not explicitly describe the code changes from a functional perspective, but it does indicate that the changes are related to documentation. When looking at the diff, it's clear that the changes are related to formatting, specifically replacing tabs with spaces in a YAML example. While this doesn't introduce new behaviors, it does improve the readability and consistency of the documentation, which can be considered a functional change from the perspective of users and maintainers.",False,"The commit message does not lack an explanation. It clearly states that the change was made to replace tabs with spaces in a YAML example for configuring endpoint web exposure. This change was made to improve the formatting and consistency of the documentation, which is a valid reason for a commit. The change might be small and simple, but it is still important to document the reason for the change to maintain clarity and consistency in the codebase."
https://github.com/spring-projects/spring-boot/commit/599792097cfc690d2adf52a6c4d4f98c44a77162,Upgrade Spring WS to 2.2.1.RELEASE  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/599792097cfc690d2adf52a6c4d4f98c44a77162,"@@ -126,7 +126,7 @@
 		<spring-social-facebook.version>1.1.1.RELEASE</spring-social-facebook.version>
 		<spring-social-linkedin.version>1.0.1.RELEASE</spring-social-linkedin.version>
 		<spring-social-twitter.version>1.1.0.RELEASE</spring-social-twitter.version>
-		<spring-ws.version>2.2.0.RELEASE</spring-ws.version>
+		<spring-ws.version>2.2.1.RELEASE</spring-ws.version>
 		<sun-mail.version>${javax-mail.version}</sun-mail.version>
 		<thymeleaf.version>2.1.4.RELEASE</thymeleaf.version>
 		<thymeleaf-extras-springsecurity3.version>2.1.1.RELEASE</thymeleaf-extras-springsecurity3.version>
",True,"The commit message 'Upgrade Spring WS to 2.2.1.RELEASE' does contain an expression that describes the necessity of changes. In this case, the necessity is the upgrade to the latest stable version of Spring WS. This is a common practice in software development to keep dependencies up-to-date for security reasons, to take advantage of new features, or to fix bugs. The code diff also supports this explanation, as it shows the version of Spring WS being updated.",True,"The commit message 'Upgrade Spring WS to 2.2.1.RELEASE' clearly and concisely describes the change made in the code diff. The necessity of the change is implied by the version number change, as it is common practice to upgrade dependencies to the latest stable release to ensure the application is using the most recent features, improvements, and bug fixes. Therefore, the commit message does not require a rationale beyond the change itself.",False,"The commit message does not explicitly describe the necessity of the changes. It only mentions that Spring WS is being upgraded to a newer version and it closes a pull request. However, it does not elaborate on any error scenario, issue report, or shortcoming of the previous implementation that necessitated this change.",True,"The commit message 'Upgrade Spring WS to 2.2.1.RELEASE' indicates that the change is being made to address a need for software development. The need is to upgrade the Spring WS version to the latest release (2.2.1.RELEASE) from the previous version (2.2.0.RELEASE). This could be due to new features, improvements, or bug fixes in the latest release that are required for the project.",True,"The commit message 'Upgrade Spring WS to 2.2.1.RELEASE' directly mentions the change made to the code, which is an upgrade to a newer version of Spring WS. This could potentially fix bugs or add new features in the newer version. Additionally, the message mentions that it closes a pull request, which suggests that the upgrade is related to a specific issue or feature request.",True,"The commit message 'Upgrade Spring WS to 2.2.1.RELEASE' clearly describes the change made in the code diff. It specifically mentions the component that was changed (Spring WS) and the version it was upgraded to (2.2.1.RELEASE). This is a direct summary of the diff, which shows the change from version 2.2.0.RELEASE to 2.2.1.RELEASE for the spring-ws dependency.",False,"The commit message only mentions the upgrade of Spring WS to a newer version, but it does not explain the technical principle or reason behind this upgrade. It does not describe any changes in the codebase that might be related to a specific technical principle.",True,"The commit message 'Upgrade Spring WS to 2.2.1.RELEASE' clearly describes the change made in the code diff. It explains that a version upgrade is being performed on Spring WS, and it specifies the new version (2.2.1.RELEASE). This change does not introduce new behaviors or functionalities, but it does modify existing behavior by upgrading the version of a dependency. However, the message does effectively summarize the changes made in the code diff from a functional perspective.",True,"The commit message 'Upgrade Spring WS to 2.2.1.RELEASE' clearly states the reason for the commit, which is to upgrade a specific library to a newer version. The change in the code diff (changing the version number of Spring WS) makes it clear that the upgrade is the purpose of the commit. Therefore, there was no need for an additional explanation in the commit message."
https://github.com/junit-team/junit4/commit/3d7de190844d92de87ca197cfd1fce74ae432f0f,Add test for handling InitializationError  <enter> The code was changed by commit  <otherCommit_link>  but unfortunately the test was not part of the commit. The test is based on Philip Graf's test in pull request  <pr_link> . <enter> Co-authored-by: Philip Graf <git@acanda.ch> ,https://api.github.com/repos/junit-team/junit4/commits/3d7de190844d92de87ca197cfd1fce74ae432f0f,"@@ -13,7 +13,7 @@
 import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunListener;
 
-class EventCollector extends RunListener {
+public class EventCollector extends RunListener {
     static Matcher<EventCollector> everyTestRunSuccessful() {
         return allOf(hasNoFailure(), hasNoAssumptionFailure());
     }
@@ -73,7 +73,7 @@ static Matcher<EventCollector> hasNoAssumptionFailure() {
         return hasNumberOfAssumptionFailures(0);
     }
 
-    static Matcher<EventCollector> hasSingleFailureWithMessage(String message) {
+    public static Matcher<EventCollector> hasSingleFailureWithMessage(String message) {
         return hasSingleFailureWithMessage(equalTo(message));
     }
 
@@ -2,8 +2,12 @@
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.rules.EventCollector.hasSingleFailureWithMessage;
 
 import org.junit.Test;
+import org.junit.rules.EventCollector;
+import org.junit.runners.model.InitializationError;
+import org.junit.runners.model.RunnerBuilder;
 
 public class RequestTest {
 
@@ -18,4 +22,29 @@ public void createsADescriptionWithANameForClasses() {
                 .getDescription();
         assertThat(description.toString(), is(""classes""));
     }
+
+    @Test
+    public void reportsInitializationErrorThrownWhileCreatingSuite() {
+        EventCollector collector = new EventCollector();
+        JUnitCore core = new JUnitCore();
+        core.addListener(collector);
+
+        core.run(new FailingComputer(), FooTest.class, BarTest.class);
+
+        assertThat(collector, hasSingleFailureWithMessage(""cannot create suite""));
+    }
+
+    private static class FailingComputer extends Computer {
+        @Override
+        public Runner getSuite(RunnerBuilder builder, Class<?>[] classes)
+                throws InitializationError {
+            throw new InitializationError(""cannot create suite"");
+        }
+    }
+
+    private static class FooTest {
+    }
+
+    private static class BarTest {
+    }
 }
",True,"The commit message explains the necessity of changes by referencing a prior commit (commit <otherCommit_link>) and a pull request (pull request <pr_link>) by Philip Graf. It mentions that the changes in the commit did not include a test, which was present in Philip Graf's pull request. This indicates that the test is necessary to ensure the correctness of the changes made in the commit.",True,"The commit message 'Add test for handling InitializationError' clearly states the reason for the changes, which is to add a test case for handling InitializationError. This is a common practice in software development and the necessity for the change is clearly explained in the commit message.",True,"The commit message directly elaborates the motivation of the code change by mentioning the 'InitializationError' that was handled in the code changes from commit <otherCommit_link>. The message also references Philip Graf's test in pull request <pr_link> and explains that the test was not part of the original commit. The added test is specifically designed to handle the 'InitializationError' scenario, which directly addresses a possible problem that could arise if the exceptions were not handled properly in the previous implementation.",True,"The commit message 'Add test for handling InitializationError' indicates that the developer added a test to handle an InitializationError, which was a problem in the process of software maintenance. The problem was that an InitializationError was being thrown while creating a suite, but there was no test to handle this error. The test was based on Philip Graf's test in a previous pull request, which suggests that the requirement for the test came from a user or a problem in the software development process.",True,"The commit message 'Add test for handling InitializationError' directly mentions the improvement it makes to the code, which is adding a test to handle the InitializationError. This is evident in the code diff where a new test method 'reportsInitializationErrorThrownWhileCreatingSuite' is added to the RequestTest class.",True,"The commit message does a good job of summarizing the changes. It mentions adding a test for handling InitializationError, which is a clear and accurate description of the new code added to the file. The diff also supports this, as it shows the addition of a new test method and several related imports.",True,"The commit message describes the technical principle underpinning the changes by mentioning the addition of a test for handling InitializationError. This indicates that the changes are made to ensure that the system can properly handle and respond to InitializationError exceptions, which is a key technical principle in robust and fault-tolerant software development.",True,"The commit message 'Add test for handling InitializationError' accurately describes the changes made to the code. The code diff shows that a new test has been added to the RequestTest class, which checks for an InitializationError that might be thrown while creating a suite. This new test introduces a new behavior in the codebase, which is the ability to handle and report InitializationErrors that occur during test suite creation.",True,"The commit message explicitly mentions adding a test for handling InitializationError. The code diff shows that a new test method has been added to the RequestTest class, which tests for this specific scenario. Therefore, there was no need for an additional explanation in the commit message."
https://github.com/square/retrofit/commit/fe6d0f9b2a68063a086fa9da80d04293fbe3becf,Introduce factory for converter concept.  <enter> This is still highly-inefficient in its internal use and there are no tests proving that we now fail earlier in configuring a service method. Both of those will come in follow up commits ,https://api.github.com/repos/square/retrofit/commits/fe6d0f9b2a68063a086fa9da80d04293fbe3becf,"@@ -49,7 +49,7 @@ interface Service {
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .callAdapterFactory(ObservableCallAdapterFactory.create())
         .build();
     service = retrofit.create(Service.class);
@@ -195,13 +195,17 @@ interface Service {
     }
   }
 
-  static class StringConverter implements Converter {
-    @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-      return body.string();
-    }
+  static class StringConverterFactory implements Converter.Factory {
+    @Override public Converter<?> get(Type type) {
+      return new Converter<String>() {
+        @Override public String fromBody(ResponseBody body) throws IOException {
+          return body.string();
+        }
 
-    @Override public RequestBody toBody(Object object, Type type) {
-      return RequestBody.create(MediaType.parse(""text/plain""), String.valueOf(object));
+        @Override public RequestBody toBody(String value) {
+          return RequestBody.create(MediaType.parse(""text/plain""), value);
+        }
+      };
     }
   }
 }
@@ -15,71 +15,48 @@
  */
 package retrofit;
 
-import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.reflect.Type;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
 import java.nio.charset.Charset;
+import okio.Buffer;
 
-/**
- * A {@link Converter} which uses GSON for serialization and deserialization of entities.
- */
-public class GsonConverter implements Converter {
-  private final Gson gson;
-  private final Charset charset;
-  private final MediaType mediaType;
-
-  /**
-   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter() {
-    this(new Gson());
-  }
+final class GsonConverter<T> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse(""application/json; charset=UTF-8"");
+  private static final Charset UTF_8 = Charset.forName(""UTF-8"");
 
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter(Gson gson) {
-    this(gson, Charset.forName(""UTF-8""));
-  }
+  private final TypeAdapter<T> typeAdapter;
 
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
-   */
-  public GsonConverter(Gson gson, Charset charset) {
-    if (gson == null) throw new NullPointerException(""gson == null"");
-    if (charset == null) throw new NullPointerException(""charset == null"");
-    this.gson = gson;
-    this.charset = charset;
-    this.mediaType = MediaType.parse(""application/json; charset="" + charset.name());
+  GsonConverter(TypeAdapter<T> typeAdapter) {
+    this.typeAdapter = typeAdapter;
   }
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    Charset charset = this.charset;
-    if (body.contentType() != null) {
-      charset = body.contentType().charset(charset);
-    }
-
-    InputStream is = body.byteStream();
+  @Override public T fromBody(ResponseBody body) throws IOException {
+    Reader in = body.charStream();
     try {
-      return gson.fromJson(new InputStreamReader(is, charset), type);
+      return typeAdapter.fromJson(in);
     } finally {
       try {
-        is.close();
+        in.close();
       } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
-    String json = gson.toJson(object, type);
-    return RequestBody.create(mediaType, json);
+  @Override public RequestBody toBody(T value) {
+    Buffer buffer = new Buffer();
+    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+    try {
+      typeAdapter.toJson(writer, value);
+      writer.flush();
+    } catch (IOException e) {
+      throw new AssertionError(e); // Writing to Buffer does no I/O.
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.reflect.TypeToken;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Gson for JSON. */
+public final class GsonConverterFactory implements Converter.Factory {
+  /**
+   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create() {
+    return create(new Gson());
+  }
+
+  /**
+   * Create an instance using {@code gson} for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create(Gson gson) {
+    return new GsonConverterFactory(gson);
+  }
+
+  private final Gson gson;
+
+  private GsonConverterFactory(Gson gson) {
+    if (gson == null) throw new NullPointerException(""gson == null"");
+    this.gson = gson;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+    return new GsonConverter<>(adapter);
+  }
+}
@@ -33,7 +33,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class GsonConverterTest {
+public final class GsonConverterFactoryTest {
   interface AnInterface {
     String getName();
   }
@@ -87,10 +87,9 @@ interface Service {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
         .create();
-    Converter converter = new GsonConverter(gson);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(GsonConverterFactory.create(gson))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -1,39 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit;
 
 import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.Type;
 
-/**
- * A {@link Converter} which uses Jackson for reading and writing entities.
- *
- * @author Kai Waldron (kaiwaldron@gmail.com)
- */
-public class JacksonConverter implements Converter {
+final class JacksonConverter<T> implements Converter<T> {
   private static final MediaType MEDIA_TYPE = MediaType.parse(""application/json; charset=UTF-8"");
 
-  private final ObjectMapper objectMapper;
+  private final ObjectWriter writer;
+  private final ObjectReader reader;
 
-  public JacksonConverter() {
-    this(new ObjectMapper());
+  JacksonConverter(ObjectWriter writer, ObjectReader reader) {
+    this.writer = writer;
+    this.reader = reader;
   }
 
-  public JacksonConverter(ObjectMapper objectMapper) {
-    if (objectMapper == null) throw new NullPointerException(""objectMapper == null"");
-    this.objectMapper = objectMapper;
-  }
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+  @Override public T fromBody(ResponseBody body) throws IOException {
     InputStream is = body.byteStream();
     try {
-      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      return objectMapper.readValue(is, javaType);
+      return reader.readValue(is);
     } finally {
       try {
         is.close();
@@ -42,11 +48,10 @@ public JacksonConverter(ObjectMapper objectMapper) {
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
+  @Override public RequestBody toBody(T value) {
     try {
-      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      String json = objectMapper.writerWithType(javaType).writeValueAsString(object);
-      return RequestBody.create(MEDIA_TYPE, json);
+      byte[] bytes = writer.writeValueAsBytes(value);
+      return RequestBody.create(MEDIA_TYPE, bytes);
     } catch (JsonProcessingException e) {
       throw new RuntimeException(e);
     }
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Jackson. */
+public final class JacksonConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
+  public static JacksonConverterFactory create() {
+    return create(new ObjectMapper());
+  }
+
+  /** Create an instance using {@code mapper} for conversion. */
+  public static JacksonConverterFactory create(ObjectMapper mapper) {
+    return new JacksonConverterFactory(mapper);
+  }
+
+  private final ObjectMapper mapper;
+
+  private JacksonConverterFactory(ObjectMapper mapper) {
+    if (mapper == null) throw new NullPointerException(""mapper == null"");
+    this.mapper = mapper;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    JavaType javaType = mapper.getTypeFactory().constructType(type);
+    ObjectWriter writer = mapper.writerWithType(javaType);
+    ObjectReader reader = mapper.reader(javaType);
+    return new JacksonConverter<>(writer, reader);
+  }
+}
@@ -119,10 +119,9 @@ interface Service {
         .getDefaultVisibilityChecker()
         .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
 
-    Converter converter = new JacksonConverter(mapper);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(JacksonConverterFactory.create(mapper))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -15,36 +15,27 @@
  */
 package retrofit;
 
-import com.squareup.moshi.Moshi;
+import com.squareup.moshi.JsonAdapter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.lang.reflect.Type;
 import okio.Buffer;
 import okio.BufferedSource;
 
-/** A {@link Converter} which uses Moshi for serialization and deserialization of entities. */
-public final class MoshiConverter implements Converter {
-  private final Moshi moshi;
-  private final MediaType mediaType;
+final class MoshiConverter<T> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse(""application/json; charset=UTF-8"");
 
-  /** Create an instance using a default {@link Moshi} instance for conversion. */
-  public MoshiConverter() {
-    this(new Moshi.Builder().build());
-  }
+  private JsonAdapter<T> adapter;
 
-  /** Create an instance using the supplied {@link Moshi} object for conversion. */
-  public MoshiConverter(Moshi moshi) {
-    if (moshi == null) throw new NullPointerException(""moshi == null"");
-    this.moshi = moshi;
-    this.mediaType = MediaType.parse(""application/json; charset=UTF-8"");
+  MoshiConverter(JsonAdapter<T> adapter) {
+    this.adapter = adapter;
   }
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+  @Override public T fromBody(ResponseBody body) throws IOException {
     BufferedSource source = body.source();
     try {
-      return moshi.adapter(type).fromJson(source);
+      return adapter.fromJson(source);
     } finally {
       try {
         source.close();
@@ -53,13 +44,13 @@ public MoshiConverter(Moshi moshi) {
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
+  @Override public RequestBody toBody(T value) {
     Buffer buffer = new Buffer();
     try {
-      moshi.adapter(type).toJson(buffer, object);
+      adapter.toJson(buffer, value);
     } catch (IOException e) {
       throw new AssertionError(e);
     }
-    return RequestBody.create(mediaType, buffer.snapshot());
+    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
   }
 }
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Moshi for JSON. */
+public final class MoshiConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Moshi} instance for conversion. */
+  public static MoshiConverterFactory create() {
+    return create(new Moshi.Builder().build());
+  }
+
+  /** Create an instance using {@code moshi} for conversion. */
+  public static MoshiConverterFactory create(Moshi moshi) {
+    return new MoshiConverterFactory(moshi);
+  }
+
+  private final Moshi moshi;
+
+  private MoshiConverterFactory(Moshi moshi) {
+    if (moshi == null) throw new NullPointerException(""moshi == null"");
+    this.moshi = moshi;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    JsonAdapter<Object> adapter = moshi.adapter(type);
+    return new MoshiConverter<>(adapter);
+  }
+}
@@ -51,7 +51,6 @@ static class AnImplementation implements AnInterface {
 
   static class AnInterfaceAdapter {
     @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      System.out.println(""TO JSON: "" + anInterface);
       jsonWriter.beginObject();
       jsonWriter.name(""name"").value(anInterface.getName());
       jsonWriter.endObject();
@@ -87,10 +86,9 @@ interface Service {
     Moshi moshi = new Moshi.Builder()
         .add(new AnInterfaceAdapter())
         .build();
-    Converter converter = new MoshiConverter(moshi);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(MoshiConverterFactory.create(moshi))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -1,39 +1,44 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit;
 
-import com.google.protobuf.AbstractMessageLite;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
 
-/** A {@link Converter} that reads and writes protocol buffers. */
-public class ProtoConverter implements Converter {
+final class ProtoConverter<T extends MessageLite> implements Converter<T> {
   private static final MediaType MEDIA_TYPE = MediaType.parse(""application/x-protobuf"");
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException(""Expected a raw Class<?> but was "" + type);
-    }
-    Class<?> c = (Class<?>) type;
-    if (!AbstractMessageLite.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException(""Expected a protobuf message but was "" + c.getName());
-    }
+  private Parser<T> parser;
 
+  ProtoConverter(Parser<T> parser) {
+    this.parser = parser;
+  }
+
+  @Override public T fromBody(ResponseBody body) throws IOException {
     InputStream is = body.byteStream();
     try {
-      Method parseFrom = c.getMethod(""parseFrom"", InputStream.class);
-      return parseFrom.invoke(null, is);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException(c.getName() + "".parseFrom() failed"", e.getCause());
-    } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException(""Expected a protobuf message but was "" + c.getName());
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
+      return parser.parseFrom(is);
+    } catch (InvalidProtocolBufferException e) {
+      throw new RuntimeException(e);
     } finally {
       try {
         is.close();
@@ -42,13 +47,8 @@ public class ProtoConverter implements Converter {
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
-    if (!(object instanceof AbstractMessageLite)) {
-      throw new IllegalArgumentException(
-          ""Expected a protobuf message but was "" + (object != null ? object.getClass().getName()
-              : ""null""));
-    }
-    byte[] bytes = ((AbstractMessageLite) object).toByteArray();
+  @Override public RequestBody toBody(T value) {
+    byte[] bytes = value.toByteArray();
     return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Protocol Buffers. */
+public final class ProtoConverterFactory implements Converter.Factory {
+  public static ProtoConverterFactory create() {
+    return new ProtoConverterFactory();
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class<?>)) {
+      throw new IllegalArgumentException(""Expected a raw Class<?> but was "" + type);
+    }
+    Class<?> c = (Class<?>) type;
+    if (!MessageLite.class.isAssignableFrom(c)) {
+      throw new IllegalArgumentException(""Expected a protobuf message but was "" + c.getName());
+    }
+
+    Parser<MessageLite> parser;
+    try {
+      Field field = c.getDeclaredField(""PARSER"");
+      //noinspection unchecked
+      parser = (Parser<MessageLite>) field.get(null);
+    } catch (NoSuchFieldException | IllegalAccessException e) {
+      throw new IllegalArgumentException(
+          ""Expected a protobuf message but "" + c.getName() + "" had no PARSER field."");
+    }
+
+    return new ProtoConverter<>(parser);
+  }
+}
@@ -49,7 +49,7 @@ interface Service {
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new ProtoConverter())
+        .converterFactory(ProtoConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -21,49 +21,30 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStreamWriter;
-import java.lang.reflect.Type;
 import okio.Buffer;
 import org.simpleframework.xml.Serializer;
-import org.simpleframework.xml.core.Persister;
 
-/**
- * A {@link Converter} which uses SimpleXML for reading and writing entities.
- *
- * @author Fabien Ric (fabien.ric@gmail.com)
- */
-public class SimpleXmlConverter implements Converter {
-  private static final boolean DEFAULT_STRICT = true;
+final class SimpleXmlConverter<T> implements Converter<T> {
   private static final String CHARSET = ""UTF-8"";
   private static final MediaType MEDIA_TYPE =
       MediaType.parse(""application/xml; charset="" + CHARSET);
 
+  private final Class<T> cls;
   private final Serializer serializer;
-
   private final boolean strict;
 
-  public SimpleXmlConverter() {
-    this(DEFAULT_STRICT);
-  }
-
-  public SimpleXmlConverter(boolean strict) {
-    this(new Persister(), strict);
-  }
-
-  public SimpleXmlConverter(Serializer serializer) {
-    this(serializer, DEFAULT_STRICT);
-  }
-
-  public SimpleXmlConverter(Serializer serializer, boolean strict) {
+  SimpleXmlConverter(Class<T> cls, Serializer serializer, boolean strict) {
+    this.cls = cls;
     this.serializer = serializer;
     this.strict = strict;
   }
 
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+  @Override public T fromBody(ResponseBody body) throws IOException {
     InputStream is = body.byteStream();
     try {
-      Object read = serializer.read((Class<?>) type, is, strict);
+      T read = serializer.read(cls, is, strict);
       if (read == null) {
-        throw new IllegalStateException(""Could not deserialize body as "" + type);
+        throw new IllegalStateException(""Could not deserialize body as "" + cls);
       }
       return read;
     } catch (RuntimeException | IOException e) {
@@ -78,19 +59,15 @@ public SimpleXmlConverter(Serializer serializer, boolean strict) {
     }
   }
 
-  @Override public RequestBody toBody(Object source, Type type) {
+  @Override public RequestBody toBody(T value) {
     Buffer buffer = new Buffer();
     try {
       OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
-      serializer.write(source, osw);
+      serializer.write(value, osw);
       osw.flush();
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
-
-  public boolean isStrict() {
-    return strict;
-  }
 }
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.reflect.Type;
+import org.simpleframework.xml.Serializer;
+import org.simpleframework.xml.core.Persister;
+
+/** A {@linkplain Converter.Factory converter} which uses Simple Framework for XML. */
+public final class SimpleXmlConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Persister} instance for conversion. */
+  public static SimpleXmlConverterFactory create() {
+    return create(new Persister());
+  }
+
+  /** Create an instance using {@code serializer} for conversion. */
+  public static SimpleXmlConverterFactory create(Serializer serializer) {
+    return new SimpleXmlConverterFactory(serializer, true);
+  }
+
+  /** Create an instance using a default {@link Persister} instance for non-strict conversion. */
+  public static SimpleXmlConverterFactory createNonStrict() {
+    return createNonStrict(new Persister());
+  }
+
+  /** Create an instance using {@code serializer} for non-strict conversion. */
+  public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+    return new SimpleXmlConverterFactory(serializer, false);
+  }
+
+  private final Serializer serializer;
+  private final boolean strict;
+
+  private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
+    if (serializer == null) throw new NullPointerException(""serializer == null"");
+    this.serializer = serializer;
+    this.strict = strict;
+  }
+
+  public boolean isStrict() {
+    return strict;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class)) {
+      throw new IllegalArgumentException(""Expected a raw class but was "" + type);
+    }
+    Class<?> cls = (Class<?>) type;
+    return new SimpleXmlConverter<>(cls, serializer, strict);
+  }
+}
@@ -48,10 +48,9 @@ interface Service {
   @Before public void setUp() {
     Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
     Persister persister = new Persister(format);
-    Converter converter = new SimpleXmlConverter(persister);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(SimpleXmlConverterFactory.create(persister))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit;
 
 import com.squareup.okhttp.MediaType;
@@ -8,38 +22,22 @@
 import com.squareup.wire.Wire;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.Type;
 
-/** A {@link Converter} that reads and writes protocol buffers using Wire. */
-public class WireConverter implements Converter {
+final class WireConverter<T extends Message> implements Converter<T> {
   private static final MediaType MEDIA_TYPE = MediaType.parse(""application/x-protobuf"");
 
   private final Wire wire;
+  private final Class<T> cls;
 
-  /** Create a converter with a default {@link Wire} instance. */
-  public WireConverter() {
-    this(new Wire());
-  }
-
-  /** Create a converter using the supplied {@link Wire} instance. */
-  public WireConverter(Wire wire) {
-    if (wire == null) throw new NullPointerException(""wire == null"");
+  public WireConverter(Wire wire, Class<T> cls) {
     this.wire = wire;
+    this.cls = cls;
   }
 
-  @SuppressWarnings(""unchecked"") //
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException(""Expected a raw Class<?> but was "" + type);
-    }
-    Class<?> c = (Class<?>) type;
-    if (!Message.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException(""Expected a proto message but was "" + c.getName());
-    }
-
+  @Override public T fromBody(ResponseBody body) throws IOException {
     InputStream in = body.byteStream();
     try {
-      return wire.parseFrom(in, (Class<Message>) c);
+      return wire.parseFrom(in, cls);
     } finally {
       try {
         in.close();
@@ -48,13 +46,8 @@ public WireConverter(Wire wire) {
     }
   }
 
-  @Override public RequestBody toBody(Object object, Type type) {
-    if (!(object instanceof Message)) {
-      throw new IllegalArgumentException(
-          ""Expected a proto message but was "" + (object != null ? object.getClass().getName()
-              : ""null""));
-    }
-    byte[] bytes = ((Message) object).toByteArray();
+  @Override public RequestBody toBody(T value) {
+    byte[] bytes = value.toByteArray();
     return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.Wire;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers. */
+public final class WireConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Wire} instance for conversion. */
+  public static WireConverterFactory create() {
+    return create(new Wire());
+  }
+
+  /** Create an instance using {@code wire} for conversion. */
+  public static WireConverterFactory create(Wire wire) {
+    return new WireConverterFactory(wire);
+  }
+
+  private final Wire wire;
+
+  /** Create a converter using the supplied {@link Wire} instance. */
+  private WireConverterFactory(Wire wire) {
+    if (wire == null) throw new NullPointerException(""wire == null"");
+    this.wire = wire;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class<?>)) {
+      throw new IllegalArgumentException(""Expected a raw Class<?> but was "" + type);
+    }
+    Class<?> c = (Class<?>) type;
+    if (!Message.class.isAssignableFrom(c)) {
+      throw new IllegalArgumentException(""Expected a proto message but was "" + c.getName());
+    }
+    //noinspection unchecked
+    return new WireConverter<>(wire, (Class<Message>) c);
+  }
+}
@@ -48,7 +48,7 @@ interface Service {
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new WireConverter())
+        .converterFactory(WireConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -20,24 +20,15 @@
 import java.io.IOException;
 import java.lang.reflect.Type;
 
-/**
- * Arbiter for converting objects to and from their representation in HTTP.
- */
-public interface Converter {
-  /**
-   * Convert an HTTP response body to a concrete object of the specified type.
-   *
-   * @param body HTTP response body.
-   * @param type Target object type.
-   * @return Instance of {@code type} which will be cast by the caller.
-   */
-  Object fromBody(ResponseBody body, Type type) throws IOException;
+/** Convert objects to and from their representation as HTTP bodies. */
+public interface Converter<T> {
+  /** Convert an HTTP response body to a concrete object of the specified type. */
+  T fromBody(ResponseBody body) throws IOException;
+
+  /** Convert an object to an appropriate representation for HTTP transport. */
+  RequestBody toBody(T value);
 
-  /**
-   * Convert an object to an appropriate representation for HTTP transport.
-   *
-   * @param object Object instance to convert.
-   * @return Representation of the specified object as bytes.
-   */
-  RequestBody toBody(Object object, Type type);
+  interface Factory {
+    Converter<?> get(Type type);
+  }
 }
@@ -61,7 +61,7 @@ enum BodyEncoding {
 
   final Method method;
   final CallAdapter.Factory adapterFactory;
-  final Converter converter;
+  final Converter.Factory converterFactory;
 
   // Method-level details
   CallAdapter<?> adapter;
@@ -80,10 +80,11 @@ enum BodyEncoding {
   // Parameter-level details
   Annotation[] requestParamAnnotations;
 
-  MethodInfo(Method method, CallAdapter.Factory adapterFactory, Converter converter) {
+  MethodInfo(Method method, CallAdapter.Factory adapterFactory,
+      Converter.Factory converterFactory) {
     this.method = method;
     this.adapterFactory = adapterFactory;
-    this.converter = converter;
+    this.converterFactory = converterFactory;
     parseResponseType();
     parseMethodAnnotations();
     parseParameters();
@@ -229,7 +230,7 @@ private void parseResponseType() {
           ""Registered call adapter factory was unable to handle return type "" + returnType);
     }
     Type responseType = adapter.responseType();
-    if (converter == null && responseType != ResponseBody.class) {
+    if (converterFactory == null && responseType != ResponseBody.class) {
       throw methodError(""Method response type is ""
           + responseType
           + "" but no converter registered. ""
@@ -291,7 +292,7 @@ private void parseParameters() {
             if (bodyEncoding != BodyEncoding.MULTIPART) {
               throw parameterError(i, ""@Part parameters can only be used with multipart encoding."");
             }
-            if (converter == null && methodParameterType != BodyEncoding.class) {
+            if (converterFactory == null && methodParameterType != BodyEncoding.class) {
               throw parameterError(i, ""@Part parameter is ""
                   + methodParameterType
                   + "" but no converter registered. ""
@@ -317,7 +318,7 @@ private void parseParameters() {
             if (gotBody) {
               throw methodError(""Multiple @Body method annotations found."");
             }
-            if (converter == null && methodParameterType != RequestBody.class) {
+            if (converterFactory == null && methodParameterType != RequestBody.class) {
               throw parameterError(i, ""@Body parameter is ""
                   + methodParameterType
                   + "" but no converter registered. ""
@@ -26,26 +26,26 @@
 
 final class OkHttpCall<T> implements Call<T> {
   private final Endpoint endpoint;
-  private final Converter converter;
+  private final Converter.Factory converterFactory;
   private final OkHttpClient client;
   private final MethodInfo methodInfo;
   private final Object[] args;
 
   private volatile com.squareup.okhttp.Call rawCall;
   private boolean executed; // Guarded by this.
 
-  OkHttpCall(Endpoint endpoint, Converter converter, OkHttpClient client, MethodInfo methodInfo,
-      Object[] args) {
+  OkHttpCall(Endpoint endpoint, Converter.Factory converterFactory, OkHttpClient client,
+      MethodInfo methodInfo, Object[] args) {
     this.endpoint = endpoint;
-    this.converter = converter;
+    this.converterFactory = converterFactory;
     this.client = client;
     this.methodInfo = methodInfo;
     this.args = args;
   }
 
   @SuppressWarnings(""CloneDoesntCallSuperClone"") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(endpoint, converter, client, methodInfo, args);
+    return new OkHttpCall<>(endpoint, converterFactory, client, methodInfo, args);
   }
 
   public void enqueue(final Callback<T> callback) {
@@ -111,7 +111,7 @@ public Response<T> execute() throws IOException {
 
   private com.squareup.okhttp.Call createRawCall() {
     HttpUrl url = endpoint.url();
-    RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo, converter);
+    RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo, converterFactory);
     requestBuilder.setArguments(args);
     Request request = requestBuilder.build();
 
@@ -162,7 +162,7 @@ private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) thro
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
       //noinspection unchecked
-      T body = (T) converter.fromBody(catchingBody, responseType);
+      T body = (T) converterFactory.get(responseType).fromBody(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
@@ -44,7 +44,7 @@ final class RequestBuilder {
   private static final Headers NO_HEADERS = Headers.of();
   private static final byte[] NO_BODY = new byte[0];
 
-  private final Converter converter;
+  private final Converter.Factory converterFactory;
   private final Annotation[] paramAnnotations;
   private final String requestMethod;
   private final boolean requestHasBody;
@@ -59,8 +59,8 @@ final class RequestBuilder {
   private Headers.Builder headers;
   private String contentTypeHeader;
 
-  RequestBuilder(HttpUrl url, MethodInfo methodInfo, Converter converter) {
-    this.converter = converter;
+  RequestBuilder(HttpUrl url, MethodInfo methodInfo, Converter.Factory converterFactory) {
+    this.converterFactory = converterFactory;
 
     paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
@@ -286,7 +286,10 @@ void setArguments(Object[] args) {
             multipartBuilder.addPart(headers,
                 RequestBody.create(MediaType.parse(""text/plain""), (String) value));
           } else {
-            multipartBuilder.addPart(headers, converter.toBody(value, value.getClass()));
+            //noinspection unchecked
+            Converter<Object> converter =
+                (Converter<Object>) converterFactory.get(value.getClass());
+            multipartBuilder.addPart(headers, converter.toBody(value));
           }
         }
       } else if (annotationType == PartMap.class) {
@@ -310,8 +313,10 @@ void setArguments(Object[] args) {
                 multipartBuilder.addPart(headers,
                     RequestBody.create(MediaType.parse(""text/plain""), (String) entryValue));
               } else {
-                multipartBuilder.addPart(headers,
-                    converter.toBody(entryValue, entryValue.getClass()));
+                //noinspection unchecked
+                Converter<Object> converter =
+                    (Converter<Object>) converterFactory.get(entryValue.getClass());
+                multipartBuilder.addPart(headers, converter.toBody(entryValue));
               }
             }
           }
@@ -324,7 +329,9 @@ void setArguments(Object[] args) {
             || (requestType == Object.class && value instanceof RequestBody)) {
           body = (RequestBody) value;
         } else {
-          body = converter.toBody(value, requestType);
+          //noinspection unchecked
+          Converter<Object> converter = (Converter<Object>) converterFactory.get(requestType);
+          body = converter.toBody(value);
         }
       } else {
         throw new IllegalArgumentException(
@@ -22,7 +22,6 @@
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
-import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import retrofit.http.HTTP;
@@ -49,7 +48,7 @@
  * <p>
  * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
  * will be converted to request representation by a call to
- * {@link Converter#toBody(Object, java.lang.reflect.Type) toBody}
+ * {@link Converter#toBody(Object) toBody}
  * on the supplied {@link Converter} for this instance. A {@link RequestBody} can also be used
  * which will not use the {@code Converter}.
  * <p>
@@ -68,7 +67,7 @@
  * <p>
  * By default, methods return a {@link Call} which represents the HTTP request. The generic
  * parameter of the call is the response body type and will be converted by a call to
- * {@link Converter#fromBody(ResponseBody, Type) fromBody} on the supplied {@link Converter} for
+ * {@link Converter#fromBody(ResponseBody) fromBody} on the supplied {@link Converter} for
  * this instance. {@link ResponseBody} can also be used which will not use the {@code Converter}.
  * <p>
  * For example:
@@ -89,14 +88,14 @@ public final class Retrofit {
   private final Map<Method, MethodInfo> methodInfoCache = new LinkedHashMap<>();
   private final OkHttpClient client;
   private final Endpoint endpoint;
-  private final Converter converter;
+  private final Converter.Factory converterFactory;
   private final CallAdapter.Factory adapterFactory;
 
-  private Retrofit(OkHttpClient client, Endpoint endpoint, Converter converter,
+  private Retrofit(OkHttpClient client, Endpoint endpoint, Converter.Factory converterFactory,
       CallAdapter.Factory adapterFactory) {
     this.client = client;
     this.endpoint = endpoint;
-    this.converter = converter;
+    this.converterFactory = converterFactory;
     this.adapterFactory = adapterFactory;
   }
 
@@ -121,7 +120,7 @@ public <T> T create(Class<T> service) {
   // Package-private avoids synthetic accessor method from InvocationHandler. Also for testing.
   Object invokeMethod(Method method, Object... args) {
     MethodInfo methodInfo = loadMethodInfo(method);
-    Call call = new OkHttpCall(endpoint, converter, client, methodInfo, args);
+    Call call = new OkHttpCall(endpoint, converterFactory, client, methodInfo, args);
     return methodInfo.adapter.adapt(call);
   }
 
@@ -131,7 +130,7 @@ private MethodInfo loadMethodInfo(Method method) {
       synchronized (methodInfoCache) {
         methodInfo = methodInfoCache.get(method);
         if (methodInfo == null) {
-          methodInfo = new MethodInfo(method, adapterFactory, converter);
+          methodInfo = new MethodInfo(method, adapterFactory, converterFactory);
           methodInfoCache.put(method, methodInfo);
         }
       }
@@ -152,8 +151,8 @@ public Endpoint endpoint() {
    * <p>
    * May be null.
    */
-  public Converter converter() {
-    return converter;
+  public Converter.Factory converterFactory() {
+    return converterFactory;
   }
 
   public CallAdapter.Factory callAdapterFactory() {
@@ -169,7 +168,7 @@ public CallAdapter.Factory callAdapterFactory() {
   public static class Builder {
     private OkHttpClient client;
     private Endpoint endpoint;
-    private Converter converter;
+    private Converter.Factory converterFactory;
     private CallAdapter.Factory adapterFactory;
 
     /** The HTTP client used for requests. */
@@ -205,8 +204,8 @@ public Builder endpoint(Endpoint endpoint) {
     }
 
     /** The converter used for serialization and deserialization of objects. */
-    public Builder converter(Converter converter) {
-      this.converter = checkNotNull(converter, ""converter == null"");
+    public Builder converterFactory(Converter.Factory converterFactory) {
+      this.converterFactory = checkNotNull(converterFactory, ""converterFactory == null"");
       return this;
     }
 
@@ -232,7 +231,7 @@ public Retrofit build() {
         adapterFactory = Platform.get().defaultCallAdapterFactory();
       }
 
-      return new Retrofit(client, endpoint, converter, adapterFactory);
+      return new Retrofit(client, endpoint, converterFactory, adapterFactory);
     }
   }
 }
@@ -58,7 +58,7 @@ interface Service {
   @Test public void http200Sync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -72,7 +72,7 @@ interface Service {
   @Test public void http200Async() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -100,7 +100,7 @@ interface Service {
   @Test public void http404Sync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -115,7 +115,7 @@ interface Service {
   @Test public void http404Async() throws InterruptedException, IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -144,7 +144,7 @@ interface Service {
   @Test public void transportProblemSync() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -161,7 +161,7 @@ interface Service {
   @Test public void transportProblemAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -188,9 +188,13 @@ interface Service {
   @Test public void conversionProblemOutgoingSync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter() {
-          @Override public RequestBody toBody(Object object, Type type) {
-            throw new UnsupportedOperationException(""I am broken!"");
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public RequestBody toBody(String value) {
+                throw new UnsupportedOperationException(""I am broken!"");
+              }
+            };
           }
         })
         .build();
@@ -208,9 +212,13 @@ interface Service {
   @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter() {
-          @Override public RequestBody toBody(Object object, Type type) {
-            throw new UnsupportedOperationException(""I am broken!"");
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public RequestBody toBody(String value) {
+                throw new UnsupportedOperationException(""I am broken!"");
+              }
+            };
           }
         })
         .build();
@@ -237,9 +245,13 @@ interface Service {
   @Test public void conversionProblemIncomingSync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter() {
-          @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-            throw new UnsupportedOperationException(""I am broken!"");
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                throw new UnsupportedOperationException(""I am broken!"");
+              }
+            };
           }
         })
         .build();
@@ -276,14 +288,18 @@ interface Service {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .client(client)
-        .converter(new StringConverter() {
-          @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-            try {
-              return super.fromBody(body, type);
-            } catch (IOException e) {
-              // Some serialization libraries mask transport problems in runtime exceptions. Bad!
-              throw new RuntimeException(""wrapper"", e);
-            }
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                try {
+                  return super.fromBody(body);
+                } catch (IOException e) {
+                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
+                  throw new RuntimeException(""wrapper"", e);
+                }
+              }
+            };
           }
         })
         .build();
@@ -303,9 +319,13 @@ interface Service {
   @Test public void conversionProblemIncomingAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter() {
-          @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-            throw new UnsupportedOperationException(""I am broken!"");
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                throw new UnsupportedOperationException(""I am broken!"");
+              }
+            };
           }
         })
         .build();
@@ -332,10 +352,14 @@ interface Service {
   }
 
   @Test public void http204SkipsConverter() throws IOException {
-    Converter converter = spy(new StringConverter());
+    final Converter converter = spy(new StringConverterFactory.StringConverter());
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter get(Type type) {
+            return converter;
+          }
+        })
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -348,10 +372,14 @@ interface Service {
   }
 
   @Test public void http205SkipsConverter() throws IOException {
-    Converter converter = spy(new StringConverter());
+    final Converter converter = spy(new StringConverterFactory.StringConverter());
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(converter)
+        .converterFactory(new StringConverterFactory() {
+          @Override public Converter get(Type type) {
+            return converter;
+          }
+        })
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -366,7 +394,7 @@ interface Service {
   @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -379,7 +407,7 @@ interface Service {
   @Test public void responseBody() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -392,7 +420,7 @@ interface Service {
   @Test public void responseBodyBuffers() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -413,7 +441,7 @@ interface Service {
   @Test public void responseBodyStreams() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -434,7 +462,7 @@ interface Service {
   @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -456,7 +484,7 @@ interface Service {
   @Test public void emptyResponse() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -15,9 +15,9 @@
 
 @SuppressWarnings(""unused"") // Lots of unused parameters for example code.
 public final class MethodInfoTest {
-  private static CallAdapter.Factory FACTORY =
+  private static CallAdapter.Factory CALL_ADAPTER_FACTORY =
       new DefaultCallAdapterFactory(Executors.newSingleThreadExecutor());
-  private static Converter CONVERTER = new StringConverter();
+  private static Converter.Factory CONVERTER_FACTORY = new StringConverterFactory();
 
   @Test public void pathParameterParsing() throws Exception {
     expectParams(""/"");
@@ -57,7 +57,7 @@ class Example {
     }
 
     Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
     assertThat(methodInfo.requestType).isEqualTo(Dummy.class);
   }
 
@@ -69,7 +69,7 @@ class Example {
     }
 
     Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
     Type expected = new TypeToken<List<Dummy>>() {}.getType();
     assertThat(methodInfo.requestType).isEqualTo(expected);
   }
@@ -82,7 +82,7 @@ class Example {
     }
 
     Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
     Type expected = new TypeToken<List<? super String>>() {}.getType();
     assertThat(methodInfo.requestType).isEqualTo(expected);
   }
@@ -1418,13 +1418,14 @@ private static void assertBody(RequestBody body, String expected) {
 
   private Request buildRequest(Class<?> cls, Object... args) {
     HttpUrl url = HttpUrl.parse(""http://example.com/"");
-    Converter converter = new StringConverter();
-    CallAdapter.Factory factory = new DefaultCallAdapterFactory(new Utils.SynchronousExecutor());
+    Converter.Factory converterFactory = new StringConverterFactory();
+    CallAdapter.Factory callAdapterFactory =
+        new DefaultCallAdapterFactory(new Utils.SynchronousExecutor());
 
     Method method = TestingUtils.onlyMethod(cls);
-    MethodInfo methodInfo = new MethodInfo(method, factory, converter);
+    MethodInfo methodInfo = new MethodInfo(method, callAdapterFactory, converterFactory);
 
-    RequestBuilder builder = new RequestBuilder(url, methodInfo, converter);
+    RequestBuilder builder = new RequestBuilder(url, methodInfo, converterFactory);
     builder.setArguments(args);
     return builder.build();
   }
@@ -135,7 +135,7 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
 
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .callAdapterFactory(new GreetingCallAdapterFactory())
         .build();
     StringService example = retrofit.create(StringService.class);
@@ -218,7 +218,7 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
   @Test public void unresolvableTypeThrows() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
-        .converter(new StringConverter())
+        .converterFactory(new StringConverterFactory())
         .build();
     Unresolvable example = retrofit.create(Unresolvable.class);
 
@@ -352,27 +352,27 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
 
   @Test public void converterNullThrows() {
     try {
-      new Retrofit.Builder().converter(null);
+      new Retrofit.Builder().converterFactory(null);
       fail();
     } catch (NullPointerException e) {
-      assertThat(e).hasMessage(""converter == null"");
+      assertThat(e).hasMessage(""converterFactory == null"");
     }
   }
 
   @Test public void converterNoDefault() {
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(""http://example.com/"")
         .build();
-    assertThat(retrofit.converter()).isNull();
+    assertThat(retrofit.converterFactory()).isNull();
   }
 
-  @Test public void converterPropagated() {
-    Converter converter = mock(Converter.class);
+  @Test public void converterFactoryPropagated() {
+    Converter.Factory factory = mock(Converter.Factory.class);
     Retrofit retrofit = new Retrofit.Builder()
         .endpoint(""http://example.com/"")
-        .converter(converter)
+        .converterFactory(factory)
         .build();
-    assertThat(retrofit.converter()).isSameAs(converter);
+    assertThat(retrofit.converterFactory()).isSameAs(factory);
   }
 
   @Test public void callAdapterFactoryNullThrows() {
@@ -1,17 +0,0 @@
-package retrofit;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.Type;
-
-class StringConverter implements Converter {
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    return body.string();
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    return RequestBody.create(MediaType.parse(""text/plain""), String.valueOf(object));
-  }
-}
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.reflect.Type;
+
+class StringConverterFactory implements Converter.Factory {
+  private static final MediaType MEDIA_TYPE = MediaType.parse(""text/plain"");
+
+  @Override public Converter get(Type type) {
+    if (type != String.class) {
+      throw new IllegalArgumentException(""Type was not "" + String.class);
+    }
+    return new StringConverter();
+  }
+
+  static class StringConverter implements Converter<String> {
+    @Override public String fromBody(ResponseBody body) throws IOException {
+      return body.string();
+    }
+
+    @Override public RequestBody toBody(String value) {
+      return RequestBody.create(MEDIA_TYPE, value);
+    }
+  }
+}
",True,The commit message refers to the necessity of changing the factory for the converter concept. This is done to improve the efficiency of the internal use and to add tests that prove that the service method configuration now fails earlier.,True,"The commit message refers to the introduction of a factory for the converter concept, which is a significant change that could potentially break existing code or introduce new bugs. The message does not explicitly state why this change is necessary, but it is likely that the current implementation of the converter is inefficient or does not provide the necessary functionality for configuring a service method, as mentioned in the message.",True,The commit message explains that the introduction of a factory for the converter concept is necessary because the current implementation is highly-inefficient in its internal use and there are no tests proving that we now fail earlier in configuring a service method. Both of those issues will be addressed in follow up commits.,True,"The commit message indicates that the developer is introducing a factory for the converter concept. This suggests that the change is being made to improve the efficiency and reliability of the system, as the current implementation is not efficient and does not provide tests to ensure that the service method is configured correctly. This implies that the change is being made to address a problem in the software maintenance process, specifically the need for improved performance and testing.",True,"The commit message mentions the introduction of a factory for the converter concept, which suggests that the change is related to improving the code structure and making it more flexible. This could include refactoring the existing converter classes to use a factory pattern, which would allow for easier addition of new converter types in the future. The message also mentions that there are no tests proving that we now fail earlier in configuring a service method, which could indicate that the change is intended to improve the error handling and testing of the code.",True,"The commit message 'Introduce factory for converter concept' describes the change by summarizing the introduction of a factory for the converter concept, which is a key component of the change. The diff shows that the StringConverter class has been replaced with a StringConverterFactory class, which is a factory for creating StringConverter instances. This change allows for more flexibility and extensibility in the conversion process.",True,"The commit message introduces a factory for the converter concept, which is a design pattern used to convert objects to and from their representation in HTTP. This suggests that the changes are likely to involve the implementation of a new way to handle serialization and deserialization of objects, which is a technical principle underpinning the changes.",True,"The commit message expresses the introduction of a factory for the converter concept. This change is described as a refactoring to improve the internal efficiency and to add tests for error handling. The code diff shows that the StringConverter class has been replaced with a StringConverterFactory class, which is a factory for creating StringConverter instances. This change introduces new behavior by allowing multiple StringConverter instances to be created, each with its own configuration. This is a significant change that affects how the converter is used throughout the codebase.",True,"The commit message does not explicitly state the reason for the change, but it can be inferred from the code diff. The change is from using a 'StringConverter' to using a 'StringConverterFactory'. This suggests that the previous implementation was not able to handle multiple types of conversions, and the new implementation is more flexible and can handle a wider range of types. This change was made to improve the efficiency and functionality of the code."
https://github.com/square/retrofit/commit/30fabb8e9a87b644d0b78d0962efe6aef027f04b,Revert version to 0.6 to match previous ant/ivy build.  <enter> Add a description too... ,https://api.github.com/repos/square/retrofit/commits/30fabb8e9a87b644d0b78d0962efe6aef027f04b,"@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
@@ -14,17 +14,16 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <groupId>com.squareup</groupId>
     <artifactId>retrofit</artifactId>
-    <version>1.0.0-SNAPSHOT</version>
+    <version>0.6.0-SNAPSHOT</version>
     <packaging>pom</packaging>
 
     <name>Retrofit</name>
-    <description></description>
+    <description>Reusable Java and Android code from Square, Inc. for simplified I/O, HTTP, and more.</description>
     <url>http://github.com/square/retrofit/</url>
 
     <modules>
@@ -158,4 +157,4 @@
             </plugin>
         </plugins>
     </build>
-</project>
\ No newline at end of file
+</project>
@@ -1,13 +1,12 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
         <groupId>com.squareup</groupId>
         <artifactId>retrofit</artifactId>
-        <version>1.0.0-SNAPSHOT</version>
+        <version>0.6.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
",True,The commit message refers to a convention or standard by mentioning the need to revert the version to 0.6 to match a previous ant/ivy build. This explains why the commit is changing the version number in the project's POM file.,True,"The commit message explains the necessity of the changes by stating that it is being reverted to version 0.6 to match a previous ant/ivy build. This is not a common sense or easy to infer change, but rather a specific requirement for the project's build system.",True,"The commit message explains the reason for the change by mentioning that it is reverting the version to 0.6 to match a previous ant/ivy build. This implies that there was a problem with the newer version (1.0.0-SNAPSHOT) that caused issues with the ant/ivy build system, and the change is being made to revert to a known working version.",True,"The commit message 'Revert version to 0.6 to match previous ant/ivy build' indicates that the developer is making changes to match the requirements of a previous build environment. This suggests that the changes are necessary to maintain the functionality of the software, which is a common requirement in software maintenance.",True,"The commit message mentions the change is to revert the version to 0.6 to match a previous ant/ivy build. This implies that there was an issue with the previous version (1.0.0-SNAPSHOT) that required a reversion to a stable version (0.6.0-SNAPSHOT). Additionally, the description of the project in the code diff has been updated to provide more detail about the project, which could indicate an improvement or clarification of the project's purpose.",True,"The commit message 'Revert version to 0.6 to match previous ant/ivy build' accurately describes the change made in the diff. It clearly states that the version of the project is being reverted from 1.0.0-SNAPSHOT to 0.6.0-SNAPSHOT, which is the key component of the change.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on reverting the version to match a previous ant/ivy build. While this could imply a principle of consistency or reproducibility, it's not explicitly stated in the message.",True,"The commit message 'Revert version to 0.6 to match previous ant/ivy build' clearly describes the change made to the code. It explains that the version of the project is being reverted from 1.0.0-SNAPSHOT to 0.6.0-SNAPSHOT to match a previous build configuration. This change does not introduce new behaviors but rather restores a previous state, which is a significant change that the commit message accurately describes.",False,"The commit message does not explicitly explain the reason for the version revert. While it's clear that the version is being changed from 1.0.0-SNAPSHOT to 0.6.0-SNAPSHOT, the reason for this change (matching previous ant/ivy build) is not explicitly stated in the commit message. This could potentially lead to confusion for other developers who review the commit."
https://github.com/square/okhttp/commit/489c92400f579bace0950c910de2dca03959785e,Revise the upgrading guide for OkHttp 4.x.  <enter> Also change the old OkHttp 3.x Javadoc to set the new docs as canonical.  https://publicobject.com/2017/02/14/canonical-urls-for-javadocs/ ,https://api.github.com/repos/square/okhttp/commits/489c92400f579bace0950c910de2dca03959785e,"@@ -41,6 +41,7 @@ mkdocs gh-deploy
 # Restore Javadocs from 1.x, 2.x, and 3.x.
 git checkout gh-pages
 git cherry-pick bb229b9dcc9a21a73edbf8d936bea88f52e0a3ff
+git cherry-pick c695732f1d4aea103b826876c077fbfea630e244
 git push
 
 # Delete our temp folder
@@ -2,16 +2,16 @@ Upgrading to OkHttp 4
 =====================
 
 OkHttp 4.x upgrades our implementation language from Java to Kotlin and keeps everything else the
-same. We've chosen Kotlin because it gives us powerful new capabilities while integrating closely
+same. We’ve chosen Kotlin because it gives us powerful new capabilities while integrating closely
 with Java.
 
-We spent a lot of time and energy on retaining strict compatibility with OkHttp 3.x. We're even
+We spent a lot of time and energy on retaining strict compatibility with OkHttp 3.x. We’re even
 keeping the package name the same: `okhttp3`!
 
-There are three kinds of compatibility we're tracking:
+There are three kinds of compatibility we’re tracking:
 
  * **Binary compatibility** is the ability to compile a program against OkHttp 3.x, and then to run
-   it against OkHttp 4.x. We're using the excellent [japicmp][japicmp] library via its
+   it against OkHttp 4.x. We’re using the excellent [japicmp][japicmp] library via its
    [Gradle plugin][japicmp_gradle] to enforce binary compatibility.
 
  * **Java source compatibility** is the ability to upgrade Java uses of OkHttp 3.x to 4.x without
@@ -20,39 +20,41 @@ There are three kinds of compatibility we're tracking:
  * **Kotlin source compatibility** is the ability to upgrade Kotlin uses of OkHttp 3.x to 4.x
    without changing `.kt` files.
 
-With one exception, OkHttp 4.x is both binary- and Java source-compatible with OkHttp 3.x. You can
-use an OkHttp 4.x .jar file with applications or libraries built for OkHttp 3.x. (The exception?
-`OkHttpClient` makes more things `final`.)
+With a few small exceptions (below), OkHttp 4.x is both binary- and Java source-compatible with
+OkHttp 3.x. You can use an OkHttp 4.x .jar file with applications or libraries built for OkHttp 3.x.
 
 OkHttp is **not** source-compatible for Kotlin callers, but upgrading should be automatic thanks to
-Kotlin's powerful deprecation features. Most developers should be able to use IntelliJ's _Code
+Kotlin’s powerful deprecation features. Most developers should be able to use IntelliJ’s _Code
 Cleanup_ for a safe and fast upgrade.
 
-For example, when we upgraded Square's Kotlin and Java codebases to OkHttp 4.x we had these
-problems:
-
- * Single Abstract Method (SAM) conversions required us to replace lambdas with objects for Kotlin
-   callers.
-
- * OkHttp 4.x's new `RequestBody.create()` overload conflicted with an overload in one of our
-   subclasses. The compiler caught this!
-
-We expect most projects to have similarly trivial problems with the upgrade, if any. This guide
-walks through all of the changes and how to address them.
-
 
 Backwards-Incompatible Changes
 ------------------------------
 
+#### OkHttpClient final methods
+
 `OkHttpClient` has 26 accessors like `interceptors()` and `writeTimeoutMillis()` that were non-final
 in OkHttp 3.x and are final in 4.x. These were made non-final for use with mocking frameworks like
-[Mockito][mockito]. We believe subtyping `OkHttpClient` is the wrong way to test with OkHttp.
+[Mockito][mockito]. We believe subtyping `OkHttpClient` is the wrong way to test with OkHttp. If
+you must, mock `Call.Factory` which is the interface that `OkHttpClient` implements.
+
+#### Internal API changes
 
 The `okhttp3.internal` package is not a published API and we change it frequently without warning.
-Depending on code in this package is bad and will cause you problems with any upgrade. But the 4.x
+Depending on code in this package is bad and will cause you problems with any upgrade! But the 4.x
 will be particularly painful to naughty developers that import from this package! We changed a lot
 to take advantage of sweet Kotlin features.
 
+#### Credentials.basic()
+
+The username and password parameters to `Credentials.basic()` are now non-null strings. In OkHttp
+3.x, null would yield a username or password of ""null"".
+
+#### HttpUrl.queryParameterValues()
+
+The return type of `HttpUrl.queryParameterValues()` is `List<String?>`. Lists that may contain null
+are uncommon and Kotlin callers may have incorrectly assigned the result to `List<String>`.
+
 
 Code Cleanup
 ------------
@@ -61,63 +63,15 @@ IntelliJ and Android Studio offer a **Code Cleanup** feature that will automatic
 deprecated APIs with their replacements. Access this feature from the _Search Anywhere_ dialog
 (double-press shift) or under the _Analyze_ menu.
 
-The deprecation replacements that Code Cleanup possible are included in OkHttp 4.0. We will remove
-them in a future update to OkHttp, so if you're skipping releases you should upgrade to OkHttp 4.0
+We’ve included deprecated APIs in OkHttp 4.0 because they make migration easy. We will remove them
+in a future release! If you’re skipping releases, it’ll be much easier if you upgrade to OkHttp 4.0
 as an intermediate step.
 
+#### Vars and Vals
 
-SAM Conversions
----------------
-
-When you use Java APIs from Kotlin you can operate on Java interfaces as if they were Kotlin
-lambdas. The [feature][kotlin_sam] is available for interfaces that define a Single Abstract Method
-(SAM).
-
-But when you use Kotlin APIs from Kotlin there's no automatic conversion. Code that used SAM lambdas
-with OkHttp 3.x: must use `object :` with OkHttp 4.x:
-
-Kotlin calling OkHttp 3.x:
-
-```kotlin
-val client = OkHttpClient.Builder()
-    .dns { hostname -> InetAddress.getAllByName(hostname).toList() }
-    .build()
-```
-
-Kotlin calling OkHttp 4.x:
-
-```kotlin
-val client = OkHttpClient.Builder()
-    .dns(object : Dns {
-      override fun lookup(hostname: String) =
-          InetAddress.getAllByName(hostname).toList()
-    })
-    .build()
-```
-
-SAM conversion impacts these APIs:
-
- * Authenticator
- * Dispatcher.setIdleCallback(Runnable)
- * Dns
- * EventListener.Factory
- * HttpLoggingInterceptor.Logger
- * LoggingEventListener.Factory
- * OkHttpClient.Builder.hostnameVerifier(HostnameVerifier)
-
-JetBrains [is working on][kotlin_sams] SAM conversions of Kotlin interfaces. Expect it in a future
-release of the Kotlin language.
-
-
-Vars and Vals
--------------
-
-Java doesn't have language support for properties so developers make do with getters and setters.
+Java doesn’t have language support for properties so developers make do with getters and setters.
 Kotlin does have properties and we take advantage of them in OkHttp.
 
-We recommend using _Code Cleanup_ to fix these; it'll use `@Deprecated` to find replacements and fix
-them automatically.
-
  * **Address**: certificatePinner, connectionSpecs, dns, hostnameVerifier, protocols, proxy,
    proxyAuthenticator, proxySelector, socketFactory, sslSocketFactory, url
  * **Cache**: directory
@@ -155,11 +109,14 @@ them automatically.
  * **Route**: address, proxy, socketAddress
  * **TlsVersion**: javaName
 
+#### Renamed Functions
+
+* **Headers.of()**: for symmetry with `listOf()`, `setOf()`, etc., we’ve replaced
+  `Headers.of(String...)` with `headersOf(vararg String)`.
 
-Extension Functions
--------------------
+#### Extension Functions
 
-_Code Cleanup_ will fix these too:
+We’ve migrated from static functions to extension functions where we think they fit.
 
 | Java                                | Kotlin                          |
 | :---------------------------------- | :------------------------------ |
@@ -183,24 +140,47 @@ _Code Cleanup_ will fix these too:
 | ResponseBody.create(String)         | String.toResponseBody()         |
 
 
-headersOf()
------------
+SAM Conversions
+---------------
 
-For symmetry with `listOf()`, `setOf()`, etc., we've replaced `Headers.of(String...)` with
-`headersOf(vararg String)`.
+When you use Java APIs from Kotlin you can operate on Java interfaces as if they were Kotlin
+lambdas. The [feature][java_sams] is available for interfaces that define a Single Abstract Method
+(SAM).
+
+But when you use Kotlin APIs from Kotlin there’s no automatic conversion. Code that used SAM lambdas
+with OkHttp 3.x: must use `object :` with OkHttp 4.x:
+
+Kotlin calling OkHttp 3.x:
+
+```kotlin
+val client = OkHttpClient.Builder()
+    .dns { hostname -> InetAddress.getAllByName(hostname).toList() }
+    .build()
+```
 
+Kotlin calling OkHttp 4.x:
 
-queryParameterValues()
-----------------------
+```kotlin
+val client = OkHttpClient.Builder()
+    .dns(object : Dns {
+      override fun lookup(hostname: String) =
+          InetAddress.getAllByName(hostname).toList()
+    })
+    .build()
+```
 
-The return type of `HttpUrl.queryParameterValues()` is `List<String?>`. Lists that may contain
-null are uncommon and Kotlin callers may have incorrectly assigned the result to `List<String>`.
+SAM conversion impacts these APIs:
 
+ * Authenticator
+ * Dispatcher.setIdleCallback(Runnable)
+ * Dns
+ * EventListener.Factory
+ * HttpLoggingInterceptor.Logger
+ * LoggingEventListener.Factory
+ * OkHttpClient.Builder.hostnameVerifier(HostnameVerifier)
 
-[japicmp]: https://github.com/siom79/japicmp
-[japicmp_gradle]: https://github.com/melix/japicmp-gradle-plugin
-[mockito]: https://site.mockito.org/
-[kotlin_sam]: https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions
+JetBrains [is working on][kotlin_sams] SAM conversions of Kotlin interfaces. Expect it in a future
+release of the Kotlin language.
 
 
 Companion Imports
@@ -230,6 +210,16 @@ sed -i """" \
 ```
 
 
+Advanced Profiling
+------------------
+
+Android Studio’s Advanced Profiling feature rewrites OkHttp bytecode for instrumentation.
+Unfortunately it crashes on OkHttp 4.x’s bytecode. Until [Google’s bug][advanced_profiling_bug] is
+fixed you must disable advanced profiling in Android Studio.
+
+![Disable Advanced Profiling](images/disable_advanced_profiling@2x.png)
+
+
 R8 / ProGuard
 -------------
 
@@ -238,11 +228,16 @@ R8 and ProGuard are both code optimizers for `.class` files.
 R8 is the [default optimizer][r8] in Android Studio 3.4 and newer. It works well with all
 releases of OkHttp.
 
-ProGuard was the previous default. We're [tracking problems][proguard_problems] with interactions
-between ProGuard, OkHttp 4.x, and Kotlin-originated `.class` files. Make sure you're on the latest
-release if you're using ProGuard,
+ProGuard was the previous default. We’re [tracking problems][proguard_problems] with interactions
+between ProGuard, OkHttp 4.x, and Kotlin-originated `.class` files. Make sure you’re on the latest
+release if you’re using ProGuard,
 
 
- [kotlin_sams]: https://discuss.kotlinlang.org/t/new-type-inference-in-kotlin-1-3-0-rc-190/9914/2
+ [advanced_profiling_bug]: https://issuetracker.google.com/issues/135141615
+ [japicmp]: https://github.com/siom79/japicmp
+ [japicmp_gradle]: https://github.com/melix/japicmp-gradle-plugin
+ [java_sams]: https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions
+ [kotlin_sams]: https://youtrack.jetbrains.com/issue/KT-11129
+ [mockito]: https://site.mockito.org/
  [proguard_problems]: https://github.com/square/okhttp/issues/5167
  [r8]: https://developer.android.com/studio/releases#r8-default
",True,"The commit message refers to the necessity of changes by referencing conventions and standards. It mentions the upgrading guide for OkHttp 4.x and changing the old OkHttp 3.x Javadoc to set the new docs as canonical, which is a common practice to ensure that the latest documentation is easily accessible. This explains why the commit includes changes to the upgrading guide and the Javadoc.",False,"The commit message does not explicitly state the necessity of the changes. While it mentions revising the upgrading guide for OkHttp 4.x and changing the old OkHttp 3.x Javadoc, it does not provide a clear rationale for these changes. The code diff suggests that the changes are related to updating documentation and version management, but the commit message does not explicitly explain why these changes are necessary.",True,The commit message explains the motivation for the changes by mentioning the need to revise the upgrading guide for OkHttp 4.x and the need to change the old OkHttp 3.x Javadoc to set the new docs as canonical. This is done to address the issue of outdated documentation and to ensure that users are directed to the most accurate and up-to-date information. The message also mentions the link to the article that explains the importance of canonical URLs for Javadocs.,True,"The commit message indicates that the changes are being made to upgrade the OkHttp library to version 4.x. This upgrade involves revising the upgrading guide and changing the old Javadoc to set the new docs as canonical. The message also mentions that there are internal API changes, which could indicate that the current codebase is out of date or that the development environment has changed.",True,"The commit message mentions the changes made to the upgrading guide for OkHttp 4.x and the modification of the Javadoc for OkHttp 3.x. It also highlights the improvements made to the code, such as the use of Kotlin and the retention of strict compatibility with OkHttp 3.x. Additionally, the message mentions the inclusion of deprecated APIs to facilitate migration and the removal of internal API changes that could cause problems for naughty developers.",True,"The commit message describes the changes made to the OkHttp documentation and codebase. It mentions revising the upgrading guide for OkHttp 4.x, changing the old OkHttp 3.x Javadoc to set the new docs as canonical, and making changes to the codebase to accommodate these changes. The diff supports this description, showing changes to the documentation and the addition of a new commit to the codebase.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on updating the documentation and making changes to the codebase, but it does not explicitly state a principle that guides these changes.",True,"The commit message describes the changes made to the OkHttp 4.x upgrading guide and the Javadoc. It mentions revising the guide, changing the old Javadoc to set the new docs as canonical, and making changes to the codebase to accommodate the migration to Kotlin. The code changes include cherry-picking commits, deleting a temporary folder, and making internal API changes. The commit message does not explicitly describe the functional changes from a user's perspective, but it does imply that the changes are intended to improve compatibility, performance, and usability of OkHttp 4.x, while maintaining compatibility with OkHttp 3.x.",False,"The commit message explains the reason for the commit by mentioning the upgrading guide for OkHttp 4.x and the change in the Javadoc to set the new docs as canonical. The code diff also supports this explanation by showing changes related to the upgrade and the Javadoc. While the changes are small and simple, the explanation in the commit message is necessary to understand the context and purpose of the changes."
https://github.com/spring-projects/spring-boot/commit/4f747d426e0f1b45ec341c021f699c7f25a8c3c2,Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20 ,https://api.github.com/repos/spring-projects/spring-boot/commits/4f747d426e0f1b45ec341c021f699c7f25a8c3c2,"@@ -213,7 +213,7 @@
 		<maven-shade-plugin.version>2.4.3</maven-shade-plugin.version>
 		<maven-site-plugin.version>3.5.1</maven-site-plugin.version>
 		<maven-source-plugin.version>3.0.1</maven-source-plugin.version>
-		<maven-surefire-plugin.version>2.19.2</maven-surefire-plugin.version>
+		<maven-surefire-plugin.version>2.19.1</maven-surefire-plugin.version>
 		<maven-war-plugin.version>3.1.0</maven-war-plugin.version>
 		<versions-maven-plugin.version>2.3</versions-maven-plugin.version>
 	</properties>
",True,"The commit message refers to a change in versioning of the Surefire plugin. It mentions that version 2.19.2 was rebranded as 2.20, which could indicate a problem or inconsistency with the project's dependencies or build tools. By rolling back to version 2.19.1, the commit message is addressing this issue, which is a clear expression of the necessity of changes.",True,"The commit message 'Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20' clearly explains the reason for the change. It's not common sense or easy to infer that the version of Surefire should be downgraded. The message explicitly states that version 2.19.2 was rebranded as 2.20, which might have caused issues in the project, and the change is made to revert back to a stable version.",True,"The commit message 'Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20' directly elaborates the motivation of the code change. It mentions that the version 2.19.2 of Surefire was rebranded as 2.20, which might have caused issues in the previous implementation. Therefore, the change is made to revert back to the stable version 2.19.1.",True,"The commit message 'Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20' indicates that the developer is making a change due to a problem in the software maintenance process. The problem is that version 2.19.2 of the Surefire plugin was rebranded as 2.20, causing a potential issue with the build process. Therefore, the change is necessary to maintain the functionality of the software.",True,"The commit message 'Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20' directly mentions the issue that version 2.19.2 of Surefire was rebranded as 2.20, which might have caused problems in the project. The change to version 2.19.1 is made to fix this issue.",True,"The commit message 'Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20' accurately summarizes the change in the code diff. It clearly states that the version of the maven-surefire-plugin is being changed from 2.19.2 to 2.19.1, and it provides context for this change by mentioning that 2.19.2 was rebranded as 2.20. This not only summarizes the change but also provides additional context, making it a good summary of the diffs.",False,The commit message does not explicitly describe a technical principle underpinning the changes. It simply mentions that the version of the Maven Surefire plugin is being downgraded from 2.19.2 to 2.19.1 due to a rebranding issue. It does not explain why this change is necessary or what it might achieve.,True,"The commit message 'Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20' accurately summarizes the code changes. It explains that the version of the maven-surefire-plugin was changed from 2.19.2 to 2.19.1 due to a rebranding of 2.19.2 to 2.20. This change does not introduce new behaviors, but it does modify the existing behavior by using a different version of the plugin.",False,"The commit message does not lack an explanation. It explicitly states the reason for the change: 'Drop back to Surefire 2.19.1 as 2.19.2 was rebranded as 2.20'. This is important because the version number change might not be immediately obvious from the diff, and the explanation in the commit message helps others understand the reason behind the change."
https://github.com/square/okhttp/commit/4b204037e6415a486df4eadb0c659c666e6b9aba,Remove overlapping package-info.java ,https://api.github.com/repos/square/okhttp/commits/4b204037e6415a486df4eadb0c659c666e6b9aba,"@@ -1,3 +0,0 @@
-/** Support for JDK provider APIs. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3;
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that the package-info.java file is being removed, without providing any context or explanation for why this is necessary.",True,"The commit message 'Remove overlapping package-info.java' clearly describes the necessity of changes. The code diff shows that the package-info.java file is being removed, which is likely due to overlapping or redundant documentation. This is a common practice in software development to avoid confusion and maintain clean code structure.",False,"The commit message does not explicitly describe the necessity of changes. It only states that it is removing an overlapping package-info.java file. However, the code diff does not provide any context about why this file was overlapping or causing any issues.",True,"The commit message 'Remove overlapping package-info.java' suggests that there was an issue with the codebase. The presence of an overlapping package-info.java file could potentially cause confusion or errors, as it might be duplicating information already present in another part of the codebase. This could be considered a problem in the process of software maintenance, as outdated or redundant code can lead to inefficiencies and potential bugs.",False,"The commit message does not directly mention the defects it fixes or the improvements it makes to the code. It only states that it is removing an overlapping package-info.java file, which does not provide any information about the purpose or outcome of the change.",True,"The commit message 'Remove overlapping package-info.java' accurately summarizes the change in the diff. It clearly states that a file named 'package-info.java' is being removed, which is exactly what the diff shows. The diff shows the removal of three lines of code, including a package declaration and a comment, which further supports the message.",False,"The commit message only describes the removal of a file (package-info.java) and does not explain any technical principle underpinning the changes. The code diff shows that the file contained documentation and annotations, but it does not indicate any functional changes to the code.",False,"The commit message only mentions the removal of a file (package-info.java) but does not describe any changes to the functional behavior of the code. The diff shows that the file contained documentation and annotations, but it does not indicate that these were used to introduce new behaviors or modify existing ones.",True,"The commit message 'Remove overlapping package-info.java' clearly explains the reason for the change, which is to eliminate redundant code. The code diff also supports this explanation by showing the removal of three lines that were previously defining the package and its documentation. Therefore, there was no need for an additional explanation in the commit message."
https://github.com/square/retrofit/commit/3b5a795892ac079320f6e4fb0d715a6d1a619122,Adding a human-readable name to the Server interface ,https://api.github.com/repos/square/retrofit/commits/3b5a795892ac079320f6e4fb0d715a6d1a619122,"@@ -35,6 +35,10 @@ public String webUrl() {
     return webUrl;
   }
 
+  public String getType() {
+    return ""production"";
+  }
+
   /**
    * Returns true if we should ignore SSL warnings. Returns false by default.
    * Ignored for development servers.
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that a human-readable name is being added to the Server interface, which does not provide a clear explanation for the necessity of the change.",True,"The commit message 'Adding a human-readable name to the Server interface' does not explicitly explain why the change is necessary. However, it is common sense that adding a method like 'getType' to an interface can improve code readability and maintainability, especially when dealing with multiple implementations of the interface. Therefore, the commit message can be considered to contain an expression that describes the necessity of changes.",False,"The commit message does not explicitly describe the necessity of changes or the motivation behind the code change. It only states that a human-readable name is being added to the Server interface, but it does not elaborate on any errors, issues, or shortcomings of the previous implementation that this change aims to address.",False,"The commit message 'Adding a human-readable name to the Server interface' does not explicitly describe the necessity of changes. It does not mention any user requirements, problems in the process of software maintenance, or changes in the runtime or development environment. The changes made in the code diff are more about adding functionality (a new method 'getType') rather than addressing a specific issue or requirement.",True,"The commit message 'Adding a human-readable name to the Server interface' directly mentions the improvement it makes to the code, which is adding a new method 'getType' to the Server interface. This change makes the code more readable and easier to understand, as it provides a clear name for the type of server.",True,"The commit message 'Adding a human-readable name to the Server interface' accurately summarizes the change made in the diff. The key component of the change is the addition of a new method 'getType()' to the Server interface, which returns a hardcoded string 'production'. This change adds a new feature to the Server interface, making it more human-readable and providing additional information about the server type.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that a new method 'getType' is added to the Server interface, which returns a hardcoded string 'production'. This change does not seem to be based on any specific technical principle.",True,"The commit message 'Adding a human-readable name to the Server interface' does describe a summary of the changes made in the code diff. The added method 'getType()' introduces a new behavior to the Server interface, which is returning a string that describes the type of the server. In this case, it always returns 'production', which is a new behavior introduced by the changes in the code diff.",False,"The commit message does not lack an explanation. Although the change is small and simple, it is not immediately clear why the type of the server is being added. The commit message explicitly states that a human-readable name is being added to the Server interface, which implies that the type might be used for identification or display purposes. Without the commit message, it would not be clear what the 'getType' method is intended for."
https://github.com/square/retrofit/commit/f939189f3b825beb66a499686b9f6ca0f3a70cc1,Expose static factory for Invocation  <enter> Also rework the internals of how an Invocation gets instantiated and set as a tag on the Request. This will make a future change easier to land. ,https://api.github.com/repos/square/retrofit/commits/f939189f3b825beb66a499686b9f6ca0f3a70cc1,"@@ -50,15 +50,19 @@
  * types for parameters!
  */
 public final class Invocation {
-  private final Method method;
-  private final List<?> arguments;
-
-  public Invocation(Method method, List<?> arguments) {
+  public static Invocation of(Method method, List<?> arguments) {
     checkNotNull(method, ""method == null"");
     checkNotNull(arguments, ""arguments == null"");
+    return new Invocation(method, new ArrayList<>(arguments)); // Defensive copy.
+  }
+
+  private final Method method;
+  private final List<?> arguments;
 
+  /** Trusted constructor assumes ownership of {@code arguments}. */
+  Invocation(Method method, List<?> arguments) {
     this.method = method;
-    this.arguments = Collections.unmodifiableList(new ArrayList<>(arguments)); // Immutable copy.
+    this.arguments = Collections.unmodifiableList(arguments);
   }
 
   public Method method() {
@@ -46,14 +46,13 @@ final class RequestBuilder {
   private @Nullable FormBody.Builder formBuilder;
   private @Nullable RequestBody body;
 
-  RequestBuilder(Invocation invocation, String method, HttpUrl baseUrl,
+  RequestBuilder(String method, HttpUrl baseUrl,
       @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
       boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
-    this.requestBuilder = new Request.Builder()
-        .tag(Invocation.class, invocation);
+    this.requestBuilder = new Request.Builder();
     this.contentType = contentType;
     this.hasBody = hasBody;
 
@@ -187,7 +186,7 @@ void setBody(RequestBody body) {
     this.body = body;
   }
 
-  Request build() {
+  Request.Builder get() {
     HttpUrl url;
     HttpUrl.Builder urlBuilder = this.urlBuilder;
     if (urlBuilder != null) {
@@ -226,8 +225,7 @@ Request build() {
 
     return requestBuilder
         .url(url)
-        .method(method, body)
-        .build();
+        .method(method, body);
   }
 
   private static class ContentTypeOverridingRequestBody extends RequestBody {
@@ -21,8 +21,9 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URI;
-import java.util.Arrays;
+import java.util.ArrayList;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -98,15 +99,18 @@ okhttp3.Request create(Object[] args) throws IOException {
           + "") doesn't match expected count ("" + handlers.length + "")"");
     }
 
-    Invocation invocation = new Invocation(method, Arrays.asList(args));
-    RequestBuilder requestBuilder = new RequestBuilder(invocation, httpMethod, baseUrl, relativeUrl,
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
         headers, contentType, hasBody, isFormEncoded, isMultipart);
 
+    List<Object> argumentList = new ArrayList<>(argumentCount);
     for (int p = 0; p < argumentCount; p++) {
+      argumentList.add(args[p]);
       handlers[p].apply(requestBuilder, args[p]);
     }
 
-    return requestBuilder.build();
+    return requestBuilder.get()
+        .tag(Invocation.class, new Invocation(method, argumentList))
+        .build();
   }
 
   /**
@@ -58,7 +58,7 @@ Call<ResponseBody> postMethod(
 
   @Test public void nullMethod() {
     try {
-      new Invocation(null, Arrays.asList(""one"", ""two""));
+      Invocation.of(null, Arrays.asList(""one"", ""two""));
       fail();
     } catch (NullPointerException expected) {
       assertThat(expected).hasMessage(""method == null"");
@@ -67,7 +67,7 @@ Call<ResponseBody> postMethod(
 
   @Test public void nullArguments() {
     try {
-      new Invocation(Example.class.getDeclaredMethods()[0], null);
+      Invocation.of(Example.class.getDeclaredMethods()[0], null);
       fail();
     } catch (NullPointerException expected) {
       assertThat(expected).hasMessage(""arguments == null"");
@@ -76,7 +76,7 @@ Call<ResponseBody> postMethod(
 
   @Test public void argumentsAreImmutable() {
     List<String> mutableList = new ArrayList<>(Arrays.asList(""one"", ""two""));
-    Invocation invocation = new Invocation(Example.class.getDeclaredMethods()[0], mutableList);
+    Invocation invocation = Invocation.of(Example.class.getDeclaredMethods()[0], mutableList);
     mutableList.add(""three"");
     assertThat(invocation.arguments()).isEqualTo(Arrays.asList(""one"", ""two""));
     try {
",True,The commit message refers to the necessity of changes by mentioning that it is making a change to 'the internals of how an Invocation gets instantiated' to 'make a future change easier to land'. This implies that there is a known issue or limitation in the current implementation that is being addressed to facilitate a future change.,True,"The commit message explains that the changes are being made to 'expose a static factory for Invocation' and 'rework the internals of how an Invocation gets instantiated and set as a tag on the Request'. This is done to make a future change easier to land. The necessity of these changes is clear from the explanation in the commit message, which makes it unnecessary to provide a detailed rationale in the code diff.",True,"The commit message explains the motivation for the changes by mentioning that it is making a future change easier to land. This implies that there is a known issue or shortcoming in the previous implementation that is causing difficulties. Additionally, the code diff shows that the constructor for the Invocation class has been changed to a static factory method, which suggests that the previous implementation may have been problematic in some way. Overall, the commit message and code diff both indicate that the changes were made to address a specific issue or shortcoming in the previous implementation.",True,"The commit message indicates that the changes were made to accommodate a future change, which suggests that there was a requirement or need for the changes. Specifically, the message mentions that the changes were made to 'make a future change easier to land', which implies that there is a planned change that the current modifications are preparing for.",True,The commit message directly mentions the improvements it makes to the code by stating that it 'Expose[s] static factory for Invocation' and 'rework[s] the internals of how an Invocation gets instantiated and set as a tag on the Request'. This indicates that the change is intended to simplify the creation of Invocation instances and make a future change easier to land.,True,"The commit message describes the changes made to the code. It mentions the exposure of a static factory for Invocation, which is a key component of the change. It also mentions the reworking of the internals of how an Invocation gets instantiated and set as a tag on the Request, which is another significant change. The message contrasts the before and after state of the code by mentioning the previous way of creating an Invocation and the new static factory method.",True,"The commit message explains that the changes are made to expose a static factory for Invocation, which simplifies the instantiation process and makes it easier to create an immutable copy of the arguments. This follows the principle of encapsulation and immutability, which are important principles in object-oriented programming.",True,"The commit message expresses a change in the instantiation of the Invocation class and its usage in the RequestBuilder class. It introduces a static factory method 'of' in the Invocation class, which makes the instantiation more explicit and easier to use. Additionally, it makes a defensive copy of the arguments to ensure immutability. The message also mentions that this change will make a future change easier to land, which suggests that there are more changes planned in this area. Therefore, the commit message does describe the changes made to the code from a functional perspective and introduces new behaviors.",False,"The commit message explains that the change was made to make a future change easier to land. This suggests that the change is not just a simple fix, but rather a more significant refactoring. The code diff also shows that the change involves renaming methods, adding a static factory method, and modifying the constructor of the Invocation class. These changes are not trivial and would likely require an explanation in the commit message."
https://github.com/junit-team/junit4/commit/5af049cac0c976c586d955607fa459aacb778d3c,Remove unnecessary comments,https://api.github.com/repos/junit-team/junit4/commits/5af049cac0c976c586d955607fa459aacb778d3c,"@@ -19,21 +19,5 @@ public Runner getRunner() {
 		// TODO: (Dec 10, 2007 9:41:13 PM) Should this class exist?
 
 		return new ErrorReportingRunner(fClass, fCause);
-//		List<Throwable> goofs= getCauses(fCause);
-//		CompositeRunner runner= new CompositeRunner(fClass.getName());
-//		for (int i= 0; i < goofs.size(); i++) {
-//			final Description description= Description.createTestDescription(fClass, ""initializationError"" + i);
-//			final Throwable throwable= goofs.get(i);
-//			runner.add(new ErrorReportingRunner(fClass, throwable));
-//		}
-//		return runner;
 	}
-	
-//	private List<Throwable> getCauses(Throwable cause) {
-//		if (cause instanceof InvocationTargetException)
-//			return getCauses(cause.getCause());
-//		if (cause instanceof InitializationError)
-//			return ((InitializationError) cause).getCauses();
-//		return Arrays.asList(cause);	
-//	}
 }
@@ -14,8 +14,6 @@ public class ErrorReportingRunner extends ParentRunner<Throwable> {
 	private final Class<?> fClass;
 
 	public ErrorReportingRunner(Class<?> type, Throwable cause) {
-		// TODO: (Dec 10, 2007 9:35:57 PM) Is this the only time calling super(null)?
-
 		super(null);
 		// TODO: (Dec 10, 2007 9:41:50 PM) remove fClass
 
@@ -1,6 +1,5 @@
 package org.junit.internal.runners;
 
-import java.util.ArrayList;
 import java.util.List;
 
 import org.junit.internal.runners.links.ExpectException;
@@ -29,9 +28,7 @@ public class JUnit4ClassRunner extends ParentRunner<FrameworkMethod> implements
 	public JUnit4ClassRunner(Class<?> klass) throws InitializationError {
 		super(klass);
 		fTestMethods= computeTestMethods();
-		List<Throwable> errors= new ArrayList<Throwable>();
-		collectInitializationErrors(errors);
-		assertValid(errors);
+		validate();
 	}
 	
 	//
@@ -42,6 +39,7 @@ protected List<FrameworkMethod> computeTestMethods() {
 		return getTestClass().getTestMethods();
 	}
 
+	@Override
 	protected void collectInitializationErrors(List<Throwable> errors) {
 		getTestClass().validateMethodsForDefaultRunner(errors);
 	}
@@ -23,7 +23,7 @@
 import org.junit.runner.notification.StoppedByUserException;
 
 public abstract class ParentRunner<T> extends Runner implements Filterable, Sortable {
-	protected final TestClass fTestClass;
+	private final TestClass fTestClass;
 	private List<T> fChildren = null;
 	private Filter fFilter = null;
 	private Sorter fSorter = null;
@@ -35,7 +35,7 @@ public ParentRunner(Class<?> testClass) {
 	//
 	// Must be overridden
 	//
-	
+
 	protected abstract List<T> getChildren();
 	
 	protected abstract Description describeChild(T child);
@@ -46,6 +46,16 @@ public ParentRunner(Class<?> testClass) {
 	// May be overridden
 	//
 	
+	protected void collectInitializationErrors(List<Throwable> errors) {
+	}
+
+	protected Statement classBlock(final RunNotifier notifier) {
+		Statement statement= runChildren(notifier);
+		statement= new RunBefores(statement, fTestClass, null);
+		statement= new RunAfters(statement, fTestClass, null);
+		return statement;
+	}
+	
 	protected Statement runChildren(final RunNotifier notifier) {
 		return new Statement() {
 			@Override
@@ -56,13 +66,6 @@ public void evaluate() {
 		};
 	}
 
-	protected Statement classBlock(final RunNotifier notifier) {
-		Statement statement= runChildren(notifier);
-		statement= new RunBefores(statement, fTestClass, null);
-		statement= new RunAfters(statement, fTestClass, null);
-		return statement;
-	}
-
 	protected Annotation[] classAnnotations() {
 		return fTestClass.getAnnotations();
 	}
@@ -79,15 +82,13 @@ protected final TestClass getTestClass() {
 		return fTestClass;
 	}
 
-	protected final void assertValid(List<Throwable> errors) throws InitializationError {
+	protected void validate() throws InitializationError {
+		List<Throwable> errors= new ArrayList<Throwable>();
+		collectInitializationErrors(errors);
 		if (!errors.isEmpty())
 			throw new InitializationError(errors);
 	}
-	
-	//
-	// Implementation
-	// 
-	
+
 	public void filter(Filter filter) throws NoTestsRemainException {
 		fFilter= filter;
 		
",False,"The commit message 'Remove unnecessary comments' does not reference any conventions, standards, improvements in prior commits, or implemented features. It simply states that the changes made are to remove comments, which does not provide any context or explanation for the necessity of the changes.",True,"The commit message 'Remove unnecessary comments' clearly describes the changes made in the code diff. The removal of comments is a common practice to improve code readability and maintainability, and it is easy to infer the necessity of this change from the commit message.",False,"The commit message 'Remove unnecessary comments' does not directly elaborate the motivation of the code change. It does not mention any error scenario, issue report, or shortcoming of the previous implementation. Instead, it simply states that the changes are made to remove unnecessary comments, which does not provide a clear explanation of the necessity of the changes.",False,"The commit message 'Remove unnecessary comments' does not explicitly describe the necessity of changes. It does not mention any user requirements, problems in the process of software maintenance, or changes in the runtime or development environment.",False,"The commit message 'Remove unnecessary comments' does not directly mention the defects it fixes or the improvements it makes to the code. It only states that unnecessary comments are being removed, which does not provide a clear indication of the purpose or objective of the change.",True,"The commit message 'Remove unnecessary comments' accurately describes the changes made in the code diff. The diff shows the removal of multiple blocks of code, including comments and methods, which aligns with the commit message. This makes the commit message a summary of the changes, as it points out the key components of the change, which is the removal of unnecessary comments and code.",False,"The commit message 'Remove unnecessary comments' does not contain an expression that describes the technical principle underpinning the changes. The changes are related to code refactoring and simplification, but the message does not explicitly state the principle or concept being applied, such as 'simplifying code structure' or 'improving maintainability'.",True,"The commit message 'Remove unnecessary comments' does not directly describe the changes made to the code, but the code diff shows that several lines of code have been removed. These lines of code were responsible for handling multiple throwables and creating a composite runner. By removing these lines, the code now only handles a single throwable and creates a single error reporting runner. This change introduces a new behavior where the code can only handle and report on a single error at a time, rather than multiple errors.",True,"The commit message 'Remove unnecessary comments' clearly indicates that the change made was to remove comments from the code. Since the removed comments were not providing any useful information or explanation about the code, there was no need for an additional explanation in the commit message."
https://github.com/square/okhttp/commit/ea014716fd2a8712ee39888725f91bed43148cd3,"Remove CBC-mode ECDSA cipher suites  <enter> This removes the following cipher suites as supported-by-default:   TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA   TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA <enter> This tracks a similar change in Chromium 56:    https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls  <enter> OkHttp's updated cipher suites, plus comparisons to Android, Java, Chromium, Firefox, and Square's server-site configuration is here:    https://tinyurl.com/okhttp-cipher-suites  <enter>  Closes :  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/ea014716fd2a8712ee39888725f91bed43148cd3,"@@ -54,9 +54,7 @@ public final class ConnectionSpec {
       // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
       // continue to include them until better suites are commonly available. For example, none
       // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
",True,"The commit message refers to a convention or standard by mentioning the removal of CBC-mode ECDSA cipher suites. This is done to track a similar change in Chromium 56 and to align OkHttp's configuration with other platforms like Android, Java, Firefox, and Square's server-side configuration. This change is made to improve security and align with the best practices in the industry.",True,"The commit message explains the necessity of changes by referring to a security vulnerability in the CBC-mode ECDSA cipher suites. This is a common reason for removing or disabling certain cipher suites to improve security. The message also provides a reference to a similar change in Chromium 56, which further supports the need for the change.",True,"The commit message explains the motivation for the code change by mentioning that the change is being made to remove the CBC-mode ECDSA cipher suites due to a similar change in Chromium 56. This is done to address a security vulnerability, as the message provides a link to the Chromium update that explains the issue in more detail. Additionally, the message provides a link to a comparison of OkHttp's updated cipher suites to other platforms, which further elaborates on the necessity of the change.",True,"The commit message indicates that the changes are made due to the need to remove the CBC-mode ECDSA cipher suites. This is done to track a similar change in Chromium 56, which was made due to security concerns. The message also mentions that these cipher suites are being removed as they are on HTTP/2's bad cipher suites list and are not commonly available in better suites. This suggests that the changes are made to improve the security and compatibility of the software.",True,"The commit message directly mentions the objective of the change by stating 'This removes the following cipher suites as supported-by-default' and listing the specific cipher suites that are being removed. This is done to track a similar change in Chromium 56 and to align OkHttp's cipher suites with other popular platforms. The message also provides references to further information about the change, which further supports the claim that the change is being made to address security concerns.",True,The commit message accurately summarizes the changes made in the code diff. It clearly states that it is removing two specific cipher suites (TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA and TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA) that were previously supported by default. This is a clear and concise summary of the changes made in the code diff.,True,"The commit message explains that the change is removing CBC-mode ECDSA cipher suites due to security concerns. This is based on the technical principle that CBC-mode ECDSA cipher suites are less secure than other alternatives, as they are vulnerable to padding oracle attacks. This is a well-known principle in cryptography and network security.",True,"The commit message 'Remove CBC-mode ECDSA cipher suites' clearly describes the functional change made in the code. It explains that the commit removes two specific cipher suites (TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA and TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA) that were previously supported by default. This change is motivated by a similar change in Chromium 56 and the new behavior is described as removing support for these cipher suites, which are known to use CBC mode with ECDSA. This change is likely to improve security.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'This removes the following cipher suites as supported-by-default... This tracks a similar change in Chromium 56... This is done to improve security by removing CBC-mode ECDSA cipher suites, which are considered less secure. The message also provides references for further information."
https://github.com/apache/dubbo/commit/3747cc36fada387a52363fc7dfc97a4c6c2b2670,Remove useless config item in xsd ,https://api.github.com/repos/apache/dubbo/commits/3747cc36fada387a52363fc7dfc97a4c6c2b2670,"@@ -61,9 +61,6 @@ public abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {
     // group
     protected String group;
 
-    // enable dynamic tag
-    protected String enabledynamictag;
-
     public Boolean isCheck() {
         return check;
     }
@@ -313,12 +313,6 @@
                             <![CDATA[ Defines the service tag]]></xsd:documentation>
                     </xsd:annotation>
                 </xsd:attribute>
-                <xsd:attribute name=""enabledynamictag"" type=""xsd:boolean"" default=""false"">
-                    <xsd:annotation>
-                        <xsd:documentation>
-                            <![CDATA[ Defines the service tag]]></xsd:documentation>
-                    </xsd:annotation>
-                </xsd:attribute>
                 <xsd:anyAttribute namespace=""##other"" processContents=""lax""/>
             </xsd:extension>
         </xsd:complexContent>
@@ -313,12 +313,6 @@
                             <![CDATA[ Defines the service tag]]></xsd:documentation>
                     </xsd:annotation>
                 </xsd:attribute>
-                <xsd:attribute name=""enabledynamictag"" type=""xsd:boolean"" default=""false"">
-                    <xsd:annotation>
-                        <xsd:documentation>
-                            <![CDATA[ Defines the service tag]]></xsd:documentation>
-                    </xsd:annotation>
-                </xsd:attribute>
                 <xsd:anyAttribute namespace=""##other"" processContents=""lax""/>
             </xsd:extension>
         </xsd:complexContent>
",True,"The commit message 'Remove useless config item in xsd' explains the necessity of changes by referencing the presence of a 'useless' configuration item in the xsd file. The code diff shows that this 'useless' configuration item, 'enabledynamictag', has been removed. This change might have been made to improve the codebase, adhere to conventions or standards, or to remove redundant or unnecessary features.",True,"The commit message 'Remove useless config item in xsd' does not provide a rationale for the change. The code diff shows that a configuration item 'enabledynamictag' has been removed from the xsd file. However, the reason for this removal is not explained in the commit message. This is a common practice when the necessity of the change is self-evident from the code diff, such as removing an unused or redundant configuration item.",False,"The commit message does not explicitly describe the necessity of the changes. It only mentions removing a 'useless config item' in the xsd, but it does not elaborate on why this config item is considered useless or what problem it might have caused.",False,"The commit message 'Remove useless config item in xsd' does not explicitly describe the necessity of changes by referring to user requirements, problems in the process of software maintenance, or changes in the runtime or development environment. The message only states that a configuration item is being removed, but it does not provide any context or explanation for why this change is necessary.",True,"The commit message 'Remove useless config item in xsd' directly mentions the change made to the code, which is the removal of a configuration item that is no longer needed or used. This indicates that the change was made to improve the code by simplifying it and removing unnecessary elements.",True,"The commit message 'Remove useless config item in xsd' accurately describes the change made in the code diff. The diff shows the removal of a configuration item named 'enabledynamictag' from the xsd file. The commit message summarizes this change by stating that it removes a 'useless' config item, which is a clear reference to the 'enabledynamictag' item removed in the diff.",False,"The commit message 'Remove useless config item in xsd' does not explicitly describe a technical principle underpinning the changes. The code diff shows that a configuration item 'enabledynamictag' is being removed, but the message does not explain why this item was considered useless or what principle it violated.",True,"The commit message 'Remove useless config item in xsd' accurately describes the code changes. The code diff shows that a configuration item 'enabledynamictag' has been removed from the xsd file. This change does not introduce any new behaviors, but rather removes an unnecessary configuration option, which is described in the commit message.",False,"The commit message does not lack an explanation. The 'enabledynamictag' config item is being removed, but the commit message does not clarify why it is no longer needed. The removal of this item could have been due to a variety of reasons, such as it being deprecated, no longer used, or causing issues. Without additional context from the commit message, it is not possible to infer the reason for the change."
https://github.com/apache/dubbo/commit/51e2e80158c1d2f10cf8c38ae533e8c09ef91e9a,Remove unnecessary null check. ,https://api.github.com/repos/apache/dubbo/commits/51e2e80158c1d2f10cf8c38ae533e8c09ef91e9a,"@@ -175,7 +175,7 @@ private static void putRandomPort(String protocol, Integer port) {
     }
 
     public URL toUrl() {
-        return urls == null || urls.isEmpty() ? null : urls.iterator().next();
+        return urls.isEmpty() ? null : urls.iterator().next();
     }
 
     public List<URL> toUrls() {
",,"Error: 504 - {
  ""message"":""The upstream server is timing out"",
  ""request_id"":""9c230f0fca661f04247b6465b93e0824""
}",True,"The commit message 'Remove unnecessary null check' does not explicitly explain why the change is necessary. However, it is easy to infer from the code diff that the null check was unnecessary because it checks if the 'urls' list is empty before returning the next URL. If the list is empty, the function will return null anyway, so the null check is redundant.",,"Error: 504 - {
  ""message"":""The upstream server is timing out"",
  ""request_id"":""349b5079bc92e565367cd505ef554c18""
}",True,"The commit message 'Remove unnecessary null check' indicates that the change was made to simplify the code and improve its efficiency. The code diff shows that a null check for the 'urls' variable was removed. This could be a result of the maintenance of the software, where outdated or unnecessary code is being removed to improve the performance and maintainability of the software.",,"Error: 504 - {
  ""message"":""The upstream server is timing out"",
  ""request_id"":""38d2ff4276c5446af88d875b45815005""
}",True,"The commit message 'Remove unnecessary null check' accurately summarizes the change in the diff. The diff shows that a null check for the 'urls' variable is being removed, which is consistent with the message. This change simplifies the code and improves readability, as it removes an unnecessary condition that was not affecting the outcome of the code.",,argument of type 'float' is not iterable,,"Error: 504 - {
  ""message"":""The upstream server is timing out"",
  ""request_id"":""31243b7b2763262201f4ba2b85882d71""
}",True,"The commit message 'Remove unnecessary null check' clearly indicates that the change was made to simplify the code. The code diff shows that a null check for the 'urls' variable was removed, and it was replaced with a check for 'urls.isEmpty()'. This change makes the code more concise and easier to understand, and the reason for the change is clearly explained in the commit message. Therefore, there was no need for an additional explanation of the change."
https://github.com/square/okhttp/commit/112f020c411c9d14f34e480b98325777b25a7434,Change the cache to have non-shared semantics.  <enter> This means we'll cache responses that use an 'Authorization' header. This means OkHttp's cache shouldn't be used on middleboxes that sit between user agents and the origin server; in practice this is never a use case for OkHttp. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/square/okhttp/commits/112f020c411c9d14f34e480b98325777b25a7434,"@@ -1216,40 +1216,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("""", response.body().string());
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
+  @Test public void authorizationRequestFullyCached() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader(""Last-Modified: "" + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader(""Cache-Control: max-age=60"")
-        .setBody(""A""));
-    server.enqueue(new MockResponse()
-        .setBody(""B""));
-
-    URL url = server.getUrl(""/"");
-    Request request = new Request.Builder()
-        .url(url)
-        .header(""Authorization"", ""password"")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals(""A"", response.body().string());
-    assertEquals(""B"", get(url).body().string());
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: s-maxage=60""));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader(""Cache-Control: public""));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: must-revalidate""));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse
         .addHeader(""Cache-Control: max-age=60"")
         .setBody(""A""));
     server.enqueue(new MockResponse()
@@ -1098,36 +1098,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("""", readAscii(connection));
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader(""Last-Modified: "" + formatDate(-2, TimeUnit.MINUTES))
-            .addHeader(""Cache-Control: max-age=60"")
-            .setBody(""A""));
-    server.enqueue(new MockResponse().setBody(""B""));
-
-    URL url = server.getUrl(""/"");
-    URLConnection connection = client.open(url);
-    connection.addRequestProperty(""Authorization"", ""password"");
-    assertEquals(""A"", readAscii(connection));
-    assertEquals(""B"", readAscii(client.open(url)));
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: s-maxage=60""));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader(""Cache-Control: public""));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: must-revalidate""));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.addHeader(""Cache-Control: max-age=60"").setBody(""A""));
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader(""Cache-Control: max-age=60"").setBody(""A""));
     server.enqueue(new MockResponse().setBody(""B""));
 
     URL url = server.getUrl(""/"");
@@ -917,36 +917,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("""", readAscii(connection));
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader(""Last-Modified: "" + formatDate(-2, TimeUnit.MINUTES))
-            .addHeader(""Cache-Control: max-age=60"")
-            .setBody(""A""));
-    server.enqueue(new MockResponse().setBody(""B""));
-
-    URL url = server.getUrl(""/"");
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty(""Authorization"", ""password"");
-    assertEquals(""A"", readAscii(connection));
-    assertEquals(""B"", readAscii(openConnection(url)));
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: s-maxage=60""));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader(""Cache-Control: public""));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader(""Cache-Control: must-revalidate""));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.addHeader(""Cache-Control: max-age=60"").setBody(""A""));
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader(""Cache-Control: max-age=60"").setBody(""A""));
     server.enqueue(new MockResponse().setBody(""B""));
 
     URL url = server.getUrl(""/"");
@@ -50,17 +50,8 @@ public static boolean isCacheable(Response response, Request request) {
       return false;
     }
 
-    // Responses to authorized requests aren't cacheable unless they include
-    // a 'public', 'must-revalidate' or 's-maxage' directive.
-    CacheControl responseCaching = response.cacheControl();
-    if (request.header(""Authorization"") != null
-        && !responseCaching.isPublic()
-        && !responseCaching.mustRevalidate()
-        && responseCaching.sMaxAgeSeconds() == -1) {
-      return false;
-    }
-
     // A 'no-store' directive on request or response prevents the response from being cached.
+    CacheControl responseCaching = response.cacheControl();
     CacheControl requestCaching = request.cacheControl();
     if (responseCaching.noStore() || requestCaching.noStore()) {
       return false;
",True,"The commit message explains the necessity of changes by referencing a convention. It mentions that the cache should have non-shared semantics, which means it should not be used on middleboxes that sit between user agents and the origin server. This is because responses that use an 'Authorization' header should not be cached. The commit message also refers to this convention by stating that the change is to ensure that OkHttp's cache is not used in this use case, which is never a practical scenario for OkHttp.",True,"The commit message explains the necessity of changes by stating that the cache should have non-shared semantics, which means it should cache responses that use an 'Authorization' header. This is because OkHttp's cache should not be used on middleboxes that sit between user agents and the origin server, and in practice, this is never a use case for OkHttp. The code diff also supports this explanation by removing several tests that previously allowed caching of authorized requests, and adding a new test that ensures authorized requests are fully cached.",True,"The commit message explains the motivation for the change by mentioning that the cache should have non-shared semantics, which means it should not cache responses that use an 'Authorization' header. This is because OkHttp's cache should not be used on middleboxes that sit between user agents and the origin server, and in practice this is never a use case for OkHttp. The message also mentions that this change fixes an issue, which is a good practice as it provides a reference to the issue report or the shortcoming of the previous implementation.",True,"The commit message 'Change the cache to have non-shared semantics' indicates that the developer is addressing the need for software development to meet the requirements of users. Specifically, the change is made to cache responses that use an 'Authorization' header, which suggests that the developer is addressing the need to securely cache user data.",True,"The commit message directly mentions the change made to the cache, stating that it will now have non-shared semantics. This means that the cache will now cache responses that use an 'Authorization' header. This change is made to address the issue where OkHttp's cache was being used in a use case where it should not be, which is when there are middleboxes between user agents and the origin server. The message also mentions that this fixes a specific issue, which is indicated by the 'Fixes <issue_link>' at the end of the message.",True,"The commit message 'Change the cache to have non-shared semantics' accurately describes the change made in the code diff. The diff shows that the cache behavior for requests with an 'Authorization' header has been modified. The commit message highlights this change and explains its implications, which is a clear summary of the diffs.",True,"The commit message explains that the cache has been changed to have non-shared semantics, which means that responses with an 'Authorization' header will be cached. This is a technical principle underpinning the changes, as it describes how the system handles caching in the presence of authorized requests.",True,"The commit message 'Change the cache to have non-shared semantics' accurately describes the functional change in the code. The change allows the cache to store responses that use an 'Authorization' header. This is a significant change as it introduces new behavior into the system, allowing for more responses to be cached. The code diff supports this by modifying the cache control logic to allow caching of authorized requests under certain conditions.",False,"The commit message explains the reason for the change clearly. It mentions that the cache is being changed to have non-shared semantics, which means it will cache responses that use an 'Authorization' header. This is a significant change that cannot be easily inferred from the code diff alone, as it involves modifying the caching behavior of the application."
https://github.com/apache/dubbo/commit/57c13e07430a58e77249b96af9574b3db04e6dba,Remove unused import for unit test ( <pr_link> )  <enter> * clear unused import ,https://api.github.com/repos/apache/dubbo/commits/57c13e07430a58e77249b96af9574b3db04e6dba,"@@ -20,7 +20,6 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
-import java.util.Objects;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -44,7 +44,6 @@
 import org.apache.dubbo.rpc.Filter;
 import org.apache.dubbo.rpc.RpcContext;
 import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.service.GenericException;
 import org.apache.dubbo.rpc.service.GenericService;
 
 import org.junit.Assert;
@@ -17,7 +17,6 @@
 package org.apache.dubbo.config.spring.beans.factory.annotation;
 
 import org.apache.dubbo.config.spring.ServiceBean;
-import org.apache.dubbo.config.spring.api.DemoService;
 import org.apache.dubbo.config.spring.api.HelloService;
 
 import org.junit.Assert;
@@ -30,7 +30,6 @@
 import java.io.IOException;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.Properties;
 import java.util.regex.Pattern;
 
 /**
",True,"The commit message 'Remove unused import for unit test' explains the necessity of changes by referencing the presence of an unused import in the unit test. This is a common practice to keep the codebase clean and efficient, as unused imports can lead to unnecessary dependencies and potential conflicts.",True,"The commit message 'Remove unused import for unit test' clearly states the reason for the change, which is to remove an unused import in the code. This is a common practice to keep the code clean and efficient, and it is easy to infer that the removal of the import is not necessary for the functionality of the code, but rather for code maintenance and organization.",False,"The commit message does not explicitly describe the necessity of changes by elaborating the motivation of a code change. It only mentions the removal of an unused import for a unit test, but it does not explain any error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message 'Remove unused import for unit test' indicates that the developer removed an import statement that was not being used in the unit test. This could be a result of refactoring or cleaning up the code, which is a good practice to maintain code quality and performance. However, it does not explicitly describe the source of the requirement or problem. However, it can be inferred that the requirement or problem was likely the presence of unused code, which can lead to confusion and inefficiency.",True,"The commit message 'Remove unused import for unit test' directly mentions the objective of the change, which is to clean up the code by removing an unused import. This improves the readability and maintainability of the code.",True,"The commit message 'Remove unused import for unit test' accurately summarizes the change made in the diff. It specifically mentions the removal of an unused import, which is the key component of the change. The diff also confirms this by showing the removal of the 'import java.util.Objects;' line from the code.",False,The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions the removal of an unused import for a unit test. The code diff does not provide any context or explanation for why the import was removed or how it affects the overall functionality of the code.,True,"The commit message 'Remove unused import for unit test' does express a summary of the changes by explaining the code changes from a functional perspective. It clearly states that the change is to remove an unused import, which is a modification to the codebase that doesn't introduce new behaviors but rather improves code cleanliness and maintainability. However, the code diff provided does not introduce any new behaviors or functional changes, so the message does not describe any new behaviors introduced.",False,"The commit message does not explicitly state the reason for the removal of the import. While it's clear from the diff that the import is no longer used, it's still good practice to include a brief explanation in the commit message for clarity and future reference."
https://github.com/junit-team/junit4/commit/eedd1f68fbd014beca60c979e8173c271ea5cf2d,"Upate TestName to make the 'name' field volatile.  <enter> This ensures that the name is published across threads correctly--for instance, if a parallelized runner is used. <enter>  Closes   <pr_link> ",https://api.github.com/repos/junit-team/junit4/commits/eedd1f68fbd014beca60c979e8173c271ea5cf2d,"@@ -25,7 +25,7 @@
  * @since 4.7
  */
 public class TestName extends TestWatcher {
-    private String name;
+    private volatile String name;
 
     @Override
     protected void starting(Description d) {
",True,"The commit message explains the necessity of changes by referencing a convention. It mentions that making the 'name' field volatile ensures that the name is published across threads correctly, especially if a parallelized runner is used. This is a common practice to prevent visibility problems in multi-threaded environments.",True,"The commit message explains the necessity of the change by stating that making the 'name' field volatile ensures that the name is published across threads correctly, which is particularly important if a parallelized runner is used. This is not a common sense or easy to infer change, as the correctness of multithreaded code can be difficult to predict and debug without proper synchronization.",True,"The commit message explains the necessity of the change by mentioning that making the 'name' field volatile ensures that the name is published across threads correctly. This is particularly important if a parallelized runner is used, which could lead to inconsistent or unexpected behavior if the 'name' field was not volatile.",True,"The commit message mentions the need to make the 'name' field volatile to ensure that the name is published across threads correctly, especially if a parallelized runner is used. This is a common issue in multi-threaded programming where shared data can lead to inconsistencies. Therefore, the commit message does describe the necessity of changes by describing the problem in the process of software maintenance.",True,"The commit message directly mentions the objective of the change by stating that making the 'name' field volatile ensures that the name is published across threads correctly, especially if a parallelized runner is used. This directly addresses the potential issue of thread safety and improves the code.",True,"The commit message accurately summarizes the change made in the code diff. It clearly states that the 'name' field has been updated to be volatile. This is a direct reflection of the change in the code diff where 'private String name;' has been changed to 'private volatile String name;'. The message also provides a reason for the change, which is to ensure that the name is published across threads correctly, which is a good explanation of why this change was necessary.",True,The commit message explains that the 'name' field is made volatile to ensure that the name is published across threads correctly. This is a common technique used in multi-threaded programming to ensure that changes made by one thread are visible to other threads. This is a clear expression of the technical principle underpinning the changes.,True,"The commit message expresses a change in the code and specifies that the behavior only applies to the 'name' field. It clearly states that the 'name' field is being made volatile, which is a change in the code that introduces new behavior. This change ensures that the 'name' is published across threads correctly, which is a functional perspective of the code change.",False,"The commit message does not lack an explanation. It clearly states the reason for the change, which is to make the 'name' field volatile to ensure that the name is published across threads correctly, especially when a parallelized runner is used."
https://github.com/square/retrofit/commit/999c72be0468664c711159cd53deff79e62ee4a1,Refactor Rx tests to avoid the use of blocking operators. ,https://api.github.com/repos/square/retrofit/commits/999c72be0468664c711159cd53deff79e62ee4a1,"@@ -4,7 +4,7 @@ Retrofit Adapters
 Retrofit ships with a default adapter for executing `Call` instances. The child modules contained
 herein are additional adapters for other popular execution mechanisms.
 
-To use, supply an instance of your desired converter when building your `Retrofit` instance.
+To use, supply an instance of your desired adapter when building your `Retrofit` instance.
 
 ```java
 Retrofit retrofit = new Retrofit.Builder()
@@ -4,12 +4,17 @@
 
 /** Exception for an unexpected, non-2xx HTTP response. */
 public final class HttpException extends Exception {
+  private static String getMessage(Response<?> response) {
+    if (response == null) throw new NullPointerException(""response == null"");
+    return ""HTTP "" + response.code() + "" "" + response.message();
+  }
+
   private final int code;
   private final String message;
   private final transient Response<?> response;
 
   public HttpException(Response<?> response) {
-    super(""HTTP "" + response.code() + "" "" + response.message());
+    super(getMessage(response));
     this.code = response.code();
     this.message = response.message();
     this.response = response;
@@ -24,9 +24,11 @@
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
+import rx.Completable;
 import rx.Observable;
 import rx.Producer;
 import rx.Scheduler;
+import rx.Single;
 import rx.Subscriber;
 import rx.Subscription;
 import rx.exceptions.Exceptions;
@@ -35,15 +37,16 @@
 /**
  * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables.
  * <p>
- * Adding this class to {@link Retrofit} allows you to return {@link Observable} from service
- * methods.
+ * Adding this class to {@link Retrofit} allows you to return an {@link Observable}, {@link Single},
+ * or {@link Completable} from service methods.
  * <pre><code>
  * interface MyService {
  *   &#64;GET(""user/me"")
  *   Observable&lt;User&gt; getUser()
  * }
  * </code></pre>
- * There are three configurations supported for the {@code Observable} type parameter:
+ * There are three configurations supported for the {@code Observable} or {@code Single} type
+ * parameter:
  * <ul>
  * <li>Direct body (e.g., {@code Observable<User>}) calls {@code onNext} with the deserialized body
  * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
@@ -54,6 +57,10 @@
  * <li>Result wrapped body (e.g., {@code Observable<Result<User>>}) calls {@code onNext} with a
  * {@link Result} object for all HTTP responses and errors.</li>
  * </ul>
+ * <p>
+ * <em>Note:</em> Support for {@link Single} and {@link Completable} is experimental and subject
+ * to backwards-incompatible changes at any time since both of these types are not considered
+ * stable by RxJava.
  */
 public final class RxJavaCallAdapterFactory extends CallAdapter.Factory {
   /**
@@ -24,10 +24,10 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
+import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class CompletableTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -48,29 +48,26 @@ interface Service {
 
   @Test public void completableSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
-    service.completable().await();
+
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    subscriber.assertCompleted();
   }
 
   @Test public void completableSuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    try {
-      service.completable().await();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
-    }
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    Throwable cause = subscriber.getOnErrorEvents().get(0);
+    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
   }
 
   @Test public void completableFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    try {
-      service.completable().await();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 }
@@ -26,7 +26,7 @@
 import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class CompletableSchedulerTest {
+public final class CompletableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import org.junit.Test;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class HttpExceptionTest {
+  @Test public void response() {
+    Response<String> response = Response.success(""Hi"");
+    HttpException exception = new HttpException(response);
+    assertThat(exception.code()).isEqualTo(200);
+    assertThat(exception.message()).isEqualTo(""OK"");
+    assertThat(exception.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      new HttpException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage(""response == null"");
+    }
+  }
+}
@@ -25,12 +25,10 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.observables.BlockingObservable;
 import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class ObservableTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -55,33 +53,29 @@ interface Service {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    assertThat(o.first()).isEqualTo(""Hi"");
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertValues(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
-    }
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoValues();
+    Throwable cause = subscriber.getOnErrorEvents().get(0);
+    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void bodyRespectsBackpressure() {
@@ -103,31 +97,32 @@ interface Service {
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.first();
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    Response<String> response = subscriber.getOnNextEvents().get(0);
     assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void responseSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.first();
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    Response<String> response = subscriber.getOnNextEvents().get(0);
     assertThat(response.isSuccessful()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void responseRespectsBackpressure() {
@@ -149,32 +144,38 @@ interface Service {
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
     assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void resultSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
     assertThat(response.isSuccessful()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo(""Hi"");
+    subscriber.assertCompleted();
   }
 
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
   }
 
   @Test public void resultRespectsBackpressure() {
@@ -27,7 +27,7 @@
 import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class ObservableSchedulerTest {
+public final class ObservableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
@@ -25,11 +25,10 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.singles.BlockingSingle;
+import rx.observers.TestSubscriber;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class SingleTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -54,70 +53,62 @@ interface Service {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    assertThat(o.value()).isEqualTo(""Hi"");
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertValue(""Hi"");
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
-    }
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    Throwable cause = subscriber.getOnErrorEvents().get(0);
+    assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 Client Error"");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.value();
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    Response<String> response = subscriber.getOnNextEvents().get(0);
     assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo(""Hi"");
   }
 
   @Test public void responseSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.value();
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    Response<String> response = subscriber.getOnNextEvents().get(0);
     assertThat(response.isSuccessful()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo(""Hi"");
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody(""Hi""));
 
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
     assertThat(response.isSuccessful()).isTrue();
@@ -127,8 +118,9 @@ interface Service {
   @Test public void resultSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
     assertThat(response.isSuccessful()).isFalse();
@@ -138,8 +130,9 @@ interface Service {
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.getOnNextEvents().get(0);
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
@@ -27,7 +27,7 @@
 import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class SingleSchedulerTest {
+public final class SingleWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
",True,"The commit message refers to a convention regarding the use of RxJava, specifically avoiding the use of blocking operators. This explains why the commit refactors the Rx tests to not use blocking operators, which is a common practice to avoid blocking the thread and improve performance.",True,"The commit message 'Refactor Rx tests to avoid the use of blocking operators' clearly explains the necessity of the changes. The code diff shows that the tests were refactored to use non-blocking operators, which is a common best practice in RxJava to avoid blocking the thread and improve performance.",True,"The commit message 'Refactor Rx tests to avoid the use of blocking operators' suggests that the motivation for the change is to improve the test suite by avoiding the use of blocking operators, which can lead to thread blocking and potential deadlocks. This is a common best practice in RxJava to ensure that the tests are non-blocking and can handle asynchronous operations effectively.",True,"The commit message 'Refactor Rx tests to avoid the use of blocking operators' indicates that the developer is making changes to improve the efficiency and responsiveness of the tests. This could be due to the need for better performance or to address issues with the current implementation, such as the use of blocking operators which can lead to thread blocking and poor test execution. This suggests that there may be a problem in the process of software maintenance that is being addressed.",True,"The commit message 'Refactor Rx tests to avoid the use of blocking operators' directly mentions the change that is being made to the code. It indicates that the change is being made to improve the code by removing the use of blocking operators in the Rx tests. This change aims to make the tests more efficient and non-blocking, which is an improvement to the code.",True,"The commit message 'Refactor Rx tests to avoid the use of blocking operators' accurately describes the changes made in the code diff. The diff shows the removal of blocking operators from the Rx tests, which is a significant refactoring change. The message also contrasts the before and after state of the code, making it clear that the change is a refactoring to avoid blocking operators.",True,"The commit message 'Refactor Rx tests to avoid the use of blocking operators' describes the technical principle underpinning the changes, which is the use of non-blocking operators in RxJava to improve the efficiency and responsiveness of the tests.",True,"The commit message 'Refactor Rx tests to avoid the use of blocking operators' describes a change in the codebase that aims to improve the asynchronous behavior of the tests. Specifically, it mentions the removal of blocking operators, which are used to convert asynchronous operations into synchronous ones. This change likely introduces new behaviors in the tests, such as the ability to handle multiple operations concurrently and the use of schedulers to control when and where operations are executed. The code diff supports this interpretation by showing changes to test classes that use RxJava's Observable, Single, and Completable types, which are all asynchronous and non-blocking. Additionally, the diff shows the addition of new test classes for HttpException and the use of TestSubscriber to handle asynchronous operations in a more flexible and efficient way.",False,"The commit message does not lack an explanation. While the change is small and simple, the reason for the commit is to refactor the tests to avoid the use of blocking operators. This is important because blocking operators can lead to performance issues and deadlocks, and using non-blocking operators is a best practice for reactive programming."
https://github.com/square/okhttp/commit/ff7946416d86aedcf154b868ba869241cd4816e9,"Add some pings to force happens-before in SPDY tests.  <enter> Previously we were relying on accidents to get our tests to pass. There may still be some that require work, but this should fix the three tests that I saw fail. <enter>  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/ff7946416d86aedcf154b868ba869241cd4816e9,"@@ -97,12 +97,15 @@ public final class SpdyConnectionTest {
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries(""b"", ""banana""));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries(""a"", ""android""), false, false);
     assertEquals(1, connection.openStreamCount());
     assertEquals(headerEntries(""b"", ""banana""), stream.getResponseHeaders());
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
   }
 
@@ -334,12 +337,10 @@ public final class SpdyConnectionTest {
     SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
-    synchronized (connection) {
-      assertEquals(0, connection.peerSettings.getHeaderTableSize());
-      Http20Draft10.Reader frameReader = (Http20Draft10.Reader) connection.frameReader;
-      assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
-      // TODO: when supported, check the frameWriter's compression table is unaffected.
-    }
+    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    Http20Draft10.Reader frameReader = (Http20Draft10.Reader) connection.frameReader;
+    assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
+    // TODO: when supported, check the frameWriter's compression table is unaffected.
   }
 
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
@@ -350,9 +351,7 @@ public final class SpdyConnectionTest {
     SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
-    synchronized (connection) {
-      assertFalse(connection.peerSettings.getEnablePush(true));
-    }
+    assertFalse(connection.peerSettings.getEnablePush(true));
   }
 
   @Test public void serverSendsSettingsToClient() throws Exception {
@@ -652,13 +651,16 @@ public final class SpdyConnectionTest {
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries(""b"", ""banana""));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8(""square""));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries(""a"", ""android""), false, true);
     Source source = stream.getSource();
     assertStreamData(""square"", source);
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -1516,6 +1518,8 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     peer.setVariantAndClient(HTTP_20_DRAFT_09, client);
     peer.sendFrame().settings(settings);
     peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
@@ -1526,6 +1530,8 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     assertEquals(TYPE_SETTINGS, ackFrame.type);
     assertEquals(0, ackFrame.streamId);
     assertTrue(ackFrame.ack);
+
+    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
     return connection;
   }
 
",True,"The commit message refers to the necessity of changes by mentioning that previously the tests were relying on accidents to pass. The commit adds pings to force happens-before in SPDY tests, which is done to ensure that the tests pass consistently and not by chance. This is a clear reference to a convention or standard (consistent test passing) and an improvement in prior commits.",True,"The commit message explains the necessity of changes by stating that previously, the tests were relying on accidents to pass. The changes added pings to force happens-before in SPDY tests, which is necessary to ensure the tests pass consistently and reliably. This is not a common sense or easy to infer change, as it requires explicit code modifications to ensure the tests pass.",True,"The commit message explains the motivation for the changes by mentioning that previously they were relying on accidents to get their tests to pass. It also mentions that there may still be some tests that require work, but this commit should fix the three tests that the author saw fail. This indicates that the changes are being made to address a specific issue or problem, which is a clear expression of necessity.",True,The commit message 'Add some pings to force happens-before in SPDY tests. Previously we were relying on accidents to get our tests to pass.' indicates that the developer made changes to ensure that tests pass reliably. This suggests that there was a problem in the previous process where tests were failing due to unintended circumstances. This is an expression of the necessity of changes to address a problem in the software maintenance process.,True,The commit message directly mentions the issue it fixes by stating 'Previously we were relying on accidents to get our tests to pass. This should fix the three tests that I saw fail.' This clearly indicates that the change is made to improve the code and fix specific issues or defects.,True,"The commit message 'Add some pings to force happens-before in SPDY tests' accurately summarizes the changes made in the diff. The changes involve adding ping frames to the code, which is mentioned in the commit message. This is a key component of the change, and the message contrasts the before and after state of the code by mentioning that previously the tests were relying on accidents to pass, but now ping frames are being added to ensure the tests pass reliably.",True,"The commit message explains that the changes are made to ensure that certain operations happen before others in the SPDY tests. This is a common technique in concurrent programming to ensure correctness and avoid race conditions. The technical principle underpinning the changes is the 'happens-before' relationship, which is a principle in concurrent programming that describes the order in which operations appear to have occurred.",True,"The commit message describes the changes made to the code from a functional perspective. It mentions adding pings to force happens-before in SPDY tests, which was previously relying on accidents. The code diff shows that pings are being sent and received in various parts of the test suite. This indicates that the changes are introducing new behaviors, specifically ensuring that certain frames are received before others, which was not previously guaranteed.",False,"The commit message explains the reason for the change, which is to add pings to force happens-before in SPDY tests. This is not a trivial change and requires explicit explanation in the commit message."
https://github.com/square/retrofit/commit/c3633423b4a52566446bc6d540904f1f5f715205,"Re-work unresolvable type detection in parameters  <enter> In order to natively support Kotlin's 'suspend' modifier in the future, we need to allow wildcards to be used for the last parameter. As a result, we only validate the shape of a type once a Retrofit annotation is detected. ",https://api.github.com/repos/square/retrofit/commits/c3633423b4a52566446bc6d540904f1f5f715205,"@@ -171,18 +171,7 @@ RequestFactory build() {
       int parameterCount = parameterAnnotationsArray.length;
       parameterHandlers = new ParameterHandler<?>[parameterCount];
       for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(method, p,
-              ""Parameter type must not include a type variable or wildcard: %s"", parameterType);
-        }
-
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(method, p, ""No Retrofit annotation found."");
-        }
-
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+        parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);
       }
 
       if (relativeUrl == null && !gotUrl) {
@@ -290,21 +279,24 @@ private Headers parseHeaders(String[] headers) {
     }
 
     private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
+        int p, Type parameterType, @Nullable Annotation[] annotations) {
       ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+      if (annotations != null) {
+        for (Annotation annotation : annotations) {
+          ParameterHandler<?> annotationAction =
+              parseParameterAnnotation(p, parameterType, annotations, annotation);
 
-        if (annotationAction == null) {
-          continue;
-        }
+          if (annotationAction == null) {
+            continue;
+          }
 
-        if (result != null) {
-          throw parameterError(method, p, ""Multiple Retrofit annotations found, only one allowed."");
-        }
+          if (result != null) {
+            throw parameterError(method, p,
+                ""Multiple Retrofit annotations found, only one allowed."");
+          }
 
-        result = annotationAction;
+          result = annotationAction;
+        }
       }
 
       if (result == null) {
@@ -317,6 +309,7 @@ private ParameterHandler<?> parseParameter(
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
+        validateResolvableType(p, type);
         if (gotUrl) {
           throw parameterError(method, p, ""Multiple @Url method annotations found."");
         }
@@ -349,6 +342,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof Path) {
+        validateResolvableType(p, type);
         if (gotQuery) {
           throw parameterError(method, p, ""A @Path parameter must not come after a @Query."");
         }
@@ -375,6 +369,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.Path<>(name, converter, path.encoded());
 
       } else if (annotation instanceof Query) {
+        validateResolvableType(p, type);
         Query query = (Query) annotation;
         String name = query.value();
         boolean encoded = query.encoded();
@@ -405,6 +400,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof QueryName) {
+        validateResolvableType(p, type);
         QueryName query = (QueryName) annotation;
         boolean encoded = query.encoded();
 
@@ -434,6 +430,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof QueryMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         gotQueryMap = true;
         if (!Map.class.isAssignableFrom(rawParameterType)) {
@@ -456,6 +453,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
       } else if (annotation instanceof Header) {
+        validateResolvableType(p, type);
         Header header = (Header) annotation;
         String name = header.value();
 
@@ -484,6 +482,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof HeaderMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
           throw parameterError(method, p, ""@HeaderMap parameter type must be Map."");
@@ -505,6 +504,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.HeaderMap<>(valueConverter);
 
       } else if (annotation instanceof Field) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p, ""@Field parameters can only be used with form encoding."");
         }
@@ -539,6 +539,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof FieldMap) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p,
               ""@FieldMap parameters can only be used with form encoding."");
@@ -565,6 +566,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
 
       } else if (annotation instanceof Part) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               ""@Part parameters can only be used with multipart encoding."");
@@ -646,6 +648,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         }
 
       } else if (annotation instanceof PartMap) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               ""@PartMap parameters can only be used with multipart encoding."");
@@ -680,6 +683,7 @@ private ParameterHandler<?> parseParameterAnnotation(
         return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
 
       } else if (annotation instanceof Body) {
+        validateResolvableType(p, type);
         if (isFormEncoded || isMultipart) {
           throw parameterError(method, p,
               ""@Body parameters cannot be used with form or multi-part encoding."");
@@ -702,6 +706,13 @@ private ParameterHandler<?> parseParameterAnnotation(
       return null; // Not a Retrofit annotation.
     }
 
+    private void validateResolvableType(int p, Type type) {
+      if (Utils.hasUnresolvableType(type)) {
+        throw parameterError(method, p,
+            ""Parameter type must not include a type variable or wildcard: %s"", type);
+      }
+    }
+
     private void validatePathName(int p, String name) {
       if (!PARAM_NAME_REGEX.matcher(name).matches()) {
         throw parameterError(method, p, ""@Path parameter name must match %s. Found: %s"",
",True,"The commit message explains the necessity of changes by referencing a future feature, which is the native support for Kotlin's 'suspend' modifier. This feature requires allowing wildcards to be used for the last parameter, which is why the commit message mentions that the shape of a type is only validated once a Retrofit annotation is detected. Additionally, the commit message mentions that unresolvable type detection in parameters is being re-worked to support this feature.",True,"The commit message explains the necessity of changes by stating that the changes are made to natively support Kotlin's 'suspend' modifier in the future. This is done by allowing wildcards to be used for the last parameter. The commit message also explains that this change is needed because the current implementation only validates the shape of a type once a Retrofit annotation is detected, which causes issues with unresolvable types. The code diff supports this explanation by showing the removal of the type validation for unresolvable types and the addition of a new method to validate the type only when a Retrofit annotation is detected.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that the changes are made to natively support Kotlin's 'suspend' modifier in the future. This is done by allowing wildcards to be used for the last parameter. The reason for this change is that previously, the code was validating the shape of a type for every parameter, which was causing issues with unresolvable types. Now, the code only validates the shape of a type once a Retrofit annotation is detected, which resolves the issue and allows for the support of Kotlin's 'suspend' modifier.",True,The commit message indicates the necessity of changes by describing the source of the requirements. The developer mentions that the changes are needed to 'natively support Kotlin's 'suspend' modifier in the future'. This implies that the changes are being made to accommodate for a new feature or requirement in the software development process.,True,"The commit message directly mentions the objective of the change by stating that it is re-working unresolvable type detection in parameters. This is to allow wildcards to be used for the last parameter, which is done to natively support Kotlin's 'suspend' modifier in the future. This change improves the code by allowing for more flexibility and compatibility with future versions of Kotlin.",True,"The commit message accurately summarizes the changes made in the code diff. It mentions the re-work of unresolvable type detection in parameters, which is a key component of the change. Additionally, it explains that the change allows wildcards to be used for the last parameter, which is also a significant modification mentioned in the code diff.",True,"The commit message explains that the changes are made to natively support Kotlin's 'suspend' modifier in the future. This is achieved by allowing wildcards to be used for the last parameter. The technical principle underpinning the changes is the need to validate the shape of a type once a Retrofit annotation is detected, which was not previously done for parameters with wildcards. This is evident in the code diff where a new function `validateResolvableType` is added to check for unresolvable types in parameters annotated with Retrofit annotations.",True,"The commit message expresses a significant change in the codebase, specifically reworking the unresolvable type detection in parameters. It explains that the change is made to natively support Kotlin's 'suspend' modifier in the future. This is done by allowing wildcards to be used for the last parameter and only validating the shape of a type once a Retrofit annotation is detected. This change introduces new behavior, as it modifies how the code handles unresolvable types and annotations, which can lead to different outcomes when the code is executed.",False,"The commit message explains the reason for the change, which is to allow wildcards to be used for the last parameter in order to natively support Kotlin's 'suspend' modifier in the future. This change is not easily inferred from the code diff alone, as it involves modifying the validation logic for Retrofit annotations."
https://github.com/square/okhttp/commit/53e12cca33f7d24cd8ea6c6ead262559b3553fbb,Request entity tests for the Apache client shim. ,https://api.github.com/repos/square/okhttp/commits/53e12cca33f7d24cd8ea6c6ead262559b3553fbb,"@@ -2,28 +2,40 @@
 
 import com.google.mockwebserver.MockResponse;
 import com.google.mockwebserver.MockWebServer;
+import com.google.mockwebserver.RecordedRequest;
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.util.Arrays;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.ByteArrayEntity;
+import org.apache.http.entity.InputStreamEntity;
 import org.apache.http.util.EntityUtils;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class OkApacheClientTest {
-  private MockWebServer server = new MockWebServer();
-  private OkApacheClient client = new OkApacheClient();
+  private MockWebServer server;
+  private OkApacheClient client;
+
+  @Before public void setUp() throws IOException {
+    client = new OkApacheClient();
+    server = new MockWebServer();
+    server.play();
+  }
 
   @After public void tearDown() throws IOException {
     server.shutdown();
   }
 
   @Test public void success() throws Exception {
     server.enqueue(new MockResponse().setBody(""Hello, World!""));
-    server.play();
 
     HttpGet request = new HttpGet(server.getUrl(""/"").toURI());
     HttpResponse response = client.execute(request);
@@ -34,7 +46,6 @@ public class OkApacheClientTest {
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(302).addHeader(""Location"", ""/foo""));
     server.enqueue(new MockResponse().setBody(""Hello, Redirect!""));
-    server.play();
 
     HttpGet request = new HttpGet(server.getUrl(""/"").toURI());
     HttpResponse response = client.execute(request);
@@ -44,7 +55,6 @@ public class OkApacheClientTest {
 
   @Test public void sessionExpired() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(422));
-    server.play();
 
     HttpGet request = new HttpGet(server.getUrl(""/"").toURI());
     HttpResponse response = client.execute(request);
@@ -54,7 +64,6 @@ public class OkApacheClientTest {
   @Test public void headers() throws Exception {
     server.enqueue(new MockResponse().addHeader(""Foo"", ""Bar""));
     server.enqueue(new MockResponse().addHeader(""Foo"", ""Bar"").addHeader(""Foo"", ""Baz""));
-    server.play();
 
     HttpGet request1 = new HttpGet(server.getUrl(""/"").toURI());
     HttpResponse response1 = client.execute(request1);
@@ -72,9 +81,34 @@ public class OkApacheClientTest {
 
   @Test public void noEntity() throws Exception {
     server.enqueue(new MockResponse());
-    server.play();
 
     HttpPost post = new HttpPost(server.getUrl(""/"").toURI());
     client.execute(post);
   }
+
+  @Test public void postByteEntity() throws Exception {
+    server.enqueue(new MockResponse());
+
+    final HttpPost post = new HttpPost(server.getUrl(""/"").toURI());
+    byte[] body = ""Hello, world!"".getBytes(""UTF-8"");
+    post.setEntity(new ByteArrayEntity(body));
+    client.execute(post);
+
+    RecordedRequest request = server.takeRequest();
+    assertTrue(Arrays.equals(body, request.getBody()));
+    assertEquals(request.getHeader(""Content-Length""), ""13"");
+  }
+
+  @Test public void postInputStreamEntity() throws Exception {
+    server.enqueue(new MockResponse());
+
+    final HttpPost post = new HttpPost(server.getUrl(""/"").toURI());
+    byte[] body = ""Hello, world!"".getBytes(""UTF-8"");
+    post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
+    client.execute(post);
+
+    RecordedRequest request = server.takeRequest();
+    assertTrue(Arrays.equals(body, request.getBody()));
+    assertEquals(request.getHeader(""Content-Length""), ""13"");
+  }
 }
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features. It simply states that the commit adds tests for the Apache client shim, but it does not explain why these tests are necessary or how they improve the codebase.",True,"The commit message 'Request entity tests for the Apache client shim' clearly states the reason for the changes, which is to add tests for handling different types of request entities in the Apache client shim. This is a common practice in software development to ensure the correctness of the code and to prevent regressions in the future. The code diff also supports this explanation by showing the addition of new test methods for handling byte array entities and input stream entities.",False,"The commit message 'Request entity tests for the Apache client shim' does not directly elaborate the motivation of the code change. It does not mention any error scenario, issue report, or shortcoming of the previous implementation that necessitated the changes. The code diff, however, shows that new tests have been added for handling different types of request entities, which might indicate that there was a need for these tests due to a problem or a shortcoming in the previous implementation.",True,"The commit message 'Request entity tests for the Apache client shim' indicates that the changes were made to add tests for handling different types of request entities in the Apache client shim. This suggests that the need for the changes was to improve the robustness and reliability of the software, likely in response to issues or requirements identified during testing or usage.",True,"The commit message 'Request entity tests for the Apache client shim' indicates that the change is adding tests for handling different types of entities in the Apache client shim. This suggests that the change is improving the code by adding more comprehensive testing, which can help to fix any existing defects or issues related to entity handling.",True,"The commit message 'Request entity tests for the Apache client shim' accurately summarizes the changes made in the diff. Specifically, it highlights the addition of tests for handling different types of request entities, such as ByteArrayEntity and InputStreamEntity, which were not previously tested.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on adding tests for the Apache client shim, which is a functional change rather than a change based on a specific technical principle.",True,"The commit message 'Request entity tests for the Apache client shim' does describe a summary of the changes made in the code diff. The changes include the addition of tests for handling different types of request entities, such as ByteArrayEntity and InputStreamEntity, which were not previously tested. This introduces new behaviors in the code, specifically the ability to handle these types of entities in HTTP requests.",False,The commit message does not lack an explanation. It specifically mentions 'Request entity tests for the Apache client shim'. This is a clear indication that the changes made are to add tests for handling different types of request entities in the Apache client shim. The code diff also supports this explanation by showing the addition of tests for byte array entities and input stream entities.
https://github.com/spring-projects/spring-boot/commit/3eb5c348fb93a416d5dcd0003d3273570a217589,"Align test with Spring MVC's internals once again  <enter> The internals have been updated so that the field that was originally used, interceptors, can be used again. <enter> This reverts commit  <otherCommit_link> . ",https://api.github.com/repos/spring-projects/spring-boot/commits/3eb5c348fb93a416d5dcd0003d3273570a217589,"@@ -148,7 +148,7 @@ public void onDifferentPort() throws Exception {
 		assertContent(""/endpoint"", ports.get().management, ""endpointoutput"");
 		List<?> interceptors = (List<?>) ReflectionTestUtils.getField(
 				this.applicationContext.getBean(EndpointHandlerMapping.class),
-				""handlerInterceptors"");
+				""interceptors"");
 		assertEquals(1, interceptors.size());
 		this.applicationContext.close();
 		assertAllClosed();
",True,"The commit message refers to a convention of Spring MVC's internals, specifically mentioning the 'interceptors' field that was originally used but is now available again. This explains why the commit is making changes to the test code, as the internals have been updated and the test needs to be aligned with these changes.",True,"The commit message 'Align test with Spring MVC's internals once again' does not explicitly state the reason for the changes, but it is easy to infer from the code diff that the changes were made to keep the test in sync with the updated Spring MVC internals. Specifically, the name of the field used in the test was changed from 'handlerInterceptors' to 'interceptors' to match the updated internals. This is a common practice in testing to ensure that the test is still valid and accurate after changes have been made to the codebase.",True,"The commit message explains the motivation for the code change by mentioning that the internals of Spring MVC have been updated, which caused the previously used field 'interceptors' to no longer be accessible. The commit message then explains that the change is necessary to align the test with Spring MVC's updated internals and to make the field 'interceptors' usable again. This directly elaborates the motivation of the code change and describes the shortcoming of the previous implementation.",True,"The commit message 'Align test with Spring MVC's internals once again' indicates that the changes were made due to the need to keep the test code in sync with the updated internals of Spring MVC. This suggests that the changes were made to address a problem in the software maintenance process, specifically the need to update outdated code to match the latest changes in the framework.",True,"The commit message directly mentions the change made to the code, which is aligning the test with Spring MVC's internals. It specifically mentions that the field 'interceptors' that was originally used can be used again, which implies that there was a previous issue with this field and the change is to fix it.",True,"The commit message 'Align test with Spring MVC's internals once again' does describe a summary of the changes made in the diff. The message highlights that the test code has been updated to use the 'interceptors' field, which was originally used but was no longer available due to updates in Spring MVC's internals. This contrasts the before and after state of the code, making it clear that a change has been made to align the test with the updated internals.",False,"The commit message does not explicitly state or describe the technical principle underpinning the changes. It only mentions that the test has been aligned with Spring MVC's internals and that a specific field, 'interceptors', can be used again. However, it does not explain why this change was necessary or what principle it is based on.",True,"The commit message 'Align test with Spring MVC's internals once again' does describe a summary of the changes. It explains that the test code has been updated to align with the changes in Spring MVC's internals. Specifically, it mentions that the 'interceptors' field, which was originally used, can be used again. This indicates that the code changes have introduced a new behavior where the 'interceptors' field is used in the test, which was not the case before.",False,"The commit message does not lack an explanation. It clearly states that the internals have been updated and the field 'interceptors' that was originally used can be used again. This is a significant change that requires an explanation, even though the code change is small and simple."
https://github.com/spring-projects/spring-boot/commit/c25736d84f92e6d9158927b63e690cb5f2bae65e,Add test for nested properties ,https://api.github.com/repos/spring-projects/spring-boot/commits/c25736d84f92e6d9158927b63e690cb5f2bae65e,"@@ -52,6 +52,16 @@ public void testBasicPropertiesBinding() {
 		assertEquals(""foo"", this.context.getBean(TestProperties.class).name);
 	}
 
+	@Test
+	public void testNestedPropertiesBinding() {
+		this.context.register(NestedConfiguration.class);
+		TestUtils.addEnviroment(this.context, ""name:foo"", ""nested.name:bar"");
+		this.context.refresh();
+		assertEquals(1, this.context.getBeanNamesForType(NestedProperties.class).length);
+		assertEquals(""foo"", this.context.getBean(NestedProperties.class).name);
+		assertEquals(""bar"", this.context.getBean(NestedProperties.class).nested.name);
+	}
+
 	@Test
 	public void testBasicPropertiesBindingWithAnnotationOnBaseClass() {
 		this.context.register(DerivedConfiguration.class);
@@ -190,6 +200,11 @@ protected static class TestConfiguration {
 	protected static class DerivedConfiguration {
 	}
 
+	@Configuration
+	@EnableConfigurationProperties(NestedProperties.class)
+	protected static class NestedConfiguration {
+	}
+
 	@Configuration
 	protected static class DefaultConfiguration {
 		@Bean
@@ -225,6 +240,29 @@ public String getName() {
 	protected static class MoreConfiguration {
 	}
 
+	@ConfigurationProperties
+	protected static class NestedProperties {
+		private String name;
+		private Nested nested = new Nested();
+
+		public void setName(String name) {
+			this.name = name;
+		}
+
+		public Nested getNested() {
+			return this.nested;
+		}
+
+		protected static class Nested {
+			private String name;
+
+			public void setName(String name) {
+				this.name = name;
+			}
+
+		}
+	}
+
 	@ConfigurationProperties
 	protected static class BaseProperties {
 		private String name;
",True,"The commit message 'Add test for nested properties' describes the necessity of changes by referencing the addition of a new feature: the test is being added to handle nested properties, which were not previously supported.",True,"The commit message 'Add test for nested properties' clearly and concisely describes the changes made in the code diff. It is easy to infer that the changes are necessary to add test coverage for the newly introduced nested properties feature. Therefore, the commit message does not require a rationale beyond what is already provided.",True,"The commit message 'Add test for nested properties' does describe the necessity of changes by elaborating the motivation of a code change. The code diff shows that a new test case has been added to handle nested properties, which is not previously supported. This change is likely made to address the shortcoming of the previous implementation, which did not support nested properties.",True,"The commit message 'Add test for nested properties' indicates that the developer added a new test to handle nested properties. This change was likely necessary due to the addition of nested properties in the code diff, which suggests a requirement for more complex property binding.",True,"The commit message 'Add test for nested properties' directly mentions the improvement it makes to the code, which is adding a test for nested properties. This is a clear indication that the change is intended to enhance the functionality of the codebase.",True,"The commit message 'Add test for nested properties' accurately summarizes the changes made in the diff. It points out the addition of a new test method (testNestedPropertiesBinding) that tests the binding of nested properties. Additionally, it mentions the creation of new classes (NestedConfiguration, NestedProperties, and Nested) which are also key components of the change.",True,"The commit message 'Add test for nested properties' describes the technical principle underpinning the changes, which is the ability to bind nested properties in a configuration. This is demonstrated in the code diff where a new test method 'testNestedPropertiesBinding' is added to test the binding of nested properties, and a new configuration class 'NestedProperties' is introduced to handle these nested properties.",True,"The commit message 'Add test for nested properties' accurately describes the changes made in the code diff. The changes include the addition of a new test method 'testNestedPropertiesBinding' and the creation of a new configuration class 'NestedConfiguration' and a new properties class 'NestedProperties'. These additions are to handle and test the binding of nested properties. The new test method tests the binding of both basic and nested properties, which is a new behavior introduced by the changes.",False,"The commit message 'Add test for nested properties' does not fully explain the reason for the commit. While it is clear that a new test has been added, the commit message does not explain why this test is necessary or what it is testing for. The code diff shows that a new configuration class and properties class have been added to handle nested properties, but the commit message does not mention this. Therefore, the commit message lacks an expression explaining the reason for the commit."
https://github.com/square/okhttp/commit/353ec0b0cdbf46ddbc2755e482c62ec711badf90,"Fix for SslContextBuilder/MockWebServer disagreeing about localhost  <enter> MockWebServer binds to getByName('localhost'), SslContextBuilder was using InetAddress.getByName(null) (null == any loopback). On Android, null returns IPv6 loopback, which has the name 'ip6-localhost'. ",https://api.github.com/repos/square/okhttp/commits/353ec0b0cdbf46ddbc2755e482c62ec711badf90,"@@ -68,7 +68,7 @@ public SslContextBuilder(String hostName) {
   public static synchronized SSLContext localhost() {
     if (localhost == null) {
       try {
-        localhost = new SslContextBuilder(InetAddress.getByName(null).getHostName()).build();
+        localhost = new SslContextBuilder(InetAddress.getByName(""localhost"").getHostName()).build();
       } catch (GeneralSecurityException e) {
         throw new RuntimeException(e);
       } catch (UnknownHostException e) {
",True,"The commit message explains the necessity of changes by referencing a problem that occurred when MockWebServer and SslContextBuilder were disagreeing about localhost. It mentions that MockWebServer was using 'localhost' directly, while SslContextBuilder was using InetAddress.getByName(null), which on Android returns IPv6 loopback. This discrepancy was causing an issue, and the change in the code diff (replacing null with 'localhost') is a solution to address this problem.",False,"The commit message does not contain an expression that describes the necessity of changes by not offering a rationale. It clearly explains the issue and the solution, which is changing the argument passed to InetAddress.getByName() from null to 'localhost'. This is not a common sense or easy to infer change, as the behavior of InetAddress.getByName(null) can vary depending on the environment, and it's not a standard practice to use 'localhost' instead of null.",True,"The commit message explains the problem scenario directly. It mentions that MockWebServer binds to 'localhost' while SslContextBuilder was using InetAddress.getByName(null), which on Android returns IPv6 loopback, named 'ip6-localhost'. This discrepancy was causing a conflict, and the commit message clearly explains this issue and the reason for the change.",True,"The commit message 'Fix for SslContextBuilder/MockWebServer disagreeing about localhost' indicates that there was a problem in the software maintenance process. The problem was that MockWebServer was binding to a different localhost address than SslContextBuilder. This discrepancy was causing issues, as the code was not behaving as expected. The change in the code diff (changing InetAddress.getByName(null) to InetAddress.getByName(",True,"The commit message directly mentions the issue it fixes, which is the disagreement between SslContextBuilder and MockWebServer about localhost. It explains that MockWebServer binds to 'localhost' while SslContextBuilder was using InetAddress.getByName(null), which on Android returns IPv6 loopback. The change made in the code diff (replacing null with ",True,The commit message accurately summarizes the change made in the code diff. It explains that the issue was with the SslContextBuilder and MockWebServer disagreeing about localhost due to different methods used to get the localhost address. The message then contrasts the before and after by specifying that SslContextBuilder was using InetAddress.getByName(null) and MockWebServer was using InetAddress.getByName('localhost'). The fix is also clearly described as changing null to 'localhost' in the SslContextBuilder method.,True,"The commit message explains that the change was made to ensure consistency between MockWebServer and SslContextBuilder when dealing with localhost. Specifically, it mentions that MockWebServer was using InetAddress.getByName('localhost'), while SslContextBuilder was using InetAddress.getByName(null). This highlights the technical principle that the same method should be used to retrieve the localhost address consistently, as using null can return the IPv6 loopback address on Android, which can cause inconsistencies.",True,"The commit message accurately describes the code change and its functional impact. It explains that the SslContextBuilder was previously using InetAddress.getByName(null), which on Android returned IPv6 loopback, causing a disagreement with MockWebServer. The commit message then states that the issue was fixed by changing null to 'localhost', which ensures that both SslContextBuilder and MockWebServer use the same loopback address.",False,"The commit message does not lack an explanation. It clearly explains the reason for the commit, which is to fix an issue where MockWebServer and SslContextBuilder were disagreeing about localhost due to different methods of getting the localhost address. The change from using InetAddress.getByName(null) to InetAddress.getByName('localhost') is necessary to ensure consistency and correctness in the code."
https://github.com/apache/dubbo/commit/5a9ea9373084613b6da4bf34861b1b8a013274b5,Polish release notes in CHANGES.md ,https://api.github.com/repos/apache/dubbo/commits/5a9ea9373084613b6da4bf34861b1b8a013274b5,"@@ -1,3 +1,7 @@
+# Release Notes
+
+## 2.6.2
+
 1. Hessian-lite serialization: revert locale serialization for compatibility, #1413
 2. Asset transfer to ASF, includeing pom, license, DISCLAIMER and so on, #1491
 3. Introduce of new dispatcher policy: EagerThreadpool, #1568
@@ -6,4 +10,6 @@
 6. Gaceful shutdown enhancement
    - Remove exporter destroy logic in AnnotationBean.
    - Waiting for registry notification on consumer side by checking channel state.
-7. Simplify consumer/provider side check in RpcContext, #1444.
\ No newline at end of file
+7. Simplify consumer/provider side check in RpcContext, #1444.
+
+Issues and Pull Requests, check [milestone-2.6.2](https://github.com/apache/incubator-dubbo/milestone/15).
\ No newline at end of file
",True,"The commit message refers to the release notes being updated in CHANGES.md, which is a common practice in software development to document changes made in each release. The message also mentions specific issues and pull requests that were addressed in this release, such as #1413, #1491, #1568, and #1444. This references improvements in prior commits, demonstrating the necessity of the changes made in this commit.",True,"The commit message 'Polish release notes in CHANGES.md' does not explicitly describe the necessity of changes, but it is easy to infer that the changes are being made to improve the clarity and presentation of the release notes. This is a common practice in software development and does not require a detailed rationale.",True,"The commit message mentions the issue reports (#1413, #1491, #1568, #1444) associated with the changes made in the code diff. This provides a clear explanation of the motivation behind the changes, as these issue reports likely detail the error scenarios or shortcomings of the previous implementation that the changes are addressing.",True,"The commit message mentions the changes made to the release notes in CHANGES.md. The code diff indicates several changes, including reverting locale serialization for compatibility (#1413), which might have been necessary due to a change in an API or a problem with outdated code. Additionally, the message includes a link to a milestone on GitHub, which suggests that the changes were made to address specific issues or pull requests, indicating a need for software development to meet requirements or fix problems.",True,"The commit message mentions the changes made to the code, such as fixing issues #1413, #1491, #1568, and #1444. These issues are directly mentioned in the commit message, which indicates that the changes are made to address specific defects or improvements in the code.",True,"The commit message 'Polish release notes in CHANGES.md' does describe a summary of what changes by listing the key components of the change, which are the updates to the release notes for version 2.6.2. This includes the addition of new features such as the Hessian-lite serialization, Asset transfer to ASF, and the introduction of a new dispatcher policy. It also mentions the resolution of issues and pull requests, which is a key part of the change.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly focuses on documenting the release notes and listing the changes made in the release. The changes listed, such as revert locale serialization, asset transfer, and introducing a new dispatcher policy, do not directly relate to a specific technical principle.",True,"The commit message does not directly describe the code changes from a functional perspective, but it does mention several changes such as reverting locale serialization, introducing a new dispatcher policy, and simplifying consumer/provider side checks. These changes could be interpreted to introduce new behaviors such as improved serialization compatibility, a new way to manage threads, and simplified checks for consumers and providers. However, the message does not explicitly describe these new behaviors, so it does not fully meet the criteria.",False,"The commit message does not lack an explanation. While the changes made are relatively small and simple, the commit message provides a clear explanation of the purpose of the changes. It mentions polishing release notes, which could involve a variety of tasks such as adding new features, fixing bugs, or improving clarity. The specific changes listed in the diff, such as reverting a change for compatibility, transferring assets to ASF, and introducing a new dispatcher policy, are also mentioned in the commit message. Additionally, the message includes a link to the milestone on GitHub, which provides more context about the changes made."
https://github.com/apache/dubbo/commit/c21cc05ec9ff4f96f34af9027714bb525cd0edf5,replace ServiceAnnotationBeanPostProcessor log.isInfoEnabled->log.isWarnEnabled ( <pr_link> ) <enter> simplify ExtensionLoader code segment ,https://api.github.com/repos/apache/dubbo/commits/c21cc05ec9ff4f96f34af9027714bb525cd0edf5,"@@ -860,19 +860,8 @@ private String createAdaptiveExtensionClassCode() {
                 String[] value = adaptiveAnnotation.value();
                 // value is not set, use the value generated from class name as the key
                 if (value.length == 0) {
-                    char[] charArray = type.getSimpleName().toCharArray();
-                    StringBuilder sb = new StringBuilder(128);
-                    for (int i = 0; i < charArray.length; i++) {
-                        if (Character.isUpperCase(charArray[i])) {
-                            if (i != 0) {
-                                sb.append(""."");
-                            }
-                            sb.append(Character.toLowerCase(charArray[i]));
-                        } else {
-                            sb.append(charArray[i]);
-                        }
-                    }
-                    value = new String[]{sb.toString()};
+                    String splitName = StringUtils.camelToSplitName(type.getSimpleName(), ""."");
+                    value = new String[]{splitName};
                 }
 
                 boolean hasInvocation = false;
@@ -261,7 +261,7 @@ private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, Bean
         if (scanner.checkCandidate(beanName, serviceBeanDefinition)) { // check duplicated candidate bean
             registry.registerBeanDefinition(beanName, serviceBeanDefinition);
 
-            if (logger.isInfoEnabled()) {
+            if (logger.isWarnEnabled()) {
                 logger.warn(""The BeanDefinition["" + serviceBeanDefinition +
                         ""] of ServiceBean has been registered with name : "" + beanName);
             }
",True,"The commit message refers to a change in the logging level from 'info' to 'warn'. This could be done to improve the visibility of important messages or to reduce log verbosity, which could be considered an improvement based on prior commits or conventions.",True,"The commit message refers to a common practice in logging, where it is common to use a more severe log level (like WARN) for important messages. This change does not require a detailed explanation as it is a standard practice to improve logging.",True,"The commit message mentions the change from 'log.isInfoEnabled' to 'log.isWarnEnabled' in the context of registering a service bean. This change is likely made to increase the logging level from INFO to WARN, which could be done to reduce verbosity in the logs or to highlight potential issues that were previously overlooked.",True,"The commit message mentions 'replace ServiceAnnotationBeanPostProcessor log.isInfoEnabled->log.isWarnEnabled' which indicates a change in the logging level from INFO to WARN. This could be done to address a problem where too much information was being logged, causing performance issues or making it difficult to find important logs. Additionally, the message 'simplify ExtensionLoader code segment' suggests that the code might have been complex or outdated, and the changes made in the commit aim to improve it.",True,"The commit message directly mentions the change will simplify the ExtensionLoader code segment and also mentions the specific change of replacing log.isInfoEnabled with log.isWarnEnabled, which is an improvement to the code as it changes the logging level from INFO to WARN.",True,"The commit message accurately summarizes the changes made in the diff. It mentions the replacement of 'log.isInfoEnabled' with 'log.isWarnEnabled' and the simplification of the 'ExtensionLoader' code segment. The diff provided also supports this summary, showing the exact changes made.",False,"The commit message does not explicitly state the technical principle underpinning the changes. It mentions simplifying the ExtensionLoader code segment and changing a log level, but it does not explain why these changes were made or what principle they are based on.",True,The commit message expresses a change in the logging level from INFO to WARN and describes the new behavior as the log message will now be displayed as a WARN level message instead of INFO.,False,"The commit message changed the logging level from 'info' to 'warn'. This change could potentially hide important information, so an explanation in the commit message is necessary to clarify the reason for this change."
https://github.com/square/okhttp/commit/60f5406dcc094d0431420139bd002e8bdd4ea5d5,"Move TLS retries / fallback into Connection.  <enter> API changes: 1) Added: Address.getCertificatePinner() 2) Incompatible API change: Address constructor no longer includes ConnectionSpecs. Removed getConnectionSpecs(). 3) Added: ConnectionSpec.isCompatible(SSLSocket) 4) Added: TlsVersion.javaName() <enter> Implicit / semantic / internal changes: <enter> 1) Connection now handles all attempts to connect via a route (effectively a {proxy, socket address} pair), rather than just one attempt. i.e. Connection now handles all the TLS negotiation fallbacks internally. <enter> 2) Route no longer deals with TLS versions. Individual TLS failures are not counted against a Route. If no connection attempts to a route were successful the failure is counted against the route. <enter> 3) The code makes a distinction between when various IOExceptions occur, with the intention making retries a bit smarter. It is now more obvious which exceptions happen during setup (RequestException), connection (RouteException), HTTP communication and thus which can be retried and whether the request might have been sent. ",https://api.github.com/repos/square/okhttp/commits/60f5406dcc094d0431420139bd002e8bdd4ea5d5,"@@ -38,7 +38,6 @@
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
@@ -681,6 +680,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  // https://github.com/square/okhttp/issues/442
   @Test public void timeoutsNotRetried() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
@@ -851,7 +851,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(request).execute();
       fail();
     } catch (UnknownServiceException expected) {
-      assertTrue(expected.getMessage().contains(""no connection specs""));
+      assertTrue(expected.getMessage().contains(""CLEARTEXT communication not supported""));
     }
   }
 
@@ -1699,21 +1699,6 @@ private Buffer gzip(String data) throws IOException {
     return result;
   }
 
-  private void assertContains(Collection<String> collection, String element) {
-    for (String c : collection) {
-      if (c != null && c.equalsIgnoreCase(element)) return;
-    }
-    fail(""No "" + element + "" in "" + collection);
-  }
-
-  private void assertContainsNoneMatching(List<String> headers, String pattern) {
-    for (String header : headers) {
-      if (header.matches(pattern)) {
-        fail(""Header "" + header + "" matches "" + pattern);
-      }
-    }
-  }
-
   private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
 
     private List<SSLSocket> socketsCreated = new ArrayList<SSLSocket>();
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
@@ -43,6 +44,13 @@
 import static org.junit.Assert.fail;
 
 public final class ConnectionPoolTest {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  private static final List<ConnectionSpec> CONNECTION_SPECS = Util.immutableList(
+      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
+
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
   private static final SSLContext sslContext = SslContextBuilder.localhost();
 
@@ -77,44 +85,39 @@ private void setUp(int poolSize) throws Exception {
     httpServer = new MockWebServer();
     spdyServer.useHttps(sslContext.getSocketFactory(), false);
 
-    List<ConnectionSpec> connectionSpecs = Util.immutableList(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
     httpServer.start();
     httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
         null, null, AuthenticatorAdapter.INSTANCE, null,
-        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), connectionSpecs, proxySelector);
+        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), CONNECTION_SPECS, proxySelector);
     httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
         httpServer.getPort());
 
     spdyServer.start();
     spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
         sslContext.getSocketFactory(), new RecordingHostnameVerifier(), CertificatePinner.DEFAULT,
         AuthenticatorAdapter.INSTANCE, null, Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1),
-        connectionSpecs, proxySelector);
+        CONNECTION_SPECS, proxySelector);
     spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
         spdyServer.getPort());
 
-    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
-        ConnectionSpec.CLEARTEXT);
-    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress,
-        ConnectionSpec.MODERN_TLS);
+    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress);
+    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress);
     pool = new ConnectionPool(poolSize, KEEP_ALIVE_DURATION_MS);
     // Disable the automatic execution of the cleanup.
     cleanupExecutor = new FakeExecutor();
     pool.replaceCleanupExecutorForTests(cleanupExecutor);
     httpA = new Connection(pool, httpRoute);
-    httpA.connect(200, 200, 200, null);
+    httpA.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpB = new Connection(pool, httpRoute);
-    httpB.connect(200, 200, 200, null);
+    httpB.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpC = new Connection(pool, httpRoute);
-    httpC.connect(200, 200, 200, null);
+    httpC.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpD = new Connection(pool, httpRoute);
-    httpD.connect(200, 200, 200, null);
+    httpD.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpE = new Connection(pool, httpRoute);
-    httpE.connect(200, 200, 200, null);
+    httpE.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     spdyA = new Connection(pool, spdyRoute);
-    spdyA.connect(20000, 20000, 2000, null);
+    spdyA.connect(20000, 20000, 2000, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
 
     owner = new Object();
     httpA.setOwner(owner);
@@ -146,9 +149,8 @@ private void resetWithPoolSize(int poolSize) throws Exception {
     Connection connection = pool.get(httpAddress);
     assertNull(connection);
 
-    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
-        ConnectionSpec.CLEARTEXT));
-    connection.connect(200, 200, 200, null);
+    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress));
+    connection.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     connection.setOwner(owner);
     assertEquals(0, pool.getConnectionCount());
 
@@ -15,13 +15,8 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-
 import org.junit.Test;
 
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
 import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
@@ -35,14 +30,6 @@
 
 public final class ConnectionSpecTest {
 
-  private static final Proxy PROXY = Proxy.NO_PROXY;
-  private static final InetSocketAddress INET_SOCKET_ADDRESS =
-      InetSocketAddress.createUnresolved(""host"", 443);
-  private static final Address HTTPS_ADDRESS = new Address(
-      INET_SOCKET_ADDRESS.getHostString(), INET_SOCKET_ADDRESS.getPort(), null, null, null, null,
-      AuthenticatorAdapter.INSTANCE, PROXY, Arrays.asList(Protocol.HTTP_1_1),
-      Arrays.asList(ConnectionSpec.MODERN_TLS), ProxySelector.getDefault());
-
   @Test
   public void cleartextBuilder() throws Exception {
     ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
@@ -89,9 +76,8 @@ public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        false /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, false /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -119,9 +105,8 @@ public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        true /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -153,9 +138,8 @@ public void tls_explicitCiphers() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        true /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -176,6 +160,52 @@ public void tls_stringCiphersAndVersions() throws Exception {
         .build();
   }
 
+  public void tls_missingRequiredCipher() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
+  @Test
+  public void tls_missingTlsVersion() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+
+    socket.setEnabledProtocols(
+        new String[] { TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName });
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledProtocols(new String[] { TlsVersion.TLS_1_1.javaName });
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
   private static Set<String> createSet(String... values) {
     return new LinkedHashSet<String>(Arrays.asList(values));
   }
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.TlsVersion;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ConnectionSpecSelectorTest {
+
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
+      ""Simulated handshake exception"");
+
+  @Test
+  public void nonRetryableIOException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(
+        new IOException(""Non-handshake exception""));
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void nonRetryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    SSLHandshakeException trustIssueException =
+        new SSLHandshakeException(""Certificate handshake exception"");
+    trustIssueException.initCause(new CertificateException());
+    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void retryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+  }
+
+  @Test
+  public void someFallbacksSupported() throws Exception {
+    ConnectionSpec sslV3 =
+        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+            .tlsVersions(TlsVersion.SSL_3_0)
+            .build();
+
+    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
+
+    TlsVersion[] enabledSocketTlsVersions = { TlsVersion.TLS_1_1, TlsVersion.TLS_1_0 };
+    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+
+    // MODERN_TLS is used here.
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+
+    // COMPATIBLE_TLS is used here.
+    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+
+    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertFalse(retry);
+    socket.close();
+
+    // sslV3 is not used because SSLv3 is not enabled on the socket.
+  }
+
+  private static ConnectionSpecSelector createConnectionSpecSelector(
+      ConnectionSpec... connectionSpecs) {
+    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
+  }
+
+  private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
+    SSLSocket socket = (SSLSocket) sslContext.getSocketFactory().createSocket();
+    socket.setEnabledProtocols(javaNames(tlsVersions));
+    return socket;
+  }
+
+  private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
+    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
+    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
+    assertEquals(expected, actual);
+  }
+
+  private static String[] javaNames(TlsVersion... tlsVersions) {
+    String[] protocols = new String[tlsVersions.length];
+    for (int i = 0; i < tlsVersions.length; i++) {
+      protocols[i] = tlsVersions[i].javaName();
+    }
+    return protocols;
+  }
+}
@@ -28,7 +28,6 @@
 import com.squareup.okhttp.internal.RouteDatabase;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
@@ -41,7 +40,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
 import org.junit.Before;
 import org.junit.Test;
@@ -114,8 +112,7 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -135,8 +132,7 @@ public final class RouteSelectorTest {
     Route route = routeSelector.next();
     routeDatabase.failed(route);
     routeSelector = RouteSelector.get(address, httpRequest, client);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     assertFalse(routeSelector.hasNext());
     try {
       routeSelector.next();
@@ -153,10 +149,8 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
@@ -171,10 +165,8 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -190,8 +182,7 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -203,10 +194,8 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -224,25 +213,20 @@ public final class RouteSelectorTest {
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0], proxyBPort);
     dns.assertRequests(proxyBHost);
 
     // Finally try the only IP address of the origin server.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -258,8 +242,7 @@ public final class RouteSelectorTest {
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -276,8 +259,7 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
@@ -291,44 +273,17 @@ public final class RouteSelectorTest {
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
   }
 
-  // https://github.com/square/okhttp/issues/442
-  @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeSelector.connectFailed(route, new IOException(""Non SSL exception""));
-    assertEquals(2, routeDatabase.failedRoutesCount());
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void sslErrorAddsOnlyFailedConfigurationToFailedRoute() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeSelector.connectFailed(route, new SSLHandshakeException(""SSL exception""));
-    assertTrue(routeDatabase.failedRoutesCount() == 1);
-    assertTrue(routeSelector.hasNext());
-  }
-
   @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
@@ -337,39 +292,21 @@ public final class RouteSelectorTest {
 
     // Proxy A
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
 
     // Proxy B
     dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0], proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
-        proxyBPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
-        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1], proxyBPort);
 
     // Origin
     dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
   }
@@ -379,7 +316,8 @@ public final class RouteSelectorTest {
     client.setProxy(Proxy.NO_PROXY);
     RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
 
-    dns.inetAddresses = makeFakeAddresses(255, 1);
+    final int numberOfAddresses = 2;
+    dns.inetAddresses = makeFakeAddresses(255, numberOfAddresses);
 
     // Extract the regular sequence of routes from selector.
     List<Route> regularRoutes = new ArrayList<>();
@@ -388,7 +326,7 @@ public final class RouteSelectorTest {
     }
 
     // Check that we do indeed have more than one route.
-    assertTrue(regularRoutes.size() > 1);
+    assertEquals(numberOfAddresses, regularRoutes.size());
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
@@ -422,13 +360,12 @@ public final class RouteSelectorTest {
     assertEquals(""127.0.0.1"", RouteSelector.getHostString(socketAddress));
   }
 
-  private void assertRoute(Route route, Address address, Proxy proxy,
-      InetAddress socketAddress, int socketPort, ConnectionSpec connectionSpec) {
+  private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
+      int socketPort) {
     assertEquals(address, route.getAddress());
     assertEquals(proxy, route.getProxy());
     assertEquals(socketAddress, route.getSocketAddress().getAddress());
     assertEquals(socketPort, route.getSocketAddress().getPort());
-    assertEquals(connectionSpec, route.getConnectionSpec());
   }
 
   /** Returns an address that's without an SSL socket factory or hostname verifier. */
@@ -613,6 +613,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     RecordedRequest request = server.takeRequest();
     assertEquals(""GET /foo HTTP/1.1"", request.getRequestLine());
+    assertEquals(TlsVersion.TLS_1_0, request.getTlsVersion());
   }
 
   /**
@@ -27,11 +27,13 @@
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RequestException;
 import com.squareup.okhttp.internal.http.RetryableSink;
 import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.FileNotFoundException;
@@ -432,7 +434,25 @@ private boolean execute(boolean readResponse) throws IOException {
       }
 
       return true;
+    } catch (RequestException e) {
+      // An attempt to interpret a request failed.
+      IOException toThrow = e.getCause();
+      httpEngineFailure = toThrow;
+      throw toThrow;
+    } catch (RouteException e) {
+      // The attempt to connect via a route failed. The request will not have been sent.
+      HttpEngine retryEngine = httpEngine.recover(e);
+      if (retryEngine != null) {
+        httpEngine = retryEngine;
+        return false;
+      }
+
+      // Give up; recovery is not possible.
+      IOException toThrow = e.getLastConnectException();
+      httpEngineFailure = toThrow;
+      throw toThrow;
     } catch (IOException e) {
+      // An attempt to communicate with a server failed. The request may have been sent.
       HttpEngine retryEngine = httpEngine.recover(e);
       if (retryEngine != null) {
         httpEngine = retryEngine;
@@ -139,6 +139,13 @@ public ProxySelector getProxySelector() {
     return proxySelector;
   }
 
+  /**
+   * Returns this address's certificate pinner. Only used for secure connections.
+   */
+  public CertificatePinner getCertificatePinner() {
+    return certificatePinner;
+  }
+
   @Override public boolean equals(Object other) {
     if (other instanceof Address) {
       Address that = (Address) other;
@@ -16,7 +16,9 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RequestException;
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.ProtocolException;
@@ -270,7 +272,20 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
       try {
         engine.sendRequest();
         engine.readResponse();
+      } catch (RequestException e) {
+        // The attempt to interpret the request failed. Give up.
+        throw e.getCause();
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        HttpEngine retryEngine = engine.recover(e);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
+        // Give up; recovery is not possible.
+        throw e.getLastConnectException();
       } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
         HttpEngine retryEngine = engine.recover(e, null);
         if (retryEngine != null) {
           engine = retryEngine;
@@ -16,30 +16,18 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
-import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RouteException;
+import com.squareup.okhttp.internal.http.SocketConnector;
 import com.squareup.okhttp.internal.http.SpdyTransport;
 import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
-import java.net.Proxy;
 import java.net.Socket;
-import java.net.URL;
-import java.security.cert.X509Certificate;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-import okio.Source;
-
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import java.net.UnknownServiceException;
+import java.util.List;
 
 /**
  * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be
@@ -142,23 +130,42 @@ void closeIfOwnedBy(Object owner) throws IOException {
     socket.close();
   }
 
-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)
-      throws IOException {
+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,
+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
     if (connected) throw new IllegalStateException(""already connected"");
 
-    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {
-      socket = route.address.socketFactory.createSocket();
+    SocketConnector socketConnector = new SocketConnector(this, pool);
+    SocketConnector.ConnectedSocket connectedSocket;
+    if (route.address.getSslSocketFactory() != null) {
+      // https:// communication
+      connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,
+          request, route, connectionSpecs, connectionRetryEnabled);
     } else {
-      socket = new Socket(route.proxy);
+      // http:// communication.
+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+        throw new RouteException(
+            new UnknownServiceException(
+                ""CLEARTEXT communication not supported: "" + connectionSpecs));
+      }
+      connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);
     }
 
-    socket.setSoTimeout(readTimeout);
-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
+    socket = connectedSocket.socket;
+    handshake = connectedSocket.handshake;
+    protocol = connectedSocket.alpnProtocol == null
+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;
 
-    if (route.address.sslSocketFactory != null) {
-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
+    try {
+      if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.
+        spdyConnection = new SpdyConnection.Builder(route.address.uriHost, true, socket)
+            .protocol(protocol).build();
+        spdyConnection.sendConnectionPreface();
+      } else {
+        httpConnection = new HttpConnection(pool, this, socket);
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
     }
     connected = true;
   }
@@ -167,13 +174,14 @@ void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunn
    * Connects this connection if it isn't already. This creates tunnels, shares
    * the connection with the connection pool, and configures timeouts.
    */
-  void connectAndSetOwner(OkHttpClient client, Object owner, Request request) throws IOException {
+  void connectAndSetOwner(OkHttpClient client, Object owner, Request request)
+      throws RouteException {
     setOwner(owner);
 
     if (!isConnected()) {
-      Request tunnelRequest = tunnelRequest(request);
-      connect(client.getConnectTimeout(), client.getReadTimeout(),
-          client.getWriteTimeout(), tunnelRequest);
+      List<ConnectionSpec> connectionSpecs = route.address.getConnectionSpecs();
+      connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
+          request, connectionSpecs, client.getRetryOnConnectionFailure());
       if (isSpdy()) {
         client.getConnectionPool().share(this);
       }
@@ -183,97 +191,6 @@ void connectAndSetOwner(OkHttpClient client, Object owner, Request request) thro
     setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
   }
 
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
-   * no tunnel is necessary. Everything in the tunnel request is sent
-   * unencrypted to the proxy server, so tunnels include only the minimum set of
-   * headers. This avoids sending potentially sensitive data like HTTP cookies
-   * to the proxy unencrypted.
-   */
-  private Request tunnelRequest(Request request) throws IOException {
-    if (!route.requiresTunnel()) return null;
-
-    String host = request.url().getHost();
-    int port = getEffectivePort(request.url());
-    String authority = (port == getDefaultPort(""https"")) ? host : (host + "":"" + port);
-    Request.Builder result = new Request.Builder()
-        .url(new URL(""https"", host, port, ""/""))
-        .header(""Host"", authority)
-        .header(""Proxy-Connection"", ""Keep-Alive""); // For HTTP/1.0 proxies like Squid.
-
-    // Copy over the User-Agent header if it exists.
-    String userAgent = request.header(""User-Agent"");
-    if (userAgent != null) {
-      result.header(""User-Agent"", userAgent);
-    }
-
-    // Copy over the Proxy-Authorization header if it exists.
-    String proxyAuthorization = request.header(""Proxy-Authorization"");
-    if (proxyAuthorization != null) {
-      result.header(""Proxy-Authorization"", proxyAuthorization);
-    }
-
-    return result.build();
-  }
-
-  /**
-   * Create an {@code SSLSocket} and perform the TLS handshake and certificate
-   * validation.
-   */
-  private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeout)
-      throws IOException {
-    Platform platform = Platform.get();
-
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    if (tunnelRequest != null) {
-      makeTunnel(tunnelRequest, readTimeout, writeTimeout);
-    }
-
-    // Create the wrapper over connected socket.
-    socket = route.address.sslSocketFactory
-        .createSocket(socket, route.address.uriHost, route.address.uriPort, true /* autoClose */);
-    SSLSocket sslSocket = (SSLSocket) socket;
-
-    // Configure the socket's ciphers, TLS versions, and extensions.
-    route.connectionSpec.apply(sslSocket, route);
-
-    try {
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
-
-      String maybeProtocol;
-      if (route.connectionSpec.supportsTlsExtensions()
-          && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
-        protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
-      }
-    } finally {
-      platform.afterHandshake(sslSocket);
-    }
-
-    handshake = Handshake.get(sslSocket.getSession());
-
-    // Verify that the socket's certificates are acceptable for the target host.
-    if (!route.address.hostnameVerifier.verify(route.address.uriHost, sslSocket.getSession())) {
-      X509Certificate cert = (X509Certificate) sslSocket.getSession().getPeerCertificates()[0];
-      throw new SSLPeerUnverifiedException(""Hostname "" + route.address.uriHost + "" not verified:""
-          + ""\n    certificate: "" + CertificatePinner.pin(cert)
-          + ""\n    DN: "" + cert.getSubjectDN().getName()
-          + ""\n    subjectAltNames: "" + OkHostnameVerifier.allSubjectAltNames(cert));
-    }
-
-    // Check that the certificate pinner is satisfied by the certificates presented.
-    route.address.certificatePinner.check(route.address.uriHost, handshake.peerCertificates());
-
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
-      sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
-          .protocol(protocol).build();
-      spdyConnection.sendConnectionPreface();
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
-    }
-  }
-
   /** Returns true if {@link #connect} has been attempted on this connection. */
   boolean isConnected() {
     return connected;
@@ -361,12 +278,17 @@ void setProtocol(Protocol protocol) {
     this.protocol = protocol;
   }
 
-  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) throws IOException {
+  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis)
+      throws RouteException {
     if (!connected) throw new IllegalStateException(""setTimeouts - not connected"");
 
     // Don't set timeouts on shared SPDY connections.
     if (httpConnection != null) {
-      socket.setSoTimeout(readTimeoutMillis);
+      try {
+        socket.setSoTimeout(readTimeoutMillis);
+      } catch (IOException e) {
+        throw new RouteException(e);
+      }
       httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
     }
   }
@@ -383,55 +305,6 @@ int recycleCount() {
     return recycleCount;
   }
 
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-   * CONNECT request to create the proxy connection. This may need to be
-   * retried if the proxy requires authorization.
-   */
-  private void makeTunnel(Request request, int readTimeout, int writeTimeout)
-      throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
-    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
-    URL url = request.url();
-    String requestLine = ""CONNECT "" + url.getHost() + "":"" + url.getPort() + "" HTTP/1.1"";
-    while (true) {
-      tunnelConnection.writeRequest(request.headers(), requestLine);
-      tunnelConnection.flush();
-      Response response = tunnelConnection.readResponse().request(request).build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = OkHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
-          // happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just that
-          // it will almost certainly fail because the proxy has sent unexpected data.
-          if (tunnelConnection.bufferSize() > 0) {
-            throw new IOException(""TLS tunnel buffered too many bytes!"");
-          }
-          return;
-
-        case HTTP_PROXY_AUTH:
-          request = OkHeaders.processAuthHeader(
-              route.address.authenticator, response, route.proxy);
-          if (request != null) continue;
-          throw new IOException(""Failed to authenticate with proxy"");
-
-        default:
-          throw new IOException(
-              ""Unexpected response code for CONNECT: "" + response.code());
-      }
-    }
-  }
-
   @Override public String toString() {
     return ""Connection{""
         + route.address.uriHost + "":"" + route.address.uriPort
@@ -15,44 +15,45 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.util.Arrays;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 
 /**
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
- * https:} URLs, this includes the TLS version and ciphers to use when negotiating a secure
+ * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
  * connection.
  */
 public final class ConnectionSpec {
 
+  // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+  // All of these suites are available on Android 5.0; earlier releases support a subset of
+  // these suites. https://github.com/square/okhttp/issues/330
+  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+
+      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+      // continue to include them until better suites are commonly available. For example, none
+      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+  };
+
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(
-          // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
-          // All of these suites are available on Android 5.0; earlier releases support a subset of
-          // these suites. https://github.com/square/okhttp/issues/330
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
-
-          // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
-          // continue to include them until better suites are commonly available. For example, none
-          // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA
-      )
+      .cipherSuites(APPROVED_CIPHER_SUITES)
       .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
@@ -91,8 +92,8 @@ public boolean isTls() {
   }
 
   /**
-   * Return the cipher suites to use with the connection. This method can return {@code null} if the
-   * ciphers enabled by default should be used.
+   * Returns the cipher suites to use for a connection. This method can return {@code null} if the
+   * cipher suites enabled by default should be used.
    */
   public List<CipherSuite> cipherSuites() {
     if (cipherSuites == null) {
@@ -117,22 +118,40 @@ public boolean supportsTlsExtensions() {
     return supportsTlsExtensions;
   }
 
-  /** Applies this spec to {@code sslSocket} for {@code route}. */
-  void apply(SSLSocket sslSocket, Route route) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket);
+  /** Applies this spec to {@code sslSocket}. */
+  void apply(SSLSocket sslSocket, boolean isFallback) {
+    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
 
     sslSocket.setEnabledProtocols(specToApply.tlsVersions);
 
     String[] cipherSuitesToEnable = specToApply.cipherSuites;
-    if (route.shouldSendTlsFallbackIndicator) {
+    // null means ""use default set"".
+    if (cipherSuitesToEnable != null) {
+      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+    }
+  }
+
+  /**
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by
+   * {@code sslSocket}.
+   */
+  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+    String[] cipherSuitesToEnable = null;
+    if (cipherSuites != null) {
+      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
+      cipherSuitesToEnable =
+          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+    }
+
+    if (isFallback) {
       // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
       // the SCSV cipher is added to signal that a protocol fallback has taken place.
       final String fallbackScsv = ""TLS_FALLBACK_SCSV"";
       boolean socketSupportsFallbackScsv =
           Arrays.asList(sslSocket.getSupportedCipherSuites()).contains(fallbackScsv);
 
       if (socketSupportsFallbackScsv) {
-        // Add the SCSV cipher to the set of enabled ciphers iff it is supported.
+        // Add the SCSV cipher to the set of enabled cipher suites iff it is supported.
         String[] oldEnabledCipherSuites = cipherSuitesToEnable != null
             ? cipherSuitesToEnable
             : sslSocket.getEnabledCipherSuites();
@@ -143,35 +162,71 @@ void apply(SSLSocket sslSocket, Route route) {
         cipherSuitesToEnable = newEnabledCipherSuites;
       }
     }
-    // null means ""use default set"".
-    if (cipherSuitesToEnable != null) {
-      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+
+    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
+    String[] protocolsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
+    return new Builder(this)
+        .cipherSuites(cipherSuitesToEnable)
+        .tlsVersions(protocolsToEnable)
+        .build();
+  }
+
+  /**
+   * Returns {@code true} if the socket, as currently configured, supports this ConnectionSpec.
+   * In order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   *
+   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+   * must have at least one cipher suite enabled.
+   *
+   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+   * socket's enabled protocols.
+   */
+  public boolean isCompatible(SSLSocket socket) {
+    if (!tls) {
+      return false;
+    }
+
+    String[] enabledProtocols = socket.getEnabledProtocols();
+    boolean requiredProtocolsEnabled = nonEmptyIntersection(tlsVersions, enabledProtocols);
+    if (!requiredProtocolsEnabled) {
+      return false;
     }
 
-    Platform platform = Platform.get();
-    if (specToApply.supportsTlsExtensions) {
-      platform.configureTlsExtensions(sslSocket, route.address.uriHost, route.address.protocols);
+    boolean requiredCiphersEnabled;
+    if (cipherSuites == null) {
+      requiredCiphersEnabled = socket.getEnabledCipherSuites().length > 0;
+    } else {
+      String[] enabledCipherSuites = socket.getEnabledCipherSuites();
+      requiredCiphersEnabled = nonEmptyIntersection(cipherSuites, enabledCipherSuites);
     }
+    return requiredCiphersEnabled;
   }
 
   /**
-   * Returns a copy of this that omits cipher suites and TLS versions not
-   * enabled by {@code sslSocket}.
+   * An N*M intersection that terminates if any intersection is found. The sizes of both
+   * arguments are assumed to be so small, and the likelihood of an intersection so great, that it
+   * is not worth the CPU cost of sorting or the memory cost of hashing.
    */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
-    String[] cipherSuitesToEnable = null;
-    if (cipherSuites != null) {
-      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
-      cipherSuitesToEnable =
-          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+  private static boolean nonEmptyIntersection(String[] a, String[] b) {
+    if (a == null || b == null || a.length == 0 || b.length == 0) {
+      return false;
+    }
+    for (String toFind : a) {
+      if (contains(b, toFind)) {
+        return true;
+      }
     }
+    return false;
+  }
 
-    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
-    String[] tlsVersionsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
-    return new Builder(this)
-        .cipherSuites(cipherSuitesToEnable)
-        .tlsVersions(tlsVersionsToEnable)
-        .build();
+  private static <T> boolean contains(T[] array, T value) {
+    for (T arrayValue : array) {
+      if (Util.equal(value, arrayValue)) {
+        return true;
+      }
+    }
+    return false;
   }
 
   @Override public boolean equals(Object other) {
@@ -257,6 +312,9 @@ public Builder cipherSuites(String... cipherSuites) {
 
     public Builder tlsVersions(TlsVersion... tlsVersions) {
       if (!tls) throw new IllegalStateException(""no TLS versions for cleartext connections"");
+      if (tlsVersions.length == 0) {
+        throw new IllegalArgumentException(""At least one TlsVersion is required"");
+      }
 
       // Convert enums to the string names Java wants. This makes a defensive copy!
       String[] strings = new String[tlsVersions.length];
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
@@ -36,6 +37,7 @@
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
 /**
@@ -116,7 +118,7 @@ public class OkHttpClient implements Cloneable {
       }
 
       @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
-          HttpEngine owner, Request request) throws IOException {
+          HttpEngine owner, Request request) throws RouteException {
         connection.connectAndSetOwner(client, owner, request);
       }
 
@@ -136,6 +138,11 @@ public void callEnqueue(Call call, Callback responseCallback, boolean forWebSock
       @Override public void connectionSetOwner(Connection connection, Object owner) {
         connection.setOwner(owner);
       }
+
+      @Override
+      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+        tlsConfiguration.apply(sslSocket, isFallback);
+      }
     };
   }
 
@@ -28,26 +28,15 @@
  *   <li><strong>IP address:</strong> whether connecting directly to an origin
  *       server or a proxy, opening a socket requires an IP address. The DNS
  *       server may return multiple IP addresses to attempt.
- *   <li><strong>TLS configuration:</strong> which cipher suites and TLS
- *       versions to attempt with the HTTPS connection.
  * </ul>
  * Each route is a specific selection of these options.
  */
 public final class Route {
   final Address address;
   final Proxy proxy;
   final InetSocketAddress inetSocketAddress;
-  final ConnectionSpec connectionSpec;
-  final boolean shouldSendTlsFallbackIndicator;
 
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec) {
-    this(address, proxy, inetSocketAddress, connectionSpec,
-        false /* shouldSendTlsFallbackIndicator */);
-  }
-
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec, boolean shouldSendTlsFallbackIndicator) {
+  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
     if (address == null) {
       throw new NullPointerException(""address == null"");
     }
@@ -57,14 +46,9 @@ public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
     if (inetSocketAddress == null) {
       throw new NullPointerException(""inetSocketAddress == null"");
     }
-    if (connectionSpec == null) {
-      throw new NullPointerException(""connectionConfiguration == null"");
-    }
     this.address = address;
     this.proxy = proxy;
     this.inetSocketAddress = inetSocketAddress;
-    this.connectionSpec = connectionSpec;
-    this.shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator;
   }
 
   public Address getAddress() {
@@ -86,14 +70,6 @@ public InetSocketAddress getSocketAddress() {
     return inetSocketAddress;
   }
 
-  public ConnectionSpec getConnectionSpec() {
-    return connectionSpec;
-  }
-
-  public boolean getShouldSendTlsFallbackIndicator() {
-    return shouldSendTlsFallbackIndicator;
-  }
-
   /**
    * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
    * href=""http://www.ietf.org/rfc/rfc2817.txt"">RFC 2817, Section 5.2</a>.
@@ -107,9 +83,7 @@ public boolean requiresTunnel() {
       Route other = (Route) obj;
       return address.equals(other.address)
           && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress)
-          && connectionSpec.equals(other.connectionSpec)
-          && shouldSendTlsFallbackIndicator == other.shouldSendTlsFallbackIndicator;
+          && inetSocketAddress.equals(other.inetSocketAddress);
     }
     return false;
   }
@@ -119,8 +93,6 @@ public boolean requiresTunnel() {
     result = 31 * result + address.hashCode();
     result = 31 * result + proxy.hashCode();
     result = 31 * result + inetSocketAddress.hashCode();
-    result = 31 * result + connectionSpec.hashCode();
-    result = 31 * result + (shouldSendTlsFallbackIndicator ? 1 : 0);
     return result;
   }
 }
@@ -43,4 +43,8 @@ public static TlsVersion forJavaName(String javaName) {
     }
     throw new IllegalArgumentException(""Unexpected TLS version: "" + javaName);
   }
+
+  public String javaName() {
+    return javaName;
+  }
 }
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.ConnectionSpec;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.ProtocolException;
+import java.net.UnknownServiceException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+
+/**
+ * Handles the connection spec fallback strategy: When a secure socket connection fails
+ * due to a handshake / protocol problem the connection may be retried with different protocols.
+ * Instances are stateful and should be created and used for a single connection attempt.
+ */
+public final class ConnectionSpecSelector {
+
+  private final List<ConnectionSpec> connectionSpecs;
+  private int nextModeIndex;
+  private boolean isFallbackPossible;
+  private boolean isFallback;
+
+  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+    this.nextModeIndex = 0;
+    this.connectionSpecs = connectionSpecs;
+  }
+
+  /**
+   * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
+   * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
+   *
+   * @throws IOException if the socket does not support any of the TLS modes available
+   */
+  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+    ConnectionSpec tlsConfiguration = null;
+    for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
+      ConnectionSpec connectionSpec = connectionSpecs.get(i);
+      if (connectionSpec.isCompatible(sslSocket)) {
+        tlsConfiguration = connectionSpec;
+        nextModeIndex = i + 1;
+        break;
+      }
+    }
+
+    if (tlsConfiguration == null) {
+      // This may be the first time a connection has been attempted and the socket does not support
+      // any the required protocols, or it may be a retry (but this socket supports fewer
+      // protocols than was suggested by a prior socket).
+      throw new UnknownServiceException(
+          ""Unable to find acceptable protocols. isFallback="" + isFallback
+              + "", modes="" + connectionSpecs
+              + "", supported protocols="" + Arrays.toString(sslSocket.getEnabledProtocols()));
+    }
+
+    isFallbackPossible = isFallbackPossible(sslSocket);
+
+    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+
+    return tlsConfiguration;
+  }
+
+  /**
+   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to
+   * try, if any.
+   *
+   * @return {@code true} if the connection should be retried using
+   *     {@link #configureSecureSocket(SSLSocket)} or {@code false} if not
+   */
+  public boolean connectionFailed(IOException e) {
+    // Any future attempt to connect using this strategy will be a fallback attempt.
+    isFallback = true;
+
+    // TODO(nfuller): This is the same logic as in HttpEngine.
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout, don't recover.
+    if (e instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different connection spec.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+    // TODO(nfuller): End of common code.
+
+
+    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
+    // retry those when we probably should not.
+    return ((e instanceof SSLHandshakeException || e instanceof SSLProtocolException))
+        && isFallbackPossible;
+  }
+
+  /**
+   * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
+   * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
+   * same capabilities as the supplied socket.
+   */
+  private boolean isFallbackPossible(SSLSocket socket) {
+    for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
+      if (connectionSpecs.get(i).isCompatible(socket)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
@@ -19,14 +19,17 @@
 import com.squareup.okhttp.Callback;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
 import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
 
 /**
  * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
@@ -35,6 +38,12 @@
  */
 public abstract class Internal {
   public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  public static void initializeInstanceForTests() {
+    // Needed in tests to ensure that the instance is actually pointing to something.
+    new OkHttpClient();
+  }
+
   public static Internal instance;
 
   public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
@@ -67,7 +76,10 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
   public abstract void setNetwork(OkHttpClient client, Network network);
 
   public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
-      HttpEngine owner, Request request) throws IOException;
+      HttpEngine owner, Request request) throws RouteException;
+
+  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
+      boolean isFallback);
 
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
@@ -22,9 +22,8 @@
 /**
  * A blacklist of failed routes to avoid when creating a new connection to a
  * target address. This is used so that OkHttp can learn from its mistakes: if
- * there was a failure attempting to connect to a specific IP address, proxy
- * server or TLS mode, that failure is remembered and alternate routes are
- * preferred.
+ * there was a failure attempting to connect to a specific IP address or proxy
+ * server, that failure is remembered and alternate routes are preferred.
  */
 public final class RouteDatabase {
   private final Set<Route> failedRoutes = new LinkedHashSet<>();
@@ -210,8 +210,15 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * Figures out what the response source will be, and opens a socket to that
    * source if necessary. Prepares the request headers and gets ready to start
    * writing the request body if it exists.
+   *
+   * @throws RequestException if there was a problem with request setup. Unrecoverable.
+   * @throws RouteException if the was a problem during connection via a specific route. Sometimes
+   *     recoverable. See {@link #recover(RouteException)}.
+   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
+   *     {@link #recover(IOException)}.
+   *
    */
-  public void sendRequest() throws IOException {
+  public void sendRequest() throws RequestException, RouteException, IOException {
     if (cacheStrategy != null) return; // Already sent.
     if (transport != null) throw new IllegalStateException();
 
@@ -308,12 +315,16 @@ private static Response stripBody(Response response) {
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  private void connect() throws IOException {
+  private void connect() throws RequestException, RouteException {
     if (connection != null) throw new IllegalStateException();
 
     if (routeSelector == null) {
       address = createAddress(client, networkRequest);
-      routeSelector = RouteSelector.get(address, networkRequest, client);
+      try {
+        routeSelector = RouteSelector.get(address, networkRequest, client);
+      } catch (IOException e) {
+        throw new RequestException(e);
+      }
     }
 
     connection = nextConnection();
@@ -325,24 +336,29 @@ private void connect() throws IOException {
    *
    * @throws java.util.NoSuchElementException if there are no more routes to attempt.
    */
-  private Connection nextConnection() throws IOException {
+  private Connection nextConnection() throws RouteException {
     Connection connection = createNextConnection();
     Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
     return connection;
   }
 
-  private Connection createNextConnection() throws IOException {
+  private Connection createNextConnection() throws RouteException {
     ConnectionPool pool = client.getConnectionPool();
 
     // Always prefer pooled connections over new connections.
     for (Connection pooled; (pooled = pool.get(address)) != null; ) {
       if (networkRequest.method().equals(""GET"") || Internal.instance.isReadable(pooled)) {
         return pooled;
       }
-      pooled.getSocket().close();
+      closeQuietly(pooled.getSocket());
+    }
+
+    try {
+      Route route = routeSelector.next();
+      return new Connection(pool, route);
+    } catch (IOException e) {
+      throw new RouteException(e);
     }
-    Route route = routeSelector.next();
-    return new Connection(pool, route);
   }
 
   /**
@@ -393,8 +409,75 @@ public Connection getConnection() {
   }
 
   /**
-   * Report and attempt to recover from {@code e}. Returns a new HTTP engine
-   * that should be used for the retry if {@code e} is recoverable, or null if
+   * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
+   * that should be used for the retry if there are other routes to try, or null if
+   * there are no more routes to try.
+   */
+  public HttpEngine recover(RouteException e) {
+    if (routeSelector != null && connection != null) {
+      connectFailed(routeSelector, e.getLastConnectException());
+    }
+
+    if (routeSelector == null && connection == null // No connection.
+        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+        || !isRecoverable(e)) {
+      return null;
+    }
+
+    Connection connection = close();
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
+  }
+
+  private boolean isRecoverable(RouteException e) {
+    // If the application has opted-out of recovery, don't recover.
+    if (!client.getRetryOnConnectionFailure()) {
+      return false;
+    }
+
+    // Problems with a route may mean the connection can be retried with a new route, or may
+    // indicate a client-side or server-side issue that should not be retried. To tell, we must look
+    // at the cause.
+
+    IOException ioe = e.getLastConnectException();
+
+    // TODO(nfuller): This is the same logic as in ConnectionSpecSelector
+    // If there was a protocol problem, don't recover.
+    if (ioe instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout, don't recover.
+    if (ioe instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (ioe instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (ioe.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (ioe instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+    // TODO(nfuller): End of common code.
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  /**
+   * Report and attempt to recover from a failure to communicate with a server. Returns a new
+   * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
    * the failure is permanent. Requests with a body can only be recovered if the
    * body is buffered.
    */
@@ -435,13 +518,6 @@ private boolean isRecoverable(IOException e) {
       return false;
     }
 
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server-initiated exception.
-    if (e instanceof SSLPeerUnverifiedException
-        || (e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException)) {
-      return false;
-    }
-
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
       return false;
@@ -1050,10 +1126,10 @@ && getEffectivePort(url) == getEffectivePort(followUp)
   }
 
   private static Address createAddress(OkHttpClient client, Request request)
-      throws UnknownHostException {
+      throws RequestException {
     String uriHost = request.url().getHost();
     if (uriHost == null || uriHost.length() == 0) {
-      throw new UnknownHostException(request.url().toString());
+      throw new RequestException(new UnknownHostException(request.url().toString()));
     }
 
     SSLSocketFactory sslSocketFactory = null;
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+
+/**
+ * Indicates a problem with interpreting a request. It may indicate there was a problem with the
+ * request itself, or the environment being used to interpret the request (network failure, etc.).
+ */
+public final class RequestException extends Exception {
+
+  public RequestException(IOException cause) {
+    super(cause);
+  }
+
+  @Override
+  public IOException getCause() {
+    return (IOException) super.getCause();
+  }
+}
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
+ * have been made with alternative protocols, none of which were successful.
+ */
+public final class RouteException extends Exception {
+
+  private final List<IOException> connectExceptions = new ArrayList<IOException>();
+
+  public RouteException(IOException cause) {
+    super(cause);
+    connectExceptions.add(cause);
+  }
+
+  public IOException getLastConnectException() {
+    return connectExceptions.get(connectExceptions.size() - 1);
+  }
+
+  public void addConnectException(IOException e) {
+    connectExceptions.add(e);
+  }
+}
@@ -16,7 +16,6 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
-import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Route;
@@ -30,13 +29,10 @@
 import java.net.SocketAddress;
 import java.net.SocketException;
 import java.net.URI;
-import java.net.UnknownServiceException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -51,12 +47,10 @@ public final class RouteSelector {
   private final Network network;
   private final OkHttpClient client;
   private final RouteDatabase routeDatabase;
-  private final Request request;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
   private InetSocketAddress lastInetSocketAddress;
-  private ConnectionSpec lastSpec;
 
   /* State for negotiating the next proxy to use. */
   private List<Proxy> proxies = Collections.emptyList();
@@ -66,59 +60,48 @@ public final class RouteSelector {
   private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
   private int nextInetSocketAddressIndex;
 
-  /* Specs to attempt with the connection. */
-  private List<ConnectionSpec> connectionSpecs = Collections.emptyList();
-  private int nextSpecIndex;
-
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  private RouteSelector(Address address, URI uri, OkHttpClient client, Request request) {
+  private RouteSelector(Address address, URI uri, OkHttpClient client) {
     this.address = address;
     this.uri = uri;
     this.client = client;
     this.routeDatabase = Internal.instance.routeDatabase(client);
     this.network = Internal.instance.network(client);
-    this.request = request;
 
     resetNextProxy(uri, address.getProxy());
   }
 
   public static RouteSelector get(Address address, Request request, OkHttpClient client)
       throws IOException {
-    return new RouteSelector(address, request.uri(), client, request);
+    return new RouteSelector(address, request.uri(), client);
   }
 
   /**
    * Returns true if there's another route to attempt. Every address has at
    * least one route.
    */
   public boolean hasNext() {
-    return hasNextConnectionSpec()
-        || hasNextInetSocketAddress()
+    return hasNextInetSocketAddress()
         || hasNextProxy()
         || hasNextPostponed();
   }
 
   public Route next() throws IOException {
     // Compute the next route to attempt.
-    if (!hasNextConnectionSpec()) {
-      if (!hasNextInetSocketAddress()) {
-        if (!hasNextProxy()) {
-          if (!hasNextPostponed()) {
-            throw new NoSuchElementException();
-          }
-          return nextPostponed();
+    if (!hasNextInetSocketAddress()) {
+      if (!hasNextProxy()) {
+        if (!hasNextPostponed()) {
+          throw new NoSuchElementException();
         }
-        lastProxy = nextProxy();
+        return nextPostponed();
       }
-      lastInetSocketAddress = nextInetSocketAddress();
+      lastProxy = nextProxy();
     }
-    lastSpec = nextConnectionSpec();
+    lastInetSocketAddress = nextInetSocketAddress();
 
-    final boolean shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator(lastSpec);
-    Route route = new Route(address, lastProxy, lastInetSocketAddress, lastSpec,
-        shouldSendTlsFallbackIndicator);
+    Route route = new Route(address, lastProxy, lastInetSocketAddress);
     if (routeDatabase.shouldPostpone(route)) {
       postponedRoutes.add(route);
       // We will only recurse in order to skip previously failed routes. They will be tried last.
@@ -128,11 +111,6 @@ public Route next() throws IOException {
     return route;
   }
 
-  private boolean shouldSendTlsFallbackIndicator(ConnectionSpec connectionSpec) {
-    return connectionSpec != connectionSpecs.get(0)
-        && connectionSpec.isTls();
-  }
-
   /**
    * Clients should invoke this method when they encounter a connectivity
    * failure on a connection returned by this route selector.
@@ -144,20 +122,6 @@ public void connectFailed(Route failedRoute, IOException failure) {
     }
 
     routeDatabase.failed(failedRoute);
-
-    // If the previously returned route's problem was not related to the connection's spec, and the
-    // next route only changes that, we shouldn't even attempt it. This suppresses it in both this
-    // selector and also in the route database.
-    if (!(failure instanceof SSLHandshakeException) && !(failure instanceof SSLProtocolException)) {
-      while (nextSpecIndex < connectionSpecs.size()) {
-        ConnectionSpec connectionSpec = connectionSpecs.get(nextSpecIndex++);
-        final boolean shouldSendTlsFallbackIndicator =
-            shouldSendTlsFallbackIndicator(connectionSpec);
-        Route toSuppress = new Route(address, lastProxy, lastInetSocketAddress, connectionSpec,
-            shouldSendTlsFallbackIndicator);
-        routeDatabase.failed(toSuppress);
-      }
-    }
   }
 
   /** Prepares the proxy servers to try. */
@@ -224,6 +188,7 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
       inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
     }
+
     nextInetSocketAddressIndex = 0;
   }
 
@@ -256,42 +221,7 @@ private InetSocketAddress nextInetSocketAddress() throws IOException {
       throw new SocketException(""No route to "" + address.getUriHost()
           + ""; exhausted inet socket addresses: "" + inetSocketAddresses);
     }
-    InetSocketAddress result = inetSocketAddresses.get(nextInetSocketAddressIndex++);
-    resetConnectionSpecs();
-    return result;
-  }
-
-  /** Prepares the connection specs to attempt. */
-  private void resetConnectionSpecs() {
-    connectionSpecs = new ArrayList<>();
-    List<ConnectionSpec> specs = address.getConnectionSpecs();
-    for (int i = 0, size = specs.size(); i < size; i++) {
-      ConnectionSpec spec = specs.get(i);
-      if (request.isHttps() == spec.isTls()) {
-        connectionSpecs.add(spec);
-      }
-    }
-    nextSpecIndex = 0;
-  }
-
-  /** Returns true if there's another connection spec to try. */
-  private boolean hasNextConnectionSpec() {
-    return nextSpecIndex < connectionSpecs.size();
-  }
-
-  /** Returns the next connection spec to try. */
-  private ConnectionSpec nextConnectionSpec() throws IOException {
-    if (connectionSpecs.isEmpty()) {
-      throw new UnknownServiceException(""No route to ""
-          + ((uri.getScheme() != null) ? (uri.getScheme() + ""://"") : ""//"") + address.getUriHost()
-          + ""; no connection specs"");
-    }
-    if (!hasNextConnectionSpec()) {
-      throw new SocketException(""No route to ""
-          + ((uri.getScheme() != null) ? (uri.getScheme() + ""://"") : ""//"") + address.getUriHost()
-          + ""; exhausted connection specs: "" + connectionSpecs);
-    }
-    return connectionSpecs.get(nextSpecIndex++);
+    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
   }
 
   /** Returns true if there is another postponed route to try. */
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Address;
+import com.squareup.okhttp.CertificatePinner;
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.Route;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.ConnectionSpecSelector;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.Socket;
+import java.net.URL;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+import okio.Source;
+
+import static com.squareup.okhttp.internal.Util.closeQuietly;
+import static com.squareup.okhttp.internal.Util.getDefaultPort;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+
+/**
+ * Helper that can establish a socket connection to a {@link com.squareup.okhttp.Route} using the
+ * specified {@link ConnectionSpec} set. A {@link SocketConnector} can be used multiple times.
+ */
+public class SocketConnector {
+  private final Connection connection;
+  private final ConnectionPool connectionPool;
+
+  public SocketConnector(Connection connection, ConnectionPool connectionPool) {
+    this.connection = connection;
+    this.connectionPool = connectionPool;
+  }
+
+  public ConnectedSocket connectCleartext(int connectTimeout, int readTimeout, Route route)
+      throws RouteException {
+    Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
+    return new ConnectedSocket(route, socket);
+  }
+
+  public ConnectedSocket connectTls(int connectTimeout, int readTimeout,
+      int writeTimeout, Request request, Route route, List<ConnectionSpec> connectionSpecs,
+      boolean connectionRetryEnabled) throws RouteException {
+
+    Address address = route.getAddress();
+    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+    RouteException routeException = null;
+    do {
+      Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
+      if (route.requiresTunnel()) {
+        createTunnel(readTimeout, writeTimeout, request, route, socket);
+      }
+
+      SSLSocket sslSocket = null;
+      try {
+        SSLSocketFactory sslSocketFactory = address.getSslSocketFactory();
+
+        // Create the wrapper over the connected socket.
+        sslSocket = (SSLSocket) sslSocketFactory
+            .createSocket(socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
+
+        // Configure the socket's ciphers, TLS versions, and extensions.
+        ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+        Platform platform = Platform.get();
+        Handshake handshake = null;
+        Protocol alpnProtocol = null;
+        try {
+          if (connectionSpec.supportsTlsExtensions()) {
+            platform.configureTlsExtensions(
+                sslSocket, address.getUriHost(), address.getProtocols());
+          }
+          // Force handshake. This can throw!
+          sslSocket.startHandshake();
+
+          handshake = Handshake.get(sslSocket.getSession());
+
+          String maybeProtocol;
+          if (connectionSpec.supportsTlsExtensions()
+              && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
+            alpnProtocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
+          }
+        } finally {
+          platform.afterHandshake(sslSocket);
+        }
+
+        // Verify that the socket's certificates are acceptable for the target host.
+        if (!address.getHostnameVerifier().verify(address.getUriHost(), sslSocket.getSession())) {
+          X509Certificate cert = (X509Certificate) sslSocket.getSession()
+              .getPeerCertificates()[0];
+          throw new SSLPeerUnverifiedException(
+              ""Hostname "" + address.getUriHost() + "" not verified:""
+              + ""\n    certificate: "" + CertificatePinner.pin(cert)
+              + ""\n    DN: "" + cert.getSubjectDN().getName()
+              + ""\n    subjectAltNames: "" + OkHostnameVerifier.allSubjectAltNames(cert));
+        }
+
+        // Check that the certificate pinner is satisfied by the certificates presented.
+        address.getCertificatePinner().check(address.getUriHost(), handshake.peerCertificates());
+
+        return new ConnectedSocket(route, sslSocket, alpnProtocol, handshake);
+      } catch (IOException e) {
+        boolean canRetry = connectionRetryEnabled && connectionSpecSelector.connectionFailed(e);
+        closeQuietly(sslSocket);
+        closeQuietly(socket);
+        if (routeException == null) {
+          routeException = new RouteException(e);
+        } else {
+          routeException.addConnectException(e);
+        }
+        if (!canRetry) {
+          throw routeException;
+        }
+      }
+    } while (true);
+  }
+
+  private Socket connectRawSocket(int soTimeout, int connectTimeout, Route route)
+      throws RouteException {
+    Platform platform = Platform.get();
+    try {
+      Proxy proxy = route.getProxy();
+      Address address = route.getAddress();
+      Socket socket;
+      if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP) {
+        socket = address.getSocketFactory().createSocket();
+      } else {
+        socket = new Socket(proxy);
+      }
+      socket.setSoTimeout(soTimeout);
+      platform.connectSocket(socket, route.getSocketAddress(), connectTimeout);
+
+      return socket;
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
+   * CONNECT request to create the proxy connection. This may need to be
+   * retried if the proxy requires authorization.
+   */
+  private void createTunnel(int readTimeout, int writeTimeout, Request request, Route route,
+      Socket socket) throws RouteException {
+    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+    try {
+      Request tunnelRequest = createTunnelRequest(request);
+      HttpConnection tunnelConnection = new HttpConnection(connectionPool, connection, socket);
+      tunnelConnection.setTimeouts(readTimeout, writeTimeout);
+      URL url = tunnelRequest.url();
+      String requestLine = ""CONNECT "" + url.getHost() + "":"" + url.getPort() + "" HTTP/1.1"";
+      while (true) {
+        tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+        tunnelConnection.flush();
+        Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+        // The response body from a CONNECT should be empty, but if it is not then we should consume
+        // it before proceeding.
+        long contentLength = OkHeaders.contentLength(response);
+        if (contentLength == -1L) {
+          contentLength = 0L;
+        }
+        Source body = tunnelConnection.newFixedLengthSource(contentLength);
+        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+        body.close();
+
+        switch (response.code()) {
+          case HTTP_OK:
+            // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+            // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+            // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+            // that it will almost certainly fail because the proxy has sent unexpected data.
+            if (tunnelConnection.bufferSize() > 0) {
+              throw new IOException(""TLS tunnel buffered too many bytes!"");
+            }
+            return;
+
+          case HTTP_PROXY_AUTH:
+            tunnelRequest = OkHeaders.processAuthHeader(
+                route.getAddress().getAuthenticator(), response, route.getProxy());
+            if (tunnelRequest != null) continue;
+            throw new IOException(""Failed to authenticate with proxy"");
+
+          default:
+            throw new IOException(
+                ""Unexpected response code for CONNECT: "" + response.code());
+        }
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
+   * no tunnel is necessary. Everything in the tunnel request is sent
+   * unencrypted to the proxy server, so tunnels include only the minimum set of
+   * headers. This avoids sending potentially sensitive data like HTTP cookies
+   * to the proxy unencrypted.
+   */
+  private Request createTunnelRequest(Request request) throws IOException {
+    String host = request.url().getHost();
+    int port = getEffectivePort(request.url());
+    String authority = (port == getDefaultPort(""https"")) ? host : (host + "":"" + port);
+    Request.Builder result = new Request.Builder()
+        .url(new URL(""https"", host, port, ""/""))
+        .header(""Host"", authority)
+        .header(""Proxy-Connection"", ""Keep-Alive""); // For HTTP/1.0 proxies like Squid.
+
+    // Copy over the User-Agent header if it exists.
+    String userAgent = request.header(""User-Agent"");
+    if (userAgent != null) {
+      result.header(""User-Agent"", userAgent);
+    }
+
+    // Copy over the Proxy-Authorization header if it exists.
+    String proxyAuthorization = request.header(""Proxy-Authorization"");
+    if (proxyAuthorization != null) {
+      result.header(""Proxy-Authorization"", proxyAuthorization);
+    }
+
+    return result.build();
+  }
+
+  /**
+   * A connected socket with metadata.
+   */
+  public static class ConnectedSocket {
+    public final Route route;
+    public final Socket socket;
+    public final Protocol alpnProtocol;
+    public final Handshake handshake;
+
+    /** A connected plain / raw (i.e. unencrypted communication) socket. */
+    public ConnectedSocket(Route route, Socket socket) {
+      this.route = route;
+      this.socket = socket;
+      alpnProtocol = null;
+      handshake = null;
+    }
+
+    /** A connected {@link SSLSocket}. */
+    public ConnectedSocket(Route route, SSLSocket socket, Protocol alpnProtocol,
+        Handshake handshake) {
+      this.route = route;
+      this.socket = socket;
+      this.alpnProtocol = alpnProtocol;
+      this.handshake = handshake;
+    }
+  }
+}
",,,,,,,,,,,,,,,,,,
https://github.com/square/retrofit/commit/778a67e3c27226aecf5292ba4c3785a5d3c53067,Update README.md,https://api.github.com/repos/square/retrofit/commits/778a67e3c27226aecf5292ba4c3785a5d3c53067,"@@ -21,7 +21,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jaxb:latest.version'
+implementation 'com.squareup.retrofit2:converter-jaxb:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
",True,"The commit message does not explicitly reference a convention, standard, or improvement in prior commits. However, the change in the code diff from 'compile' to 'implementation' suggests that the project might be transitioning from using an older version of Gradle to a newer one. In newer versions of Gradle, 'compile' has been replaced with 'implementation' for better dependency management and separation of concerns. This change is likely an improvement and the commit message could have been more descriptive about this, such as 'Update to Gradle 5.0 and use implementation instead of compile for better dependency management'.",True,"The commit message 'Update README.md' does not explicitly explain the necessity of the changes. However, the code diff shows that the change is a simple update to the build configuration, specifically changing 'compile' to 'implementation' in the Gradle dependency. This is likely a version management change to align with the latest Gradle syntax. While it's not explicitly stated in the commit message, the change is common sense and easy to infer from the code diff.",False,"The commit message 'Update README.md' does not directly elaborate the motivation of the code change. It only mentions that a file (README.md) has been updated. The code diff shows a change in the build configuration from 'compile' to 'implementation', which is likely due to a change in the build tool or version. However, the commit message does not explain why this change was necessary, such as mentioning an error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message does not explicitly state the reason for the changes, but the code diff indicates that the developer is updating the build configuration. The change from 'compile' to 'implementation' suggests that the developer might be updating the build tool or configuration to match a newer version or standard. This could be due to a change in the development environment, such as a newer version of Gradle, which might require a different configuration syntax. Therefore, the changes could be necessary to maintain the functionality of the software in the updated development environment.",True,"The commit message does not explicitly mention the defects it fixes or the improvements it makes to the code. However, the code diff shows that the change is updating the dependency configuration from 'compile' to 'implementation'. This change is likely made to align with the new Gradle configuration syntax, which is an improvement to the code. While it's not explicitly stated in the commit message, the change can be inferred to improve the build configuration and potentially address any compatibility issues with the new Gradle version.",True,"The commit message 'Update README.md' does contain an expression that describes a summary of what changes by being a summary of the diffs. The key component of the change is the modification of the build configuration in the README.md file. Specifically, the message highlights the change from 'compile' to 'implementation' in the Gradle configuration for the 'converter-jaxb' dependency. This contrasts the before and after state of the configuration, making it clear that the change is an update to the build system.",False,"The commit message only mentions updating the README.md file and the code diff shows a change in the build.gradle file. However, the commit message does not explain the technical principle underpinning the changes, which is the difference between 'compile' and 'implementation' in Gradle build scripts. The 'implementation' keyword is used to set dependencies that are only needed for compilation and not for runtime or test compilation, while 'compile' is used for dependencies that are needed for both compilation and runtime. Therefore, the commit message does not contain an expression that describes this technical principle.",True,"The commit message 'Update README.md' does contain an expression that describes a summary of what changes by explaining the code changes from a functional perspective. The code diff shows a change in the build configuration from 'compile' to 'implementation'. This change is significant because it indicates a change in the dependency configuration, specifically moving from the old 'compile' configuration to the new 'implementation' configuration introduced in Gradle 5.0. This change does not affect the behavior of the code itself, but it does introduce a new way of managing dependencies in the build system, which is a new behavior introduced by the commit.",True,"The commit message does not explicitly explain the reason for the change, but the change itself is quite clear from the diff. The change is a simple replacement of 'compile' with 'implementation' in the README.md file. This is a common change in build configuration files when migrating from Gradle versions that use 'compile' to newer versions that use 'implementation'. Therefore, the reason for the change can be easily inferred from the change itself, and there was no need for an explicit explanation in the commit message."
https://github.com/apache/dubbo/commit/6140bc2a653cc3066d15ceeff5a3f06962fb32ad,"Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated. ",https://api.github.com/repos/apache/dubbo/commits/6140bc2a653cc3066d15ceeff5a3f06962fb32ad,"@@ -505,8 +505,6 @@ && isPrimitive(method.getReturnType())) {
                     }
                 }
             } catch (Exception e) {
-                System.out.println(this.getClass().getName());
-                System.out.println(method.getName());
                 throw new IllegalStateException(e.getMessage(), e);
             }
         }
@@ -56,8 +56,6 @@ public void init() {
         /**
          * Instead of using Dubbo's configuration, I would suggest use the original configuration method Apollo provides.
          */
-//        String configEnv = env.getCompositeConf().getString(ENV_KEY);
-//        String configCluster = env.getCompositeConf().getString(CLUSTER_KEY);
         String configEnv = url.getParameter(Constants.CONFIG_ENV_KEY);
         String configAddr = url.getBackupAddress();
         String configCluster = url.getParameter(Constants.CONFIG_CLUSTER_KEY);
@@ -39,6 +39,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
@@ -59,7 +60,7 @@ public class ZooKeeperConfigurationSource implements WatchedConfigurationSource,
     // The final root path would be: /configRootPath/""config""
     private final String configRootPath;
     private final TreeCache treeCache;
-    private boolean connected = false;
+    private CountDownLatch initializedLatch = new CountDownLatch(1);
 
     private final Charset charset = Charset.forName(""UTF-8"");
 
@@ -96,7 +97,7 @@ public ZooKeeperConfigurationSource(String connectString, int sessionTimeout, in
                 new ExponentialBackoffRetry(1000, 3));
         client.start();
         try {
-            connected = client.blockUntilConnected(connectTimeout, TimeUnit.MILLISECONDS);
+            boolean connected = client.blockUntilConnected(connectTimeout, TimeUnit.MILLISECONDS);
             if (!connected) {
                 boolean check = Boolean.parseBoolean(System.getProperty(ARCHAIUS_CONFIG_CHECK_KEY, ""false""));
                 if (check) {
@@ -138,8 +139,8 @@ public void childEvent(CuratorFramework aClient, TreeCacheEvent event)
 
                 TreeCacheEvent.Type type = event.getType();
                 ChildData data = event.getData();
-                if (type == TreeCacheEvent.Type.INITIALIZED || type == TreeCacheEvent.Type.CONNECTION_RECONNECTED) {
-                    connected = true;
+                if (type == TreeCacheEvent.Type.INITIALIZED) {
+                    initializedLatch.countDown();
                 }
 
                 // TODO, ignore other event types
@@ -202,9 +203,10 @@ public Map<String, Object> getCurrentData() throws Exception {
 
         Map<String, Object> all = new HashMap<>();
 
-        if (!connected) {
-            logger.warn(""ConfigCenter is not connected yet, zookeeper does't support local snapshot, so there's no backup data to use!"");
-            return all;
+        try {
+            initializedLatch.await();
+        } catch (InterruptedException e) {
+            logger.error(""Being interrupted unexpectedly when waiting zookeeper to initialize, the config data may not ready yet, be careful!"");
         }
 
         Map<String, ChildData> dataMap = treeCache.getCurrentChildren(configRootPath);
@@ -257,8 +259,4 @@ public void close() {
             logger.error(""IOException should not have been thrown."", exc);
         }
     }
-
-    public boolean isConnected() {
-        return connected;
-    }
 }
",True,"The commit message refers to a concurrent problem in the zookeeper configcenter, which is fixed by waiting to start until the cache is fully populated. This change is likely necessary to improve the stability and reliability of the system.",True,"The commit message 'Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated.' clearly describes the necessity of the changes. The code diff shows that the changes are made to handle a concurrent problem in the zookeeper configcenter. The addition of a CountDownLatch and modifications to the childEvent and getCurrentData methods are likely to ensure that the cache is fully populated before the start of the application, which is a common solution to concurrent problems.",True,"The commit message 'Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated.' directly elaborates the motivation of the code change. It mentions the 'concurrent problem' that was being faced and the solution implemented to 'wait to start until cache being fully populated'. This indicates that the change was made to address a specific issue or shortcoming in the previous implementation.",True,"The commit message 'Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated.' indicates that the developer is addressing a concurrent problem in the zookeeper configcenter. This could be due to the need for software development to ensure the requirements of users are met, as the configcenter needs to be fully populated before the application starts, which could prevent inconsistencies or errors caused by concurrent access. The code diff also supports this interpretation, as it shows changes related to handling the initialization of the zookeeper client and waiting for it to be fully connected before proceeding.",True,"The commit message 'Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated.' directly mentions the defect it fixes, which is a concurrent problem in the zookeeper configcenter. The code diff also supports this by adding a CountDownLatch to ensure that the cache is fully populated before the start of the application.",True,"The commit message 'Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated.' does describe a summary of the changes made in the diff. The diff shows that a CountDownLatch is added to ensure that the cache is fully populated before the application starts. This is exactly what the commit message suggests.",True,"The commit message 'Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated.' describes the technical principle underpinning the changes, which is to ensure that the configuration cache is fully populated before the system starts. This is achieved by using a CountDownLatch to block the start of the system until the cache is fully populated.",True,"The commit message 'Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated.' describes the functional change made to the code. The code changes involve adding a CountDownLatch to ensure that the configuration cache is fully populated before the application starts. This is done to address a concurrent problem where the application might start using the configuration before it has been fully loaded. The new behavior introduced is that the application will wait until the configuration cache is fully populated before starting, which ensures that the application has access to all the necessary configuration data.",False,"The commit message does not lack an explanation. It explicitly mentions the reason for the commit: 'Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated.' This is necessary because the change involves modifying the initialization process of the zookeeper configcenter to ensure that it waits until the cache is fully populated before starting. The code diff also supports this explanation by showing the addition of a CountDownLatch to block the initialization process until the cache is fully populated."
https://github.com/spring-projects/spring-boot/commit/deef784403419ed57cb733089c0326d8b0781dd2,"Blitz some more special characters from the metric names  <enter> When MVC path matchers are used as metric keys, they can still contain invalid characters and patterns (like asterisks). This change removes some more special characters and also tidies up the names a bit so no key part starts or ends with '-' (which is ugly). <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/deef784403419ed57cb733089c0326d8b0781dd2,"@@ -101,7 +101,7 @@ protected void doFilterInternal(HttpServletRequest request,
 					// not convertible
 				}
 				if (bestMatchingPattern != null) {
-					suffix = bestMatchingPattern.toString().replaceAll(""[{}]"", ""-"");
+					suffix = fixSpecialCharacters(bestMatchingPattern.toString());
 				}
 				else if (httpStatus.is4xxClientError()) {
 					suffix = UNKNOWN_PATH_SUFFIX;
@@ -114,6 +114,20 @@ else if (httpStatus.is4xxClientError()) {
 			}
 		}
 
+		private String fixSpecialCharacters(String value) {
+			String result = value.replaceAll(""[{}]"", ""-"");
+			result = result.replace(""**"", ""-star-star-"");
+			result = result.replace(""*"", ""-star-"");
+			result = result.replace(""/-"", ""/"");
+			if (result.endsWith(""-"")) {
+				result = result.substring(0, result.length() - 1);
+			}
+			if (result.startsWith(""-"")) {
+				result = result.substring(1);
+			}
+			return result;
+		}
+
 		private int getStatus(HttpServletResponse response) {
 			try {
 				return response.getStatus();
@@ -89,9 +89,9 @@ public void recordsHttpInteractionsWithTemplateVariable() throws Exception {
 		mvc.perform(get(""/templateVarTest/foo"")).andExpect(status().isOk());
 
 		verify(context.getBean(CounterService.class)).increment(
-				""status.200.templateVarTest.-someVariable-"");
+				""status.200.templateVarTest.someVariable"");
 		verify(context.getBean(GaugeService.class)).submit(
-				eq(""response.templateVarTest.-someVariable-""), anyDouble());
+				eq(""response.templateVarTest.someVariable""), anyDouble());
 		context.close();
 	}
 
@@ -106,9 +106,9 @@ public void recordsKnown404HttpInteractionsAsSingleMetricWithPathAndTemplateVari
 		mvc.perform(get(""/knownPath/foo"")).andExpect(status().isNotFound());
 
 		verify(context.getBean(CounterService.class)).increment(
-				""status.404.knownPath.-someVariable-"");
+				""status.404.knownPath.someVariable"");
 		verify(context.getBean(GaugeService.class)).submit(
-				eq(""response.knownPath.-someVariable-""), anyDouble());
+				eq(""response.knownPath.someVariable""), anyDouble());
 		context.close();
 	}
 
",True,"The commit message refers to the necessity of changes by mentioning that MVC path matchers used as metric keys can still contain invalid characters and patterns. This is a convention or standard that the commit message is addressing. The changes made in the code diff are to remove some more special characters and tidy up the names so no key part starts or ends with '-', which is considered ugly. This is done to ensure the metric names are valid and follow a certain standard or convention.",True,"The commit message 'Blitz some more special characters from the metric names' does not explicitly state the necessity of the changes. However, the changes are made to remove special characters and patterns from the metric keys, which is likely done to ensure the keys are valid and consistent. This is a common practice to maintain data integrity and ease of use, and it is easy to infer the necessity of these changes from the code diff.",True,"The commit message explains the problem that can arise if special characters are not properly handled in metric names. It mentions that MVC path matchers can contain invalid characters and patterns, which can lead to issues. The message also mentions that the change is to remove some more special characters and tidy up the names to avoid starting or ending with '-', which is considered ugly. Additionally, the message mentions that it fixes an issue, which implies that there was a known problem that the change is addressing.",True,"The commit message describes the necessity of changes by mentioning that MVC path matchers can still contain invalid characters and patterns. This indicates that the changes are being made to address a problem in the software maintenance process, specifically to fix a bug or issue that was causing invalid characters to be used in metric keys.",True,"The commit message directly mentions the issue it fixes, which is the presence of invalid characters and patterns in the metric names. It also mentions the improvements made to the code, such as removing special characters and tidying up the names to ensure no key part starts or ends with '-'.",True,"The commit message 'Blitz some more special characters from the metric names' does describe a summary of what changes by being a summary of the diffs. It points out that the change is to remove more special characters from the metric names, which is exactly what the diff shows. Additionally, the message mentions that it also tidies up the names so no key part starts or ends with '-', which is also reflected in the diff where a new method 'fixSpecialCharacters' is added to handle this.",True,"The commit message explains that the changes are made to handle special characters in metric names, which can cause issues. The code diff shows that the special characters are being replaced with more appropriate characters or patterns. This demonstrates the technical principle of sanitizing input to ensure it is in a format that can be handled correctly.",True,"The commit message 'Blitz some more special characters from the metric names' accurately summarizes the changes made in the code. It explains that the changes are being made to handle special characters and patterns in the metric keys, which can cause issues. The code diff shows that the special characters are being replaced with '-' or other appropriate strings, and the function 'fixSpecialCharacters' has been added to handle this. Additionally, the commit message mentions that it also tidies up the names so no key part starts or ends with '-', which is also reflected in the code changes. Therefore, the commit message effectively describes the functional changes made to the code.",False,The commit message does not lack an explanation. It clearly states that the change is to remove special characters from the metric names to ensure they are valid and to tidy up the names. It also mentions that this fixes a specific issue.
https://github.com/square/okhttp/commit/82f773376e19bb7e10916627349fad06e45f90cb,Add HTTP/2 and TLSv1.3 columns to our security providers doc ,https://api.github.com/repos/square/okhttp/commits/82f773376e19bb7e10916627349fad06e45f90cb,"@@ -4,12 +4,24 @@ Security Providers
 
 ## Provider Status
 
-| Provider            | Issues                                                | Link                                                        | Usage Guidance |
-| ------------------- | ----------------------------------------------------- | ----------------------------------------------------------- | -------------- |
-| Bouncy Castle       | [#5698](https://github.com/square/okhttp/issues/5698) | https://www.bouncycastle.org/java.html                      | Clean-Room JSSE implementation |
-| Conscrypt - Android | ✅                                                    |  https://www.conscrypt.org/                                 | TLS 1.3 via BoringSSL. Activated if Conscrypt is first registered provider. |
-| Conscrypt - OpenJDK | ✅                                                    | https://www.conscrypt.org/                                  | TLS 1.3 via BoringSSL. Activated if Conscrypt is first registered provider. |
-| OpenJSSE            | ✅ Missing HTTP/2                                     | https://github.com/openjsse/openjsse                        | Supports TLS 1.3 on Java SE 8 |
-| Corretto            | [#5592](https://github.com/square/okhttp/issues/5592) | https://github.com/corretto/amazon-corretto-crypto-provider | Amazon high-performance cryptographic implementations backed by OpenSSL |
+| Provider         | HTTP/2  | TLSv1.3      | Powered By      | Notes                                                        |
+| :--------------- | :------ | :----------- | :-------------- | :----------------------------------------------------------- |
+| JVM default      | Java 9+ | Java 11+     | [OpenJDK]       |                                                              |
+| Android default  | ✅      | Android 10+  | [BoringSSL]     |                                                              |
+| [Bouncy Castle]  | ✅      |              | [Bouncy Castle] | [Tracking bug.][bug5698]                                     |
+| [Conscrypt]      | ✅      | ✅           | [BoringSSL]     | Activated if Conscrypt is first registered provider.         |
+| [OpenJSSE]       |         | ✅           | [OpenJDK]       | OpenJDK backport.                                            |
+| [Corretto]       | ✅      | ✅           | [OpenSSL]       | Amazon's high-performance provider. [Tracking bug.][bug5592] |
 
+All providers support HTTP/1.1 and TLSv1.2.
 
+
+[BoringSSL]: https://boringssl.googlesource.com/boringssl/
+[Bouncy Castle]: https://www.bouncycastle.org/java.html
+[Conscrypt]: https://www.conscrypt.org/
+[Corretto]: https://github.com/corretto/amazon-corretto-crypto-provider
+[OpenJDK]: https://openjdk.java.net/groups/security/
+[OpenJSSE]: https://github.com/openjsse/openjsse
+[OpenSSL]: https://www.openssl.org/
+[bug5592]: https://github.com/square/okhttp/issues/5592
+[bug5698]: https://github.com/square/okhttp/issues/5698
",True,The commit message refers to the necessity of changes by mentioning the addition of HTTP/2 and TLSv1.3 columns to the security providers documentation. This is done to improve the documentation by providing more detailed information about the capabilities of different security providers.,True,"The commit message 'Add HTTP/2 and TLSv1.3 columns to our security providers doc' does not explicitly explain why the changes are necessary, but it is easy to infer from the code diff that the changes are being made to update the documentation to reflect the current support for HTTP/2 and TLSv1.3 by various security providers. This is a common practice in documentation updates and does not require an explicit rationale in the commit message.",True,"The commit message 'Add HTTP/2 and TLSv1.3 columns to our security providers doc' does contain an expression that describes the necessity of changes. The changes are made to address the shortcoming of the previous implementation, which was missing the HTTP/2 and TLSv1.3 columns in the security providers documentation. This is evident from the code diff, where the new columns are added to the table.",True,"The commit message 'Add HTTP/2 and TLSv1.3 columns to our security providers doc' indicates that the changes were made to address the need for software development to meet the requirements of users. The document is being updated to include new columns for HTTP/2 and TLSv1.3, which are newer protocols that are not currently supported by all providers. This suggests that the changes are being made to improve the functionality and security of the software for users.",True,The commit message 'Add HTTP/2 and TLSv1.3 columns to our security providers doc' directly mentions the improvements it makes to the code by adding new columns for HTTP/2 and TLSv1.3 support to the security providers documentation. This change provides more detailed information about the capabilities of different security providers.,True,"The commit message 'Add HTTP/2 and TLSv1.3 columns to our security providers doc' accurately summarizes the changes made in the diff. It clearly points out the addition of two new columns (HTTP/2 and TLSv1.3) to the security providers documentation, which is a key component of the change.",False,"The commit message does not explicitly describe the technical principle underpinning the changes. It only mentions adding HTTP/2 and TLSv1.3 columns to a documentation table, which is a change in the presentation of existing information rather than a change in the underlying technical implementation.",True,"The commit message 'Add HTTP/2 and TLSv1.3 columns to our security providers doc' accurately describes the changes made in the code diff. The changes added two new columns to the table, one for HTTP/2 and one for TLSv1.3, which are both new behaviors introduced. The diff shows that the table now includes information about which providers support HTTP/2 and TLSv1.3, which aligns with the commit message.",False,The commit message does not lack an explanation. It clearly states that the columns for HTTP/2 and TLSv1.3 are being added to the security providers documentation. This is not a trivial change as it involves updating the documentation to include new information about the capabilities of different security providers.
https://github.com/junit-team/junit4/commit/4411c102d489c2272d7e38606e912a54be4defa8,"Restore folder `javadoc/latest` for Javadoc.  <enter> This folder has been used for many years. There are links to Javadoc at that folder (e.g.  http://stackoverflow.com/questions/156503/how-do-you-assert-that-a-certain-exception-is-thrown-in-junit-4-tests/2935935#2935935  ). Restoring the folder `javadoc/latest` will hopefully restore the Javadoc pages in Google Search, too. ",https://api.github.com/repos/junit-team/junit4/commits/4411c102d489c2272d7e38606e912a54be4defa8,"@@ -383,6 +383,7 @@
                 <artifactId>maven-javadoc-plugin</artifactId>
                 <version>2.9.1</version>
                 <configuration>
+                    <destDir>javadoc/latest</destDir>
                     <stylesheetfile>${basedir}/src/main/javadoc/stylesheet.css</stylesheetfile>
                     <show>protected</show>
                     <author>false</author>
@@ -88,7 +88,7 @@
             <li><a href=""https://github.com/junit-team/junit/wiki/Maintainer-documentation"">Maintainer Documentation</a></li>
             <li><a href=""https://github.com/junit-team/junit/wiki/I-want-to-help%21"">I want to help!</a></li>
             <li><a href=""http://stackoverflow.com/questions/tagged/junit"">Latest JUnit Questions on StackOverflow</a></li>
-            <li><a href=""./apidocs/"">JavaDocs</a></li>
+            <li><a href=""javadoc/latest/index.html"">JavaDocs</a></li>
             <li><a href=""./faq.html"">Frequently asked questions</a></li>
             <li><a href=""https://github.com/junit-team/junit/wiki"">Wiki</a></li>
           </ul>
",True,"The commit message refers to the long-standing use of the 'javadoc/latest' folder for hosting Javadoc pages. It also mentions that there are links to Javadoc at that folder, which implies that the folder's existence is a convention or standard. The diff shows that the folder is being restored by adding a destination directory for the Javadoc plugin. This change is likely necessary to restore the functionality of the Javadoc pages, which were previously linked to the 'javadoc/latest' folder.",True,"The commit message explains that the folder 'javadoc/latest' has been used for many years and there are links to Javadoc at that folder. The changes in the diff also confirm this by modifying the destination directory for Javadoc generation and updating the links in the project's documentation. This makes it clear that the changes are necessary to restore the functionality of the Javadoc pages, which was previously broken.",True,"The commit message explains the motivation for the code change by mentioning that the 'javadoc/latest' folder has been used for many years and there are links to Javadoc at that folder. The message also mentions that restoring the folder will hopefully restore the Javadoc pages in Google Search, too. This directly elaborates the necessity of the changes by describing the shortcoming of the previous implementation, which was the absence of the 'javadoc/latest' folder, and the problem scenario that it caused.",True,"The commit message mentions that the folder 'javadoc/latest' has been used for many years and there are links to Javadoc at that folder. This indicates that the Javadoc pages have been missing or out of date, which is a problem in the process of software maintenance. Restoring the folder will hopefully restore the Javadoc pages in Google Search, too, which further emphasizes the necessity of the changes.",True,"The commit message directly mentions the objective of the change by stating that it is restoring the folder 'javadoc/latest' for Javadoc. This change is expected to restore the Javadoc pages in Google Search, which implies that the change is fixing a problem or improving the functionality of the code.",True,"The commit message accurately summarizes the changes made in the diff. It mentions the restoration of the 'javadoc/latest' folder, which was removed in the previous commit. This is also reflected in the diff, where a line is added to configure the destination directory for the Javadoc plugin to be 'javadoc/latest'. Additionally, the commit message explains the reason for the change, mentioning that the folder has been used for many years and that there are links to Javadoc at that folder. This provides context for the change and its potential impact.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly discusses the restoration of a folder for Javadoc and its potential impact on external links and Google Search. However, it does not explain why the folder was moved or deleted in the first place, or what technical principle or best practice is being restored by this change.",True,"The commit message expresses the restoration of a folder named 'javadoc/latest' which was used for Javadoc. This change is also reflected in the code diff where a line is added to configure the destination directory for the Javadoc plugin to be 'javadoc/latest'. Additionally, the commit message mentions that there are links to Javadoc at that folder and restoring the folder will hopefully restore the Javadoc pages in Google Search. This indicates that the change will introduce new behavior, i.e., making the Javadoc pages available again at the specified location.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'This folder has been used for many years' and 'Restoring the folder `javadoc/latest` will hopefully restore the Javadoc pages in Google Search, too.' The change in the diff is not trivial, as it involves updating the destination directory for Javadoc generation and changing the link to the Javadoc in the project's documentation. Therefore, the commit message provides a clear and sufficient explanation for the change."
https://github.com/square/okhttp/commit/6a79c3223c5ff2d556bbab8eb9909fffc4ca4387,Update README.md -> Mockito moved to Github ,https://api.github.com/repos/square/okhttp/commits/6a79c3223c5ff2d556bbab8eb9909fffc4ca4387,"@@ -19,7 +19,7 @@ awkward-to-reproduce situations like 500 errors or slow-loading responses.
 ### Example
 
 Use MockWebServer the same way that you use mocking frameworks like
-[Mockito](https://code.google.com/p/mockito/):
+[Mockito](https://github.com/mockito/mockito):
 
 1. Script the mocks.
 2. Run application code.
",True,"The commit message refers to a change in the README.md file, which is a convention for documenting the project. The change is made to update the link to Mockito's new location on GitHub. This is done to improve the accuracy and usability of the documentation, as the previous link was outdated.",True,"The commit message 'Update README.md -> Mockito moved to Github' clearly describes the necessity of the change. The code diff shows that the link to Mockito in the README.md file has been updated from 'code.google.com' to 'github.com'. This is a common practice and easy to infer that the change is made because the project has moved its repository to GitHub. Therefore, the commit message does not need to provide a rationale beyond what is already clear from the change.",False,"The commit message does not directly elaborate the motivation of the code change. It only mentions that Mockito has moved to GitHub, but it does not explain why this change was necessary, what problem it solves, or what issue report it is related to.",True,"The commit message 'Update README.md -> Mockito moved to Github' indicates that the change was made due to an external factor, in this case, the source code repository for Mockito has been moved from Google Code to GitHub. This is a common requirement in software development, as it's necessary to keep up with changes in the tools and libraries that the software depends on. Therefore, the commit message does express the necessity of changes by describing the source of the requirements.",False,"The commit message only mentions a change in the README.md file, specifically updating the link for Mockito to point to its new location on GitHub. It does not directly mention any defects that are fixed or improvements made to the code.",True,"The commit message 'Update README.md -> Mockito moved to Github' accurately summarizes the change in the diff. It points out the key component of the change, which is the update of the Mockito link in the README.md file from 'code.google.com' to 'github.com'. This is a clear and concise summary of the change, and it effectively contrasts the before and after states of the link.",False,The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions that the link to Mockito in the README.md file has been updated to point to its new location on GitHub. The code diff does not provide any context to infer a technical principle.,True,"The commit message 'Update README.md -> Mockito moved to Github' does express a change and it does describe the functional perspective of the code changes. The change in the README.md file is updating the link for Mockito from 'code.google.com' to 'github.com'. This change doesn't introduce any new behavior to the codebase, but it does update a reference to an external resource, which could be considered a functional change from a user's perspective.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'Mockito moved to Github'. This change is not trivial as it involves updating a URL in the README.md file. The reason for the change is not immediately obvious from the diff, as the change is not a simple text removal or addition."
https://github.com/apache/dubbo/commit/635bc7983287d47d1d2c637a85fe21aabacdcd27,Remove the shutdown logic from spring bean destroy to avoid competition. ,https://api.github.com/repos/apache/dubbo/commits/635bc7983287d47d1d2c637a85fe21aabacdcd27,"@@ -16,10 +16,16 @@
  */
 package com.alibaba.dubbo.config.spring;
 
-import com.alibaba.dubbo.config.*;
+import com.alibaba.dubbo.config.ApplicationConfig;
+import com.alibaba.dubbo.config.ConsumerConfig;
+import com.alibaba.dubbo.config.ModuleConfig;
+import com.alibaba.dubbo.config.MonitorConfig;
+import com.alibaba.dubbo.config.ReferenceConfig;
+import com.alibaba.dubbo.config.RegistryConfig;
 import com.alibaba.dubbo.config.annotation.Reference;
 import com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory;
 import com.alibaba.dubbo.config.support.Parameter;
+
 import org.springframework.beans.factory.BeanFactoryUtils;
 import org.springframework.beans.factory.DisposableBean;
 import org.springframework.beans.factory.FactoryBean;
@@ -167,4 +173,8 @@ public void afterPropertiesSet() throws Exception {
         }
     }
 
+    @Override
+    public void destroy() {
+        // do nothing
+    }
 }
\ No newline at end of file
@@ -16,9 +16,16 @@
  */
 package com.alibaba.dubbo.config.spring;
 
-import com.alibaba.dubbo.config.*;
+import com.alibaba.dubbo.config.ApplicationConfig;
+import com.alibaba.dubbo.config.ModuleConfig;
+import com.alibaba.dubbo.config.MonitorConfig;
+import com.alibaba.dubbo.config.ProtocolConfig;
+import com.alibaba.dubbo.config.ProviderConfig;
+import com.alibaba.dubbo.config.RegistryConfig;
+import com.alibaba.dubbo.config.ServiceConfig;
 import com.alibaba.dubbo.config.annotation.Service;
 import com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory;
+
 import org.springframework.beans.factory.BeanFactoryUtils;
 import org.springframework.beans.factory.BeanNameAware;
 import org.springframework.beans.factory.DisposableBean;
@@ -255,7 +262,9 @@ && getInterface() != null && getInterface().length() > 0
     }
 
     public void destroy() throws Exception {
-        unexport();
+        // This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.
+        // We will guarantee dubbo related resources being released with dubbo shutdown hook.
+        //unexport();
     }
 
 }
\ No newline at end of file
@@ -21,6 +21,8 @@
 import com.alibaba.dubbo.common.extension.ExtensionLoader;
 import com.alibaba.dubbo.common.logger.Logger;
 import com.alibaba.dubbo.common.logger.LoggerFactory;
+import com.alibaba.dubbo.common.utils.ConfigUtils;
+import com.alibaba.dubbo.common.utils.NamedThreadFactory;
 import com.alibaba.dubbo.common.utils.StringUtils;
 import com.alibaba.dubbo.common.utils.UrlUtils;
 import com.alibaba.dubbo.registry.NotifyListener;
@@ -42,6 +44,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
 import static com.alibaba.dubbo.common.Constants.ACCEPT_FOREIGN_IP;
 import static com.alibaba.dubbo.common.Constants.QOS_ENABLE;
@@ -147,30 +151,7 @@ public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcExceptio
         overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
         registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
         //Ensure that a new exporter instance is returned every time export
-        return new Exporter<T>() {
-            public Invoker<T> getInvoker() {
-                return exporter.getInvoker();
-            }
-
-            public void unexport() {
-                try {
-                    exporter.unexport();
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-                try {
-                    registry.unregister(registedProviderUrl);
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-                try {
-                    overrideListeners.remove(overrideSubscribeUrl);
-                    registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-            }
-        };
+        return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);
     }
 
     @SuppressWarnings(""unchecked"")
@@ -471,4 +452,56 @@ public void unexport() {
             exporter.unexport();
         }
     }
+
+    static private class DestroyableExporter<T> implements Exporter<T> {
+
+        public static final ExecutorService executor = Executors.newSingleThreadExecutor(new NamedThreadFactory(""Exporter-Unexport"", true));
+
+        private Exporter<T> exporter;
+        private Invoker<T> originInvoker;
+        private URL subscribeUrl;
+        private URL registerUrl;
+
+        public DestroyableExporter(Exporter<T> exporter, Invoker<T> originInvoker, URL subscribeUrl, URL registerUrl) {
+            this.exporter = exporter;
+            this.originInvoker = originInvoker;
+            this.subscribeUrl = subscribeUrl;
+            this.registerUrl = registerUrl;
+        }
+
+        public Invoker<T> getInvoker() {
+            return exporter.getInvoker();
+        }
+
+        public void unexport() {
+            Registry registry = RegistryProtocol.INSTANCE.getRegistry(originInvoker);
+            try {
+                registry.unregister(registerUrl);
+            } catch (Throwable t) {
+                logger.warn(t.getMessage(), t);
+            }
+            try {
+                NotifyListener listener = RegistryProtocol.INSTANCE.overrideListeners.remove(subscribeUrl);
+                registry.unsubscribe(subscribeUrl, listener);
+            } catch (Throwable t) {
+                logger.warn(t.getMessage(), t);
+            }
+
+            executor.submit(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        int timeout = ConfigUtils.getServerShutdownTimeout();
+                        if (timeout > 0) {
+                            logger.info(""Waiting "" + timeout + ""ms for registry to notify all consumers before unexport. Usually, this is called when you use dubbo API"");
+                            Thread.sleep(timeout);
+                        }
+                        exporter.unexport();
+                    } catch (Throwable t) {
+                        logger.warn(t.getMessage(), t);
+                    }
+                }
+            });
+        }
+    }
 }
\ No newline at end of file
@@ -113,7 +113,9 @@ public void testNotifyOverride() throws Exception {
         assertEquals(""y"", exporter.getInvoker().getUrl().getParameter(""x""));
 
         exporter.unexport();
-        assertEquals(false, exporter.getInvoker().isAvailable());
+//        int timeout = ConfigUtils.getServerShutdownTimeout();
+//        Thread.sleep(timeout + 1000);
+//        assertEquals(false, exporter.getInvoker().isAvailable());
         destroyRegistryProtocol();
 
     }
",True,"The commit message refers to the necessity of changes by mentioning the removal of shutdown logic from spring bean destroy to avoid competition. This is likely a reference to a known issue or problem that the change is addressing, which adds to the explanation of the commit.",True,The commit message 'Remove the shutdown logic from spring bean destroy to avoid competition' clearly explains the necessity of the changes. The code diff shows that the shutdown logic was removed from the spring bean destroy method to prevent potential competition during the shutdown process. This is a common practice to ensure proper resource release and avoid conflicts.,False,"The commit message does not explicitly describe the necessity of changes or the motivation behind the code change. It only mentions removing the shutdown logic from spring bean destroy to avoid competition, but it does not elaborate on the problem or issue that this change is addressing.",True,"The commit message 'Remove the shutdown logic from spring bean destroy to avoid competition' indicates that the developer removed the shutdown logic from the spring bean destroy method to avoid potential competition or race conditions. This could be due to a problem in the software maintenance process, such as outdated code or a runtime environment change, that caused issues with the shutdown logic.",True,The commit message 'Remove the shutdown logic from spring bean destroy to avoid competition' indicates that the change was made to address a potential issue with resource competition during the shutdown process. This suggests that the change is likely an improvement or a fix to the code.,True,"The commit message 'Remove the shutdown logic from spring bean destroy to avoid competition' accurately describes the change made in the code diff. The diff shows the removal of the shutdown logic from the spring bean destroy method, which is in line with the commit message. This change is likely to prevent competition or conflicts during the shutdown process.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions the removal of shutdown logic from spring bean destroy to avoid competition, but it does not explain why this is necessary or what principle it is based on.",True,"The commit message 'Remove the shutdown logic from spring bean destroy to avoid competition' describes a change in the codebase that removes the shutdown logic from the spring bean destroy method. This change is likely to prevent potential conflicts or race conditions that could occur during the shutdown process. While the code diff doesn't explicitly introduce new behaviors, it does modify existing behavior by removing a part of the shutdown process. Therefore, the commit message effectively summarizes the changes from a functional perspective.",False,"The commit message explains the reason for the change, which is to avoid competition during the shutdown logic from spring bean destroy. This is not something that can be easily inferred from the code diff alone."
https://github.com/junit-team/junit4/commit/87245d66c7a17b27478da3bf7030e1b2dc86da55,Added script for uploading docs ,https://api.github.com/repos/junit-team/junit4/commits/87245d66c7a17b27478da3bf7030e1b2dc86da55,"@@ -124,5 +124,6 @@
 			<fileset dir=""${dist}"" includes=""*.jar"" />
 			<fileset file=""${zipfile}"" />
 		</ftp>
+		<echo message=""To upload docs, use build/upload_docs.sh"" />
 	</target>
 </project>
@@ -0,0 +1 @@
+scp -r ../doc/* dsaff@shell.sourceforge.net:/home/groups/j/ju/junit/htdocs/doc
\ No newline at end of file
",False,"The commit message does not explicitly reference any conventions, standards, improvements in prior commits, or implemented features that necessitate the changes. It simply states that a script for uploading docs has been added, but it does not explain why this change is necessary or beneficial.",True,The commit message 'Added script for uploading docs' clearly describes the purpose of the changes made in the code diff. The diff shows the addition of a script for uploading documentation and an echo message that instructs users on how to use the script. This is a common practice in software development and the necessity of the changes is easily inferred from the commit message and the code diff.,False,The commit message does not explicitly describe the necessity of changes or the motivation behind the code change. It only states that a script for uploading docs has been added. The diff does not reveal any errors or shortcomings in the previous implementation that would necessitate this change.,True,"The commit message 'Added script for uploading docs' indicates that the developer added a new script to upload documentation. This could be a requirement from users or a problem in the software maintenance process, as the documentation might be out of date or not easily accessible.",False,"The commit message 'Added script for uploading docs' does not directly mention any defects it fixes or improvements it makes to the code. It only describes the addition of a new script for uploading documents. The code diff shows the addition of a script for uploading docs, but it does not indicate any changes to existing code or fixes to any known issues.",True,"The commit message 'Added script for uploading docs' does describe a summary of the changes made in the diff. The diff shows the addition of a new script for uploading documents, which is exactly what the commit message summarizes.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It simply states that a script for uploading docs has been added, but it does not explain why this change was made, what problem it solves, or what principle it follows.",True,"The commit message 'Added script for uploading docs' accurately summarizes the changes made in the code diff. The diff shows the addition of a new script (build/upload_docs.sh) and an echo message that instructs users to use this script for uploading docs. This change introduces a new behavior in the project, which is the ability to upload documentation using a script.",True,"The commit message 'Added script for uploading docs' is sufficient to explain the change, as the code diff clearly shows that a new script for uploading documentation has been added. The script is also mentioned in the commit message. The change is not trivial, as it involves adding a new script, but it is relatively simple and straightforward. Therefore, a more detailed explanation of the reason for the commit may not be necessary."
https://github.com/junit-team/junit4/commit/4cb9a65f450efa5f2a42128856c7b56e6d283386,"Fixed a bug in Theories classes with constructor parameters, where the method parameters and constructor parameters were switched ",https://api.github.com/repos/junit-team/junit4/commits/4cb9a65f450efa5f2a42128856c7b56e6d283386,"@@ -9,7 +9,7 @@ private Version() {
 	}
 
 	public static String id() {
-		return ""4.5-SNAPSHOT-20070904-1400"";
+		return ""4.5-SNAPSHOT-20071012-1919"";
 	}
 	
 	public static void main(String[] args) {
@@ -8,7 +8,6 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.List;
 
 
@@ -23,7 +22,7 @@ public static ArrayList<ParameterSignature> signatures(Method method) {
 	}
 
 
-	public static Collection<? extends ParameterSignature> signatures(
+	public static List<ParameterSignature> signatures(
 			Constructor<?> constructor) {
 		// TODO: (Oct 12, 2007 12:33:06 PM) handle DUP above
 		ArrayList<ParameterSignature> sigs= new ArrayList<ParameterSignature>();
@@ -93,12 +93,60 @@ protected void collectInitializationErrors(
 						// do nothing
 					}
 					
+					@Override
+					public Statement chain(TestMethod method) {
+						// TODO: (Oct 12, 2007 2:00:52 PM) Name this Link
+						final Statement link= super.chain(method);
+						return new Statement() {
+						
+							@Override
+							public void evaluate() throws Throwable {
+								try {
+									link.evaluate();
+									successes++;
+								} catch (AssumptionViolatedException e) {
+									// TODO: (Oct 12, 2007 2:07:01 PM) DUP? even correct?
+									// do nothing
+								} catch (Throwable e) {
+									 // TODO: (Oct 12, 2007 2:04:01 PM) nullsOk as argument to Assignments constructor
+
+										reportParameterizedError(e, complete.getAllArguments(nullsOk()));
+									}
+								// TODO Auto-generated method stub
+						
+							}
+						
+						};
+					}
+					
 					@Override
 					protected Statement invoke(TestMethod method, Object test) {
 						// TODO: (Oct 12, 2007 12:07:28 PM) push method in
 						return methodCompletesWithParameters(complete, test);
 					}
 					
+					@Override
+					protected Statement ignoreViolatedAssumptions(final Statement next) {
+						// TODO: (Oct 12, 2007 2:15:02 PM) name this
+
+						return new Statement() {
+						
+							@Override
+							public void evaluate() throws Throwable {
+								try {
+									next.evaluate();						
+								} catch (AssumptionViolatedException e) {
+									// TODO: (Oct 12, 2007 2:19:52 PM) This feels hacky
+
+									successes--;
+									handleAssumptionViolation(e);
+									// TODO: (Oct 12, 2007 2:15:44 PM) Can I remove other calls?
+
+								}
+							}
+						};
+					}
+					
 					@Override
 					public Object createTest() throws Exception {
 						// TODO: (Oct 12, 2007 12:31:12 PM) DUP
@@ -132,14 +180,11 @@ public void evaluate() throws Throwable {
 		private void invokeWithActualParameters(Object target,
 				Assignments complete) throws Throwable {
 			final Object[] values= complete.getMethodArguments(nullsOk(), target);
-			try {
+//			try {
 				fTestMethod.invokeExplosively(target, values);
-				successes++;
-			} catch (AssumptionViolatedException e) {
-				handleAssumptionViolation(e);
-			} catch (Throwable e) {
-				reportParameterizedError(e, values);
-			}
+//			} catch (AssumptionViolatedException e) {
+//				handleAssumptionViolation(e);
+//			}
 		}
 
 		protected void handleAssumptionViolation(AssumptionViolatedException e) {
@@ -32,8 +32,8 @@ public Assignments(List<PotentialAssignment> assigned,
 
 	public static Assignments allUnassigned(Method testMethod,
 			Class<?> testClass) {
-		ArrayList<ParameterSignature> signatures= ParameterSignature.signatures(testMethod);
-		signatures.addAll(ParameterSignature.signatures(testClass.getConstructors()[0]));
+		List<ParameterSignature> signatures= ParameterSignature.signatures(testClass.getConstructors()[0]);
+		signatures.addAll(ParameterSignature.signatures(testMethod));
 		return new Assignments(new ArrayList<PotentialAssignment>(),
 				signatures, testClass);
 	}
@@ -57,9 +57,10 @@ public Assignments assignNext(PotentialAssignment source) {
 	public Object[] getActualValues(boolean nullsOk, int start, int stop) throws CouldNotGenerateValueException {
 		Object[] values= new Object[stop - start];
 		for (int i= start; i < stop; i++) {
-			values[i]= fAssigned.get(i).getValue();
-			if (values[i] == null && !nullsOk)
+			Object value= fAssigned.get(i).getValue();
+			if (value == null && !nullsOk)
 				throw new CouldNotGenerateValueException();
+			values[i - start]= value;
 		}
 		return values;
 	}
@@ -110,4 +111,8 @@ public Object[] getMethodArguments(boolean nullsOk, Object target) throws CouldN
 		return getActualValues(nullsOk, getOnlyConstructor()
 				.getParameterTypes().length, fAssigned.size());
 	}
+
+	public Object[] getAllArguments(boolean nullsOk) throws CouldNotGenerateValueException {
+		return getActualValues(nullsOk, 0, fAssigned.size());
+	}
 }
\ No newline at end of file
@@ -8,7 +8,6 @@
 import org.junit.internal.runners.model.MultipleFailureException;
 import org.junit.internal.runners.model.TestElement;
 import org.junit.internal.runners.model.TestMethod;
-import org.junit.runner.notification.StoppedByUserException;
 
 public class RunAfters extends Statement {
 	private final Statement fNext;
@@ -28,8 +27,6 @@ public void evaluate() throws Throwable {
 		MultipleFailureException errors= new MultipleFailureException();
 		try {
 			fNext.evaluate();
-		} catch (StoppedByUserException e) {
-			throw e; // TODO this is ugly. if we can eliminate pleaseStop(), we can remove it
 		} catch (Throwable e) {
 			errors.add(e);
 		} finally {
@@ -8,9 +8,12 @@ public class MultipleFailureException extends Exception {
 	
 	private List<Throwable> fErrors = new ArrayList<Throwable>();
 	
-	public void assertEmpty() throws MultipleFailureException {
-		if (!fErrors.isEmpty())
-			throw this;
+	public void assertEmpty() throws Throwable {
+		if (fErrors.isEmpty())
+			return;
+		if (fErrors.size() == 1)
+			throw fErrors.get(0);
+		throw this;
 	}
 
 	public void add(Throwable e) {
@@ -13,7 +13,7 @@ public void runBefores(Object target) throws Throwable {
 				before.invokeExplosively(target);
 	}
 
-	public void runAfters(Object target) throws MultipleFailureException {
+	public void runAfters(Object target) throws Throwable {
 		MultipleFailureException errors= new MultipleFailureException();
 		
 		List<TestMethod> afters= getAfters();
@@ -12,13 +12,15 @@
 import org.junit.tests.experimental.theories.runner.WithDataPointFields;
 import org.junit.tests.experimental.theories.runner.WithDataPointMethod;
 import org.junit.tests.experimental.theories.runner.WithExtendedParameterSources;
+import org.junit.tests.experimental.theories.runner.WithOnlyTestAnnotations;
 
 @RunWith(Suite.class)
 @SuiteClasses( { ParameterizedAssertionErrorTest.class,
 		WithDataPointFields.class, PrintableResultTest.class,
 		ResultMatchersTest.class, WithDataPointMethod.class,
 		ParameterSignatureTest.class, WhenNoParametersMatch.class,
-		WithExtendedParameterSources.class, StubbedTheoriesTest.class })
+		WithExtendedParameterSources.class, StubbedTheoriesTest.class, 
+		WithOnlyTestAnnotations.class })
 public class ExperimentalTests {
 
 }
@@ -222,4 +222,53 @@ public void haveAPostiveSquare() {
 	public void honorConstructorAssumptions() {
 		assertThat(testResult(PositiveIntsWithNegativeField.class), isSuccessful());
 	}
+	
+	@RunWith(Theories.class)
+	public static class PositiveIntsWithMethodParams {
+		@DataPoint
+		public static final int ONE= 1;
+
+		private int x;
+
+		public PositiveIntsWithMethodParams(int x) {
+			assumeTrue(x > 0);
+			this.x= x;
+		}
+
+		@Theory
+		public void haveAPostiveSquare(int y) {
+			assumeTrue(y > 0);
+			assertTrue(x * y > 0);
+		}
+	}
+	
+	// TODO: (Oct 12, 2007 2:26:22 PM) Just run enclosed?
+
+	
+	@Test public void passParametersToBothConstructorAndMethod() {
+		assertThat(testResult(PositiveIntsWithMethodParams.class), isSuccessful());	
+	}
+	
+	@RunWith(Theories.class)
+	public static class DifferentTypesInConstructor {
+		@DataPoint
+		public static final int ONE= 1;
+
+		@DataPoint public static final String A = ""A"";
+		
+		public DifferentTypesInConstructor(int x) {
+		}
+
+		@Theory
+		public void yesIndeed(String a) {
+		}
+	}
+	
+	
+	@Test public void differentTypesForConstructorAndMethodOk() {
+		assertThat(testResult(DifferentTypesInConstructor.class), isSuccessful());	
+	}
+	
+	// TODO: (Oct 12, 2007 2:24:55 PM) Complex
+
 }
\ No newline at end of file
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertThat;
 import static org.junit.experimental.results.PrintableResult.testResult;
 import static org.junit.experimental.results.ResultMatchers.failureCountIs;
+import static org.junit.experimental.results.ResultMatchers.isSuccessful;
 import org.junit.Test;
 import org.junit.experimental.theories.Theories;
 import org.junit.runner.RunWith;
@@ -22,6 +23,19 @@ public void honorExpected() throws Exception {
 		assertThat(testResult(HonorExpectedException.class).getFailures()
 				.size(), is(1));
 	}
+	
+	@RunWith(Theories.class)
+	public static class HonorExpectedExceptionPasses {
+		@Test(expected= NullPointerException.class)
+		public void shouldThrow() {
+			throw new NullPointerException();
+		}
+	}
+
+	@Test
+	public void honorExpectedPassing() throws Exception {
+		assertThat(testResult(HonorExpectedExceptionPasses.class), isSuccessful());
+	}
 
 	@RunWith(Theories.class)
 	public static class HonorTimeout {
",True,"The commit message refers to the necessity of changes by mentioning a bug in Theories classes with constructor parameters. The bug was that the method parameters and constructor parameters were switched, which is explained in the code diff. The commit message does not explicitly reference conventions, standards, or improvements in prior commits, but it does implicitly reference the correct order of parameters, which could be considered a standard or convention.",True,"The commit message 'Fixed a bug in Theories classes with constructor parameters, where the method parameters and constructor parameters were switched' clearly explains the necessity of the changes. The code diff shows that the method signatures for the constructor and the method were incorrectly swapped, causing a bug. The commit message provides a clear explanation of the issue and the fix, making it easy to infer the necessity of the changes.",True,"The commit message 'Fixed a bug in Theories classes with constructor parameters, where the method parameters and constructor parameters were switched' directly elaborates the motivation of the code change by describing the error scenario where the method parameters and constructor parameters were incorrectly switched.",True,"The commit message 'Fixed a bug in Theories classes with constructor parameters, where the method parameters and constructor parameters were switched' indicates that the developer made changes to address a problem in the software maintenance process. The problem was that the method parameters and constructor parameters were incorrectly switched, which could have caused runtime errors or incorrect behavior. The changes made in the commit message are necessary to fix this problem and ensure that the software functions correctly.",True,"The commit message 'Fixed a bug in Theories classes with constructor parameters, where the method parameters and constructor parameters were switched' directly mentions the issue that was fixed, which is the incorrect order of method parameters and constructor parameters in Theories classes.",True,"The commit message 'Fixed a bug in Theories classes with constructor parameters, where the method parameters and constructor parameters were switched' accurately describes the change made in the code diff. The diff shows that the return type of the signatures method was changed from Collection to List, and the order of the parameters in the method call was switched. This change was made to fix a bug where the method parameters and constructor parameters were incorrectly ordered.",True,"The commit message explains that the bug was caused by a mistake in the order of method parameters and constructor parameters in the Theories classes. This indicates that the technical principle underpinning the changes is the correct usage of method and constructor parameters in Java, which is a fundamental concept in object-oriented programming.",True,"The commit message 'Fixed a bug in Theories classes with constructor parameters, where the method parameters and constructor parameters were switched' describes the code changes from a functional perspective. The code diff shows that the method signatures for constructors and methods have been switched, which is likely to have caused a bug. Additionally, the diff shows that new methods have been added to the RunAfters and MultipleFailureException classes, which suggests that new behaviors have been introduced to handle exceptions in a different way.",False,"The commit message explains the reason for the change clearly, stating that a bug was fixed in the Theories classes due to a mistake where the method parameters and constructor parameters were switched. The code diff also supports this explanation, showing changes in the constructor and method signatures. Therefore, the commit message does not lack an explanation."
https://github.com/junit-team/junit4/commit/9ee381470d56efa800420e5e22721e402aca01c2,"Remove fast-tests maven target.  <enter> Many of our tests store data in static fields, so the tests cannot be run in parallel. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/junit-team/junit4/commits/9ee381470d56efa800420e5e22721e402aca01c2,"@@ -558,19 +558,5 @@
                 </plugins>
             </reporting>
         </profile>
-        <profile>
-            <id>fast-tests</id>
-            <build>
-                <plugins>
-                    <plugin>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <parallel>classes</parallel>
-                            <threadCountClasses>2</threadCountClasses>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
     </profiles>
 </project>
",True,"The commit message explains the necessity of changes by referencing a problem with the existing setup. It mentions that 'many of our tests store data in static fields, so the tests cannot be run in parallel'. This is a common issue that can lead to incorrect test results and slower test execution. The commit message also refers to the removal of the 'fast-tests' maven target, which was likely configured to run tests in parallel. By removing this target, the commit ensures that tests are run sequentially, addressing the issue mentioned in the commit message.",True,"The commit message 'Remove fast-tests maven target' clearly explains the reason for the change. It states that 'Many of our tests store data in static fields, so the tests cannot be run in parallel.' This is a common reason for removing parallel test execution, making the necessity of the change clear without the need for further explanation.",True,"The commit message directly elaborates the motivation of the code change by mentioning that 'many of our tests store data in static fields, so the tests cannot be run in parallel.' This clearly explains a shortcoming of the previous implementation and the need for the change. Additionally, the message mentions that it 'fixes' a specific issue, which could be an issue report or a bug tracking system reference.",True,"The commit message 'Remove fast-tests maven target' and the code diff indicate that the changes were made due to the need for software development. The message mentions that 'many of our tests store data in static fields, so the tests cannot be run in parallel'. This suggests that the changes were made to improve the efficiency or functionality of the software, likely in response to user requirements or problems in the software maintenance process.",True,"The commit message directly mentions the issue it fixes by stating 'Many of our tests store data in static fields, so the tests cannot be run in parallel.' This clearly indicates that the change is being made to improve the code by addressing a specific problem.",True,"The commit message 'Remove fast-tests maven target' accurately summarizes the change made in the diff. It clearly states that a section of the code, specifically the 'fast-tests' profile, has been removed. This is a direct reflection of the changes made in the diff, which shows the deletion of the 'fast-tests' profile. The message also provides context about why the change was made, mentioning that the tests cannot be run in parallel due to static fields. This adds to the understanding of the change.",True,"The commit message explains the technical principle underpinning the changes by stating that 'many of our tests store data in static fields, so the tests cannot be run in parallel'. This is a common issue in test suites and the commit message correctly identifies it as the reason for removing the fast-tests maven target, which was configured to run tests in parallel.",True,"The commit message 'Remove fast-tests maven target' describes the code change by explaining that it removes a section of the code that was used to run tests in parallel. This change was made because the tests stored data in static fields, which prevented them from being run in parallel. This change does not introduce new behaviors, but it does modify existing behavior by changing how the tests are run.",False,The commit message does not lack an explanation. It clearly states the reason for the commit: 'Remove fast-tests maven target.' This is because the tests cannot be run in parallel due to the use of static fields. The code diff also supports this explanation by removing the configuration for parallel test execution.
https://github.com/square/retrofit/commit/580d31ae906ac28f608427d4c4d2318a0e8b658a,Rename main class to Retrofit. ,https://api.github.com/repos/square/retrofit/commits/580d31ae906ac28f608427d4c4d2318a0e8b658a,"@@ -47,12 +47,12 @@ interface Service {
   private Service service;
 
   @Before public void setUp() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .callAdapterFactory(ObservableCallAdapterFactory.create())
         .build();
-    service = ra.create(Service.class);
+    service = retrofit.create(Service.class);
   }
 
   @Test public void bodySuccess200() {
@@ -4,11 +4,11 @@ Retrofit Converters
 Retrofit ships with a default converter for JSON that uses Gson but the library is content-format
 agnostic. The child modules contained herein are additional converters for other popular formats.
 
-To use, supply an instance of your desired converter when building your `RestAdapter` instance.
+To use, supply an instance of your desired converter when building your `Retrofit` instance.
 
 ```java
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setEndpoint(""https://api.example.com"")
-    .setConverter(new ProtoConverter())
+Retrofit retrofit = new Retrofit.Builder()
+    .endpoint(""https://api.example.com"")
+    .converter(new ProtoConverter())
     .build();
 ```
@@ -18,7 +18,7 @@
 /**
  * An exception used to trigger the simulation of an HTTP error for mock services.
  *
- * @see MockRestAdapter
+ * @see MockRetrofit
  */
 public class MockHttpException extends RuntimeException {
   /** Create a new {@link MockHttpException} for HTTP 301 Moved Permanently. */
@@ -38,15 +38,15 @@
  * </pre>
  * Given a {@link RestAdapter} an instance of this class can be created by calling {@link #from}.
  * <pre>
- *   MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
+ *   MockRetrofit mockRetrofit = MockRetrofit.from(restAdapter);
  * </pre>
  * Instances of this class should be used as a singleton so that the behavior of every mock service
  * is consistent.
  * <p>
  * Rather than using the {@code MockUserService} directly, pass it through
  * {@link #create(Class, Object) the create method}.
  * <pre>
- *   UserService service = mockRestAdapter.create(UserService.class, new MockUserService());
+ *   UserService service = mockRetrofit.create(UserService.class, new MockUserService());
  * </pre>
  * The returned {@code UserService} instance will now behave like it is happening over the network
  * while allowing the mock implementation to be written synchronously.
@@ -55,18 +55,18 @@
  * {@link MockHttpException}. This should be done for both synchronous and asynchronous methods.
  * Do not call the {@link Callback#failure(RetrofitError) failure()} method of a callback.
  */
-public final class MockRestAdapter {
+public final class MockRetrofit {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PCT = 40; // Network delay varies by ±40%.
   private static final int DEFAULT_ERROR_PCT = 3; // 3% of network calls will fail.
   private static final int ERROR_DELAY_FACTOR = 3; // Network errors will be scaled by this value.
 
   /**
-   * Create a new {@link MockRestAdapter} which will act as a factory for mock services. Some of
+   * Create a new {@link MockRetrofit} which will act as a factory for mock services. Some of
    * the configuration of the supplied {@link RestAdapter} will be used generating mock behavior.
    */
-  public static MockRestAdapter from(RestAdapter restAdapter, Executor executor) {
-    return new MockRestAdapter(restAdapter, executor);
+  public static MockRetrofit from(RestAdapter restAdapter, Executor executor) {
+    return new MockRetrofit(restAdapter, executor);
   }
 
   private final RestAdapter restAdapter;
@@ -77,7 +77,7 @@ public static MockRestAdapter from(RestAdapter restAdapter, Executor executor) {
   private int variancePct = DEFAULT_VARIANCE_PCT;
   private int errorPct = DEFAULT_ERROR_PCT;
 
-  private MockRestAdapter(RestAdapter restAdapter, Executor executor) {
+  private MockRetrofit(RestAdapter restAdapter, Executor executor) {
     this.restAdapter = restAdapter;
     this.executor = executor;
   }
@@ -27,7 +27,7 @@
 import static org.mockito.Mockito.verifyZeroInteractions;
 import static retrofit.Utils.SynchronousExecutor;
 
-public class MockRestAdapterTest {
+public class MockRetrofitTest {
   interface SyncExample {
     @GET(""/"") Object doStuff();
   }
@@ -48,7 +48,7 @@ interface ObservableExample {
 
   private Executor httpExecutor;
   private Executor callbackExecutor;
-  private MockRestAdapter mockRestAdapter;
+  private MockRetrofit mockRetrofit;
   private Throwable nextError;
 
   @Before public void setUp() throws IOException {
@@ -70,21 +70,21 @@ interface ObservableExample {
         })
         .build();
 
-    mockRestAdapter = MockRestAdapter.from(restAdapter, httpExecutor);
+    mockRetrofit = MockRetrofit.from(restAdapter, httpExecutor);
 
     // Seed the random with a value so the tests are deterministic.
-    mockRestAdapter.random.setSeed(2847);
+    mockRetrofit.random.setSeed(2847);
   }
 
   @Test public void delayRestrictsRange() {
     try {
-      mockRestAdapter.setDelay(-1);
+      mockRetrofit.setDelay(-1);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Delay must be positive value."");
     }
     try {
-      mockRestAdapter.setDelay(Long.MAX_VALUE);
+      mockRetrofit.setDelay(Long.MAX_VALUE);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageStartingWith(""Delay value too large."");
@@ -93,13 +93,13 @@ interface ObservableExample {
 
   @Test public void varianceRestrictsRange() {
     try {
-      mockRestAdapter.setVariancePercentage(-13);
+      mockRetrofit.setVariancePercentage(-13);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Variance percentage must be between 0 and 100."");
     }
     try {
-      mockRestAdapter.setVariancePercentage(174);
+      mockRetrofit.setVariancePercentage(174);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Variance percentage must be between 0 and 100."");
@@ -108,48 +108,48 @@ interface ObservableExample {
 
   @Test public void errorRestrictsRange() {
     try {
-      mockRestAdapter.setErrorPercentage(-13);
+      mockRetrofit.setErrorPercentage(-13);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Error percentage must be between 0 and 100."");
     }
     try {
-      mockRestAdapter.setErrorPercentage(174);
+      mockRetrofit.setErrorPercentage(174);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Error percentage must be between 0 and 100."");
     }
   }
 
   @Test public void errorPercentageIsAccurate() {
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setErrorPercentage(0);
     for (int i = 0; i < 10000; i++) {
-      assertThat(mockRestAdapter.calculateIsFailure()).isFalse();
+      assertThat(mockRetrofit.calculateIsFailure()).isFalse();
     }
 
-    mockRestAdapter.setErrorPercentage(3);
+    mockRetrofit.setErrorPercentage(3);
     int failures = 0;
     for (int i = 0; i < 100000; i++) {
-      if (mockRestAdapter.calculateIsFailure()) {
+      if (mockRetrofit.calculateIsFailure()) {
         failures += 1;
       }
     }
     assertThat(failures).isEqualTo(2964); // ~3% of 100k
   }
 
   @Test public void delayVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
+    mockRetrofit.setDelay(2000);
 
-    mockRestAdapter.setVariancePercentage(0);
+    mockRetrofit.setVariancePercentage(0);
     for (int i = 0; i < 100000; i++) {
-      assertThat(mockRestAdapter.calculateDelayForCall()).isEqualTo(2000);
+      assertThat(mockRetrofit.calculateDelayForCall()).isEqualTo(2000);
     }
 
-    mockRestAdapter.setVariancePercentage(40);
+    mockRetrofit.setVariancePercentage(40);
     int lowerBound = Integer.MAX_VALUE;
     int upperBound = Integer.MIN_VALUE;
     for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForCall();
+      int delay = mockRetrofit.calculateDelayForCall();
       if (delay > upperBound) {
         upperBound = delay;
       }
@@ -162,12 +162,12 @@ interface ObservableExample {
   }
 
   @Test public void errorVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
+    mockRetrofit.setDelay(2000);
 
     int lowerBound = Integer.MAX_VALUE;
     int upperBound = Integer.MIN_VALUE;
     for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForError();
+      int delay = mockRetrofit.calculateDelayForError();
       if (delay > upperBound) {
         upperBound = delay;
       }
@@ -180,16 +180,16 @@ interface ObservableExample {
   }
 
   @Test public void syncFailureTriggersNetworkError() {
-    mockRestAdapter.setErrorPercentage(100);
-    mockRestAdapter.setDelay(1);
+    mockRetrofit.setErrorPercentage(100);
+    mockRetrofit.setDelay(1);
 
     class MockSyncExample implements SyncExample {
       @Override public Object doStuff() {
         throw new AssertionError();
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     try {
       mockService.doStuff();
@@ -201,16 +201,16 @@ class MockSyncExample implements SyncExample {
   }
 
   @Test public void asyncFailureTriggersNetworkError() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setErrorPercentage(100);
+    mockRetrofit.setDelay(1);
+    mockRetrofit.setErrorPercentage(100);
 
     class MockAsyncExample implements AsyncExample {
       @Override public void doStuff(Callback<String> cb) {
         throw new AssertionError();
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
     mockService.doStuff(new Callback<String>() {
@@ -232,9 +232,9 @@ class MockAsyncExample implements AsyncExample {
   }
 
   @Test public void syncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     final AtomicBoolean called = new AtomicBoolean();
     final Object expected = new Object();
@@ -245,7 +245,7 @@ class MockSyncExample implements SyncExample {
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     long startNanos = System.nanoTime();
     Object actual = mockService.doStuff();
@@ -257,9 +257,9 @@ class MockSyncExample implements SyncExample {
   }
 
   @Test public void asyncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Hi"");
@@ -270,7 +270,7 @@ class MockAsyncExample implements AsyncExample {
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -294,9 +294,9 @@ class MockAsyncExample implements AsyncExample {
   }
 
   @Test public void observableApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Hello"");
@@ -308,7 +308,7 @@ class MockObservableExample implements ObservableExample {
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -336,9 +336,9 @@ class MockObservableExample implements ObservableExample {
 
 
   @Test public void syncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Hello"");
@@ -349,7 +349,7 @@ class MockSyncExample implements SyncExample {
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     long startNanos = System.nanoTime();
     try {
@@ -367,9 +367,9 @@ class MockSyncExample implements SyncExample {
   }
 
   @Test public void asyncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Greetings"");
@@ -380,7 +380,7 @@ class MockAsyncExample implements AsyncExample {
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -409,9 +409,9 @@ class MockAsyncExample implements AsyncExample {
   }
 
   @Test public void observableHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings(""RedundantStringConstructorCall"") // Allocated on-heap.
     final String expected = new String(""Hi"");
@@ -423,7 +423,7 @@ class MockObservableExample implements ObservableExample {
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -453,9 +453,9 @@ class MockObservableExample implements ObservableExample {
   }
 
   @Test public void nullBodyIsAllowedOnHttpException() throws Exception {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
       @Override public Observable<String> doStuff() {
@@ -464,7 +464,7 @@ class MockObservableExample implements ObservableExample {
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -494,17 +494,17 @@ class MockObservableExample implements ObservableExample {
   }
 
   @Test public void syncErrorUsesErrorHandler() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockSyncExample implements SyncExample {
       @Override public Object doStuff() {
         throw MockHttpException.newNotFound(new Object());
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
     nextError = new IllegalArgumentException(""Test"");
 
     try {
@@ -516,17 +516,17 @@ class MockSyncExample implements SyncExample {
   }
 
   @Test public void asyncErrorUsesErrorHandler() throws InterruptedException {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockAsyncExample implements AsyncExample {
       @Override public void doStuff(Callback<String> cb) {
         throw MockHttpException.newNotFound(new Object());
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
     nextError = new IllegalArgumentException(""Test"");
 
     final CountDownLatch latch = new CountDownLatch(1);
@@ -544,9 +544,9 @@ class MockAsyncExample implements AsyncExample {
   }
 
   @Test public void observableErrorUsesErrorHandler() throws InterruptedException {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
       @Override public Observable<String> doStuff() {
@@ -555,7 +555,7 @@ class MockObservableExample implements ObservableExample {
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
     nextError = new IllegalArgumentException(""Test"");
 
     final CountDownLatch latch = new CountDownLatch(1);
@@ -573,9 +573,9 @@ class MockObservableExample implements ObservableExample {
   }
 
   @Test public void asyncCanUseCallbackSubtype() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(1);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockAsyncCallbackSubtypeExample implements AsyncCallbackSubtypeExample {
       @Override public void doStuff(Foo foo) {
@@ -584,7 +584,7 @@ class MockAsyncCallbackSubtypeExample implements AsyncCallbackSubtypeExample {
     }
 
     AsyncCallbackSubtypeExample mockService =
-        mockRestAdapter.create(AsyncCallbackSubtypeExample.class,
+        mockRetrofit.create(AsyncCallbackSubtypeExample.class,
             new MockAsyncCallbackSubtypeExample());
 
     final AtomicReference<String> actual = new AtomicReference<>();
@@ -19,7 +19,7 @@
  * Communicates responses from a server or offline requests. One and only one method will be
  * invoked in response to a given request.
  * <p>
- * Callback methods are executed using the {@link RestAdapter} callback executor. When none is
+ * Callback methods are executed using the {@link Retrofit} callback executor. When none is
  * specified, the following defaults are used:
  * <ul>
  * <li>Android: Callbacks are executed on the application's main (UI) thread.</li>
@@ -233,7 +233,7 @@ private void parseResponseType() {
       throw methodError(""Method response type is ""
           + responseType
           + "" but no converter registered. ""
-          + ""Either add a converter to the RestAdapter or use ResponseBody."");
+          + ""Either add a converter to the Retrofit instance or use ResponseBody."");
     }
 
     this.adapter = adapter;
@@ -295,7 +295,7 @@ private void parseParameters() {
               throw parameterError(i, ""@Part parameter is ""
                   + methodParameterType
                   + "" but no converter registered. ""
-                  + ""Either add a converter to the RestAdapter or use RequestBody."");
+                  + ""Either add a converter to the Retrofit instance or use RequestBody."");
             }
 
             gotPart = true;
@@ -321,7 +321,7 @@ private void parseParameters() {
               throw parameterError(i, ""@Body parameter is ""
                   + methodParameterType
                   + "" but no converter registered. ""
-                  + ""Either add a converter to the RestAdapter or use RequestBody."");
+                  + ""Either add a converter to the Retrofit instance or use RequestBody."");
             }
 
             requestType = methodParameterType;
@@ -84,14 +84,14 @@
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
  */
-public final class RestAdapter {
+public final class Retrofit {
   private final Map<Method, MethodInfo> methodInfoCache = new LinkedHashMap<>();
   private final OkHttpClient client;
   private final Endpoint endpoint;
   private final Converter converter;
   private final CallAdapter.Factory adapterFactory;
 
-  private RestAdapter(OkHttpClient client, Endpoint endpoint, Converter converter,
+  private Retrofit(OkHttpClient client, Endpoint endpoint, Converter converter,
       CallAdapter.Factory adapterFactory) {
     this.client = client;
     this.endpoint = endpoint;
@@ -160,7 +160,7 @@ public CallAdapter.Factory callAdapterFactory() {
   }
 
   /**
-   * Build a new {@link RestAdapter}.
+   * Build a new {@link Retrofit}.
    * <p>
    * Calling {@link #endpoint} is required before calling {@link #build()}. All other methods
    * are optional.
@@ -202,8 +202,8 @@ public Builder callAdapterFactory(CallAdapter.Factory adapterFactory) {
       return this;
     }
 
-    /** Create the {@link RestAdapter} instances. */
-    public RestAdapter build() {
+    /** Create the {@link Retrofit} instances. */
+    public Retrofit build() {
       checkNotNull(endpoint, ""Endpoint required."");
 
       // Set any platform-appropriate defaults for unspecified components.
@@ -214,7 +214,7 @@ public RestAdapter build() {
         adapterFactory = Platform.get().defaultCallAdapterFactory();
       }
 
-      return new RestAdapter(client, endpoint, converter, adapterFactory);
+      return new Retrofit(client, endpoint, converter, adapterFactory);
     }
   }
 }
@@ -19,14 +19,15 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import retrofit.Converter;
+import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
- * body). The object will be serialized using the {@link retrofit.RestAdapter RestAdapter}'s
+ * body). The object will be serialized using the {@link Retrofit Retrofit} instance
  * {@link Converter Converter} and the result will be set directly as the
  * request body.
  * <p>
@@ -46,11 +46,11 @@ interface Service {
   }
 
   @Test public void http200Sync() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -60,11 +60,11 @@ interface Service {
   }
 
   @Test public void http200Async() throws InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -88,11 +88,11 @@ interface Service {
   }
 
   @Test public void http404Sync() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
@@ -103,11 +103,11 @@ interface Service {
   }
 
   @Test public void http404Async() throws InterruptedException, IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setResponseCode(404).setBody(""Hi""));
 
@@ -132,11 +132,11 @@ interface Service {
   }
 
   @Test public void transportProblemSync() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
 
@@ -149,11 +149,11 @@ interface Service {
   }
 
   @Test public void transportProblemAsync() throws InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
 
@@ -176,15 +176,15 @@ interface Service {
   }
 
   @Test public void conversionProblemOutgoingSync() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter() {
           @Override public RequestBody toBody(Object object, Type type) {
             throw new UnsupportedOperationException(""I am broken!"");
           }
         })
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     Call<String> call = example.postMethod(""Hi"");
     try {
@@ -196,15 +196,15 @@ interface Service {
   }
 
   @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter() {
           @Override public RequestBody toBody(Object object, Type type) {
             throw new UnsupportedOperationException(""I am broken!"");
           }
         })
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
@@ -225,15 +225,15 @@ interface Service {
   }
 
   @Test public void conversionProblemIncomingSync() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter() {
           @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
             throw new UnsupportedOperationException(""I am broken!"");
           }
         })
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -247,15 +247,15 @@ interface Service {
   }
 
   @Test public void conversionProblemIncomingAsync() throws InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter() {
           @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
             throw new UnsupportedOperationException(""I am broken!"");
           }
         })
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -279,11 +279,11 @@ interface Service {
 
   @Test public void http204SkipsConverter() throws IOException {
     Converter converter = spy(new StringConverter());
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(converter)
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setStatus(""HTTP/1.1 204 Nothin""));
 
@@ -295,11 +295,11 @@ interface Service {
 
   @Test public void http205SkipsConverter() throws IOException {
     Converter converter = spy(new StringConverter());
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(converter)
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setStatus(""HTTP/1.1 205 Nothin""));
 
@@ -310,11 +310,11 @@ interface Service {
   }
 
   @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Service example = ra.create(Service.class);
+    Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody(""Hi"").removeHeader(""Content-Type""));
 
@@ -23,7 +23,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-public final class RestAdapterTest {
+public final class RetrofitTest {
   @Rule public final MockWebServerRule server = new MockWebServerRule();
 
   interface CallMethod {
@@ -50,33 +50,33 @@ interface Unresolvable {
 
   @SuppressWarnings(""EqualsBetweenInconvertibleTypes"") // We are explicitly testing this behavior.
   @Test public void objectMethodsStillWork() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
 
     assertThat(example.hashCode()).isNotZero();
     assertThat(example.equals(this)).isFalse();
     assertThat(example.toString()).isNotEmpty();
   }
 
   @Test public void interfaceWithExtendIsNotSupported() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
     try {
-      ra.create(Extending.class);
+      retrofit.create(Extending.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(""Interface definitions must not extend other interfaces."");
     }
   }
 
   @Test public void callReturnTypeAdapterAddedByDefault() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
     assertThat(example.allowed()).isNotNull();
   }
 
@@ -102,11 +102,11 @@ class MyCallAdapterFactory implements CallAdapter.Factory {
       }
     }
 
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .callAdapterFactory(new MyCallAdapterFactory())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
     assertThat(example.allowed()).isNotNull();
     assertThat(factoryCalled.get()).isTrue();
     assertThat(adapterCalled.get()).isTrue();
@@ -130,20 +130,20 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
       }
     }
 
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .callAdapterFactory(new GreetingCallAdapterFactory())
         .build();
-    StringService example = ra.create(StringService.class);
+    StringService example = retrofit.create(StringService.class);
     assertThat(example.get()).isEqualTo(""Hi!"");
   }
 
   @Test public void customReturnTypeAdapterMissingThrows() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    FutureMethod example = ra.create(FutureMethod.class);
+    FutureMethod example = retrofit.create(FutureMethod.class);
     try {
       example.method();
       fail();
@@ -153,25 +153,25 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
   }
 
   @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
     try {
       example.disallowed(""Hi!"");
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
           ""CallMethod.disallowed: @Body parameter is class java.lang.String but no converter registered. ""
-              + ""Either add a converter to the RestAdapter or use RequestBody. (parameter #1)"");
+              + ""Either add a converter to the Retrofit instance or use RequestBody. (parameter #1)"");
     }
   }
 
   @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -181,15 +181,15 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
           ""CallMethod.disallowed: Method response type is class java.lang.String but no converter registered. ""
-              + ""Either add a converter to the RestAdapter or use ResponseBody."");
+              + ""Either add a converter to the Retrofit instance or use ResponseBody."");
     }
   }
 
   @Test public void requestBodyOutgoingAllowed() throws IOException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -198,10 +198,10 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
   }
 
   @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .build();
-    CallMethod example = ra.create(CallMethod.class);
+    CallMethod example = retrofit.create(CallMethod.class);
 
     server.enqueue(new MockResponse().setBody(""Hi""));
 
@@ -213,11 +213,11 @@ class GreetingCallAdapterFactory implements CallAdapter.Factory {
   }
 
   @Test public void unresolvableTypeThrows() {
-    RestAdapter ra = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(server.getUrl(""/"").toString())
         .converter(new StringConverter())
         .build();
-    Unresolvable example = ra.create(Unresolvable.class);
+    Unresolvable example = retrofit.create(Unresolvable.class);
 
     try {
       example.typeVariable();
@@ -26,7 +26,7 @@
 import retrofit.CallAdapter;
 import retrofit.Callback;
 import retrofit.Response;
-import retrofit.RestAdapter;
+import retrofit.Retrofit;
 import retrofit.http.GET;
 
 /**
@@ -95,12 +95,12 @@ static class Ip {
   }
 
   public static void main(String... args) {
-    RestAdapter restAdapter = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(""http://httpbin.org"")
         .callAdapterFactory(new ListenableFutureCallAdapterFactory())
         .build();
 
-    HttpBinService service = restAdapter.create(HttpBinService.class);
+    HttpBinService service = retrofit.create(HttpBinService.class);
     final ListenableFuture<Ip> ip = service.getIp();
     ip.addListener(new Runnable() {
       @Override public void run() {
@@ -18,7 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import retrofit.Call;
-import retrofit.RestAdapter;
+import retrofit.Retrofit;
 import retrofit.http.GET;
 import retrofit.http.Path;
 
@@ -44,12 +44,12 @@ Call<List<Contributor>> contributors(
 
   public static void main(String... args) throws IOException {
     // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(API_URL)
         .build();
 
     // Create an instance of our GitHub API interface.
-    GitHub github = restAdapter.create(GitHub.class);
+    GitHub github = retrofit.create(GitHub.class);
 
     // Create a call instance for looking up Retrofit contributors.
     Call<List<Contributor>> call = github.contributors(""square"", ""retrofit"");
@@ -9,11 +9,11 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executors;
-import retrofit.MockRestAdapter;
-import retrofit.RestAdapter;
+import retrofit.MockRetrofit;
+import retrofit.Retrofit;
 
 /**
- * An example of using {@link MockRestAdapter} to create a mock service implementation with
+ * An example of using {@link MockRetrofit} to create a mock service implementation with
  * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
  */
 public final class SimpleMockService {
@@ -61,18 +61,17 @@ public void addContributor(String owner, String repo, String name, int contribut
 
   public static void main(String... args) {
     // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
+    Retrofit retrofit = new Retrofit.Builder()
         .endpoint(SimpleService.API_URL)
         .build();
 
     // Wrap our REST adapter to allow mock implementations and fake network delay.
-    MockRestAdapter mockRestAdapter =
-        MockRestAdapter.from(restAdapter, Executors.newSingleThreadExecutor());
+    MockRetrofit mockRetrofit = MockRetrofit.from(retrofit, Executors.newSingleThreadExecutor());
 
     // Instantiate a mock object so we can interact with it later.
     MockGitHub mockGitHub = new MockGitHub();
     // Use the mock REST adapter and our mock object to create the API interface.
-    GitHub gitHub = mockRestAdapter.create(GitHub.class, mockGitHub);
+    GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
     // Query for some contributors for a few repositories.
     printContributors(gitHub, ""square"", ""retrofit"");
@@ -48,12 +48,12 @@ <h3 id=""introduction"">Introduction</h3>
   @GET(""/users/{user}/repos"")
   List&lt;Repo> listRepos(@Path(""user"") String user);
 }</pre>
-            <p>The <code>RestAdapter</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-            <pre class=""prettyprint"">RestAdapter restAdapter = new RestAdapter.Builder()
+            <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+            <pre class=""prettyprint"">Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint(""https://api.github.com"")
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
             <p>Each call on the generated <code>GitHubService</code> makes an HTTP request to the remote webserver.</p>
             <pre class=""prettyprint"">List&lt;Repo> repos = service.listRepos(""octocat"");</pre>
             <p>Use annotations to describe the HTTP request:</p>
@@ -88,7 +88,7 @@ <h4>Request Body</h4>
             <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
             <pre class=""prettyprint"">@POST(""/users/new"")
 void createUser(@Body User user, Callback&lt;User> cb);</pre>
-            <p>The object will also be converted using the <code>RestAdapter</code>'s converter.</p>
+            <p>The object will also be converted using the <code>Retrofit</code>'s converter.</p>
 
             <h4>Form Encoded and Multipart</h4>
             <p>Methods can also be declared to send form-encoded and multipart data.</p>
@@ -100,7 +100,7 @@ <h4>Form Encoded and Multipart</h4>
             <pre class=""prettyprint"">@Multipart
 @PUT(""/user/photo"")
 User updateUser(@Part(""photo"") TypedFile photo, @Part(""description"") TypedString description);</pre>
-            <p>Multipart parts use the <code>RestAdapter</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
+            <p>Multipart parts use the <code>Retrofit</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
 
             <h4>Header Manipulation</h4>
             <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
@@ -125,7 +125,7 @@ <h4>Header Manipulation</h4>
   }
 };
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
   .setEndpoint(""https://api.github.com"")
   .setRequestInterceptor(requestInterceptor)
   .build();</pre>
@@ -146,7 +146,7 @@ <h4>Synchronous vs. Asynchronous vs. Observable</h4>
             <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
 
             <h4>Response Object Type</h4>
-            <p>HTTP responses are automatically converted to a specified type using the <code>RestAdapter</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
+            <p>HTTP responses are automatically converted to a specified type using the <code>Retrofit</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
             <pre class=""prettyprint"">@GET(""/users/list"")
 List&lt;User> userList();
 
@@ -165,11 +165,11 @@ <h4>Response Object Type</h4>
 @GET(""/users/list"")
 Observable&lt;Response> userList();</pre>
 
-            <h3 id=""restadapter-configuration"">RestAdapter Configuration</h3>
-            <p><code>RestAdapter</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+            <h3 id=""restadapter-configuration"">Retrofit Configuration</h3>
+            <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
 
             <h4>JSON Conversion</h4>
-            <p>Retrofit uses <a href=""https://code.google.com/p/google-gson/"">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>RestAdapter</code>. Refer to the <a href=""https://sites.google.com/site/gson/gson-user-guide"">Gson documentation</a> for more details on customization.</p>
+            <p>Retrofit uses <a href=""https://code.google.com/p/google-gson/"">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>Retrofit</code>. Refer to the <a href=""https://sites.google.com/site/gson/gson-user-guide"">Gson documentation</a> for more details on customization.</p>
             <h4>Custom Gson Converter Example</h4>
             <p>The following code creates a new <code>Gson</code> instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the <code>Date</code> class. This <code>DateTypeAdapter</code> will be used anytime Gson encounters a <code>Date</code> field.</p>
             <p>The <code>gson</code> instance is passed as a parameter to <code>GsonConverter</code>, which is a wrapper class for converting types.</p>
@@ -178,22 +178,22 @@ <h4>Custom Gson Converter Example</h4>
     .registerTypeAdapter(Date.class, new DateTypeAdapter())
     .create();
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint(""https://api.github.com"")
     .setConverter(new GsonConverter(gson))
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>RestAdapter</code>.</p>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
+            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>Retrofit</code>.</p>
             <h4>Content format Agnostic</h4>
             <p>In addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using <a href=""http://simple.sourceforge.net/"">Simple</a>) and Protocol Buffers (using <a href=""https://code.google.com/p/protobuf/"">protobuf</a> or <a href=""https://github.com/square/wire"">Wire</a>). Please see the <a href=""https://github.com/square/retrofit/tree/master/retrofit-converters"">retrofit-converters</a> directory for the full listing of converters.</p>
             <p>The following code shows how to use <code>SimpleXMLConverter</code> to communicate with an API that uses XML</p>
-            <pre class=""prettyprint"">RestAdapter restAdapter = new RestAdapter.Builder()
+            <pre class=""prettyprint"">Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint(""https://api.soundcloud.com"")
     .setConverter(new SimpleXMLConverter())
     .build();
 
-SoundCloudService service = restAdapter.create(SoundCloudService.class);</pre>
+SoundCloudService service = retrofit.create(SoundCloudService.class);</pre>
             <h4>Custom Converters</h4>
             <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href=""https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java""><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
             <h4>Custom Error Handling</h4>
@@ -209,21 +209,21 @@ <h4>Custom Error Handling</h4>
   }
 }
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint(""https://api.github.com"")
     .setErrorHandler(new MyErrorHandler())
     .build();</pre>
             <p>Note that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied <code>RetrofitError</code> as the cause to any new exceptions you throw.</p>
 
             <h4>Logging</h4>
-            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>RestAdapter</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
+            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>Retrofit</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
             <p>The following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.</p>
             <pre class=""prettyprint"">
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setLogLevel(RestAdapter.LogLevel.FULL)
+Retrofit retrofit = new Retrofit.Builder()
+    .setLogLevel(Retrofit.LogLevel.FULL)
     .setEndpoint(""https://api.github.com"")
     .build();</pre>
-            <p>This logging can be added or changed at any point in the <code>RestAdapter</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
+            <p>This logging can be added or changed at any point in the <code>Retrofit</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
 
             <h3 id=""download"">Download</h3>
             <p><a href=""https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST"" class=""dl version-href"">&darr; <span class=""version-tag"">Latest</span> JAR</a></p>
@@ -286,7 +286,7 @@ <h3 id=""license"">License</h3>
               <ul class=""nav nav-tabs nav-stacked primary"">
                 <li><a href=""#introduction"">Introduction</a></li>
                 <li><a href=""#api-declaration"">API Declaration</a></li>
-                <li><a href=""#restadapter-configuration"">RestAdapter Configuration</a></li>
+                <li><a href=""#restadapter-configuration"">Retrofit Configuration</a></li>
                 <li><a href=""#download"">Download</a></li>
                 <li><a href=""#contributing"">Contributing</a></li>
                 <li><a href=""#license"">License</a></li>
",True,The commit message refers to the renaming of the main class from 'RestAdapter' to 'Retrofit'. This change is mentioned in the code diff and is likely done to better reflect the library's functionality and to avoid confusion with other libraries or frameworks that also use 'RestAdapter'.,True,"The commit message 'Rename main class to Retrofit' clearly indicates a refactoring change, as it is changing the name of a major component in the codebase. This change does not require a detailed explanation as it is a common practice in software development and the necessity is easily inferred from the context.",False,"The commit message does not explicitly describe the necessity of changes by directly elaborating the motivation of a code change like describing the error scenario, mentioning the issue report, or the shortcoming of the previous implementation.",True,"The commit message 'Rename main class to Retrofit' indicates that the developer is updating the codebase to use a new library or framework called Retrofit, which is replacing the previous library or framework used in the codebase. This change is likely being made to take advantage of new features or improvements offered by Retrofit, or to address issues or limitations in the previous library or framework. Without more context, it is not possible to determine the specific reasons for the change.",True,The commit message 'Rename main class to Retrofit' indicates that the objective of the change is to improve the code by renaming a class to better reflect its purpose or functionality.,True,"The commit message 'Rename main class to Retrofit' accurately describes the change made in the code diff. The diff shows that the main class has been renamed from 'RestAdapter' to 'Retrofit', which is reflected in the commit message.",True,"The commit message 'Rename main class to Retrofit' indicates that the technical principle underpinning the changes is the refactoring of the main class from 'RestAdapter' to 'Retrofit'. This suggests that the changes are likely related to the renaming of the main class and its associated methods, interfaces, and dependencies, which could potentially involve a change in the overall architecture or design of the project.",True,"The commit message 'Rename main class to Retrofit' indicates a significant change in the codebase, specifically the renaming of a main class. This change is reflected in the code diff provided, where the class 'RestAdapter' is renamed to 'Retrofit'. The message also describes the new behavior introduced by this change, which is the use of the 'Retrofit' class instead of 'RestAdapter' for building and configuring the API client. Therefore, the commit message accurately summarizes the changes made to the codebase and describes the new behaviors introduced.",True,"The commit message 'Rename main class to Retrofit' clearly explains the reason for the change, which is to rename the main class from 'RestAdapter' to 'Retrofit'. This change is not trivial and requires updating all references to the class name. Therefore, a clear explanation in the commit message is necessary to communicate the change to other developers."
https://github.com/junit-team/junit4/commit/467c3f8efe1a87e3029df282e4df60ad98bc4142,Deprecate Assert#assertThat  <enter> The method 'assertThat' is used for writing assertions with Hamcrest. Hamcrest is an independent assertion library and contains an own 'assertThat' method in the class 'org.hamcrest.MatcherAssert'. It is available both in the old Hamcrest 1.3 release and in the current Hamcrest 2.1. Therefore the JUnit team recommends to use Hamcrest's own 'assertThat' directly. ,https://api.github.com/repos/junit-team/junit4/commits/467c3f8efe1a87e3029df282e4df60ad98bc4142,"@@ -923,8 +923,9 @@ public static void assertEquals(Object[] expecteds, Object[] actuals) {
      * @param matcher an expression, built of {@link Matcher}s, specifying allowed
      * values
      * @see org.hamcrest.CoreMatchers
-     * @see org.hamcrest.MatcherAssert
+     * @deprecated use {@code org.hamcrest.MatcherAssert.assertThat()}
      */
+    @Deprecated
     public static <T> void assertThat(T actual, Matcher<? super T> matcher) {
         assertThat("""", actual, matcher);
     }
@@ -955,8 +956,9 @@ public static <T> void assertThat(T actual, Matcher<? super T> matcher) {
      * @param matcher an expression, built of {@link Matcher}s, specifying allowed
      * values
      * @see org.hamcrest.CoreMatchers
-     * @see org.hamcrest.MatcherAssert
+     * @deprecated use {@code org.hamcrest.MatcherAssert.assertThat()}
      */
+    @Deprecated
     public static <T> void assertThat(String reason, T actual,
             Matcher<? super T> matcher) {
         MatcherAssert.assertThat(reason, actual, matcher);
",True,"The commit message refers to the JUnit team's recommendation to use Hamcrest's own 'assertThat' method directly, which is a standard or convention. This explains why the commit is deprecating the existing 'assertThat' method in favor of the one from Hamcrest's 'MatcherAssert' class.",True,"The commit message explains the necessity of changes by providing a rationale. It states that the method 'assertThat' is used for writing assertions with Hamcrest, and the JUnit team recommends using Hamcrest's own 'assertThat' directly. This is because Hamcrest's 'assertThat' is available in both the old and current versions of the library, and using it directly avoids the need for the deprecated method in JUnit.",True,"The commit message explains the motivation for the code change by mentioning that the method 'assertThat' is used for writing assertions with Hamcrest, and the JUnit team recommends using Hamcrest's own 'assertThat' directly. This is because Hamcrest is an independent assertion library and contains its own 'assertThat' method, which is available in both the old Hamcrest 1.3 release and the current Hamcrest 2.1. By deprecating the JUnit's 'assertThat' method, the commit message is indicating that this change is necessary to avoid confusion and potential errors that could arise from using two different 'assertThat' methods.",True,"The commit message indicates that the changes are being made due to a recommendation from the JUnit team. The message mentions that Hamcrest, an independent assertion library, also contains its own 'assertThat' method, and the JUnit team recommends using Hamcrest's 'assertThat' directly. This suggests that the changes are being made to align with a new standard or to improve the maintainability of the codebase, which can be considered a source of requirements.",True,"The commit message directly mentions the objective of the change by stating that it is deprecating the 'assertThat' method. This is done to recommend using Hamcrest's own 'assertThat' method directly, which is a clear improvement to the code.",True,The commit message accurately summarizes the changes made in the code diff. It clearly states that the 'assertThat' method is being deprecated and that the JUnit team recommends using Hamcrest's own 'assertThat' method directly. This is also reflected in the code diff where the '@Deprecated' annotation is added to the 'assertThat' methods and a comment is added to suggest using 'org.hamcrest.MatcherAssert.assertThat()' instead.,True,The commit message explains that the 'assertThat' method is being deprecated because it is available in the Hamcrest library itself. This is based on the principle of 'prefer using the library's own functionality' to reduce redundancy and potential conflicts.,True,"The commit message expresses that the 'assertThat' method is being deprecated and suggests using Hamcrest's own 'assertThat' method directly. This change is reflected in the code diff, where the 'assertThat' method is marked as deprecated and the commit message suggests using 'org.hamcrest.MatcherAssert.assertThat()' instead. This change introduces new behavior by encouraging the use of a different 'assertThat' method, which aligns with the JUnit team's recommendation.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit, which is to deprecate the Assert#assertThat method. The reason is explained in detail, mentioning that Hamcrest is an independent assertion library with its own 'assertThat' method, and the JUnit team recommends using it directly. The code diff also supports this explanation by adding a deprecation warning and the @Deprecated annotation to the method."
https://github.com/apache/dubbo/commit/9ca9bb04b926ba33c6755aff8373314e60f2be89,Fix typo <issue_link> ,https://api.github.com/repos/apache/dubbo/commits/9ca9bb04b926ba33c6755aff8373314e60f2be89,"@@ -304,7 +304,7 @@ private void init() {
         appendParameters(map, module);
         appendParameters(map, consumer, Constants.DEFAULT_KEY);
         appendParameters(map, this);
-        String prifix = StringUtils.getServiceKey(map);
+        String prefix = StringUtils.getServiceKey(map);
         if (methods != null && methods.size() > 0) {
             for (MethodConfig method : methods) {
                 appendParameters(map, method, method.getName());
@@ -315,7 +315,7 @@ private void init() {
                         map.put(method.getName() + "".retries"", ""0"");
                     }
                 }
-                appendAttributes(attributes, method, prifix + ""."" + method.getName());
+                appendAttributes(attributes, method, prefix + ""."" + method.getName());
                 checkAndConvertImplicitConfig(method, map, attributes);
             }
         }
@@ -473,7 +473,7 @@ public void setInterface(Class<?> interfaceClass) {
             throw new IllegalStateException(""The interface class "" + interfaceClass + "" is not a interface!"");
         }
         this.interfaceClass = interfaceClass;
-        setInterface(interfaceClass == null ? (String) null : interfaceClass.getName());
+        setInterface(interfaceClass == null ? null : interfaceClass.getName());
     }
 
     public void setInterface(String interfaceName) {
",False,"The commit message only mentions a typo fix, but it does not reference any conventions, standards, improvements in prior commits, or implemented features.",True,"The commit message 'Fix typo' clearly indicates a small, non-functional change in the code. The diff shows that the typo 'prifix' has been corrected to 'prefix'. This is a common change that doesn't require a detailed explanation in the commit message.",False,"The commit message 'Fix typo <issue_link>' does not directly elaborate the motivation of the code change. It only mentions a typo fix without explaining the error scenario, issue report, or shortcoming of the previous implementation.",True,"The commit message 'Fix typo' indicates that there was a mistake in the code that needed to be corrected. The typo 'prifix' was changed to 'prefix', which suggests that the code was not functioning as intended due to the typo. This can be considered a problem in the process of software maintenance, as outdated or incorrect code can lead to bugs and issues.",False,"The commit message 'Fix typo' does not directly mention the defects it fixes or the improvements it makes to the code. It only mentions a typo, but the code diff shows that the change is not just a typo fix, it's also a variable name change from 'prifix' to 'prefix'. However, the commit message does not explain this change.",True,The commit message 'Fix typo' does describe a summary of the changes in the diff. The key component of the change is the correction of a typo from 'prifix' to 'prefix' in the method calls and variable declarations.,False,"The commit message only mentions fixing a typo, but it does not explain any technical principle underpinning the changes. The code diff shows a change from 'prifix' to 'prefix', which is a simple typo fix and does not demonstrate any significant technical principle.",False,"The commit message 'Fix typo' does not describe the code changes from a functional perspective or introduce new behaviors. It only mentions a typo fix, but the code diff shows a variable renaming from 'prifix' to 'prefix' and some modifications to method calls. However, the message does not explain what these changes mean or how they affect the functionality of the code.",True,"The commit message 'Fix typo' clearly indicates that the change was made to correct a typographical error. The code diff shows that the variable 'prifix' was changed to 'prefix'. This is a small and simple change that can easily be inferred from the diff, so there was no need for an additional explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/3d437711363ade1717a7e11b7b781d240bad4983,"Register an AuthenticationManager in security autoconfig  <enter> This is quite a big step, but I think it helps a lot. Since Spring Boot always creates an AuthenticationManager if it doesn't find one already registered, it makes sense to also make it into a  @bean . Spring Security does not register its AuthenticationManager by default though, so we have to do that for it if the user has created one with an  @Autowired  AuthenticationManagerBuilder, but not registered it as a  @bean . <enter> Having the  @bean  (marked  @primary  to prevent issues with  @Autowired ) makes it easier to reason about what Spring Boot has done for you, and easier to default in simple use cases to the boot-created AuthenticationManager. For example, if I want an OAuth2 Authorization Server with password grant, it makes total sense for the AuthenticationManager for users to be the same as the  @primary  one. Now it is easy to set that up (just  @autowire  it). ",https://api.github.com/repos/spring-projects/spring-boot/commits/3d437711363ade1717a7e11b7b781d240bad4983,"@@ -40,10 +40,19 @@ public abstract class SpringBootCondition implements Condition {
 	@Override
 	public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
 		String classOrMethodName = getClassOrMethodName(metadata);
-		ConditionOutcome outcome = getMatchOutcome(context, metadata);
-		logOutcome(classOrMethodName, outcome);
-		recordEvaluation(context, classOrMethodName, outcome);
-		return outcome.isMatch();
+		try {
+			ConditionOutcome outcome = getMatchOutcome(context, metadata);
+			logOutcome(classOrMethodName, outcome);
+			recordEvaluation(context, classOrMethodName, outcome);
+			return outcome.isMatch();
+		}
+		catch (NoClassDefFoundError e) {
+			throw new IllegalStateException(
+					""Could not evaluate condition owing to internal class not found. ""
+							+ ""This can happen if you are @ComponentScanning a springframework package ""
+							+ ""(e.g. if you put a @ComponentScan in the default package by mistake)"",
+					e);
+		}
 	}
 
 	private static String getClassOrMethodName(AnnotatedTypeMetadata metadata) {
@@ -26,7 +26,12 @@
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.security.SecurityProperties.User;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Lazy;
+import org.springframework.context.annotation.Primary;
+import org.springframework.context.annotation.Scope;
+import org.springframework.context.annotation.ScopedProxyMode;
 import org.springframework.core.Ordered;
 import org.springframework.core.annotation.Order;
 import org.springframework.security.authentication.AuthenticationManager;
@@ -60,9 +65,25 @@ public class AuthenticationManagerConfiguration extends
 	@Autowired
 	private SecurityProperties security;
 
+	private BootDefaultingAuthenticationConfigurerAdapter configurer = new BootDefaultingAuthenticationConfigurerAdapter();
+
 	@Override
 	public void init(AuthenticationManagerBuilder auth) throws Exception {
-		auth.apply(new BootDefaultingAuthenticationConfigurerAdapter());
+		auth.apply(this.configurer);
+	}
+
+	@Bean
+	// avoid issues with scopedTarget (SPR-11548)
+	@Primary
+	public AuthenticationManager authenticationManager() {
+		return lazyAuthenticationManager();
+	}
+
+	@Bean
+	@Lazy
+	@Scope(proxyMode = ScopedProxyMode.INTERFACES)
+	protected AuthenticationManager lazyAuthenticationManager() {
+		return this.configurer.getAuthenticationManagerBuilder().getOrBuild();
 	}
 
 	/**
@@ -92,9 +113,16 @@ public void init(AuthenticationManagerBuilder auth) throws Exception {
 	private class BootDefaultingAuthenticationConfigurerAdapter extends
 			GlobalAuthenticationConfigurerAdapter {
 
+		private AuthenticationManagerBuilder defaultAuth;
+
+		public AuthenticationManagerBuilder getAuthenticationManagerBuilder() {
+			return this.defaultAuth;
+		}
+
 		@Override
 		public void configure(AuthenticationManagerBuilder auth) throws Exception {
 			if (auth.isConfigured()) {
+				this.defaultAuth = auth;
 				return;
 			}
 
@@ -104,12 +132,12 @@ public void configure(AuthenticationManagerBuilder auth) throws Exception {
 						+ user.getPassword() + ""\n\n"");
 			}
 
-			AuthenticationManagerBuilder defaultAuth = new AuthenticationManagerBuilder(
+			this.defaultAuth = new AuthenticationManagerBuilder(
 					AuthenticationManagerConfiguration.this.objectPostProcessor);
 
 			Set<String> roles = new LinkedHashSet<String>(user.getRole());
 
-			AuthenticationManager parent = defaultAuth.inMemoryAuthentication()
+			AuthenticationManager parent = this.defaultAuth.inMemoryAuthentication()
 					.withUser(user.getName()).password(user.getPassword())
 					.roles(roles.toArray(new String[roles.size()])).and().and().build();
 
@@ -19,15 +19,11 @@
 import java.util.List;
 
 import org.junit.Test;
-import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
 import org.springframework.boot.autoconfigure.TestAutoConfigurationPackage;
 import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
-import org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer;
 import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
 import org.springframework.boot.autoconfigure.orm.jpa.test.City;
-import org.springframework.boot.context.event.ApplicationPreparedEvent;
-import org.springframework.boot.logging.LoggingApplicationListener;
 import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -60,7 +56,7 @@ public void testWebConfiguration() throws Exception {
 		this.context.setServletContext(new MockServletContext());
 		this.context.register(SecurityAutoConfiguration.class,
 				PropertyPlaceholderAutoConfiguration.class);
-		debugRefresh(this.context);
+		this.context.refresh();
 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class));
 		// 4 for static resources and one for the rest
 		List<SecurityFilterChain> filterChains = this.context.getBean(
@@ -93,6 +89,16 @@ public void testDisableBasicAuthOnApplicationPaths() throws Exception {
 		assertEquals(0, this.context.getBeanNamesForType(FilterChainProxy.class).length);
 	}
 
+	@Test
+	public void testAuthenticationManagerCreated() throws Exception {
+		this.context = new AnnotationConfigWebApplicationContext();
+		this.context.setServletContext(new MockServletContext());
+		this.context.register(SecurityAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
+		this.context.refresh();
+		assertNotNull(this.context.getBean(AuthenticationManager.class));
+	}
+
 	@Test
 	public void testOverrideAuthenticationManager() throws Exception {
 		this.context = new AnnotationConfigWebApplicationContext();
@@ -118,18 +124,6 @@ public void testJpaCoexistsHappily() throws Exception {
 		assertNotNull(this.context.getBean(JpaTransactionManager.class));
 	}
 
-	private static AnnotationConfigWebApplicationContext debugRefresh(
-			AnnotationConfigWebApplicationContext context) {
-		EnvironmentTestUtils.addEnvironment(context, ""debug:true"");
-		LoggingApplicationListener logging = new LoggingApplicationListener();
-		logging.onApplicationEvent(new ApplicationPreparedEvent(new SpringApplication(),
-				new String[0], context));
-		AutoConfigurationReportLoggingInitializer initializer = new AutoConfigurationReportLoggingInitializer();
-		initializer.initialize(context);
-		context.refresh();
-		return context;
-	}
-
 	@Configuration
 	@TestAutoConfigurationPackage(City.class)
 	protected static class EntityConfiguration {
",True,"The commit message refers to a convention in Spring Boot security, where it always creates an AuthenticationManager if it doesn't find one already registered. The commit message explains that this behavior can cause confusion, so it makes sense to register the AuthenticationManager as a @bean. This makes it easier to reason about what Spring Boot has done for you and easier to default in simple use cases to the boot-created AuthenticationManager.",True,"The commit message explains the necessity of changes by stating that 'Spring Boot always creates an AuthenticationManager if it doesn't find one already registered, it makes sense to also make it into a @bean.' This is because the commit is adding an AuthenticationManager as a @bean, which makes it easier to reason about what Spring Boot has done for you and easier to default in simple use cases to the boot-created AuthenticationManager. This is not a common sense or easy to infer change, as it involves modifying the configuration of the AuthenticationManager.",True,"The commit message explains the motivation for the change by mentioning that Spring Boot always creates an AuthenticationManager if it doesn't find one already registered. This can lead to confusion, so the commit message proposes to make it into a @bean. This makes it easier to reason about what Spring Boot has done for you and easier to default in simple use cases to the boot-created AuthenticationManager.",True,"The commit message indicates that the changes were made to address a requirement of users and to make it easier to reason about what Spring Boot has done for them. Specifically, the message mentions that the changes make it easier to default to the boot-created AuthenticationManager, which is beneficial for simple use cases such as setting up an OAuth2 Authorization Server with password grant. This suggests that the changes were made in response to user needs and requirements.",True,The commit message directly mentions the objective of the change by stating that it 'Registers an AuthenticationManager in security autoconfig'. This change is made to help Spring Boot create an AuthenticationManager if it doesn't find one already registered. The message also explains that this change makes it easier to reason about what Spring Boot has done for you and easier to default in simple use cases to the boot-created AuthenticationManager.,True,"The commit message does a good job of summarizing the changes. It mentions the registration of an AuthenticationManager in security autoconfig, which is a key component of the change. It also explains why this change is beneficial, mentioning that Spring Boot always creates an AuthenticationManager if it doesn't find one already registered, and that this change makes it easier to reason about what Spring Boot has done for you and easier to default in simple use cases to the boot-created AuthenticationManager. The message also contrasts the before and after state of the code, mentioning the addition of a try-catch block to handle NoClassDefFoundError and the creation of a new AuthenticationManager bean.",True,"The commit message explains that the technical principle underpinning the changes is the use of the @Bean annotation to make it easier to reason about what Spring Boot has done for you and to default in simple use cases to the boot-created AuthenticationManager. This is particularly relevant in the context of the code diff, which shows the addition of an @Bean-annotated method that returns an AuthenticationManager.",True,"The commit message expresses the introduction of a new bean for the AuthenticationManager and explains its purpose and benefits. It mentions that Spring Boot always creates an AuthenticationManager if it doesn't find one already registered, and that Spring Security does not register its AuthenticationManager by default. The commit message explains that the new bean is registered to make it easier to reason about what Spring Boot has done for you and to default in simple use cases to the boot-created AuthenticationManager. The code diff supports this explanation by showing the addition of the @Bean annotation for the AuthenticationManager, as well as the addition of the BootDefaultingAuthenticationConfigurerAdapter class and its methods for configuring the AuthenticationManager.",False,"The commit message does not lack an explanation. It explains the reason for the commit as it involves a significant change in the codebase. The commit registers an AuthenticationManager in security autoconfig, which is a big step. The message explains why this is beneficial, such as making it easier to reason about what Spring Boot has done for you and easier to default in simple use cases to the boot-created AuthenticationManager. Additionally, the message explains the changes made in the code diff, such as adding a try-catch block to handle NoClassDefFoundError and creating a new AuthenticationManager bean."
https://github.com/junit-team/junit4/commit/41092ce4e01cc57d8aa1911e2f1169e0f355b1ae,Move TestClassTest to package org.junit.runners.model.  <enter> It is common to add tests to the same package as the class under test. ,https://api.github.com/repos/junit-team/junit4/commits/41092ce4e01cc57d8aa1911e2f1169e0f355b1ae,"@@ -1,4 +1,4 @@
-package org.junit.tests.running.classes;
+package org.junit.runners.model;
 
 import static org.hamcrest.CoreMatchers.hasItem;
 import static org.hamcrest.CoreMatchers.is;
@@ -11,9 +11,6 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.rules.TestRule;
-import org.junit.runners.model.FrameworkField;
-import org.junit.runners.model.FrameworkMethod;
-import org.junit.runners.model.TestClass;
 
 public class TestClassTest {
 
@@ -17,6 +17,7 @@
 import org.junit.runners.Suite.SuiteClasses;
 import org.junit.runners.model.FrameworkFieldTest;
 import org.junit.runners.model.FrameworkMethodTest;
+import org.junit.runners.model.TestClassTest;
 import org.junit.tests.assertion.AssertionTest;
 import org.junit.tests.assertion.ComparisonFailureTest;
 import org.junit.tests.assertion.MultipleFailureExceptionTest;
@@ -85,7 +86,6 @@
 import org.junit.tests.running.classes.ParentRunnerTest;
 import org.junit.tests.running.classes.RunWithTest;
 import org.junit.tests.running.classes.SuiteTest;
-import org.junit.tests.running.classes.TestClassTest;
 import org.junit.tests.running.classes.UseSuiteAsASuperclassTest;
 import org.junit.tests.running.core.CommandLineTest;
 import org.junit.tests.running.core.JUnitCoreReturnsCorrectExitCodeTest;
",True,"The commit message refers to a convention regarding the location of tests, which explains why the commit moves the location of the test. The convention is to add tests to the same package as the class under test. This is mentioned in the commit message: 'It is common to add tests to the same package as the class under test.'",True,"The commit message 'Move TestClassTest to package org.junit.runners.model. It is common to add tests to the same package as the class under test.' describes the necessity of changes by explaining the rationale behind moving the test class to a different package. The explanation 'It is common to add tests to the same package as the class under test' clearly states the reason for the change, which is a common convention in software development.",False,"The commit message does not explicitly describe the necessity of changes. It only mentions that it is a common practice to add tests to the same package as the class under test, but it does not elaborate on any errors, issues, or shortcomings in the previous implementation that the change aims to address.",False,"The commit message does not explicitly describe the necessity of changes by referring to user requirements, problems in the process of software maintenance, or changes in the runtime or development environment. The message simply states that the TestClassTest class is being moved to a different package, which does not necessarily imply a need for the change.",False,The commit message does not explicitly mention the defects it fixes or the improvements it makes to the code. It only states that the TestClassTest is being moved to a different package. The code diff does not provide any clear indication of what the change aims to achieve.,True,"The commit message 'Move TestClassTest to package org.junit.runners.model' accurately summarizes the key component of the change, which is the relocation of the TestClassTest class from one package to another. This is a clear and concise summary of the change as reflected in the diff.",True,"The commit message explains the technical principle underpinning the changes by stating 'It is common to add tests to the same package as the class under test.' This principle is being applied in the code diff where the test class 'TestClassTest' is being moved to the same package as the class it is testing, which is 'org.junit.runners.model'.",True,"The commit message 'Move TestClassTest to package org.junit.runners.model' accurately summarizes the code change. It explains that the TestClassTest class is being moved to a new package, which is a significant change. This change could potentially introduce new behaviors if the new package has different dependencies or if the class relies on its new package location for functionality. However, based on the code diff provided, it's not clear whether any new behaviors are introduced. However, the message does imply that the test is now in the same package as the class under test, which could potentially affect the test's behavior.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'It is common to add tests to the same package as the class under test.' This reason is not easily inferred from the code diff, which only shows a change in the package declaration and some imports. The explanation in the commit message adds context and clarifies the intent behind the change."
https://github.com/square/retrofit/commit/704c484b56b0cf2d1f26f4315b3569c08e5cdc6a,Prepare version 2.8.1 ,https://api.github.com/repos/square/retrofit/commits/704c484b56b0cf2d1f26f4315b3569c08e5cdc6a,"@@ -1,6 +1,13 @@
 Change Log
 ==========
 
+Version 2.8.1 *(2020-03-25)*
+----------------------------
+
+ * Fix: Do not access `MethodHandles.Lookup` on Android API 24 and 25. The class is only available
+   on Android API 26 and higher.
+
+
 Version 2.8.0 *(2020-03-23)*
 ----------------------------
 
@@ -9,7 +9,7 @@ For more information please see [the website][1].
 Download
 --------
 
-Download [the latest JAR][2] or grab from Maven central at the coordinates `com.squareup.retrofit2:retrofit:2.8.0`.
+Download [the latest JAR][2] or grab from Maven central at the coordinates `com.squareup.retrofit2:retrofit:2.8.1`.
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
",True,"The commit message 'Prepare version 2.8.1' refers to the changes made in the code diff, which is a fix for a bug. The fix is necessary to address compatibility issues with Android API 24 and 25, as the class 'MethodHandles.Lookup' is only available on Android API 26 and higher. This commit message expresses the necessity of the changes by referencing a specific issue (compatibility with Android API 24 and 25) and the implemented fix.",True,"The commit message 'Prepare version 2.8.1' does not explicitly explain the necessity of the changes. However, the changes in the diff indicate a bug fix: 'Fix: Do not access `MethodHandles.Lookup` on Android API 24 and 25.' This is a clear indication that the changes are being made to address an issue, which is not easily inferrable from the commit message alone.",True,The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that the change is to 'Fix: Do not access `MethodHandles.Lookup` on Android API 24 and 25. The class is only available on Android API 26 and higher.' This clearly describes an error scenario where the previous implementation was causing issues on certain Android API versions due to the unavailability of the `MethodHandles.Lookup` class.,True,"The commit message 'Prepare version 2.8.1' and the code diff indicate that the changes were made to fix a problem. Specifically, the code diff shows that the developer added a fix for Android API 24 and 25, which are versions that do not have the `MethodHandles.Lookup` class. This suggests that the changes were made to address a compatibility issue, which can be considered a problem in the process of software maintenance.",True,"The commit message 'Prepare version 2.8.1' does contain an expression that describes the objective of the change. Specifically, it mentions the fix for a defect in the code: 'Fix: Do not access `MethodHandles.Lookup` on Android API 24 and 25. The class is only available on Android API 26 and higher.' This directly mentions the issue that the change is addressing and the improvement it makes to the code.",True,"The commit message 'Prepare version 2.8.1' does contain an expression that describes a summary of what changes by listing the key components of the change. Specifically, it mentions the version number and the fix for not accessing 'MethodHandles.Lookup' on Android API 24 and 25, which is not available on those versions. This is a clear and concise summary of the changes made in the diff.",True,"The commit message describes the technical principle underpinning the changes as it explains that the code is being modified to handle a compatibility issue with Android API 24 and 25. The change is to avoid accessing the `MethodHandles.Lookup` class, which is only available on Android API 26 and higher. This is a clear example of backward compatibility, which is a technical principle that ensures that new versions of software are still compatible with older versions.",True,"The commit message 'Prepare version 2.8.1' does contain an expression that describes a summary of what changes by explaining the code changes from a functional perspective. The code diff shows that a new version 2.8.1 is being prepared, and the changes made in this version are a fix for an issue where the `MethodHandles.Lookup` class was being accessed on Android API 24 and 25, which is not supported. This fix introduces new behavior that ensures the code does not attempt to access `MethodHandles.Lookup` on unsupported Android versions, thereby improving the stability and compatibility of the software.",False,"The commit message does not lack an explanation. It explicitly mentions that version 2.8.1 is being prepared and the change log for this version includes a fix for a specific issue. The issue is not immediately obvious from the code diff, as it involves changing a version number and modifying a changelog, but the commit message clearly explains that a fix has been made for Android API 24 and 25."
https://github.com/junit-team/junit4/commit/3e08f69912d69189e895c279b1bece0c7c0840f4,"Create a class TestWithParameters.  <enter> This class keeps the data together that are needed for creating a runner for a single data set of a parameterized test. This makes it also clear, that the computation of the name is not the responsibility of the runner but of the Parameterized class. ",https://api.github.com/repos/junit-team/junit4/commits/3e08f69912d69189e895c279b1bece0c7c0840f4,"@@ -18,6 +18,8 @@
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.Statement;
+import org.junit.runners.model.TestClass;
+import org.junit.runners.parameterized.TestWithParameters;
 
 /**
  * The custom runner <code>Parameterized</code> implements parameterized tests.
@@ -188,11 +190,21 @@ protected class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {
 
         private final String fName;
 
+        /**
+         * @deprecated please use
+         *             {@code TestClassRunnerForParameters(TestWithParameters)}
+         */
+        @Deprecated
         protected TestClassRunnerForParameters(Class<?> type, String pattern, int index, Object[] parameters) throws InitializationError {
-            super(type);
+            this(createTestWithParameters(new TestClass(type), pattern, index,
+                    parameters));
+        }
 
-            fParameters = parameters;
-            fName = nameFor(pattern, index, parameters);
+        protected TestClassRunnerForParameters(TestWithParameters test)
+                throws InitializationError {
+            super(test.getTestClass().getJavaClass());
+            fParameters = test.getParameters().toArray();
+            fName = test.getName();
         }
 
         @Override
@@ -231,12 +243,6 @@ private Object createTestUsingFieldInjection() throws Exception {
             return testClassInstance;
         }
 
-        protected String nameFor(String pattern, int index, Object[] parameters) {
-            String finalPattern = pattern.replaceAll(""\\{index\\}"", Integer.toString(index));
-            String name = MessageFormat.format(finalPattern, parameters);
-            return ""["" + name + ""]"";
-        }
-
         @Override
         protected String getName() {
             return fName;
@@ -319,11 +325,14 @@ private Runner createRunnerWithNotNormalizedParameters(String pattern,
             throws InitializationError {
         Object[] parameters= (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter
             : new Object[] { parametersOrSingleParameter };
-        return createRunner(pattern, index, parameters);
+        TestWithParameters test = createTestWithParameters(getTestClass(),
+                pattern, index, parameters);
+        return createRunnerForTest(test);
     }
 
-    protected Runner createRunner(String pattern, int index, Object[] parameters) throws InitializationError {
-        return new TestClassRunnerForParameters(getTestClass().getJavaClass(), pattern, index, parameters);
+    protected Runner createRunnerForTest(TestWithParameters test)
+            throws InitializationError {
+        return new TestClassRunnerForParameters(test);
     }
 
     @SuppressWarnings(""unchecked"")
@@ -381,4 +390,13 @@ private List<FrameworkField> getAnnotatedFieldsByParameter() {
     private boolean fieldsAreAnnotated() {
         return !getAnnotatedFieldsByParameter().isEmpty();
     }
-}
\ No newline at end of file
+
+    private static TestWithParameters createTestWithParameters(
+            TestClass testClass, String pattern, int index, Object[] parameters) {
+        String finalPattern = pattern.replaceAll(""\\{index\\}"",
+                Integer.toString(index));
+        String name = MessageFormat.format(finalPattern, parameters);
+        return new TestWithParameters(""["" + name + ""]"", testClass,
+                Arrays.asList(parameters));
+    }
+}
@@ -252,6 +252,26 @@ public boolean isANonStaticInnerClass() {
         return fClass.isMemberClass() && !isStatic(fClass.getModifiers());
     }
 
+    @Override
+    public int hashCode() {
+        return (fClass == null) ? 0 : fClass.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        TestClass other = (TestClass) obj;
+        return fClass == other.fClass;
+    }
+
     /**
      * Compares two fields by its name.
      */
@@ -0,0 +1,82 @@
+package org.junit.runners.parameterized;
+
+import static java.util.Collections.unmodifiableList;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.runners.model.TestClass;
+
+/**
+ * A {@code TestWithParameters} keeps the data together that are needed for
+ * creating a runner for a single data set of a parameterized test. It has a
+ * name, the test class and a list of parameters.
+ * 
+ * @since 4.12
+ */
+public class TestWithParameters {
+    private final String fName;
+
+    private final TestClass fTestClass;
+
+    private final List<Object> fParameters;
+
+    public TestWithParameters(String name, TestClass testClass,
+            List<Object> parameters) {
+        notNull(name, ""The name is missing."");
+        notNull(testClass, ""The test class is missing."");
+        notNull(parameters, ""The parameters are missing."");
+        fName = name;
+        fTestClass = testClass;
+        fParameters = unmodifiableList(new ArrayList<Object>(parameters));
+    }
+
+    public String getName() {
+        return fName;
+    }
+
+    public TestClass getTestClass() {
+        return fTestClass;
+    }
+
+    public List<Object> getParameters() {
+        return fParameters;
+    }
+
+    @Override
+    public int hashCode() {
+        int prime = 14747;
+        int result = prime + fName.hashCode();
+        result = prime * result + fTestClass.hashCode();
+        return prime * result + fParameters.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        TestWithParameters other = (TestWithParameters) obj;
+        return fName.equals(other.fName)
+                && fParameters.equals(other.fParameters)
+                && fTestClass.equals(other.fTestClass);
+    }
+
+    @Override
+    public String toString() {
+        return fTestClass.getName() + "" '"" + fName + ""' with parameters ""
+                + fParameters;
+    }
+
+    private static void notNull(Object value, String message) {
+        if (value == null) {
+            throw new NullPointerException(message);
+        }
+    }
+}
@@ -2,7 +2,10 @@
 
 import static org.hamcrest.CoreMatchers.hasItem;
 import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
 
 import java.util.List;
 
@@ -147,4 +150,55 @@ public void annotatedMethodValues() {
     	assertThat(values, hasItem(""jupiter""));
     	assertThat(values.size(), is(1));
     }
+
+    @Test
+    public void isEqualToTestClassThatWrapsSameJavaClass() {
+        TestClass testClass = new TestClass(DummyClass.class);
+        TestClass testClassThatWrapsSameJavaClass = new TestClass(
+                DummyClass.class);
+        assertTrue(testClass.equals(testClassThatWrapsSameJavaClass));
+    }
+
+    @Test
+    public void isEqualToTestClassThatWrapsNoJavaClassToo() {
+        TestClass testClass = new TestClass(null);
+        TestClass testClassThatWrapsNoJavaClassToo = new TestClass(null);
+        assertTrue(testClass.equals(testClassThatWrapsNoJavaClassToo));
+    }
+
+    @Test
+    public void isNotEqualToTestClassThatWrapsADifferentJavaClass() {
+        TestClass testClass = new TestClass(DummyClass.class);
+        TestClass testClassThatWrapsADifferentJavaClass = new TestClass(
+                AnotherDummyClass.class);
+        assertFalse(testClass.equals(testClassThatWrapsADifferentJavaClass));
+    }
+
+    @Test
+    public void isNotEqualToNull() {
+        TestClass testClass = new TestClass(DummyClass.class);
+        assertFalse(testClass.equals(null));
+    }
+
+    private static class DummyClass {
+    }
+
+    private static class AnotherDummyClass {
+    }
+
+    @Test
+    public void hasSameHashCodeAsTestClassThatWrapsSameJavaClass() {
+        TestClass testClass = new TestClass(DummyClass.class);
+        TestClass testClassThatWrapsSameJavaClass = new TestClass(
+                DummyClass.class);
+        assertEquals(testClass.hashCode(),
+                testClassThatWrapsSameJavaClass.hashCode());
+    }
+
+    @Test
+    public void hasHashCodeWithoutJavaClass() {
+        TestClass testClass = new TestClass(null);
+        testClass.hashCode();
+        // everything is fine if no exception is thrown.
+    }
 }
@@ -0,0 +1,137 @@
+package org.junit.runners.parameterized;
+
+import static java.util.Arrays.asList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.rules.ExpectedException.none;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runners.model.TestClass;
+
+public class TestWithParametersTest {
+    private static final String DUMMY_NAME = ""dummy name"";
+
+    private static final TestClass DUMMY_TEST_CLASS = new TestClass(
+            DummyClass.class);
+
+    private static final List<Object> DUMMY_PARAMETERS = Arrays
+            .<Object> asList(""a"", ""b"");
+
+    @Rule
+    public final ExpectedException thrown = none();
+
+    @Test
+    public void cannotBeCreatedWithoutAName() {
+        thrown.expect(NullPointerException.class);
+        thrown.expectMessage(""The name is missing."");
+        new TestWithParameters(null, DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+    }
+
+    @Test
+    public void cannotBeCreatedWithoutTestClass() {
+        thrown.expect(NullPointerException.class);
+        thrown.expectMessage(""The test class is missing."");
+        new TestWithParameters(DUMMY_NAME, null, DUMMY_PARAMETERS);
+    }
+
+    @Test
+    public void cannotBeCreatedWithoutParameters() {
+        thrown.expect(NullPointerException.class);
+        thrown.expectMessage(""The parameters are missing."");
+        new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS,
+                (List<Object>) null);
+    }
+
+    @Test
+    public void doesNotAllowToModifyProvidedParameters() {
+        TestWithParameters test = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        thrown.expect(UnsupportedOperationException.class);
+        test.getParameters().set(0, ""another parameter"");
+    }
+
+    @Test
+    public void doesNotConsiderParametersWhichChangedAfterTestInstantiation() {
+        List<Object> parameters = Arrays.<Object> asList(""dummy parameter"");
+        TestWithParameters test = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, parameters);
+        parameters.set(0, ""another parameter"");
+        assertEquals(asList(""dummy parameter""), test.getParameters());
+    }
+
+    @Test
+    public void isEqualToTestWithSameNameAndTestClassAndParameters() {
+        TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME,
+                new TestClass(DummyClass.class), Arrays.<Object> asList(""a"",
+                        ""b""));
+        TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME,
+                new TestClass(DummyClass.class), Arrays.<Object> asList(""a"",
+                        ""b""));
+        assertEquals(firstTest, secondTest);
+    }
+
+    @Test
+    public void isNotEqualToTestWithDifferentName() {
+        TestWithParameters firstTest = new TestWithParameters(""name"",
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        TestWithParameters secondTest = new TestWithParameters(""another name"",
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        assertNotEquals(firstTest, secondTest);
+    }
+
+    @Test
+    public void isNotEqualToTestWithDifferentTestClass() {
+        TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME,
+                new TestClass(DummyClass.class), DUMMY_PARAMETERS);
+        TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME,
+                new TestClass(AnotherDummyClass.class), DUMMY_PARAMETERS);
+        assertNotEquals(firstTest, secondTest);
+    }
+
+    @Test
+    public void isNotEqualToTestWithDifferentParameters() {
+        TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, Arrays.<Object> asList(""a""));
+        TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, Arrays.<Object> asList(""b""));
+        assertNotEquals(firstTest, secondTest);
+    }
+
+    @Test
+    public void isNotEqualToObjectWithDifferentClass() {
+        TestWithParameters test = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        assertNotEquals(test, new Integer(3));
+    }
+
+    @Test
+    public void hasSameHashCodeAsEqualTest() {
+        TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME,
+                DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
+        assertEquals(firstTest.hashCode(), secondTest.hashCode());
+    }
+
+    @Test
+    public void hasMeaningfulToString() {
+        TestWithParameters test = new TestWithParameters(""name"", new TestClass(
+                DummyClass.class), Arrays.<Object> asList(""first parameter"",
+                ""second parameter""));
+        assertEquals(
+                ""Wrong toString()."",
+                ""org.junit.runners.parameterized.TestWithParametersTest$DummyClass 'name' with parameters [first parameter, second parameter]"",
+                test.toString());
+    }
+
+    private static class DummyClass {
+    }
+
+    private static class AnotherDummyClass {
+    }
+}
@@ -18,6 +18,7 @@
 import org.junit.runners.model.FrameworkFieldTest;
 import org.junit.runners.model.FrameworkMethodTest;
 import org.junit.runners.model.TestClassTest;
+import org.junit.runners.parameterized.TestWithParametersTest;
 import org.junit.tests.assertion.AssertionTest;
 import org.junit.tests.assertion.ComparisonFailureTest;
 import org.junit.tests.assertion.MultipleFailureExceptionTest;
@@ -202,7 +203,8 @@
         FrameworkFieldTest.class,
         FrameworkMethodTest.class,
         FailOnTimeoutTest.class,
-        JUnitCoreTest.class
+        JUnitCoreTest.class,
+        TestWithParametersTest.class
 })
 public class AllTests {
     public static Test suite() {
",True,"The commit message refers to the necessity of changes by mentioning the responsibility of the Parameterized class. It explains that the computation of the name is not the responsibility of the runner but of the Parameterized class, which is a new class being created in this commit. This implies that the changes are being made to improve the structure and organization of the code.",True,"The commit message 'Create a class TestWithParameters' clearly states the purpose of the changes, which is to create a new class. This is a common practice in software development and does not require a detailed explanation of the necessity of the changes, as it is self-explanatory.",True,"The commit message explains the motivation for the changes by stating that the computation of the name is not the responsibility of the runner but of the Parameterized class. This implies that the previous implementation may have been inefficient or incorrect, and the changes are made to improve the design and functionality of the code.",True,"The commit message 'Create a class TestWithParameters' indicates that the developer is adding a new class to the codebase. This could be done to address a requirement, such as the need for more flexibility in parameterized tests, or to improve the organization of the code. However, without more context, it's difficult to definitively say that the change was necessitated by a specific user requirement or problem in the software maintenance process.",True,"The commit message directly mentions the objective of the change by stating that the class 'TestWithParameters' is created to keep the data together that are needed for creating a runner for a single data set of a parameterized test. This makes it clear that the computation of the name is not the responsibility of the runner but of the Parameterized class, which is an improvement to the code.",True,"The commit message 'Create a class TestWithParameters' describes the creation of a new class, which is a key component of the change. Additionally, the message explains that this class is used to keep data together for creating a runner for a single data set of a parameterized test, which is a clear description of its purpose. The code diff also supports this explanation, as it shows the creation of the TestWithParameters class and its usage in the TestClassRunnerForParameters class.",True,"The commit message explains that the computation of the name for a parameterized test is not the responsibility of the runner but of the Parameterized class. This is a clear statement of the separation of concerns principle, where each part of the system has a single responsibility.",True,"The commit message 'Create a class TestWithParameters' clearly describes the creation of a new class in the codebase. This class is introduced to keep data together that are needed for creating a runner for a single data set of a parameterized test. The message also explains that the computation of the name is not the responsibility of the runner but of the Parameterized class, which is reflected in the code changes.",False,The commit message explains the reason for the commit by stating that the creation of the TestWithParameters class is to make it clear that the computation of the name is not the responsibility of the runner but of the Parameterized class. This is a significant change that justifies the need for a clear explanation in the commit message.
https://github.com/junit-team/junit4/commit/5e4f8e7fb82919d992887fca1741bb04ef1c8f4a,New Suite implementation makes ClassesRequest crazy simple ,https://api.github.com/repos/junit-team/junit4/commits/5e4f8e7fb82919d992887fca1741bb04ef1c8f4a,"@@ -1,28 +1,21 @@
 package org.junit.internal.requests;
 
-import org.junit.internal.runners.InitializationError;
 import org.junit.runner.Request;
 import org.junit.runner.Runner;
 import org.junit.runners.Suite;
 
 public class ClassesRequest extends Request {
+	// TODO: (Dec 13, 2007 2:29:43 AM) how useful are requests anymore?
+
 	private final Class<?>[] fClasses;
-	private final String fName;
 	
-	public ClassesRequest(String name, Class<?>... classes) {
+	public ClassesRequest(Class<?>... classes) {
 		fClasses= classes;
-		fName= name;
 	}
 
 	/** @inheritDoc */
 	@Override 
 	public Runner getRunner() {
-		try {
-			return new Suite(fName, fClasses);
-		} catch (InitializationError e) {
-			// TODO: (Dec 10, 2007 9:13:13 PM) untested
-
-			return Request.errorReport(null, e).getRunner();
-		}
+		return new Suite(fClasses);
 	}
 }
\ No newline at end of file
@@ -53,7 +53,7 @@ public static Request aClass(Class<?> clazz) {
 	 * @return a <code>Request</code> that will cause all tests in the classes to be run
 	 */
 	public static Request classes(String collectionName, Class<?>... classes) {
-		return new ClassesRequest(collectionName, classes);
+		return new ClassesRequest(classes);
 	}
 
 	public static Request errorReport(Class<?> klass, Throwable cause) {
",True,"The commit message 'New Suite implementation makes ClassesRequest crazy simple' suggests that the changes were made to improve the simplicity and usability of the ClassesRequest class. This could be interpreted as a reference to a standard or convention, as the new implementation is likely easier to use and understand than the previous one. Additionally, the removal of the name parameter from the ClassesRequest constructor and the simplification of the getRunner() method could be seen as improvements over prior commits, as they make the class more concise and efficient.",True,"The commit message 'New Suite implementation makes ClassesRequest crazy simple' does not explicitly state the reason for the changes, but it is easy to infer from the code diff that the changes were made to simplify the implementation of the ClassesRequest class. Specifically, the constructor no longer takes a name parameter, and the getRunner method no longer catches an InitializationError exception. These changes make the code simpler and easier to understand, which is likely the reason for the changes.",False,"The commit message does not directly elaborate the motivation of the code change. It only states that the new Suite implementation makes ClassesRequest 'crazy simple'. However, the code diff does not reveal any specific error scenario, issue report, or shortcoming of the previous implementation that the new code is addressing.",True,"The commit message 'New Suite implementation makes ClassesRequest crazy simple' does not explicitly state the source of the requirements. However, the code diff suggests that the changes were made to simplify the implementation of the ClassesRequest class. This could imply that the changes were made to improve the maintainability of the code, as the previous implementation was complex and potentially causing issues, such as the need to handle InitializationError exceptions. Therefore, the source of the requirements could be considered to be the need for software maintenance to improve the maintainability and simplicity of the code.",True,The commit message 'New Suite implementation makes ClassesRequest crazy simple' directly mentions the improvement it makes to the code. The change simplifies the ClassesRequest class by removing unnecessary code and making the constructor and getRunner() method more concise.,True,"The commit message 'New Suite implementation makes ClassesRequest crazy simple' accurately summarizes the changes made in the code diff. It highlights the key component of the change, which is the new implementation of the Suite class that simplifies the ClassesRequest. The message also contrasts the before and after by mentioning the removal of the name parameter from the ClassesRequest constructor and the change in the getRunner() method.",True,"The commit message 'New Suite implementation makes ClassesRequest crazy simple' suggests that the technical principle underpinning the changes is simplification. The code diff shows that the constructor of ClassesRequest has been simplified by removing the need for a name parameter, and the getRunner() method has been simplified by removing the try-catch block that handled InitializationError.",True,"The commit message 'New Suite implementation makes ClassesRequest crazy simple' does express a summary of the changes. It describes that the new implementation of the Suite class has made the ClassesRequest much simpler. The code changes removed the need for a name parameter in the ClassesRequest constructor and the getRunner() method, which simplifies the usage of the ClassesRequest. Additionally, the code changes removed the try-catch block in the getRunner() method, which handles the InitializationError exception, making the code cleaner and more straightforward. Overall, the commit message accurately describes the functional changes that have been made to the code.",False,"The commit message does not explicitly state the reason for the removal of the 'name' parameter from the ClassesRequest constructor. While it can be inferred that the new implementation makes the ClassesRequest 'crazy simple' by removing unnecessary complexity, the reason for this change is not explicitly stated in the commit message."
https://github.com/apache/dubbo/commit/4a8da59573cb0f1d793809439abb2f2162f2d80f,"Proofread README.md file with multiple fixes ( <pr_link> )  <enter> Fixed typo, grammatical, punctuations, and semantic coherence to improve readability and content quality. <enter> Signed-off-by: Aditya Kumar Roy <akroy@umass.edu> ",https://api.github.com/repos/apache/dubbo/commits/4a8da59573cb0f1d793809439abb2f2162f2d80f,"@@ -10,9 +10,9 @@
 [![](https://img.shields.io/twitter/follow/ApacheDubbo.svg?label=Follow&style=social&logoWidth=0)](https://twitter.com/intent/follow?screen_name=ApacheDubbo)
 [![Gitter](https://badges.gitter.im/alibaba/dubbo.svg)](https://gitter.im/alibaba/dubbo?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)
 
-Apache Dubbo is a high-performance, Java based open source RPC framework. Please visit [official site](http://dubbo.apache.org) for quick start and documentations, as well as [Wiki](https://github.com/apache/dubbo/wiki) for news, FAQ, and release notes.
+Apache Dubbo is a high-performance, Java-based open-source RPC framework. Please visit [official site](http://dubbo.apache.org) for quick start and documentations, as well as the [wiki](https://github.com/apache/dubbo/wiki) for news, FAQ, and release notes.
 
-We are now collecting dubbo user info in order to help us to improve Dubbo better, pls. kindly help us by providing yours on [issue#1012: Wanted: who's using dubbo](https://github.com/apache/dubbo/issues/1012), thanks :)
+We are now collecting Dubbo user info to help us to improve Dubbo further. Kindly support us by supplementing your information on [issue#1012: Wanted: who's using dubbo](https://github.com/apache/dubbo/issues/1012), thanks :)
 
 ## Architecture
 
@@ -29,14 +29,14 @@ We are now collecting dubbo user info in order to help us to improve Dubbo bette
 
 ## Getting started
 
-The following code snippet comes from [Dubbo Samples](https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-api). You may clone the sample project and step into `dubbo-samples-api` sub directory before read on.
+The following code snippet comes from [Dubbo Samples](https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-api). You may clone the sample project and step into the `dubbo-samples-api` subdirectory before proceeding.
 
 ```bash
 # git clone https://github.com/apache/dubbo-samples.git
 # cd dubbo-samples/java/dubbo-samples-api
 ```
 
-There's a [README](https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-api/README.md) file under `dubbo-samples-api` directory. Read it and try this sample out by following the instructions.
+There's a [README](https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-api/README.md) file under `dubbo-samples-api` directory. We recommend referencing the samples in that directory by following the below-mentioned instructions: 
 
 ### Maven dependency
 
@@ -128,7 +128,7 @@ public class Application {
 # mvn -Djava.net.preferIPv4Stack=true -Dexec.mainClass=org.apache.dubbo.samples.provider.Application exec:java
 ```
 
-### Call remote service in consumer
+### Call remote service in the consumer
 
 ```java
 package org.apache.dubbo.samples.client;
@@ -174,7 +174,7 @@ The consumer will print out `hi, dubbo` on the screen.
 
 ## Building
 
-If you want to try out the cutting-edge features, you can build with the following commands. (Java 1.8 is required to build the master branch)
+If you want to try out the cutting-edge features, you can build with the following commands. (Java 1.8 is needed to build the master branch)
 
 ```
   mvn clean install
@@ -195,18 +195,18 @@ See [CONTRIBUTING](https://github.com/apache/dubbo/blob/master/CONTRIBUTING.md)
 
 ### How can I contribute?
 
-* Take a look at issues with tag called [`Good first issue`](https://github.com/apache/dubbo/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) or [`Help wanted`](https://github.com/apache/dubbo/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22).
-* Join the discussion on mailing list, subscription [guide](https://github.com/apache/dubbo/wiki/Mailing-list-subscription-guide).
+* Take a look at issues with tags marked [`Good first issue`](https://github.com/apache/dubbo/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) or [`Help wanted`](https://github.com/apache/dubbo/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22).
+* Join the discussion on the mailing list, subscription [guide](https://github.com/apache/dubbo/wiki/Mailing-list-subscription-guide).
 * Answer questions on [issues](https://github.com/apache/dubbo/issues).
-* Fix bugs reported on [issues](https://github.com/apache/dubbo/issues), and send us pull request.
+* Fix bugs reported on [issues](https://github.com/apache/dubbo/issues), and send us a pull request.
 * Review the existing [pull request](https://github.com/apache/dubbo/pulls).
 * Improve the [website](https://github.com/apache/dubbo-website), typically we need
   * blog post
   * translation on documentation
-  * use cases about how Dubbo is being used in enterprise system.
+  * use cases around the integration of Dubbo in enterprise systems.
 * Improve the [dubbo-admin/dubbo-monitor](https://github.com/apache/dubbo-admin).
 * Contribute to the projects listed in [ecosystem](https://github.com/dubbo).
-* Any form of contribution that is not mentioned above.
+* Other forms of contribution not explicitly enumerated above.
 * If you would like to contribute, please send an email to dev@dubbo.apache.org to let us know!
 
 ## Reporting bugs
@@ -215,7 +215,7 @@ Please follow the [template](https://github.com/apache/dubbo/issues/new?template
 
 ## Reporting a security vulnerability
 
-Please report security vulnerability to [us](mailto:security@dubbo.apache.org) privately.
+Please report security vulnerabilities to [us](mailto:security@dubbo.apache.org) privately.
 
 ## Dubbo ecosystem
 
@@ -236,4 +236,4 @@ Please report security vulnerability to [us](mailto:security@dubbo.apache.org) p
 
 ## License
 
-Apache Dubbo is under the Apache 2.0 license. See the [LICENSE](https://github.com/apache/dubbo/blob/master/LICENSE) file for details.
+Apache Dubbo software is licenced under the Apache License Version 2.0. See the [LICENSE](https://github.com/apache/dubbo/blob/master/LICENSE) file for details.
",True,"The commit message refers to the necessity of changes by mentioning the improvement in readability and content quality of the README.md file. The changes made include fixing typos, grammatical errors, punctuations, and semantic coherence to enhance the overall clarity and quality of the content.",True,"The commit message 'Proofread README.md file with multiple fixes' clearly describes the changes made to the README.md file, which are typographic fixes, grammatical corrections, punctuation adjustments, and semantic coherence improvements. These types of changes are common and easy to infer, making it unnecessary to provide a rationale for the changes.",False,"The commit message focuses on the changes made to the README.md file, such as fixing typos, grammar, punctuation, and semantic coherence. It does not directly elaborate on the motivation for the changes, such as describing an error scenario, mentioning an issue report, or discussing the shortcomings of the previous implementation.",True,"The commit message indicates that the changes were made to improve the readability and content quality of the README.md file. This could be due to the need to clarify information for users, as the changes made include fixing typos, grammar, punctuation, and semantic coherence. This suggests that the changes were made to address a problem in the software maintenance process, specifically out-of-date or unclear documentation.",True,"The commit message directly mentions the improvements made to the README.md file, such as fixing typos, grammatical errors, punctuations, and semantic coherence to improve readability and content quality.",True,"The commit message accurately summarizes the changes made to the README.md file. It mentions fixing typos, grammatical errors, punctuation, and semantic coherence to improve readability and content quality. This is a clear and concise summary of the changes made in the diff.",False,"The commit message focuses on the readability and grammatical improvements made to the README.md file. However, it does not explicitly describe any technical principle underpinning the changes. The code diff shows various corrections and improvements to the README.md file, but it does not reveal any significant technical changes or principles.",True,"The commit message describes the changes made to the README.md file, which were proofreading fixes for typos, grammar, punctuation, and semantic coherence. The code diff also shows changes in the README.md file, such as fixing the link to the wiki and improving the instructions for building and contributing to the project. These changes do not introduce new behaviors or functionalities, but they improve the readability and content quality of the documentation.",False,"The commit message does not lack an explanation, as it clearly states the purpose of the changes made to the README.md file. The changes include fixing typos, grammar, punctuation, and semantic coherence to improve readability and content quality. This is a significant change that requires an explanation in the commit message."
https://github.com/apache/dubbo/commit/6912d9a14fe2c35dee306da9a8e953ba29d736da,Upgrade tomcat version to 8.5.31. ( <pr_link> ) ,https://api.github.com/repos/apache/dubbo/commits/6912d9a14fe2c35dee306da9a8e953ba29d736da,"@@ -99,7 +99,7 @@
 
         <rs_api_version>2.0</rs_api_version>
         <resteasy_version>3.0.19.Final</resteasy_version>
-        <tomcat_embed_version>8.0.11</tomcat_embed_version>
+        <tomcat_embed_version>8.5.31</tomcat_embed_version>
         <!-- Log libs -->
         <slf4j_version>1.7.25</slf4j_version>
         <jcl_version>1.2</jcl_version>
@@ -49,10 +49,6 @@
             <groupId>org.apache.tomcat.embed</groupId>
             <artifactId>tomcat-embed-core</artifactId>
         </dependency>
-        <dependency>
-            <groupId>org.apache.tomcat.embed</groupId>
-            <artifactId>tomcat-embed-logging-juli</artifactId>
-        </dependency>
         <dependency>
             <groupId>org.apache.httpcomponents</groupId>
             <artifactId>fluent-hc</artifactId>
",True,"The commit message 'Upgrade tomcat version to 8.5.31' does reference a necessity for changes. It mentions that the tomcat version is being upgraded, which could be due to the availability of a newer version with improvements, security patches, or bug fixes. This is a common practice in software development to stay updated with the latest stable versions of dependencies to ensure optimal performance, security, and compatibility.",False,"The commit message does not provide a rationale for the change. While it is clear from the diff that the Tomcat version is being upgraded, the message does not explain why this upgrade is necessary. It could be for security reasons, to take advantage of new features, or for compatibility with other components, but the message does not provide this information.",True,"The commit message 'Upgrade tomcat version to 8.5.31. ( <pr_link> )' does describe the necessity of changes by directly elaborating the motivation of a code change. It mentions that the Tomcat version is being upgraded, which could potentially fix issues or add new features that were not available in the previous version. Additionally, the code diff shows that the 'tomcat-embed-logging-juli' dependency is removed, which might have been causing problems in the previous implementation.",True,"The commit message 'Upgrade tomcat version to 8.5.31' indicates that the change is being made due to a problem in the software maintenance process. The problem is that the current version of tomcat (8.0.11) is out of date, and the developer is upgrading to version 8.5.31 to address this issue. This is evident from the code diff, where the version number of tomcat is being changed.",True,"The commit message 'Upgrade tomcat version to 8.5.31' directly mentions the improvement made to the code, which is upgrading the tomcat version. This change could potentially fix any bugs or issues present in the previous version of tomcat, and it also improves the code by providing access to new features and improvements in the newer version.",True,"The commit message 'Upgrade tomcat version to 8.5.31' accurately summarizes the change made in the diff. The diff shows that the tomcat_embed_version has been changed from 8.0.11 to 8.5.31. The message clearly states this change, mentioning the component (tomcat version) and the new version number. Additionally, the diff also shows the removal of a dependency for 'tomcat-embed-logging-juli', but the commit message does not mention this. However, since the message focuses on the upgrade of the tomcat version, it can be considered as a summary of the key component change.",False,"The commit message only mentions the upgrade of the tomcat version from 8.0.11 to 8.5.31. It does not explicitly describe a technical principle underpinning the changes. The code diff shows that the logging dependency 'tomcat-embed-logging-juli' has been removed, but the commit message does not explain why this change was made or what technical principle it is based on.",True,"The commit message 'Upgrade tomcat version to 8.5.31' accurately summarizes the code changes. The code diff shows that the version of Tomcat Embedded in the project is being updated from 8.0.11 to 8.5.31. This change does not introduce any new behaviors or functionalities to the project, but it does modify the underlying technology used. Therefore, the commit message effectively describes the changes made.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit, which is to upgrade the tomcat version to 8.5.31. The code diff also supports this explanation by showing the change in the tomcat_embed_version. Additionally, the diff shows that the dependency for tomcat-embed-logging-juli has been removed, which might be related to the upgrade."
https://github.com/apache/dubbo/commit/f490df87de45b57be8c224581a8a1a7dd9a20946,"keep demo simple, and switch to use zookeeper as registry center ( <pr_link> )  <enter> * keep demo simple, and switch to use zookeeper as registry center <enter> * remove comment ",https://api.github.com/repos/apache/dubbo/commits/f490df87de45b57be8c224581a8a1a7dd9a20946,"@@ -19,15 +19,14 @@
 
 package org.apache.dubbo.demo.consumer.comp;
 
-import org.apache.dubbo.config.annotation.Method;
 import org.apache.dubbo.config.annotation.Reference;
 import org.apache.dubbo.demo.DemoService;
 
 import org.springframework.stereotype.Component;
 
 @Component(""demoServiceComponent"")
 public class DemoServiceComponent implements DemoService {
-    @Reference(timeout = 100,methods = @Method(timeout = 500,name = ""sayHello""))
+    @Reference
     private DemoService demoService;
 
     @Override
@@ -27,10 +27,6 @@
 import org.springframework.context.annotation.PropertySource;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) throws Exception {
         AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class);
         context.start();
@@ -18,25 +18,19 @@
  */
 package org.apache.dubbo.demo.provider;
 
-import org.apache.dubbo.config.annotation.Method;
 import org.apache.dubbo.config.annotation.Service;
 import org.apache.dubbo.demo.DemoService;
 import org.apache.dubbo.rpc.RpcContext;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-@Service(timeout = 100,methods = @Method(timeout = 1000,name = ""sayHello""))
+@Service
 public class DemoServiceImpl implements DemoService {
     private static final Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);
 
     @Override
     public String sayHello(String name) {
-        try {
-            Thread.sleep(2000);
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
         logger.info(""Hello "" + name + "", request from consumer: "" + RpcContext.getContext().getRemoteAddress());
         return ""Hello "" + name + "", response from provider: "" + RpcContext.getContext().getLocalAddress();
     }
@@ -24,14 +24,10 @@
 import org.apache.dubbo.demo.DemoService;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) {
         ReferenceConfig<DemoService> reference = new ReferenceConfig<>();
         reference.setApplication(new ApplicationConfig(""dubbo-demo-api-consumer""));
-        reference.setRegistry(new RegistryConfig(""multicast://224.5.6.7:1234""));
+        reference.setRegistry(new RegistryConfig(""zookeeper://127.0.0.1:2181""));
         reference.setInterface(DemoService.class);
         DemoService service = reference.get();
         String message = service.sayHello(""dubbo"");
@@ -24,14 +24,10 @@
 import org.apache.dubbo.demo.DemoService;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) throws Exception {
         ServiceConfig<DemoServiceImpl> service = new ServiceConfig<>();
         service.setApplication(new ApplicationConfig(""dubbo-demo-api-provider""));
-        service.setRegistry(new RegistryConfig(""multicast://224.5.6.7:1234""));
+        service.setRegistry(new RegistryConfig(""zookeeper://127.0.0.1:2181""));
         service.setInterface(DemoService.class);
         service.setRef(new DemoServiceImpl());
         service.export();
@@ -21,10 +21,6 @@
 import org.springframework.context.support.ClassPathXmlApplicationContext;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) {
         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(""spring/dubbo-consumer.xml"");
         context.start();
@@ -23,10 +23,8 @@
 
     <dubbo:application name=""demo-consumer""/>
 
-    <dubbo:registry address=""multicast://224.5.6.7:1234""/>
+    <dubbo:registry address=""zookeeper://127.0.0.1:2181""/>
 
-    <!-- generate proxy for the remote service, then demoService can be used in the same way as the
-    local regular interface -->
     <dubbo:reference id=""demoService"" check=""false"" interface=""org.apache.dubbo.demo.DemoService""/>
 
 </beans>
@@ -19,10 +19,6 @@
 import org.springframework.context.support.ClassPathXmlApplicationContext;
 
 public class Application {
-    /**
-     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
-     * launch the application
-     */
     public static void main(String[] args) throws Exception {
         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(""spring/dubbo-provider.xml"");
         context.start();
@@ -21,18 +21,14 @@
        xsi:schemaLocation=""http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
        http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"">
 
-    <!-- provider's application name, used for tracing dependency relationship -->
     <dubbo:application name=""demo-provider""/>
 
-    <dubbo:registry address=""multicast://224.5.6.7:1234"" />
+    <dubbo:registry address=""zookeeper://127.0.0.1:2181""/>
 
-    <!-- use dubbo protocol to export service on port 20880 -->
     <dubbo:protocol name=""dubbo""/>
 
-    <!-- service implementation, as same as regular local bean -->
     <bean id=""demoService"" class=""org.apache.dubbo.demo.provider.DemoServiceImpl""/>
 
-    <!-- declare the service interface to be exported -->
     <dubbo:service interface=""org.apache.dubbo.demo.DemoService"" ref=""demoService""/>
 
 </beans>
",True,"The commit message 'keep demo simple, and switch to use zookeeper as registry center' explains the necessity of changes by referencing a standard (zookeeper) and an improvement in prior commits (simplifying the demo). The code diff also supports this explanation, as it shows the removal of the multicast registry and the addition of zookeeper as the registry center.",True,"The commit message 'keep demo simple, and switch to use zookeeper as registry center' clearly explains the necessity of the changes. The changes are made to simplify the demo and improve its scalability by switching to a more robust registry center, zookeeper, instead of the previous multicast registry.",True,"The commit message 'keep demo simple, and switch to use zookeeper as registry center' directly elaborates the motivation of the code change by mentioning the switch to a different registry center (zookeeper) to simplify the demo. This change is likely made to improve the simplicity and maintainability of the demo, as zookeeper is a more commonly used and robust registry center compared to multicast.",True,"The commit message 'keep demo simple, and switch to use zookeeper as registry center' indicates that the developer is making a change to simplify the demo and improve its maintainability. The change from 'multicast' to 'zookeeper' as the registry center suggests that the previous multicast registry was out of date or not suitable for the current requirements, as Zookeeper is a more robust and scalable solution for service discovery and management.",True,"The commit message directly mentions the change of switching to use Zookeeper as the registry center, which is an improvement to the code. It also mentions keeping the demo simple, which could imply simplifying the code or making it easier to understand.",True,"The commit message 'keep demo simple, and switch to use zookeeper as registry center' accurately summarizes the changes made in the code diff. It highlights the key components of the change, which are simplifying the demo and switching the registry center from multicast to zookeeper. The message also contrasts the before and after state of the registry center.",True,"The commit message 'keep demo simple, and switch to use zookeeper as registry center' does describe the technical principle underpinning the changes. The changes involve switching from a multicast registry to a zookeeper registry, which is a common practice to improve the reliability and scalability of a distributed system.",True,"The commit message 'keep demo simple, and switch to use zookeeper as registry center' accurately describes the changes made in the code. The changes involve switching from a multicast registry to a zookeeper registry, which is a significant functional change. The code diff also supports this, showing the removal of the multicast registry configuration and the addition of the zookeeper registry configuration in various parts of the codebase.",False,"The commit message does not lack an explanation, but it does not explicitly state the reason for switching to Zookeeper as the registry center. However, the change in the code diff indicates that the previous multicast registry is being replaced with Zookeeper. This change might be due to the need for a more reliable and scalable registry solution, but the commit message does not explicitly state this reason."
https://github.com/spring-projects/spring-boot/commit/0515ca0dd02fec54d438d45afbf95db1b5f41353,Auto configure micrometer cache metrics  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/0515ca0dd02fec54d438d45afbf95db1b5f41353,"@@ -27,6 +27,7 @@
 
 import org.springframework.beans.factory.ObjectProvider;
 import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnEnabledEndpoint;
+import org.springframework.boot.actuate.autoconfigure.metrics.cache.CacheMetricsConfiguration;
 import org.springframework.boot.actuate.autoconfigure.metrics.export.MetricsExporter;
 import org.springframework.boot.actuate.autoconfigure.metrics.export.atlas.AtlasExportConfiguration;
 import org.springframework.boot.actuate.autoconfigure.metrics.export.datadog.DatadogExportConfiguration;
@@ -45,6 +46,7 @@
 import org.springframework.boot.actuate.metrics.integration.SpringIntegrationMetrics;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
+import org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
@@ -68,12 +70,13 @@
 @EnableConfigurationProperties(MetricsProperties.class)
 @Import({ MeterBindersConfiguration.class, WebMvcMetricsConfiguration.class,
 		WebFluxMetricsConfiguration.class, RestTemplateMetricsConfiguration.class,
-		DataSourcePoolMetricsConfiguration.class, AtlasExportConfiguration.class,
-		DatadogExportConfiguration.class, GangliaExportConfiguration.class,
-		GraphiteExportConfiguration.class, InfluxExportConfiguration.class,
-		JmxExportConfiguration.class, PrometheusExportConfiguration.class,
-		SimpleExportConfiguration.class, StatsdExportConfiguration.class })
-@AutoConfigureAfter(DataSourceAutoConfiguration.class)
+		CacheMetricsConfiguration.class, DataSourcePoolMetricsConfiguration.class,
+		AtlasExportConfiguration.class, DatadogExportConfiguration.class,
+		GangliaExportConfiguration.class, GraphiteExportConfiguration.class,
+		InfluxExportConfiguration.class, JmxExportConfiguration.class,
+		PrometheusExportConfiguration.class, SimpleExportConfiguration.class,
+		StatsdExportConfiguration.class })
+@AutoConfigureAfter({ CacheAutoConfiguration.class, DataSourceAutoConfiguration.class })
 public class MetricsAutoConfiguration {
 
 	@Bean
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import com.hazelcast.core.Hazelcast;
+import com.hazelcast.spring.cache.HazelcastCache;
+import io.micrometer.core.instrument.binder.MeterBinder;
+import net.sf.ehcache.Ehcache;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider;
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.cache.caffeine.CaffeineCache;
+import org.springframework.cache.ehcache.EhCacheCache;
+import org.springframework.cache.jcache.JCacheCache;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+/**
+ * {@link Configuration Auto-configuration} for {@link CacheMeterBinderProvider} beans.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ * @see CacheMeterBinderProviders
+ */
+@Configuration
+@ConditionalOnClass(MeterBinder.class)
+class CacheMeterBinderProvidersConfiguration {
+
+	@Configuration
+	@ConditionalOnClass({ CaffeineCache.class, com.github.benmanes.caffeine.cache.Cache.class })
+	static class CaffeineCacheMeterBinderProviderConfiguration {
+
+		@Bean
+		public CacheMeterBinderProvider caffeineCacheMeterBinderProvider() {
+			return new CacheMeterBinderProviders.CaffeineCacheMeterBinderProvider();
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnClass({ EhCacheCache.class, Ehcache.class })
+	static class EhCache2CacheMeterBinderProviderConfiguration {
+
+		@Bean
+		public CacheMeterBinderProvider ehCache2CacheMeterBinderProvider() {
+			return new CacheMeterBinderProviders.EhCache2CacheMeterBinderProvider();
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnClass({ HazelcastCache.class, Hazelcast.class })
+	static class HazelcastCacheMeterBinderProviderConfiguration {
+
+		@Bean
+		public CacheMeterBinderProvider hazelcastCacheMeterBinderProvider() {
+			return new CacheMeterBinderProviders.HazelcastCacheMeterBinderProvider();
+		}
+
+	}
+
+	@Configuration
+	@ConditionalOnClass({ JCacheCache.class, javax.cache.CacheManager.class })
+	static class JCacheCacheMeterBinderProviderConfiguration {
+
+		@Bean
+		public CacheMeterBinderProvider jCacheCacheMeterBinderProvider() {
+			return new CacheMeterBinderProviders.JCacheCacheMeterBinderProvider();
+		}
+
+	}
+
+}
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.cache.Cache;
+import org.springframework.cache.CacheManager;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Import;
+
+/**
+ * Configure metrics for all available {@link Cache caches}.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+@Configuration
+@ConditionalOnBean(CacheManager.class)
+@ConditionalOnProperty(value = ""management.metrics.cache.instrument-cache"", matchIfMissing = true)
+@EnableConfigurationProperties(CacheMetricsProperties.class)
+@Import({ CacheMeterBinderProvidersConfiguration.class, CacheMetricsRegistrarConfiguration.class })
+public class CacheMetricsConfiguration {
+
+}
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+/**
+ * Configuration properties for Cache-based metrics.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+@ConfigurationProperties(""management.metrics.cache"")
+public class CacheMetricsProperties {
+
+	/**
+	 * Name of the metric for cache usage.
+	 */
+	private String cacheMetricName = ""cache"";
+
+	public String getCacheMetricName() {
+		return this.cacheMetricName;
+	}
+
+	public void setCacheMetricName(String cacheMetricName) {
+		this.cacheMetricName = cacheMetricName;
+	}
+
+}
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.Tag;
+import io.micrometer.core.instrument.Tags;
+import io.micrometer.core.instrument.binder.MeterBinder;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider;
+import org.springframework.cache.Cache;
+
+/**
+ * Register supported {@link Cache} to a {@link MeterRegistry}.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+public class CacheMetricsRegistrar {
+
+	private final MeterRegistry registry;
+
+	private final String metricName;
+
+	private final Collection<CacheMeterBinderProvider> cacheMeterBinderProviders;
+
+	/**
+	 * Creates a new registrar.
+	 * @param registry the {@link MeterRegistry} to use
+	 * @param metricName the name of the metric
+	 * @param binderProviders the {@link CacheMeterBinderProvider} instances that should
+	 * be used to detect compatible caches
+	 */
+	public CacheMetricsRegistrar(MeterRegistry registry, String metricName,
+			Collection<CacheMeterBinderProvider> binderProviders) {
+		this.registry = registry;
+		this.metricName = metricName;
+		this.cacheMeterBinderProviders = binderProviders;
+	}
+
+	/**
+	 * Attempt to bind the specified {@link Cache} to the registry. Return {@code true}
+	 * if the cache is supported and was bound to the registry, {@code false} otherwise.
+	 * @param cache the cache to handle
+	 * @param tags the tags to associate with the metrics of that cache
+	 * @return {@code true} if the {@code cache} is supported and was registered
+	 */
+	public boolean bindCacheToRegistry(Cache cache, Tag... tags) {
+		List<Tag> allTags = new ArrayList(Arrays.asList(tags));
+		MeterBinder meterBinder = getMeterBinder(cache, allTags);
+		if (meterBinder != null) {
+			meterBinder.bindTo(this.registry);
+			return true;
+		}
+		return false;
+	}
+
+	private MeterBinder getMeterBinder(Cache cache, List<Tag> tags) {
+		tags.addAll(getAdditionalTags(cache));
+		for (CacheMeterBinderProvider binderProvider : this.cacheMeterBinderProviders) {
+			MeterBinder meterBinder = binderProvider.getMeterBinder(cache,
+					this.metricName, tags);
+			if (meterBinder != null) {
+				return meterBinder;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Return additional {@link Tag tags} to be associated with the given {@link Cache}.
+	 * @param cache the cache
+	 * @return a list of additional tags to associate to that {@code cache}.
+	 */
+	protected List<Tag> getAdditionalTags(Cache cache) {
+		return Tags.zip(""name"", cache.getName());
+	}
+
+}
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import java.util.Collection;
+import java.util.Map;
+
+import javax.annotation.PostConstruct;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.Tag;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.cache.Cache;
+import org.springframework.cache.CacheManager;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.util.StringUtils;
+
+/**
+ * Configure a {@link CacheMetricsRegistrar} and register all available
+ * {@link Cache caches}.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+@Configuration
+@ConditionalOnBean(CacheMeterBinderProvider.class)
+class CacheMetricsRegistrarConfiguration {
+
+	private static final String CACHE_MANAGER_SUFFIX = ""cacheManager"";
+
+	private final MeterRegistry registry;
+
+	private final CacheMetricsProperties properties;
+
+	private final Collection<CacheMeterBinderProvider> cacheMeterBinderProviders;
+
+	private final Map<String, CacheManager> cacheManagers;
+
+	CacheMetricsRegistrarConfiguration(MeterRegistry registry,
+			CacheMetricsProperties properties,
+			Collection<CacheMeterBinderProvider> cacheMeterBinderProviders,
+			Map<String, CacheManager> cacheManagers) {
+		this.registry = registry;
+		this.cacheMeterBinderProviders = cacheMeterBinderProviders;
+		this.properties = properties;
+		this.cacheManagers = cacheManagers;
+	}
+
+	@Bean
+	public CacheMetricsRegistrar cacheMetricsRegistrar() {
+		return new CacheMetricsRegistrar(this.registry,
+				this.properties.getCacheMetricName(), this.cacheMeterBinderProviders);
+	}
+
+	@PostConstruct
+	public void bindCachesToRegistry() {
+		this.cacheManagers.forEach((beanName, cacheManager) -> cacheManager.getCacheNames()
+				.forEach((cacheName) ->
+						bindCacheToRegistry(beanName, cacheManager.getCache(cacheName))));
+	}
+
+	private void bindCacheToRegistry(String beanName, Cache cache) {
+		Tag cacheManagerTag = Tag.of(""cacheManager"", getCacheManagerName(beanName));
+		cacheMetricsRegistrar().bindCacheToRegistry(cache, cacheManagerTag);
+	}
+
+	/**
+	 * Get the name of a {@link CacheManager} based on its {@code beanName}.
+	 * @param beanName the name of the {@link CacheManager} bean
+	 * @return a name for the given cache manager
+	 */
+	private String getCacheManagerName(String beanName) {
+		if (beanName.length() > CACHE_MANAGER_SUFFIX.length()
+				&& StringUtils.endsWithIgnoreCase(beanName, CACHE_MANAGER_SUFFIX)) {
+			return beanName.substring(0,
+					beanName.length() - CACHE_MANAGER_SUFFIX.length());
+		}
+		return beanName;
+	}
+
+}
@@ -215,6 +215,12 @@
       ""description"": ""Whether to enable uptime metrics."",
       ""defaultValue"": true
     },
+    {
+      ""name"": ""management.metrics.cache.instrument-cache"",
+      ""type"": ""java.lang.Boolean"",
+      ""description"": ""Instrument all available caches."",
+      ""defaultValue"": true
+    },
     {
       ""name"": ""management.metrics.export.jmx.enabled"",
       ""type"": ""java.lang.Boolean"",
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
+import org.junit.Test;
+
+import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
+import org.springframework.boot.autoconfigure.AutoConfigurations;
+import org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration;
+import org.springframework.boot.test.context.runner.ApplicationContextRunner;
+import org.springframework.cache.annotation.EnableCaching;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link CacheMetricsConfiguration}.
+ *
+ * @author Stephane Nicoll
+ */
+public class CacheMetricsConfigurationTests {
+
+	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
+			.withUserConfiguration(RegistryConfiguration.class)
+			.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class))
+			.withPropertyValues(""management.metrics.use-global-registry=false"");
+
+	@Test
+	public void autoConfiguredCacheManagerIsInstrumented() {
+		this.contextRunner
+				.withConfiguration(
+						AutoConfigurations.of(CacheAutoConfiguration.class))
+				.withPropertyValues(""spring.cache.type=caffeine"",
+						""spring.cache.cache-names=cache1,cache2"")
+				.run((context) -> {
+					MeterRegistry registry = context.getBean(MeterRegistry.class);
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache1"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isPresent();
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache2"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isPresent();
+				});
+	}
+
+	@Test
+	public void autoConfiguredCacheManagerWithCustomMetricName() {
+		this.contextRunner
+				.withConfiguration(
+						AutoConfigurations.of(CacheAutoConfiguration.class))
+				.withPropertyValues(
+						""management.metrics.cache.cache-metric-name=custom.name"",
+						""spring.cache.type=caffeine"", ""spring.cache.cache-names=cache1"")
+				.run((context) -> {
+					MeterRegistry registry = context.getBean(MeterRegistry.class);
+					assertThat(registry.find(""custom.name.requests"")
+							.tags(""name"", ""cache1"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isPresent();
+				});
+	}
+
+	@Test
+	public void autoConfiguredNonSupportedCacheManagerIsIgnored() {
+		this.contextRunner
+				.withConfiguration(
+						AutoConfigurations.of(CacheAutoConfiguration.class))
+				.withPropertyValues(""spring.cache.type=simple"",
+						""spring.cache.cache-names=cache1,cache2"")
+				.run((context) -> {
+					MeterRegistry registry = context.getBean(MeterRegistry.class);
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache1"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isNotPresent();
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache2"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isNotPresent();
+				});
+	}
+
+	@Test
+	public void cacheInstrumentationCanBeDisabled() {
+		this.contextRunner
+				.withConfiguration(
+						AutoConfigurations.of(CacheAutoConfiguration.class))
+				.withPropertyValues(""management.metrics.cache.instrument-cache=false"",
+						""spring.cache.type=caffeine"", ""spring.cache.cache-names=cache1"")
+				.run((context) -> {
+					MeterRegistry registry = context.getBean(MeterRegistry.class);
+					assertThat(registry.find(""cache.requests"")
+							.tags(""name"", ""cache1"")
+							.tags(""cacheManager"", ""cacheManager"").meter()).isNotPresent();
+				});
+	}
+
+
+	@Configuration
+	@EnableCaching
+	static class RegistryConfiguration {
+
+		@Bean
+		public MeterRegistry meterRegistry() {
+			return new SimpleMeterRegistry();
+		}
+
+	}
+
+}
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.autoconfigure.metrics.cache;
+
+import java.util.Collections;
+
+import com.github.benmanes.caffeine.cache.Caffeine;
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
+import org.junit.Test;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders;
+import org.springframework.cache.caffeine.CaffeineCache;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for {@link CacheMetricsRegistrar}.
+ *
+ * @author Stephane Nicoll
+ */
+public class CacheMetricsRegistrarTests {
+
+	private final MeterRegistry meterRegistry = new SimpleMeterRegistry();
+
+	@Test
+	public void bindToSupportedCache() {
+		CacheMetricsRegistrar registrar = new CacheMetricsRegistrar(this.meterRegistry,
+				""root"", Collections.singleton(
+				new CacheMeterBinderProviders.CaffeineCacheMeterBinderProvider()));
+		assertThat(registrar.bindCacheToRegistry(
+				new CaffeineCache(""test"", Caffeine.newBuilder().build()))).isTrue();
+		assertThat(this.meterRegistry.find(""root.requests"")
+				.tags(""name"", ""test"").meter()).isPresent();
+	}
+
+	@Test
+	public void bindToUnsupportedCache() {
+		CacheMetricsRegistrar registrar = new CacheMetricsRegistrar(this.meterRegistry,
+				""root"", Collections.EMPTY_LIST);
+		assertThat(registrar.bindCacheToRegistry(
+				new CaffeineCache(""test"", Caffeine.newBuilder().build()))).isFalse();
+		assertThat(this.meterRegistry.find(""root.requests"")
+				.tags(""name"", ""test"").meter()).isNotPresent();
+	}
+
+}
@@ -26,6 +26,16 @@
 			<artifactId>jackson-databind</artifactId>
 			<optional>true</optional>
 		</dependency>
+		<dependency>
+			<groupId>com.hazelcast</groupId>
+			<artifactId>hazelcast</artifactId>
+			<optional>true</optional>
+		</dependency>
+		<dependency>
+			<groupId>com.hazelcast</groupId>
+			<artifactId>hazelcast-spring</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>com.sun.mail</groupId>
 			<artifactId>javax.mail</artifactId>
@@ -56,11 +66,21 @@
 			<artifactId>jest</artifactId>
 			<optional>true</optional>
 		</dependency>
+		<dependency>
+			<groupId>javax.cache</groupId>
+			<artifactId>cache-api</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>javax.jms</groupId>
 			<artifactId>javax.jms-api</artifactId>
 			<optional>true</optional>
 		</dependency>
+		<dependency>
+			<groupId>net.sf.ehcache</groupId>
+			<artifactId>ehcache</artifactId>
+			<optional>true</optional>
+		</dependency>
 		<dependency>
 			<groupId>org.apache.tomcat.embed</groupId>
 			<artifactId>tomcat-embed-core</artifactId>
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.metrics.cache;
+
+import io.micrometer.core.instrument.Tag;
+import io.micrometer.core.instrument.binder.MeterBinder;
+
+import org.springframework.cache.Cache;
+
+/**
+ * Provide a {@link MeterBinder} based on a {@link Cache}.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+public interface CacheMeterBinderProvider {
+
+	/**
+	 * Return the {@link MeterBinder} managing the specified {@link Cache} or {@code null}
+	 * if the specified {@link Cache} is not supported.
+	 * @param cache the cache to instrument
+	 * @param name the name prefix of the metrics
+	 * @param tags tags to apply to all recorded metrics
+	 * @return a {@link MeterBinder} handling the specified {@link Cache} or {@code null}
+	 */
+	MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags);
+
+}
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.metrics.cache;
+
+import com.hazelcast.core.IMap;
+import com.hazelcast.spring.cache.HazelcastCache;
+import io.micrometer.core.instrument.Tag;
+import io.micrometer.core.instrument.binder.MeterBinder;
+import io.micrometer.core.instrument.binder.cache.CaffeineCacheMetrics;
+import io.micrometer.core.instrument.binder.cache.EhCache2Metrics;
+import io.micrometer.core.instrument.binder.cache.HazelcastCacheMetrics;
+import io.micrometer.core.instrument.binder.cache.JCacheMetrics;
+
+import org.springframework.cache.Cache;
+import org.springframework.cache.caffeine.CaffeineCache;
+import org.springframework.cache.ehcache.EhCacheCache;
+import org.springframework.cache.jcache.JCacheCache;
+
+/**
+ * Common {@link CacheMeterBinderProvider} implementations.
+ *
+ * @author Stephane Nicoll
+ * @since 2.0.0
+ */
+public abstract class CacheMeterBinderProviders {
+
+	/**
+	 * {@link CacheMeterBinderProvider} implementation for Caffeine.
+	 */
+	public static class CaffeineCacheMeterBinderProvider
+			implements CacheMeterBinderProvider {
+
+		@Override
+		public MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags) {
+			if (cache instanceof CaffeineCache) {
+				return new CaffeineCacheMetrics(
+						((CaffeineCache) cache).getNativeCache(), tags, name);
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * {@link CacheMeterBinderProvider} implementation for EhCache2.
+	 */
+	public static class EhCache2CacheMeterBinderProvider
+			implements CacheMeterBinderProvider {
+
+		@Override
+		public MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags) {
+			if (cache instanceof EhCacheCache) {
+				return new EhCache2Metrics(((EhCacheCache) cache).getNativeCache(),
+						name, tags);
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * {@link CacheMeterBinderProvider} implementation for Hazelcast.
+	 */
+	public static class HazelcastCacheMeterBinderProvider
+			implements CacheMeterBinderProvider {
+
+		@Override
+		public MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags) {
+			if (cache instanceof HazelcastCache) {
+				IMap<Object, Object> nativeCache = (IMap<Object, Object>) ((HazelcastCache) cache).getNativeCache();
+				return new HazelcastCacheMetrics(nativeCache, name, tags);
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * {@link CacheMeterBinderProvider} implementation for JCache.
+	 */
+	public static class JCacheCacheMeterBinderProvider
+			implements CacheMeterBinderProvider {
+		@Override
+		public MeterBinder getMeterBinder(Cache cache, String name, Iterable<Tag> tags) {
+			if (cache instanceof JCacheCache) {
+				return new JCacheMetrics(((JCacheCache) cache).getNativeCache(),
+						name, tags);
+			}
+			return null;
+		}
+	}
+
+}
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2012-2018 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.boot.actuate.metrics.cache;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Collections;
+
+import com.github.benmanes.caffeine.cache.Caffeine;
+import com.hazelcast.core.IMap;
+import com.hazelcast.spring.cache.HazelcastCache;
+import io.micrometer.core.instrument.binder.MeterBinder;
+import io.micrometer.core.instrument.binder.cache.CaffeineCacheMetrics;
+import io.micrometer.core.instrument.binder.cache.EhCache2Metrics;
+import io.micrometer.core.instrument.binder.cache.HazelcastCacheMetrics;
+import io.micrometer.core.instrument.binder.cache.JCacheMetrics;
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.config.CacheConfiguration;
+import net.sf.ehcache.config.Configuration;
+import org.junit.Test;
+
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders.CaffeineCacheMeterBinderProvider;
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders.EhCache2CacheMeterBinderProvider;
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders.HazelcastCacheMeterBinderProvider;
+import org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProviders.JCacheCacheMeterBinderProvider;
+import org.springframework.cache.caffeine.CaffeineCache;
+import org.springframework.cache.concurrent.ConcurrentMapCache;
+import org.springframework.cache.ehcache.EhCacheCache;
+import org.springframework.cache.jcache.JCacheCache;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+
+/**
+ * Tests for {@link CacheMeterBinderProviders}.
+ *
+ * @author Stephane Nicoll
+ */
+public class CacheMeterBinderProvidersTests {
+
+	@Test
+	public void caffeineCacheProvider() {
+		CaffeineCache cache = new CaffeineCache(""test"", Caffeine.newBuilder().build());
+		MeterBinder meterBinder = new CaffeineCacheMeterBinderProvider().getMeterBinder(
+				cache, ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isInstanceOf(CaffeineCacheMetrics.class);
+	}
+
+	@Test
+	public void caffeineCacheProviderWithUnsupportedCache() {
+		MeterBinder meterBinder = new CaffeineCacheMeterBinderProvider().getMeterBinder(
+				new ConcurrentMapCache(""test""), ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isNull();
+	}
+
+	@Test
+	public void ehCache2CacheProvider() {
+		CacheManager cacheManager = new CacheManager(
+				new Configuration().name(""EhCacheCacheTests"").defaultCache(
+						new CacheConfiguration(""default"", 100)));
+		try {
+			Cache nativeCache = new Cache(
+					new CacheConfiguration(""test"", 100));
+			cacheManager.addCache(nativeCache);
+			EhCacheCache cache = new EhCacheCache(nativeCache);
+			MeterBinder meterBinder = new EhCache2CacheMeterBinderProvider().getMeterBinder(
+					cache, ""test"", Collections.EMPTY_LIST);
+			assertThat(meterBinder).isInstanceOf(EhCache2Metrics.class);
+		}
+		finally {
+			cacheManager.shutdown();
+		}
+	}
+
+	@Test
+	public void ehCache2CacheProviderWithUnsupportedCache() {
+		MeterBinder meterBinder = new EhCache2CacheMeterBinderProvider().getMeterBinder(
+				new ConcurrentMapCache(""test""), ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isNull();
+	}
+
+	@Test
+	public void hazelcastCacheProvider() {
+		IMap<Object, Object> nativeCache = mock(IMap.class);
+		given(nativeCache.getName()).willReturn(""test"");
+		HazelcastCache cache = new HazelcastCache(nativeCache);
+		MeterBinder meterBinder = new HazelcastCacheMeterBinderProvider().getMeterBinder(
+				cache, ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isInstanceOf(HazelcastCacheMetrics.class);
+	}
+
+	@Test
+	public void hazelcastCacheProviderWithUnsupportedCache() {
+		MeterBinder meterBinder = new HazelcastCacheMeterBinderProvider().getMeterBinder(
+				new ConcurrentMapCache(""test""), ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isNull();
+	}
+
+	@Test
+	public void jCacheCacheProvider() throws URISyntaxException {
+		javax.cache.CacheManager cacheManager = mock(javax.cache.CacheManager.class);
+		given(cacheManager.getURI()).willReturn(new URI(""/test""));
+		javax.cache.Cache<Object, Object> nativeCache = mock(javax.cache.Cache.class);
+		given(nativeCache.getCacheManager()).willReturn(cacheManager);
+		given(nativeCache.getName()).willReturn(""test"");
+		JCacheCache cache = new JCacheCache(nativeCache);
+		MeterBinder meterBinder = new JCacheCacheMeterBinderProvider().getMeterBinder(
+				cache, ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isInstanceOf(JCacheMetrics.class);
+	}
+
+	@Test
+	public void jCacheCacheWithUnsupportedCache() {
+		MeterBinder meterBinder = new JCacheCacheMeterBinderProvider().getMeterBinder(
+				new ConcurrentMapCache(""test""), ""test"", Collections.EMPTY_LIST);
+		assertThat(meterBinder).isNull();
+	}
+
+}
@@ -1256,6 +1256,8 @@ content into your application. Rather, pick only the properties that you need.
 	management.metrics.binders.logback.enabled=true # Whether to enable Logback metrics.
 	management.metrics.binders.processor.enabled=true # Whether to enable processor metrics.
 	management.metrics.binders.uptime.enabled=true # Whether to enable uptime metrics.
+	management.metrics.cache.cache-metric-name=cache # Name of the metric for cache usage.
+	management.metrics.cache.instrument-cache=true # Instrument all available caches.
 	management.metrics.export.atlas.batch-size= # Number of measurements per request to use for the backend. If more measurements are found, then multiple requests will be made.
 	management.metrics.export.atlas.config-refresh-frequency= # Frequency for refreshing config settings from the LWC service.
 	management.metrics.export.atlas.config-time-to-live= # Time to live for subscriptions from the LWC service.
@@ -1017,6 +1017,30 @@ following information:
 
 
 
+[[production-ready-metrics-cache]]
+=== Cache metrics
+Auto-configuration will enable the instrumentation of all available ``Cache``s on startup
+with a metric named `cache`. The prefix can be customized by using the
+`management.metrics.cache.cache-metric-name` property. Cache instrumentation is specific
+to each cache library, refer to https://micrometer.io/docs[the micrometer documentation]
+for more details.
+
+The following cache libraries are supported:
+
+* Caffeine
+* EhCache 2
+* Hazelcast
+* Any compliant JCache (JSR-107) implementation
+
+Metrics will also be tagged by the name of the `CacheManager` computed based on the bean
+name.
+
+NOTE: Only caches that are available on startup are bound to the registry. For caches
+created on-the-fly or programmatically after the startup phase, an explicit registration
+is required. A `CacheMetricsRegistrar` bean is made available to make that process easier.
+
+
+
 [[production-ready-metrics-jdbc]]
 === DataSource metrics
 Auto-configuration will enable the instrumentation of all available ``DataSource``s with a
",True,"The commit message 'Auto configure micrometer cache metrics' refers to the addition of support for cache metrics in the Micrometer library, which is used for metrics collection in Spring Boot applications. This is done by adding a new configuration class 'CacheMetricsConfiguration' that enables the instrumentation of all available caches on startup with a metric named 'cache'. The prefix can be customized using the 'management.metrics.cache.cache-metric-name' property. This change improves the observability of the application by providing metrics about cache usage.",True,"The commit message 'Auto configure micrometer cache metrics' clearly indicates that the changes are related to configuring metrics for cache usage. The code diff shows that new classes and dependencies related to cache metrics have been added, and existing classes have been modified to include these new features. This suggests that the commit is adding support for cache metrics, which is a common use case for metrics in applications.",True,"The commit message 'Auto configure micrometer cache metrics' and the code diff indicate that the commit is adding support for cache metrics using Micrometer. This is done by importing necessary classes and configurations for various cache providers such as Caffeine, EhCache2, Hazelcast, and JCache. The commit also includes a new configuration property 'management.metrics.cache.cache-metric-name' to customize the name of the metric for cache usage. Additionally, the commit message mentions that it closes an issue, which could provide more context about the necessity of the changes.",True,"The commit message 'Auto configure micrometer cache metrics' indicates that the developer is adding support for cache metrics using the Micrometer library. This is done by importing and configuring classes related to cache metrics, such as CacheMetricsConfiguration, CacheMetricsRegistrarConfiguration, and CacheMeterBinderProviders. These changes are likely necessary to improve the monitoring and observability of the application's caching mechanism, which can be beneficial for debugging and performance optimization.",True,"The commit message 'Auto configure micrometer cache metrics' directly mentions the objective of the change, which is to configure micrometer cache metrics. This implies that the change is likely to improve the monitoring and metrics collection for cache usage in the application.",True,"The commit message 'Auto configure micrometer cache metrics' accurately describes the changes made in the code diff. The diff shows the addition of several classes and dependencies related to cache metrics, such as CacheMetricsConfiguration, CacheMetricsProperties, CacheMetricsRegistrar, and CacheMeterBinderProviders. These additions are specifically for configuring and enabling cache metrics using Micrometer. The message also mentions the closure of an issue, which is a common practice in commit messages to reference related work. Therefore, the commit message effectively summarizes the changes made in the code diff.",True,"The commit message 'Auto configure micrometer cache metrics' and the code diff indicate that the changes are related to configuring metrics for caches. The added classes and configurations are for setting up cache metrics using Micrometer, a metrics instrumentation library. This suggests that the technical principle underpinning the changes is the use of metrics to monitor and understand the behavior of caches in the application.",,,False,"The commit message does not explicitly state the reason for the change, but it can be inferred from the code diff. The commit adds a new import for CacheMetricsConfiguration and CacheAutoConfiguration, which suggests that it is enabling cache metrics for the application. This is a significant change that could have an impact on performance or resource usage, so it would be beneficial to have a commit message that explains this change."
https://github.com/spring-projects/spring-boot/commit/0741c90489c94c7a15a415013301f40f93caae05,Avoid blocking on a Mono indefinitely  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/0741c90489c94c7a15a415013301f40f93caae05,"@@ -16,6 +16,8 @@
 
 package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
 
+import java.time.Duration;
+
 import org.junit.Test;
 
 import org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration;
@@ -63,7 +65,8 @@ public void healthDetailsAlwaysPresent() {
 		this.contextRunner.run((context) -> {
 			CloudFoundryReactiveHealthEndpointWebExtension extension = context
 					.getBean(CloudFoundryReactiveHealthEndpointWebExtension.class);
-			assertThat(extension.health().block().getBody().getDetails()).isNotEmpty();
+			assertThat(extension.health().block(Duration.ofSeconds(30)).getBody()
+					.getDetails()).isNotEmpty();
 		});
 	}
 
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
 
+import java.time.Duration;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
@@ -201,16 +202,17 @@ public void cloudFoundryPathsIgnoredBySpringSecurity() {
 					Boolean cfRequestMatches = filters.get(0)
 							.matches(MockServerWebExchange.from(MockServerHttpRequest
 									.get(""/cloudfoundryapplication/my-path"").build()))
-							.block();
+							.block(Duration.ofSeconds(30));
 					Boolean otherRequestMatches = filters.get(0)
 							.matches(MockServerWebExchange.from(MockServerHttpRequest
 									.get(""/some-other-path"").build()))
-							.block();
+							.block(Duration.ofSeconds(30));
 					assertThat(cfRequestMatches).isTrue();
 					assertThat(otherRequestMatches).isFalse();
-					otherRequestMatches = filters.get(1).matches(MockServerWebExchange
-							.from(MockServerHttpRequest.get(""/some-other-path"").build()))
-							.block();
+					otherRequestMatches = filters.get(1)
+							.matches(MockServerWebExchange.from(MockServerHttpRequest
+									.get(""/some-other-path"").build()))
+							.block(Duration.ofSeconds(30));
 					assertThat(otherRequestMatches).isTrue();
 				});
 
@@ -314,7 +316,7 @@ public void skipSslValidation() {
 					WebClient webClient = (WebClient) ReflectionTestUtils
 							.getField(interceptorSecurityService, ""webClient"");
 					webClient.get().uri(""https://self-signed.badssl.com/"").exchange()
-							.block();
+							.block(Duration.ofSeconds(30));
 				});
 	}
 
@@ -337,7 +339,7 @@ public void sslValidationNotSkippedByDefault() {
 							.getField(interceptorSecurityService, ""webClient"");
 					this.thrown.expectCause(instanceOf(SSLException.class));
 					webClient.get().uri(""https://self-signed.badssl.com/"").exchange()
-							.block();
+							.block(Duration.ofSeconds(30));
 				});
 	}
 
@@ -17,6 +17,7 @@
 package org.springframework.boot.actuate.autoconfigure.health;
 
 import java.security.Principal;
+import java.time.Duration;
 
 import org.junit.Test;
 import reactor.core.publisher.Mono;
@@ -97,8 +98,8 @@ public void regularAndReactiveHealthIndicatorsMatch() {
 					SecurityContext securityContext = mock(SecurityContext.class);
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
-					Health extensionHealth = extension.health(securityContext).block()
-							.getBody();
+					Health extensionHealth = extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody();
 					assertThat(endpointHealth.getDetails())
 							.containsOnlyKeys(""application"", ""first"", ""second"");
 					assertThat(extensionHealth.getDetails())
@@ -111,8 +112,8 @@ public void unauthenticatedUsersAreNotShownDetailsByDefault() {
 		this.contextRunner.run((context) -> {
 			ReactiveHealthEndpointWebExtension extension = context
 					.getBean(ReactiveHealthEndpointWebExtension.class);
-			assertThat(extension.health(mock(SecurityContext.class)).block().getBody()
-					.getDetails()).isEmpty();
+			assertThat(extension.health(mock(SecurityContext.class))
+					.block(Duration.ofSeconds(30)).getBody().getDetails()).isEmpty();
 		});
 	}
 
@@ -123,8 +124,8 @@ public void authenticatedUsersAreNotShownDetailsByDefault() {
 					.getBean(ReactiveHealthEndpointWebExtension.class);
 			SecurityContext securityContext = mock(SecurityContext.class);
 			given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
-			assertThat(extension.health(securityContext).block().getBody().getDetails())
-					.isEmpty();
+			assertThat(extension.health(securityContext).block(Duration.ofSeconds(30))
+					.getBody().getDetails()).isEmpty();
 		});
 	}
 
@@ -139,8 +140,9 @@ public void authenticatedUsersWhenAuthorizedCanBeShownDetails() {
 					SecurityContext securityContext = mock(SecurityContext.class);
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isNotEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isNotEmpty();
 				});
 	}
 
@@ -151,8 +153,8 @@ public void unauthenticatedUsersCanBeShownDetails() {
 				.run((context) -> {
 					ReactiveHealthEndpointWebExtension extension = context
 							.getBean(ReactiveHealthEndpointWebExtension.class);
-					assertThat(extension.health(null).block().getBody().getDetails())
-							.isNotEmpty();
+					assertThat(extension.health(null).block(Duration.ofSeconds(30))
+							.getBody().getDetails()).isNotEmpty();
 				});
 	}
 
@@ -164,8 +166,9 @@ public void detailsCanBeHiddenFromAuthenticatedUsers() {
 					ReactiveHealthEndpointWebExtension extension = context
 							.getBean(ReactiveHealthEndpointWebExtension.class);
 					SecurityContext securityContext = mock(SecurityContext.class);
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isEmpty();
 				});
 	}
 
@@ -180,8 +183,9 @@ public void detailsCanBeHiddenFromUnauthorizedUsers() {
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
 					given(securityContext.isUserInRole(""ACTUATOR"")).willReturn(false);
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isEmpty();
 				});
 	}
 
@@ -196,8 +200,9 @@ public void detailsCanBeShownToAuthorizedUsers() {
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
 					given(securityContext.isUserInRole(""ACTUATOR"")).willReturn(true);
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isNotEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isNotEmpty();
 				});
 	}
 
@@ -212,8 +217,9 @@ public void roleCanBeCustomized() {
 					given(securityContext.getPrincipal())
 							.willReturn(mock(Principal.class));
 					given(securityContext.isUserInRole(""ADMIN"")).willReturn(true);
-					assertThat(extension.health(securityContext).block().getBody()
-							.getDetails()).isNotEmpty();
+					assertThat(extension.health(securityContext)
+							.block(Duration.ofSeconds(30)).getBody().getDetails())
+									.isNotEmpty();
 				});
 	}
 
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.actuate.autoconfigure.security.reactive;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -250,8 +251,8 @@ void matches(String path) {
 		}
 
 		private void matches(ServerWebExchange exchange) {
-			assertThat(this.matcher.matches(exchange).block().isMatch())
-					.as(""Matches "" + getRequestPath(exchange)).isTrue();
+			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30))
+					.isMatch()).as(""Matches "" + getRequestPath(exchange)).isTrue();
 		}
 
 		void doesNotMatch(String path) {
@@ -262,8 +263,9 @@ void doesNotMatch(String path) {
 		}
 
 		private void doesNotMatch(ServerWebExchange exchange) {
-			assertThat(this.matcher.matches(exchange).block().isMatch())
-					.as(""Does not match "" + getRequestPath(exchange)).isFalse();
+			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30))
+					.isMatch()).as(""Does not match "" + getRequestPath(exchange))
+							.isFalse();
 		}
 
 		private TestHttpWebHandlerAdapter webHandler() {
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.actuate.endpoint.web.reactive;
 
+import java.time.Duration;
 import java.util.Arrays;
 
 import org.junit.Rule;
@@ -99,7 +100,8 @@ public void mappingNarrowedToMethod() throws Exception {
 
 	private Object getHandler(ControllerEndpointHandlerMapping mapping, HttpMethod method,
 			String requestURI) {
-		return mapping.getHandler(exchange(method, requestURI)).block();
+		return mapping.getHandler(exchange(method, requestURI))
+				.block(Duration.ofSeconds(30));
 	}
 
 	private ControllerEndpointHandlerMapping createMapping(String prefix,
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.actuate.metrics.web.reactive.server;
 
+import java.time.Duration;
+
 import io.micrometer.core.instrument.MockClock;
 import io.micrometer.core.instrument.simple.SimpleConfig;
 import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
@@ -58,7 +60,7 @@ public void filterAddsTagsToRegistry() {
 		this.webFilter
 				.filter(exchange,
 						(serverWebExchange) -> exchange.getResponse().setComplete())
-				.block();
+				.block(Duration.ofSeconds(30));
 		assertMetricsContainsTag(""uri"", ""/projects/{project}"");
 		assertMetricsContainsTag(""status"", ""200"");
 	}
@@ -74,7 +76,7 @@ public void filterAddsTagsToRegistryForExceptions() {
 				.onErrorResume((t) -> {
 					exchange.getResponse().setStatusCodeValue(500);
 					return exchange.getResponse().setComplete();
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertMetricsContainsTag(""uri"", ""/projects/{project}"");
 		assertMetricsContainsTag(""status"", ""500"");
 		assertMetricsContainsTag(""exception"", ""IllegalStateException"");
@@ -91,7 +93,7 @@ public void filterAddsNonEmptyTagsToRegistryForAnonymousExceptions() {
 				.onErrorResume((t) -> {
 					exchange.getResponse().setStatusCodeValue(500);
 					return exchange.getResponse().setComplete();
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertMetricsContainsTag(""uri"", ""/projects/{project}"");
 		assertMetricsContainsTag(""status"", ""500"");
 		assertMetricsContainsTag(""exception"", anonymous.getClass().getName());
@@ -105,7 +107,7 @@ public void filterAddsTagsToRegistryForExceptionsAndCommittedResponse() {
 			exchange.getResponse().setStatusCodeValue(500);
 			return exchange.getResponse().setComplete()
 					.then(Mono.error(new IllegalStateException(""test error"")));
-		}).onErrorResume((t) -> Mono.empty()).block();
+		}).onErrorResume((t) -> Mono.empty()).block(Duration.ofSeconds(30));
 		assertMetricsContainsTag(""uri"", ""/projects/{project}"");
 		assertMetricsContainsTag(""status"", ""500"");
 	}
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.security.Principal;
+import java.time.Duration;
 import java.util.EnumSet;
 
 import javax.servlet.ServletException;
@@ -68,7 +69,7 @@ public Mono<Void> filter(ServerWebExchange exchange) {
 						return Mono.empty();
 					}
 
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertThat(this.repository.findAll()).hasSize(1);
 	}
 
@@ -82,11 +83,12 @@ public void filterCapturesSessionIdWhenSessionIsUsed()
 
 					@Override
 					public Mono<Void> filter(ServerWebExchange exchange) {
-						exchange.getSession().block().getAttributes().put(""a"", ""alpha"");
+						exchange.getSession().block(Duration.ofSeconds(30))
+								.getAttributes().put(""a"", ""alpha"");
 						return Mono.empty();
 					}
 
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertThat(this.repository.findAll()).hasSize(1);
 		Session session = this.repository.findAll().get(0).getSession();
 		assertThat(session).isNotNull();
@@ -103,11 +105,11 @@ public void filterDoesNotCaptureIdOfUnusedSession()
 
 					@Override
 					public Mono<Void> filter(ServerWebExchange exchange) {
-						exchange.getSession().block();
+						exchange.getSession().block(Duration.ofSeconds(30));
 						return Mono.empty();
 					}
 
-				}).block();
+				}).block(Duration.ofSeconds(30));
 		assertThat(this.repository.findAll()).hasSize(1);
 		Session session = this.repository.findAll().get(0).getSession();
 		assertThat(session).isNull();
@@ -129,11 +131,12 @@ public Mono<Principal> getPrincipal() {
 
 			@Override
 			public Mono<Void> filter(ServerWebExchange exchange) {
-				exchange.getSession().block().getAttributes().put(""a"", ""alpha"");
+				exchange.getSession().block(Duration.ofSeconds(30)).getAttributes()
+						.put(""a"", ""alpha"");
 				return Mono.empty();
 			}
 
-		}).block();
+		}).block(Duration.ofSeconds(30));
 		assertThat(this.repository.findAll()).hasSize(1);
 		org.springframework.boot.actuate.trace.http.HttpTrace.Principal tracedPrincipal = this.repository
 				.findAll().get(0).getPrincipal();
@@ -155,7 +158,7 @@ public Mono<Void> filter(ServerWebExchange exchange) {
 							return Mono.error(new RuntimeException());
 						}
 
-					}).block();
+					}).block(Duration.ofSeconds(30));
 			fail();
 		}
 		catch (Exception ex) {
@@ -17,6 +17,7 @@
 package org.springframework.boot.autoconfigure.freemarker;
 
 import java.io.StringWriter;
+import java.time.Duration;
 import java.util.Locale;
 
 import org.junit.Test;
@@ -60,7 +61,8 @@ public void defaultConfiguration() {
 	public void defaultViewResolution() {
 		this.contextRunner.run((context) -> {
 			MockServerWebExchange exchange = render(context, ""home"");
-			String result = exchange.getResponse().getBodyAsString().block();
+			String result = exchange.getResponse().getBodyAsString()
+					.block(Duration.ofSeconds(30));
 			assertThat(result).contains(""home"");
 			assertThat(exchange.getResponse().getHeaders().getContentType())
 					.isEqualTo(MediaType.TEXT_HTML);
@@ -72,7 +74,8 @@ public void customPrefix() {
 		this.contextRunner.withPropertyValues(""spring.freemarker.prefix:prefix/"")
 				.run((context) -> {
 					MockServerWebExchange exchange = render(context, ""prefixed"");
-					String result = exchange.getResponse().getBodyAsString().block();
+					String result = exchange.getResponse().getBodyAsString()
+							.block(Duration.ofSeconds(30));
 					assertThat(result).contains(""prefixed"");
 				});
 	}
@@ -82,7 +85,8 @@ public void customSuffix() {
 		this.contextRunner.withPropertyValues(""spring.freemarker.suffix:.freemarker"")
 				.run((context) -> {
 					MockServerWebExchange exchange = render(context, ""suffixed"");
-					String result = exchange.getResponse().getBodyAsString().block();
+					String result = exchange.getResponse().getBodyAsString()
+							.block(Duration.ofSeconds(30));
 					assertThat(result).contains(""suffixed"");
 				});
 	}
@@ -93,7 +97,8 @@ public void customTemplateLoaderPath() {
 				""spring.freemarker.templateLoaderPath:classpath:/custom-templates/"")
 				.run((context) -> {
 					MockServerWebExchange exchange = render(context, ""custom"");
-					String result = exchange.getResponse().getBodyAsString().block();
+					String result = exchange.getResponse().getBodyAsString()
+							.block(Duration.ofSeconds(30));
 					assertThat(result).contains(""custom"");
 				});
 	}
@@ -128,7 +133,8 @@ private MockServerWebExchange render(ApplicationContext context, String viewName
 		Mono<View> view = resolver.resolveViewName(viewName, Locale.UK);
 		MockServerWebExchange exchange = MockServerWebExchange
 				.from(MockServerHttpRequest.get(""/path""));
-		view.flatMap((v) -> v.render(null, MediaType.TEXT_HTML, exchange)).block();
+		view.flatMap((v) -> v.render(null, MediaType.TEXT_HTML, exchange))
+				.block(Duration.ofSeconds(30));
 		return exchange;
 	}
 
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.autoconfigure.security.reactive;
 
+import java.time.Duration;
+
 import org.junit.Test;
 import reactor.core.publisher.Mono;
 
@@ -55,8 +57,8 @@ public void configuresADefaultUser() {
 				.run((context) -> {
 					ReactiveUserDetailsService userDetailsService = context
 							.getBean(ReactiveUserDetailsService.class);
-					assertThat(userDetailsService.findByUsername(""user"").block())
-							.isNotNull();
+					assertThat(userDetailsService.findByUsername(""user"")
+							.block(Duration.ofSeconds(30))).isNotNull();
 				});
 	}
 
@@ -67,12 +69,12 @@ public void doesNotConfigureDefaultUserIfUserDetailsServiceAvailable() {
 				.run((context) -> {
 					ReactiveUserDetailsService userDetailsService = context
 							.getBean(ReactiveUserDetailsService.class);
-					assertThat(userDetailsService.findByUsername(""user"").block())
-							.isNull();
-					assertThat(userDetailsService.findByUsername(""foo"").block())
-							.isNotNull();
-					assertThat(userDetailsService.findByUsername(""admin"").block())
-							.isNotNull();
+					assertThat(userDetailsService.findByUsername(""user"")
+							.block(Duration.ofSeconds(30))).isNull();
+					assertThat(userDetailsService.findByUsername(""foo"")
+							.block(Duration.ofSeconds(30))).isNotNull();
+					assertThat(userDetailsService.findByUsername(""admin"")
+							.block(Duration.ofSeconds(30))).isNotNull();
 				});
 	}
 
@@ -93,8 +95,8 @@ public void userDetailsServiceWhenPasswordEncoderAbsentAndDefaultPassword() {
 				.run(((context) -> {
 					MapReactiveUserDetailsService userDetailsService = context
 							.getBean(MapReactiveUserDetailsService.class);
-					String password = userDetailsService.findByUsername(""user"").block()
-							.getPassword();
+					String password = userDetailsService.findByUsername(""user"")
+							.block(Duration.ofSeconds(30)).getPassword();
 					assertThat(password).startsWith(""{noop}"");
 				}));
 	}
@@ -122,8 +124,8 @@ private void testPasswordEncoding(Class<?> configClass, String providedPassword,
 				.run(((context) -> {
 					MapReactiveUserDetailsService userDetailsService = context
 							.getBean(MapReactiveUserDetailsService.class);
-					String password = userDetailsService.findByUsername(""user"").block()
-							.getPassword();
+					String password = userDetailsService.findByUsername(""user"")
+							.block(Duration.ofSeconds(30)).getPassword();
 					assertThat(password).isEqualTo(expectedPassword);
 				}));
 	}
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.autoconfigure.security.reactive;
 
+import java.time.Duration;
+
 import org.assertj.core.api.AssertDelegateTarget;
 import org.junit.Rule;
 import org.junit.Test;
@@ -116,8 +118,8 @@ void matches(String path) {
 		}
 
 		private void matches(ServerWebExchange exchange) {
-			assertThat(this.matcher.matches(exchange).block().isMatch())
-					.as(""Matches "" + getRequestPath(exchange)).isTrue();
+			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30))
+					.isMatch()).as(""Matches "" + getRequestPath(exchange)).isTrue();
 		}
 
 		void doesNotMatch(String path) {
@@ -128,8 +130,9 @@ void doesNotMatch(String path) {
 		}
 
 		private void doesNotMatch(ServerWebExchange exchange) {
-			assertThat(this.matcher.matches(exchange).block().isMatch())
-					.as(""Does not match "" + getRequestPath(exchange)).isFalse();
+			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30))
+					.isMatch()).as(""Does not match "" + getRequestPath(exchange))
+							.isFalse();
 		}
 
 		private TestHttpWebHandlerAdapter webHandler() {
@@ -17,6 +17,7 @@
 package org.springframework.boot.autoconfigure.web.reactive.function.client;
 
 import java.net.URI;
+import java.time.Duration;
 
 import org.junit.Test;
 import reactor.core.publisher.Mono;
@@ -108,8 +109,10 @@ public void shouldGetPrototypeScopedBean() {
 					secondBuilder.clientConnector(secondConnector)
 							.baseUrl(""http://second.example.org"");
 					assertThat(firstBuilder).isNotEqualTo(secondBuilder);
-					firstBuilder.build().get().uri(""/foo"").exchange().block();
-					secondBuilder.build().get().uri(""/foo"").exchange().block();
+					firstBuilder.build().get().uri(""/foo"").exchange()
+							.block(Duration.ofSeconds(30));
+					secondBuilder.build().get().uri(""/foo"").exchange()
+							.block(Duration.ofSeconds(30));
 					verify(firstConnector).connect(eq(HttpMethod.GET),
 							eq(URI.create(""http://first.example.org/foo"")), any());
 					verify(secondConnector).connect(eq(HttpMethod.GET),
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.test.autoconfigure.data.mongo;
 
+import java.time.Duration;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -44,10 +46,11 @@ public class DataMongoTestReactiveIntegrationTests {
 	public void testRepository() {
 		ExampleDocument exampleDocument = new ExampleDocument();
 		exampleDocument.setText(""Look, new @DataMongoTest!"");
-		exampleDocument = this.exampleRepository.save(exampleDocument).block();
+		exampleDocument = this.exampleRepository.save(exampleDocument)
+				.block(Duration.ofSeconds(30));
 		assertThat(exampleDocument.getId()).isNotNull();
-		assertThat(this.mongoTemplate.collectionExists(""exampleDocuments"").block())
-				.isTrue();
+		assertThat(this.mongoTemplate.collectionExists(""exampleDocuments"")
+				.block(Duration.ofSeconds(30))).isTrue();
 	}
 
 }
@@ -19,6 +19,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.URISyntaxException;
+import java.time.Duration;
 import java.util.Arrays;
 
 import io.undertow.Undertow;
@@ -114,7 +115,7 @@ private void testAccessLog(String prefix, String suffix, String expectedFile)
 		Mono<String> result = client.post().uri(""/test"").contentType(MediaType.TEXT_PLAIN)
 				.body(BodyInserters.fromObject(""Hello World"")).exchange()
 				.flatMap((response) -> response.bodyToMono(String.class));
-		assertThat(result.block()).isEqualTo(""Hello World"");
+		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(""Hello World"");
 		File accessLog = new File(accessLogDirectory, expectedFile);
 		awaitFile(accessLog);
 		assertThat(accessLogDirectory.listFiles()).contains(accessLog);
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,8 @@
 
 package org.springframework.boot.web.reactive.result.view;
 
+import java.time.Duration;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -46,12 +48,15 @@ public void init() {
 
 	@Test
 	public void resolveNonExistent() {
-		assertThat(this.resolver.resolveViewName(""bar"", null).block()).isNull();
+		assertThat(
+				this.resolver.resolveViewName(""bar"", null).block(Duration.ofSeconds(30)))
+						.isNull();
 	}
 
 	@Test
 	public void resolveExisting() {
-		assertThat(this.resolver.resolveViewName(""template"", null).block()).isNotNull();
+		assertThat(this.resolver.resolveViewName(""template"", null)
+				.block(Duration.ofSeconds(30))).isNotNull();
 	}
 
 }
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2017 the original author or authors.
+ * Copyright 2012-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package org.springframework.boot.web.reactive.result.view;
 
 import java.nio.charset.StandardCharsets;
+import java.time.Duration;
 import java.util.Collections;
 
 import com.samskivert.mustache.Mustache;
@@ -59,9 +60,9 @@ public void viewResolvesHandlebars() {
 		view.setCharset(StandardCharsets.UTF_8.displayName());
 		view.setApplicationContext(this.context);
 		view.render(Collections.singletonMap(""World"", ""Spring""), MediaType.TEXT_HTML,
-				this.exchange).block();
-		assertThat(this.exchange.getResponse().getBodyAsString().block())
-				.isEqualTo(""Hello Spring"");
+				this.exchange).block(Duration.ofSeconds(30));
+		assertThat(this.exchange.getResponse().getBodyAsString()
+				.block(Duration.ofSeconds(30))).isEqualTo(""Hello Spring"");
 	}
 
 }
@@ -102,7 +102,7 @@ public void specificPort() {
 				.contentType(MediaType.TEXT_PLAIN)
 				.body(BodyInserters.fromObject(""Hello World"")).exchange()
 				.flatMap((response) -> response.bodyToMono(String.class));
-		assertThat(result.block()).isEqualTo(""Hello World"");
+		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(""Hello World"");
 		assertThat(this.webServer.getPort()).isEqualTo(specificPort);
 	}
 
@@ -131,7 +131,7 @@ protected final void testBasicSslWithKeyStore(String keyStore, String keyPasswor
 		Mono<String> result = client.post().uri(""/test"").contentType(MediaType.TEXT_PLAIN)
 				.body(BodyInserters.fromObject(""Hello World"")).exchange()
 				.flatMap((response) -> response.bodyToMono(String.class));
-		assertThat(result.block()).isEqualTo(""Hello World"");
+		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(""Hello World"");
 	}
 
 	protected ReactorClientHttpConnector buildTrustAllSslConnector() {
@@ -187,7 +187,7 @@ protected void testClientAuthSuccess(Ssl sslConfiguration,
 		Mono<String> result = client.post().uri(""/test"").contentType(MediaType.TEXT_PLAIN)
 				.body(BodyInserters.fromObject(""Hello World"")).exchange()
 				.flatMap((response) -> response.bodyToMono(String.class));
-		assertThat(result.block()).isEqualTo(""Hello World"");
+		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(""Hello World"");
 	}
 
 	@Test
@@ -245,15 +245,15 @@ protected WebClient.Builder getWebClient(
 	public void compressionOfResponseToGetRequest() {
 		WebClient client = prepareCompressionTest();
 		ResponseEntity<Void> response = client.get().exchange()
-				.flatMap((res) -> res.toEntity(Void.class)).block();
+				.flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30));
 		assertResponseIsCompressed(response);
 	}
 
 	@Test
 	public void compressionOfResponseToPostRequest() {
 		WebClient client = prepareCompressionTest();
 		ResponseEntity<Void> response = client.post().exchange()
-				.flatMap((res) -> res.toEntity(Void.class)).block();
+				.flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30));
 		assertResponseIsCompressed(response);
 	}
 
@@ -264,7 +264,7 @@ public void noCompressionForSmallResponse() {
 		compression.setMinResponseSize(3001);
 		WebClient client = prepareCompressionTest(compression);
 		ResponseEntity<Void> response = client.get().exchange()
-				.flatMap((res) -> res.toEntity(Void.class)).block();
+				.flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30));
 		assertResponseIsNotCompressed(response);
 	}
 
@@ -274,7 +274,7 @@ public void noCompressionForMimeType() {
 		compression.setMimeTypes(new String[] { ""application/json"" });
 		WebClient client = prepareCompressionTest(compression);
 		ResponseEntity<Void> response = client.get().exchange()
-				.flatMap((res) -> res.toEntity(Void.class)).block();
+				.flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30));
 		assertResponseIsNotCompressed(response);
 	}
 
@@ -285,7 +285,8 @@ public void noCompressionForUserAgent() {
 		compression.setExcludedUserAgents(new String[] { ""testUserAgent"" });
 		WebClient client = prepareCompressionTest(compression);
 		ResponseEntity<Void> response = client.get().header(""User-Agent"", ""testUserAgent"")
-				.exchange().flatMap((res) -> res.toEntity(Void.class)).block();
+				.exchange().flatMap((res) -> res.toEntity(Void.class))
+				.block(Duration.ofSeconds(30));
 		assertResponseIsNotCompressed(response);
 	}
 
@@ -16,6 +16,7 @@
 
 package sample.session;
 
+import java.time.Duration;
 import java.util.Base64;
 
 import org.junit.Test;
@@ -52,17 +53,19 @@ public void userDefinedMappingsSecureByDefault() throws Exception {
 		WebClient webClient = this.webClientBuilder
 				.baseUrl(""http://localhost:"" + this.port + ""/"").build();
 		ClientResponse response = webClient.get().header(""Authorization"", getBasicAuth())
-				.exchange().block();
+				.exchange().block(Duration.ofSeconds(30));
 		assertThat(response.statusCode()).isEqualTo(HttpStatus.OK);
 		ResponseCookie sessionCookie = response.cookies().getFirst(""SESSION"");
-		String sessionId = response.bodyToMono(String.class).block();
+		String sessionId = response.bodyToMono(String.class)
+				.block(Duration.ofSeconds(30));
 		response = webClient.get().cookie(""SESSION"", sessionCookie.getValue()).exchange()
-				.block();
+				.block(Duration.ofSeconds(30));
 		assertThat(response.statusCode()).isEqualTo(HttpStatus.OK);
-		assertThat(response.bodyToMono(String.class).block()).isEqualTo(sessionId);
+		assertThat(response.bodyToMono(String.class).block(Duration.ofSeconds(30)))
+				.isEqualTo(sessionId);
 		Thread.sleep(2000);
 		response = webClient.get().cookie(""SESSION"", sessionCookie.getValue()).exchange()
-				.block();
+				.block(Duration.ofSeconds(30));
 		assertThat(response.statusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
 	}
 
",True,"The commit message 'Avoid blocking on a Mono indefinitely' refers to the necessity of changes by mentioning the issue of blocking on a Mono indefinitely, which can lead to potential deadlocks or timeouts. This is a common issue in reactive programming, and the changes made in the code diff are adding a timeout to the block() method calls to avoid this issue.",True,The commit message 'Avoid blocking on a Mono indefinitely' clearly describes the necessity of the changes made in the code diff. The changes are made to prevent the application from blocking indefinitely when waiting for a Mono to complete. This is a common issue in reactive programming and the commit message effectively communicates the problem and the solution.,True,"The commit message 'Avoid blocking on a Mono indefinitely' clearly explains the necessity of the changes by mentioning the potential issue of blocking indefinitely on a Mono, which could lead to application hangs or timeouts. The code diff also shows that the changes involve adding a timeout to the Mono block operations, which directly addresses this issue.",True,"The commit message 'Avoid blocking on a Mono indefinitely' indicates that the developer is addressing a potential issue with the code. In the code diff, the developer has added a timeout to the block() method calls to avoid blocking indefinitely. This change is likely made to improve the performance and stability of the application.",True,"The commit message 'Avoid blocking on a Mono indefinitely' directly mentions the change that is being made to the code, which is to avoid blocking indefinitely on a Mono by specifying a timeout duration.",True,The commit message 'Avoid blocking on a Mono indefinitely' accurately describes the change made in the code diff. The change involves adding a timeout to the block() method calls on Mono instances to prevent indefinite blocking. This is a significant change that addresses a potential issue with the previous implementation.,False,"The commit message does not explicitly describe a technical principle underpinning the changes. It only mentions avoiding blocking on a Mono indefinitely, which is a technical solution to a problem, not a principle.",True,"The commit message 'Avoid blocking on a Mono indefinitely' accurately describes the functional change made in the code. The code diff shows that the block() method is being replaced with block(Duration.ofSeconds(30)) to avoid indefinite blocking. This change ensures that the Mono completes within a specified timeout, preventing potential deadlocks or performance issues.",False,"The commit message does not explicitly explain the reason for the change, but it can be inferred from the code diff. The change is adding a timeout to block() calls to prevent potential blocking indefinitely. This is a good practice to avoid blocking in a reactive application."
https://github.com/spring-projects/spring-boot/commit/0a55e3e7365a44d2b1986954912f938be5a77398,Polish 'Clarify edge case docs on ConditionalOnClass'  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/0a55e3e7365a44d2b1986954912f938be5a77398,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2015 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -36,14 +36,11 @@
 public @interface ConditionalOnClass {
 
 	/**
-	 * <p>
-	 * The classes that must be present. Since this annotation parsed by loading class
-	 * bytecode it is safe to specify classes here that may ultimately not be on the
+	 * The classes that must be present. Since this annotation is parsed by loading class
+	 * bytecode, it is safe to specify classes here that may ultimately not be on the
 	 * classpath, only if this annotation is directly on the affected component and
-	 * <b>not</b> if this annotation is used as a composed, meta-annotation. If this
-	 * is used as a meta annotation and the given class is not available at runtime
-	 * then this {@link @Conditional} will effectively be ignored. In order to use
-	 * this annotation as a meta-annotation, only use the {@link #name} attribute.
+	 * <b>not</b> if this annotation is used as a composed, meta-annotation. In order to
+	 * use this annotation as a meta-annotation, only use the {@link #name} attribute.
 	 * @return the classes that must be present
 	 */
 	Class<?>[] value() default {};
@@ -5839,16 +5839,18 @@ code by annotating `@Configuration` classes or individual `@Bean` methods.
 [[boot-features-class-conditions]]
 ==== Class conditions
 The `@ConditionalOnClass` and `@ConditionalOnMissingClass` annotations allows
-configuration to be included based on the presence or absence of specific classes.
-If you are using the `@ConditionalOnClass` annotation directly on the class you are conditionally
-registering, you can actually use the `value` attribute to refer to the real class,
-even though that class might not actually appear on the running application classpath.
-This is due to the fact that annotation metadata directly on a class is parsed
-using http://asm.ow2.org/[ASM]. You can also use the `name` attribute if you prefer to
-specify the class name using a `String` value, which is required if you are using
-`@ConditionalOnClass` or `@ConditionalOnMissingClass` as apart of a meta-annotation to
-compose your own composed annotations or in an `@Bean` method as neither of these cases
-are handled by ASM.
+configuration to be included based on the presence or absence of specific classes. Due to
+the fact that annotation metadata is parsed using http://asm.ow2.org/[ASM] you can
+actually use the `value` attribute to refer to the real class, even though that class
+might not actually appear on the running application classpath. You can also use the
+`name` attribute if you prefer to specify the class name using a `String` value.
+
+[TIP]
+====
+If you are using `@ConditionalOnClass` or `@ConditionalOnMissingClass` as apart of a
+meta-annotation to compose your own composed annotations you must use `name` as referring
+to the class in such a case is not handled.
+====
 
 
 
",True,"The commit message 'Polish 'Clarify edge case docs on ConditionalOnClass'' refers to the necessity of changes by clarifying the documentation of the ConditionalOnClass annotation. Specifically, it mentions the use of the value attribute to refer to the real class, even if it's not on the classpath, which is a convention or standard that the commit message is explaining. This clarification improves the prior documentation and makes it more understandable for users.",True,"The commit message 'Polish 'Clarify edge case docs on ConditionalOnClass'' does not explicitly state the necessity of the changes, but it is clear from the diff that the changes are made to improve the documentation. This is a common practice and the necessity of the changes is easily inferred from the context.",True,"The commit message 'Polish 'Clarify edge case docs on ConditionalOnClass'' does contain an expression that describes the necessity of changes. The changes made to the documentation clarify an edge case scenario where the `@ConditionalOnClass` annotation is used directly on the class being conditionally registered, but the specified class might not be on the running application classpath. This scenario is explained in the updated documentation to provide a clearer understanding of the annotation's behavior.",True,"The commit message 'Polish 'Clarify edge case docs on ConditionalOnClass'' does not explicitly mention the necessity of changes, but the diff suggests that the changes were made to clarify the documentation about the ConditionalOnClass annotation. This could imply that there was a problem in the process of software maintenance, specifically out-of-date or unclear documentation.",True,"The commit message 'Polish 'Clarify edge case docs on ConditionalOnClass'' indicates that the change is aimed at improving the documentation of the code. Specifically, it mentions clarifying edge case documentation for the 'ConditionalOnClass' annotation. The code diff shows changes to the documentation of this annotation, which suggests that the commit message accurately describes the objective of the change.",True,"The commit message 'Polish 'Clarify edge case docs on ConditionalOnClass'' does contain an expression that describes a summary of what changes by being a summary of the diffs. The message focuses on clarifying the documentation for the 'ConditionalOnClass' annotation, which is the key component of the change. The diff shows modifications to the documentation, specifically updating the explanation of how the annotation is parsed using ASM and adding a note about using the 'name' attribute when composing annotations.",True,"The commit message and the code diff both refer to the use of the `@ConditionalOnClass` annotation, which allows configuration to be included based on the presence or absence of specific classes. The code diff explains how this annotation works by mentioning that it is parsed using ASM, which allows the `value` attribute to refer to the real class even if it's not on the classpath. This is a technical principle underpinning the changes, as it explains how the annotation works and when it can be used.",True,"The commit message 'Polish 'Clarify edge case docs on ConditionalOnClass'' does express a change in the documentation, specifically clarifying the behavior of the @ConditionalOnClass annotation when used as a meta-annotation. The code diff shows changes in the documentation that explain how the annotation can be used with classes that may not be on the classpath, but only if it is directly on the affected component. This change in documentation introduces new behaviors and clarifies existing ones, making it a descriptive summary of the changes.",False,"The commit message does not explicitly explain the reason for the change, even though it can be inferred from the code diff. The change is not just a simple typo or formatting issue, but rather a clarification of the documentation for the ConditionalOnClass annotation. The explanation in the documentation has been updated to reflect that the annotation is parsed using ASM, which affects how classes can be referred to in the annotation. This is a significant change that warrants an explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/0f9e8315bca4e3c8be824c2c1a1b7ec6defdc734,Replace use of deprecated Reactor MonoProcessor in tests  <enter> Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/0f9e8315bca4e3c8be824c2c1a1b7ec6defdc734,"@@ -45,7 +45,6 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Mono;
-import reactor.core.publisher.MonoProcessor;
 import reactor.core.publisher.Sinks;
 import reactor.netty.NettyPipeline;
 import reactor.netty.http.client.HttpClient;
@@ -499,7 +498,7 @@ public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response)
 
 	protected static class BlockingHandler implements HttpHandler {
 
-		private final BlockingQueue<MonoProcessor<Void>> processors = new ArrayBlockingQueue<>(10);
+		private final BlockingQueue<Sinks.Empty<Void>> processors = new ArrayBlockingQueue<>(10);
 
 		private volatile boolean blocking = true;
 
@@ -510,17 +509,17 @@ public BlockingHandler() {
 		@Override
 		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
 			if (this.blocking) {
-				Sinks.One<Void> completion = Sinks.one();
-				this.processors.add(MonoProcessor.fromSink(completion));
+				Sinks.Empty<Void> completion = Sinks.empty();
+				this.processors.add(completion);
 				return completion.asMono().then(Mono.empty());
 			}
 			return Mono.empty();
 		}
 
 		public void completeOne() {
 			try {
-				MonoProcessor<Void> processor = this.processors.take();
-				processor.onComplete();
+				Sinks.Empty<Void> processor = this.processors.take();
+				processor.tryEmitEmpty();
 			}
 			catch (InterruptedException ex) {
 				Thread.currentThread().interrupt();
@@ -535,7 +534,7 @@ public void awaitQueue() throws InterruptedException {
 
 		public void stopBlocking() {
 			this.blocking = false;
-			this.processors.forEach(MonoProcessor::onComplete);
+			this.processors.forEach(Sinks.Empty::tryEmitEmpty);
 		}
 
 	}
",True,"The commit message refers to the use of deprecated Reactor MonoProcessor in tests, which is a convention that should be followed to ensure the codebase is up-to-date and adheres to best practices. The message also mentions that it fixes a specific issue, which implies that there was a problem with the previous implementation that needed to be addressed.",True,"The commit message 'Replace use of deprecated Reactor MonoProcessor in tests' clearly explains the necessity of the changes. The code diff shows that the deprecated MonoProcessor class is being replaced with Sinks.Empty in the tests. This is a common practice to ensure that the codebase is up-to-date and adheres to best practices, as using deprecated classes can lead to issues in the future.",True,"The commit message 'Replace use of deprecated Reactor MonoProcessor in tests' directly elaborates the motivation of the code change. It mentions that the deprecated Reactor MonoProcessor is being replaced in the tests, which implies that the previous implementation was not up-to-date or was using an outdated feature. This could potentially lead to issues or errors in the future, so the change is necessary to ensure the tests continue to function correctly.",True,"The commit message 'Replace use of deprecated Reactor MonoProcessor in tests' indicates that the changes were made due to the deprecation of the Reactor MonoProcessor in the tests. This is a problem in the process of software maintenance, specifically outdated code, as the developer is updating the code to use a newer, non-deprecated version of the library.",True,"The commit message directly mentions the issue it fixes by stating 'Replace use of deprecated Reactor MonoProcessor in tests' and providing a link to the issue. This clearly indicates that the change is made to address a specific problem, which is the use of a deprecated class in the tests.",True,"The commit message 'Replace use of deprecated Reactor MonoProcessor in tests' accurately summarizes the changes made in the code diff. It points out the key component of the change, which is the replacement of the deprecated Reactor MonoProcessor with Sinks.Empty. The message also contrasts the before and after by mentioning the use of MonoProcessor before and Sinks.Empty after the change.",True,"The commit message explains that the changes are made to replace the use of deprecated Reactor MonoProcessor with Sinks.Empty in the tests. This is a technical principle that shows the importance of keeping the code up-to-date and using the latest, non-deprecated libraries or methods to ensure the codebase remains maintainable and functional.",True,"The commit message 'Replace use of deprecated Reactor MonoProcessor in tests' clearly describes the changes made in the code. It explains that the deprecated MonoProcessor class is being replaced with Sinks.Empty in the tests. This change is functional as it updates the code to use a more recent and recommended approach, while maintaining the same behavior.",False,"The commit message does not explicitly state the reason for the change, but it does mention that the deprecated Reactor MonoProcessor is being replaced with Sinks.Empty. While the reason for this change can be inferred from the code diff, it's still beneficial to have an explanation in the commit message for clarity and future reference."
https://github.com/spring-projects/spring-boot/commit/11b7fd832d15856244bcaf3b1ec031e9eb1b6dc6,"Report non-matching outer class conditions  <enter> Update ConditionEvaluationReport so that, whenever a negative outcome is added for a source, any existing outcomes for inner classes of that source are updated with a non-matching outcome that indicates that the outer configuration did not match. <enter> Conditions are evaluated in two phases; PARSE_CONFIGURATION first and REGISTER_BEAN second. If a parent class’s conditions match in PARSE_CONFIGURATION then its inner classes will have their PARSE_CONFIGURATION conditions evaluated. If they all match, the inner class will be reported as a positive match in the auto-configuration report even if the outer class does not match as a result of the subsequent evaluation of a REGISTER_BEAN condition. <enter>  Fixes   <issue_link> ",https://api.github.com/repos/spring-projects/spring-boot/commits/11b7fd832d15856244bcaf3b1ec031e9eb1b6dc6,"@@ -20,13 +20,16 @@
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
 
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
 import org.springframework.context.annotation.Condition;
+import org.springframework.context.annotation.ConditionContext;
+import org.springframework.core.type.AnnotatedTypeMetadata;
 import org.springframework.util.Assert;
 import org.springframework.util.ObjectUtils;
 
@@ -36,13 +39,18 @@
  * @author Greg Turnquist
  * @author Dave Syer
  * @author Phillip Webb
+ * @author Andy Wilkinson
  */
 public class ConditionEvaluationReport {
 
 	private static final String BEAN_NAME = ""autoConfigurationReport"";
 
+	private static final AncestorsMatchedCondition ANCESTOR_CONDITION = new AncestorsMatchedCondition();
+
 	private final SortedMap<String, ConditionAndOutcomes> outcomes = new TreeMap<String, ConditionAndOutcomes>();
 
+	private boolean addedAncestorOutcomes;
+
 	private ConditionEvaluationReport parent;
 
 	/**
@@ -67,16 +75,36 @@ public void recordConditionEvaluation(String source, Condition condition,
 			this.outcomes.put(source, new ConditionAndOutcomes());
 		}
 		this.outcomes.get(source).add(condition, outcome);
+		this.addedAncestorOutcomes = false;
 	}
 
 	/**
 	 * Returns condition outcomes from this report, grouped by the source.
 	 * @return the condition outcomes
 	 */
 	public Map<String, ConditionAndOutcomes> getConditionAndOutcomesBySource() {
+		if (!this.addedAncestorOutcomes) {
+			for (Map.Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {
+				if (!entry.getValue().isFullMatch()) {
+					addNoMatchOutcomeToAncestors(entry.getKey());
+				}
+			}
+			this.addedAncestorOutcomes = true;
+		}
 		return Collections.unmodifiableMap(this.outcomes);
 	}
 
+	private void addNoMatchOutcomeToAncestors(String source) {
+		String prefix = source + ""$"";
+		for (Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {
+			if (entry.getKey().startsWith(prefix)) {
+				ConditionOutcome outcome = new ConditionOutcome(false, ""Ancestor '""
+						+ source + ""' did not match"");
+				entry.getValue().add(ANCESTOR_CONDITION, outcome);
+			}
+		}
+	}
+
 	/**
 	 * The parent report (from a parent BeanFactory if there is one).
 	 * @return the parent report (or null if there isn't one)
@@ -186,6 +214,20 @@ public boolean equals(Object obj) {
 		public int hashCode() {
 			return this.condition.getClass().hashCode() * 31 + this.outcome.hashCode();
 		}
+
+		@Override
+		public String toString() {
+			return this.condition.getClass() + "" "" + this.outcome;
+		}
+	}
+
+	private static class AncestorsMatchedCondition implements Condition {
+
+		@Override
+		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
+			throw new UnsupportedOperationException();
+		}
+
 	}
 
 }
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2013 the original author or authors.
+ * Copyright 2012-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -26,16 +26,23 @@
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-import org.springframework.beans.factory.annotation.Configurable;
 import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
 import org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.ConditionAndOutcome;
 import org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.ConditionAndOutcomes;
 import org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration;
 import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;
+import org.springframework.boot.test.EnvironmentTestUtils;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Condition;
+import org.springframework.context.annotation.ConditionContext;
+import org.springframework.context.annotation.Conditional;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.ConfigurationCondition;
 import org.springframework.context.annotation.Import;
+import org.springframework.core.type.AnnotatedTypeMetadata;
+import org.springframework.util.ClassUtils;
 
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.equalTo;
@@ -51,7 +58,7 @@
  * @author Greg Turnquist
  * @author Phillip Webb
  */
-public class AutoConfigurationReportTests {
+public class ConditionEvaluationReportTests {
 
 	private DefaultListableBeanFactory beanFactory;
 
@@ -225,6 +232,23 @@ public void duplicateOutcomes() {
 		context.close();
 	}
 
+	@Test
+	public void negativeOuterPositiveInnerBean() throws Exception {
+		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
+		EnvironmentTestUtils.addEnvironment(context, ""test.present=true"");
+		context.register(NegativeOuterConfig.class);
+		context.refresh();
+		ConditionEvaluationReport report = ConditionEvaluationReport.get(context
+				.getBeanFactory());
+		Map<String, ConditionAndOutcomes> sourceOutcomes = report
+				.getConditionAndOutcomesBySource();
+		assertThat(context.containsBean(""negativeOuterPositiveInnerBean""), equalTo(false));
+		String negativeConfig = NegativeOuterConfig.class.getName();
+		assertThat(sourceOutcomes.get(negativeConfig).isFullMatch(), equalTo(false));
+		String positiveConfig = NegativeOuterConfig.PositiveInnerConfig.class.getName();
+		assertThat(sourceOutcomes.get(positiveConfig).isFullMatch(), equalTo(false));
+	}
+
 	private int getNumberOfOutcomes(ConditionAndOutcomes outcomes) {
 		Iterator<ConditionAndOutcome> iterator = outcomes.iterator();
 		int numberOfOutcomesAdded = 0;
@@ -235,16 +259,89 @@ private int getNumberOfOutcomes(ConditionAndOutcomes outcomes) {
 		return numberOfOutcomesAdded;
 	}
 
-	@Configurable
+	@Configuration
 	@Import(WebMvcAutoConfiguration.class)
 	static class Config {
 
 	}
 
-	@Configurable
+	@Configuration
 	@Import(MultipartAutoConfiguration.class)
 	static class DuplicateConfig {
 
 	}
 
+	@Configuration
+	@Conditional({ ConditionEvaluationReportTests.MatchParseCondition.class,
+			ConditionEvaluationReportTests.NoMatchBeanCondition.class })
+	public static class NegativeOuterConfig {
+
+		@Configuration
+		@Conditional({ ConditionEvaluationReportTests.MatchParseCondition.class })
+		public static class PositiveInnerConfig {
+
+			@Bean
+			public String negativeOuterPositiveInnerBean() {
+				return ""negativeOuterPositiveInnerBean"";
+			}
+
+		}
+	}
+
+	static class TestMatchCondition extends SpringBootCondition implements
+			ConfigurationCondition {
+
+		private final ConfigurationPhase phase;
+		private final boolean match;
+
+		public TestMatchCondition(ConfigurationPhase phase, boolean match) {
+			this.phase = phase;
+			this.match = match;
+		}
+
+		@Override
+		public ConfigurationPhase getConfigurationPhase() {
+			return this.phase;
+		}
+
+		@Override
+		public ConditionOutcome getMatchOutcome(ConditionContext context,
+				AnnotatedTypeMetadata metadata) {
+			return new ConditionOutcome(this.match, ClassUtils.getShortName(getClass()));
+		}
+
+	}
+
+	static class MatchParseCondition extends TestMatchCondition {
+
+		public MatchParseCondition() {
+			super(ConfigurationPhase.PARSE_CONFIGURATION, true);
+		}
+
+	}
+
+	static class MatchBeanCondition extends TestMatchCondition {
+
+		public MatchBeanCondition() {
+			super(ConfigurationPhase.REGISTER_BEAN, true);
+		}
+
+	}
+
+	static class NoMatchParseCondition extends TestMatchCondition {
+
+		public NoMatchParseCondition() {
+			super(ConfigurationPhase.PARSE_CONFIGURATION, false);
+		}
+
+	}
+
+	static class NoMatchBeanCondition extends TestMatchCondition {
+
+		public NoMatchBeanCondition() {
+			super(ConfigurationPhase.REGISTER_BEAN, false);
+		}
+
+	}
+
 }
",True,"The commit message refers to the necessity of changes by explaining the issue with the current implementation. It mentions that if a parent class's conditions match in PARSE_CONFIGURATION, then its inner classes will have their PARSE_CONFIGURATION conditions evaluated. However, if the outer class does not match as a result of the subsequent evaluation of a REGISTER_BEAN condition, the inner class will still be reported as a positive match in the auto-configuration report. This is undesirable, as the commit message explains that the inner class should also be reported as a non-matching outcome. The commit message also references the issue that it is fixing, which adds to the explanation of the necessity of the changes.",True,"The commit message explains the necessity of changes by stating that it is updating the ConditionEvaluationReport to handle a specific scenario where a negative outcome is added for a source, and any existing outcomes for inner classes of that source are updated with a non-matching outcome. This is not a common sense or easy to infer change, as it involves modifying the behavior of the ConditionEvaluationReport to handle a specific edge case.",True,"The commit message directly elaborates the motivation of the code change by explaining the issue scenario. It mentions that the code change is to update the ConditionEvaluationReport so that whenever a negative outcome is added for a source, any existing outcomes for inner classes of that source are updated with a non-matching outcome. This is done to indicate that the outer configuration did not match, even if the inner classes did. This is a clear and direct explanation of the necessity of the changes and the problem it solves.",True,"The commit message describes the necessity of changes by mentioning the problem in the process of software maintenance. Specifically, it mentions that there is a situation where the inner class conditions match during PARSE_CONFIGURATION, but the outer class does not match during REGISTER_BEAN evaluation, leading to incorrect reporting. This is a clear indication of a requirement for software development to fix the issue.",True,"The commit message directly mentions the issue it fixes, which is the scenario where a negative outcome is added for a source, and any existing outcomes for inner classes of that source are updated with a non-matching outcome. This change is made to ensure that the inner class is not reported as a positive match in the auto-configuration report even if the outer class does not match due to the subsequent evaluation of a REGISTER_BEAN condition.",True,"The commit message 'Report non-matching outer class conditions' accurately summarizes the change made in the code diff. It highlights the key component of the change, which is updating the ConditionEvaluationReport to handle situations where a negative outcome is added for a source, and any existing outcomes for inner classes of that source are updated with a non-matching outcome. This effectively addresses the issue where inner classes could be reported as a positive match even if the outer class did not match due to the subsequent evaluation of a REGISTER_BEAN condition.",True,"The commit message explains the technical principle that if a parent class's conditions match in the PARSE_CONFIGURATION phase, but the outer class does not match in the REGISTER_BEAN phase, any inner classes that matched in PARSE_CONFIGURATION should be updated with a non-matching outcome to indicate that the outer configuration did not match.",True,"The commit message 'Report non-matching outer class conditions' describes the changes made to the code. It explains that the update to ConditionEvaluationReport ensures that whenever a negative outcome is added for a source, any existing outcomes for inner classes of that source are updated with a non-matching outcome. This is done to indicate that the outer configuration did not match. The message clearly explains the new behavior introduced by the code changes, which is a significant improvement in the functionality of the ConditionEvaluationReport class.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: to ensure that whenever a negative outcome is added for a source, any existing outcomes for inner classes of that source are updated with a non-matching outcome that indicates that the outer configuration did not match. This is necessary because conditions are evaluated in two phases, and if a parent class’s conditions match in the first phase, its inner classes will have their first phase conditions evaluated. If they all match, the inner class will be reported as a positive match in the auto-configuration report even if the outer class does not match as a result of the subsequent evaluation of a second phase condition."
https://github.com/spring-projects/spring-boot/commit/14bd404b71fcb967d4af282e839a763112ecd40c,Document AWS Elastic Beanstalk deployment  <enter> Update the reference documentation to include details of Amazon Elastic Beanstalk. <enter>  Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/14bd404b71fcb967d4af282e839a763112ecd40c,"@@ -294,6 +294,88 @@ run the app.
 
 
 
+[[cloud-deployment-aws]]
+=== Amazon Web Services (AWS)
+Amazon Web Services offers multiple ways to install Spring Boot based applications, either
+as traditional web applications (war) or as executable jar files with an embedded web
+server. Options include :
+
+* AWS Elastic Beanstalk
+* AWS Code Deploy
+* AWS OPS Works
+* AWS Cloud Formation
+* AWS Container Registry
+
+Each has different features and pricing model, here we will describe only the simplest
+option : AWS Elastic Beanstalk.
+
+
+
+==== AWS Elastic Beanstalk
+As described in the official http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html[Elastic
+Beanstalk Java guide], there are two main options to deploy a Java application; You can
+either us the ""`Tomcat Platform`"" or the ""`Java SE platform`"".
+
+
+
+===== Using the Tomcat platform
+This option applies to Spring Boot projects producing a war file. There is no any special
+configuration required, just follow the official guide.
+
+
+
+===== Using the Java SE platform
+This option applies to Spring Boot projects producing a jar file and running an embedded
+web container. Elastic Beanstalk environments run an nginx instance on port 80 to proxy
+the actual application, running on port 5000. To configure it, add the following to your
+`application.properties`:
+
+[indent=0]
+----
+	server.port=5000
+----
+
+
+
+===== Best practices
+
+====== Uploading binaries instead of sources
+By default Elastic Beanstalk uploads sources and compile them in AWS. To upload the
+binaries instead, add the following to your `.elasticbeanstalk/config.yml` file:
+
+
+
+[source,xml,indent=0,subs=""verbatim,quotes,attributes""]
+----
+	deploy:
+		artifact: target/demo-0.0.1-SNAPSHOT.jar
+----
+
+
+
+====== Reduce costs by setting the environment type
+By default an Elastic Beanstalk environment is load balanced. The load balancer has a cost
+perspective, to avoid it, set the environment type to ""`Single instance`"" as described
+http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity[in the Amazon documentation].
+Single instance environments can be created using the CLI as well using the following
+command:
+
+[indent=0]
+----
+	eb create -s
+----
+
+
+
+==== Summary
+This is one of the easiest way to get to AWS, but there are more things
+to cover, e.g.: how to integrate Elastic Beanstalk into any CI / CD tool, using the
+Elastic Beanstalk maven plugin instead of the CLI, etc. There is a
+https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/[blog]
+covering these topics more in detail.
+
+
+
 [[cloud-deployment-boxfuse]]
 === Boxfuse and Amazon Web Services
 https://boxfuse.com/[Boxfuse] works by turning your Spring Boot executable jar or war
",True,"The commit message refers to the necessity of changes by referencing a standard, in this case, the need to update the reference documentation to include details of Amazon Elastic Beanstalk. This is done to improve the documentation and provide more information to users about the deployment options available on AWS.",True,"The commit message 'Document AWS Elastic Beanstalk deployment' clearly describes the necessity of the changes, which is to update the reference documentation to include details about Amazon Elastic Beanstalk. This is not a trivial change, as it involves adding new information about a specific deployment option for Spring Boot applications. The code diff also supports this, as it shows the addition of a new section about AWS Elastic Beanstalk in the documentation.",True,"The commit message 'Document AWS Elastic Beanstalk deployment' clearly describes the changes made to the reference documentation, which is to include details about Amazon Elastic Beanstalk. This indicates that the commit is not just a random change, but rather a necessary update to the documentation. Additionally, the diff shows that the documentation has been expanded to include detailed information about AWS Elastic Beanstalk, its features, pricing model, and best practices for deployment. This elaborates on the motivation for the change, as it provides valuable information to users about how to deploy their Spring Boot applications on AWS Elastic Beanstalk.",True,"The commit message 'Document AWS Elastic Beanstalk deployment' indicates that the changes were made to provide additional information about Amazon Elastic Beanstalk, which is a service offered by AWS for deploying and scaling applications. This could be seen as a requirement from users who are interested in deploying their Spring Boot applications on AWS, and the documentation update could help address this need.",True,"The commit message 'Document AWS Elastic Beanstalk deployment' directly mentions the improvement made to the code, which is the addition of detailed documentation about Amazon Elastic Beanstalk. This includes details about the different deployment options, best practices, and how to integrate Elastic Beanstalk into a CI/CD tool. The code diff also supports this, as it shows the addition of extensive documentation about AWS Elastic Beanstalk.",True,"The commit message 'Document AWS Elastic Beanstalk deployment' accurately summarizes the changes made in the diff. The diff shows the addition of detailed documentation about Amazon Elastic Beanstalk, including its features, pricing model, deployment options, best practices, and a summary. The message reflects this by mentioning the update of reference documentation to include details of Amazon Elastic Beanstalk.",True,"The commit message and the diff both describe the technical principle underpinning the changes, which is documenting the deployment of a Spring Boot application on AWS Elastic Beanstalk. The diff specifically mentions the use of the Tomcat platform and the Java SE platform for deployment, as well as best practices such as uploading binaries instead of sources and reducing costs by setting the environment type.",True,"The commit message 'Document AWS Elastic Beanstalk deployment' accurately summarizes the changes made in the code diff. The diff adds a new section about AWS Elastic Beanstalk, which is a service offered by Amazon Web Services for deploying and scaling applications. The section explains how to deploy a Java application using Elastic Beanstalk, including the two main options ('Tomcat Platform' and 'Java SE platform'), best practices for deployment, and a summary of the process. The message does not only describe a renaming or a change that only applies to JSON, but it also explains the new behavior introduced by the addition of the AWS Elastic Beanstalk documentation.",False,The commit message does not lack an explanation. It clearly states that the documentation is being updated to include details about Amazon Elastic Beanstalk. The code diff also supports this explanation by showing the addition of detailed documentation about AWS Elastic Beanstalk.
https://github.com/spring-projects/spring-boot/commit/1c0bcc13cfa3aa00a8fea96e2ecb2e1867859a96,Set UserDetailsService in default AuthenticationManagerBuilder  <enter> Only affects the default AuthenticationManagerBuilder (so when users are not overriding the default global user details). Makes the UserDetailsService effectively available as it would be if we used AuthenticationManagerBuilder.inMemoryAuthentication() as a shared object in the HttpSecurity. <enter>  Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/1c0bcc13cfa3aa00a8fea96e2ecb2e1867859a96,"@@ -16,6 +16,7 @@
 
 package org.springframework.boot.autoconfigure.security;
 
+import java.lang.reflect.Field;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
@@ -46,6 +47,7 @@
 import org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;
 import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer;
 import org.springframework.stereotype.Component;
+import org.springframework.util.ReflectionUtils;
 
 /**
  * Configuration for a Spring Security in-memory {@link AuthenticationManager}. Can be
@@ -171,9 +173,21 @@ public void configure(AuthenticationManagerBuilder auth) throws Exception {
 			Set<String> roles = new LinkedHashSet<String>(user.getRole());
 			withUser(user.getName()).password(user.getPassword()).roles(
 					roles.toArray(new String[roles.size()]));
+			setField(auth, ""defaultUserDetailsService"", getUserDetailsService());
 			super.configure(auth);
 		}
 
+		private void setField(Object target, String name, Object value) {
+			try {
+				Field field = ReflectionUtils.findField(target.getClass(), name);
+				ReflectionUtils.makeAccessible(field);
+				ReflectionUtils.setField(field, target, value);
+			}
+			catch (Exception e) {
+				logger.info(""Could not set "" + name);
+			}
+		}
+
 	}
 
 	/**
@@ -49,6 +49,7 @@
 import org.springframework.security.core.Authentication;
 import org.springframework.security.core.AuthenticationException;
 import org.springframework.security.core.authority.AuthorityUtils;
+import org.springframework.security.core.userdetails.UserDetailsService;
 import org.springframework.security.web.FilterChainProxy;
 import org.springframework.security.web.SecurityFilterChain;
 import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
@@ -190,6 +191,19 @@ public void testOverrideAuthenticationManager() throws Exception {
 				this.context.getBean(AuthenticationManager.class));
 	}
 
+	@Test
+	public void testDefaultAuthenticationManagerMakesUserDetailsAvailable()
+			throws Exception {
+		this.context = new AnnotationConfigWebApplicationContext();
+		this.context.setServletContext(new MockServletContext());
+		this.context.register(UserDetailsSecurityCustomizer.class,
+				SecurityAutoConfiguration.class, ServerPropertiesAutoConfiguration.class,
+				PropertyPlaceholderAutoConfiguration.class);
+		this.context.refresh();
+		assertNotNull(this.context.getBean(UserDetailsSecurityCustomizer.class)
+				.getUserDetails().loadUserByUsername(""user""));
+	}
+
 	@Test
 	public void testOverrideAuthenticationManagerAndInjectIntoSecurityFilter()
 			throws Exception {
@@ -380,4 +394,21 @@ public void init(AuthenticationManagerBuilder auth) throws Exception {
 
 	}
 
+	@Configuration
+	protected static class UserDetailsSecurityCustomizer extends
+			WebSecurityConfigurerAdapter {
+
+		private UserDetailsService userDetails;
+
+		@Override
+		protected void configure(HttpSecurity http) throws Exception {
+			this.userDetails = http.getSharedObject(UserDetailsService.class);
+		}
+
+		public UserDetailsService getUserDetails() {
+			return this.userDetails;
+		}
+
+	}
+
 }
",True,The commit message refers to the necessity of changes by mentioning that it 'makes the UserDetailsService effectively available as it would be if we used AuthenticationManagerBuilder.inMemoryAuthentication() as a shared object in the HttpSecurity'. This explains why the commit is making changes to the default AuthenticationManagerBuilder and adding a method to set a field using reflection. The message also references a prior issue that it is fixing.,True,"The commit message explains the necessity of changes by stating that it 'Sets UserDetailsService in default AuthenticationManagerBuilder' and 'Only affects the default AuthenticationManagerBuilder'. This is done to make the UserDetailsService effectively available as it would be if we used AuthenticationManagerBuilder.inMemoryAuthentication(). This change is made to ensure that the UserDetailsService is available in a consistent manner, which is not the case when users are not overriding the default global user details.",True,"The commit message explains the motivation for the change by mentioning that it only affects the default AuthenticationManagerBuilder and that it makes the UserDetailsService effectively available. It also mentions that it fixes an issue, which is a common way to describe the necessity of changes. The code diff supports this explanation by adding a method to set the UserDetailsService field in the AuthenticationManagerBuilder, which was not present in the previous implementation.",True,"The commit message indicates that the changes were made to address an issue where the UserDetailsService was not effectively available as it would be if we used AuthenticationManagerBuilder.inMemoryAuthentication(). This suggests that the change was made to improve the software maintenance process, specifically to address a problem in the existing code that was causing the UserDetailsService to not be properly configured.",True,The commit message directly mentions the issue it fixes by stating 'Only affects the default AuthenticationManagerBuilder...Makes the UserDetailsService effectively available' and 'Fixes <issue_link>'. This clearly indicates that the change is made to address a specific problem or issue.,True,"The commit message describes the change accurately by summarizing the code diff. It mentions setting the UserDetailsService in the default AuthenticationManagerBuilder, which is a key component of the change. It also contrasts the before and after situation by mentioning that the change only affects the default AuthenticationManagerBuilder when users are not overriding the default global user details.",True,"The commit message explains that the changes are made to set the UserDetailsService in the default AuthenticationManagerBuilder. This allows the UserDetailsService to be effectively available as it would be if we used AuthenticationManagerBuilder.inMemoryAuthentication(). This is a technical principle that demonstrates the use of reflection to set a private field in a class, which is a common technique in Java but can be risky if not done correctly.",True,"The commit message expresses a change in the configuration of the Spring Security AuthenticationManager. It mentions that the UserDetailsService is being set in the default AuthenticationManagerBuilder, which will make the UserDetailsService effectively available. This change introduces new behavior as it allows the UserDetailsService to be used in the HttpSecurity configuration, which was not possible before. The code diff supports this explanation by showing the addition of methods and imports related to setting the UserDetailsService in the AuthenticationManagerBuilder.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Set UserDetailsService in default AuthenticationManagerBuilder' and explains its impact: 'Only affects the default AuthenticationManagerBuilder... Makes the UserDetailsService effectively available...' The change is not just a simple fix, but a modification that has a significant impact on the functionality of the code."
https://github.com/spring-projects/spring-boot/commit/56ded38f5d6b6cc1d3e7a6bd6d131a7dac33b0c9,Generate default values from Duration and Period .ZERO  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/56ded38f5d6b6cc1d3e7a6bd6d131a7dac33b0c9,"@@ -98,6 +98,8 @@ private static class FieldCollector implements TreeVisitor {
 			values.put(""StandardCharsets.UTF_8"", ""UTF-8"");
 			values.put(""StandardCharsets.UTF_16"", ""UTF-16"");
 			values.put(""StandardCharsets.US_ASCII"", ""US-ASCII"");
+			values.put(""Duration.ZERO"", 0);
+			values.put(""Period.ZERO"", 0);
 			WELL_KNOWN_STATIC_FINALS = Collections.unmodifiableMap(values);
 		}
 
@@ -94,6 +94,7 @@ void getFieldValues() throws Exception {
 		assertThat(values.get(""durationMinutes"")).isEqualTo(""30m"");
 		assertThat(values.get(""durationHours"")).isEqualTo(""40h"");
 		assertThat(values.get(""durationDays"")).isEqualTo(""50d"");
+		assertThat(values.get(""durationZero"")).isEqualTo(0);
 		assertThat(values.get(""dataSizeNone"")).isNull();
 		assertThat(values.get(""dataSizeBytes"")).isEqualTo(""5B"");
 		assertThat(values.get(""dataSizeKilobytes"")).isEqualTo(""10KB"");
@@ -105,6 +106,7 @@ void getFieldValues() throws Exception {
 		assertThat(values.get(""periodWeeks"")).isEqualTo(""2w"");
 		assertThat(values.get(""periodMonths"")).isEqualTo(""10m"");
 		assertThat(values.get(""periodYears"")).isEqualTo(""15y"");
+		assertThat(values.get(""periodZero"")).isEqualTo(0);
 	}
 
 	@SupportedAnnotationTypes({ ""org.springframework.boot.configurationsample.ConfigurationProperties"" })
@@ -125,6 +125,8 @@ public class FieldValues {
 
 	private Duration durationDays = Duration.ofDays(50);
 
+	private Duration durationZero = Duration.ZERO;
+
 	private DataSize dataSizeNone;
 
 	private DataSize dataSizeBytes = DataSize.ofBytes(5);
@@ -147,4 +149,6 @@ public class FieldValues {
 
 	private Period periodYears = Period.ofYears(15);
 
+	private Period periodZero = Period.ZERO;
+
 }
",True,"The commit message refers to the necessity of changes by mentioning the generation of default values from Duration and Period .ZERO. This is likely done to improve the functionality of the code by adding support for these default values. The code diff also supports this explanation, as it shows the addition of these default values to the WELL_KNOWN_STATIC_FINALS map, and the addition of new test cases to ensure these values are handled correctly.",True,"The commit message 'Generate default values from Duration and Period .ZERO' clearly describes the necessity of changes. It is not common sense or easy to infer that these changes are needed, as they are adding new default values for Duration and Period constants that are not already defined in the code. The commit message does not provide a rationale, but the code diff makes it clear that these changes are necessary to support new functionality.",True,"The commit message 'Generate default values from Duration and Period .ZERO' directly elaborates the motivation of the code change by mentioning the issue it closes and the specific classes (Duration and Period) that are being modified. The message also indicates that the changes are necessary to generate default values for these classes, which suggests that the previous implementation may not have handled these cases correctly.",True,"The commit message 'Generate default values from Duration and Period .ZERO' indicates that the developer added default values for Duration.ZERO and Period.ZERO to match the changes in the code. This suggests that the changes were made to accommodate new requirements or to update outdated code, as the default values for Duration.ZERO and Period.ZERO were not previously defined.",True,"The commit message 'Generate default values from Duration and Period .ZERO' directly mentions the change it makes to the code, which is generating default values for Duration.ZERO and Period.ZERO. This is an improvement to the code as it adds more functionality and makes the code more complete.",True,"The commit message 'Generate default values from Duration and Period .ZERO' accurately summarizes the changes made in the code diff. It clearly states that the changes involve adding default values for Duration.ZERO and Period.ZERO, which is exactly what the code diff shows. Additionally, the commit message mentions closing an issue, which is a common practice in software development to link the commit to a specific task or bug.",True,"The commit message 'Generate default values from Duration and Period .ZERO' describes the technical principle underpinning the changes, which is the use of the ZERO constant from the Duration and Period classes to provide default values. This is evident in the code diff where the ZERO constants are being used to set default values for Duration and Period fields in the FieldValues class and in the FieldCollector class.",True,"The commit message 'Generate default values from Duration and Period .ZERO' accurately describes the changes made in the code diff. It explains that the code changes involve adding default values for Duration.ZERO and Period.ZERO, which are both set to 0. The code diff also shows that these default values are used in various assertions and are assigned to new fields in the FieldValues class. Therefore, the commit message effectively summarizes the changes from a functional perspective and describes the new behaviors introduced.",True,"The commit message 'Generate default values from Duration and Period .ZERO' clearly explains the reason for the commit. The code diff shows that the commit is adding default values for Duration.ZERO and Period.ZERO to a map and also adding assertions to test these values. This change is not trivial as it involves modifying multiple files and adding new test cases. Therefore, the commit message does not lack an explanation."
https://github.com/spring-projects/spring-boot/commit/8014b21ad96cf109735e092bb1d4e1c251634064,Upgrade to Maven Enforcer Plugin 3.0.0-M2  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/8014b21ad96cf109735e092bb1d4e1c251634064,"@@ -193,7 +193,7 @@
 		<maven-compiler-plugin.version>3.7.0</maven-compiler-plugin.version>
 		<maven-dependency-plugin.version>3.0.2</maven-dependency-plugin.version>
 		<maven-deploy-plugin.version>2.8.2</maven-deploy-plugin.version>
-		<maven-enforcer-plugin.version>3.0.0-M1</maven-enforcer-plugin.version>
+		<maven-enforcer-plugin.version>3.0.0-M2</maven-enforcer-plugin.version>
 		<maven-failsafe-plugin.version>2.22.0</maven-failsafe-plugin.version>
 		<maven-install-plugin.version>2.5.2</maven-install-plugin.version>
 		<maven-invoker-plugin.version>3.1.0</maven-invoker-plugin.version>
",True,"The commit message 'Upgrade to Maven Enforcer Plugin 3.0.0-M2' refers to the necessity of changes by mentioning the upgrade of a plugin to a newer version. This could be due to the availability of new features, improvements, or to address issues in the prior version. However, without additional context, it's not possible to definitively determine if the message is referencing a convention, standard, or improvement in prior commits.",True,"The commit message 'Upgrade to Maven Enforcer Plugin 3.0.0-M2' clearly describes the necessity of the change. The change is a version upgrade, which is a common practice to ensure the use of the latest stable version of a plugin for better functionality, security, and compatibility. The code diff also supports this explanation, showing the exact change in the version of the Maven Enforcer Plugin.",True,"The commit message 'Upgrade to Maven Enforcer Plugin 3.0.0-M2 Closes <issue_link>' does describe the necessity of changes. It mentions that the upgrade is being done to address a specific issue, which is not explicitly stated in the message but is implied by the 'Closes <issue_link>' phrase. This phrase typically refers to an issue tracker where the specifics of the issue, such as an error scenario or a shortcoming of the previous implementation, might be detailed. Therefore, the commit message does indicate a motivation for the code change.",True,"The commit message 'Upgrade to Maven Enforcer Plugin 3.0.0-M2' indicates that the change is being made to address a problem in the software maintenance process. The problem is that the current version of the Maven Enforcer Plugin is out of date, and the change is to upgrade to a newer version. This suggests that the older version may have been causing issues or not meeting the current requirements of the project.",True,"The commit message 'Upgrade to Maven Enforcer Plugin 3.0.0-M2' directly mentions the change made to the code, which is an upgrade to a newer version of the Maven Enforcer Plugin. This change could potentially fix issues or add improvements that are present in the newer version of the plugin compared to the older one.",True,"The commit message 'Upgrade to Maven Enforcer Plugin 3.0.0-M2' accurately summarizes the change made in the diff. It specifically mentions the upgrade of the Maven Enforcer Plugin from version 3.0.0-M1 to 3.0.0-M2, which is the only significant change in the diff. This makes the commit message a clear and concise summary of the changes.",False,"The commit message only mentions the upgrade of a Maven plugin to a new version. It does not explicitly describe a technical principle underpinning the changes. The code diff shows that the version of the Maven Enforcer Plugin is being updated, but the commit message does not explain why this is necessary or what technical principle it relates to.",True,"The commit message 'Upgrade to Maven Enforcer Plugin 3.0.0-M2' clearly describes the change made in the code diff. It explains that the version of the Maven Enforcer Plugin is being upgraded from 3.0.0-M1 to 3.0.0-M2. This change does not introduce new behaviors, but it does modify existing behavior by upgrading a plugin to a newer version. The new version might introduce bug fixes, new features, or changes in existing features, but the commit message does not provide specific details about these potential changes.",False,"The commit message does not explicitly explain the reason for the upgrade. While it's clear from the diff that the Maven Enforcer Plugin is being upgraded, the commit message does not provide any context or explanation for why this upgrade is necessary. This could be to fix a bug, to take advantage of new features, or for security reasons, and the commit message does not clarify this."
https://github.com/spring-projects/spring-boot/commit/e28b98c59d43190b5ca8ea3ae4deac50c9737766,Remove multi config runApplication extension  <enter> Closes   <pr_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/e28b98c59d43190b5ca8ea3ae4deac50c9737766,"@@ -42,16 +42,3 @@ inline fun <reified T : Any> runApplication(vararg args: String): ConfigurableAp
  */
 inline fun <reified T : Any> runApplication(vararg args: String, init: SpringApplication.() -> Unit): ConfigurableApplicationContext =
 		SpringApplication(T::class.java).apply(init).run(*args)
-
-
-/**
- * Top level function acting as a Kotlin shortcut allowing to write
- * `runApplication(arrayOf(FooApplication::class, FooConfiguration::class), arg1, arg2) { // Optional SpringApplication customization ... }`
- * instead of instantiating `SpringApplication` class, customize it and then invoking
- * `run(arrayOf(arg1, arg2))`.`
- *
- * @author Sebastien Deleuze
- * @since 2.0.0
- */
-fun runApplication(primarySources: Array<KClass<*>>, vararg args: String, init: SpringApplication.() -> Unit = {}): ConfigurableApplicationContext =
-		SpringApplication(*primarySources.map { it.java }.toTypedArray()).apply(init).run(*args)
@@ -70,42 +70,6 @@ class SpringApplicationExtensionsTests {
 		assertEquals(environment, context.environment)
 	}
 
-	@Test
-	fun `Kotlin runApplication(array of KClass) top level function`() {
-		val context = runApplication(arrayOf(ExampleConfig::class, ExampleWebConfig::class))
-		assertNotNull(context)
-	}
-
-	@Test
-	fun `Kotlin runApplication(array of KClass) top level function with a custom environment`() {
-		val environment = StandardEnvironment()
-		val context = runApplication(arrayOf(ExampleConfig::class, ExampleWebConfig::class)) {
-			setEnvironment(environment)
-		}
-		assertNotNull(context)
-		assertEquals(environment, context.environment)
-	}
-
-	@Test
-	fun `Kotlin runApplication(array of KClass, arg1, arg2) top level function`() {
-		val context = runApplication(arrayOf(ExampleConfig::class, ExampleWebConfig::class), ""--debug"", ""spring"", ""boot"")
-		val args = context.getBean<ApplicationArguments>()
-		assertArrayEquals(arrayOf(""spring"", ""boot""), args.nonOptionArgs.toTypedArray())
-		assertTrue(args.containsOption(""debug""))
-	}
-
-	@Test
-	fun `Kotlin runApplication(array of KClass, arg1, arg2) top level function with a custom environment`() {
-		val environment = StandardEnvironment()
-		val context = runApplication(arrayOf(ExampleConfig::class, ExampleWebConfig::class), ""--debug"", ""spring"", ""boot"") {
-			setEnvironment(environment)
-		}
-		val args = context.getBean<ApplicationArguments>()
-		assertArrayEquals(arrayOf(""spring"", ""boot""), args.nonOptionArgs.toTypedArray())
-		assertTrue(args.containsOption(""debug""))
-		assertEquals(environment, context.environment)
-	}
-
 
 	@Configuration
 	internal open class ExampleConfig
",True,"The commit message refers to the removal of a multi config runApplication extension, which is no longer needed. This could be due to the deprecation of the feature, the introduction of a new feature that replaces it, or the improvement in the existing functionality. The code diff shows that the multi config runApplication extension is removed, which supports the necessity of the changes mentioned in the commit message.",True,"The commit message 'Remove multi config runApplication extension' clearly describes the changes made in the code diff. The removal of the multi config runApplication extension is a refactoring change, which is a common practice in software development to improve the maintainability and readability of the code. The commit message does not provide a rationale for the change, but it is easy to infer from the code diff that the multi config runApplication extension is no longer needed because it is being replaced by a simpler and more streamlined version of the function. Additionally, the removal of the tests related to the multi config runApplication extension further supports the assumption that the change was made to simplify the codebase.",False,"The commit message does not directly elaborate the motivation of the code change. It only mentions that the change is related to a pull request (PR) and that it closes it. However, it does not describe the error scenario, mention the issue report, or explain the shortcoming of the previous implementation that necessitated the changes.",True,"The commit message 'Remove multi config runApplication extension' indicates that the changes were made to address the need for simplification and removal of outdated or unnecessary code. The code diff shows that a multi-configuration version of the runApplication function was removed, which suggests that it was no longer needed or was causing issues.",False,"The commit message does not explicitly mention the defects it fixes or the improvements it makes to the code. It only states that it is removing a multi config runApplication extension, but it does not explain why this change is necessary or what benefits it provides.",True,"The commit message 'Remove multi config runApplication extension' accurately summarizes the changes in the diff. It points out the key component of the change, which is the removal of the 'runApplication' extension that allows for the use of an array of KClasses. This is clearly reflected in the diff, where the entire section of code for this extension has been removed.",False,"The commit message does not explicitly describe the technical principle underpinning the changes. It only mentions the removal of a multi config runApplication extension. The code diff suggests that this removal might be related to simplifying the codebase or reducing redundancy, but it does not explicitly state or imply a specific technical principle.",True,"The commit message 'Remove multi config runApplication extension' clearly describes the changes made to the code. It indicates that a function that allowed running a Spring Boot application with multiple configuration classes has been removed. This change removes the ability to specify multiple configuration classes when starting the application, which was previously possible using the 'runApplication' function with an array of KClass objects. The code diff also supports this explanation by showing the removal of the function and related tests.",True,"The commit message removed a function that was used to run a Spring Boot application with multiple configuration classes. This change could be inferred from the code diff, which shows the removal of the function and its related tests. Therefore, there was no need for an explanation of the change in the commit message."
https://github.com/spring-projects/spring-boot/commit/e2cb7a75458d83c1358faf9e19194b9ab8fe0454,Align default scopes for Google with changes in Spring Security 5.0.1  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/e2cb7a75458d83c1358faf9e19194b9ab8fe0454,"@@ -119,8 +119,7 @@ public void getClientRegistrationsWhenUsingCommonProviderShouldAdapt() {
 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE);
 		assertThat(adapted.getRedirectUriTemplate())
 				.isEqualTo(""{baseUrl}/login/oauth2/code/{registrationId}"");
-		assertThat(adapted.getScopes()).containsExactly(""openid"", ""profile"", ""email"",
-				""address"", ""phone"");
+		assertThat(adapted.getScopes()).containsExactly(""openid"", ""profile"", ""email"");
 		assertThat(adapted.getClientName()).isEqualTo(""Google"");
 	}
 
@@ -203,8 +202,7 @@ public void getClientRegistrationsWhenProviderNotSpecifiedShouldUseRegistrationI
 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE);
 		assertThat(adapted.getRedirectUriTemplate())
 				.isEqualTo(""{baseUrl}/login/oauth2/code/{registrationId}"");
-		assertThat(adapted.getScopes()).containsExactly(""openid"", ""profile"", ""email"",
-				""address"", ""phone"");
+		assertThat(adapted.getScopes()).containsExactly(""openid"", ""profile"", ""email"");
 		assertThat(adapted.getClientName()).isEqualTo(""Google"");
 	}
 
",True,"The commit message refers to a change in the Spring Security 5.0.1 version, which is likely a new release or update. The code diff shows that the default scopes for Google have been modified to remove 'address' and 'phone'. This change is likely due to the updates in Spring Security 5.0.1, as the message suggests. Therefore, the commit message describes the necessity of changes by referencing an external standard (Spring Security 5.0.1) and its impact on the codebase.",True,"The commit message 'Align default scopes for Google with changes in Spring Security 5.0.1' does not explicitly explain why the changes were made. However, the code diff shows that the scopes for Google in the tests have been reduced from 'openid', 'profile', 'email', 'address', 'phone' to 'openid', 'profile', 'email'. This is likely due to changes in Spring Security 5.0.1, which the commit message refers to. Therefore, the commit message does contain an expression that describes the necessity of changes without providing a full rationale.",True,"The commit message 'Align default scopes for Google with changes in Spring Security 5.0.1' directly elaborates the motivation of the code change by mentioning the issue of changes in Spring Security 5.0.1 and the need to align the default scopes for Google. The code diff also supports this explanation by showing the removal of 'address' and 'phone' scopes, which were not mentioned in the previous implementation.",True,"The commit message 'Align default scopes for Google with changes in Spring Security 5.0.1' indicates that the developer made changes to align the default scopes for Google with the changes in Spring Security 5.0.1. This suggests that there was a change in the API or the underlying library (Spring Security 5.0.1) that the project was using, which necessitated changes in the project's code to maintain compatibility and functionality.",True,"The commit message 'Align default scopes for Google with changes in Spring Security 5.0.1' directly mentions the change made to the code, which is the alignment of the default scopes for Google with the changes in Spring Security 5.0.1. This change is likely an improvement to the code as it ensures compatibility with the newer version of Spring Security and removes unnecessary scopes.",True,"The commit message 'Align default scopes for Google with changes in Spring Security 5.0.1' accurately summarizes the changes in the diff. It points out the key component of the change, which is the modification of the default scopes for Google. The diff shows that the scopes 'address' and 'phone' have been removed, which is reflected in the commit message.",True,The commit message 'Align default scopes for Google with changes in Spring Security 5.0.1' suggests that the changes are being made to ensure consistency with the updated default scopes in Spring Security 5.0.1. This implies a technical principle of maintaining compatibility and adhering to updated standards or configurations.,True,"The commit message 'Align default scopes for Google with changes in Spring Security 5.0.1' accurately describes the code changes. The changes in the code diff are modifications to the 'getScopes' method, where the expected scopes are reduced from ['openid', 'profile', 'email', 'address', 'phone'] to ['openid', 'profile', 'email']. This change aligns the default scopes with the changes in Spring Security 5.0.1, which indicates a new behavior introduced in the code.",True,"The commit message mentions that it is aligning the default scopes for Google with changes in Spring Security 5.0.1. The code diff shows that the scopes 'address' and 'phone' have been removed. This change is straightforward and the reason for the change is clearly stated in the commit message, so there was no need for an additional explanation in the commit message."
https://github.com/spring-projects/spring-boot/commit/e79ef9b73baca23e11db3c60fd3af2ca3a3dfb70,Add option to exclude devtools from fat jar  <enter> Add an `excludeDevtools` property to both the Maven and Gradle plugin that removes `org.springframework.boot:spring-boot-devtools` (if necessary) when repackaging the application. <enter>  Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/e79ef9b73baca23e11db3c60fd3af2ca3a3dfb70,"@@ -395,6 +395,10 @@ want the other Boot features but not this one)
 |`embeddedLaunchScriptProperties`
 |Additional properties that to be expanded in the launch script. The default script
  supports a `mode` property which can contain the values `auto`, `service` or `run`.
+
+|`excludeDevtools`
+|Boolean flag to indicate if the devtools jar should be excluded from the repackaged
+archives. Defaults to `false`.
 |===
 
 
@@ -844,6 +844,10 @@ applied to other modules using your project. Gradle does not support `optional`
 dependencies out-of-the-box so you may want to have a look to the
 {propdeps-plugin}[`propdeps-plugin`] in the meantime.
 
+TIP: If you want to ensure that devtools is never included in a production build, you can
+use set the `excludeDevtools` build property to completely remove the JAR. The property is
+supported with both the Maven and Gradle plugins.
+
 
 
 [[using-boot-devtools-property-defaults]]
@@ -47,19 +47,24 @@ public static void createProject() throws IOException {
 	}
 
 	@Test
-	public void repackagingEnabled() {
+	public void repackagingEnabled() throws IOException {
 		project.newBuild().forTasks(""clean"", ""build"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"").run();
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=false"")
+				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
-		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
+		File repackageFile = new File(buildLibs, ""repackage.jar"");
+		assertTrue(repackageFile.exists());
 		assertTrue(new File(buildLibs, ""repackage.jar.original"").exists());
 		assertFalse(new File(buildLibs, ""repackage-sources.jar.original"").exists());
+		assertTrue(isDevToolsJarIncluded(repackageFile));
 	}
 
 	@Test
 	public void repackagingDisabled() {
 		project.newBuild().forTasks(""clean"", ""build"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"")
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"",
+						""-PexcludeDevtools=false"")
 				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
@@ -70,7 +75,8 @@ public void repackagingDisabled() {
 	@Test
 	public void repackagingDisabledWithCustomRepackagedJar() {
 		project.newBuild().forTasks(""clean"", ""build"", ""customRepackagedJar"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"")
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"",
+						""-PexcludeDevtools=false"")
 				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
@@ -84,7 +90,8 @@ public void repackagingDisabledWithCustomRepackagedJar() {
 	public void repackagingDisabledWithCustomRepackagedJarUsingStringJarTaskReference() {
 		project.newBuild()
 				.forTasks(""clean"", ""build"", ""customRepackagedJarWithStringReference"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"")
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=false"",
+						""-PexcludeDevtools=false"")
 				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
@@ -97,7 +104,9 @@ public void repackagingDisabledWithCustomRepackagedJarUsingStringJarTaskReferenc
 	@Test
 	public void repackagingEnabledWithCustomRepackagedJar() {
 		project.newBuild().forTasks(""clean"", ""build"", ""customRepackagedJar"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"").run();
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=false"")
+				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
 		assertTrue(new File(buildLibs, ""repackage.jar.original"").exists());
@@ -110,7 +119,9 @@ public void repackagingEnabledWithCustomRepackagedJar() {
 	public void repackagingEnableWithCustomRepackagedJarUsingStringJarTaskReference() {
 		project.newBuild()
 				.forTasks(""clean"", ""build"", ""customRepackagedJarWithStringReference"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"").run();
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=false"")
+				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		assertTrue(new File(buildLibs, ""repackage.jar"").exists());
 		assertTrue(new File(buildLibs, ""repackage.jar.original"").exists());
@@ -124,10 +135,38 @@ public void repackageWithFileDependency() throws Exception {
 		FileCopyUtils.copy(new File(""src/test/resources/foo.jar""),
 				new File(""target/repackage/foo.jar""));
 		project.newBuild().forTasks(""clean"", ""build"")
-				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"").run();
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=false"")
+				.run();
 		File buildLibs = new File(""target/repackage/build/libs"");
 		JarFile jarFile = new JarFile(new File(buildLibs, ""repackage.jar""));
 		assertThat(jarFile.getEntry(""lib/foo.jar""), notNullValue());
 		jarFile.close();
 	}
+
+	@Test
+	public void repackagingEnabledExcludeDevtools() throws IOException {
+		project.newBuild().forTasks(""clean"", ""build"")
+				.withArguments(""-PbootVersion="" + BOOT_VERSION, ""-Prepackage=true"",
+						""-PexcludeDevtools=true"")
+				.run();
+		File buildLibs = new File(""target/repackage/build/libs"");
+		File repackageFile = new File(buildLibs, ""repackage.jar"");
+		assertTrue(repackageFile.exists());
+		assertTrue(new File(buildLibs, ""repackage.jar.original"").exists());
+		assertFalse(new File(buildLibs, ""repackage-sources.jar.original"").exists());
+		assertFalse(isDevToolsJarIncluded(repackageFile));
+	}
+
+	private boolean isDevToolsJarIncluded(File repackageFile) throws IOException {
+		JarFile jarFile = new JarFile(repackageFile);
+		try {
+			String name = ""lib/spring-boot-devtools-"" + BOOT_VERSION + "".jar"";
+			return jarFile.getEntry(name) != null;
+		}
+		finally {
+			jarFile.close();
+		}
+	}
+
 }
@@ -18,11 +18,13 @@ apply plugin: 'java'
 dependencies {
 	compile 'org.springframework.boot:spring-boot-starter-freemarker'
 	compile 'org.springframework.boot:spring-boot-starter-web'
+	compile 'org.springframework.boot:spring-boot-devtools'
 	compile files(""foo.jar"")
 }
 
 springBoot {
 	mainClass = 'foo.bar.Baz'
+	excludeDevtools = Boolean.valueOf(project.excludeDevtools)
 }
 
 bootRepackage.enabled = Boolean.valueOf(project.repackage)
@@ -38,6 +38,7 @@
  *
  * @author Phillip Webb
  * @author Dave Syer
+ * @author Stephane Nicoll
  */
 public class SpringBootPluginExtension {
 
@@ -87,6 +88,11 @@ public class SpringBootPluginExtension {
 	 */
 	Set<String> requiresUnpack;
 
+	/**
+	 * Whether Spring Boot Devtools should be excluded from the fat jar.
+	 */
+	boolean excludeDevtools = false;
+
 	/**
 	 * Location of an agent jar to attach to the VM when running the application with
 	 * runJar task.
@@ -186,6 +192,14 @@ public void setRequiresUnpack(Set<String> requiresUnpack) {
 		this.requiresUnpack = requiresUnpack;
 	}
 
+	public boolean isExcludeDevtools() {
+		return this.excludeDevtools;
+	}
+
+	public void setExcludeDevtools(boolean excludeDevtools) {
+		this.excludeDevtools = excludeDevtools;
+	}
+
 	public File getAgent() {
 		return this.agent;
 	}
@@ -155,12 +155,26 @@ private void libraries(Set<GradleLibrary> libraries, LibraryCallback callback)
 		if (libraries != null) {
 			Set<String> duplicates = getDuplicates(libraries);
 			for (GradleLibrary library : libraries) {
-				library.setIncludeGroupName(duplicates.contains(library.getName()));
-				callback.library(library);
+				if (!isExcluded(library)) {
+					library.setIncludeGroupName(duplicates.contains(library.getName()));
+					callback.library(library);
+				}
 			}
 		}
 	}
 
+	private boolean isExcluded(GradleLibrary library) {
+		if (this.extension.isExcludeDevtools() && isDevToolsJar(library)) {
+			return true;
+		}
+		return false;
+	}
+
+	private boolean isDevToolsJar(GradleLibrary library) {
+		return ""org.springframework.boot"".equals(library.getGroup())
+				&& library.getName().startsWith(""spring-boot-devtools"");
+	}
+
 	private Set<String> getDuplicates(Set<GradleLibrary> libraries) {
 		Set<String> duplicates = new HashSet<String>();
 		Set<String> seen = new HashSet<String>();
@@ -187,6 +201,10 @@ public void setIncludeGroupName(boolean includeGroupName) {
 			this.includeGroupName = includeGroupName;
 		}
 
+		public String getGroup() {
+			return this.group;
+		}
+
 		@Override
 		public String getName() {
 			String name = super.getName();
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2014 the original author or authors.
+ * Copyright 2012-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package org.springframework.boot.maven;
 
+import java.util.Arrays;
 import java.util.List;
 
 import org.apache.maven.artifact.Artifact;
@@ -29,6 +30,10 @@
  */
 public class ExcludeFilter extends DependencyFilter {
 
+	public ExcludeFilter(Exclude... excludes) {
+		this(Arrays.asList(excludes));
+	}
+
 	public ExcludeFilter(List<Exclude> excludes) {
 		super(excludes);
 	}
@@ -35,6 +35,7 @@
 import org.apache.maven.plugins.annotations.ResolutionScope;
 import org.apache.maven.project.MavenProject;
 import org.apache.maven.project.MavenProjectHelper;
+import org.apache.maven.shared.artifact.filter.collection.ArtifactsFilter;
 import org.springframework.boot.loader.tools.DefaultLaunchScript;
 import org.springframework.boot.loader.tools.LaunchScript;
 import org.springframework.boot.loader.tools.Layout;
@@ -153,6 +154,13 @@ public class RepackageMojo extends AbstractDependencyFilterMojo {
 	@Parameter
 	private Properties embeddedLaunchScriptProperties;
 
+	/**
+	 * Exclude Spring Boot devtools.
+	 * @since 1.3
+	 */
+	@Parameter(defaultValue = ""false"")
+	private boolean excludeDevtools;
+
 	@Override
 	public void execute() throws MojoExecutionException, MojoFailureException {
 		if (this.project.getPackaging().equals(""pom"")) {
@@ -190,7 +198,7 @@ protected String findMainMethod(JarFile source) throws IOException {
 		}
 
 		Set<Artifact> artifacts = filterDependencies(this.project.getArtifacts(),
-				getFilters());
+				getFilters(getAdditionalFilters()));
 
 		Libraries libraries = new ArtifactsLibraries(artifacts, this.requiresUnpack,
 				getLog());
@@ -213,6 +221,17 @@ else if (!source.equals(target)) {
 		}
 	}
 
+	private ArtifactsFilter[] getAdditionalFilters() {
+		if (this.excludeDevtools) {
+			Exclude exclude = new Exclude();
+			exclude.setGroupId(""org.springframework.boot"");
+			exclude.setArtifactId(""spring-boot-devtools"");
+			ExcludeFilter filter = new ExcludeFilter(exclude);
+			return new ArtifactsFilter[] { filter };
+		}
+		return new ArtifactsFilter[] {};
+	}
+
 	private File getTargetFile() {
 		String classifier = (this.classifier == null ? """" : this.classifier.trim());
 		if (classifier.length() > 0 && !classifier.startsWith(""-"")) {
",True,"The commit message refers to the necessity of changes by mentioning the addition of an `excludeDevtools` property to both the Maven and Gradle plugin. This property is used to remove `org.springframework.boot:spring-boot-devtools` from the repackaged application, which is a common practice to ensure that devtools is not included in a production build.",True,The commit message 'Add option to exclude devtools from fat jar' clearly describes the necessity of the changes by explaining that the new option removes 'org.springframework.boot:spring-boot-devtools' from the repackaged application when necessary. This is a common practice to exclude devtools from production builds to improve performance and security.,True,"The commit message directly elaborates the motivation of the code change by mentioning the issue it closes and the problem it solves, which is the need to exclude devtools from the fat jar.",True,"The commit message 'Add option to exclude devtools from fat jar' indicates that the developer added a feature to exclude the Spring Boot Devtools from the fat jar. This was likely done to address a requirement or problem, such as reducing the size of the jar or removing unnecessary dependencies in a production environment.",True,"The commit message directly mentions the improvement it makes to the code by adding an 'excludeDevtools' property to both the Maven and Gradle plugin that removes 'org.springframework.boot:spring-boot-devtools' from the repackaged application. This is done to fix the issue of devtools being included in a production build, which is not desired.",True,"The commit message 'Add option to exclude devtools from fat jar' accurately summarizes the change by describing the addition of a new feature to exclude the Spring Boot devtools jar from the repackaged application. The code diff also supports this, showing the addition of an 'excludeDevtools' property to both the Maven and Gradle plugins, which removes the 'org.springframework.boot:spring-boot-devtools' jar if necessary when repackaging the application.",True,"The commit message explains that an 'excludeDevtools' property has been added to both the Maven and Gradle plugin. This property removes 'org.springframework.boot:spring-boot-devtools' from the repackaged application if necessary. This change is based on the technical principle of modularity, where the application can be customized to exclude certain components based on the specific needs of the project.",True,"The commit message 'Add option to exclude devtools from fat jar' accurately describes the code changes. It explains that a new property, `excludeDevtools`, has been added to both the Maven and Gradle plugin. This property removes `org.springframework.boot:spring-boot-devtools` from the repackaged application if necessary. The code diff also supports this explanation, showing the addition of the `excludeDevtools` property to the plugin extension and the modification of the repackaging task to respect this property.",False,"The commit message does not lack an explanation. It clearly states the reason for the commit: 'Add an `excludeDevtools` property to both the Maven and Gradle plugin that removes `org.springframework.boot:spring-boot-devtools` (if necessary) when repackaging the application.' This is a significant change that requires explanation, especially since it involves modifying the build process to exclude a specific dependency."
https://github.com/spring-projects/spring-boot/commit/f0c53726420e84267ba9ccff1640ed0bdf7f5fd7,Align with Spring Framework 5's new Commons Logging adapter  <enter> Closes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/f0c53726420e84267ba9ccff1640ed0bdf7f5fd7,"@@ -16,27 +16,22 @@
 
 package org.springframework.boot.autoconfigure.logging;
 
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogConfigurationException;
-import org.apache.commons.logging.LogFactory;
-import org.apache.commons.logging.impl.LogFactoryImpl;
-import org.apache.commons.logging.impl.NoOpLog;
-import org.junit.After;
-import org.junit.Before;
+
+import ch.qos.logback.classic.Level;
+import ch.qos.logback.classic.Logger;
+import ch.qos.logback.classic.LoggerContext;
+import org.junit.Rule;
 import org.junit.Test;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
+import org.slf4j.impl.StaticLoggerBinder;
 
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport;
 import org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration;
 import org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration;
 import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
 import org.springframework.boot.context.event.ApplicationFailedEvent;
+import org.springframework.boot.testutil.InternalOutputCapture;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -47,10 +42,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willAnswer;
-import static org.mockito.Mockito.mock;
 
 /**
  * Tests for {@link AutoConfigurationReportLoggingInitializer}.
@@ -60,66 +51,21 @@
  */
 public class AutoConfigurationReportLoggingInitializerTests {
 
-	private static ThreadLocal<Log> logThreadLocal = new ThreadLocal<>();
-
-	private Log log;
-
-	private AutoConfigurationReportLoggingInitializer initializer;
-
-	protected List<String> debugLog = new ArrayList<>();
-
-	protected List<String> infoLog = new ArrayList<>();
-
-	@Before
-	public void setup() {
-		setupLogging(true, true);
-	}
-
-	private void setupLogging(boolean debug, boolean info) {
-		this.log = mock(Log.class);
-		logThreadLocal.set(this.log);
-
-		given(this.log.isDebugEnabled()).willReturn(debug);
-		willAnswer(new Answer<Object>() {
-
-			@Override
-			public Object answer(InvocationOnMock invocation) throws Throwable {
-				return AutoConfigurationReportLoggingInitializerTests.this.debugLog
-						.add(String.valueOf(invocation.getArguments()[0]));
-			}
-
-		}).given(this.log).debug(any());
-
-		given(this.log.isInfoEnabled()).willReturn(info);
-		willAnswer(new Answer<Object>() {
+	@Rule
+	public InternalOutputCapture outputCapture = new InternalOutputCapture();
 
-			@Override
-			public Object answer(InvocationOnMock invocation) throws Throwable {
-				return AutoConfigurationReportLoggingInitializerTests.this.infoLog
-						.add(String.valueOf(invocation.getArguments()[0]));
-			}
-
-		}).given(this.log).info(any());
-
-		LogFactory.releaseAll();
-		System.setProperty(LogFactory.FACTORY_PROPERTY, MockLogFactory.class.getName());
-		this.initializer = new AutoConfigurationReportLoggingInitializer();
-	}
-
-	@After
-	public void cleanup() {
-		System.clearProperty(LogFactory.FACTORY_PROPERTY);
-		LogFactory.releaseAll();
-	}
+	private AutoConfigurationReportLoggingInitializer initializer = new AutoConfigurationReportLoggingInitializer();
 
 	@Test
 	public void logsDebugOnContextRefresh() {
 		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
 		this.initializer.initialize(context);
 		context.register(Config.class);
 		context.refresh();
-		this.initializer.onApplicationEvent(new ContextRefreshedEvent(context));
-		assertThat(this.debugLog.size()).isNotEqualTo(0);
+		withDebugLogging(() -> {
+			this.initializer.onApplicationEvent(new ContextRefreshedEvent(context));
+		});
+		assertThat(this.outputCapture.toString()).contains(""AUTO-CONFIGURATION REPORT"");
 	}
 
 	@Test
@@ -132,16 +78,16 @@ public void logsDebugOnError() {
 			fail(""Did not error"");
 		}
 		catch (Exception ex) {
-			this.initializer.onApplicationEvent(new ApplicationFailedEvent(
-					new SpringApplication(), new String[0], context, ex));
+			withDebugLogging(() -> {
+				this.initializer.onApplicationEvent(new ApplicationFailedEvent(
+						new SpringApplication(), new String[0], context, ex));
+			});
 		}
-		assertThat(this.debugLog.size()).isNotEqualTo(0);
-		assertThat(this.infoLog.size()).isEqualTo(0);
+		assertThat(this.outputCapture.toString()).contains(""AUTO-CONFIGURATION REPORT"");
 	}
 
 	@Test
 	public void logsInfoOnErrorIfDebugDisabled() {
-		setupLogging(false, true);
 		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
 		this.initializer.initialize(context);
 		context.register(ErrorConfig.class);
@@ -153,8 +99,9 @@ public void logsInfoOnErrorIfDebugDisabled() {
 			this.initializer.onApplicationEvent(new ApplicationFailedEvent(
 					new SpringApplication(), new String[0], context, ex));
 		}
-		assertThat(this.debugLog.size()).isEqualTo(0);
-		assertThat(this.infoLog.size()).isNotEqualTo(0);
+		assertThat(this.outputCapture.toString()).contains(""Error starting""
+				+ "" ApplicationContext. To display the auto-configuration report re-run""
+				+ "" your application with 'debug' enabled."");
 	}
 
 	@Test
@@ -165,13 +112,10 @@ public void logsOutput() throws Exception {
 		ConditionEvaluationReport.get(context.getBeanFactory())
 				.recordExclusions(Arrays.asList(""com.foo.Bar""));
 		context.refresh();
-		this.initializer.onApplicationEvent(new ContextRefreshedEvent(context));
-		for (String message : this.debugLog) {
-			System.out.println(message);
-		}
-		// Just basic sanity check, test is for visual inspection
-		String l = this.debugLog.get(0);
-		assertThat(l)
+		withDebugLogging(() -> {
+			this.initializer.onApplicationEvent(new ContextRefreshedEvent(context));
+		});
+		assertThat(this.outputCapture.toString())
 				.contains(""not a servlet web application (OnWebApplicationCondition)"");
 	}
 
@@ -199,20 +143,23 @@ public void noErrorIfNotInitialized() throws Exception {
 		this.initializer
 				.onApplicationEvent(new ApplicationFailedEvent(new SpringApplication(),
 						new String[0], null, new RuntimeException(""Planned"")));
-		assertThat(this.infoLog.get(0))
+		assertThat(this.outputCapture.toString())
 				.contains(""Unable to provide auto-configuration report"");
 	}
 
-	public static class MockLogFactory extends LogFactoryImpl {
-
-		@Override
-		public Log getInstance(String name) throws LogConfigurationException {
-			if (AutoConfigurationReportLoggingInitializer.class.getName().equals(name)) {
-				return logThreadLocal.get();
-			}
-			return new NoOpLog();
+	private void withDebugLogging(Runnable runnable) {
+		LoggerContext context = (LoggerContext) StaticLoggerBinder.getSingleton()
+				.getLoggerFactory();
+		Logger logger = context
+				.getLogger(AutoConfigurationReportLoggingInitializer.class);
+		Level currentLevel = logger.getLevel();
+		logger.setLevel(Level.DEBUG);
+		try {
+			runnable.run();
+		}
+		finally {
+			logger.setLevel(currentLevel);
 		}
-
 	}
 
 	@Configuration
@@ -155,8 +155,10 @@ protected String[] getSources(String... args) {
 		return sources;
 	}
 
-	public String getOutput() {
-		return this.outputCapture.toString();
+	private String getOutput() {
+		String output = this.outputCapture.toString();
+		this.outputCapture.reset();
+		return output;
 	}
 
 	@Override
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -33,20 +33,17 @@ public class DirectorySourcesIntegrationTests {
 
 	@Test
 	public void runDirectory() throws Exception {
-		this.cli.run(""code"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""code"")).contains(""Hello World"");
 	}
 
 	@Test
 	public void runDirectoryRecursive() throws Exception {
-		this.cli.run("""");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run("""")).contains(""Hello World"");
 	}
 
 	@Test
 	public void runPathPattern() throws Exception {
-		this.cli.run(""**/*.groovy"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""**/*.groovy"")).contains(""Hello World"");
 	}
 
 }
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -47,14 +47,12 @@ public void grabAntBuilder() throws Exception {
 	// this will fail
 	@Test
 	public void securityDependencies() throws Exception {
-		this.cli.run(""secure.groovy"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""secure.groovy"")).contains(""Hello World"");
 	}
 
 	@Test
 	public void dataJpaDependencies() throws Exception {
-		this.cli.run(""data-jpa.groovy"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""data-jpa.groovy"")).contains(""Hello World"");
 	}
 
 	@Test
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -59,6 +59,7 @@ public void bannerAndLoggingIsOutputByDefault() throws Exception {
 
 	@Test
 	public void quietModeSuppressesAllCliOutput() throws Exception {
+		this.cli.run(""quiet.groovy"");
 		String output = this.cli.run(""quiet.groovy"", ""-q"");
 		assertThat(output).isEqualTo(""Ssshh"");
 	}
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -159,8 +159,7 @@ public void deviceSample() throws Exception {
 
 	@Test
 	public void caching() throws Exception {
-		this.cli.run(""caching.groovy"");
-		assertThat(this.cli.getOutput()).contains(""Hello World"");
+		assertThat(this.cli.run(""caching.groovy"")).contains(""Hello World"");
 	}
 
 }
@@ -105,10 +105,10 @@ public void resolveArtifactWithDependencies() throws Exception {
 	@Test
 	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
 	public void resolveShorthandArtifactWithDependencies() throws Exception {
-		List<File> resolved = this.resolver.resolve(Arrays.asList(""spring-core""));
+		List<File> resolved = this.resolver.resolve(Arrays.asList(""spring-beans""));
 		assertThat(resolved).hasSize(2);
-		assertThat(getNames(resolved)).has((Condition) Matched.by(
-				hasItems(startsWith(""commons-logging-""), startsWith(""spring-core-""))));
+		assertThat(getNames(resolved)).has((Condition) Matched
+				.by(hasItems(startsWith(""spring-core-""), startsWith(""spring-beans-""))));
 	}
 
 	@Test
@@ -66,8 +66,8 @@ private AetherGrapeEngine createGrapeEngine(
 	public void dependencyResolution() {
 		Map<String, Object> args = new HashMap<>();
 		createGrapeEngine(this.springMilestones).grab(args,
-				createDependency(""org.springframework"", ""spring-jdbc"", ""3.2.4.RELEASE""));
-		assertThat(this.groovyClassLoader.getURLs()).hasSize(5);
+				createDependency(""org.springframework"", ""spring-jdbc"", null));
+		assertThat(this.groovyClassLoader.getURLs()).hasSize(4);
 	}
 
 	@Test
@@ -153,10 +153,10 @@ public void dependencyResolutionWithCustomClassLoader() {
 		args.put(""classLoader"", customClassLoader);
 
 		createGrapeEngine(this.springMilestones).grab(args,
-				createDependency(""org.springframework"", ""spring-jdbc"", ""3.2.4.RELEASE""));
+				createDependency(""org.springframework"", ""spring-jdbc"", null));
 
 		assertThat(this.groovyClassLoader.getURLs().length).isEqualTo(0);
-		assertThat(customClassLoader.getURLs().length).isEqualTo(5);
+		assertThat(customClassLoader.getURLs().length).isEqualTo(4);
 	}
 
 	@Test
@@ -30,6 +30,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-cassandra</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 </project>
@@ -26,6 +26,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-couchbase</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 	<build>
@@ -26,6 +26,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-elasticsearch</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 	<build>
@@ -54,6 +54,10 @@
 					<groupId>org.aspectj</groupId>
 					<artifactId>aspectjrt</artifactId>
 				</exclusion>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
 			</exclusions>
 		</dependency>
 		<dependency>
@@ -26,6 +26,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-ldap</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 	<build>
@@ -31,6 +31,10 @@
 					<groupId>org.mongodb</groupId>
 					<artifactId>mongo-java-driver</artifactId>
 				</exclusion>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
 			</exclusions>
 		</dependency>
 		<dependency>
@@ -35,6 +35,10 @@
 					<groupId>org.mongodb</groupId>
 					<artifactId>mongo-java-driver</artifactId>
 				</exclusion>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
 			</exclusions>
 		</dependency>
 	</dependencies>
@@ -25,6 +25,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-neo4j</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 </project>
@@ -26,6 +26,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-redis</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 		<dependency>
 			<groupId>redis.clients</groupId>
@@ -38,6 +38,12 @@
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-rest-webmvc</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 	</dependencies>
 	<build>
@@ -31,11 +31,21 @@
 					<groupId>log4j</groupId>
 					<artifactId>log4j</artifactId>
 				</exclusion>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
 			</exclusions>
 		</dependency>
 		<dependency>
 			<groupId>org.springframework.data</groupId>
 			<artifactId>spring-data-solr</artifactId>
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>jcl-over-slf4j</artifactId>
+				</exclusion>
+			</exclusions>
 		</dependency>
 		<dependency>
 			 <groupId>org.apache.httpcomponents</groupId>
@@ -31,10 +31,6 @@
 			<groupId>org.apache.logging.log4j</groupId>
 			<artifactId>log4j-core</artifactId>
 		</dependency>
-		<dependency>
-			<groupId>org.slf4j</groupId>
-			<artifactId>jcl-over-slf4j</artifactId>
-		</dependency>
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>jul-to-slf4j</artifactId>
@@ -22,10 +22,6 @@
 			<groupId>ch.qos.logback</groupId>
 			<artifactId>logback-classic</artifactId>
 		</dependency>
-		<dependency>
-			<groupId>org.slf4j</groupId>
-			<artifactId>jcl-over-slf4j</artifactId>
-		</dependency>
 		<dependency>
 			<groupId>org.slf4j</groupId>
 			<artifactId>jul-to-slf4j</artifactId>
@@ -238,7 +238,7 @@ public void enableBannerInLogViaProperty() throws Exception {
 		application.setWebApplicationType(WebApplicationType.NONE);
 		this.context = application.run(""--spring.main.banner-mode=log"");
 		verify(application, atLeastOnce()).setBannerMode(Banner.Mode.LOG);
-		assertThat(this.output.toString()).contains(""o.s.boot.SpringApplication"");
+		assertThat(this.output.toString()).contains(""o.s.b.SpringApplication"");
 	}
 
 	@Test
@@ -28,16 +28,15 @@
 import java.util.Map;
 import java.util.Properties;
 
-import ch.qos.logback.classic.BasicConfigurator;
-import ch.qos.logback.classic.Logger;
-import ch.qos.logback.classic.LoggerContext;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.config.LoggerConfig;
 import org.assertj.core.api.Condition;
 import org.junit.After;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
-import org.slf4j.LoggerFactory;
 
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.WebApplicationType;
@@ -90,14 +89,6 @@ public class ConfigFileApplicationListenerTests {
 
 	private ConfigurableApplicationContext context;
 
-	@Before
-	public void resetLogging() {
-		LoggerContext loggerContext = ((Logger) LoggerFactory.getLogger(getClass()))
-				.getLoggerContext();
-		loggerContext.reset();
-		new BasicConfigurator().configure(loggerContext);
-	}
-
 	@After
 	public void cleanUp() {
 		if (this.context != null) {
@@ -442,7 +433,9 @@ private void validateProfilePrecedence(String... profiles) {
 		ApplicationPreparedEvent event = new ApplicationPreparedEvent(
 				new SpringApplication(), new String[0],
 				new AnnotationConfigApplicationContext());
-		this.initializer.onApplicationEvent(event);
+		withDebugLogging(() -> {
+			this.initializer.onApplicationEvent(event);
+		});
 		String log = this.out.toString();
 
 		// First make sure that each profile got processed only once
@@ -463,6 +456,23 @@ private void validateProfilePrecedence(String... profiles) {
 		}
 	}
 
+	private void withDebugLogging(Runnable runnable) {
+		LoggerContext loggingContext = (LoggerContext) LogManager.getContext(true);
+		org.apache.logging.log4j.core.config.Configuration configuration = loggingContext
+				.getConfiguration();
+		configuration.addLogger(ConfigFileApplicationListener.class.getName(),
+				new LoggerConfig(ConfigFileApplicationListener.class.getName(),
+						Level.DEBUG, true));
+		loggingContext.updateLoggers();
+		try {
+			runnable.run();
+		}
+		finally {
+			configuration.removeLogger(ConfigFileApplicationListener.class.getName());
+			loggingContext.updateLoggers();
+		}
+	}
+
 	private String createLogForProfile(String profile) {
 		String suffix = profile != null ? ""-"" + profile : """";
 		String string = "".properties)"";
@@ -34,12 +34,15 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
 import org.slf4j.bridge.SLF4JBridgeHandler;
 
 import org.springframework.boot.ApplicationPid;
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.context.event.ApplicationFailedEvent;
 import org.springframework.boot.context.event.ApplicationStartingEvent;
+import org.springframework.boot.junit.runner.classpath.ClassPathExclusions;
+import org.springframework.boot.junit.runner.classpath.ModifiedClassPathRunner;
 import org.springframework.boot.logging.AbstractLoggingSystem;
 import org.springframework.boot.logging.LogFile;
 import org.springframework.boot.logging.LogLevel;
@@ -61,14 +64,17 @@
 import static org.hamcrest.Matchers.not;
 
 /**
- * Tests for {@link LoggingApplicationListener}.
+ * Tests for {@link LoggingApplicationListener} with Logback.
  *
  * @author Dave Syer
  * @author Phillip Webb
  * @author Andy Wilkinson
  * @author Stephane Nicoll
  * @author Ben Hale
  */
+
+@RunWith(ModifiedClassPathRunner.class)
+@ClassPathExclusions(""log4j*.jar"")
 public class LoggingApplicationListenerTests {
 
 	private static final String[] NO_ARGS = {};
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2016 the original author or authors.
+ * Copyright 2012-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -23,8 +23,8 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.logging.Level;
+import java.util.logging.Logger;
 
-import org.apache.commons.logging.impl.Jdk14Logger;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -64,15 +64,15 @@ public boolean accept(File pathname) {
 	@Rule
 	public InternalOutputCapture output = new InternalOutputCapture();
 
-	private Jdk14Logger logger;
+	private Logger logger;
 
 	private Locale defaultLocale;
 
 	@Before
 	public void init() throws SecurityException, IOException {
 		this.defaultLocale = Locale.getDefault();
 		Locale.setDefault(Locale.ENGLISH);
-		this.logger = new Jdk14Logger(getClass().getName());
+		this.logger = Logger.getLogger(getClass().getName());
 	}
 
 	@After
@@ -82,7 +82,7 @@ public void clearLocale() {
 
 	@After
 	public void resetLogger() {
-		this.logger.getLogger().setLevel(Level.OFF);
+		this.logger.setLevel(Level.OFF);
 	}
 
 	@Test
@@ -161,9 +161,9 @@ public void getSupportedLevels() {
 	public void setLevel() throws Exception {
 		this.loggingSystem.beforeInitialize();
 		this.loggingSystem.initialize(null, null, null);
-		this.logger.debug(""Hello"");
+		this.logger.fine(""Hello"");
 		this.loggingSystem.setLogLevel(""org.springframework.boot"", LogLevel.DEBUG);
-		this.logger.debug(""Hello"");
+		this.logger.fine(""Hello"");
 		assertThat(StringUtils.countOccurrencesOf(this.output.toString(), ""Hello""))
 				.isEqualTo(1);
 	}
@@ -0,0 +1,17 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<Configuration status=""warn"" name=""test"" packages="""">
+	<Properties>
+		<Property name=""LOG_EXCEPTION_CONVERSION_WORD"">%xwEx</Property>
+		<Property name=""LOG_LEVEL_PATTERN"">%5p</Property>
+	</Properties>
+	<Appenders>
+		<Console name=""STDOUT"" target=""SYSTEM_OUT"" follow=""true"">
+			<PatternLayout pattern=""%clr{%d{yyyy-MM-dd HH:mm:ss.SSS}}{faint} %clr{${LOG_LEVEL_PATTERN}} %clr{${sys:PID}}{magenta} %clr{---}{faint} %clr{[%15.15t]}{faint} %clr{%-40.40c{1.}}{cyan} %clr{:}{faint} %m%n${sys:LOG_EXCEPTION_CONVERSION_WORD}""/>
+		</Console>
+	</Appenders>
+	<Loggers>
+		<Root level=""info"">
+			<AppenderRef ref=""STDOUT""/>
+		</Root>
+	</Loggers>
+</Configuration>
",True,"The commit message 'Align with Spring Framework 5's new Commons Logging adapter' refers to a change in the logging framework used by the Spring Framework. This is a necessary change to align with the latest version of the framework and improve logging capabilities. The code diff shows that the old Commons Logging implementation has been replaced with Logback, which is the new Commons Logging adapter in Spring Framework 5.",True,"The commit message 'Align with Spring Framework 5's new Commons Logging adapter' indicates that the change is being made to align the project with a new version of Spring Framework. This change is not a trivial one, as it involves updating the logging adapter to match the new version. The commit message does not provide a detailed explanation of why this change is necessary, but it is clear that it is a necessary update to keep the project in sync with the latest version of Spring Framework.",True,"The commit message 'Align with Spring Framework 5's new Commons Logging adapter' directly elaborates the motivation of the code change by mentioning that the change is necessary to align with a new version of the Spring Framework. Additionally, the message mentions that it closes an issue, which suggests that there was a problem or shortcoming in the previous implementation that the change addresses.",True,"The commit message 'Align with Spring Framework 5's new Commons Logging adapter' indicates that the developer is making changes to align with a new version of Spring Framework. This could be due to changes in the underlying Commons Logging adapter, which might have been deprecated or modified in the new version. This is a requirement change that necessitates code modifications to keep the application up-to-date and compatible with the new version.",True,"The commit message 'Align with Spring Framework 5's new Commons Logging adapter' directly mentions the change to align with a new version of the Commons Logging adapter in the Spring Framework, which is an improvement to the code.",True,"The commit message 'Align with Spring Framework 5's new Commons Logging adapter' describes the change made in the code diff by summarizing the key component of the change, which is the replacement of the Commons Logging adapter with the one from Spring Framework 5. The code diff shows the removal of imports related to the old Commons Logging adapter and the addition of imports related to the new Logback adapter.",True,The commit message 'Align with Spring Framework 5's new Commons Logging adapter' suggests that the changes are being made to align the project's logging configuration with the new Commons Logging adapter introduced in Spring Framework 5. This implies a technical principle of keeping the project up-to-date with the latest versions of its dependencies to ensure compatibility and take advantage of new features.,True,"The commit message 'Align with Spring Framework 5's new Commons Logging adapter' describes a change in the logging framework used in the project. The code diff shows that the project is moving from using Apache Commons Logging to Logback, which is a replacement for Commons Logging in Spring Framework 5. This change introduces new behaviors, such as the ability to set log levels programmatically and the use of a different logging configuration format.",True,The commit message 'Align with Spring Framework 5's new Commons Logging adapter' is sufficient to explain the reason for the commit because the change is a simple replacement of the logging adapter used in the project to align with the new version of Spring Framework 5. The code diff shows that the old Commons Logging adapter has been removed and the new Logback adapter has been added. The commit message does not need to provide additional explanation for this change.
https://github.com/spring-projects/spring-boot/commit/f9094143d72a99bb52ad6414568ee2c93611115c,Remove undefined FILE appender from basic log4j config  <enter> Fixes   <issue_link> ,https://api.github.com/repos/spring-projects/spring-boot/commits/f9094143d72a99bb52ad6414568ee2c93611115c,"@@ -1,4 +1,4 @@
-log4j.rootCategory=INFO, CONSOLE, FILE
+log4j.rootCategory=INFO, CONSOLE
 
 PID=????
 LOG_PATTERN=[%d{yyyy-MM-dd HH:mm:ss.SSS}] boot%X{context} - ${PID} %5p [%t] --- %c{1}: %m%n
",True,"The commit message refers to the necessity of changes by mentioning the removal of an undefined FILE appender from the basic log4j config. This change is likely made to fix an issue, as indicated by the 'Fixes <issue_link>' part of the message. The code diff also supports this, as it shows the removal of the FILE appender from the log4j configuration. This change could be seen as an improvement over a prior commit that may have included the undefined FILE appender, or it could be a fix for a bug or issue that was previously implemented.",True,"The commit message 'Remove undefined FILE appender from basic log4j config' clearly explains the necessity of the changes. The message states that the 'FILE' appender is undefined, which is a common issue that can cause errors. The code diff also supports this explanation by removing the 'FILE' appender from the log4j configuration. Therefore, the commit message does not require a rationale beyond what is already provided.",True,"The commit message 'Remove undefined FILE appender from basic log4j config' directly elaborates the motivation of the code change. It mentions the issue of having an undefined FILE appender in the basic log4j configuration, which could potentially cause errors or unexpected behavior. The message also includes a reference to the issue it is fixing, which adds to the clarity of the change.",True,"The commit message 'Remove undefined FILE appender from basic log4j config' indicates that the change was made to fix an issue. The issue is that the FILE appender was undefined, which could have caused runtime errors or issues with the software's logging functionality. This suggests that there was a problem in the process of software maintenance, specifically an out-of-date or incorrect configuration.",True,"The commit message directly mentions the issue it fixes, which is the removal of an undefined FILE appender from the basic log4j configuration. This change improves the code by resolving a configuration error.",True,The commit message 'Remove undefined FILE appender from basic log4j config' accurately summarizes the change made in the diff. It clearly states that the 'FILE' appender is being removed from the 'basic log4j config'. This is a direct reflection of the change in the diff where 'FILE' is no longer listed in the 'log4j.rootCategory' configuration.,True,"The commit message explains that the change was made to remove an undefined FILE appender from the basic log4j configuration. This implies that the technical principle underpinning the changes is the importance of having a well-defined and properly configured logging system. The removal of the undefined FILE appender ensures that the logging system only attempts to write logs to valid and accessible destinations, which is a fundamental principle of software development.",True,"The commit message 'Remove undefined FILE appender from basic log4j config' accurately summarizes the code changes. It clearly states that a FILE appender, which was previously defined in the log4j configuration, has been removed. This change will result in the logging system no longer attempting to write logs to an undefined FILE, which could have caused errors or unexpected behavior in the past.",False,"The commit message does not lack an explanation. It explicitly states the reason for the commit: 'Remove undefined FILE appender from basic log4j config'. This is necessary because the change is not trivial and could potentially cause issues if the FILE appender was being used elsewhere in the codebase. The diff also supports this explanation, showing that the FILE appender has been removed from the log4j configuration."
https://github.com/square/okhttp/commit/067aa1f4495f9c93bafca183a6d655fa81b139d6,Throw UnknownHostException again from HttpURLConnection  <enter> This is to address issue  <issue_link> . ,https://api.github.com/repos/square/okhttp/commits/067aa1f4495f9c93bafca183a6d655fa81b139d6,"@@ -17,8 +17,10 @@
 
 import com.squareup.okhttp.UrlComponentEncodingTester.Component;
 import com.squareup.okhttp.UrlComponentEncodingTester.Encoding;
+import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
@@ -949,6 +951,27 @@ public final class HttpUrlTest {
     assertEquals(null, HttpUrl.get(uri));
   }
 
+  @Test public void fromJavaNetUrl_checked() throws Exception {
+    HttpUrl httpUrl = HttpUrl.getChecked(""http://username:password@host/path?query#fragment"");
+    assertEquals(""http://username:password@host/path?query#fragment"", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
+    try {
+      HttpUrl.getChecked(""mailto:user@example.com"");
+      fail();
+    } catch (MalformedURLException e) {
+    }
+  }
+
+  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
+    try {
+      HttpUrl.getChecked(""http://hostw ithspace/"");
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   @Test public void composeQueryWithComponents() throws Exception {
     HttpUrl base = HttpUrl.parse(""http://host/"");
     HttpUrl url = base.newBuilder().addQueryParameter(""a+=& b"", ""c+=& d"").build();
@@ -3178,6 +3178,37 @@ private void zeroLengthPayload(String method)
     assertContent(""abc"", client.open(server.getUrl(""/"")));
   }
 
+  @Test public void urlWithSpaceInHost() throws Exception {
+    URLConnection urlConnection = client.open(new URL(""http://and roid.com/""));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
+    server.enqueue(new MockResponse());
+    URLConnection urlConnection =
+        client.open(new URL(""http://and roid.com/""), server.toProxyAddress());
+
+    try {
+      // This test is to check that a NullPointerException is not thrown.
+      urlConnection.getInputStream();
+      fail(); // the RI makes a bogus proxy request for ""GET http://and roid.com/ HTTP/1.1""
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlHostWithNul() throws Exception {
+    URLConnection urlConnection = client.open(new URL(""http://host\u0000/""));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
   public Buffer gzip(String data) throws IOException {
     Buffer result = new Buffer();
@@ -46,10 +46,12 @@
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.Permission;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -321,14 +323,16 @@ private void initHttpEngine() throws IOException {
     }
   }
 
-  private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableSink requestBody, Response priorResponse) {
+  private HttpEngine newHttpEngine(String method, Connection connection, RetryableSink requestBody,
+      Response priorResponse) throws MalformedURLException, UnknownHostException {
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(method)
         ? EMPTY_REQUEST_BODY
         : null;
+    URL url = getURL();
+    HttpUrl httpUrl = Internal.instance.getHttpUrlChecked(url.toString());
     Request.Builder builder = new Request.Builder()
-        .url(getURL())
+        .url(httpUrl)
         .method(method, placeholderBody);
     Headers headers = requestHeaders.build();
     for (int i = 0, size = headers.size(); i < size; i++) {
@@ -561,7 +561,9 @@ public String fragment() {
 
   /** Returns the URL that would be retrieved by following {@code link} from this URL. */
   public HttpUrl resolve(String link) {
-    return new Builder().parse(this, link);
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(this, link);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
   }
 
   public Builder newBuilder() {
@@ -584,11 +586,13 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns a new {@code OkUrl} representing {@code url} if it is a well-formed HTTP or HTTPS URL,
-   * or null if it isn't.
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or null if it isn't.
    */
   public static HttpUrl parse(String url) {
-    return new Builder().parse(null, url);
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
   }
 
   /**
@@ -599,6 +603,29 @@ public static HttpUrl get(URL url) {
     return parse(url.toString());
   }
 
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or throws an exception if it isn't.
+   *
+   * @throws MalformedURLException if there was a non-host related URL issue
+   * @throws UnknownHostException if the host was invalid
+   */
+  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    switch (result) {
+      case SUCCESS:
+        return builder.build();
+      case INVALID_HOST:
+        throw new UnknownHostException(""Invalid host: "" + url);
+      case UNSUPPORTED_SCHEME:
+      case MISSING_SCHEME:
+      case INVALID_PORT:
+      default:
+        throw new MalformedURLException(""Invalid URL: "" + result + "" for "" + url);
+    }
+  }
+
   public static HttpUrl get(URI uri) {
     return parse(uri.toString());
   }
@@ -883,7 +910,15 @@ public HttpUrl build() {
       return result.toString();
     }
 
-    HttpUrl parse(HttpUrl base, String input) {
+    enum ParseResult {
+      SUCCESS,
+      MISSING_SCHEME,
+      UNSUPPORTED_SCHEME,
+      INVALID_PORT,
+      INVALID_HOST,
+    }
+
+    ParseResult parse(HttpUrl base, String input) {
       int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
       int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
 
@@ -897,12 +932,12 @@ HttpUrl parse(HttpUrl base, String input) {
           this.scheme = ""http"";
           pos += ""http:"".length();
         } else {
-          return null; // Not an HTTP scheme.
+          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
         }
       } else if (base != null) {
         this.scheme = base.scheme;
       } else {
-        return null; // No scheme.
+        return ParseResult.MISSING_SCHEME; // No scheme.
       }
 
       // Authority.
@@ -960,12 +995,12 @@ HttpUrl parse(HttpUrl base, String input) {
               if (portColonOffset + 1 < componentDelimiterOffset) {
                 this.host = canonicalizeHost(input, pos, portColonOffset);
                 this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (this.port == -1) return null; // Invalid port.
+                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
               } else {
                 this.host = canonicalizeHost(input, pos, portColonOffset);
                 this.port = defaultPort(this.scheme);
               }
-              if (this.host == null) return null; // Invalid host.
+              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
               pos = componentDelimiterOffset;
               break authority;
           }
@@ -1002,7 +1037,7 @@ HttpUrl parse(HttpUrl base, String input) {
             input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false);
       }
 
-      return build();
+      return ParseResult.SUCCESS;
     }
 
     private void resolvePath(String input, int pos, int limit) {
@@ -27,9 +27,11 @@
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
 import java.net.CookieHandler;
+import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.URLConnection;
+import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
@@ -157,6 +159,11 @@ public void callEnqueue(Call call, Callback responseCallback, boolean forWebSock
       public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
         tlsConfiguration.apply(sslSocket, isFallback);
       }
+
+      @Override public HttpUrl getHttpUrlChecked(String url)
+          throws MalformedURLException, UnknownHostException {
+        return HttpUrl.getChecked(url);
+      }
     };
   }
 
@@ -21,13 +21,16 @@
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.UnknownHostException;
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import okio.BufferedSink;
@@ -85,6 +88,9 @@ public abstract void connectAndSetOwner(OkHttpClient client, Connection connecti
   public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
       boolean isFallback);
 
+  public abstract HttpUrl getHttpUrlChecked(String url)
+      throws MalformedURLException, UnknownHostException;
+
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
   public abstract void callEngineReleaseConnection(Call call) throws IOException;
",True,"The commit message refers to the necessity of changes by referencing an issue that requires throwing UnknownHostException again from HttpURLConnection. This is done to address a specific problem that was previously identified and tracked. Additionally, the code diff shows the addition of new tests that specifically check for UnknownHostException, which further supports the necessity of the changes.",True,"The commit message does not explicitly state the reason for the changes, but it is clear from the code diff that the changes are being made to address an issue related to handling URLs with invalid hosts. The commit adds new test cases to check for this scenario and throws UnknownHostException when an invalid host is encountered. This is a common practice to ensure that the application behaves correctly when it encounters invalid URLs.",True,"The commit message 'Throw UnknownHostException again from HttpURLConnection' directly mentions the issue it is addressing, which is the scenario where the host is unknown. This is further elaborated in the code diff, where new tests have been added to handle URLs with invalid hosts, and the newHttpEngine method now throws UnknownHostException. Additionally, the getChecked method in the HttpUrl class has been updated to throw UnknownHostException if the host is invalid.",True,"The commit message 'Throw UnknownHostException again from HttpURLConnection' indicates that the developer is addressing an issue where the application was not properly handling the UnknownHostException. This could be due to a change in the underlying API, as indicated by the code diff, which now requires the exception to be thrown again. This suggests that there was a requirement for software development to address a problem in the process of software maintenance, specifically an out-of-date code issue.",True,The commit message 'Throw UnknownHostException again from HttpURLConnection' directly mentions the change that it is addressing the issue of not throwing UnknownHostException when the host is invalid. This is evident in the code diff where new methods have been added to check the URL's host and throw UnknownHostException if it is invalid.,True,"The commit message 'Throw UnknownHostException again from HttpURLConnection' describes the change made in the code diff. The diff shows that the UnknownHostException is now being thrown in several new methods, such as fromJavaNetUrlBadHost_checked() and urlWithSpaceInHost(). This indicates that the code is now correctly handling cases where the host is unknown or invalid, which is what the UnknownHostException is for.",True,"The commit message 'Throw UnknownHostException again from HttpURLConnection' describes the technical principle that the code is addressing the issue where an UnknownHostException is not properly thrown from HttpURLConnection when the host is invalid or unreachable. This is underpinned by the changes in the code diff, which include adding import statements for UnknownHostException and MalformedURLException, and adding new test cases to check for these exceptions.",True,"The commit message 'Throw UnknownHostException again from HttpURLConnection' accurately describes the functional change made in the code. The code diff adds new methods to the HttpUrl class that throw UnknownHostException when the host is invalid or unresolvable. This is a significant change as it introduces a new behavior that was not present before, which is throwing UnknownHostException in certain scenarios.",False,"The commit message does not provide a clear explanation of the reason for the commit. While the code diff suggests that the commit is addressing an issue related to handling URLs with invalid hosts, the message does not explicitly mention this. Therefore, the commit message could be improved to provide more context and clarity."
https://github.com/square/okhttp/commit/5373160d20aa3f6036ff5ebc91137888c4abffbe,"Whole operation timeouts  <enter> Strictly-speaking this change is backwards-incompatible because it adds a new method to the Call interface. The method returns the call's timeout. <enter> The trickiest part of this is signaling the end of the call, which occurs after the last byte is consumed of the last follow up request, or when the call fails. Fortunately this is made easier by borrowing the sites used by EventListener, which already plots out where calls end. <enter>  <issue_link> ",https://api.github.com/repos/square/okhttp/commits/5373160d20aa3f6036ff5ebc91137888c4abffbe,"@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpURLConnection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSink;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WholeOperationTimeoutTest {
+  /** A large response body. Smaller bodies might successfully read after the socket is closed! */
+  private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client = defaultClient();
+
+  @Test public void timeoutWritingRequest() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutWritingRequestWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutProcessing() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutProcessingWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutReadingResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(500);
+    try {
+      response.body().source().readUtf8();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutReadingResponseWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          Thread.sleep(500);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        try {
+          response.body().source().readUtf8();
+          fail();
+        } catch (IOException e) {
+          exceptionRef.set(e);
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/b"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/c"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/d"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/e"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader(""Location"", ""/f"")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url(""/a""))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void noTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(250, TimeUnit.MILLISECONDS)
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url(""/""))
+        .post(sleepingRequestBody(250))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(250);
+    response.body().source().readUtf8();
+    response.close();
+    assertFalse(call.isCanceled());
+  }
+
+  private RequestBody sleepingRequestBody(final int sleepMillis) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse(""text/plain"");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        try {
+          sink.writeUtf8(""abc"");
+          sink.flush();
+          Thread.sleep(sleepMillis);
+          sink.writeUtf8(""def"");
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    };
+  }
+}
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import okio.Timeout;
 
 /**
  * A call is a request that has been prepared for execution. A call can be canceled. As this object
@@ -80,6 +81,12 @@ public interface Call extends Cloneable {
 
   boolean isCanceled();
 
+  /**
+   * Returns a timeout that applies to the entire call: writing the request, server processing,
+   * and reading the response.
+   */
+  Timeout timeout();
+
   /**
    * Create a new, identical call to this one which can be enqueued or executed even if this call
    * has already been.
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.Socket;
@@ -37,11 +38,11 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.platform.Platform;
+import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
@@ -187,6 +188,10 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         return ((RealCall) call).streamAllocation();
       }
 
+      @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
+        return ((RealCall) call).timeoutExit(e);
+      }
+
       @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
         return RealCall.newRealCall(client, originalRequest, true);
       }
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -28,12 +29,15 @@
 import okhttp3.internal.http.RealInterceptorChain;
 import okhttp3.internal.http.RetryAndFollowUpInterceptor;
 import okhttp3.internal.platform.Platform;
+import okio.AsyncTimeout;
+import okio.Timeout;
 
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+  final AsyncTimeout timeout;
 
   /**
    * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
@@ -53,6 +57,11 @@ private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSoc
     this.originalRequest = originalRequest;
     this.forWebSocket = forWebSocket;
     this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
+    this.timeout = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        cancel();
+      }
+    };
   }
 
   static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
@@ -72,20 +81,32 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       executed = true;
     }
     captureCallStackTrace();
+    timeout.enter();
     eventListener.callStart(this);
     try {
       client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException(""Canceled"");
       return result;
     } catch (IOException e) {
+      e = timeoutExit(e);
       eventListener.callFailed(this, e);
       throw e;
     } finally {
       client.dispatcher().finished(this);
     }
   }
 
+  @Nullable IOException timeoutExit(@Nullable IOException cause) {
+    if (!timeout.exit()) return cause;
+
+    InterruptedIOException e = new InterruptedIOException(""timeout"");
+    if (cause != null) {
+      e.initCause(cause);
+    }
+    return e;
+  }
+
   private void captureCallStackTrace() {
     Object callStackTrace = Platform.get().getStackTraceForCloseable(""response.body().close()"");
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
@@ -105,6 +126,10 @@ private void captureCallStackTrace() {
     retryAndFollowUpInterceptor.cancel();
   }
 
+  @Override public Timeout timeout() {
+    return timeout;
+  }
+
   @Override public synchronized boolean isExecuted() {
     return executed;
   }
@@ -144,6 +169,7 @@ RealCall get() {
 
     @Override protected void execute() {
       boolean signalledCallback = false;
+      timeout.enter();
       try {
         Response response = getResponseWithInterceptorChain();
         if (retryAndFollowUpInterceptor.isCanceled()) {
@@ -154,6 +180,7 @@ RealCall get() {
           responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
+        e = timeoutExit(e);
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, ""Callback failure for "" + toLoggableString(), e);
@@ -15,7 +15,9 @@
  */
 package okhttp3.internal;
 
+import java.io.IOException;
 import java.net.Socket;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
@@ -73,5 +75,7 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
 
   public abstract StreamAllocation streamAllocation(Call call);
 
+  public abstract @Nullable IOException timeoutExit(Call call, @Nullable IOException e);
+
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 }
@@ -317,8 +317,10 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead
     }
 
     if (e != null) {
+      e = Internal.instance.timeoutExit(call, e);
       eventListener.callFailed(call, e);
     } else if (callEnd) {
+      Internal.instance.timeoutExit(call, null);
       eventListener.callEnd(call);
     }
   }
@@ -351,6 +353,7 @@ public void release() {
     }
     closeQuietly(socket);
     if (releasedConnection != null) {
+      Internal.instance.timeoutExit(call, null);
       eventListener.connectionReleased(call, releasedConnection);
       eventListener.callEnd(call);
     }
",True,"The commit message refers to the necessity of changes by mentioning that it adds a new method to the Call interface, which returns the call's timeout. This is done to provide a more comprehensive way to manage the entire call's timeout, including writing the request, server processing, and reading the response. This change is mentioned as being backwards-incompatible, which implies that it may break existing code that relies on the old behavior. The message also mentions that the trickiest part of this change is signaling the end of the call, which is made easier by borrowing the sites used by EventListener, which already plots out where calls end. This suggests that the change is being made to improve the overall functionality and reliability of the system.",True,"The commit message explains the necessity of changes by mentioning that it adds a new method to the Call interface to return the call's timeout. This is a significant change that could break existing code, so the commit message provides a clear explanation of the change and its potential impact.",True,"The commit message explains the necessity of changes by directly elaborating the motivation of a code change. It mentions that the change is backwards-incompatible because it adds a new method to the Call interface. This new method returns the call's timeout. The message also explains the trickiest part of this change, which is signaling the end of the call, and it mentions that this is made easier by borrowing the sites used by EventListener, which already plots out where calls end. This explains the problem that could arise if the exceptions were not handled properly and the need for the new method to return the call's timeout.",True,"The commit message mentions that the change is backwards-incompatible because it adds a new method to the Call interface. This indicates that the change was made to accommodate new requirements or to address a problem in the software maintenance process, such as the need to provide more information about the call's timeout.",True,"The commit message mentions the change will add a new method to the Call interface that returns the call's timeout. This directly relates to the improvement made to the code, which is adding a timeout feature to the Call interface.",True,"The commit message describes the changes made to the code by mentioning the addition of a new method to the Call interface that returns the call's timeout. This is a clear summary of the change, as it directly relates to the code diff. Additionally, the message mentions the tricky part of the change, which is signaling the end of the call, and how it was made easier by borrowing the sites used by EventListener. This contrasts the before and after situation, as it explains how the new method improves the functionality of the Call interface.",True,The commit message explains that the change introduces a new method to the Call interface that returns the call's timeout. This is a clear expression of the technical principle that the system should provide a way to control the duration of network operations to prevent them from hanging indefinitely.,True,"The commit message expresses the addition of a new method to the Call interface, which returns the call's timeout. This new behavior is clearly described, making it a summary of the changes from a functional perspective.",False,"The commit message explains the reason for the change, which is the addition of a new method to the Call interface that returns the call's timeout. This change is not trivial and could have unintended consequences, so it requires a clear explanation in the commit message."
https://github.com/square/okhttp/commit/ff959f8fd550b8f55a47038ea4235b1b2ed2eaa8,Android Additional Tests ( <pr_link> ) ,https://api.github.com/repos/square/okhttp/commits/ff959f8fd550b8f55a47038ea4235b1b2ed2eaa8,"@@ -31,6 +31,10 @@ repositories {
   }
 }
 
+def isIDE = properties.containsKey('android.injected.invoked.from.ide') ||
+        (System.getenv(""XPC_SERVICE_NAME"") ?: """").contains(""intellij"") ||
+        System.getenv(""IDEA_INITIAL_DIRECTORY"") != null
+
 android {
   compileOptions {
     sourceCompatibility JavaVersion.VERSION_1_8
@@ -60,6 +64,17 @@ android {
             'notPackage': 'org.bouncycastle'
     ])
   }
+
+  if (!isIDE) {
+    sourceSets {
+      named(""androidTest"") {
+        it.java.srcDirs += project.file(""../okhttp-brotli/src/test/java"")
+        it.java.srcDirs += project.file(""../okhttp-dnsoverhttps/src/test/java"")
+        it.java.srcDirs += project.file(""../okhttp-logging-interceptor/src/test/java"")
+        it.java.srcDirs += project.file(""../okhttp-sse/src/test/java"")
+      }
+    }
+  }
 }
 
 dependencies {
@@ -77,10 +92,12 @@ dependencies {
   androidTestImplementation ""org.bouncycastle:bctls-jdk15to18:${versions.bouncycastle}""
   androidTestImplementation ""org.conscrypt:conscrypt-android:2.5.1""
   androidTestImplementation project(':mockwebserver-junit5')
-  androidTestImplementation project(':okhttp-tls')
+  androidTestImplementation project(':okhttp-brotli')
   androidTestImplementation project(':okhttp-dnsoverhttps')
   androidTestImplementation project(':okhttp-logging-interceptor')
+  androidTestImplementation project(':okhttp-sse')
   androidTestImplementation project(':okhttp-testing-support')
+  androidTestImplementation project(':okhttp-tls')
   androidTestImplementation 'androidx.test.ext:junit:1.1.2'
   androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
   androidTestImplementation 'org.apache.httpcomponents.client5:httpclient5:5.0'
@@ -331,6 +331,7 @@ class OkHttpTest(val server: MockWebServer) {
   }
 
   @Test
+  @Disabled(""cleartext required for additional okhttp wide tests"")
   fun testHttpRequestBlocked() {
     assumeTrue(Build.VERSION.SDK_INT >= 23)
 
@@ -671,6 +672,7 @@ class OkHttpTest(val server: MockWebServer) {
   }
 
   @Test
+  @Disabled(""TODO: currently logging okhttp3.internal.concurrent.TaskRunner, okhttp3.internal.http2.Http2"")
   fun testLoggingLevels() {
     enableTls()
 
@@ -1,4 +1,6 @@
 <manifest xmlns:android=""http://schemas.android.com/apk/res/android""
     package=""okhttp.android.test"">
+  <application
+      android:usesCleartextTraffic=""true"" />
   <uses-permission android:name=""android.permission.INTERNET"" />
 </manifest>
@@ -15,7 +15,7 @@ dependencies {
 
   testImplementation project(':okhttp-testing-support')
   testImplementation project(':mockwebserver-deprecated')
-  testRuntimeOnly project(':mockwebserver-junit5')
+  testImplementation project(':mockwebserver-junit5')
   testImplementation deps.conscrypt
   testImplementation deps.junit
   testImplementation deps.assertj
@@ -26,6 +26,7 @@
 import mockwebserver3.MockResponse;
 import mockwebserver3.MockWebServer;
 import mockwebserver3.RecordedRequest;
+import mockwebserver3.junit5.internal.MockWebServerExtension;
 import okhttp3.Cache;
 import okhttp3.Dns;
 import okhttp3.HttpUrl;
@@ -36,13 +37,15 @@
 import okio.ByteString;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+@ExtendWith(MockWebServerExtension.class)
 public class DnsOverHttpsTest {
   @RegisterExtension public final PlatformRule platform = new PlatformRule();
 
@@ -17,7 +17,7 @@ dependencies {
   testCompileOnly deps.jsr305
   testImplementation deps.junit
   testImplementation project(':mockwebserver')
-  testRuntimeOnly project(':mockwebserver-junit5')
+  testImplementation project(':mockwebserver-junit5')
   testImplementation project(':okhttp-testing-support')
   testImplementation project(':okhttp-tls')
   testImplementation deps.assertj
@@ -22,6 +22,7 @@
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 import javax.net.ssl.HostnameVerifier;
+import mockwebserver3.junit5.internal.MockWebServerExtension;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
@@ -42,6 +43,7 @@
 import okio.ByteString;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import static okhttp3.tls.internal.TlsUtil.localhost;
@@ -50,6 +52,7 @@
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeThat;
 
+@ExtendWith(MockWebServerExtension.class)
 public final class HttpLoggingInterceptorTest {
   private static final MediaType PLAIN = MediaType.get(""text/plain; charset=utf-8"");
 
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.net.UnknownHostException;
+import mockwebserver3.junit5.internal.MockWebServerExtension;
 import okhttp3.Call;
 import okhttp3.EventListener;
 import okhttp3.HttpUrl;
@@ -33,6 +34,7 @@
 import okhttp3.tls.HandshakeCertificates;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import static java.util.Arrays.asList;
@@ -42,6 +44,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+@ExtendWith(MockWebServerExtension.class)
 public final class LoggingEventListenerTest {
   private static final MediaType PLAIN = MediaType.get(""text/plain"");
 
@@ -98,7 +101,7 @@ public void get() throws Exception {
         .assertLogMatch(
             ""responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url=""
                 + url
-                + ""}"")
+                + ""\\}"")
         .assertLogMatch(""responseBodyStart"")
         .assertLogMatch(""responseBodyEnd: byteCount=6"")
         .assertLogMatch(""connectionReleased"")
@@ -135,7 +138,7 @@ public void post() throws IOException {
         .assertLogMatch(
             ""responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url=""
                 + url
-                + ""}"")
+                + ""\\}"")
         .assertLogMatch(""responseBodyStart"")
         .assertLogMatch(""responseBodyEnd: byteCount=0"")
         .assertLogMatch(""connectionReleased"")
@@ -177,12 +180,12 @@ public void secureGet() throws Exception {
                 + url.host()
                 + "":\\d+, proxy=DIRECT hostAddress=""
                 + url.host()
-                + ""/.+ cipherSuite=.+ protocol=h2}"")
+                + ""/.+ cipherSuite=.+ protocol=h2\\}"")
         .assertLogMatch(""requestHeadersStart"")
         .assertLogMatch(""requestHeadersEnd"")
         .assertLogMatch(""responseHeadersStart"")
         .assertLogMatch(
-            ""responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url="" + url + ""}"")
+            ""responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url="" + url + ""\\}"")
         .assertLogMatch(""responseBodyStart"")
         .assertLogMatch(""responseBodyEnd: byteCount=0"")
         .assertLogMatch(""connectionReleased"")
@@ -257,10 +260,10 @@ public void testCacheEvents() {
     listener.satisfactionFailure(call, response);
 
     logRecorder
-        .assertLogMatch(""cacheConditionalHit: Response\\{protocol=h2, code=200, message=, url="" + url + ""}"")
-        .assertLogMatch(""cacheHit: Response\\{protocol=h2, code=200, message=, url="" + url + ""}"")
+        .assertLogMatch(""cacheConditionalHit: Response\\{protocol=h2, code=200, message=, url="" + url + ""\\}"")
+        .assertLogMatch(""cacheHit: Response\\{protocol=h2, code=200, message=, url="" + url + ""\\}"")
         .assertLogMatch(""cacheMiss"")
-        .assertLogMatch(""satisfactionFailure: Response\\{protocol=h2, code=200, message=, url="" + url + ""}"")
+        .assertLogMatch(""satisfactionFailure: Response\\{protocol=h2, code=200, message=, url="" + url + ""\\}"")
         .assertNoMoreLogs();
   }
 
@@ -16,7 +16,7 @@ dependencies {
 
   testImplementation project(':okhttp-testing-support')
   testImplementation project(':mockwebserver')
-  testRuntimeOnly project(':mockwebserver-junit5')
+  testImplementation project(':mockwebserver-junit5')
   testImplementation deps.junit
   testImplementation deps.assertj
   testCompileOnly deps.jsr305
@@ -19,6 +19,7 @@
 import javax.annotation.Nullable;
 import mockwebserver3.MockResponse;
 import mockwebserver3.MockWebServer;
+import mockwebserver3.junit5.internal.MockWebServerExtension;
 import okhttp3.OkHttpClient;
 import okhttp3.OkHttpClientTestRule;
 import okhttp3.Request;
@@ -28,10 +29,12 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+@ExtendWith(MockWebServerExtension.class)
 public final class EventSourceHttpTest {
   @RegisterExtension public final PlatformRule platform = new PlatformRule();
 
",True,"The commit message refers to the addition of Android tests, which is a common practice to ensure the functionality of the code. The code diff shows that the tests are being added to the project, which includes checking for cleartext traffic and logging levels. This suggests that the changes are being made to improve the testing coverage and reliability of the project.",True,"The commit message 'Android Additional Tests' does not explicitly describe the necessity of the changes. However, the changes made to the build.gradle file and the addition of new test files suggest that the commit is adding additional tests to the project. This is a common practice in software development and does not require an explicit explanation in the commit message.",True,"The commit message does not explicitly describe the necessity of changes, but the code diff does. The added code checks if the tests are running in an IDE and if so, it adds additional test sources to the androidTest source set. This could be done to ensure that certain tests are only run when the project is being developed in an IDE, which could be a necessary change to improve the development experience or to ensure that all tests are run when the project is built.",True,"The commit message 'Android Additional Tests' does not explicitly describe the necessity of changes. However, the code diff indicates that changes were made to the Android test configuration. Specifically, additional tests were added for the okhttp-brotli, okhttp-dnsoverhttps, okhttp-logging-interceptor, and okhttp-sse projects. This suggests that the changes were made to accommodate new requirements or features, which could be due to user needs or changes in the software development process.",True,"The commit message mentions the addition of additional tests, and the code diff shows that it includes changes to the build configuration to include new dependencies for these tests. Additionally, the diff shows that the commit adds new code to determine if the IDE is being used, and if not, it adds additional source directories to the 'androidTest' source set. This suggests that the change is related to improving the testing infrastructure for the Android project, which could include fixing defects or improving code quality.",True,"The commit message 'Android Additional Tests' does contain an expression that describes a summary of what changes by being a summary of the diffs. The diff shows the addition of code that checks if the IDE is being used, and if not, it adds additional test dependencies and configurations. This is a clear summary of the changes made in the code.",False,"The commit message does not explicitly describe a technical principle underpinning the changes. It mainly mentions adding tests and modifying dependencies. While the changes might be based on a principle, such as modularizing tests or improving test coverage, the message does not explicitly state this.",True,"The commit message 'Android Additional Tests' does not explicitly describe the changes made to the code, but the code diff reveals several significant additions and modifications. For instance, a new function 'isIDE' is added to check if the code is being run from an IDE. Additionally, the build.gradle file has been updated to include new dependencies and source sets for additional tests. Furthermore, the code diff shows that several tests have been disabled due to cleartext requirements or logging issues. These changes introduce new behaviors and expand the test coverage of the project, which is described in the code changes.",False,"The commit message does not provide an explanation for the changes made. While the changes are not complex, they are significant as they add new dependencies, modify test configurations, and introduce new conditions for tests. Therefore, a commit message that explains these changes would be beneficial for understanding the purpose and impact of the commit."
